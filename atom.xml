<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-17T02:33:22.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mach-o文件结构理解</title>
    <link href="http://yoursite.com/wiki/IOS%20/Mach_O/Mach_O_File_Struct/"/>
    <id>http://yoursite.com/wiki/IOS /Mach_O/Mach_O_File_Struct/</id>
    <published>2018-05-16T04:07:12.000Z</published>
    <updated>2018-05-17T02:33:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：</p><ol><li>有助于理解崩溃日志解析的原理。理解KSCrash源码；</li><li>有助于理解开源代码fishhook的原理；</li><li>有助于理解腾讯OOMDetector开源库源码；</li><li>好处应该不止这些。</li></ol><a id="more"></a><p>它的组成结构如下图所示，包括了Header、Load commands、Data（包含Segement的具体数据）。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/mach-o-overall_small.jpg" alt="mach-o 文件结构"></p><p>这张图片说明了几点：</p><ol><li>mach-o由三部分构成，header、Load Commands、Data区域。</li><li>commond指定了各种数据在Data区域的位置。 可以将header比喻为文章的摘要，Load Commands为文章的目录、Data是文章的正文。 目录的特点是可以定位内容在文章的位置。Load Commands其实就是这个作用。</li><li>每个segment下面可以有一个或多个section。 可以理解为一级目录下的子二级目录~~。</li></ol><p>也可以从另外角度认识Mach-O结构，如图所示。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_O_new_overall_small.png" alt="mach-o 内部详细结构"></p><p>这张图表达了更多的细节信息：</p><ol><li>segment 的类型有__TEXT(程序的代码区域，只读) 、__DATA(程序的数据区域，可读写)</li><li>__DATA segment 后面跟随着多个section，包括__nl__symbol_ptr （not layz符号）__la__symbol_ptr</li></ol><p>下面来聊聊Header部分</p><h2 id="mach-header"><a href="#mach-header" class="headerlink" title="mach-header"></a>mach-header</h2><p>mach-header 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>magic;<span class="comment">/* mach magic number identifier */</span></span><br><span class="line"><span class="keyword">cpu_type_t</span>cputype;<span class="comment">/* cpu specifier */</span></span><br><span class="line"><span class="keyword">cpu_subtype_t</span>cpusubtype;<span class="comment">/* machine specifier */</span></span><br><span class="line"><span class="keyword">uint32_t</span>filetype;<span class="comment">/* type of file */</span></span><br><span class="line"><span class="keyword">uint32_t</span>ncmds;<span class="comment">/* number of load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>sizeofcmds;<span class="comment">/* the size of all the load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>magic：魔数，用于快速确认该文件的种类（用于64位还是32位）。可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64 0xcffaedfe <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></span><br></pre></td></tr></table></figure><ul><li>cputype：CPU类型，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386CPU_TYPE_X86  <span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>CPU_TYPE_X86_64(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM((cpu_type_t) 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br></pre></td></tr></table></figure><ul><li>cpusubtype：对应的具体类型，比如arm64、armv7，可取值（部分）如下：</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_SUBTYPE_X86_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_X86_64_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7((<span class="name">cpu_subtype_t</span>) <span class="number">9</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7S((<span class="name">cpu_subtype_t</span>) <span class="number">11</span>) /* Swift */</span><br></pre></td></tr></table></figure><ul><li>filetype：文件类型，比如可执行文件、库文件、Dsym文件，例如：MH_EXECUTE值是2，代表可执行文件，可取值如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * Constants <span class="keyword">for</span> the filetype field of the mach_header</span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_OBJECT   0x1     <span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_EXECUTE  0x2     <span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FVMLIB   0x3     <span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CORE     0x4     <span class="comment">/* core file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PRELOAD  0x5     <span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB    0x6     <span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLINKER 0x7     <span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BUNDLE   0x8     <span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB_STUB   0x9     <span class="comment">/* shared library stub for static */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DSYM     0xa     <span class="comment">/* companion file with only debug */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_KEXT_BUNDLE  0xb     <span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure><ul><li>ncmds ：加载命令条数</li><li>sizeofcmds：所有加载命令的大小</li><li>reserved：保留字段</li><li>flags：标志位，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK0x4<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="meta"><span class="comment">   dynamic linker and can't be staticly</span></span></span><br><span class="line"><span class="meta"><span class="comment">   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBOUND0x10<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">   references prebound. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS0x20<span class="comment">/* the file has its read-only and</span></span></span><br><span class="line"><span class="meta"><span class="comment">   read-write segments split */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL0x80<span class="comment">/* the image is using two-level name</span></span></span><br><span class="line"><span class="meta"><span class="comment">   space bindings */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOMULTIDEFS0x200<span class="comment">/* this umbrella guarantees no multiple</span></span></span><br><span class="line"><span class="meta"><span class="comment">   defintions of symbols in its</span></span></span><br><span class="line"><span class="meta"><span class="comment">   sub-images so the two-level namespace</span></span></span><br><span class="line"><span class="meta"><span class="comment">   hints can always be used. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CANONICAL    0x4000<span class="comment">/* the binary has been canonicalized</span></span></span><br><span class="line"><span class="meta"><span class="comment">   via the unprebind operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES0x8000<span class="comment">/* the final linked image contains</span></span></span><br><span class="line"><span class="meta"><span class="comment">   external weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000<span class="comment">/* the final linked image uses</span></span></span><br><span class="line"><span class="meta"><span class="comment">   weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_PIE 0x200000<span class="comment">/* When this bit is set, the OS will</span></span></span><br><span class="line"><span class="meta"><span class="comment">   load the main executable at a</span></span></span><br><span class="line"><span class="meta"><span class="comment">   random address.  Only used in</span></span></span><br><span class="line"><span class="meta"><span class="comment">   MH_EXECUTE filetypes. */</span></span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>下图是借用machoview查看header的结构：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/machview-header.png" alt="header 结构"></p><p>可以看出：</p><ol><li>该文件是可执行文件</li><li>文件的构架是x86_64</li><li>number of Load commands表示有74个load commond</li><li>MH_TWOLEVEL二级名字空间</li><li>MH_PIE 随机地址空间</li></ol><p>接下来介绍head后的load command部分。</p><h2 id="load-command"><a href="#load-command" class="headerlink" title="load command"></a>load command</h2><p>Load commands紧跟在头部之后，这些加载指令清晰地告诉加载器如何处理二进制数据，有些命令是由内核处理的，有些是由动态链接器处理的。在源码中有明显的注释来说明这些是动态连接器处理的。</p><p>这里列举几个看上去比较熟悉的….</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT0x1<span class="comment">/* segment of this file to be mapped  被映射到内存的段*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SYMTAB0x2<span class="comment">/* link-edit stab symbol table info  符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_DYSYMTAB0xb<span class="comment">/* dynamic link-edit symbol table info 动态符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_DYLIB0xc<span class="comment">/* load a dynamically linked shared library 动态链接库*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load a dynamically linked shared library that is allowed to be missing</span></span><br><span class="line"><span class="comment"> * (all symbols are weak imported).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT_640x19<span class="comment">/* 64-bit segment of this file to be</span></span></span><br><span class="line"><span class="meta"><span class="comment">   mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_UUID0x1b<span class="comment">/* the uuid */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_RPATH       (0x1c | LC_REQ_DYLD)    <span class="comment">/* runpath additions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_CODE_SIGNATURE 0x1d<span class="comment">/* local of code signature */</span></span></span><br></pre></td></tr></table></figure><p>load command的基本定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;       <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;   <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体只表示了所有的command都需要包含的属性—-命令类型和命令的大小。具体对于不同的命令都会有不同的定义。但是必须包含上面两个字段。</p><p>下面就来看具体的命令—LC_SEGMENT_64类型命令的定义。</p><h4 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The segment load command indicates <span class="keyword">that</span> a part <span class="keyword">of</span> this <span class="built_in">file</span> <span class="keyword">is</span> <span class="keyword">to</span> be</span><br><span class="line"> * mapped <span class="keyword">into</span> <span class="keyword">the</span> task's address <span class="literal">space</span>.  The size <span class="keyword">of</span> this segment <span class="keyword">in</span> memory,</span><br><span class="line"> * vmsize, maybe <span class="keyword">equal</span> <span class="keyword">to</span> <span class="keyword">or</span> larger than <span class="keyword">the</span> amount <span class="keyword">to</span> map <span class="keyword">from</span> this <span class="built_in">file</span>,</span><br><span class="line"> * filesize.  The <span class="built_in">file</span> <span class="keyword">is</span> mapped starting <span class="keyword">at</span> fileoff <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">beginning</span> <span class="keyword">of</span></span><br><span class="line"> * <span class="keyword">the</span> segment <span class="keyword">in</span> memory, vmaddr.  The <span class="built_in">rest</span> <span class="keyword">of</span> <span class="keyword">the</span> memory <span class="keyword">of</span> <span class="keyword">the</span> segment,</span><br><span class="line"> * <span class="keyword">if</span> any, <span class="keyword">is</span> allocated zero fill <span class="keyword">on</span> demand.  The segment's maximum virtual</span><br><span class="line"> * memory protection <span class="keyword">and</span> initial virtual memory protection are specified</span><br><span class="line"> * <span class="keyword">by</span> <span class="keyword">the</span> maxprot <span class="keyword">and</span> initprot fields.  If <span class="keyword">the</span> segment has sections <span class="keyword">then</span> <span class="keyword">the</span></span><br><span class="line"> * section structures directly follow <span class="keyword">the</span> segment command <span class="keyword">and</span> their size <span class="keyword">is</span></span><br><span class="line"> * reflected <span class="keyword">in</span> cmdsize.</span><br><span class="line">段加载命令指定了：文件需要映射到程序地址空间的某个部分。 </span><br><span class="line">段在内存中的大小用vmsize指定。内存中段的大小可能等于或大于文件大小（filesize），文件大小使用filesize指定。</span><br><span class="line">映射的源起始文件地址是fileoff，目的起始地址是vmaddr。内存中剩余的段内存用<span class="number">0</span>填充。</span><br><span class="line">段的最大内存权限和初始内存权限用maxprot、initprot字段指定。</span><br><span class="line">如果段有section，那么section的结构紧跟着段。section的大小包括在cmdsize字段中。</span><br><span class="line"> */</span><br><span class="line">struct segment_command &#123; /* <span class="keyword">for</span> <span class="number">32</span>-bit architectures */</span><br><span class="line">uint32_tcmd;/* LC_SEGMENT */</span><br><span class="line">uint32_tcmdsize;/* includes sizeof section structs */</span><br><span class="line">charsegname[<span class="number">16</span>];/* segment <span class="built_in">name</span> */</span><br><span class="line">uint32_tvmaddr;/* memory address <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tvmsize;/* memory size <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfileoff;/* <span class="built_in">file</span> <span class="built_in">offset</span> <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfilesize;/* amount <span class="keyword">to</span> map <span class="keyword">from</span> <span class="keyword">the</span> <span class="built_in">file</span> */</span><br><span class="line">vm_prot_tmaxprot;/* maximum VM protection */</span><br><span class="line">vm_prot_tinitprot;/* initial VM protection */</span><br><span class="line">uint32_tnsects;/* <span class="built_in">number</span> <span class="keyword">of</span> sections <span class="keyword">in</span> segment */</span><br><span class="line">uint32_tflags;/* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出segment_command包含了命令必须的属性cmd、cmdsize。剩下的属性是segment_command特有的属性。</p><p>下面是名称为_DATA的segment commond的截图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/DATA_Segment.png" alt="segement"></p><p>可以看出：</p><ol><li>命令类型是LC_SEGMENT_64</li><li>命令的大小1832</li><li>segment 命令的名称是__DATA</li><li>映射的内存地址是4360744960（十进制）</li><li>内存的大小12488704</li><li>文件的偏移量是65777664</li><li>需要映射的文件的大小10424320</li><li>最大内存保护权限：读写执行</li><li>初始内存权限：读写</li><li>这个端附属了22个 section，也就是说1832大小的segment_command包括了22个section命令的大小。</li><li>看的方法：offset代表文件的便宜量、Data表示内存地址中存储的值、description表示这段内存地址的名称的描述、value表示存储的值的可视描述。</li></ol><p>下面看看22个section的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/sections.png" alt="22sections"></p><p>下面讲解section的结构,section 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></span><br><span class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></span><br><span class="line"><span class="keyword">uint64_t</span>addr;<span class="comment">/* memory address of this section */</span></span><br><span class="line"><span class="keyword">uint64_t</span>size;<span class="comment">/* size in bytes of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>offset;<span class="comment">/* file offset of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>align;<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reloff;<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nreloc;<span class="comment">/* number of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved1;<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved2;<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved3;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图是__nl_symbol_ptr section 的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/nl_symbol_ptr_section.png" alt="nl_symbol_ptr_section"></p><p>可以看出：</p><ol><li>section的名称是__nl_symbol_ptr</li><li>该section所属的端的名称 _DATA 。段名称大写，section名称小写</li><li>内存地址4360744960</li><li>该section在内存中的大小是16</li><li>该section在物理文件的偏移量</li><li>内存对齐大小 8</li><li>间接符号索引是1198 （这里不太懂什么意思）</li></ol><p>另外一半segment 有四种，如图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/segment_types.png" alt="segment_types"></p><p>可以看出一半有<strong>PAGEZERO、</strong>TEXT、<strong>DATA、</strong>LINKEDIT。</p><h4 id="LC-SYMTAB"><a href="#LC-SYMTAB" class="headerlink" title="LC_SYMTAB"></a>LC_SYMTAB</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD</span></span><br><span class="line"><span class="comment"> * "stab" style symbol table information as described in the header files</span></span><br><span class="line"><span class="comment"> * &lt;nlist.h&gt; and &lt;stab.h&gt;.</span></span><br><span class="line"><span class="comment"> * symtab_command 包含了符号表、字符串索引表 的偏移量和大小 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_SYMTAB */</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct symtab_command) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>symoff;<span class="comment">/* symbol table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nsyms;<span class="comment">/* number of symbol table entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>stroff;<span class="comment">/* string table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>strsize;<span class="comment">/* string table size in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是LC_SYMTAB command示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/systab.png" alt="symbol table"></p><p>由表中可以看出</p><ol><li>命令的大小是24 （十进制）</li><li>符号表在物理文件的偏移量是 77360448</li><li>符号表的大小 1069179</li><li>String表的物理文件偏移量是94479244</li><li>string表的大小是22093264</li></ol><p>这个commond同时指定了两个表的位置信息。</p><p>符号表具体结构(这部分位于DATA区域，不属于load command，顺便讲下)定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Symbols with a index into the string table of zero (n_un.n_strx == 0) are</span></span><br><span class="line"><span class="comment"> * defined to have a null, "", name.  Therefore all string indexes to non null</span></span><br><span class="line"><span class="comment"> * names must not have a zero string index.  This is bit historical information</span></span><br><span class="line"><span class="comment"> * that has never been well documented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The n_type field really contains four fields:</span></span><br><span class="line"><span class="comment"> *unsigned char N_STAB:3,</span></span><br><span class="line"><span class="comment"> *      N_PEXT:1,</span></span><br><span class="line"><span class="comment"> *      N_TYPE:3,</span></span><br><span class="line"><span class="comment"> *      N_EXT:1;</span></span><br><span class="line"><span class="comment"> * which are used via the following masks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_STAB0xe0  <span class="comment">/* if any of these bits set, a symbolic debugging entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_PEXT0x10  <span class="comment">/* private external symbol bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_TYPE0x0e  <span class="comment">/* mask for the type bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_EXT0x01  <span class="comment">/* external symbol bit, set for external symbols */</span></span></span><br></pre></td></tr></table></figure><p>示意图如下：<br><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/system_detail.png" alt="symbol"></p><p>可以看出：</p><ol><li>String表的偏移量是0xbbff8, 翻译后是[GMRYouHaoHuoReq getRequestURL]</li><li>地址是0x100003300，意思如果[GMRYouHaoHuoReq getRequestURL]函数内部崩溃，那么崩溃日志中的地址就和0x100003300对应。</li></ol><p>下面看看String表的0xbbf8处是不是[GMRYouHaoHuoReq getRequestURL]，符号表的地址是0x049C6D40 加上偏移量0x000BBFB1 ，等于0x54d633d。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/stringtable.png" alt="string table"></p><p>可以看出string表的0x54d633d地址出就是：[GMRYouHaoHuoReq getRequestURL]。</p><h4 id="LC-UUID"><a href="#LC-UUID" class="headerlink" title="LC_UUID"></a>LC_UUID</h4><p>LC_UUID 用来标识唯一APP，命令的定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_UUID */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct uuid_command) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>uuid[<span class="number">16</span>];<span class="comment">/* the 128-bit uuid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/uuid.png" alt="uuid"></p><p>每个可执行程序都有一个uuid，这样根据不同的uuid能确定包。比如崩溃日志中就会包含uuid字段。表示是哪个包崩溃了。</p><h2 id="注意啦"><a href="#注意啦" class="headerlink" title="注意啦"></a>注意啦</h2><p>网上直接下载的MachOView经常崩溃，是由于有段代码没有做非空判断，所以为了有效使用MachOView，请从<a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">官网</a>下载代码，然后在崩溃的地方添加非空判断。就OK拉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h" rel="external nofollow noopener noreferrer" target="_blank">mach-o/loader.h</a></li><li><a href="https://www.jianshu.com/p/54d842db3f69" rel="external nofollow noopener noreferrer" target="_blank">趣探 Mach-O：文件格式分析</a></li><li><a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">MachOView 源码地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有助于理解崩溃日志解析的原理。理解KSCrash源码；&lt;/li&gt;
&lt;li&gt;有助于理解开源代码fishhook的原理；&lt;/li&gt;
&lt;li&gt;有助于理解腾讯OOMDetector开源库源码；&lt;/li&gt;
&lt;li&gt;好处应该不止这些。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="Mach-O" scheme="http://yoursite.com/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>iOS事件处理看我就够了(转载)</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/iOS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/wiki/IOS /事件处理/iOS事件处理/</id>
    <published>2018-04-27T04:07:12.000Z</published>
    <updated>2018-04-28T07:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.jianshu.com/p/b0884faae603" rel="external nofollow noopener noreferrer" target="_blank">iOS事件处理，看我就够了~</a></p><a id="more"></a><h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>UIResponder是iOS中用于处理用户事件的API，可以处理触摸事件、按压事件(3D touch)、远程控制事件、硬件运动事件。可以通过touchesBegan、pressesBegan、motionBegan、remoteControlReceivedWithEvent等方法，获取到对应的回调消息。UIResponder不只用来接收事件，还可以处理和传递对应的事件，如果当前响应者不能处理，则转发给其他合适的响应者处理。</p><p>应用程序通过响应者来接收和处理事件，响应者可以是继承自UIResponder的任何子类，例如UIView、UIViewController、UIApplication等。<font color="red">当事件来到时，系统会将事件传递给合适的响应者，并且将其成为第一响应者</font>。</p><p>第一响应者未处理的事件，将会在响应者链中进行传递，传递规则由UIResponder的nextResponder决定，可以通过重写该属性来决定传递规则。当一个事件到来时，第一响应者没有接收消息，则顺着响应者链向后传递。</p><h2 id="查找第一响应者"><a href="#查找第一响应者" class="headerlink" title="查找第一响应者"></a>查找第一响应者</h2><h4 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h4><p>查找第一响应者时，有两个非常关键的API，查找第一响应者就是通过不断调用子视图的这两个API完成的。</p><p>调用下面方法，获取到被点击的视图，也就是第一响应者。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(UIView *)</span>hitTest:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p>查找点击的视图。 内部会调用pointInside:withEvent方法。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>pointInside:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p>来判断点击区域是否在视图上，是则返回YES，不是则返回NO。</p><h4 id="查找第一响应者-1"><a href="#查找第一响应者-1" class="headerlink" title="查找第一响应者"></a>查找第一响应者</h4><p>应用程序接收到事件后，将事件交给keyWindow并转发给根视图，根视图按照视图层级逐级遍历子视图，并且遍历的过程中不断判断视图范围，并最终找到第一响应者。</p><p>从keyWindow开始，向前逐级遍历子视图，不断调用UIView的hitTest:withEvent:方法，通过该方法查找在点击区域中的视图后，并继续调用返回视图的子视图的hitTest:withEvent:方法，以此类推。如果子视图不在点击区域或没有子视图，则当前视图就是第一响应者。</p><p>在hitTest:withEvent:方法中，会从上到下遍历子视图，并调用subViews的pointInside:withEvent:方法，来找到点击区域内且最上面的子视图。如果找到子视图则调用其hitTest:withEvent:方法，并继续执行这个流程，以此类推。如果子视图不在点击区域内，则忽略这个视图及其子视图，继续遍历其他视图。</p><font color="blue">可以通过重写对应的方法，控制这个遍历过程。通过重写pointInside:withEvent:方法，来做自己的判断并返回YES或NO，返回点击区域是否在视图上。通过重写hitTest:withEvent:方法，返回被点击的视图</font>。<br><br>此方法在遍历视图时，忽略以下三种情况的视图，如果视图具有以下特征则忽略。但是视图的背景颜色是clearColor，并不在忽略范围内。<br><font color="red"><br><br>1.  视图的hidden等于YES。<br><br>2.  视图的alpha小于等于0.01。<br><br>3.  视图的userInteractionEnabled为NO。<br><br></font><br>如果点击事件是发生在视图外，但在其子视图内部，子视图也不能接收事件并成为第一响应者。这是因为在其父视图进行hitTest:withEvent:的过程中，就会将其忽略掉。<br><br>## 事件传递<br><br>#### 传递过程<br><br><u><br>1.  UIApplication接收到事件，将事件传递给keyWindow。<br><br>2.  keyWindow遍历subViews的hitTest:withEvent:方法，找到点击区域内合适的视图来处理事件。<br><br>3.  UIView的子视图也会遍历其subViews的hitTest:withEvent:方法，以此类推。<br><br>4.  直到找到点击区域内，且处于最上方的视图，将视图逐步返回给UIApplication。<br><br>5.  在查找第一响应者的过程中，已经形成了一个响应者链。<br><br>6.  应用程序会先调用第一响应者处理事件。<br><br>7.  如果第一响应者不能处理事件，则调用其nextResponder方法，一直找响应者链中能处理该事件的对象。<br><br>8.  最后到UIApplication后仍然没有能处理该事件的对象，则该事件被废弃。<br></u><br><br>模拟代码<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span> || <span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> inside = [<span class="keyword">self</span> pointInside:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (inside) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span>.subviews;</span><br><span class="line">        <span class="comment">// 对子视图从上向下找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = subViews.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">UIView</span> *subView = subViews[i];</span><br><span class="line">            <span class="built_in">CGPoint</span> insidePoint = [<span class="keyword">self</span> convertPoint:point toView:subView];</span><br><span class="line">            <span class="built_in">UIView</span> *hitView = [subView hitTest:insidePoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitView) &#123;</span><br><span class="line">                <span class="keyword">return</span> hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 示例<br><br><img src="http://of685p9vy.bkt.clouddn.com/enentChain/eventChain.png" alt="事件传递"><br><br>事件传递示例<br><br>如上图所示，响应者链如下：<br><br>1.  如果点击UITextField后其会成为第一响应者。<br><br>2.  如果textField未处理事件，则会将事件传递给下一级响应者链，也就是其父视图。<br><br>3.  父视图未处理事件则继续向下传递，也就是UIViewController的View。<br><br>4.  如果控制器的View未处理事件，则会交给控制器处理。<br><br>5.  控制器未处理则会交给UIWindow。<br><br>6.  然后会交给UIApplication。<br><br>7.  最后交给UIApplicationDelegate，如果其未处理则丢弃事件。<br><br><u>事件通过UITouch进行传递，在事件到来时，第一响应者会分配对应的UITouch，UITouch会一直跟随着第一响应者，并且根据当前事件的变化UITouch也会变化，当事件结束后则UITouch被释放。</u><br><br><font color="red">UIViewController没有hitTest:withEvent:方法，所以控制器不参与查找响应视图的过程。但是控制器在响应者链中，如果控制器的View不处理事件，会交给控制器来处理。控制器不处理的话，再交给View的下一级响应者处理。</font><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>在执行hitTest:withEvent:方法时，如果该视图是hidden等于NO的那三种被忽略的情况，则改视图返回nil。</p></li><li><p>如果当前视图在响应者链中，但其没有处理事件，则不考虑其兄弟视图，即使其兄弟视图和其都在点击范围内。</p></li><li><p>UIImageView的userInteractionEnabled默认为NO，如果想要UIImageView响应交互事件，将属性设置为YES即可响应事件。</p></li></ol><h2 id="事件控制"><a href="#事件控制" class="headerlink" title="事件控制"></a>事件控制</h2><h4 id="事件拦截"><a href="#事件拦截" class="headerlink" title="事件拦截"></a>事件拦截</h4><p>有时候想让指定视图来响应事件，不再向其子视图继续传递事件，可以通过重写hitTest:withEvent:方法。在执行到方法后，直接将该视图返回，而不再继续遍历子视图，这样响应者链的终端就是当前视图。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件转发"><a href="#事件转发" class="headerlink" title="事件转发"></a>事件转发</h4><p>在开发过程中，经常会遇到子视图显示范围超出父视图的情况，这时候可以重写该视图的pointInside:withEvent:方法，将点击区域扩大到能够覆盖所有子视图。</p><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/expend.png" alt="扩大响应区域"></p><p>扩大响应区域</p><p>假设有上面的视图结构，SuperView的Subview超出了其视图范围，如果点击Subview在父视图外面的部分，则不能响应事件。所以通过重写pointInside:withEvent:方法，将响应区域扩大为虚线区域，包含SuperView的所有子视图，即可让子视图响应事件。</p><h4 id="事件逐级传递"><a href="#事件逐级传递" class="headerlink" title="事件逐级传递"></a>事件逐级传递</h4><p>如果想让响应者链中，每一级UIResponder都可以响应事件，可以在每级UIResponder中都实现touches并调用super方法，即可实现响应者链事件逐级传递。</p><p><font color="red">只不过这并不包含UIControl子类以及UIGestureRecognizer的子类，这两类会直接打断响应者链</font>。</p><h2 id="Gesture-Recognizer"><a href="#Gesture-Recognizer" class="headerlink" title="Gesture Recognizer"></a>Gesture Recognizer</h2><p><strong>如果有事件到来时，视图有附加的手势识别器，则手势识别器优先处理事件。如果手势识别器没有处理事件，则将事件交给视图处理，视图如果未处理则顺着响应者链继续向后传递。</strong></p><p><img src="http://of685p9vy.bkt.clouddn.com/gesture.png" alt="手势识别"></p><p>手势识别</p><p>当响应者链和手势同时出现时，也就是既实现了touches方法又添加了手势，会发现touches方法有时会失效，这是因为手势的执行优先级是高于响应者链的。</p><p>事件到来后先会执行hitTest和pointInside操作，通过这两个方法找到第一响应者，这个在上面已经详细讲过了。当找到第一响应者并将其返回给UIApplication后，UIApplication会向第一响应者派发事件，并且遍历整个响应者链。如果响应者链中能够处理当前事件的手势，则将事件交给手势处理，并调用touches的cancelled方法将响应者链取消。</p><p><font color="red">在UIApplication向第一响应者派发事件，并且遍历响应者链查找手势时，会开始执行响应者链中的touches系列方法。</font>会先执行touchesBegan和touchesMoved方法，如果响应者链能够继续响应事件，则执行touchesEnded方法表示事件完成，如果将事件交给手势处理则调用touchesCancelled方法将响应者链打断。</p><p>根据苹果的官方文档，<u>手势不参与响应者链传递事件，但是也通过hitTest的方式查找响应的视图，手势和响应者链一样都需要通过hitTest方法来确定响应者链的。在UIApplication向响应者链派发消息时，只要响应者链中存在能够处理事件的手势，则手势响应事件，如果手势不在响应者链中则不能处理事件。</u></p><p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer" rel="external nofollow noopener noreferrer" target="_blank">Apple UIGestureRecognizer Documentation</a></p><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>根据上面的手势和响应者链的处理规则，我们会发现UIButton或者UISlider等控件，并不符合这个处理规则。UIButton可以在其父视图已经添加tapGestureRecognizer的情况下，依然正常响应事件，并且tap手势不响应。</p><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/btnStack.jpg" alt=""></p><p>UIControl</p><p>以UIButton为例，UIButton也是通过hitTest的方式查找第一响应者的。区别在于，<font color="red">如果UIButton是第一响应者，则直接由UIApplication派发事件，不通过Responder Chain派发。</font>如果其不能处理事件，则交给手势处理或响应者链传递。</p><p>不只UIButton是直接由UIApplication派发事件的，所有继承自UIControl的类，都是由UIApplication直接派发事件的。</p><p>[Apple UIControl Documentation][2]</p><h2 id="事件传递优先级"><a href="#事件传递优先级" class="headerlink" title="事件传递优先级"></a>事件传递优先级</h2><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>为了有依据的推断响应事件的实现和传递机制，我们做以下测试。</p><h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/example1.png" alt=""></p><p>示例1</p><p>假设RootView、SuperView、Button都实现touches方法，并且Button添加buttonAction:的action，点击button后的调用如下。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line"></span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> touchesBegan:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> touchesEnded:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> buttonAction:</span><br></pre></td></tr></table></figure><h6 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h6><p>还是上面的视图结构，我们给RootView加上UITapGestureRecognizer手势，并且通过tapAction:方法接收回调，点击上面的SuperView后，方法调用如下。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line"></span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizer:shouldReceivePress:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> touchesBegan:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizerShouldBegin:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> tapAction:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> touchesCancelled:</span><br></pre></td></tr></table></figure><h6 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h6><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/example2.png" alt=""></p><p>示例3</p><p>上面的视图中Subview1、Subview2、Subview3是同级视图，都是SuperView的子视图。我们给Subview1加上UITapGestureRecognizer手势，并且通过subView1Action:方法接收回调，点击上面的Subview3后，方法调用如下。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SuperView -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line"></span><br><span class="line">Subview3 -&gt; <span class="string">touchesBegan:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">touchesEnded:</span><span class="string">withEvent:</span></span><br></pre></td></tr></table></figure><p>通过上面的例子来看，虽然Subview1在Subview3的下面，并且添加了手势，点击区域是在Subview1和Subview3两个视图上的。但是由于经过hitTest和pointInside之后，响应者链中并没有Subview1，所以Subview1的手势并没有被响应。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>根据我们上面的测试，推断iOS响应事件的优先级，以及整体的响应逻辑。</p><p>当事件到来时，会通过hitTest和pointInside两个方法，从Window开始向上面的视图查找，找到第一响应者的视图。找到第一响应者后，系统会判断其是继承自UIControl还是UIResponder，如果是继承自UIControl，则直接通过UIApplication直接向其派发消息，并且不再向响应者链派发消息。</p><p>如果是继承自UIResponder的类，则调用第一响应者的touchesBegin，并且不会立即执行touchesEnded，而是调用之后顺着响应者链向后查找。如果在查找过程中，发现响应者链中有的视图添加了手势，则进入手势的代理方法中，如果代理方法返回可以响应这个事件，则将第一响应者的事件取消，并调用其touchesCanceled方法，然后由手势来响应事件。</p><p>如果手势不能处理事件，则交给第一响应者来处理。如果第一响应者也不能响应事件，则顺着响应者链继续向后查找，直到找到能够处理事件的UIResponder对象。如果找到UIApplication还没有对象响应事件的话，则将这次事件丢弃。</p><h3 id="接收事件深度剖析"><a href="#接收事件深度剖析" class="headerlink" title="接收事件深度剖析"></a>接收事件深度剖析</h3><p>在UIApplication接收到响应事件之前，还有更复杂的系统级的处理，处理流程大致如下。</p><ol><li><p>系统通过IOKit.framework来处理硬件操作，其中屏幕处理也通过IOKit完成(IOKit可能是注册监听了屏幕输出的端口) 当用户操作屏幕，IOKit收到屏幕操作，会将这次操作封装为IOHIDEvent对象。通过mach port(IPC进程间通信)将事件转发给SpringBoard来处理。</p></li><li><p>SpringBoard是iOS系统的桌面程序。SpringBoard收到mach port发过来的事件，唤醒main runloop来处理。 main runloop将事件交给source1处理，source1会调用__IOHIDEventSystemClientQueueCallback()函数。</p></li><li><p>函数内部会判断，是否有程序在前台显示，如果有则通过mach port将IOHIDEvent事件转发给这个程序。 如果前台没有程序在显示，则表明SpringBoard的桌面程序在前台显示，也就是用户在桌面进行了操作。 <strong>IOHIDEventSystemClientQueueCallback()函数会将事件交给source0处理，source0会调用</strong>UIApplicationHandleEventQueue()函数，函数内部会做具体的处理操作。</p></li><li><p>例如用户点击了某个应用程序的icon，会将这个程序启动。 应用程序接收到SpringBoard传来的消息，会唤醒main runloop并将这个消息交给source1处理，source1调用<strong>IOHIDEventSystemClientQueueCallback()函数，在函数内部会将事件交给source0处理，并调用source0的</strong>UIApplicationHandleEventQueue()函数。 在__UIApplicationHandleEventQueue()函数中，会将传递过来的IOHIDEvent转换为UIEvent对象。</p></li><li><p>在函数内部，调用UIApplication的sendEvent:方法，将UIEvent传递给第一响应者或UIControl对象处理，在UIEvent内部包含若干个UITouch对象。</p></li></ol><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h6><p>source1是runloop用来处理mach port传来的系统事件的，source0是用来处理用户事件的。 source1收到系统事件后，都会调用source0的函数，所以最终这些事件都是由source0处理的。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>在开发中，有时会有找到当前View对应的控制器的需求，这时候就可以利用我们上面所学，根据响应者链来找到最近的控制器。</p><p>在UIResponder中提供了nextResponder方法，通过这个方法可以找到当前响应环节的上一级响应对象。可以从当前UIView开始不断调用nextResponder，查找上一级响应者链的对象，就可以找到离自己最近的UIViewController。</p><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIViewController</span> *)parentController &#123;</span><br><span class="line">   <span class="built_in">UIResponder</span> *responder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">   <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([responder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</span><br><span class="line">       &#125;</span><br><span class="line">       responder = [responder nextResponder];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：刘小壮</p><p>链接：<a href="https://www.jianshu.com/p/b0884faae603" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b0884faae603</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://www.jianshu.com/p/b0884faae603&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;iOS事件处理，看我就够了~&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="事件处理" scheme="http://yoursite.com/categories/IOS/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
    
      <category term="事件处理" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>homebrew-gem使用.</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/ruby/homebrew-gem%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/wiki/工具/ruby/homebrew-gem使用/</id>
    <published>2018-04-23T04:07:12.000Z</published>
    <updated>2018-05-16T12:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用cocoapod更新repo会报下面错误：</p><p>Updating spec repo <code>master</code><br>[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down</p><p>经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。<a href="https://blog.github.com/2018-02-23-weak-cryptographic-standards-removed/" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。</p><p>解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。</p><a id="more"></a><h2 id="Homebrew介绍"><a href="#Homebrew介绍" class="headerlink" title="Homebrew介绍"></a>Homebrew介绍</h2><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。<br>援引官方的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew – OS X 不可或缺的套件管理器。</p><p>使用ruby安装Homebrew</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)”</span></span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/uninstall)"</span></span><br></pre></td></tr></table></figure><p>homebrew使用 </p><p>安装包 brew install <packagename></packagename></p><p>卸载包 brew uninstall <packagename></packagename></p><p>查询可用包 brew search <packagename></packagename></p><p>查看已经安装列表 brew list</p><p>查看任意包信息brew info <packagename></packagename></p><h2 id="ruby更新"><a href="#ruby更新" class="headerlink" title="ruby更新"></a>ruby更新</h2><p>使用brew安装ruby很方便，但缺点也是很明显的，不能实时进行版本的切换，所以还是用 brew + rvm 或brew + rbenv比较好，但是后面的这种方法我没有走通。所以我使用Homebrew更新ruby。</p><p>我们不去删除系统自带的ruby，gem，而是自己重新安装一套新的ruby，gem，通过更改PATH环境变量的方式来更新系统，</p><p>这样做好处比较安全的，不会破坏原有的苹果系统，又不耽误我使用最新的ruby。</p><h4 id="更新Home-brew"><a href="#更新Home-brew" class="headerlink" title="更新Home brew"></a>更新Home brew</h4><p>好了，开始吧</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>ruby</span><br></pre></td></tr></table></figure><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>系统原始版本的/usr/bin/ruby 我们并不删除，只是更改PATH环境变量，且将/usr/local/bin 添加到PATH的前面，这样系统就会首先用</p><p>/usr/local/bin下面找到我们用brew安装的ruby ruby 2.5.1p57(2018-03-29 revision 63029) [x86_64-darwin16]版本的了。</p><p>到自己目录下的.profile 或者 .bashrc 或者  .bash_profile    </p><p>用vim打开 （更改前请备份好这个文件，避免误操作）</p><p>在文件的末尾加入:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for brew install</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><p>然后重启终端，就可以用到了新的ruby了</p><p>检验一下</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">ruby <span class="number">2.5</span><span class="number">.1</span>p57 (<span class="number">2018</span><span class="number">-03</span><span class="number">-29</span> revision <span class="number">63029</span>) [x86_64-darwin16]</span><br><span class="line">$ which ruby</span><br><span class="line">/usr/local/bin/ruby               注意：系统的是 /usr/bin/ruby</span><br></pre></td></tr></table></figure><h4 id="gem的自我更新"><a href="#gem的自我更新" class="headerlink" title="gem的自我更新"></a>gem的自我更新</h4><p>gem是随着ruby的安装而安装的，所以路径和刚刚安装ruby的路径是相同过的，</p><p>此gem是自己安装路径中的gem (/usr/local/bin/gem)，不是系统的gem(/usr/bin/gem)，我们这里也不动系统的gem</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> gem</span></span><br><span class="line">/usr/local/bin/gem</span><br></pre></td></tr></table></figure><h2 id="gem-介绍"><a href="#gem-介绍" class="headerlink" title="gem 介绍"></a>gem 介绍</h2><p>Gem是一个管理Ruby库和程序的标准包，它通过<a href="http://rubygems.org/" rel="external nofollow noopener noreferrer" target="_blank">Ruby Gem</a>源来查找、安装、升级和卸载软件包，非常的便捷。</p><p>Ruby 1.9.2版本默认已安装Ruby Gem，如果你使用其它发行版本，请参考“如何安装Ruby Gem”。</p><p>Ruby gem包的安装方式：</p><p>所有的gem包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了Cache、doc、gems、specifications 4个目录，cache下放置下载的原生gem包，gems下则放置的是解压过的gem包。<br>当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的gem包，然后重新运行 gem install [gemname] 命令即可。</p><p>Ruby Gem命令详解：</p><p>//更新Gem自身<br>//注意：在某些linux发行版中为了系统稳定性此命令禁止执行<br>$ gem update –system</p><p>// 从Gem源安装gem包<br>$ gem install [gemname]</p><p>// 从本机安装gem包<br>$ gem install -l [gemname].gem</p><p>// 安装指定版本的gem包<br>$ gem install [gemname] –version=[ver]</p><p>// 更新所有已安装的gem包<br>$ gem update</p><p>// 更新指定的gem包<br>// 注意：gem update [gemname]不会升级旧版本的包，此时你可以使用 gem install [gemname] –version=[ver]代替<br>$ gem update [gemname]</p><p>// 删除指定的gem包，注意此命令将删除所有已安装的版本<br>$ gem uninstall [gemname]</p><p>// 删除某指定版本gem<br>$ gem uninstall [gemname] –version=[ver]</p><p>// 查看本机已安装的所有gem包<br>$ gem list [–local]</p><h2 id="解决无法连接到GitHub问题"><a href="#解决无法连接到GitHub问题" class="headerlink" title="解决无法连接到GitHub问题"></a>解决无法连接到GitHub问题</h2><p>通过下面的命令可以解决链接到Github失败的问题 ：</p><h4 id="升级openssl"><a href="#升级openssl" class="headerlink" title="升级openssl"></a>升级openssl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/opt/openssl/bin/openssl</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.0.2o  27 Mar 2018</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果openssl版本低，请使用Homebrew更新</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install openssl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew upgrade openssl</span></span><br><span class="line"></span><br><span class="line">`` If you need to have this software first in your PATH run: echo 'export PATH="/usr/local/opt/openssl/bin:$PATH"' &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/openssl/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/opt/openssl/bin/openssl</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.0.2n  7 Dec 2017</span><br></pre></td></tr></table></figure><h4 id="升级ruby"><a href="#升级ruby" class="headerlink" title="升级ruby"></a>升级ruby</h4><p>$ ruby –version<br>ruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-darwin16]</p><p>如果版本比较低，请参考ruby升级</p><h4 id="升级cocoapod"><a href="#升级cocoapod" class="headerlink" title="升级cocoapod"></a>升级cocoapod</h4><p>$ gem install cocoapods -n /usr/local/bin</p><p>$ which pod<br>/usr/local/bin/pod</p><p>$ pod –version<br>1.5.0</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/wks_lovewei/article/details/73369333" rel="external nofollow noopener noreferrer" target="_blank">mac系统用HomeBrew直接安装ruby</a></li><li><a href="https://stackoverflow.com/questions/38993527/cocoapods-failed-to-connect-to-github-to-update-the-cocoapods-specs-specs-repo" rel="external nofollow noopener noreferrer" target="_blank">Cocoapods: Failed to connect to GitHub to update the CocoaPods/Specs specs repo</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用cocoapod更新repo会报下面错误：&lt;/p&gt;
&lt;p&gt;Updating spec repo &lt;code&gt;master&lt;/code&gt;&lt;br&gt;[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down&lt;/p&gt;
&lt;p&gt;经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。&lt;a href=&quot;https://blog.github.com/2018-02-23-weak-cryptographic-standards-removed/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ruby" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/ruby/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>堆区（heap）和栈区（stack）的区别(转载)</title>
    <link href="http://yoursite.com/wiki/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/%E5%A0%86%E5%8C%BA%EF%BC%88heap%EF%BC%89%E5%92%8C%E6%A0%88%E5%8C%BA%EF%BC%88stack%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/</id>
    <published>2018-04-03T04:07:12.000Z</published>
    <updated>2018-05-16T12:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>（1）申请方式</p><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；</p><p>堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收；</p><p>（2）操作方式</p><p>栈区：操作方式类似于数据结构中的栈；</p><p>堆区：不同于数据结构中的堆，分配方式类似于链表。</p><p>（3）申请后系统的响应 </p><p>栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；</p><p>堆区：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 </p><p>（4）申请大小的限制</p><p>栈区：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p>堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>（5）申请效率的比较</p><p>栈区：系统自动分配，速度较快。但程序员是无法控制的。</p><p>堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. </p><p>注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。</p><p>（6）堆和栈中的存储内容</p><p>栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p>堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><p>参考资料</p><p><a href="https://blog.csdn.net/shanshanhi/article/details/50904706" rel="external nofollow noopener noreferrer" target="_blank">堆区（heap）和栈区（stack）的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;（1）申请方式&lt;/p&gt;
&lt;p&gt;栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；&lt;/p&gt;
&lt;p&gt;堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收；&lt;/p&gt;

      
    
    </summary>
    
      <category term="C语言语法" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="C 语言语法" scheme="http://yoursite.com/tags/C-%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>NSDateFormatter 时间格式</title>
    <link href="http://yoursite.com/wiki/IOS%20/foundation/NSDateFormatter%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS /foundation/NSDateFormatter时间格式/</id>
    <published>2018-03-22T07:35:49.000Z</published>
    <updated>2018-03-22T06:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间匹配格式"><a href="#时间匹配格式" class="headerlink" title="时间匹配格式"></a>时间匹配格式</h2><caption><a>Date Field Symbol Table</a></caption><table><thead><tr><th>Field</th><th>Sym.</th><th>No.</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>era</td><td>G</td><td>1..3</td><td>AD</td><td>Era - Replaced with the Era string for the current date. One to three letters for the abbreviated form, four letters for the long form, five for the narrow form.</td></tr><tr><td></td><td></td><td>4</td><td>Anno Domini</td></tr><tr><td></td><td></td><td>5</td><td>A</td></tr><tr><td>year</td><td>y</td><td>1..n</td><td>1996</td><td>Year. Normally the length specifies the padding, but for two letters it also specifies the maximum length. Example:</td></tr><tr><td></td><td>Y</td><td>1..n</td><td>1997</td><td>Year (in “Week of Year” based calendars). This year designation is used in ISO year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems where week date processing is desired. May not always be the same value as calendar year.</td></tr><tr><td></td><td>u</td><td>1..n</td><td>4601</td><td>Extended year. This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0.</td></tr><tr><td>quarter</td><td>Q</td><td>1..2</td><td>02</td><td>Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name.</td></tr><tr><td></td><td></td><td>3</td><td>Q2</td></tr><tr><td></td><td></td><td>4</td><td>2nd quarter</td></tr><tr><td></td><td>q</td><td>1..2</td><td>02</td><td><strong>Stand-Alone</strong> Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name.</td></tr><tr><td></td><td></td><td>3</td><td>Q2</td></tr><tr><td></td><td></td><td>4</td><td>2nd quarter</td></tr><tr><td>month</td><td>M</td><td>1..2</td><td>09</td><td>Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Sept</td></tr><tr><td></td><td></td><td>4</td><td>September</td></tr><tr><td></td><td></td><td>5</td><td>S</td></tr><tr><td></td><td>L</td><td>1..2</td><td>09</td><td><strong>Stand-Alone</strong> Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or 5 for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Sept</td></tr><tr><td></td><td></td><td>4</td><td>September</td></tr><tr><td></td><td></td><td>5</td><td>S</td></tr><tr><td></td><td>l</td><td>1</td><td>*</td><td>Special symbol for Chinese leap month, used in combination with M. Only used with the Chinese calendar.</td></tr><tr><td>week</td><td>w</td><td>1..2</td><td>27</td><td>Week of Year.</td></tr><tr><td></td><td>W</td><td>1</td><td>3</td><td>Week of Month</td></tr><tr><td>day</td><td>d</td><td>1..2</td><td>1</td><td>Date - Day of the month</td></tr><tr><td></td><td>D</td><td>1..3</td><td>345</td><td>Day of year</td></tr><tr><td></td><td>F</td><td>1</td><td>2</td><td>Day of Week in Month. The example is for the 2nd Wed in July</td></tr><tr><td></td><td>g</td><td>1..n</td><td>2451334</td><td>Modified Julian day. This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields.</td></tr><tr><td>week day</td><td>E</td><td>1..3</td><td>Tues</td><td>Day of week - Use one through three letters for the short day, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td></td><td>e</td><td>1..2</td><td>2</td><td>Local day of week. Same as E except adds a numeric value that will depend on the local starting day of the week, using one or two letters. For this example, Monday is the first day of the week.</td></tr><tr><td></td><td></td><td>3</td><td>Tues</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td></td><td>c</td><td>1</td><td>2</td><td><strong>Stand-Alone</strong> local day of week - Use one letter for the local numeric value (same as ‘e’), three for the short day, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Tues</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td>period</td><td>a</td><td>1</td><td>AM</td><td>AM or PM</td></tr><tr><td>hour</td><td>h</td><td>1..2</td><td>11</td><td>Hour [1-12].</td></tr><tr><td></td><td>H</td><td>1..2</td><td>13</td><td>Hour [0-23].</td></tr><tr><td></td><td>K</td><td>1..2</td><td>0</td><td>Hour [0-11].</td></tr><tr><td></td><td>k</td><td>1..2</td><td>24</td><td>Hour [1-24].</td></tr><tr><td></td><td>j</td><td>1..2</td><td>n/a</td><td>This is a special-purpose symbol. It must not occur in patterns, but is reserved for use in APIs doing flexible date pattern generation, and requests the preferred format (12 vs 24 hour) for the language in question.</td></tr><tr><td>minute</td><td>m</td><td>1..2</td><td>59</td><td>Minute. Use one or two for zero padding.</td></tr><tr><td>second</td><td>s</td><td>1..2</td><td>12</td><td>Second. Use one or two for zero padding.</td></tr><tr><td></td><td>S</td><td>1..n</td><td>3457</td><td>Fractional Second - rounds to the count of letters. (example is for 12.34567)</td></tr><tr><td></td><td>A</td><td>1..n</td><td>69540000</td><td>Milliseconds in day. This field behaves  <em>exactly</em>  like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value.</td></tr><tr><td>zone</td><td>z</td><td>1..3</td><td>PDT _fallbacks: _HPG-8:00 GMT-08:00</td><td>Timezone - with the s <em>pecific non-location format</em> . Where that is unavailable, falls back to  <em>localized GMT format</em> . Use one to three letters for the short format or four for the full format. In the short format, metazone names are not used unless the commonlyUsed flag is on in the locale.</td></tr><tr><td></td><td></td><td>4</td><td>Pacific Daylight Time <em>fallbacks:</em>  HPG-8:00 GMT-08:00</td></tr><tr><td></td><td>Z</td><td>1..3</td><td>-0800</td><td>Timezone - Use one to three letters for RFC 822 format, four letters for the localized GMT format.</td></tr><tr><td></td><td></td><td>4</td><td>HPG+8:00 <em>fallbacks:</em> GMT-08:00</td></tr><tr><td></td><td>v</td><td>1</td><td>PT</td><td>Timezone - with the  <em>generic</em>   <em>non-location format</em> . Where that is unavailable, uses special fallback rules given in  <em>[Appendix J][6]</em> . Use one letter for short format, four for long format.</td></tr><tr><td></td><td></td><td>4</td><td>Pacific Time <em>fallbacks:</em> Pacific Time (Canada) Pacific Time (Yellowknife) United States (Los Angeles) Time HPG-8:35 GMT-08:35</td></tr><tr><td></td><td>V</td><td>1</td><td>PST HPG-8:00 GMT-08:00</td><td>Timezone - with the same format as z, except that metazone timezone abbreviations are to be displayed if available, regardless of the value of commonlyUsed.</td></tr><tr><td></td><td></td><td>4</td><td>United States (Los Angeles) Time <em>fallbacks:</em>  HPG-8:35 MT-08:35</td><td>Timezone - with the  <em>generic</em>   <em>location format</em> . Where that is unavailable, falls back to the localized GMT format. (Fallback is only necessary with a GMT-style Timezone ID, like Etc/GMT-830.) This is especially useful when presenting possible timezone choices for user selection, since the naming is more uniform than the v format.</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://unicode.org/reports/tr35/tr35-10.html#Date_Format_Patternss" rel="external nofollow noopener noreferrer" target="_blank">UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间匹配格式&quot;&gt;&lt;a href=&quot;#时间匹配格式&quot; class=&quot;headerlink&quot; title=&quot;时间匹配格式&quot;&gt;&lt;/a&gt;时间匹配格式&lt;/h2&gt;&lt;caption&gt;&lt;a&gt;Date Field Symbol Table&lt;/a&gt;&lt;/caption&gt;

&lt;table
      
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="foundation" scheme="http://yoursite.com/categories/IOS/foundation/"/>
    
    
      <category term="NSDateFormatter" scheme="http://yoursite.com/tags/NSDateFormatter/"/>
    
  </entry>
  
  <entry>
    <title>正确使用NS_DESIGNATED_INITIALIZER</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/IOS /理论知识/指定初始化函数/</id>
    <published>2018-03-21T04:07:12.000Z</published>
    <updated>2018-04-28T06:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文结束了下指定初始化函数，本文完全转载自 <a href="https://blog.csdn.net/zcube/article/details/51657417" rel="external nofollow noopener noreferrer" target="_blank">正确使用NS_DESIGNATED_INITIALIZER</a> 。</p><h2 id="为什么会提到NS-DESIGNATED-INITIALIZER"><a href="#为什么会提到NS-DESIGNATED-INITIALIZER" class="headerlink" title="为什么会提到NS_DESIGNATED_INITIALIZER"></a>为什么会提到NS_DESIGNATED_INITIALIZER</h2><p>============================================================</p><p>最近在清理项目警告，遇到了“Method override for the designated initializer”的警告，全称为：</p><ul><li><p>Method override for the designated initializer of the superclass ‘-init’ not found 或者</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found。</p></li></ul><p>经排查是因为头文件中出现NS_DESIGNATED_INITIALIZER 声明的初始化方法，如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithPurchaseService:(<span class="type">HTLPrepayPurchaseService</span> *)service <span class="type">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p>如果用了NS_DESIGNATED_INITIALIZER，那么警告中出现init、initWithNibName或是其它，取决于你的继承的父类类型：</p><p>UIViewController</p><ul><li><p>Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found</p></li></ul><p>UIView</p><ul><li><p>Method override for the designated initializer of the superclass ‘-initWithFrame:’ not found</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found</p></li></ul><p>NSObject</p><ul><li>Method override for the designated initializer of the superclass ‘-init’ not found</li></ul><h2 id="正确使用NS-DESIGNATED-INITIALIZER"><a href="#正确使用NS-DESIGNATED-INITIALIZER" class="headerlink" title="正确使用NS_DESIGNATED_INITIALIZER"></a>正确使用NS_DESIGNATED_INITIALIZER</h2><h3 id="为什么要用NS-DESIGNATED-INITIALIZER"><a href="#为什么要用NS-DESIGNATED-INITIALIZER" class="headerlink" title="为什么要用NS_DESIGNATED_INITIALIZER"></a>为什么要用NS_DESIGNATED_INITIALIZER</h3><p>Objective-C 中主要通过NS_DESIGNATED_INITIALIZER宏来实现指定构造器的。这里之所以要用这个宏，往往是想<font color="red">告诉调用者要用这个方法去初始化（构造）类对象</font>。</p><h3 id="怎样避免使用NS-DESIGNATED-INITIALIZER产生的警告"><a href="#怎样避免使用NS-DESIGNATED-INITIALIZER产生的警告" class="headerlink" title="怎样避免使用NS_DESIGNATED_INITIALIZER产生的警告"></a>怎样避免使用NS_DESIGNATED_INITIALIZER产生的警告</h3><p>如果子类指定了新的初始化器，那么在这个初始化器内部必须调用父类的Designated Initializer。并且需要重写父类的Designated Initializer，将其指向子类新的初始化器。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> initWithName:<span class="string">@""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h3><p>如果定义NS_DESIGNATED_INITIALIZER，大多是不想让调用者调用父类的初始化函数，只希望通过该类指定的初始化进行初始化，这时候就可以用NS_UNAVAILABLE宏。</p><p>如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)init <span class="type">NS_UNAVAILABLE</span>;</span><br><span class="line">- (instance<span class="keyword">type</span>)initWithName:(<span class="type">NSString</span> *)name <span class="type">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p>如果调用者使用init 初始化，编译器就会给出一个编译错误。使用NS_UNAVAILABLE后，就不需要在.m中重写父类初始化函数了。如果要允许调用者使用init就需要在.m中重写父类的初始化函数，如上提到的，否则就会报警告。</p><h2 id="避免使用new"><a href="#避免使用new" class="headerlink" title="避免使用new"></a>避免使用new</h2><p>如果使用new来创建对象的话，即使init被声明为NS_UNAVAILABLE，也不会收到编译器的警告和错误提示了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="[http://stackoverflow.com/questions/26185239/ios-designated-initializers-using-ns-designated-initializer]">iOS Designated Initializers : Using NS_DESIGNATED_INITIALIZER</a>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文结束了下指定初始化函数，本文完全转载自 &lt;a href=&quot;https://blog.csdn.net/zcube/article/details/51657417&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;
      
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="理论知识" scheme="http://yoursite.com/categories/IOS/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="指定初始化函数" scheme="http://yoursite.com/tags/%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>工具下载地址</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/wiki/工具/工具下载地址/工具下载地址/</id>
    <published>2018-03-13T10:01:31.000Z</published>
    <updated>2018-03-22T06:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录常用工具下载地址</p><a id="more"></a><p><a href="http://xclient.info/s/cornerstone.html?_=74d8fe1bd364c1684fb6797602864a6a" rel="external nofollow noopener noreferrer" target="_blank">xclient</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录常用工具下载地址&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="工具下载地址" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>创建私有仓库</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-private-repo/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-private-repo/</id>
    <published>2018-03-01T06:50:54.000Z</published>
    <updated>2018-03-05T10:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 ‘官方仓库’、’私有仓库’。</p><ol><li><a href="https://github.com/CocoaPods/Specs.git" rel="external nofollow noopener noreferrer" target="_blank">官方仓库</a>的作用代表CocoaPods的官方podspec存放地址。 具体可以参考:<a href="https://github.com/CocoaPods/Specs" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods官方源</a>、<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" rel="external nofollow noopener noreferrer" target="_blank">Specs</a>; </li><li><a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">私有仓库</a>的是私有podspec存放地址。在git中仓库名称是LJRepo，clone到本地的别名是MyPrivateRepo。后文中私有仓库–LJRepo指的git地址，MyPrivateRepo指的是clone到本地的名称。</li></ol><a id="more"></a><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><p>仓库（Spec Repo） 是所有的Pods的一个索引，是所有公开\私有Pods的podspec文件仓库，其实就是一个部署在服务器的Git仓库，当你使用CocoaPods 后它会被Clone到本地的 ~/.cocoapods/repos 目录下。</p><p>首先在git上创建一个私有远端仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，步骤如下：</p><ol><li><p>在GitHub上创建私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，空的就可以。</p></li><li><p>将私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>添加到cocoapod中，远端私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a> 在本地中的别名是MyPrivateRepo，这样以后操作MyPrivateRepo就相当于操作<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>， 命令如下：</p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo <span class="keyword">add</span><span class="bash"> <span class="string">'MyPrivateRepo'</span> <span class="string">'git@github.com:jianli2017/LJRepo.git'</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这个Git 仓库地址要换成你自己的创建的 Specs git 地址！！！ 成功后会在~/.cocoapods/repos目录下就能看到MyPrivateRepo了，至此，第一步就完成了创建私有仓库。</p></blockquote><p>创建完成后，查看~/.cocoapods/repos 目录的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> 到~/.cocoapods/repos 目录</span></span><br><span class="line">cd ~/.cocoapods/repos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看目录结构</span></span><br><span class="line">tree -L 3</span><br></pre></td></tr></table></figure><p>大概的文件目录如下:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── MyPrivateRepo</span><br><span class="line">│   └── LJMenu</span><br><span class="line">│       └── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">└── master</span><br><span class="line">    ├── CocoaPods-version.yml</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── Specs</span><br><span class="line">        ├── <span class="number">0</span></span><br><span class="line">        ├── <span class="number">1</span></span><br><span class="line">        ├── <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中master就是官方的Sepc Repo,跟master同目录级别的MyPrivateRepo目录就是我自己创建的私有Sepc Repo。私有仓库中LJMenu是以前创建的，如果以前没有创建，MyPrivateRepo下面是空的。</p><p>也可以使用’pod repo list ‘ 命令查看仓库信息，结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  <span class="string">https:</span><span class="comment">//github.com/CocoaPods/Specs.git</span></span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/master</span><br><span class="line"></span><br><span class="line">MyPrivateRepo</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  git<span class="meta">@github</span>.<span class="string">com:</span>jianli2017/LJRepo.git</span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/MyPrivateRepo</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> repos</span><br></pre></td></tr></table></figure><p>小结</p><p>上面讲解了私有仓库的创建方法。创建完成后，从两个方面描述私有仓库，进一步认识私有创库：文件目录、pod命令</p><h2 id="创建LJMenu库"><a href="#创建LJMenu库" class="headerlink" title="创建LJMenu库"></a>创建<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a></h2><p>1.创建LJMenu库： 首先，在Git上创建一个<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu仓库</a>,当然你也是可以在公司内网创建的。 创建方法使用Cocoapods提供的一个<a href="http://guides.cocoapods.org/making/using-pod-lib-create" rel="external nofollow noopener noreferrer" target="_blank">Using Pod Lib Create</a> 工具。</p><p>在Terminal中执行cd命令，进入要创建项目的目录，执行以下命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod lib create [项目名]</span></span><br><span class="line">pod <span class="class"><span class="keyword">lib</span> <span class="title">create</span> <span class="title">LJMenu</span></span></span><br></pre></td></tr></table></figure><p>‘pod lib create’命令会在当前目录创建LJMenu项目，接着在Terminal控制台会输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cloning `<span class="keyword">https</span>://github.com/CocoaPods/pod-template.git` <span class="keyword">into</span> `LJMenu`.</span><br><span class="line">Configuring LJMenu template.</span><br><span class="line">Ignoring ffi<span class="number">-1.9</span><span class="number">.14</span> because its extensions are <span class="keyword">not</span> built.  Try: gem pristine ffi <span class="comment">--version 1.9.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"></span><br><span class="line">To <span class="built_in">get</span> you started we need <span class="built_in">to</span> ask <span class="keyword">a</span> few questions, this should only take <span class="keyword">a</span> minute.</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-02</span> <span class="number">13</span>:<span class="number">55</span>:<span class="number">04.386</span> defaults[<span class="number">30912</span>:<span class="number">784564</span>] </span><br><span class="line">The domain/default pair <span class="keyword">of</span> (org.cocoapods.pod-template, HasRunbefore) does <span class="keyword">not</span> exist</span><br><span class="line">If this is your <span class="keyword">first</span> <span class="built_in">time</span> we recommend running through <span class="keyword">with</span> <span class="keyword">the</span> guide: </span><br><span class="line"> - <span class="keyword">http</span>://guides.cocoapods.org/making/<span class="keyword">using</span>-pod-lib-<span class="built_in">create</span>.html</span><br><span class="line"> ( hold cmd <span class="keyword">and</span> double click links <span class="built_in">to</span> <span class="built_in">open</span> <span class="keyword">in</span> <span class="keyword">a</span> browser. )</span><br><span class="line"></span><br><span class="line"> Press <span class="literal">return</span> <span class="built_in">to</span> continue.</span><br></pre></td></tr></table></figure><p>选择回车按钮，接着会出现一系列的问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">What platform <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ iOS / macOS ]</span><br><span class="line"> &gt; ios</span><br><span class="line"></span><br><span class="line">What <span class="keyword">language</span> <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ Swift / ObjC ]</span><br><span class="line"> &gt; objc</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">include</span> a demo application <span class="keyword">with</span> your <span class="keyword">library</span>? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you <span class="keyword">use</span>? [ Specta / Kiwi / <span class="keyword">None</span> ]</span><br><span class="line"> &gt; specta</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">view</span> based testing? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">What <span class="keyword">is</span> your <span class="keyword">class</span> prefix?</span><br><span class="line"> &gt; LJ</span><br></pre></td></tr></table></figure><p>回答完问题后，会创建出LJMenu项目。结构如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">Example</span></span><br><span class="line">│   ├── LJMenu</span><br><span class="line">│   ├── LJMenu.xcodeproj</span><br><span class="line">│   ├── LJMenu.xcworkspace</span><br><span class="line">│   ├── Podfile</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LJMenu     **这个是创建的LJMenu项目**</span><br><span class="line">│   ├── Assets</span><br><span class="line">│   └── <span class="keyword">Classes</span></span><br><span class="line">├── LJMenu.podspec  </span><br><span class="line">├── README.md</span><br><span class="line">└── _Pods.xcodeproj -&gt; <span class="keyword">Example</span>/Pods/Pods.xcodeproj</span><br></pre></td></tr></table></figure><p>2、添加实现代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LJMenu</span><br><span class="line">├── Assets</span><br><span class="line">└── Classes</span><br><span class="line">    ├── LJMenu</span><br><span class="line">    │   ├── IFMMenu.h</span><br><span class="line">    │   ├── IFMMenu.m</span><br><span class="line">    │   ├── IFMMenuContainerView.h</span><br><span class="line">    │   ├── IFMMenuContainerView.m</span><br><span class="line">    │   ├── IFMMenuItem.h</span><br><span class="line">    │   ├── IFMMenuItem.m</span><br><span class="line">    │   ├── IFMMenuView.h</span><br><span class="line">    │   └── IFMMenuView.m</span><br><span class="line">    └── ReplaceMe.m</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">9</span> files</span><br></pre></td></tr></table></figure><p>在本教程中我在上面的Classes文件目录添加了 IFMMenu*.[h、m]八个文件。<br>3.开发模式下测试pod库的代码 打开Example工程目录Podfile文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">#pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../MyLib.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行 pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了 不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/MyLib中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。测试库文件没有问题,接着我们需要执行第4步。</p><p>4.提交<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a>到git上。 在Terminal中执行以下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'1.0.2'</span></span></span><br><span class="line"><span class="bash">git remote add origin git@github.com:jianli2017/LJMenu.git</span></span><br><span class="line"><span class="bash">git push origin master     <span class="comment">#提交到远端仓库</span></span></span><br><span class="line"><span class="bash">git tag -m <span class="string">"v1.0.2"</span> <span class="string">"v1.0.2"</span> <span class="comment">#打上标签，这个很重要</span></span></span><br><span class="line"><span class="bash">git push --tags     <span class="comment">#推送tag到远端仓库</span></span></span><br></pre></td></tr></table></figure><p>到这里，成功提交到远程仓库—<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a>，以后就可以使用git上的LJMenu库了。</p><h2 id="创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo"><a href="#创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo" class="headerlink" title="创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo"></a>创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo</h2><p>1.配置LJMenu库的podspec 文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint LJMenu.podspec' to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name             = <span class="string">'LJMenu'</span></span><br><span class="line">  s.version          = <span class="string">'1.0.2'</span></span><br><span class="line">  s.summary          = <span class="string">'A short description of LJMenu.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don't worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">TODO: Add long description of the pod here.</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage         = <span class="string">'https://github.com/jianli2017/LJMenu'</span></span><br><span class="line">  <span class="comment"># s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'</span></span><br><span class="line">  s.license          = &#123; <span class="symbol">:type</span> =&gt; <span class="string">'MIT'</span>, <span class="symbol">:file</span> =&gt; <span class="string">'LICENSE'</span> &#125;</span><br><span class="line">  s.author           = &#123; <span class="string">'jianli2017'</span> =&gt; <span class="string">'lijian-ds1@gomeplus.com'</span> &#125;</span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/jianli2017/LJMenu.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">'v1.0.2'</span>&#125;</span><br><span class="line">  <span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class="line"></span><br><span class="line">  s.ios.deployment_target = <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">'LJMenu/Classes/**/*'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   'LJMenu' =&gt; ['LJMenu/Assets/*.png']</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class="line">  <span class="comment"># s.frameworks = 'UIKit', 'MapKit'</span></span><br><span class="line">  <span class="comment"># s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>podspec更多配置请参考:<a href="http://guides.cocoapods.org/syntax/podspec.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></p><p>2.验证LJMenu.podspec</p><p>编辑完LJMenu.podspec文件后，需要验证一下这个LJMenu.podspec文件是否可用 ,在Terminal中执行cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint  <span class="comment">--allow-warnings</span></span><br></pre></td></tr></table></figure><p>当你看到 Terminal 中输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Analyzed <span class="number">1</span> podspec.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">LJMenu.podspec passed validation.</span></span><br></pre></td></tr></table></figure><p>表示这个LJMenu.podspec 验证通过，是一个符合CocoaPods规则的配置文件。</p><p>3.本地测试LJMenu.podspec文件 </p><p>打开Example工程目录Podfile文件修改下pod 的引用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pod <span class="string">'LJMenu'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">pod <span class="string">'LJMenu'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../LJMenu.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行pod install命令安装依赖，打开项目工程，现在可以看到库文件都被加载到Pods子项目中了</p><p>4.向Spec Repo提交podspec </p><p>测试库文件没有问题我们就把MyLib.podspec提交到远程Spec Repo仓库中，就是本文开头说的[官方仓库][13] 在Terminal中执行 cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pod repo push [Repo名] [podspec 文件名字]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pod repo push MyPrivateRepo ./LJMenu.podspec --allow-warnings</span></span><br></pre></td></tr></table></figure><p>如果提交成功，在Terminal会输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Validating spec</span><br><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Updating the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Already up-to-date.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Adding the spec to the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"> - [Update] LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Pushing the <span class="string">`MyPrivateRepo' repo</span></span></span><br></pre></td></tr></table></figure><p>表示提交成功了！这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/MySpecs目录下查看</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~<span class="regexp">/.cocoapods/repos</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">tree -L 3 MyPrivateRepo/</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPrivateRepo/</span><br><span class="line">└── LJMenu</span><br><span class="line">    ├── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">    │   └── LJMenu.podspec</span><br><span class="line">    └── <span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">        └── LJMenu.podspec</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>再去看我们的Spec Repo远端仓库 也就是[官方仓库][14]，也有了一次提交，这个podspec也已经被Push上去了。</p><p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了. 在Terminal中执行 pod search MyLib</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; LJMenu (<span class="number">1.0</span><span class="number">.2</span>)</span><br><span class="line">   A <span class="keyword">short</span> description of LJMenu.</span><br><span class="line">   pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu.git</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span><span class="number">.2</span>, <span class="number">1.0</span><span class="number">.1</span> [MyPrivateRepo repo]</span><br></pre></td></tr></table></figure><h2 id="使用制作好的Pod"><a href="#使用制作好的Pod" class="headerlink" title="使用制作好的Pod"></a>使用制作好的Pod</h2><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可, 在正式项目的Podfile 里添加私有Spec Repo</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#私有Spec Repo</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">source</span> <span class="string">'git<span class="variable">@github</span>.com:jianli2017/LJRepo.git'</span> </span><br><span class="line">source <span class="string">'git<span class="variable">@github</span>.com:CocoaPods/Specs.git'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br></pre></td></tr></table></figure><p>然后执行pod install，安装依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p><h2 id="将LJMenu发布到官方仓库中"><a href="#将LJMenu发布到官方仓库中" class="headerlink" title="将LJMenu发布到官方仓库中"></a>将LJMenu发布到官方仓库中</h2><h3 id="注册CocoaPods"><a href="#注册CocoaPods" class="headerlink" title="注册CocoaPods"></a>注册CocoaPods</h3><p>首先使用pod trunk me查看自己是否注册过：如果没有下面类似的内容输出,则表示没有注册过</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="symbol">Name:</span>     jianli2017</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Email:</span>    jianli2017@163.com</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Since:</span>    February <span class="number">28</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">01</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">Pods:</span>     None</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Sessions:</span></span></span><br><span class="line"><span class="ruby">- February <span class="number">28</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">01</span> - July <span class="number">6</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">04</span>. <span class="symbol">IP:</span> <span class="number">101.254</span>.<span class="number">248.194</span></span></span><br></pre></td></tr></table></figure><p>使用pod trunk register命令注册。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pod</span> <span class="selector-tag">trunk</span> <span class="selector-tag">register</span> <span class="selector-tag">jianli2017</span>@<span class="keyword">163</span>.<span class="keyword">com</span> <span class="string">'jianli2017'</span> --verbose</span><br></pre></td></tr></table></figure><p>注册完成后，使用下面的命令，将LJMenu库的spec推送到官方仓库中。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk <span class="built_in">push</span>  --allow-<span class="built_in">warnings</span></span><br></pre></td></tr></table></figure><p>推送完成后，可以使用pod search 查看。</p><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><h4 id="pod命令使用方法"><a href="#pod命令使用方法" class="headerlink" title="pod命令使用方法"></a>pod命令使用方法</h4><p>pod的命令如果不知道怎么用，可以使用pod –help命令查看使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod COMMAND</span><br><span class="line"></span><br><span class="line">CocoaPods, the Cocoa library package manager.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">cache</span>         Manipulate the CocoaPods <span class="keyword">cache</span></span><br><span class="line">+ deintegrate   Deintegrate CocoaPods <span class="keyword">from</span> your <span class="keyword">project</span></span><br><span class="line">+ env           Display pod environment</span><br><span class="line">+ init          Generate a Podfile <span class="keyword">for</span> the <span class="keyword">current</span> <span class="keyword">directory</span></span><br><span class="line">+ <span class="keyword">install</span>       <span class="keyword">Install</span> <span class="keyword">project</span> dependencies according <span class="keyword">to</span> <span class="keyword">versions</span> <span class="keyword">from</span> a</span><br><span class="line">Podfile.lock</span><br><span class="line">+ ipc           Inter-process communication</span><br><span class="line">+ lib           Develop pods</span><br><span class="line">+ <span class="keyword">list</span>          <span class="keyword">List</span> pods</span><br><span class="line">+ outdated      <span class="keyword">Show</span> outdated <span class="keyword">project</span> dependencies</span><br><span class="line">+ plugins       <span class="keyword">Show</span> available CocoaPods plugins</span><br><span class="line">+ repo          Manage spec-repositories</span><br><span class="line">+ <span class="keyword">search</span>        <span class="keyword">Search</span> <span class="keyword">for</span> pods</span><br><span class="line">+ setup         Setup the CocoaPods environment</span><br><span class="line">+ spec          Manage pod specs</span><br><span class="line">+ trunk         Interact <span class="keyword">with</span> the CocoaPods API (e.g. publishing <span class="keyword">new</span> specs)</span><br><span class="line">+ try           Try a Pod!</span><br><span class="line">+ <span class="keyword">update</span>        <span class="keyword">Update</span> outdated <span class="keyword">project</span> dependencies <span class="keyword">and</span> <span class="keyword">create</span> <span class="keyword">new</span> Podfile.lock</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"><span class="comment">--silent        Show nothing</span></span><br><span class="line"><span class="comment">--version       Show the version of the tool</span></span><br><span class="line"><span class="comment">--verbose       Show more debugging information</span></span><br><span class="line"><span class="comment">--no-ansi       Show output without ANSI codes</span></span><br><span class="line"><span class="comment">--help          Show help banner of specified command</span></span><br></pre></td></tr></table></figure><p>通过上面可以看到pod 的所有命令。常用的有pod init、pod install、 pod update、pod lib、pod repo等等，如果对pod repo不了解，可以使用pod repo –help进一步查看使用方法。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod repo [COMMAND]</span><br><span class="line"></span><br><span class="line">Manage spec-repositories</span><br><span class="line"></span><br><span class="line">Command<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">+ <span class="built_in">add</span>       Add <span class="keyword">a</span> spec repo</span><br><span class="line">+ lint      Validates <span class="keyword">all</span> specs in <span class="keyword">a</span> repo</span><br><span class="line">&gt; <span class="keyword">list</span>      List repos</span><br><span class="line">+ push      Push <span class="keyword">new</span> specifications <span class="keyword">to</span> <span class="keyword">a</span> spec-repo</span><br><span class="line">+ <span class="built_in">remove</span>    Remove <span class="keyword">a</span> spec repo</span><br><span class="line">+ <span class="keyword">update</span>    Update <span class="keyword">a</span> spec repo</span><br><span class="line"></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">--<span class="keyword">silent</span>    Show nothing</span><br><span class="line">--<span class="keyword">verbose</span>   Show more debugging information</span><br><span class="line">--<span class="keyword">no</span>-ansi   Show output without ANSI codes</span><br><span class="line">--<span class="keyword">help</span>      Show <span class="keyword">help</span> banner of specified <span class="keyword">command</span></span><br></pre></td></tr></table></figure><p>可以看出，pod repo add 、pod repo list 等命令，如果对pod repo list命令不知道如何使用，可以使用pod repo list –help命令进一步查看使用方法</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod repo list</span><br><span class="line"></span><br><span class="line">List <span class="keyword">the</span> repos <span class="built_in">from</span> <span class="keyword">the</span> <span class="built_in">local</span> spec-repos <span class="built_in">directory</span> <span class="keyword">at</span> `~/.cocoapods/repos/.`</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"><span class="comment">--count-only   Show the total number of repos</span></span><br><span class="line"><span class="comment">--silent       Show nothing</span></span><br><span class="line"><span class="comment">--verbose      Show more debugging information</span></span><br><span class="line"><span class="comment">--no-ansi      Show output without ANSI codes</span></span><br><span class="line"><span class="comment">--help         Show help banner of specified command</span></span><br></pre></td></tr></table></figure><p>上面的方法对任何的pod命令都使用，通过上面的方法我们可以学习会pod命令的使用方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://www.jianshu.com/p/107cc74847ab" rel="external nofollow noopener noreferrer" target="_blank">利用CocoaPods创建私有库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 ‘官方仓库’、’私有仓库’。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods/Specs.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方仓库&lt;/a&gt;的作用代表CocoaPods的官方podspec存放地址。 具体可以参考:&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods官方源&lt;/a&gt;、&lt;a href=&quot;http://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Specs&lt;/a&gt;; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jianli2017/LJRepo.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;私有仓库&lt;/a&gt;的是私有podspec存放地址。在git中仓库名称是LJRepo，clone到本地的别名是MyPrivateRepo。后文中私有仓库–LJRepo指的git地址，MyPrivateRepo指的是clone到本地的名称。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>图解SSH原理</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/SSH/ssh-theory/"/>
    <id>http://yoursite.com/wiki/工具/SSH/ssh-theory/</id>
    <published>2018-02-27T10:11:35.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于<a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></p><a id="more"></a><h2 id="初见SSH"><a href="#初见SSH" class="headerlink" title="初见SSH"></a>初见SSH</h2><blockquote><p>SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。</p></blockquote><h2 id="SSH工作原理"><a href="#SSH工作原理" class="headerlink" title="SSH工作原理"></a>SSH工作原理</h2><p>在讨论SSH的原理和使用前，我们需要分析一个问题：为什么需要SSH？</p><p>从第一节SSH的定义中可以看出，SSH和telnet、ftp等协议主要的区别在于安全性。这就引出下一个问题：如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种：</p><ol><li><p>对称加密（也称为秘钥加密）</p></li><li><p>非对称加密（也称公钥加密）</p></li></ol><p>所谓对称加密，指加密解密使用同一套秘钥。如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareEncrypt.png" alt="对称加密-Client端"></p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareDecrypt.png" alt="对称加密-Server端"></p><p>对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：如何安全的传输密钥、保存秘钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。</p><blockquote><p>两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。</p></blockquote><p>下面看下使用非对称加密方案的登录流程：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicEncrypt.png" alt="非对称加密登录流程"></p><ol><li><p>远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。</p></li><li><p>Client使用这个公钥，将密码进行加密。</p></li><li><p>Client将加密的密码发送给Server端。</p></li><li><p>远程Server用自己的私钥，解密登录密码，然后验证其合法性。</p></li><li><p>若验证结果，给Client相应的响应。</p></li></ol><blockquote><p>私钥是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。</p></blockquote><h4 id="这样就一定安全了吗？"><a href="#这样就一定安全了吗？" class="headerlink" title="这样就一定安全了吗？"></a>这样就一定安全了吗？</h4><p>上述流程会有一个问题：Client端如何保证接受到的公钥就是目标Server端的？，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？这就是所谓的[中间人攻击][2]</p><p><img src="//upload-images.jianshu.io/upload_images/2599999-da9359eb5fe05c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623" alt=""></p><p>图1-4：中间人攻击</p><h4 id="SSH中是如何解决这个问题的？"><a href="#SSH中是如何解决这个问题的？" class="headerlink" title="SSH中是如何解决这个问题的？"></a>SSH中是如何解决这个问题的？</h4><h5 id="基于口令的认证"><a href="#基于口令的认证" class="headerlink" title="基于口令的认证"></a>基于口令的认证</h5><p>从上面的描述可以看出，问题就在于如何对Server的公钥进行认证？在https中可以通过CA来进行公证，可是SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'ssh-server.example.com (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><blockquote><p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p></blockquote><p>如果输入yes后，会出现下面信息：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'ssh-server.example.com,12.18.429.21'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts. </span><br><span class="line">Password: (enter password)</span><br></pre></td></tr></table></figure><p>该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码，之后的流程就按照图1-3进行。</p><h5 id="2-基于公钥认证"><a href="#2-基于公钥认证" class="headerlink" title="2.基于公钥认证"></a>2.基于公钥认证</h5><p>在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicKeyAuthentication.png" alt="公钥认证流程"></p><ol><li><p>Client端用户TopGun将自己的公钥存放在Server上，追加在文件authorized_keys中。</p></li><li><p>Server收到登录请求后，随机生成一个字符串str1，并发送给Client。</p></li><li><p>Client用自己的私钥对字符串str1进行加密。</p></li><li><p>将加密后字符串发送给Server。</p></li><li><p>Server用之前存储的公钥进行解密，比较解密后的str2和str1。</p></li><li><p>根据比较结果，返回客户端登陆结果。</p></li></ol><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/GitHub-SSHKeys.png" alt="GitHub中SSH keys设置"></p><h2 id="SSH实践"><a href="#SSH实践" class="headerlink" title="SSH实践"></a>SSH实践</h2><h4 id="生成密钥操作"><a href="#生成密钥操作" class="headerlink" title="生成密钥操作"></a>生成密钥操作</h4><p>经过上面的原理分析，下面三行命令的含义应该很容易理解了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span> -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line">$ cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line">$ chmod <span class="number">0600</span> ~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure><p>ssh-keygen是用于生产密钥的工具。</p><ul><li><p>-t：指定生成密钥类型（rsa、dsa、ecdsa等）</p></li><li><p>-P：指定passphrase，用于确保私钥的安全</p></li><li><p>-f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）</p></li></ul><p>首先看下面~/.ssh中的四个文件：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/SHH-config.png" alt="SSH-涉及文件"></p><ol><li><p>id_rsa：保存私钥</p></li><li><p>id_rsa.pub：保存公钥</p></li><li><p>authorized_keys：保存已授权的客户端公钥</p></li><li><p>known_hosts：保存已认证的远程主机公钥</p></li></ol><p>四个角色的关系如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/ssh-struct.png" alt="SSH 结构简图"></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h6 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以用户名user，登录远程主机host</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地用户和远程用户相同，则用户名可省去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SSH默认端口22，可以用参数p修改端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2017 user@host</span></span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本文以图文方式对SSH原理进行解析（主要指远程登录，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于&lt;a href=&quot;https://www.jianshu.com/p/33461b619d53&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;图解SSH原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="SSH" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/SSH/"/>
    
    
  </entry>
  
  <entry>
    <title>Cocoapods-new-spec</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/Cocoapods-new-spec/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/Cocoapods-new-spec/</id>
    <published>2018-02-27T07:06:13.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>cocoapod学习 安装和使用（1）</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-learn-install/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-learn-install/</id>
    <published>2018-02-27T02:29:06.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a> Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在<a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a>的基础上稍微修改而来。<br><a id="more"></a></p><h2 id="什么是CocoaPods？"><a href="#什么是CocoaPods？" class="headerlink" title="什么是CocoaPods？"></a>什么是CocoaPods？</h2><p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a>是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要我们做太多的配置。直观、集中和自动化地管理项目的第三方库。</p><p>我们都有这样的经历，当添加第三方库的时候，需要导入一堆相关依赖库。当需要更新某个第三方库的时候，又需要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。</p><p>使用CocoaPods管理第三方库后，只需要相当少的配置，就可将第三方库集成到工程中，其它的一切都交由CocoaPods来管理即可，我们使用起来就更省心了。</p><h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>1.首先更新gem到最新版本，在终端中输入：sudo gem update –system更新gem</p><blockquote><p>Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 <a href="http://rubygems.org/" rel="external nofollow noopener noreferrer" target="_blank">http://rubygems.org/</a> ）源来查找、安装、升级和卸载软件包，非常的便捷。</p></blockquote><p>2.删除自带的ruby镜像，终端输入：<code>gem sources --remove https://rubygems.org/</code>。 </p><p>3.添加淘宝的镜像，终端输入：<code>gem sources -a https://gems.ruby-china.org/</code>(原来的淘宝镜像 <a href="https://ruby.taobao.org/已经不能用了)。" rel="external nofollow noopener noreferrer" target="_blank">https://ruby.taobao.org/已经不能用了)。</a> </p><p>4.可以用<code>gem sources -l</code>来检查使用替换镜像位置成功，结果应该只有 <code>https://gems.ruby-china.org/</code> 才对。</p><p>5.安装CocoaPods，终端输入：sudo gem install cocoapods。 </p><blockquote><p>如果提示Operation not permitted，执行sudo gem install -n /usr/local/bin cocoapods命令安装，原因请参考<a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">系统集成保护</a>。</p></blockquote><p>6.然后配置下CocoaPods，终端输入：pod setup。</p><p>到这里CocoaPods就安装好了。</p><h2 id="查找第三方库"><a href="#查找第三方库" class="headerlink" title="查找第三方库"></a>查找第三方库</h2><p>比如查找MJExtension，终端输入：<code>pod search MJExtension</code>，第一次搜索他需要建索引，等待一会儿就可以了。</p><p>输出结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-&gt; MJExtension (<span class="number">3.0</span><span class="meta">.13</span>)</span><br><span class="line">   A fast <span class="keyword">and</span> convenient conversion between JSON <span class="keyword">and</span> model</span><br><span class="line">   pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line">   - Homepage: https://github.com/CoderMJLee/MJExtension</span><br><span class="line">   - Source:   https://github.com/CoderMJLee/MJExtension.git</span><br><span class="line">   - Versions: <span class="number">3.0</span><span class="meta">.13</span>, <span class="number">3.0</span><span class="meta">.12</span>, <span class="number">3.0</span><span class="meta">.11</span>, <span class="number">3.0</span><span class="meta">.10</span>, <span class="number">3.0</span><span class="meta">.9</span>, <span class="number">3.0</span><span class="meta">.8</span>, <span class="number">3.0</span><span class="meta">.7</span>, <span class="number">3.0</span><span class="meta">.6</span>,</span><br><span class="line">   <span class="number">3.0</span><span class="meta">.5</span>, <span class="number">3.0</span><span class="meta">.4</span>, <span class="number">3.0</span><span class="meta">.3</span>, <span class="number">3.0</span><span class="meta">.2</span>, <span class="number">3.0</span><span class="meta">.0</span>, <span class="number">2.5</span><span class="meta">.16</span>, <span class="number">2.5</span><span class="meta">.15</span>, <span class="number">2.5</span><span class="meta">.14</span>, <span class="number">2.5</span><span class="meta">.13</span>, <span class="number">2.5</span><span class="meta">.12</span>,</span><br><span class="line">   <span class="number">2.5</span><span class="meta">.10</span>, <span class="number">2.5</span><span class="meta">.9</span>, <span class="number">2.5</span><span class="meta">.8</span>, <span class="number">2.5</span><span class="meta">.7</span>, <span class="number">2.5</span><span class="meta">.6</span>, <span class="number">2.5</span><span class="meta">.5</span>, <span class="number">2.5</span><span class="meta">.3</span>, <span class="number">2.5</span><span class="meta">.2</span>, <span class="number">2.5</span><span class="meta">.1</span>, <span class="number">2.5</span><span class="meta">.0</span>, <span class="number">2.4</span><span class="meta">.4</span>,</span><br><span class="line">   <span class="number">2.4</span><span class="meta">.2</span>, <span class="number">2.4</span><span class="meta">.1</span>, <span class="number">2.4</span><span class="meta">.0</span>, <span class="number">2.3</span><span class="meta">.8</span>, <span class="number">2.3</span><span class="meta">.7</span>, <span class="number">2.3</span><span class="meta">.6</span>, <span class="number">2.3</span><span class="meta">.5</span>, <span class="number">2.3</span><span class="meta">.4</span>, <span class="number">2.3</span><span class="meta">.3</span>, <span class="number">2.3</span><span class="meta">.2</span>, <span class="number">2.3</span><span class="meta">.1</span>,</span><br><span class="line">   <span class="number">2.3</span><span class="meta">.0</span>, <span class="number">2.2</span><span class="meta">.0</span>, <span class="number">2.1</span><span class="meta">.1</span>, <span class="number">2.1</span><span class="meta">.0</span>, <span class="number">2.0</span><span class="meta">.4</span>, <span class="number">2.0</span><span class="meta">.3</span>, <span class="number">2.0</span><span class="meta">.2</span>, <span class="number">2.0</span><span class="meta">.1</span>, <span class="number">2.0</span><span class="meta">.0</span>, <span class="number">1.2</span><span class="meta">.1</span>, <span class="number">1.2</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">1.1</span><span class="meta">.0</span>, <span class="number">1.0</span><span class="meta">.1</span>, <span class="number">1.0</span><span class="meta">.0</span>, <span class="number">0.3</span><span class="meta">.2</span>, <span class="number">0.3</span><span class="meta">.1</span>, <span class="number">0.3</span><span class="meta">.0</span>, <span class="number">0.2</span><span class="meta">.0</span>, <span class="number">0.1</span><span class="meta">.3</span>, <span class="number">0.1</span><span class="meta">.2</span>, <span class="number">0.1</span><span class="meta">.1</span>, <span class="number">0.1</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">0.0</span><span class="meta">.3</span>, <span class="number">0.0</span><span class="meta">.2</span>, <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br><span class="line"></span><br><span class="line">-&gt; MJExtension_HPTest (<span class="number">0.0</span><span class="meta">.1</span>)</span><br><span class="line">   花圃测试项目</span><br><span class="line">   pod <span class="string">'MJExtension_HPTest'</span>, <span class="string">'~&gt; 0.0.1'</span></span><br><span class="line">   - Homepage: https://github.com/LetMeCrazy/testPods</span><br><span class="line">   - Source:   https://github.com/LetMeCrazy/testPods.git</span><br><span class="line">   - Versions: <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br></pre></td></tr></table></figure><h2 id="引入第三方库到项目中"><a href="#引入第三方库到项目中" class="headerlink" title="引入第三方库到项目中"></a>引入第三方库到项目中</h2><p>我先在桌面上新建一个cocoapodUse项目，然后演示把MJExtension导进去。</p><p>2.然后生成并编辑一个<code>Podfile</code>文件，命令为:</p><p><code>vim Podfile</code></p><p>要导入的第三方都要写在Podfile中。进去后需要先按</p><p><code>I</code> 键进入编辑状态，写完后按<code>esc</code>，然后按<code>shift+zz</code>(或者先按<code>shift+:</code>,再按<code>wq</code>)就可以保存退出了。</p><p>Podfile的格式如下，其中’cocoapodUse’为你的target的名字。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios,<span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'cocoapodUse'</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>3.安装，命令为：</p><p><code>pod install</code></p><p>安装成功之后，第三方库就被包含到项目中了。</p><p>之前我们一直是双击Test.xcodeproj打开项目，以后我们就要双击Test.xcworkspace打开了，可以看到MJExtension已经被引入了。</p><h2 id="项目引入MJExtension"><a href="#项目引入MJExtension" class="headerlink" title="项目引入MJExtension"></a>项目引入MJExtension</h2><p>你会发现当引入MJExtension的头文件时，可以 <code>#import &lt;MJExtension.h&gt;</code>或者<code>#import &lt;MJExtension/MJExtension.h&gt;</code>，但是却不能在输入<code>#import &quot;MJExtension.h&quot;</code>的时候出现提示。虽然强制输入也可以编译通过，但是感觉很不爽。 解决这个问题的办法是在工程的Build Settings搜索Search，然后在User header search paths中添加$(SRCROOT)并选择recursive。</p><p>现在就可以提示#import “MJExtension.h”啦。</p><h2 id="增加新的第三方"><a href="#增加新的第三方" class="headerlink" title="增加新的第三方"></a>增加新的第三方</h2><p>如果使用过程中我还想添加其他的第三方怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。</p><h2 id="更新CocoaPods中的第三方库"><a href="#更新CocoaPods中的第三方库" class="headerlink" title="更新CocoaPods中的第三方库"></a>更新CocoaPods中的第三方库</h2><p>第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。</p><p>如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： pod install –verbose –no-repo-update </p><h2 id="删除CocoaPods中的某些第三方库。"><a href="#删除CocoaPods中的某些第三方库。" class="headerlink" title="删除CocoaPods中的某些第三方库。"></a>删除CocoaPods中的某些第三方库。</h2><p>当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。</p><h2 id="升级CocoaPods"><a href="#升级CocoaPods" class="headerlink" title="升级CocoaPods"></a>升级CocoaPods</h2><p>升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令sudo gem install -n /usr/local/bin cocoapods –pre就可以了。</p><h2 id="卸载CocoaPods"><a href="#卸载CocoaPods" class="headerlink" title="卸载CocoaPods"></a>卸载CocoaPods</h2><p>卸载CocoaPods的命令是sudo gem uninstall cocoapods</p><p>执行完命令后，最下面打印Successfully uninstalled cocoapods字样就代表已经成功卸载了。</p><h2 id="CocoaPods-Mac-App的安装和使用"><a href="#CocoaPods-Mac-App的安装和使用" class="headerlink" title="CocoaPods Mac App的安装和使用"></a>CocoaPods Mac App的安装和使用</h2><p>CocoaPods桌面应用版下载地址：[<a href="https://cocoapods.org/app][1" rel="external nofollow noopener noreferrer" target="_blank">https://cocoapods.org/app][1</a>] 打开应用会提示你是否安装命令行工具，选择install就也可以在命令行使用Pod了。省去了上面的步骤们，方便快捷的使用CocoaPods。</p><p>现在假如要给一个Test项目加入第三方库 1.选择File-New Podfile from Xcode Project，去选择项目的Project文件。</p><p>2.填写自动生成的Podfile，并且安装。</p><p>然后就可以去打开工程了，是不是比命令行简单多了。 </p><blockquote><p>注意：Cocoapods.app 删掉并执行命令可能会报错：Unable to locate the CocoaPods.app application bundle. Please ensure the application is available and launch it at least once<br>这时候只要执行sudo gem install -n /usr/local/bin cocoapods命令就可以了。</p></blockquote><h2 id="CocoaPods官方使用指南"><a href="#CocoaPods官方使用指南" class="headerlink" title="CocoaPods官方使用指南"></a>CocoaPods官方使用指南</h2><p>链接：<a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods 官方使用指南</a>有什么不了解的或者遇到错误可以去这里查看一下。</p><h2 id="XCode的CocoaPods插件"><a href="#XCode的CocoaPods插件" class="headerlink" title="XCode的CocoaPods插件"></a>XCode的CocoaPods插件</h2><p>[CocoaPods-xcode-plugin]是一个XCode的插件，可以很方便的在Xcode通过pods安装各种第三方库。前提是终端已经安装好CocoaPods。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a></li><li><a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">升级 OS X 10.11 cocoapods 使用不正常的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://guides.cocoapods.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods&lt;/a&gt; Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在&lt;a href=&quot;https://www.jianshu.com/p/1711e131987d&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;看一遍就会的CocoaPods的安装和使用教程&lt;/a&gt;的基础上稍微修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>自己搭建博客的经历</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/hexo/%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/wiki/工具/hexo/自己搭建博客的经历/</id>
    <published>2018-02-13T07:33:17.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。</p><a id="more"></a><h2 id="初始化hexo环境"><a href="#初始化hexo环境" class="headerlink" title="初始化hexo环境"></a>初始化hexo环境</h2><ul><li>新建博客的文件夹</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="string">/Desktop/jiangli2017</span> </span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/Desktop/jianli2017</span></span><br></pre></td></tr></table></figure><ul><li>初始化hexo</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><h2 id="Wikitten主题配置"><a href="#Wikitten主题配置" class="headerlink" title="Wikitten主题配置"></a>Wikitten主题配置</h2><p>本博客根据自己的喜好，选择的<a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">Wikitten</a>主题，这个主题类似wiki，具有文章的目录结构。</p><ul><li>进入你的 hexo 站点文件夹，克隆 <code>Wikitten</code> 主题到 <code>themes/</code> 路径下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/jiangli2017 </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten</span><br></pre></td></tr></table></figure><ul><li>覆盖站点目录中一些默认页面模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf themes/Wikitten/_source/* <span class="built_in">source</span>/</span><br><span class="line">cp -rf themes/Wikitten/_scaffolds/* scaffolds/</span><br></pre></td></tr></table></figure><ul><li>重命名主题中的 <code>_config.yml.example</code> 到 <code>_config.yml</code>，然后可以使用配置文件配置主题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml</span><br><span class="line"><span class="comment"># 编辑配置文件，定制你的配置项</span></span><br><span class="line">vim themes/Wikitten/_config.yml</span><br></pre></td></tr></table></figure><p>大部分的配置项都和 <a href="https://github.com/ppoffice/hexo-theme-icarus" rel="external nofollow noopener noreferrer" target="_blank">icarus</a> 主题中的配置项一样，你可以首先去阅读一下 <a href="https://github.com/ppoffice/hexo-theme-icarus/wiki" rel="external nofollow noopener noreferrer" target="_blank">icraus 的文档</a>。</p><ul><li>需要安装的插件写在主题的 <a href="./package.json"><code>package.json</code></a> 文件中</li></ul><p>这里列出了这些插件的功能作用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-autonofollow    // 打开非本站链接时自动开启新标签页</span><br><span class="line">hexo-directory-category // 根据文章文件目录自动为文章添加分类</span><br><span class="line">hexo-generator-feed    // 生成 RSS 源</span><br><span class="line">hexo-generator-json-content// 生成全站文章 json 内容，用于全文搜索</span><br><span class="line">hexo-generator-sitemap// 生成全站站点地图 sitemap</span><br></pre></td></tr></table></figure><p>你可以将这些插件合并到<strong>站点</strong>的 <code>package.json</code> 文件中通过 <code>npm install</code> 一次安装，</p><p>或者在<strong>站点目录</strong>下，你可以通过以下命令安装他们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><p>下面是站点推荐配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yaml</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">wiki/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">Wikitten</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'_posts/**/embed_page/**'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Markdown</span></span><br><span class="line"><span class="comment">## https://github.com/hexojs/hexo-renderer-marked</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line"><span class="attr">  gfm:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### JsonContent</span></span><br><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  pages:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">404.</span><span class="string">html</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">### Creat sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Adds nofollow attribute to all external links in your hexo blog posts automatically.</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&lt;your</span> <span class="string">site</span> <span class="string">url</span> <span class="string">domain&gt;</span> <span class="comment"># eg: zthxxx.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment（发布git）</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 多级目录结构</span></span><br><span class="line"><span class="attr">auto_dir_categorize:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span>  <span class="comment"># options:true, false; default is true</span></span><br><span class="line"><span class="attr">  force:</span> <span class="literal">true</span> <span class="comment"># options:true, false; default is false</span></span><br></pre></td></tr></table></figure><p>多级目录结构可以需要安装插件：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span> hexo-<span class="built_in">directory</span>-category</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>不能发布到git上面</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line"><span class="keyword">ERROR </span>Deployer not found: git</span><br></pre></td></tr></table></figure><p>解决办法：hexo目录下安装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span>  <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><ul><li>hexo d 没有反应</li></ul><p>需要在站点目录下的_config.yml 中添加如下配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><ul><li>图床</li></ul><p>我的博客中用相对目录显示图片，无法显示，需要用图床，我选择的是<a href="https://portal.qiniu.com" rel="external nofollow noopener noreferrer" target="_blank">七牛云</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>git时光穿梭(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%B7%A5%E4%BD%9C%E5%8C%BA/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git工作区/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><ul><li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li><li>第二步，使用命令git commit，完成。</li></ul><h2 id="工作区的状态"><a href="#工作区的状态" class="headerlink" title="工作区的状态"></a>工作区的状态</h2><ul><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向append GPL：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-head.jpg" alt="git-head"></p><p>改为指向add distributed：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-header-move.jpg" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><ol><li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li><li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li></ol><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-repo.jpg" alt="git-repo"></p><p>分支和HEAD的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br></pre></td></tr></table></figure><p>先用git status查看一下状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       LICENSE</span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   LICENSE</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage.jpg" alt="git-stage"></p><p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master <span class="number">27</span>c9860] understand how stage works</span><br><span class="line"> <span class="number">2</span> files <span class="section">changed</span>, <span class="number">675</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> LICENSE</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage-after-commit.jpg" alt="git-stage-after-commit"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</strong></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span>.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt </span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"git tracks changes"</span></span><br><span class="line">[<span class="keyword">master</span> d4f25b6] git tracks changes</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p><p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme<span class="selector-class">.txt</span> </span><br><span class="line">diff --git a/readme<span class="selector-class">.txt</span> b/readme.txt</span><br><span class="line">index <span class="number">76</span>d770f.<span class="selector-class">.a9c5755</span> <span class="number">100644</span></span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">4</span> @@</span><br><span class="line"> Git is <span class="selector-tag">a</span> distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has <span class="selector-tag">a</span> mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>现在，看看readme.txt的文件内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">add</span> readme.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> readme.txt</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure><p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退][1]一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退][2]一节，不过前提是没有推送到远程库。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add test.txt"</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">94</span>cdc44] <span class="keyword">add</span> test.txt</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm test.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       deleted:    test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line"><span class="keyword">rm</span> '<span class="keyword">test</span>.txt'</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">"remove test.txt"</span></span><br><span class="line">[master d17efd8] remove <span class="keyword">test</span>.txt</span><br><span class="line"> 1 <span class="keyword">file</span> changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git分支管理/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h2><p>在[版本回退][1]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。<strong>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-initial.png" alt="git-br-initial"></p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p><p><strong>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</strong></p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-create.png" alt="git-br-create"></p><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-fd.png" alt="git-br-dev-fd"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-ff-merge.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-remove.png" alt="git-br-rm"></p><p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p><p>下面开始实战。</p><p><strong>首先，我们创建dev分支，然后切换到dev分支：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> dev</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* dev</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"branch test"</span></span></span><br><span class="line">[dev fec145a] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-on-master.png" alt="git-br-on-master"></p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge dev</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was fec145a).</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch dev</p><p>切换分支：git checkout </p><p>创建+切换分支：git checkout -b </p><p>合并某分支到当前分支：git merge </p><p>删除分支：git branch -d </p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的feature1分支，继续我们的新分支开发：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> feature1</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">AND</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 75a857c] <span class="keyword">AND</span> simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">1</span> commit.</span><br></pre></td></tr></table></figure><p>在master分支上把readme.txt文件的最后一行改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 400b400] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-feature1.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> feature1</span><br><span class="line"><span class="keyword">Auto</span>-merging readme.txt</span><br><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> readme.txt</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unmerged paths:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> as appropriate to mark resolution)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       both modified:      readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">and</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"conflict fixed"</span></span></span><br><span class="line">[master 59bc1cb] conflict fixed</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-conflict-merged.png" alt="git-br-conflict-merged"></p><p>用带参数的git log也可以看到分支的合并情况：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 75a857c <span class="keyword">AND</span> simple</span><br><span class="line">* | 400b400 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* fec145a branch test</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d feature1</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>feature1 (was <span class="number">75</span>a857c).</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>用git log –graph命令可以看到分支合并图。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working <span class="built_in">directory</span> <span class="keyword">and</span> index state WIP <span class="keyword">on</span> <span class="title">dev</span>: <span class="title">6224937</span> <span class="title">add</span> <span class="title">merge</span></span><br><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">6224937</span> <span class="built_in">add</span> <span class="built_in">merge</span></span><br></pre></td></tr></table></figure><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">6</span> commits.</span><br><span class="line">$ git checkout -b issue<span class="number">-101</span></span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue<span class="number">-101</span> cc17032] fix bug <span class="number">101</span></span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">2</span> commits.</span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff -m "merged bug fix 101" issue-101</span></span><br><span class="line">Merge made <span class="keyword">by</span> <span class="keyword">the</span> <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> <span class="built_in">file</span> changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br><span class="line">$ git branch -d issue<span class="number">-101</span></span><br><span class="line">Deleted branch issue<span class="number">-101</span> (was cc17032).</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">list</span></span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP <span class="keyword">on</span> de<span class="variable">v:</span> <span class="number">6224937</span> <span class="built_in">add</span> merge</span><br></pre></td></tr></table></figure><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><h2 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h2><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用git remote：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> dev</span><br></pre></td></tr></table></figure><ul><li><p>master分支是主分支，因此要时刻与远程同步；</p></li><li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.<span class="string">com:</span>michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">46</span>, done.</span><br><span class="line"><span class="string">remote:</span> Compressing <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">26</span>/<span class="number">26</span>), done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">46</span> (delta <span class="number">16</span>), reused <span class="number">45</span> (delta <span class="number">15</span>)</span><br><span class="line">Receiving <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">46</span><span class="regexp">/46), 15.69 KiB | 6 KiB/</span>s, done.</span><br><span class="line">Resolving <span class="string">deltas:</span> <span class="number">100</span>% (<span class="number">16</span>/<span class="number">16</span>), done.</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add /usr/bin/env"</span></span><br><span class="line">[dev <span class="number">291</span>bea8] <span class="keyword">add</span> /usr/<span class="keyword">bin</span>/env</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">5</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">349</span> <span class="keyword">bytes</span>, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">   fc38031.<span class="number">.291</span>bea8  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.py </span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add coding: utf-8"</span></span><br><span class="line">[dev bd6ae48] <span class="keyword">add</span> coding: utf<span class="number">-8</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-<span class="keyword">fast</span>-forward)</span><br><span class="line"><span class="keyword">error</span>: <span class="keyword">failed</span> <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip <span class="keyword">of</span> your <span class="keyword">current</span> branch <span class="keyword">is</span> behind</span><br><span class="line">hint: its remote counterpart. <span class="keyword">Merge</span> the remote changes (e.g. <span class="string">'git pull'</span>)</span><br><span class="line">hint: <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line"><span class="keyword">From</span> github.com:michaelliao/learngit</span><br><span class="line">   fc38031<span class="built_in">..</span>291bea8  dev        -&gt; origin/dev</span><br><span class="line">There is <span class="literal">no</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">    git pull  </span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="builtin-name">set</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream dev origin/</span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br><span class="line">Branch <span class="built_in">dev</span> <span class="built_in">set</span> up to track remote branch <span class="built_in">dev</span> <span class="keyword">from</span> origin.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">CONFLICT (content): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> hello.py</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"merge &amp; fix hello.py"</span></span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">10</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100%</span> (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">Writing objects: <span class="number">100%</span> (<span class="number">6</span>/<span class="number">6</span>), <span class="number">747</span> bytes, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github<span class="selector-class">.com</span>:michaelliao/learngit.git</span><br><span class="line">   <span class="number">291</span>bea8.<span class="selector-class">.adca45d</span>  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p></li></ol><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  <span class="literal">master</span></span><br><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">6a5819e merged bug fix 101</span><br><span class="line">cc17032 fix bug 101</span><br><span class="line">7825a50 merge with no-ff</span><br><span class="line">6224937 <span class="builtin-name">add</span> merge</span><br><span class="line">59bc1cb conflict fixed</span><br><span class="line">400b400 &amp; simple</span><br><span class="line">75a857c <span class="keyword">AND</span> simple</span><br><span class="line">fec145a branch test</span><br><span class="line">d17efd8 <span class="builtin-name">remove</span> test.txt</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">9</span> <span class="number">6224937</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v0.<span class="number">9</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.9</span></span><br><span class="line"><span class="keyword">commit</span> <span class="number">622493706</span>ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">08</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">merge</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">1</span> -m <span class="string">"version 0.1 released"</span> <span class="number">3628164</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.<span class="number">1</span></span><br><span class="line"><span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">1</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">11</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">version</span> <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">3628164</span>fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Tue Aug <span class="number">20</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">49</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-s</span> v0.<span class="number">2</span> -m <span class="string">"signed version 0.2 released"</span> fec145a</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: signing failed: secret key not available</span><br><span class="line"><span class="keyword">error: </span>gpg failed to sign the data</span><br><span class="line"><span class="keyword">error: </span>unable to sign the tag</span><br></pre></td></tr></table></figure><p>用命令git show 可以看到PGP签名信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.2</span></span><br><span class="line">tag v0<span class="number">.2</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">33</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">signed <span class="keyword">version</span> <span class="number">0.2</span> released</span><br><span class="line"><span class="comment">-----BEGIN PGP SIGNATURE-----</span></span><br><span class="line"><span class="keyword">Version</span>: GnuPG v1<span class="number">.4</span><span class="number">.12</span> (Darwin)</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class="line"><span class="comment">-----END PGP SIGNATURE-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">10</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    branch <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p></li><li><p>git tag -a  -m “blablabla…”可以指定标签信息；</p></li><li><p>git tag -s  -m “blablabla…”可以用PGP签名标签；</p></li><li><p>命令git tag可以查看所有标签。</p></li></ul><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><ul><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git仓库/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。</p><a id="more"></a><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——[码云](<a href="https://gitee.com/）。" rel="external nofollow noopener noreferrer" target="_blank">https://gitee.com/）。</a></p><p>和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p>码云的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-add-ssh-key.jpg" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-key.jpg" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？</p><p>首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-new-repo.jpg" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令git remote add把它和码云的远程库关联：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><blockquote><p>小提示 ： origin 远程仓库也就是url对应的仓库 在本地的别名。</p></blockquote><p>如果在使用命令git remote add时报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，<font color="red">git给远程库起的默认名称是origin</font>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> github git@github.com:michaelliao/learngit.git</span></span><br></pre></td></tr></table></figure><p>接着，再关联码云的远程库：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>github master</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>gitee master</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorymulti-remote.jpg" alt="multi-remote"></p><p>码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。</p><blockquote><p>小贴士 ：git fetch 和git pull的区别</p><ul><li>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支</li><li>pull 若某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支</li></ul></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://git-scm.com/book/zh/v1/Git-基础-远程仓库的使用" rel="external nofollow noopener noreferrer" target="_blank">Git-基础-远程仓库的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用指南</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/hexo/hexo-use/"/>
    <id>http://yoursite.com/wiki/工具/hexo/hexo-use/</id>
    <published>2018-02-07T07:57:29.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC）</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n #写文章</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo d #部署 # 可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>安装Node.js</li><li>安装git（Xcode自带）</li><li>安装hexo</li></ul><p>hexo 是基于Node.js的静态博客程序，使用npm 安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><ul><li>首先注册一个『GitHub』帐号</li><li>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』</li><li>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』</li></ul><p>说明 git使用两种协议传输：https、git，如我的blog 的两种协议git地址如下：</p><p>git@github.com:jianli2017/jianli2017.github.io.git<br><a href="https://github.com/jianli2017/jianli2017.github.io.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jianli2017/jianli2017.github.io.git</a></p><p>SSH 作用于git协议，使用SSH 后，git协议的push、pull操作不需要输入密码。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>使用hexo init 命令在当前目录下初始化一个hexo项目</p><h1 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h1><p>cd 到你的init目录，执行如下命令，生成静态页面到 ./public/目录。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><h1 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h1><p>执行如下命令，启动本地服务，进行文章预览调试。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>执行new命令，生成指定名称的文章至hexo/source/_posts/postName.md。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [lay“<span class="keyword">out</span>] <span class="string">"postName"</span> <span class="meta">#新建文章</span></span><br></pre></td></tr></table></figure><p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line"><span class="keyword">tags:</span></span><br></pre></td></tr></table></figure><p>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。</p><p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">categories: </span><br><span class="line"><span class="keyword">tags:</span></span><br></pre></td></tr></table></figure><p>postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。</p><p>注意，所有文件：后面都必须有个空格，不然会报错。</p><p>看一下刚才生成的文件hexo/source/_posts/postName.md，内容如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中</span><br><span class="line">date: 2013<span class="string">-12</span><span class="string">-02</span> 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: #文章分类目录，可以为空，注意:后面有个空格</span><br><span class="line"><span class="keyword">tags:</span> #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格</span><br></pre></td></tr></table></figure><h1 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h1><p>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout: photo</span><br><span class="line">title: 我的阅历</span><br><span class="line">date: 2085<span class="string">-01</span><span class="string">-16</span> 07:33:44</span><br><span class="line"><span class="keyword">tags:</span> [hexo]</span><br><span class="line">photos:</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos<span class="string">-0</span>.jpg</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos<span class="string">-1</span>.jpg</span><br></pre></td></tr></table></figure><p>经过测试，文件头上的layout: photo可以省略。</p><p>不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layout: &#123; &#123; layout &#125; &#125;</span><br><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">photos:</span><br></pre></td></tr></table></figure><p>然后每次可以执行带layout的new命令生成照片文章：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">photo</span> <span class="string">"photoPostName"</span> <span class="meta">#新建照片文章</span></span><br></pre></td></tr></table></figure><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo你的博客</span><br><span class="line">date: 2013<span class="string">-11</span><span class="string">-22</span> 17:11:54</span><br><span class="line">categories: default</span><br><span class="line"><span class="keyword">tags:</span> [hexo]</span><br><span class="line">description: 你对本页的描述</span><br></pre></td></tr></table></figure><p>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。</p><h1 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h1><p>在需要显示摘要的地方添加如下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上是摘要</span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br><span class="line">以下是余下全文</span><br></pre></td></tr></table></figure><p>more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。</p><p>hexo中所有文件的编码格式均是UTF-8。</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>安装主题的方法就是一句git命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</span><br></pre></td></tr></table></figure><p>目录是否是modernist无所谓，只要与_config.yml文件一致即可。</p><p>安装完成后，打开hexo/_config.yml，修改主题为modernist</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">theme:</span> modernist</span><br></pre></td></tr></table></figure><p>打开hexo/themes/modernist目录，编辑主题配置文件_config.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span> <span class="comment">#配置页头显示哪些菜单</span></span><br><span class="line"><span class="comment">#  Home: /</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="attr">  Reading:</span> <span class="string">/reading</span></span><br><span class="line"><span class="attr">  About:</span> <span class="string">/about</span></span><br><span class="line"><span class="comment">#  Guestbook: /about</span></span><br><span class="line"><span class="attr">excerpt_link:</span> <span class="string">Read</span> <span class="string">More</span> <span class="comment">#摘要链接文字</span></span><br><span class="line"><span class="attr">archive_yearly:</span> <span class="literal">false</span> <span class="comment">#按年存档</span></span><br><span class="line"><span class="attr">widgets:</span> <span class="comment">#配置页脚显示哪些小挂件</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">category</span></span><br><span class="line"><span class="comment">#  - tag</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">tagcloud</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">recent_posts</span></span><br><span class="line"><span class="comment">#  - blogroll</span></span><br><span class="line"><span class="attr">blogrolls:</span> <span class="comment">#友情链接</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">duapp</span> <span class="attr">wordpress:</span> <span class="attr">http://ibruce.duapp.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="attr">javaeye:</span> <span class="attr">http://buru.iteye.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">oschina</span> <span class="attr">blog:</span> <span class="attr">http://my.oschina.net/buru</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">baidu</span> <span class="attr">space:</span> <span class="attr">http://hi.baidu.com/iburu</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span> <span class="comment">#是否开启fancybox效果</span></span><br><span class="line"><span class="attr">duoshuo_shortname:</span> <span class="string">buru</span> <span class="comment">#多说账号</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line"><span class="attr">rss:</span></span><br></pre></td></tr></table></figure><p>#更新</p><p>更新hexo：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> update -g hexo</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" rel="external nofollow noopener noreferrer" target="_blank">hexo你的博客</a></li><li><a href="http://blog.csdn.net/lemonxq/article/details/72676005" rel="external nofollow noopener noreferrer" target="_blank">Hexo静态博客搭建+个人定制</a></li><li><a href="https://www.jianshu.com/p/cea41e5c9b2a?open_source=weibo_search" rel="external nofollow noopener noreferrer" target="_blank">hexo搭建的Github博客绑定域名</a></li><li><a href="https://www.cnblogs.com/superGG1990/p/6844952.html" rel="external nofollow noopener noreferrer" target="_blank">初次安装git配置用户名和邮箱</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC）&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_semaphore 的使用方法</title>
    <link href="http://yoursite.com/wiki/IOS%20/GCD/use-dispatch-semaphore/"/>
    <id>http://yoursite.com/wiki/IOS /GCD/use-dispatch-semaphore/</id>
    <published>2017-02-11T07:35:49.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载请注明出处 <a href="http://www.cnblogs.com/snailHL/p/3906112.html" rel="external nofollow noopener noreferrer" target="_blank">关于dispatch_semaphore的使用</a>。<br>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。<br><a id="more"></a></p><p>下面我们逐一介绍三个函数：</p><h1 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a>dispatch_semaphore_create</h1><p>dispatch_semaphore_create的声明为：</p><pre><code>dispatch_semaphore_t  dispatch_semaphore_create(long value);</code></pre><p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p><h1 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h1><p>dispatch_semaphore_signal的声明为：</p><pre><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)</code></pre><p>这个函数会使传入的信号量dsema的值加1；</p><h1 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h1><p>dispatch_semaphore_wait的声明为：</p><pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</code></pre><p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>dispatch_semaphore_signal的返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。<br>dispatch_semaphore_wait的返回值也为long型。当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。当其返回不为0时，表示timeout发生。　　</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>在设置timeout时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。</p><pre><code>DISPATCH_TIME_NOW　　表示当前；DISPATCH_TIME_FOREVER　　表示遥远的未来；</code></pre><p>一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。利用创建dispatch_time创建dispatch_time_t类型变量的时候一般也会用到这两个变量。</p><p>dispatch_time的声明如下：</p><pre><code>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)；</code></pre><p>其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。例如：</p><pre><code>dispatch_time_t  t = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000);</code></pre><p>表示当前时间向后延时一秒为timeout的时间。</p><h1 id="关于信号量，一般可以用停车来比喻。"><a href="#关于信号量，一般可以用停车来比喻。" class="headerlink" title="关于信号量，一般可以用停车来比喻。"></a>关于信号量，一般可以用停车来比喻。</h1><p>停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），<br>调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>代码举简单示例如下：</p><pre><code>dispatch_semaphore_t signal;signal = dispatch_semaphore_create(1);__block long x = 0;NSLog(@&quot;0_x:%ld&quot;,x);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{sleep(1);NSLog(@&quot;waiting&quot;);x = dispatch_semaphore_signal(signal);NSLog(@&quot;1_x:%ld&quot;,x);sleep(2);NSLog(@&quot;waking&quot;);x = dispatch_semaphore_signal(signal);NSLog(@&quot;2_x:%ld&quot;,x);});//    dispatch_time_t duration = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); //超时1秒//    dispatch_semaphore_wait(signal, duration);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;3_x:%ld&quot;,x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;wait 2&quot;);NSLog(@&quot;4_x:%ld&quot;,x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;wait 3&quot;);NSLog(@&quot;5_x:%ld&quot;,x);</code></pre><p>最终打印的结果为：</p><pre><code>2014-08-11 22:51:54.734 LHTest[15700:70b] 0_x:02014-08-11 22:51:54.737 LHTest[15700:70b] 3_x:02014-08-11 22:51:55.738 LHTest[15700:f03] waiting2014-08-11 22:51:55.739 LHTest[15700:70b] wait 22014-08-11 22:51:55.739 LHTest[15700:f03] 1_x:12014-08-11 22:51:55.739 LHTest[15700:70b] 4_x:02014-08-11 22:51:57.741 LHTest[15700:f03] waking2014-08-11 22:51:57.742 LHTest[15700:f03] 2_x:12014-08-11 22:51:57.742 LHTest[15700:70b] wait 32014-08-11 22:51:57.742 LHTest[15700:70b] 5_x:0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请注明出处 &lt;a href=&quot;http://www.cnblogs.com/snailHL/p/3906112.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;关于dispatch_semaphore的使用&lt;/a&gt;。&lt;br&gt;dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。&lt;br&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="GCD" scheme="http://yoursite.com/categories/IOS/GCD/"/>
    
    
      <category term="dispatch_semaphore GCD" scheme="http://yoursite.com/tags/dispatch-semaphore-GCD/"/>
    
  </entry>
  
  <entry>
    <title>搭建weex断点调试环境</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/weex-debug/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/weex-debug/</id>
    <published>2016-12-28T01:48:40.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。</p><a id="more"></a><p>Weex Devtools 基于 Chrome devtools 实现了 Chrome Debugging Protocol，能够使用Chrome devtools调试 Weex 项目，其主要功能分为两大部分—— Debugger 和 Inspector。若使用Devtools调试weex项目，需要搭建调试环境，包括两部分：安装weex-devtool模块、App项目中集成weex-devtool SDK。</p><h1 id="安装weex-devtool-模块"><a href="#安装weex-devtool-模块" class="headerlink" title="安装weex-devtool 模块"></a>安装weex-devtool 模块</h1><p>weex-devtool是node.js的一个模块，用来启动服务器和Chrome页面，安装weex-devtool需要使用npm安装，由于使用npm安装特别慢，有时候一点速度都没有，这里使用淘宝的镜像源，切换方法：</p><pre><code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></pre><p>切换完后，使用cnpm安装weex-devtool：</p><pre><code>cnpm install -g weex-devtool</code></pre><p>weex-devtool 的用法：</p><pre><code>weex debug [options] [we_file|bundles_dir]</code></pre><p>选项有下面几种：</p><pre><code>-h, --help           显示帮助-V, --verbose        显示debug服务器运行时的各种log-v, --version        显示版本-p, --port [port]    设置debug服务器端口号 默认为8088-e, --entry [entry]  debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码)-m, --mode [mode]    设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer</code></pre><p>启动服务和chrome页面：</p><pre><code>weex debug  </code></pre><p>输出如下：</p><pre><code>bogon:~ lijian$ weex debugstart debugger server at http://10.144.36.206:8088The websocket address for native is ws://10.144.36.206:8088/debugProxy/nativeLaunching Dev Tools...</code></pre><p>输出上面的内容，表示weex-devtool已经并启动。其中ws://10.144.36.206:8088/debugProxy/native是APP连接到Chrome的调试的地址。App集成weex-devtool-iOS后，需要使用这个地址。</p><h1 id="APP集成weex-devtool-iOS-SDK"><a href="#APP集成weex-devtool-iOS-SDK" class="headerlink" title="APP集成weex-devtool-iOS SDK"></a>APP集成weex-devtool-iOS SDK</h1><p>集成weex-devtool-iOS SDK，可以参考<a href="https://github.com/weexteam/weex-devtool-iOS/blob/master/README-zh.md" rel="external nofollow noopener noreferrer" target="_blank">weex-devtool-iOS</a>将 weex-devtool-iOS 集成到项目中。这篇文章中介绍了pod集成方法和源码集成方法。这里假设已经集成完成。直接到使用SDK的步骤。<br>在AppDelegate中添加下面的代码，就可以使APP链接到Chrome的调试环境：</p><pre><code>#import &lt;WXDevtool.h&gt;[WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://10.144.36.206:8088/debugProxy/native&quot;];</code></pre><p>setDebug:参数为YES时，直接开启debug模式，反之关闭。launchDevToolDebugWithUrl 中的url就是在控制台启动Chrome时输出的地址。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>到目前为止，环境已配置完成，可以体验下调试过程。启动App，App会连接到chrome，Chrome中会显示出连接上的APP，如下：<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome.png" alt="weex-debug-chrome"></p><p>如图所示，有两个功能debug（调试）、inspector（元素省察）。其中debug可以调试JS的代码；inspector 可以审查界面的元素。点击debuger，进入调试提示页面，界面如下：<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome1.png" alt="weex-debug-chrome"><br>界面提示：使用option+commond+j进入调试JS代码界面，点击Sources标签，左边的导航栏显示源码列表，可以切换源码。调试面板包括设置断点、单步执行、查看运行时变量值等功能。<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome2.png" alt="weex-debug-chrome"></p><p>具体详细的调试方法请参考<a href="http://weex-project.io/cn/doc/how-to/debug-with-devtools.html" rel="external nofollow noopener noreferrer" target="_blank">如何使用 Devtools 调试 Weex 页面</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。&lt;/p&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex断点调试" scheme="http://yoursite.com/tags/weex%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>weex 事件原理分析</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/event-analize/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/event-analize/</id>
    <published>2016-12-16T09:46:54.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。<br><a id="more"></a></p><h1 id="事件传递过程分析"><a href="#事件传递过程分析" class="headerlink" title="事件传递过程分析"></a>事件传递过程分析</h1><p>本节通过一段示例代码，分析事件的传递过程。如果要实现一个点击事件，只需要在模板的某个标签下添加类似的代码onclick=”clickTest”， 例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">onclick</span>=<span class="string">"clickTest"</span>&gt;</span>测试点击事件<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">module</span>.exports = &#123;</span></span><br><span class="line"><span class="undefined">    data: </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="actionscript">      clickTest: <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'$event.type + $event.detail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码就是给text标签添加点击事件，事件的响应函数为clickTest。weex引擎渲染上面的代码，会将text标签转化为Native的WXText组件，转化过程中会调用WXText的初始化函数，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span>*)type</span><br><span class="line">                     styles:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance;</span><br></pre></td></tr></table></figure><p>定义中，参数events会传入组件包含的事件列表，也就是说，weex将text标签中的on开头的属性都当做事件，渲染JS时，传递到Native中，本例中，events的值为click，接下来继续看initWithRef:type:styles:attributes:events:weexInstance中怎么处理events的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                     styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    _events = events ? [<span class="built_in">NSMutableArray</span> arrayWithArray:events] : [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    ....     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    [<span class="keyword">self</span> _initEvents:<span class="keyword">self</span>.events];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，在初始化文本组件WXText（WXComponent的子类）时，将事件列表保存到events属性中。当将组件添加到父视图的时候，会调用属性view的get方法，在get方法中初始化所有的事件。下面是初始化事件的代码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)_initEvents:(NSArray *)events</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *eventsCopy = [events copy]<span class="comment">;</span></span><br><span class="line">    for (NSString *<span class="keyword">addEventName </span>in eventsCopy) &#123;</span><br><span class="line">        [<span class="keyword">self </span>_addEventOnMainThread:<span class="keyword">addEventName];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_addEventOnMainThread:(NSString *)<span class="keyword">addEventName</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(appear, <span class="keyword">addAppearEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(disappear, <span class="keyword">addDisappearEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(click, <span class="keyword">addClickEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(<span class="keyword">swipe, </span><span class="keyword">addSwipeEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(longpress, <span class="keyword">addLongPressEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(panstart, <span class="keyword">addPanStartEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(panmove, <span class="keyword">addPanMoveEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(panend, <span class="keyword">addPanEndEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(touchstart, <span class="keyword">addTouchStartEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchmove, <span class="keyword">addTouchMoveEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchend, <span class="keyword">addTouchEndEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchcancel, <span class="keyword">addTouchCancelEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    [<span class="keyword">self </span><span class="keyword">addEvent:addEventName];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">#define </span>WX_ADD_EVENT(eventName, <span class="keyword">addSelector) </span>\</span><br><span class="line"><span class="symbol">if</span> ([<span class="keyword">addEventName </span>isEqualToString:<span class="comment">@#eventName]) &#123;\</span></span><br><span class="line">    [<span class="keyword">self </span><span class="keyword">addSelector];\</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">- </span>(void)<span class="keyword">addClickEvent</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (!_tapGesture) &#123;</span><br><span class="line">        _tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:<span class="keyword">self </span>action:<span class="comment">@selector(onClick:)];</span></span><br><span class="line">        _tapGesture.delegate = <span class="keyword">self;</span></span><br><span class="line"><span class="keyword"> </span>       [<span class="keyword">self.view </span><span class="keyword">addGestureRecognizer:_tapGesture];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明初始化事件就是给文本组件的view属性添加一个点击手势tapGesture， 手势的响应函数为onClick。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onClick:(__unused <span class="built_in">UITapGestureRecognizer</span> *)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *position = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.calculatedFrame, <span class="built_in">CGRectZero</span>)) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> frame = [<span class="keyword">self</span>.view.superview convertRect:<span class="keyword">self</span>.calculatedFrame toView:<span class="keyword">self</span>.view.window];</span><br><span class="line">        position[<span class="string">@"x"</span>] = @(frame.origin.x);</span><br><span class="line">        position[<span class="string">@"y"</span>] = @(frame.origin.y);</span><br><span class="line">        position[<span class="string">@"width"</span>] = @(frame.size.width);</span><br><span class="line">        position[<span class="string">@"height"</span>] = @(frame.size.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> fireEvent:<span class="string">@"click"</span> params:@&#123;<span class="string">@"position"</span>:position&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> fireEvent:eventName params:params domChanges:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params domChanges:(<span class="built_in">NSDictionary</span> *)domChanges</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeSp = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>;</span><br><span class="line">    [dict setObject:@(timeSp) forKey:<span class="string">@"timestamp"</span>];</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">        [dict addEntriesFromDictionary:params];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[WXSDKManager bridgeMgr] fireEvent:<span class="keyword">self</span>.weexInstance.instanceId ref:<span class="keyword">self</span>.ref type:eventName params:dict domChanges:domChanges];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明：在手势响应函数中，最后调用weex的WXBridgeManager中的fireEvent函数。代码如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)fireEvent:(<span class="type">NSString</span> *)instanceId ref:(<span class="type">NSString</span> *)ref <span class="class"><span class="keyword">type</span>:(<span class="type">NSString</span> *)<span class="keyword">type</span> params:(<span class="type">NSDictionary</span> *)params domChanges:(<span class="type">NSDictionary</span> *)domChanges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="class"><span class="keyword">type</span> || !ref) &#123;</span></span><br><span class="line"><span class="class">        <span class="type">WXLogError</span>(@"<span class="type">Event</span> <span class="title">type</span> <span class="title">and</span> <span class="title">component</span> <span class="title">ref</span> <span class="title">should</span> <span class="title">not</span> <span class="title">be</span> <span class="title">nil</span>");</span></span><br><span class="line"><span class="class">        <span class="title">return</span>;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">NSArray</span> *args = @[ref, <span class="class"><span class="keyword">type</span>, params?:@&#123;&#125;, domChanges?:@&#123;&#125;];</span></span><br><span class="line">    <span class="type">NSMutableDictionary</span> *methodDict = [<span class="type">NSMutableDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                                       @<span class="string">"fireEvent"</span>, @<span class="string">"method"</span>,</span><br><span class="line">                                       args, @<span class="string">"args"</span>, nil];</span><br><span class="line">    <span class="type">WXBridgeMethod</span> *method = [[<span class="type">WXBridgeMethod</span> alloc] initWithInstance:instanceId <span class="class"><span class="keyword">data</span>:methodDict];</span></span><br><span class="line">    [self executeJsMethod:method];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)executeJsMethod:(<span class="type">WXBridgeMethod</span> *)method</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!method) return;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    <span class="type">WXPerformBlockOnBridgeThread</span>(^()&#123;</span><br><span class="line">        [weakSelf.bridgeCtx executeJsMethod:method];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明： fireEvent实际上就是执行JS的fireEvent函数，JS的fireEvent函数会根据传递的参数找到组件、组件的事件、事件响应函数，最后执行事件。本例中就是第一段JS代码的clickTest函数。其中传递的参数本例如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    args =(</span><br><span class="line">    <span class="comment">///ref（组件的标记）</span></span><br><span class="line">        <span class="number">5</span>, </span><br><span class="line">        <span class="comment">///type（事件类型）</span></span><br><span class="line">        <span class="built_in">click</span>, </span><br><span class="line">        <span class="comment">///params   </span></span><br><span class="line">        &#123;   <span class="comment">///事件触发的位置</span></span><br><span class="line">            <span class="built_in">position</span> =&#123;</span><br><span class="line">                <span class="built_in">height</span> = <span class="string">"39.5"</span>;</span><br><span class="line">                <span class="built_in">width</span> = <span class="number">768</span>;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">                y = <span class="number">64</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            timestamp = <span class="string">"1481882724298.018"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">///domChanges（是否更新界面）</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">///JS的方法</span></span><br><span class="line">    method = fireEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，weex的事件传递机制讲完了，下面做个简单的总结。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>weex的事件处理机制是： 在JS中定义标签的事件类型、事件的处理函数，在Native实现事件。原理是：将标签初始化为组件的时候，初始化标签的事件。其中click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel初始化为手势事件，appear、disappear初始化为滑动视图的出现事件和消息事件。当事件触发时，通过WXBridgeManager调用JS的fireEvent函数，在JS中调用标签的事件处理函数。下面是做了一张大概的原理图。<br><img src="http://of685p9vy.bkt.clouddn.com/weex-event-detail1.png" alt="weex-event-detail1"><br>图中红色部分是JS逻辑，黑色部分是组件的逻辑，蓝色部分是WXBridgeManager逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。&lt;br&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式学习摘要</title>
    <link href="http://yoursite.com/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/wiki/正则表达式/正则表达式学习/</id>
    <published>2016-12-13T10:01:31.000Z</published>
    <updated>2018-03-20T04:19:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>下文是学习正则表达式的学习摘要 </p><a id="more"></a><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><caption>表1.常用的元字符</caption><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线或汉字</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>^</td><td>匹配字符串的开始</td></tr><tr><td>$</td><td>匹配字符串的结束</td></tr></tbody></table><h2 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h2><caption>表2.常用的限定符</caption><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复零次或更多次</td></tr><tr><td>+</td><td>重复一次或更多次</td></tr><tr><td>?</td><td>重复零次或一次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>[aeiou]</td><td>匹配任何一个英文元音字母</td></tr><tr><td>[0-9]</td><td>和\d完全一致的，匹配任何数字</td></tr><tr><td>[a-z0-9A-Z_]</td><td>等同于\w 只考虑英文的情况</td></tr></tbody></table><h2 id="分支条件"><a href="#分支条件" class="headerlink" title="分支条件"></a>分支条件</h2><p>具体方法是用|把不同的规则分隔开。</p><p>匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。</p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p><h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><caption>表3.常用的反义代码</caption><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td>[^x]</td><td>匹配除了x以外的任意字符</td></tr><tr><td>[^aeiou]</td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><h2 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h2><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p><p>呃……其实,组号分配还不像我刚说得那么简单：</p><ul><li><p>分组0对应整个正则表达式</p></li><li><p>实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号</p></li><li><p>你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权．</p></li></ul><p>后向引用用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：</p><p>\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\1)。</p><p>你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?<word>\w+)(或者把尖括号换成’也行：(?’Word’\w+)),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<word>,所以上一个例子也可以写成这样：\b(?<word>\w+)\b\s+\k<word>\b。</word></word></word></word></p><p>使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些：</p><caption>表4.常用分组语法</caption><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td></td><td>(?<name>exp)</name></td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td></td><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td></td><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td></td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><p>我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下文是学习正则表达式的学习摘要 &lt;/p&gt;
    
    </summary>
    
      <category term="正则表达式" scheme="http://yoursite.com/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
</feed>
