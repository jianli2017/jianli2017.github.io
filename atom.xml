<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-14T07:54:48.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>字符串、向量、数组</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第三章 字符串、向量、数组/字符串、向量、数组/</id>
    <published>2018-08-10T04:07:12.000Z</published>
    <updated>2018-08-14T07:54:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>命令空间的using声明</li><li>标准库类型string</li><li>标准库类型vector</li><li>迭代器介绍</li><li>数组</li><li>多维数组</li></ol><p>基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。</p><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>std::cin中作用域运算符的含义：编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。</p><p>using声明的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>using 声明每次只能引入一个名字。using 声明必须以分号结束。</p><p>头文件不应该包括using声明。</p><h2 id="标准库string"><a href="#标准库string" class="headerlink" title="标准库string"></a>标准库string</h2><p>C++标准一方面对库类型所提供的操作做了详细的规定、另一方面也对库的实现者做了性能的要求。</p><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化对象由类的本身决定的。</p><p>初始化sting对象的方式</p><table><thead><tr><th>初始化形式</th><th>说明</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1是空串</td></tr><tr><td>string s2(s1)</td><td>s2是s1的一个副本</td></tr><tr><td>string s2= s1</td><td>等价于s2(s1)</td></tr><tr><td>string s3(“value”)</td><td>s3是字面值value的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于s3(“value”)</td></tr><tr><td>string s4(n,’c’)</td><td>初始化为连续n个字符c组成的字符串</td></tr></tbody></table><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><ol><li>拷贝初始化（copy initialization）：使用等号（=）初始化一个变量</li><li>直接初始化：不用等号</li></ol><p>当初始值只有一个时，使用直接初始化和拷贝初始化都行，如果用到多个初始值，一般来说只能直接初始化。如果非要用拷贝初始化也可以，需要显示的创建一个临时对象用于拷贝。</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>一个类除了规定初始化对象的方式外，还要定义对象上所能执行的操作。</p><table><thead><tr><th>操作示例</th><th>说明</th></tr></thead><tbody><tr><td>os&lt;&lt;s</td><td>将s写到输出流os当中，返回os</td></tr><tr><td>is&gt;&gt;s</td><td>从is中读取字符串赋给s，字符串以空白介绍，返回s</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用</td></tr><tr><td>s1+s2</td><td>返回s1、s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1 == s2</td><td>如果s1和s2所含的字符完全一样，则他们相等</td></tr><tr><td>s1 != s2</td><td></td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较</td></tr></tbody></table><h4 id="读取string对象"><a href="#读取string对象" class="headerlink" title="读取string对象"></a>读取string对象</h4><p>string对象会自动忽略开头的空白（空格，换行、制表符）并从第一个真正的字符开始算起，知道遇到下一处空白为止。</p><p>sting对象的此类输入输出操作返回运算符左侧的运算对象，所以，如果多个输入或者多个输出可以连在一起写。</p><h4 id="使用getline读取一行"><a href="#使用getline读取一行" class="headerlink" title="使用getline读取一行"></a>使用getline读取一行</h4><p>getline函数从给定的输入流中读入内容，直到遇到换行符为止，换行符的内容也被读入进来。然后将所读的内容从存入到string中。</p><p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。</p><h4 id="string的empty、size操作"><a href="#string的empty、size操作" class="headerlink" title="string的empty、size操作"></a>string的empty、size操作</h4><p>size返回的是string:size_type</p><p>string的相等意味着长度相同，且所包含的字符也完全相等。</p><p>当把string对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个加法的两侧的运算符对象至少有一个是string。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>cctype头文件中定义了一组标准函数处理字符：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>当c是字母或数字时为真</td></tr><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符时为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不为空格，单可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真，空格，可视字符</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(空格、制表符、回车、换行、进制符)</td></tr><tr><td>issupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母，否则原样输出</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大小字母，否则原因输出</td></tr></tbody></table><p>c语言的头文件形如name.h，在C++中将这些文件命名为cname，也就是去掉了.h后缀，在name名字前添加了字母c，这里的c表示是一个属于c语言标准库的头文件。cnmae的头文件中定义的明智属于命名空间std。而定义在.h的名字则不在。</p><h4 id="范围for语句（range-for）"><a href="#范围for语句（range-for）" class="headerlink" title="范围for语句（range for）"></a>范围for语句（range for）</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : <span class="type">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>其中expression部分是一个对象，表示序列。declaration是定义一个变量，用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> c : str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///对字符串c的每个字符c做某种操作</span></span><br></pre></td></tr></table></figure><p>如果想改变string对象中的字符的值，必须把循环变量定义成引用类型。这个变量实际上绑定到序列中的每个元素。</p><p>下标运算符：通过位置，返回该位置上字符的引用。 使用超出下标范围将引发不可预知的结果，使用下标访问空string也引发不可预知结果。</p><p>不管什么时候，只要对string对象使用下标，都要确认在那个位置上确实有值。</p><p>只要字符串不为常量，就能为下标运算符返回的字符串赋新值。</p><h2 id="标准库vector"><a href="#标准库vector" class="headerlink" title="标准库vector"></a>标准库vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，索引可以访问对象。因为vector“容纳着”其他对象，所以，所以他被称为容器（container）。</p><p>模板本身不是类或者函数，相反，可以看做是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称为<code>实例化</code>（instantiation），当使用模板时，需要指出编译器应把类或者函数实例化成何种形式。</p><p>提供信息的方式：即在类模板名字后面跟一对尖括号，括号内放类型信息。</p><p>vector是模板，而不是类。</p><h3 id="定义、初始化vector对象"><a href="#定义、初始化vector对象" class="headerlink" title="定义、初始化vector对象"></a>定义、初始化vector对象</h3><p>|初始化示例|说明|<br>|vector<t> v1| v1是一个空vector，他潜在的元素是T类型，执行默认初始化|<br>|vector<t> v2(v1)|v2中包含v1所有元素副本|<br>|vector<t> v2 = v1|等价于v2(v1)|<br>|vector<t> v3(n,val)|v3包含那个重复的元素。每个元素的值是val|<br>|vector<t> v4(n)|v4 包含了n个重复的执行了值初始化的元素|<br>|vector<t> v5{a,b,c,…}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>|vector<t> v5 = {a,b,c,…}|等价于v5{a,b,c,…}|</t></t></t></t></t></t></t></p><p><strong>列表初始化</strong>vector对象。</p><p>值初始化：通常情况下，可以只提供vector对象容纳元素数量，而略去初始值，此时，库会创建一个值初始化的元素初值，并且把它赋值给容器中所有元素。这个初始值由vector元素类型决定。</p><p>如果是内置类型，如int，元素初始值自动设置为0，如果是类类型，比如string，元素由类默认初始化。</p><p>如果只提供元素的数量而没有设定初始值，只能使用直接初始化。不让就是将数量拷贝给string对象了。</p><p>初始化过程中，尽可能地把花括号内的值当做是元素初始值列表处理，但是如果花括号形式所提供的值不能进行列表初始化，就要考虑用这样的值构造vector对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125; <span class="comment">//列表初始化，v5有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>); <span class="comment">//错误不能构建</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;   <span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;; <span class="comment">//v8有10个值为“hi” 的元素</span></span><br></pre></td></tr></table></figure><p> 在确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p><h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><p>vector对象能高效的增长，如果初始化的时候指定大小，可能效率会低。</p><p>范围for循环体内不应改变其所遍历序列的大小。</p><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><table><thead><tr><th>vector操作</th><th>说明</th></tr></thead><tbody><tr><td>v.empty()</td><td>如果v不含有任何元素，返回真，否则，返回假</td></tr><tr><td>v.size()</td><td>返回v中元素个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾部添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素的拷贝替换v1中的元素</td></tr><tr><td>v1 = {a,b,c…}</td><td>用列表中元素的拷贝替换v1中的元素</td></tr><tr><td>v1== v2</td><td>元素数目相同、对应位置上的元素值相同</td></tr><tr><td>v1 != v2</td><td></td></tr><tr><td>&lt; ,&lt;=, &gt; ,&gt;=</td><td>以字典的顺序进行比较</td></tr></tbody></table><p>vector对象的类型总是包含元素的类型。只有当元素的类型可以比较时，vector对象才能比较。vector可以使用下标读写元素，不能通过下标添加元素。<br>只能对已经存在的元素</p><p>缓冲区溢出（buffer overflow） 就是指的下标越界这类错误。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>类似指针类型，迭代器提供了对对象的间接访问。就迭代器而言，其对象是容器中元素或者string对象中的字符。</p><p>和指针不同，获取迭代器不是使用取地址符，有迭代器的类型，同时拥有返回迭代器的成员。比如begin、end成员。</p><ol><li>begin成员负责返回指向第一个元素的迭代器。</li><li>end成员负责返回指向容器 <strong>尾元素的下一个位置</strong>的迭代器。</li><li>end成员返回的迭代器通常称为尾后迭代器。</li><li>如果容器为空，则begin、end返回的是同一个迭代器。都是尾后迭代器。</li></ol><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>迭代器的运算符如下：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>*iter</td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter)-&gt;mem</td></tr><tr><td>++iter</td><td>令iter指示容器的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个元素是否相等，如果两个迭代器指示的是同一个元素，或者他们是同一个容器的尾后迭代器，则他们相等，否则不行等</td></tr><tr><td>iter1 != iter2</td></tr></tbody></table><p>指针和迭代器的相同点：</p><ol><li>可以解引用来获取它所指元素</li><li>也有有效和无效之分，有效：迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他所有情况都无效</li><li>提供了对对象的间接访问</li><li>都可以移动到下一个元素、上一个元素</li><li>视图解引用非法迭代器或者尾后迭代器都是未定义的，  解引用非法指针也是非法的</li></ol><p>指针和迭代器的不同点：</p><ol><li>获取方式不同，指针：取地址； 迭代器：通过容器的成员。</li></ol><p>迭代器使用实例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string </span>s(<span class="string">"some string"</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">if</span>(s.<span class="keyword">begin() </span>!= s<span class="meta">.end</span>())</span><br><span class="line">&#123;</span><br><span class="line">auto <span class="keyword">it </span>= s.<span class="keyword">begin();</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= touper(*<span class="keyword">it);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>因为end返回的迭代器并不实际指示元素，所以不能对其进行递增或者解引用的操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>(auto <span class="keyword">it </span>= s.<span class="keyword">begin(); </span><span class="keyword">it </span>!= s<span class="meta">.end</span>() &amp;&amp; !isspace(*<span class="keyword">it); </span>++<span class="keyword">it)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= toupper(*<span class="keyword">ite);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>只有string、vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库的迭代器都定义了==、!=，但是他们中的大多数没有定义&lt; 运算符，因此， 我们要养成使用迭代器和!=运算符的习惯。</p><p>实际上，那些拥有迭代器的标准库使用iterator、const_iterator表示迭代器类型。</p><p>const_iterator和常量指针差不多。能读取，不能修改。</p><p>如果vector、string对象是一个常量，只能使用const_iterator，如果vector、string不是常量，既能使用iterator，也能使用const_iterator</p><p>begin和end运算符： begin和end返回的具体类型由对象是否常量觉得，如果对象是常量，begin和end返回const_iterator，如果不是，返回iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v2;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v1.begin(); <span class="comment">//iter1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = v2.begin(); <span class="comment">//iter2 的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>cbegin()、cend() 返回const_iterator类型迭代器。</p><p>箭头-&gt;运算符将解引用和成员访问两个操作结合在一起。也就是it-&gt;mem和(*it).mem表达式的意思相同。</p><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><table><thead><tr><th>迭代器运算</th><th>说明</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上整数值，扔是一个迭代器类型。迭代器指示的新位置与原来的位置相比，向前移动了n个元素。结果迭代器或者指向容器的下一个元素，或者指向容器尾元素的下一个位置</td></tr><tr><td>iter - n</td><td></td></tr><tr><td>iter += n</td><td></td></tr><tr><td>iter1= n</td><td></td></tr><tr><td>iter 1 - iter2</td><td></td></tr><tr><td>&lt;, &lt;=, &gt;,&gt;=</td></tr></tbody></table><p>两个迭代器的间距的类型是diffrence 类型。带符号的。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义、初始化内置数组"><a href="#定义、初始化内置数组" class="headerlink" title="定义、初始化内置数组"></a>定义、初始化内置数组</h3><p>数组中元素的个数也属于数组类型的一部分，编译的时候纬度应该已知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>]  ; <span class="comment">//含有10个整形指针的数组。</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>定义数组的时候必须指定数组的类型。不允许使用auto关键字由初始值的列表来推断类型。</p><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的纬度。如果声明时没有指定纬度，编译器会根据初始值的数量计算并推断出来，如果指定了维度，那么初始值的总数量不应该超过指定的大小。</p><p>字符数组的特殊性： 一定要注意，字符串字面值的结尾还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">a</span>[] = <span class="string">"C++"</span> ;<span class="comment"> // 容量4</span></span><br></pre></td></tr></table></figure><p>不能讲数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">int a2[] = a; <span class="comment">//错误不能用一个数组初始化另一个数组</span></span><br><span class="line">a2 =a; <span class="comment">//错误不能把一个数组赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>理解复杂数组声明</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">ptrs</span><span class="selector-attr">[10]</span>; <span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">&amp;</span><span class="selector-tag">refs</span><span class="selector-attr">[10]</span>; <span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (*parray)<span class="selector-attr">[10]</span>; <span class="comment">//parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (&amp;arrRef)<span class="selector-attr">[10]</span>;<span class="comment">//parray引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><p>对数组而言，由内向外阅读比较合适。parray是一个指针，指向一个含有10个元素的数组，数组的元素类型是整形。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组的特性：在很多用到数组名字的地方，编译器都会自动的将其替换为一个指向数组首元素的指针。<br>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。</p><p>decltype不会执行数组到指针的转化。</p><p>指针也是迭代器</p><p>标注库函数begin、end。由于数组不是类类型，因此这两个函数不是成员函数。begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一个位置的指针。</p><p>尾后迭代器不能执行解引用和递增操作。</p><p>两个指针递减的结果类型是一种名为ptrdiff_t的标准库类型。定义在cstddef头文件中。</p><p>很多情况下，使用数组的名字，其实用的是一个指向数组首元素的指针。</p><p>内置下标运算符所用的索引值不是无符号类型，这一点和vector和string不一样。</p><h3 id="C分格字符串"><a href="#C分格字符串" class="headerlink" title="C分格字符串"></a>C分格字符串</h3><table><thead><tr><th>c分格字符串的函数</th><th>说明</th></tr></thead><tbody><tr><td>strlen()</td><td>返回p的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1,p2)</td><td>比较p1、p2的相等性，如果p1==p2 返回0，如果p1&gt;p2，返回一个正值，如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1,p2)</td><td>将p2附加到p1之后，返回p1</td></tr><tr><td>strcpy(p1,p2)</td><td>将p2拷贝给P1，返回p1</td></tr></tbody></table><p>当使用数组的时候其实真正用的是指向数组首元素的指针。所以比较字符串实际上比较的是指针。</p><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><ol><li>允许使用 以空字符结束的字符数组来初始哈动态string对象或者为string对象赋值</li><li>在string对象的加法运算中，允许使用空字符结束的字符数组作为其中一个运算对象。</li></ol><p>string对象的c_str函数返回一个C风格的字符串。</p><p>可以使用数组初始化vector对象。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言没有多维数组，通常所说的多维数组其实是数组的数组。</p><p>要使用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。<br>类型别名简化多维数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_ary = <span class="keyword">int</span>[<span class="number">4</span>];  <span class="comment">//int_ary 是含有4个整型元素的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_ary[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令空间的using声明&lt;/li&gt;
&lt;li&gt;标准库类型string&lt;/li&gt;
&lt;li&gt;标准库类型vector&lt;/li&gt;
&lt;li&gt;迭代器介绍&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本类型体现了大
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第三章 字符串、向量、数组" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>特殊工具和技术</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十九章特殊工具和技术/特殊工具和技术/</id>
    <published>2018-08-02T01:07:12.000Z</published>
    <updated>2018-08-02T11:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制内存"><a href="#控制内存" class="headerlink" title="控制内存"></a>控制内存</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用new表达式时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> * sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a string"</span>);</span><br><span class="line"><span class="built_in">string</span> * arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际执行了三步：</p><ol><li>new 表达式调用 operator new 或operator new [] 标准库，分配一块足够大、原始的、未命名的内存空间。</li><li>编译器运行相应的构造函数，并传入初始值。</li><li>返回一个指向该对象的指针。</li></ol><p>当我们使用delete表达式时</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure><ol><li>调用析构函数</li><li>调用名为operator delete 或者operator delete [] 释放空间。</li></ol><p>发现new、delete表达式，如果对象是类类型，首先在类类型中查找，然后是全局作用域。也可以使用::new直接使用全局作用域的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>类作用域的new、delete是静态的。因为operator new 用在对象构造之前，operator delete 用在对象销毁后。而且不能操作类的任何成员。</p><p>new表达式和 operator new 函数：不能改变new表达式、delete表达式的含义。</p><p>malloc函数接受一个表示带分配字节数的size_t，返回指向分配空间的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">void</span>* mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* mem)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address)<span class="built_in"> type </span>(initializers)</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size]</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size] &#123;braced initializer list&#125;</span><br></pre></td></tr></table></figure><p>定位new 使用 operation new (size_t ,void *)函数<br>定位new 可以构造对象，单不分配内存</p><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>allcator</td></tr><tr><td>allocate</td><td>construct</td></tr><tr><td>destroy</td><td>deallocate</td></tr></tbody></table><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>new的形式</td></tr><tr><td>operator new</td><td>构造函数（定位new可以只构造对象，不申请空间）</td></tr><tr><td>free</td><td>析构函数（可以直接调用）</td></tr></tbody></table><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><ol><li>typeid 运算符，返回表达式的类型</li><li>dynamic_cast运算符 用于将基类指针或引用安全的转化为派生类的指针或者引用</li></ol><p>当操作被定义为虚函数时，编译器将根据对象的动态类型自动的选择正确的版本 。</p><ol><li>dynamic_cast<type*> (e)</type*></li><li>dynamci_cast<type&> (e)</type&></li><li>dynamic_cast<type&&> (e)</type&&></li></ol><p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p><p>type_info 类的name成员函数返回一个C风格的字符串，表示对象的类型名字。type_info 只能通过typeid运算符创建。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型使我们可以将一组整形常量组织在一起。 </p><ol><li>限定作用域</li><li>不限定作用域</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> 枚举名 &#123; 逗号分隔的枚举列表&#125;;</span></span><br></pre></td></tr></table></figure><p>枚举值可以不唯一，枚举成员是常量表达式。</p><p>和类一样，枚举也定义新的类型，也能定义变量。enum对象赋值必须使用该类型的一个枚举成员，或该类型的另一个对象。</p><p>指定enum的大小</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValue</span> : <span class="title">unsigned</span> <span class="title">long</span> <span class="title">long</span> </span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>枚举类型的前置声明</p><h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针，是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员。</p><p>成员指针的类型囊括了类的类型、成员的类型。当初始化一个这样的指针时，我们另其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p><h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><p>声明成员指针时，必须包含成员所属的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> className:: * pdata;</span><br><span class="line">pdata = &amp;Screen::contents <span class="comment">//指向某个非特定Screen对象的contents成员</span></span><br></pre></td></tr></table></figure><p>当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员，而非该成员所属的对象。只有当解引用成员指针时，我们才提供对象的信息。 也就是解引用时候绑定到特定的对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*  data()</span><br><span class="line">&#123;</span><br><span class="line">retrun &amp;Screen::contents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data 指向Screen类const string 成员指针。</span></span><br></pre></td></tr></table></figure><h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p><code>char (Screen::*pmf2)(int,int ) const;</code></p><h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>成员函数指针不是可调用对象，调用前必须使用.<em>或者-&gt;</em>绑定到特定对象上。所以不能直接将成员函数指针传递给算法。</p><font color="red"><br>以下内容无法理解：<br><br>1. 可以使用function生成一个可调用对象。<br>2. 可以使用mem_fn生成一个可调用对象。<br>3. 使用bind 生成一个可调用对象。<br><br></font><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class） ，后者称为嵌套类型（nested type）。</p><p>嵌套类是一个独立的类，与外层基本没有什么关系，特别是，外层类对象和嵌套类对象是相互独立的，嵌套类的对象不能包括任何外层类定义的成员；类似的，在外层类的对象也不能报考任何嵌套类定义的成员。嵌套类的名字在外层作用域内是可见的。之外不可见。 嵌套类对外层类的成员也没有特殊的访问权限。</p><h2 id="union-一种节省空间的类"><a href="#union-一种节省空间的类" class="headerlink" title="union 一种节省空间的类"></a>union 一种节省空间的类</h2><p>union可以定义多个数据成员，但在任何时刻，只有一个数据成员可以有值。union可以定义包括构造函数和析构函数在内的成员函数。但union不能继承自其它类，也不能作为基类使用。 不能有虚函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;控制内存&quot;&gt;&lt;a href=&quot;#控制内存&quot; class=&quot;headerlink&quot; title=&quot;控制内存&quot;&gt;&lt;/a&gt;控制内存&lt;/h2&gt;&lt;h3 id=&quot;重载new和delete&quot;&gt;&lt;a href=&quot;#重载new和delete&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十九章特殊工具和技术" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="特殊工具和技术" scheme="http://yoursite.com/tags/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>变量和基本类型</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第二章变量和基本类型/变量和基本类型/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-08-13T05:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。</p><p>主要内容 ：</p><ol><li>基本内置类型</li><li>变量</li><li>复合类型</li><li>const限定符</li><li>处理类型</li><li>自定义数据类型</li></ol><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++ 定义了一套包括算术类型和空类型的基本数据类型。</p><p>算术类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32</td></tr><tr><td>short</td><td>短整形</td><td>16</td></tr><tr><td>int</td><td>整形</td><td>16</td></tr><tr><td>long</td><td>长整形</td><td>32</td></tr><tr><td>long long</td><td>长整形</td><td>64</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10 位有效数字</td></tr></tbody></table><ol><li>寻址的最小内存块为 <strong>字节(byte)</strong> 大多数的字节由8个bit构成。</li><li>存储的基本单元称为 <strong>字(word) </strong>一般32或64bit。</li></ol><p>通常，float一个字，double两个字，long double4个字，类型float和double 分别有<strong>7</strong>个和<strong>16</strong>个有效位。</p><p>与其他类型不同，字符型被分为三种：char、signed char 、 unsigned char。char 和signed char 并不是一种，尽管类型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种的一种，具体由编译器决定。</p><p>如何选择类型：</p><ol><li>在算术表达式中不要使用char 、bool 只有在存放字符或者bool值时候才使用它们，因为类型char在一些机器上有符号，而在另外一些机器上又是无符号的，所以，如果使用char 进行运算特别容易出问题。如果使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。</li><li>执行浮点运算选用double，这是因为float通常进度不够。对于某些机器，双精度运算甚至比单精度还快。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当给某种类型的对象强制赋予了另一种类型的值时，到底发生了什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span><span class="keyword">b </span>= <span class="number">42</span><span class="comment">;</span></span><br><span class="line">int i = <span class="keyword">b </span><span class="comment">; ///i的值时1</span></span><br></pre></td></tr></table></figure><ol><li>当把一个非布尔类型的算术值赋给布尔类型时，初始值0是false，否则为true。</li><li>当把一个布尔值赋值给非布尔类型时，初始值false 是0，true是1.</li><li>浮点数赋值给整数类型时，进行近视处理，保留小数部分之前的。</li><li>将超出范围的值赋值给无符号类型：结果是初始值对无符号类型表示的总数取模后的余数。</li><li>将超出范围的值赋给带符号类型，结果未定义。</li></ol><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p><font color="red"></font></p><ol><li>无符号数递减不能是负值，如果为负值，会是取模的余数。</li><li>切勿混用带符号和无符号类型。如果表达式里面既有带符号的，又有无符号的，带符号的数会转化为无符号的数。<br><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3></li></ol><table><thead><tr><th>字面常量</th><th>进制</th></tr></thead><tbody><tr><td>20</td><td>十进制</td></tr><tr><td>024</td><td>八进制</td></tr><tr><td>0x14</td><td>十六进制</td></tr></tbody></table><ol><li>字面值常量的类型是能容纳该数值的尺寸最小的那个（int long， long long），默认是带符号的。类型short没有对应的字面值。浮点型字面值类型是double。</li><li><strong>字符串字面值的类型实际上是由常量字符构成的数组，末尾添加‘\0’。</strong></li><li><strong>如果两个字符串字面值位置紧邻且仅由空格，缩进、换行符分隔，则他们实际上是一个整体</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really"</span> </span><br><span class="line">              <span class="string">"that spans"</span>;</span><br></pre></td></tr></table></figure><p>有两种类型字符不能直接使用，需要转义：</p><ol><li>不可打印</li><li>特殊含义字符：单引号、双引号、问号、反斜杠</li></ol><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>指定字符和字符串字面值：指定的方法如下表：</p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode 16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode 32 字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8(仅用于字符串字面常量)</td><td>char</td></tr></tbody></table><p>指定整数字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>u U</td><td>unsigned</td></tr><tr><td>l L</td><td>long</td></tr><tr><td>ll LL</td><td>long long</td></tr></tbody></table><p>指定浮点字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>f F</td><td>float</td></tr><tr><td>l L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供具名的、可供程序操作的存储空间。C++每个变量都有数据类型，数据类型决定着变量所占内存空间的大小、布局方式、该空间能存储的值的范围、以及变量能参与的运算。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>基本形式：类型说明符（type specifier） + 变量名</p><p>string表示可变长字符序列  的数据类型</p><p>对象是指能存储数据并具有某种类型的存储空间。</p><p>当一次定义了两个或多个变量时，对象的名字随着定义也马上可以使用了。因此在同一条语句中，可以用先定义的变量去初始化后定义的其他变量。</p><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p><p>初始化的四种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>花括号的初始化形式称为<strong>初始化列表</strong>。</p><p>初始化列表用于内置类型的变量时：<strong>如果初始值存在丢失信息的风险，编译器报错。</strong></p><p>如果定义变量时没有指定值，则变量被默认初始化（default initialized），此时变量被赋予了默认值。</p><p>函数体之外的内置变量被初始化为0；函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示初始化，则其值由类确定。</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明：规定了变量的类型和名字，这一点上和定义相同。<br>定义：除了规定变量的类型和名字，还申请存储空间、为变量赋一个初始值。</p><p>声明代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">//声明i，而非定义i，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; 任何包含了显示初始化的声明既变为定义。</span><br></pre></td></tr></table></figure><p>变量能且只能别定义一次，但是可以被多次声明。</p><p>这相当于为分离式编程提供了支持</p><p>C++是一种静态类型语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查。 编译器知道每一个实体对象的类型是通过类型声明。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>用户定义的标识符不能连续出现两个下划线、不能以下划线紧连大写字母开头、定义在函数体外的标识符不能以下划线开头。</p><p>变量命名规范：</p><ol><li>标识符要能体现实际含义</li><li>变量一般用小写字母</li><li>用户定义的类名一般以大写字母开头</li><li>标识符由多个单词组成，则单词间应该有明显区分</li></ol><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>名字的有效区域始于名字的声明语句，以声明语句所在的作用域未端为结束。</p><p>第一次使用变量时再定义变量，这样好处：</p><ol><li>更容易找到变量的定义</li><li>容易赋值合理的初始值</li></ol><ol><li>全局作用域</li><li>块作用域</li><li>嵌套作用域</li></ol><ol><li>内层作用域可以访问外层作用域中的名字</li><li>内层作用域中可以重新定义外层作用域中的名字</li><li>使用作用域运算符可以直接访问外层作用域中的名字</li></ol><h2 id="符合类型（引用、指针）"><a href="#符合类型（引用、指针）" class="headerlink" title="符合类型（引用、指针）"></a>符合类型（引用、指针）</h2><p>符合类型是基于其他类型定义的类型（compound type）</p><p>基本数据类型  + 声明符</p><p><strong>声明符</strong>命令了一个变量，并指定该变量的相关类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference） 为对象起了另一个名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中，然而，定义引用时，程序把引用和它的初始值绑定在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此，引用必须初始化。</p><p>定义一个引用后，对其进行的所有操作都是在与之绑定的对象进行的。</p><ol><li>获取引用的值：实际上是获取了与引用绑定的对象的值。</li><li>以引用为初始值： 实际上是以与引用绑定的对象作为初始值。</li></ol><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p><p>用于在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。</p><p>引用的类型要和与之绑定的对象严格匹配。引用只能绑定在一个对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与引用类型，指针也实现了对其他对象的间接访问。</p><p>指针和引用的区别：</p><ol><li>指针本身也是对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。</li><li>指针无需在定义的时候赋值。</li></ol><p>指针存放某个对象的地址。要想获取该地址，使用取地址符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//p存放变量ival的地址。 或者说p是指向变量ival的指针。</span></span><br></pre></td></tr></table></figure><p>指针的类型都要和它所指向的对象严格匹配。</p><p>指针值：指针的值（即地址）应属于下列4中转态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>解引用来访问该对象，解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p>空指针使用nullptr，新标准使用NULL，NULL是预处理变量。</p><p>如果使用了未经初始化的指针，则该指针所占内存空间的当前内容被看做是一个地址值，访问该指针，相当于去访问一个本不存在的位置上的</p><p>指针和引用都能踢动对其他对象的间接访问，然而，在具体实现细节上，二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法领其在绑定到另外的对象。之后每次使用这个引用都是访问他最初绑定的那个对象。</p><p>给指针赋值，就是令其存放一个新地址。</p><p>如果两个指针存放的地址值相同，则他们相等。</p><p>void<em> 是一种特殊的指针类型，可用于存放任何对象的地址。一个`void</em><code>指针存放着一个地址。这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象不了解。 不能直接操作</code>void*` 指针所指的对象。因为我们不知道这个对象到底是什么类型。</p><h3 id="理解符合类型"><a href="#理解符合类型" class="headerlink" title="理解符合类型"></a>理解符合类型</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//p是<span class="built_in">int</span>型指针、r是一个<span class="built_in">int</span>型引用</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">int</span> *<span class="built_in">pi</span> = &amp;ival;</span><br><span class="line"><span class="built_in">int</span> **ppi = &amp;<span class="built_in">pi</span>; ///ppi指向一个<span class="built_in">int</span>型的指针</span><br></pre></td></tr></table></figure><p>ppi  -&gt; pi -&gt; ival (1024)</p><h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p ;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r 引用了一个指针，因此给r赋值，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><p>离变量名最近的符号对变量类型有最直接的影响。所以r是引用。</p><p>##const限定符</p><p>默认情况下，const对象仅仅在文件内有效。如果想在多个文件中共享const对象，就对const变量不管是声明还是定义都添加extern关键字。这样只需定义一次就可以了。</p><h3 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h3><p>可以把引用绑定到const 对象上，我们称为对常量的引用（refernce to const） 。一定要记住，</p><h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>引用的类型必须和其所引用对象的类型一致，但是有两个例外，第一种例外情况是初始化常量引用时允许用任何表达式作为初始值，只要改表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span> <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1* <span class="number">2</span>;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><p>必须认识到：常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>指向常量的指针（pointer to const） 不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">//pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr  = &amp;pi;  <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure><p>指针的类型必须与其所指对象的类型一致，但是有两个例外，其中一个是：允许一个指向常量的指针指向一个非常量对象。</p><p>试试这样想吧：所谓指向常量的指针和引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以自觉的不去改变所指对象的值。</p><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>指针是对象而引用不是，所以就像其他对象类型一样，允许指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量。即不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pip <span class="comment">//pip 是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><p>要想弄清楚这些声明的含义，最行之有效的方法是从右向左阅读</p><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题，用名词顶层const表示指针本身是一个常量，而用名词底层const 表示指针所指的对象是一个常量。</p><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。</p><p>当执行对象的拷贝操作时，常量的顶层const还是底层const区别名下，其中顶层const不受影响：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci <span class="comment">//允许改变p2的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;  <span class="comment">//正确，底层一样</span></span><br></pre></td></tr></table></figure><p>另一方面，底层const的限制不能忽视</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误，p指向的值可以通过p改变，但p指向的值是常量，所以错误</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式</p><p>constexpr变量：如果认定变量是一个常量表达式，那就把它声明为constexpr类型</p><h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>字面值类型： 比较简单，值也显而易见，容易得到，算术类型、引用类型、指针都属于字面值类型。  string 不属于，也就不能被定义成constexpr。</p><p>函数体内定义的变量，一般来说并非存放固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于多有函数体之外的对象，其地址固定不变，能用来初始哈constexpr指针。</p><h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>  <span class="comment">//p是一个指向整型常量的 指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">//q是一个指向整形的向量指针。</span></span><br></pre></td></tr></table></figure><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>为了简化复杂类型的定义</p><h3 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wage base,*p ;<span class="comment">// base 是double的同义词，p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//SI 是sales_item的同义词</span></span><br></pre></td></tr></table></figure><p>using 把等号左侧的名字规定成等号右侧类型的别名。</p><h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr 是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>pstring 的基本数据类型是指针 。 不能展开，如果展开就错了</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> * <span class="built_in">cstr</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>展开就成了底层常量了</p><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器通过初始值来推断变量的类型，显然，auto的定义必须有初始值。</p><ol><li>引用： 编译器以引用对象的类型作为auto的类型，希望推断引用，需要 auto &amp;</li><li>顶层const常量： 忽略，希望推断顶层const常量，需要用const auto</li><li>底层const常量： 保留</li></ol><h3 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h3><p>场景：希望从表达式的类型推断出要定义的变量类型，但是不想用改表达式的值初始化变量。decltype不实际计算表达式的值。</p><p>decltype处理顶层const和引用的方式与auto有些不同，如果decltyoe使用的表达式时一个表里，则decltype返回改变量的类型，包括顶层const和引用在内。</p><p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外。</p><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此，decltype（*p）的结果类型就是int&amp;，而非int。</p><p>decltype的表达式如果是加上括号的变量，结果是引用。</p><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名，以表示该类型对象的定义，所以分号必不可少。</p><p>可以为数据成员提供一个<strong>类内初始值</strong>，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p>头文件通常包含哪些只能被定义一次的实体。例如类、const、constexpr变量等。</p><p>确保头文件多次包含仍能安全工作的技术是<strong>预处理器</strong>，预处理器是在编译之前执行的一段程序。#include就是预处理，当预处理器看到#include标记时，就会用指定的头文件内容替换#include</p><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义、未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义。#ifdef、#ifndef、#endif。</p><p>预处理变量无视C++语言中关于作用域的规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。&lt;/p&gt;
&lt;p&gt;主要内容 ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内置类型&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;复合类型&lt;/li&gt;
&lt;li&gt;const限定符&lt;/li&gt;
&lt;li&gt;处理类型&lt;/li&gt;
&lt;li&gt;自定义数据类型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第二章变量和基本类型" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="变量和基本类型" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模板和泛型编程</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十六章 模板和泛型编程/模板和泛型编程/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-07-26T07:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有模板和泛型编程内容</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有模板和泛型编程内容&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十六章 模板和泛型编程" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="模板和泛型编程" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/set%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/set命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> 1</span><br><span class="line"><span class="built_in">command</span> 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>Every script you write should include set -e at the top. This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit.</p><p>你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。</p><p>Using -e gives you error checking for free. If you forget to check something, bash will do it for you. Unfortunately it means you can’t check $? as bash will never get to the checking code if it isn’t zero. There are other constructs you could use:</p><p>使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span>-ne <span class="number">0</span>]; then </span><br><span class="line">echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi </span><br><span class="line">could be replaced with</span><br></pre></td></tr></table></figure><p>能够被代替为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command || &#123; echo <span class="string">"command failed"</span>; <span class="keyword">exit</span> <span class="number">1</span>; &#125; </span><br><span class="line">or</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> ! command; then</span><br><span class="line"> echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>What if you have a command that returns non-zero or you are not interested in its return value? You can use command || true, or if you have a longer section of code, you can turn off the error checking, but I recommend you use this sparingly.</p><p>如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>组件化-库</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BA%93/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/IOS/库/组件化-库/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20170427/19136.html" rel="external nofollow noopener noreferrer" target="_blank">组件化-动态库实战</a>    </p><p><a href="https://blog.csdn.net/u013604612/article/details/43197465" rel="external nofollow noopener noreferrer" target="_blank">iOS开发——创建你自己的Framework</a>  </p><p><a href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" rel="external nofollow noopener noreferrer" target="_blank">iOS - Umbrella Header在framework中的应用</a></p><p><a href="https://www.jianshu.com/p/48aff237e8ff" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发中的『库』(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170427/19136.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件化-动态库实战&lt;/a&gt;    
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/IOS/%E5%BA%93/"/>
    
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/$0,$?,$!%E7%AD%89%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/linux命令/$0,$?,$!等的特殊用法/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T11:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下linux shell下的特殊用法及参数的说明.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">变量说明:</span><br><span class="line"></span><br><span class="line">$$ </span><br><span class="line">Shell本身的PID（ProcessID） </span><br><span class="line">$! </span><br><span class="line">Shell最后运行的后台Process的PID </span><br><span class="line">$? </span><br><span class="line">最后运行的命令的结束代码（返回值） </span><br><span class="line">$- </span><br><span class="line">使用Set命令设定的Flag一览 </span><br><span class="line">$* </span><br><span class="line">所有参数列表。如<span class="string">"$*"</span>用「<span class="string">"」括起来的情况、以"</span><span class="variable">$1</span> <span class="variable">$2</span> … <span class="variable">$n</span><span class="string">"的形式输出所有参数。 </span></span><br><span class="line"><span class="string"><span class="variable">$@</span> </span></span><br><span class="line"><span class="string">所有参数列表。如"</span><span class="variable">$@</span><span class="string">"用「"</span>」括起来的情况、以<span class="string">"<span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$2</span>"</span> … <span class="string">"<span class="variable">$n</span>"</span> 的形式输出所有参数。 </span><br><span class="line"><span class="variable">$#</span> </span><br><span class="line">添加到Shell的参数个数 </span><br><span class="line"><span class="variable">$0</span> </span><br><span class="line">Shell本身的文件名 </span><br><span class="line"><span class="variable">$1</span>～<span class="variable">$n</span> </span><br><span class="line">添加到Shell的各参数值。<span class="variable">$1</span>是第1参数、<span class="variable">$2</span>是第2参数…。</span><br><span class="line"></span><br><span class="line">我们先写一个简单的脚本，执行以后再解释各个变量的意义 </span><br><span class="line"><span class="comment"># touch variable </span></span><br><span class="line"><span class="comment"># vi variable </span></span><br><span class="line">脚本内容如下： </span><br><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"number:<span class="variable">$#</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scname:<span class="variable">$0</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"first :<span class="variable">$1</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"second:<span class="variable">$2</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"argume:<span class="variable">$@</span>"</span> </span><br><span class="line">保存退出 </span><br><span class="line">赋予脚本执行权限 </span><br><span class="line"><span class="comment"># chmod +x variable </span></span><br><span class="line">执行脚本 </span><br><span class="line"><span class="comment"># ./variable aa bb </span></span><br><span class="line">number:2 </span><br><span class="line">scname:./variable </span><br><span class="line">first: aa </span><br><span class="line">second:bb </span><br><span class="line">argume:aa bb </span><br><span class="line">通过显示结果可以看到： </span><br><span class="line"><span class="variable">$#</span> 是传给脚本的参数个数 </span><br><span class="line"><span class="variable">$0</span> 是脚本本身的名字 </span><br><span class="line"><span class="variable">$1</span>是传递给该shell脚本的第一个参数 </span><br><span class="line"><span class="variable">$2</span>是传递给该shell脚本的第二个参数 </span><br><span class="line"><span class="variable">$@</span> 是传给脚本的所有参数的列表</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下linux shell下的特殊用法及参数的说明.&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/export%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/export命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T11:00:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>export命令设置或显示环境变量。</p><a id="more"></a><h2 id="Linux-export-命令"><a href="#Linux-export-命令" class="headerlink" title="Linux export 命令"></a>Linux export 命令</h2><p>功能说明：设置或显示环境变量。（比如我们要用一个命令，但这个命令的执行文件不在当前目录，这样我们每次用的时候必须指定执行文件的目录，麻烦，在代码中先执行export，这个相当于告诉程序，执行某某东西时，需要的文件或什么东东在这些目录里）</p><p>语　　法：export [-fnp][变量名称]=[变量设置值]</p><p>补充说明：在shell中执行程序时，shell会提供一组环境变量。 export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。</p><p>参　　数：</p><p>-f 　代表[变量名称]中为函数名称。</p><p>　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>　<br>　-p 　列出所有的shell赋予程序的环境变量。<br>　<br>　一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。     —-《UNIX教程》<br>　<br>　<br>　<br>　在 linux 里设置环境变量的方法 （ export PATH ）<br>　<br>　一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。例如我的mips-linux-gcc编译器在“/opt/au1200_rm /build_tools/bin”目录下，build_tools就是我的编译工具，则有如下三种方法来设置环境变量：<br>　<br>　1、直接用export命令：<br>　#export PATH=$PATH:/opt/au1200_rm/build_tools/bin<br>　查看是否已经设好，可用命令export查看：<br>　<br>　<br>　<br>　[root@localhost bin]#export<br>　declare -x BASH_ENV=”/root/.bashrc”<br>　declare -x G_BROKEN_FILENAMES=”1”<br>　declare -x HISTSIZE=”1000”<br>　declare -x HOME=”/root”<br>　declare -x HOSTNAME=”localhost.localdomain”<br>　declare -x INPUTRC=”/etc/inputrc”<br>　declare -x LANG=”zh_CN.GB18030”<br>　declare -x LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN”<br>　declare -x LESSOPEN=”|/usr/bin/lesspipe.sh %s”<br>　declare -x LOGNAME=”root”<br>　declare -x LS_COLORS=”no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:<em>.cmd=01;32:</em>.exe=01;32:<em>.com=01;32:</em>.btm=01;32:<em>.bat=01;32:</em>.sh=01;32:<em>.csh=01;32:</em>.tar=01;31:<em>.tgz=01;31:</em>.arj=01;31:<em>.taz=01;31:</em>.lzh=01;31:<em>.zip=01;31:</em>.z=01;31:<em>.Z=01;31:</em>.gz=01;31:<em>.bz2=01;31:</em>.bz=01;31:<em>.tz=01;31:</em>.rpm=01;31:<em>.cpio=01;31:</em>.jpg=01;35:<em>.gif=01;35:</em>.bmp=01;35:<em>.xbm=01;35:</em>.xpm=01;35:<em>.png=01;35:</em>.tif=01;35:”<br>　declare -x MAIL=”/var/spool/mail/root”<br>　declare -x OLDPWD=”/opt/au1200_rm/build_tools”<br>　declare -x PATH=”/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin:/opt/au1200_rm/build_tools/bin”<br>　declare -x PWD=”/opt/au1200_rm/build_tools/bin”<br>　declare -x SHELL=”/bin/bash”<br>　declare -x SHLVL=”1”<br>　declare -x SSH_ASKPASS=”/usr/libexec/openssh/gnome-ssh-askpass”<br>　declare -x SSH_AUTH_SOCK=”/tmp/ssh-XX3LKWhz/agent.4242”<br>　declare -x SSH_CLIENT=”10.3.37.152 2236 22”<br>　declare -x SSH_CONNECTION=”10.3.37.152 2236 10.3.37.186 22”<br>　declare -x SSH_TTY=”/dev/pts/2”<br>　declare -x TERM=”linux”<br>　declare -x USER=”root”<br>　declare -x USERNAME=”root”<br>　<br>　可以看到灰色部分有设置的路径，说明环境变量已经设好，PATH里面已经有了我要加的编译器的路径。<br>　<br>　2、修改profile文件：<br>　#vi /etc/profile<br>　在里面加入:<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　3. 修改.bashrc文件：<br>　# vi /root/.bashrc<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下：<br>　# echo $PATH<br>　看看输出里面是不是已经有了 /my_new_path这个路径了。<br>　<br>　另有：4. 修改/etc/re.local文件：<br>　# vi /etc/re.local<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　<br>　———————————————————————————————————————–<br>　<br>　“/bin”、“/sbin”、“ /usr/bin”、“/usr/sbin”、“/usr/local/bin”等路径已经在系统环境变量中了，如果可执行文件在这几个标准位置，在终端命令行输入该软件可执行文件的文件名和参数(如果需要参数)，回车即可。<br>　<br>　　　如果不在标准位置，文件名前面需要加上完整的路径。不过每次都这样跑就太麻烦了，一个“一劳永逸”的办法是把这个路径加入环境变量。命令 export $PATH=”路径”(或“PATH=$PATH:路径”) ($PATH为环境变量名，如DVSDK；调用时用$DVSDK)可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下的“.bash_profile”只对这个用户有效。<br>　　　<br>　　　　　export $PATH=”$PATH:路径1:路径2:…:路径n” （或“PATH=$PATH:路径1:路径2:…:路径n”　），意思是可执行文件的路径包括原先设定的路径，也包括从“路径1”到“路径n”的所有路径。当用户输入一个一串字符并按回车后，shell会依次在这些路径里找对应的可执行文件并交给系统核心执行。那个“$PATH”表示原先设定的路径仍然有效，注意不要漏掉。某些软件可能还有“PATH”以外类型的环境变量需要添加，但方法与此相同，并且也需要注意“$”。<br>　　　　　<br>　　　　　　　注意，与DOS/Window不同，UNIX类系统环境变量中路径名用冒号分隔，不是分号。另外，软件越装越多，环境变量越添越多，为了避免造成混乱，建议所有语句都添加在文件结尾，按软件的安装顺序添加。<br>　　　　　　　<br>　　　　　　　　　格式如下()：<br>　　　　　　　　　<br>　　　　　　　　　　　# 软件名-版本号<br>　　　　　　　　　　　<br>　　　　　　　　　　　　　PATH=$PATH:路径1:路径 2:…:路径n<br>　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　其他环境变量=$其他环境变量:…<br>　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　在“profile”和“.bash_profile”中，“#”是注释符号，写在这里除了视觉分隔外没有任何效果。<br>　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　设置完毕，注销并重新登录，设置就生效了。如果不注销，直接在shell里执行这些语句，也能生效，但是作用范围只限于执行了这些语句的shell。<br>　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　相关的环境变量生效后，就不必老跑到软件的可执行文件目录里去操作了。<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　———————————————————————————————————————–<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　 执行一个脚本时，会先开启一个子shell环境（不知道执行其它程序是不是这样），然后将父shell中的所有系统环境变量复制过来，这个脚本中的语句就在子shell中执行。（也就是说父shell的环境变量在子shell中可以调用，但反过来就不行，如果在子shell中定义了环境变量，则只对该shell或者它的子shell有效，当该子shell结束时，也可以理解为脚本执行完时，变量消失。）为了证明这一点，请看脚本内容：<br>　　　　　　　　　　　　　　　　　　　　　　 　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　这样的脚本执行完后，test实际上是不存在的。接着看下面的：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　bash<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　这里在脚本最后一行再开一个子shell，该shell应该是脚本文件所在shell的子shell，这个脚本执行完后，是可以看到test这个变量的，因为现在是处于它的子shell中，当用exit退出子shell后，test变量消失。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　如果用source对脚本进行执行时，如果不加export，就不会在子shell中看到这个变量，因为它还不是一个系统环境变量呀，如脚本内容是：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　用source执行后，在shell下是能看到这个变量，但再执行bash开一个子shell时，test是不会被复制到子shell中的，因为执行脚本文件其实也是在一个子shell中运行，所以我再建另一个脚本文件执行时，是不会输入任何东西的，内容如：echo $test。所以这点特别注意了，明明在提示符下可以用echo $test输出变量值，为什么把它放进脚本文件就不行了呢？<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　所以得出的结论是：1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；2、一个shell中的系统环境变量才会被复制到子shell中（用export定义的变量）；3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。3、不用export定义的变量只对该shell有效，对子shell也是无效的。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　　　后来根据版主的提示，整理了一下贴子：为什么一个脚本直接执行和用source执行不一行呢？这也是我自己碰到的一个问题。manual原文是这样的：Read and execute commands from filename in the current shell environment and return the exit status of the last command executed from filename.明白了为什么不一样了吧？直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;export命令设置或显示环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>static关键字作用总结(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/static/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字理解/static/</id>
    <published>2018-07-17T10:07:12.000Z</published>
    <updated>2018-07-17T10:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。</p><a id="more"></a><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%c "</span>, a);</span><br><span class="line">     (<span class="keyword">void</span>)msg();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span> Hello</span><br></pre></td></tr></table></figure><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h2 id="内容持久化（static变量中的记忆功能和全局生存期）"><a href="#内容持久化（static变量中的记忆功能和全局生存期）" class="headerlink" title="内容持久化（static变量中的记忆功能和全局生存期）"></a>内容持久化（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><p>程序举例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fun()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>--; <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     printf(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">     <span class="keyword">for</span>(; <span class="keyword">count</span> &lt;= <span class="number">10</span>; ++<span class="keyword">count</span>)</span><br><span class="line">               printf(<span class="string">"%d\t\t%d\n"</span>, <span class="keyword">count</span>, fun());</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">global  local static</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h2 id="默认初始化为0"><a href="#默认初始化为0" class="headerlink" title="默认初始化为0"></a>默认初始化为0</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"integer: %d; string: (begin)%s(end)"</span>, a, str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">integer</span>: <span class="number">0</span>; <span class="keyword">string</span>: (<span class="keyword">begin</span>) (<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h2 id="C-中的类成员声明static"><a href="#C-中的类成员声明static" class="headerlink" title="C++中的类成员声明static"></a>C++中的类成员声明static</h2><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </li><li>不能将静态成员函数定义为虚函数。      </li><li>由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</li><li>由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）</li><li>static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。</li><li>静态数据成员在&lt;定义或说明&gt;时前面加关键字static。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）</li><li><p>静态成员初始化与一般数据成员初始化不同:</p><p> 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；</p><pre><code>所以我们得出静态数据成员初始化的格式：</code></pre><p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p></li><li><p>为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p></li></ol><h2 id="转载地址"><a href="#转载地址" class="headerlink" title="转载地址"></a>转载地址</h2><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" rel="external nofollow noopener noreferrer" target="_blank">C++中static关键字作用总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字理解" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>explicit实例浅析(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/explicit-learn/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字理解/explicit-learn/</id>
    <published>2018-07-16T01:07:12.000Z</published>
    <updated>2018-07-16T03:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。</p><a id="more"></a><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>按默认规定，只用传一个参数的构造函数也定义了一个隐式转换。举个例子：<br>（下面这个CExample没有什么实际的意义，主要是用来说明问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iFirst;</span><br><span class="line"><span class="keyword">int</span> m_iSecond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Example.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StdAfx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line">CExample::CExample(<span class="keyword">void</span>)</span><br><span class="line">: m_iFirst(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::~CExample(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond):m_iFirst(iFirst), m_iSecond(iSecond)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TestExplicitKey.cpp</span></span><br><span class="line">...<span class="comment">//其它头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CExample objOne; <span class="comment">//调用没有参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objTwo</span><span class="params">(<span class="number">12</span>, <span class="number">12</span>)</span></span>; <span class="comment">//调用有两个参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objThree</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">//同上，可以传一个参数是因为该构造函数的第二个参数有默认值</span></span><br><span class="line">CExample objFour = <span class="number">12</span>; <span class="comment">//执行了隐式转换,等价于CExample temp(12);objFour(temp);注意这个地方调用了</span></span><br><span class="line"><span class="comment">//编译器为我们提供的默认复制构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在构造函数声明中加入关键字explicit，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CExample</span><span class="params">(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么CExample objFour = 12; 这条语句将不能通过编译。在vs05下的编译错误提示如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error C2440: <span class="string">'initializing'</span> : cannot convert <span class="keyword">from</span> <span class="string">'int'</span> <span class="keyword">to</span> <span class="string">'CExample'</span></span><br><span class="line">    <span class="function"><span class="keyword">Constructor</span> <span class="title">for</span> <span class="title">class</span> '<span class="title">CExample</span>' <span class="title">is</span> <span class="title">declared</span> '<span class="title">explicit</span>'</span></span><br></pre></td></tr></table></figure><h2 id="explicit意义"><a href="#explicit意义" class="headerlink" title="explicit意义"></a>explicit意义</h2><p>对于某些类型，这一情况非常理想。<font color="blue">但在大部分情况中，隐式转换却容易导致错误（不是语法错误，编译器不会报错）。隐式转换总是在我们没有察觉的情况下悄悄发生，除非有心所为，隐式转换常常是我们所不希望发生的。通过将构造函数声明为explicit（显式）的方式可以抑制隐式转换。也就是说，explicit构造函数必须显式调用。</font><br>引用一下Bjarne Stroustrup的例子:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">String</span>&#123;</span><br><span class="line">   <span class="keyword">explicit</span> <span class="keyword">String</span>(<span class="keyword">int</span> n);</span><br><span class="line">   <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="string">'a'</span>; <span class="comment">//错误：不能做隐式char-&gt;String转换</span></span><br><span class="line"><span class="keyword">String</span> s2(<span class="number">10</span>);  <span class="comment">//可以：调用explicit String(int n);</span></span><br><span class="line"><span class="keyword">String</span> s3 = <span class="keyword">String</span>(<span class="number">10</span>);<span class="comment">//可以：调用explicit String(int n);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s4 = <span class="string">"Brian"</span>; <span class="comment">//可以：隐式转换调用String(const char *p);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s5(<span class="string">"Fawlty"</span>); <span class="comment">//可以：正常调用String(const char *p);</span></span><br><span class="line"><span class="keyword">void</span> f(<span class="keyword">String</span>);</span><br><span class="line"><span class="keyword">String</span> g()</span><br><span class="line">&#123;</span><br><span class="line">  f(<span class="number">10</span>); <span class="comment">//错误：不能做隐式int-&gt;String转换</span></span><br><span class="line">  f(<span class="string">"Arthur"</span>); <span class="comment">//可以：隐式转换，等价于f(String("Arthur"));</span></span><br><span class="line">  <span class="built_in">return</span> <span class="number">10</span>; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际代码中的东西可不像这种故意造出的例子。<br>发生隐式转换，除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。<br>原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。</p><p>原文链接：<a href="http://blog.csdn.net/chollima/article/details/3486230" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chollima/article/details/3486230</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字理解" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="explicit" scheme="http://yoursite.com/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十五章 面向对象程序设计/面向对象程序设计/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-19T10:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有虚函数、访问控制等内容</p><a id="more"></a><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>静态类型和动态类型</p><ol><li>通过使用数据抽象，可以将类的接口和实现分离</li><li>使用继承可以定义相似类型并对相似类型建模</li><li>使用动态绑定，可以忽略相似类型的区别，而用统一的方式使用对象</li></ol><p>当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。</p><ol><li>成员函数如果没用被声明为虚函数，解析过程发生在编译时候</li><li>成员函数声明为虚函数，根据调用指针在运行的时候确定调用的版本。</li></ol><p>派生类显示的著名他使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字。</p><p>回避虚函数使用：在函数名前加作用域运算符。</p><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ol><li>protected用来声明希望与派生类共享、但不被共有访问的成员。</li><li>派生类成员和友元只能通过派生类对象访问基类的受保护的成员。</li><li>protected成员对于派生类和友元来说可以访问。</li><li>protected对于类的用户来说不可访问。</li></ol><p>某个类对其继承而来的成员的访问权限收到两个因素的影响：</p><ol><li>基类中该成员的访问说明符</li><li>派生列表中派生访问说明符</li></ol><p>爸爸受保护的属性，儿子的小三（友元）想通过儿子窃取，不行（友元不能传递）</p><p>爸爸受保护的属性，爸爸的小三想通过儿子获取，可以（谁的小三就能获取到谁的保护属性，小三具有破坏性）</p><p>派生类的作用域位于基类的作用域内</p><ol><li>class的访问说明符、派生访问说明符默认都是private</li><li>struct的访问说明符、派生访问说明符默认都是public的</li></ol><p>两个角度理解访问控制：</p><ol><li>普通用户</li><li>实现者</li></ol><p>派生类的成员隐藏同名的基类成员。</p><p>使用作用域运算符来使用一个被隐藏的基类成员</p><p>除了覆盖继承而来的虚函数，派生类最好不用重新定义其他在基类中名字</p><p>函数调用解析过程</p><p>假如我们调用p-&gt;mem()，</p><ol><li>确定p的静态类型</li><li>在静态类型对应的类中找mem</li><li>找到后判断是否虚函数，是产生虚函数调用版本、不是编译器产生常规调用版本。</li></ol><p>名字查找先于类型检测</p><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>析构函数定义成虚函数，确保删除指针能执行正确的版本。</p><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有虚函数、访问控制等内容&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十五章 面向对象程序设计" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象程序设计" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>拷贝控制</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十三章/拷贝控制/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-13T11:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们将学到：拷贝、赋值、移动、销毁做什么？</p><ol><li>拷贝构造函数  </li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li><li>析构函数</li></ol><p>函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。</p><p>如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。</p><a id="more"></a><h2 id="拷贝、赋值、销毁"><a href="#拷贝、赋值、销毁" class="headerlink" title="拷贝、赋值、销毁"></a>拷贝、赋值、销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   plublic:</span><br><span class="line">   Foo(canst Foo&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h4><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。</p><p>合成拷贝构造函数如何拷贝：</p><ol><li>类类型：使用其拷贝构造函数来拷贝</li><li>内置类型：直接拷贝</li><li>数组：逐个拷贝数组成员</li></ol><p>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig):</span><br><span class="line"><span class="function"><span class="title">bookNO</span><span class="params">(orig.bookNO)</span></span>,</span><br><span class="line"><span class="function"><span class="title">units_sold</span><span class="params">(orig.units_sold)</span></span>,</span><br><span class="line"><span class="function"><span class="title">revenue</span><span class="params">(orig.revenue)</span></span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><ol><li>直接初始化：我们实际上要求编译器用普通的函数匹配类选择与我们提供的参数最匹配的构造函数</li><li>拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。</li></ol><p>拷贝初始化发生的场景：</p><ol><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li><li>insert 、push（emplace 直接初始化）</li></ol><h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>当一个函数具有非引用类型的返回值类型时，返回值会被用来初始化调用方的结果</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。<br>如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;);</span><br></pre></td></tr></table></figure></p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">booNO = rhs.bookNO;</span><br><span class="line">units_sold = rhs.units_sold;</span><br><span class="line">revenue = rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>构造函数初始化对象的非static数据成员。</li><li>析构函数释放对象使用的资源，并销毁对象的非静态成员。</li></ol><p>析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">~Foo()</span>;</span><br></pre></td></tr></table></figure></p><ol><li>在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。</li><li>在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。</li></ol><p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。</p><p>什么时候会调用析构函数：</p><ol><li>变量在离开其作用域时</li><li>对象被销毁，其成员被销毁</li><li>容器被销毁，其成员被销毁</li><li>动态分配的对象，delete 运算符时会被销毁</li><li>对于临时对象，当创建他的完整表达式结束时被销毁</li></ol><p><font color="red">析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的</font></p><h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><p>需要析构函数的类也需要拷贝和赋值。<br>需要拷贝操作的类也需要赋值操作。</p><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。</p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。<br>删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。</p><p>=default 、=delete区别：</p><ol><li>=delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。</li><li>可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。</li></ol><p>析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。</p><p>对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。</p><p>合成的拷贝成员可能是删除的：如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。</p><p>对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，次运算符视图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。</p><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>管理类外资源的类必须定义拷贝控制函数。</p><ol><li>类值拷贝</li><li>类指针拷贝</li></ol><p>赋值运算符通常组合了析构函数和构造函数的操作。类型析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">//拷贝底层String</span></span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">//是否旧内存</span></span><br><span class="line">ps = newp;</span><br><span class="line">i=rhs.i;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它吱声，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</p><p>引用计数的工作方式：</p><ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li><li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。</li><li>析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将学到：拷贝、赋值、移动、销毁做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拷贝构造函数  &lt;/li&gt;
&lt;li&gt;拷贝赋值运算符&lt;/li&gt;
&lt;li&gt;移动构造函数&lt;/li&gt;
&lt;li&gt;移动赋值运算符&lt;/li&gt;
&lt;li&gt;析构函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么&lt;br&gt;运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。&lt;/p&gt;
&lt;p&gt;如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十三章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    
    
      <category term="拷贝控制" scheme="http://yoursite.com/tags/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>为什么`forward_list`不支持`push_back`操作？</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/forward_list%E4%B8%8D%E6%94%AF%E6%8C%81push_back%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/forward_list不支持push_back操作/</id>
    <published>2018-06-27T02:07:12.000Z</published>
    <updated>2018-06-27T02:40:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么forward-list不支持push-back操作？"><a href="#为什么forward-list不支持push-back操作？" class="headerlink" title="为什么forward_list不支持push_back操作？"></a>为什么forward_list不支持push_back操作？</h2><p>由于forward_list是单向链表，所以我们如果想要访问尾元素，都要从首元素开始跌代，算法复杂度为O(n)。而对于list为双向链表，直接通过尾指针可以访问尾元素，实现在尾元素添加元素，函数复杂度为O(1)，而vector，string,deque,也可以通过尾指针来添加元素，函数复杂度为O(1)。</p><p>同样的原因也有forward_list不支持pop_back。<br>由于类似原因(算法的复杂度)，有vector，string，不支持push_front，pop_front，但是通过insert，和erase操作仍然可以完成添加/删除首元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么forward-list不支持push-back操作？&quot;&gt;&lt;a href=&quot;#为什么forward-list不支持push-back操作？&quot; class=&quot;headerlink&quot; title=&quot;为什么forward_list不支持push_back操作？&quot;&gt;
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="forward_list" scheme="http://yoursite.com/tags/forward-list/"/>
    
  </entry>
  
  <entry>
    <title>容器基本操作</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/容器基本操作/</id>
    <published>2018-06-26T08:07:12.000Z</published>
    <updated>2018-06-26T08:19:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文列举C++中容器的通用操作。来源于C++ primer</p><a id="more"></a><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不使用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文列举C++中容器的通用操作。来源于C++ primer&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="容器操作" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库中的list的实现原理</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/list/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84list%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/C++语言/container/list/C++标准库中的list的实现原理/</id>
    <published>2018-06-26T07:07:12.000Z</published>
    <updated>2018-06-26T07:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/loveyou11111111/article/details/49763197" rel="external nofollow noopener noreferrer" target="_blank">C++标准库中的list的实现原理</a></p><a id="more"></a><p>在C++中采用了大量的标志模板库（STL）实现程序的设计，这种设计方式使得不同类型的对象都能通用，而不再是C语言中的通常对于不同的类型需要重新设计或者或者比较采用间接的指针操作。C++中的这种方式简化了写代码的复杂度，但是增加了编译器的复杂度和难度。</p><p>在数据结构中链表是比较基本的类型，在C++中链表是基于模板的类，因此在实际的使用过程中需要涉及到实际的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lint;</span><br></pre></td></tr></table></figure><p>在C++中关于list的接口比较丰富，主要是关于大小，数据的插入、删除等。但是在C++中引入了迭代器的概念，这个迭代器是关于关于容器中比较重要的一部分，因为这种迭代器使得算法等问题与容器独立开来，迭代器实质上还是指针，准确的将是一个封装了指针的类。</p><p>迭代器类的创建应该包含下面的操作，首先应该支持的操作符至少包括如下（operator*()，operator++()，operator++(int)，operator==()， operator!=()）,当然也会存在const_iterator这样的常迭代器，也就是只允许访问，不能修改对象的迭代器，当然存在迭代器的构造函数、复制控制函数，这些函数都是必须要存在的，因为设计到了指针的操作问题，构造函数应该存在参数是链表节点指针的定义，只有存在这个定义才能间接的访问节点对象。<br>当然在类中至少存在返回迭代器的begin()和end()函数，这两个函数返回的迭代器分别指向链表的开始和链表结束的下一个地址，这是迭代器中经常容易理解错误的地方。</p><p>在C++中通常创建const_iterator类，然后iterator直接继承const_iterator。</p><p>下面说说list类设计的基本思路：<br>首先、创建链表节点对象，实质上是完成对传递进来的类型的封装操作，同时构成一个双向链表的基本要素（prev、next指针）。节点肯定要存在构造函数，而且是直接初始化三个成员变量。<br>其次、创建迭代器类，实质上就是封装一个节点指针，通过节点指针实现操作，至少要实现的操作符已说明。这两个类都要设置List为友元类，因为这样才能用List直接操作迭代器的相关操作。<br>最后、依靠上面的迭代器类和节点类，创建一个List类，该类中主要完成一些基本操作。其中需要注意的就是迭代器的操作，比如删除元素和插入元素以后迭代器的变化问题等。</p><p>需要注意的是在List中采用了哨兵节点，这个哨兵节点并不算实际的操作对象，也就是为了保证肯定有目标所指向，存在一个head对象，这个对象的next就是实际的数据，而tail是迭代器所能到达的最后一个对象，但是这个对象并不是合理的区域，实际上end()实际上就是指向了tail节点，这两个节点head和tail就是哨兵节点。具体的参看代码。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>实现的基本形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYLIST_H_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYLIST_H_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        templateObject&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*封装对象，形成链表节点*/</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                        Object data;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*节点构造函数*/</span></span><br><span class="line">                        Node(<span class="keyword">const</span> Object &amp;d = Object(), Node *p = <span class="literal">NULL</span>, Node *n = <span class="literal">NULL</span>)</span><br><span class="line">                        :data(d), prev(p), next(n)&#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">/*创建一个常量迭代器类，这是容器设计的关键*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">const_iterator</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        const_iterator():current(<span class="literal">NULL</span>)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*重载迭代器的值*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object &amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载前向++操作符*/</span></span><br><span class="line">                        const_iterator &amp; <span class="keyword">operator</span>++ ()</span><br><span class="line">                        &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载后向++操作符，因为是一个局部对象不能返回引用*/</span></span><br><span class="line">                        const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                const_iterator old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*判断迭代器是否相同，实质上就是判断指向的节点是否相同*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> const_iterator &amp;rhs) <span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> current == rhs.current;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*调用==操作符*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> const_iterator &amp;rhs)<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> (!(*<span class="keyword">this</span> == rhs));</span><br><span class="line">                        &#125;</span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*迭代器实质就是一个节点指针*/</span></span><br><span class="line">                        Node *current;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*获得链表中的内容*/</span></span><br><span class="line">                        <span class="function">Object &amp; <span class="title">retrieve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">                        </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于指针参数的迭代器构造函数，保证只有List使用*/</span></span><br><span class="line">                        const_iterator(Node *p):current (p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*友元类，可以调用迭代器的私有成员*/</span></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*一般迭代器，直接继承const_iterator*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> :</span> <span class="keyword">public</span> const_iterator</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        iterator():const_iterator()</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*得到对象的值*/</span></span><br><span class="line">                        Object &amp;<span class="keyword">operator</span>*()</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于const的重载*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> const_iterator::<span class="keyword">operator</span>*();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*前向++操作符*/</span></span><br><span class="line">                        iterator &amp;<span class="keyword">operator</span>++()</span><br><span class="line">                       &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*后向++操作符*/</span></span><br><span class="line">                        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                iterator *old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*基于节点的迭代器构造函数*/</span></span><br><span class="line">                        iterator(Node *p):const_iterator(p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                List()</span><br><span class="line">                &#123;</span><br><span class="line">                        init();</span><br><span class="line">                &#125;</span><br><span class="line">                ~List()</span><br><span class="line">                &#123;</span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="keyword">delete</span> head;</span><br><span class="line">                        <span class="keyword">delete</span> tail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                       <span class="comment">/*创建哨兵节点*/</span></span><br><span class="line">                        init();</span><br><span class="line">                        <span class="comment">/*复制数据*/</span></span><br><span class="line">                        *<span class="keyword">this</span> = rhs;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> List &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        <span class="comment">/*清除原有的信息*/</span></span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="comment">/*添加新的对象*/</span></span><br><span class="line">                        <span class="keyword">for</span>(const_iterator itr = rhs.begin(); itr != rhs.end(); ++ itr)</span><br><span class="line">                                push_back(*itr);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到迭代器，实质上就是得到节点指针*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*iterator()是构造函数*/</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> theSize;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>( !empty())</span><br><span class="line">                                pop_front();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到第一个元素*/</span></span><br><span class="line">                <span class="function">Object &amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*采用了迭代器begin()*/</span></span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">front</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">Object &amp;<span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*end()指向最后一个对象的下一个地址，因此需要--*/</span></span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">back</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">                *从头插入新的节点，这时候的begin已经不再是begin</span></span><br><span class="line"><span class="comment">                *因此插入操作会导致迭代器出错</span></span><br><span class="line"><span class="comment">                ***********************************************/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(begin(), x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*从后插入新的节点，这时候会将end后移*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(end(), x);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*从头弹出一个对象*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        erase(begin());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                       erase(--end());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*插入对象，参数是迭代器和数据*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">insert</span><span class="params">(iterator itr, <span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        theSize ++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        *Node *np = Node(x,p-&gt;prev,p);</span></span><br><span class="line"><span class="comment">                        this means that np-&gt;prev = p-&gt;prev,</span></span><br><span class="line"><span class="comment">                        and np-&gt;next = p;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        update the p-&gt;prev and p-&gt;prev-&gt;next;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev-&gt;next = np;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev = np;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(p-&gt;prev=p-&gt;prev-&gt;next= <span class="keyword">new</span> Node(x,p-&gt;prev, p));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器处的对象,因此删除也会导致迭代器破坏*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator itr)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        <span class="comment">/*得到新的迭代器，并初始化*/</span></span><br><span class="line">                        <span class="function">iterator <span class="title">retVal</span><span class="params">(p-&gt;next)</span></span>;</span><br><span class="line">                        <span class="comment">/*更新链表的链接关系*/</span></span><br><span class="line">                        p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">                        p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">                        <span class="comment">/*删除对象*/</span></span><br><span class="line">                        <span class="keyword">delete</span> p;</span><br><span class="line">                        <span class="comment">/*使得对象数减少*/</span></span><br><span class="line">                        theSize --;</span><br><span class="line">                        <span class="comment">/*返回新的迭代器*/</span></span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器指向的对象*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator start, iterator end)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*for中不使用++itr的原因是erase之后</span></span><br><span class="line"><span class="comment">                         *就是下一个迭代器，因此不需要++操作*/</span></span><br><span class="line">                        <span class="keyword">for</span>(iterator itr = start; itr != end; )</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">/*该操作会导致迭代器更新到下一个*/</span></span><br><span class="line">                                itr = erase(itr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> itr;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*链表中的数据成员*/</span></span><br><span class="line">                <span class="keyword">int</span> theSize;</span><br><span class="line">                Node *head;</span><br><span class="line">                Node *tail;</span><br><span class="line">                <span class="comment">/*初始化函数*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        theSize = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">/*create two sentinel node*/</span></span><br><span class="line">                        <span class="comment">/*构建两个哨兵节点，也就是两个并不算在结构体中的对象*/</span></span><br><span class="line">                        head = <span class="keyword">new</span> Node;</span><br><span class="line">                        tail = <span class="keyword">new</span> Node;</span><br><span class="line">                        <span class="comment">/*绑定起来*/</span></span><br><span class="line">                        head-&gt;next = tail;</span><br><span class="line">                        tail-&gt;prev = head;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/loveyou11111111/article/details/49763197&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;C++标准库中的list的实现原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="list" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/list/"/>
    
    
      <category term="list" scheme="http://yoursite.com/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>deque的实现原理和使用方法详解</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/deque/deque%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/</id>
    <published>2018-06-26T02:07:12.000Z</published>
    <updated>2018-06-26T07:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a>。只用于本人学习。</p><a id="more"></a><h2 id="Deque-简介"><a href="#Deque-简介" class="headerlink" title="Deque 简介"></a>Deque 简介</h2><ol><li>deque是“double—ended queue”的缩写，和vector一样都是STL的容器，deque 是双端数组，而 vector 是单端的。</li><li>deque 在接口上和 vector 非常相似，在许多操作的地方可以直接替换。</li><li>deque 可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法，这个等下会详讲）。</li><li>deque 头部和尾部添加或移除元素都非常快速。但是在中间插入元素或移除元素比较费时。</li><li>使用时需要包含头文件 #include<deque> 。</deque></li></ol><h2 id="Deque-实现原理"><a href="#Deque-实现原理" class="headerlink" title="Deque 实现原理"></a>Deque 实现原理</h2><h3 id="deque-的中控器"><a href="#deque-的中控器" class="headerlink" title="deque 的中控器"></a>deque 的中控器</h3><p>deque是连续空间（至少逻辑上看来如此），连续线性空间总令我们联想到array或vector。<strong>array无法成长，vector虽可成长</strong>，却只能向尾端成长，而且其所谓的成长原是个假象，事实上是<font color="blue"><strong>（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。</strong></font>如果不是vector每次配置新空间时都有留下一些余裕，其成长假象所带来的代价将是相当高昂。</p><font color="blue"><strong>deque系由一段一段的定量连续空间构成。</strong></font>一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。<br><br>受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。<br><br><font color="blue"><strong>deque采用一块所谓的map作为主控</strong>。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，<strong>指向另一段（较大的）连续线性空间，称为缓冲区</strong>。<strong>缓冲区才是deque的储存空间主体</strong>。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。</font><p>deque的整体架构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequeStruct.png" alt="deque的整体架构"></p><h3 id="deque-的迭代器"><a href="#deque-的迭代器" class="headerlink" title="deque 的迭代器"></a>deque 的迭代器</h3><p>让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针，分别为cur, first, last, node。</p><p>指针结构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequePointer.png" alt="指针结构"></p><p>在上面介绍中我们大致了解了deque 的基本概念和实现原理，现在我就开始介绍如何使用 deque。</p><h2 id="deque-使用"><a href="#deque-使用" class="headerlink" title="deque 使用"></a>deque 使用</h2><h3 id="deque-对象的默认构造"><a href="#deque-对象的默认构造" class="headerlink" title="deque 对象的默认构造"></a>deque 对象的默认构造</h3><p>deque 采用模板类实现，deque 对象的默认构造形式：deque<t> dequeT；   </t></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deqInt;            <span class="comment">//一个存放int的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">float</span>&gt; deqFloat;       <span class="comment">//一个存放float的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; deqString;     <span class="comment">//一个存放string的deque容器。  </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>尖括号内还可以设置指针类型或自定义类型。</p><h3 id="deque-元素添加移除操作"><a href="#deque-元素添加移除操作" class="headerlink" title="deque 元素添加移除操作"></a>deque 元素添加移除操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.push_back(elem);       <span class="comment">//在容器尾部添加一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.push_front(elem);     <span class="comment">//在容器头部插入一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_back();           <span class="comment">//删除容器最后一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_front();          <span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-的数据存取"><a href="#deque-的数据存取" class="headerlink" title="deque 的数据存取"></a>deque 的数据存取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.at(idx);    <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。  </span></span><br><span class="line"><span class="built_in">deque</span>[idx];      <span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。  </span></span><br><span class="line"><span class="built_in">deque</span>.front();   <span class="comment">//返回第一个数据。  </span></span><br><span class="line"><span class="built_in">deque</span>.back();    <span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-与迭代器"><a href="#deque-与迭代器" class="headerlink" title="deque 与迭代器"></a>deque 与迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.begin();  <span class="comment">//返回容器中第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.end();  <span class="comment">//返回容器中最后一个元素之后的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rbegin();  <span class="comment">//返回容器中倒数第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rend();   <span class="comment">//返回容器中倒数最后一个元素之后的迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="deque-对象的带参数构造"><a href="#deque-对象的带参数构造" class="headerlink" title="deque 对象的带参数构造"></a>deque 对象的带参数构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(beg,end);    <span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);   <span class="comment">//构造函数将n个elem拷贝给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);  <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的赋值"><a href="#deque-的赋值" class="headerlink" title="deque 的赋值"></a>deque 的赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.assign(beg,end);   <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>.assign(n,elem);  <span class="comment">//将n个elem拷贝赋值给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); <span class="comment">//重载等号操作符   </span></span><br><span class="line"><span class="built_in">deque</span>.swap(deq);  <span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD;  </span><br><span class="line">deqIntA.push_back(<span class="number">1</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">3</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">5</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">7</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">9</span>);  </span><br><span class="line">  </span><br><span class="line">deqIntB.assign(deqIntA.begin(),deqIntA.end());  <span class="comment">// 1 3 5 7 9  </span></span><br><span class="line">      </span><br><span class="line">deqIntC.assign(<span class="number">5</span>,<span class="number">8</span>);        <span class="comment">//8 8 8 8 8  </span></span><br><span class="line">  </span><br><span class="line">deqIntD = deqIntA;      <span class="comment">//1 3 5 7 9  </span></span><br><span class="line">  </span><br><span class="line">deqIntC.swap(deqIntD);      <span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h3 id="deque-的大小"><a href="#deque-的大小" class="headerlink" title="deque 的大小"></a>deque 的大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();      <span class="comment">//返回容器中元素的个数  </span></span><br><span class="line"><span class="built_in">deque</span>.empty();     <span class="comment">//判断容器是否为空  </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);   <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。  </span></span><br><span class="line">                    <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。     </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。  </span></span><br><span class="line">                        <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的插入"><a href="#deque-的插入" class="headerlink" title="deque 的插入"></a>deque 的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.insert(pos,elem);   <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,n,elem);   <span class="comment">//在pos位置插入n个elem数据，无返回值。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,beg,end);   <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的删除"><a href="#deque-的删除" class="headerlink" title="deque 的删除"></a>deque 的删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.clear();  <span class="comment">//移除容器的所有数据  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(beg,end);  <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(pos);    <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> 让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针。<br>在进行迭代器的移动时，需要考虑跨缓冲区的情况。</p><p>重载前加(减)，在实现后加(减)时，调用重载的前加(减)。<br>重载+=,实现+时，直接调用+=,实现-=时，调用+=负数，实现-时，调用-=.<br>//当需要实现新的功能时，最好使用已经重载好的操作，即方便有安全。。。。</p><p>另外，deque在效率上来说是不够vector好的，因此有时候在对deque进行sort的时候，需要先将元素移到vector再进行sort，然后移回来。</p><p>构造函数：根据缓冲区设置大小和元素个数，决定map的大小；给map分配空间，根据缓冲区的个数，分配缓冲区，默认指定一个缓冲区；<br> 设置start和finish迭代器，满足左闭右开的原则。<br> push_back:如果空间满足，直接插入；不满足，调用push_back_aux。<br> push_back_aux:先调用reverse_map_at_back,若符合某种条件，重换一个map；分配空间。<br> reserve_map_at_back:看看map有没有满，满的话，调用reallocate_map。<br> reallocate_map:如果前端或后端pop过多，就会导致大量的空闲空间，如果是这种情况，则不用新分配空间，调整一下start的位置即可；<br> 如果不够，则需要重新申请空间。<br> pop：析构元素，如果是最后一块还需要删除空间。<br> erase：需要判断，前面的元素少还是后面的元素少，移动较少的部分。<br> insert：判断位置，如果为前端或后端直接调用push操作，否则，移动较少的一端。</p><p>deque的构造与内存管理：</p><p>由于deque的设计思想就是由一块块的缓存区连接起来的，因此它的内存管理会比较复杂。插入的时候要考虑是否要跳转缓存区、是否要新建map节点（和vector一样，其实是重新分配一块空间给map，删除原来空间）、插入后元素是前面元素向前移动还是后面元素向后面移动（谁小移动谁）。而在删除元素的时候，考虑是将前面元素后移覆盖需要移除元素的地方还是后面元素前移覆盖（谁小移动谁）。移动完以后要析构冗余的元素，释放冗余的缓存区。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//   deque的特性:  </span></span><br><span class="line"><span class="regexp">//</span>   对于任何一个迭代器i  </span><br><span class="line"><span class="regexp">//     i.node是map array中的某元素的地址. i.node的内容是一个指向某个结点的头的指针  </span></span><br><span class="line"><span class="regexp">//</span>     i.first == *(i.node)  </span><br><span class="line"><span class="regexp">//     i.last  == i.first + node_size  </span></span><br><span class="line"><span class="regexp">//</span>     i.cur是一个指向[i.first, i.last)之间的指针  </span><br><span class="line"><span class="regexp">//       注意: 这意味着i.cur永远是一个可以解引用的指针,  </span></span><br><span class="line"><span class="regexp">//</span>            即使其是一个指向结尾后元素的迭代器  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   起点和终点总是非奇异(nonsingular)的迭代器.  </span><br><span class="line"><span class="regexp">//     注意: 这意味着空deque一定有一个node, 而一个具有N个元素的deque  </span></span><br><span class="line"><span class="regexp">//</span>          (N是Buffer Size)一定有有两个nodes  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   对于除了start.node和finish.node之外的每一个node, 每一个node中的元素  </span><br><span class="line"><span class="regexp">//   都是一个初始化过的对象. 如果start.node == finish.node,  </span></span><br><span class="line"><span class="regexp">//</span>   那么[start.cur, finish.cur)都是未初始化的空间.  </span><br><span class="line"><span class="regexp">//   否则, [start.cur, start.last)和[finish.first, finish.cur)都是初始化的对象,  </span></span><br><span class="line"><span class="regexp">//</span>   而[start.first, start.cur)和[finish.cur, finish.last)是未初始化的空间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   [map, map + map_size)是一个合法的非空区间  </span><br><span class="line"><span class="regexp">//   [start.node, finish.node]是内含在[map, map + map_size)区间的合法区间  </span></span><br><span class="line"><span class="regexp">//</span>   一个在[map, map + map_size)区间内的指针指向一个分配过的node,  </span><br><span class="line"><span class="regexp">//   当且仅当此指针在[start.node, finish.node]区间内  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">inline size_t __deque_buf_size(size_t n, size_t sz)    </span></span><br><span class="line"><span class="regexp">&#123;    </span></span><br><span class="line"><span class="regexp">  return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));    </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> __deque_iterator的数据结构  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;  </span></span><br><span class="line">struct __deque_iterator  </span><br><span class="line">&#123;  </span><br><span class="line">    typedef __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">    typedef __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">    static size_t buffer_size() &#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, sizeof(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">    typedef random_access_iterator_tag iterator_category;  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef Ptr pointer;  </span><br><span class="line">    typedef Ref reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">    typedef T** map_pointer;  </span><br><span class="line">  </span><br><span class="line">    typedef __deque_iterator self;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 保持与容器的联结  </span></span><br><span class="line"><span class="regexp">    T* cur;       //</span> 此迭代器所指之缓冲区中的现行元素  </span><br><span class="line">    T* first;     <span class="regexp">// 此迭代器所指之缓冲区的头  </span></span><br><span class="line"><span class="regexp">    T* last;      //</span> 此迭代器所指之缓冲区的尾（含备用空间）  </span><br><span class="line">    map_pointer node;    <span class="regexp">// 指向管控中心  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 这个是deque内存管理的关键, 其模型如下  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------  </span><br><span class="line"><span class="regexp">// map--&gt;|   |   |   |   |   |   | ..... |   |   |   |&lt;------------------  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------                  |  </span><br><span class="line"><span class="regexp">//             |                                                        |  </span></span><br><span class="line"><span class="regexp">//</span>             |                                                        |  </span><br><span class="line"><span class="regexp">//             |   node                                                 |  </span></span><br><span class="line"><span class="regexp">//</span>             |   缓冲区buffer, 这里实际存储元素                          |  </span><br><span class="line"><span class="regexp">//             |   ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>             -<span class="function">--&gt;</span>|   |   |   |   |   |   | ..... |   |   | X |        |  </span><br><span class="line"><span class="regexp">//                 ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>                   ↑       ↑                             ↑            |  </span><br><span class="line"><span class="regexp">//             ------        |                             |            |  </span></span><br><span class="line"><span class="regexp">//</span>             |             |                             |            |  </span><br><span class="line"><span class="regexp">//             |   -----------   ---------------------------            |  </span></span><br><span class="line"><span class="regexp">//</span>             ----|-----        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>                 |    |        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------                             |  </span><br><span class="line"><span class="regexp">//              | cur | first | end | map |------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------  </span><br><span class="line"><span class="regexp">//              迭代器, 其内部维护着一个缓冲区状态  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(T* x, map_pointer y)  </span></span><br><span class="line"><span class="regexp">        : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator() : cur(0), first(0), last(0), node(0) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(const iterator&amp; x)  </span></span><br><span class="line"><span class="regexp">        : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference operator*() const &#123; return *cur; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 判断两个迭代器间的距离  </span><br><span class="line">    difference_type operator-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">            (cur - first) + (x.last - x.cur);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 下面重载的这些运算符是让deque从外界看上去维护的是一段连续空间的关键!!!  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 前缀自增  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 如果当前迭代器指向元素是当前缓冲区的最后一个元素,  </span></span><br><span class="line"><span class="regexp">//</span> 则将迭代器状态调整为下一个缓冲区的第一个元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 不是当前缓冲区最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first          cur                     end  </span><br><span class="line"><span class="regexp">// ↓               ↓                       ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first              cur                 end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                   ↓                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 当前元素为当前缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first                              cur end  </span><br><span class="line"><span class="regexp">// ↓                                   ↓   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first                                  end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                                       ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 下一缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> ↑  </span><br><span class="line"><span class="regexp">// cur  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">    self&amp; operator++()  </span><br><span class="line">    &#123;  </span><br><span class="line">        ++cur;    <span class="regexp">// 切换至下一个元素  </span></span><br><span class="line"><span class="regexp">        if (cur == last)    //</span> 如果已达到缓冲区的尾端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node + <span class="number">1</span>);    <span class="regexp">// 就切换至下一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = first;           //</span> 的第一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 后缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增  </span><br><span class="line">    self operator++(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        ++*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 前缀自减, 处理方式类似于前缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 如果当前迭代器指向元素是当前缓冲区的第一个元素  </span><br><span class="line">    <span class="regexp">// 则将迭代器状态调整为前一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    self&amp; operator--()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (cur == first)    //</span> 如果已达到缓冲区的头端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node - <span class="number">1</span>);    <span class="regexp">// 就切换至前一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = last;            //</span> 的最后一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        --cur;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator--(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        --*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 将迭代器向前移动n个元素, n可以为负  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                     operator+=(difference_type n)  </span><br><span class="line"><span class="regexp">//                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span>                      offset = n + (cur - first)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------- offset &gt; <span class="number">0</span> ? &amp;&amp;  </span><br><span class="line"><span class="regexp">//                                   |           移动后是否超出当前缓冲区?  </span></span><br><span class="line"><span class="regexp">//</span>               ----------------------------  </span><br><span class="line"><span class="regexp">//           No  |                          |  Yes  </span></span><br><span class="line"><span class="regexp">//</span>               |                          |  </span><br><span class="line"><span class="regexp">//               ↓                          |---------- offset &gt; 0?  </span></span><br><span class="line"><span class="regexp">//</span>           cur += n;                      |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                          Yes |                          | No  </span><br><span class="line"><span class="regexp">//                              |                          |  </span></span><br><span class="line"><span class="regexp">//</span>                              ↓                          |  </span><br><span class="line"><span class="regexp">//                   计算要向后移动多少个缓冲区                |  </span></span><br><span class="line"><span class="regexp">//</span>                   node_offset =                         |  </span><br><span class="line"><span class="regexp">//                   offset / difference_type              |  </span></span><br><span class="line"><span class="regexp">//</span>                   (buffer_size());                      ↓  </span><br><span class="line"><span class="regexp">//                              |           计算要向前移动多少个缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              |           node_offset = -difference_type  </span><br><span class="line"><span class="regexp">//                              |           ((-offset - 1) / buffer_size()) - 1;  </span></span><br><span class="line"><span class="regexp">//</span>                              |                          |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                                           |  </span><br><span class="line"><span class="regexp">//                                           |  </span></span><br><span class="line"><span class="regexp">//</span>                                           ↓  </span><br><span class="line"><span class="regexp">//                                       调整缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              set_node(node + node_offset);  </span><br><span class="line"><span class="regexp">//                                    计算并调整cur指针  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    //</span> 以下实现随机存取。迭代器可以直接跳跃n个距离  </span><br><span class="line">    self&amp; operator+=(difference_type n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type offset = n + (cur - first);  </span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">            cur += n;        <span class="regexp">// 目标位置在同一缓冲区内  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">        &#123;           //</span> 目标位置不在同一缓冲区内  </span><br><span class="line">            difference_type node_offset =  </span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">            <span class="regexp">// 切换至正确的节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            set_node(node + node_offset);  </span></span><br><span class="line"><span class="regexp">            //</span> 切换至正确的元素  </span><br><span class="line">            cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator+(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 这里调用了operator +=()可以自动调整指针状态  </span></span><br><span class="line"><span class="regexp">        return tmp += n;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 将n变为-n就可以使用operator +=()了,  </span><br><span class="line">    self&amp; operator-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator-(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp -= n;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    reference operator[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  </span><br><span class="line">    bool operator==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">    bool operator!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">    bool operator&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> set_node(map_pointer new_node)  </span><br><span class="line">    &#123;  </span><br><span class="line">        node = new_node;  </span><br><span class="line">        first = *new_node;  </span><br><span class="line">        last = first + difference_type(buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// deque的数据结构  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;  </span></span><br><span class="line"><span class="regexp">class deque  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Basic types  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef value_type* pointer;  </span><br><span class="line">    typedef value_type&amp; reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Iterators  </span></span><br><span class="line"><span class="regexp">    typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;       iterator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:                      //</span> Internal typedefs  </span><br><span class="line">  </span><br><span class="line">    typedef pointer* map_pointer;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 这个提供STL标准的allocator接口, 见&lt;stl_alloc.h&gt;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 获取缓冲区最大存储元素数量  </span><br><span class="line">    static size_type buffer_size()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> __deque_buf_size(BufSiz, sizeof(value_type));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static size_type initial_map_size() &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;  </span><br><span class="line">  </span><br><span class="line">protected:                      <span class="regexp">// Data members  </span></span><br><span class="line"><span class="regexp">    iterator start;               //</span> 起始缓冲区  </span><br><span class="line">    iterator finish;              <span class="regexp">// 最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 指向map, map是一个连续的空间, 其每个元素都是一个指针，指向一个节点（缓冲区）  </span><br><span class="line">    map_pointer map;  </span><br><span class="line">    size_type map_size;   <span class="regexp">// map容量  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:  </span></span><br><span class="line"><span class="regexp">    iterator begin() &#123; return start; &#125;  </span></span><br><span class="line"><span class="regexp">    iterator end() &#123; return finish; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 提供随机访问能力, 其调用的是迭代器重载的operator []  </span><br><span class="line">    <span class="regexp">// 其实际地址需要进行一些列的计算, 效率有损失  </span></span><br><span class="line"><span class="regexp">    reference operator[](size_type n) &#123; return start[difference_type(n)]; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference front() &#123; return *start; &#125;  </span></span><br><span class="line"><span class="regexp">    reference back()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        iterator tmp = finish;  </span></span><br><span class="line"><span class="regexp">        --tmp;  </span></span><br><span class="line"><span class="regexp">        return *tmp;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 当前容器拥有的元素个数, 调用迭代器重载的operator -  </span><br><span class="line">    size_type size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> finish - start;; &#125;  </span><br><span class="line">    size_type max_size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// deque为空的时, 只有一个缓冲区  </span></span><br><span class="line"><span class="regexp">    bool empty() const &#123; return finish == start; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Constructor, destructor.  </span><br><span class="line">    deque() : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        create_map_and_nodes(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(size_type n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(int n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    ~deque()  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start, finish);     <span class="regexp">// &lt;stl_construct.h&gt;  </span></span><br><span class="line"><span class="regexp">        destroy_map_and_nodes();  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    deque&amp; operator= (const deque&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 其实我觉得把这个操作放在<span class="keyword">if</span>内效率更高  </span><br><span class="line">        <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">        <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 当前容器比x容器拥有元素多, 析构多余元素  </span></span><br><span class="line"><span class="regexp">            if (len &gt;= x.size())  </span></span><br><span class="line"><span class="regexp">                erase(copy(x.begin(), x.end(), start), finish);  </span></span><br><span class="line"><span class="regexp">            //</span> 将x所有超出部分的元素使用insert()追加进去  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">                copy(x.begin(), mid, start);  </span><br><span class="line">                insert(finish, mid, x.end());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:  </span><br><span class="line">    <span class="literal">void</span> push_back(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 最后缓冲区尚有两个（含）以上的元素备用空间  </span></span><br><span class="line"><span class="regexp">        if (finish.cur != finish.last - 1)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(finish.cur, t);     //</span> 直接在备用空间上构造元素  </span><br><span class="line">            ++finish.cur;     <span class="regexp">// 调整最后缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 容量已满就要新申请内存了  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            push_back_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> push_front(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (start.cur != start.first)      <span class="regexp">// 第一缓冲区尚有备用空间  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(start.cur - 1, t);   //</span> 直接在备用空间上构造元素  </span><br><span class="line">            --start.cur;     <span class="regexp">// 调整第一缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else    //</span> 第一缓冲区已无备用空间  </span><br><span class="line">            push_front_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> pop_back()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (finish.cur != finish.first)    <span class="regexp">// 最后缓冲区有一个（或更多）元素  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            --finish.cur;    //</span> 调整指针，相当于排除了最后元素  </span><br><span class="line">            destroy(finish.cur);    <span class="regexp">// 将最后元素析构  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">            //</span> 最后缓冲区没有任何元素  </span><br><span class="line">            pop_back_aux();    <span class="regexp">// 这里将进行缓冲区的释放工作  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void pop_front()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (start.cur != start.last - 1)    //</span> 第一缓冲区有两个（或更多）元素  </span><br><span class="line">        &#123;  </span><br><span class="line">            destroy(start.cur);    <span class="regexp">// 将第一元素析构  </span></span><br><span class="line"><span class="regexp">            ++start.cur;           //</span>调整指针，相当于排除了第一元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="regexp">// 第一缓冲区仅有一个元素  </span></span><br><span class="line"><span class="regexp">            pop_front_aux();    //</span> 这里将进行缓冲区的释放工作  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Insert  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//             insert(iterator position, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |---------------- 判断插入位置  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> deque.begin() |          deque.emd() |                      |  </span><br><span class="line"><span class="regexp">//               |                      |                      |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                      ↓                      |  </span><br><span class="line"><span class="regexp">//         push_front(x);         push_back(x);                |  </span></span><br><span class="line"><span class="regexp">//</span>                                                             ↓  </span><br><span class="line"><span class="regexp">//                                                 insert_aux(position, x);  </span></span><br><span class="line"><span class="regexp">//</span>                                                 具体剖析见后面实现  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 如果是在deque的最前端插入, 那么直接push_front()即可  </span></span><br><span class="line"><span class="regexp">        if (position.cur == start.cur)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            push_front(x);  </span></span><br><span class="line"><span class="regexp">            return start;  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 如果是在deque的末尾插入, 直接调用push_back()  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur)  </span><br><span class="line">        &#123;  </span><br><span class="line">            push_back(x);  </span><br><span class="line">            iterator tmp = finish;  </span><br><span class="line">            --tmp;  </span><br><span class="line">            <span class="keyword">return</span> tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> insert_aux(position, x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position) &#123; <span class="keyword">return</span> insert(position, value_type()); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 详解见实现部分  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, size_type n, const value_type&amp; x);  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, int n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, long n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void resize(size_type new_size) &#123; resize(new_size, value_type()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Erase  </span><br><span class="line">  </span><br><span class="line">    iterator erase(iterator pos)  </span><br><span class="line">    &#123;  </span><br><span class="line">        iterator next = pos;  </span><br><span class="line">        ++next;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 清除点之前的元素个数  </span></span><br><span class="line"><span class="regexp">        difference_type index = pos - start;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">        //</span> 如果清除点之前的元素个数比较少, 哪部分少就移动哪部分  </span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 就移动清除点之前的元素  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, pos, next);  </span></span><br><span class="line"><span class="regexp">            pop_front();   //</span> 移动完毕，最前一个元素冗余，去除之  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   <span class="regexp">// 如果清除点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(next, finish, pos);  //</span> 就移动清除点之后的元素  </span><br><span class="line">            pop_back();   <span class="regexp">// 移动完毕，最后一个元素冗余，去除之  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        return start + index;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    iterator erase(iterator first, iterator last);  </span></span><br><span class="line"><span class="regexp">    void clear();  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 详解见实现部分  </span><br><span class="line">    <span class="literal">void</span> push_back_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> push_front_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> pop_back_aux();  </span><br><span class="line">    <span class="literal">void</span> pop_front_aux();  </span><br><span class="line">  </span><br><span class="line">    iterator insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">    <span class="literal">void</span> insert_aux(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 分配内存, 不进行构造  </span></span><br><span class="line"><span class="regexp">    pointer allocate_node() &#123; return data_allocator::allocate(buffer_size()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 释放内存, 不进行析构  </span><br><span class="line">    <span class="literal">void</span> deallocate_node(pointer n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        data_allocator::deallocate(n, buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 清除[first, last)区间的所有元素  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                  erase(iterator first, iterator last)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------------- 是否要删除整个区间?  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>               ------------------------------------------  </span><br><span class="line"><span class="regexp">//           Yes |                                        | No  </span></span><br><span class="line"><span class="regexp">//</span>               |                                        |  </span><br><span class="line"><span class="regexp">//               ↓                                        | --- 判断哪侧元素少  </span></span><br><span class="line"><span class="regexp">//</span>            clear();                                    ↓  </span><br><span class="line"><span class="regexp">//       -----------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> 左侧少 |                                                         右侧少 |  </span><br><span class="line"><span class="regexp">//       |                                                               |  </span></span><br><span class="line"><span class="regexp">//</span>       ↓                                                               ↓  </span><br><span class="line"><span class="regexp">//   copy_backward(start, first, last);            copy(last, finish, first);  </span></span><br><span class="line"><span class="regexp">//</span>   new_start = start + n;                        new_finish = finish - n;  </span><br><span class="line"><span class="regexp">//   析构多余的元素                                  析构多余的元素  </span></span><br><span class="line"><span class="regexp">//</span>   destroy(start, new_start);                    destroy(new_finish, finish);  </span><br><span class="line"><span class="regexp">//   释放多余内存空间                                释放多余内存空间  </span></span><br><span class="line"><span class="regexp">//</span>   <span class="keyword">for</span> (...)                                     <span class="keyword">for</span> (...)  </span><br><span class="line"><span class="regexp">//      ...                                             ...  </span></span><br><span class="line"><span class="regexp">//</span>   更新map状态                                    更新map状态  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish)   <span class="regexp">// 如果清除区间是整个deque  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        clear();              //</span> 直接调用clear()即可  </span><br><span class="line">        <span class="keyword">return</span> finish;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type n = last - first;   <span class="regexp">// 清除区间的长度  </span></span><br><span class="line"><span class="regexp">        difference_type elems_before = first - start;   //</span> 清除区间前方的元素个数  </span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>)   <span class="regexp">// 如果前方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, first, last);  //</span> 向后移动前方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_start = start + n;     <span class="regexp">// 标记deque的新起点  </span></span><br><span class="line"><span class="regexp">            destroy(start, new_start);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            start = new_start;   //</span> 设定deque的新起点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>    <span class="regexp">// 如果清除区间后方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(last, finish, first);  //</span> 向前移动后方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_finish = finish - n;     <span class="regexp">// 标记deque的新尾点  </span></span><br><span class="line"><span class="regexp">            destroy(new_finish, finish);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            finish = new_finish;   //</span> 设定deque的新尾点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::clear()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="regexp">// 以下针对头尾以外的每一个缓冲区  </span></span><br><span class="line"><span class="regexp">    for (map_pointer node = start.node + 1; node &lt; finish.node; ++node)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 将缓冲区内的所有元素析构  </span><br><span class="line">        destroy(*node, *node + buffer_size());  </span><br><span class="line">        <span class="regexp">// 释放缓冲区内存  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(*node, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    if (start.node != finish.node)   //</span> 至少有头尾两个缓冲区  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start.cur, start.last);  <span class="regexp">// 将头缓冲区的目前所有元素析构  </span></span><br><span class="line"><span class="regexp">        destroy(finish.first, finish.cur);  //</span> 将尾缓冲区的目前所有元素析构  </span><br><span class="line">        <span class="regexp">// 以下释放尾缓冲区。注意：头缓冲区保留  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(finish.first, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    else   //</span> 只有一个缓冲区  </span><br><span class="line">        destroy(start.cur, finish.cur);   <span class="regexp">// 将此唯一缓冲区内的所有元素析构  </span></span><br><span class="line"><span class="regexp">        //</span> 注意：并不释放缓冲区空间，这唯一的缓冲区将保留  </span><br><span class="line">  </span><br><span class="line">    finish = start;   <span class="regexp">// 调整状态  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当finish.cur == finish.last - <span class="number">1</span> 时才会被调用  </span><br><span class="line"><span class="regexp">// 也就是说，只有当最后一个缓冲区只剩下一个备用元素空间时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t)  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    value_type t_copy = t;  </span></span><br><span class="line"><span class="regexp">    reserve_map_at_back();  </span></span><br><span class="line"><span class="regexp">    *(finish.node + 1) = allocate_node();    //</span> 配置一个新节点（缓冲区）  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        construct(finish.cur, t_copy);         <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">        finish.set_node(finish.node + 1);      //</span> 改变finish，令其指向新节点  </span><br><span class="line">        finish.cur = finish.first;             <span class="regexp">// 设定finish的状态  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    __STL_UNWIND(deallocate_node(*(finish.node + 1)));  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> Called only <span class="keyword">if</span> start.cur == start.first.  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">&#123;  </span><br><span class="line">    value_type t_copy = t;  </span><br><span class="line">    reserve_map_at_front();  </span><br><span class="line">    *(start.node - <span class="number">1</span>) = allocate_node();  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        start.set_node(start.node - <span class="number">1</span>);        <span class="regexp">// 改变start，令其指向新节点  </span></span><br><span class="line"><span class="regexp">        start.cur = start.last - 1;            //</span> 设定start的状态  </span><br><span class="line">        construct(start.cur, t_copy);          <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    catch(...)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        start.set_node(start.node + 1);  </span></span><br><span class="line"><span class="regexp">        start.cur = start.first;  </span></span><br><span class="line"><span class="regexp">        deallocate_node(*(start.node - 1));  </span></span><br><span class="line"><span class="regexp">        throw;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当 finish.cur == finish.first 时才会被调用  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;:: pop_back_aux()  </span><br><span class="line">&#123;  </span><br><span class="line">    deallocate_node(finish.first);      <span class="regexp">// 释放最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">    finish.set_node(finish.node - 1);   //</span> 调整finish状态，使指向  </span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;       <span class="regexp">// 上一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    destroy(finish.cur);                //</span> 将该元素析构  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// 只有当 start.cur == start.last - 1 时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux()  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    destroy(start.cur);    //</span> 将第一个缓冲区的第一个（也是最后一个、唯一一个）元素析构  </span><br><span class="line">    deallocate_node(start.first);    <span class="regexp">// 释放第一缓冲区  </span></span><br><span class="line"><span class="regexp">    start.set_node(start.node + 1);  //</span> 调整start状态，使指向  </span><br><span class="line">    start.cur = start.first;         <span class="regexp">// 下一个缓冲区的第一个元素  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//              insert_aux(iterator pos, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |----------- 判断pos前端元素少还是后端元素少  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         前端少 |                                       后端少 |  </span><br><span class="line"><span class="regexp">//               |                                             |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                                             |  </span><br><span class="line"><span class="regexp">//           进行相关操作                                   进行相关操作  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 下面以pos前面元素少的情形进行说明, 为了简化, 假设操作不会超过一个缓冲区区间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 插入前状态  </span><br><span class="line"><span class="regexp">//           start            pos                                 end  </span></span><br><span class="line"><span class="regexp">//</span>             ↓               ↓                                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 需要进行操作的区间  </span></span><br><span class="line"><span class="regexp">//</span>                需要拷贝的区间  </span><br><span class="line"><span class="regexp">//                 -------------  </span></span><br><span class="line"><span class="regexp">//</span>       start     |           |                                  end  </span><br><span class="line"><span class="regexp">//         ↓       ↓           ↓                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">//             ↑   ↑       ↑   ↑  </span></span><br><span class="line"><span class="regexp">//</span>        front1   |       |   |  </span><br><span class="line"><span class="regexp">//                 |       |   |  </span></span><br><span class="line"><span class="regexp">//</span>            front2       |   |  </span><br><span class="line"><span class="regexp">//                         |   |  </span></span><br><span class="line"><span class="regexp">//</span>                       pos   |  </span><br><span class="line"><span class="regexp">//                             |  </span></span><br><span class="line"><span class="regexp">//</span>                          pos1  </span><br><span class="line"><span class="regexp">// 拷贝操作完成后  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">//         这是[front2, pos1)  </span></span><br><span class="line"><span class="regexp">//</span>             ------------- --------- 这里是给待插入元素预留的空间  </span><br><span class="line"><span class="regexp">//       start |           | |                                    end  </span></span><br><span class="line"><span class="regexp">//</span>         ↓   ↓           ↓ ↓                                     ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         ↑  </span><br><span class="line"><span class="regexp">//   这里存储的是原来的front()  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">typename deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">&#123;  </span><br><span class="line">    difference_type index = pos - start;   <span class="regexp">// 插入点之前的元素个数  </span></span><br><span class="line"><span class="regexp">    value_type x_copy = x;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 前面的时候用的移位操作, 这里怎么不用了呢^_^?  </span><br><span class="line">    <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>)    <span class="regexp">// 如果插入点之前的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_front(front());       //</span> 在最前端加入与第一元素同值的元素  </span><br><span class="line">        iterator front1 = start;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        ++front1;  </span></span><br><span class="line"><span class="regexp">        iterator front2 = front1;  </span></span><br><span class="line"><span class="regexp">        ++front2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        iterator pos1 = pos;  </span></span><br><span class="line"><span class="regexp">        ++pos1;  </span></span><br><span class="line"><span class="regexp">        copy(front2, pos1, front1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>    <span class="regexp">// 插入点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_back(back());         //</span> 在最尾端加入与最后元素同值的元素  </span><br><span class="line">        iterator back1 = finish;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        --back1;  </span></span><br><span class="line"><span class="regexp">        iterator back2 = back1;  </span></span><br><span class="line"><span class="regexp">        --back2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        copy_backward(pos, back2, back1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    *pos = x_copy;    <span class="regexp">// 在插入点上设定新值  </span></span><br><span class="line"><span class="regexp">    return pos;  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="源网址"><a href="#源网址" class="headerlink" title="源网址"></a>源网址</h2><ul><li><a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a></li><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7729451" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析—deque</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/baidu_28312631/article/details/48000123&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;STL源码剖析——deque的实现原理和使用方法详解&lt;/a&gt;。只用于本人学习。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="deque" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/deque/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>Markdown公式编辑</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/markdowm/Markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/wiki/工具/markdowm/Markdown公式编辑学习笔记/</id>
    <published>2018-06-25T04:11:12.000Z</published>
    <updated>2018-06-26T03:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown中使用LaTEX 编写含有数学公式的博客。</p><a id="more"></a><h2 id="如何插入公式"><a href="#如何插入公式" class="headerlink" title="如何插入公式"></a>如何插入公式</h2><ol><li>行中公式（放在文中与其他文字编辑）：可以用如下方法表示：<code>$数学公式$</code></li><li>独立公式可以用下面的方法表示：<code>$$数学公式$$</code></li><li>自动编号的公式可以用如下的方法表示：<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">数学公式</span><br><span class="line"><span class="tag">\<span class="name">label</span><span class="string">&#123;eq:当前公式名&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">自动编号后的公式可在全文任意处使用 <span class="tag">\<span class="name">eqref</span><span class="string">&#123;eq:公式名&#125;</span></span> 语句引用。</span><br></pre></td></tr></table></figure></li></ol><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，not one line &#125; $</span></span><br></pre></td></tr></table></figure><p>显示$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，not one line } $</p><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，独立公式示例&#125;$$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p><code>^</code> 表示上标， <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>{}</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</p><p>例子</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> x^&#123;y^z&#125;=(<span class="number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="number">-2</span>xy^w&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</p><p>另外，如果要在左右两边都有上下标，可以用<code>\sideset</code> 命令</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \sideset&#123;^<span class="number">1</span>_2&#125;&#123;^<span class="number">3</span>_4&#125;\bigotimes <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p><h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code>。当要显示大号的括号或分隔符时，要用 \left 和 \right 命令。<br>一些特殊的括号：</p><table><thead><tr><th>输入</th><th>显示</th></tr></thead><tbody><tr><td><code>$$\langle表达式\rangle$$</code></td><td>$$\langle表达式\rangle$$</td></tr><tr><td><code>$$\lceil表达式\rceil$$</code></td><td>$$\lceil表达式\rceil$$</td></tr><tr><td><code>$$\lfloor表达式\rfloor$$</code></td><td>$$\lfloor表达式\rfloor$$</td></tr><tr><td><code>$$\lbrace表达式\rbrace$$</code></td><td>$$\lbrace表达式\rbrace$$</td></tr></tbody></table><p>例子</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x,y,z) = <span class="number">3</span>y^<span class="number">2</span>z \left( <span class="number">3</span>+\frac&#123;<span class="number">7</span>x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) $$</span><br></pre></td></tr></table></figure><p>显示<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac {分子} {分母}</code>命令产生一个分数<code>\frac {分子} {分母}</code>，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built-in">frac</span>&#123;a<span class="number">-1</span>&#125;&#123;b<span class="number">-1</span>&#125; \quad <span class="keyword">and</span> \quad &#123;a+<span class="number">1</span>\over b+<span class="number">1</span>&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] {被开方数}</code>命令输入开方。</p><p>例子：</p><p><code>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</code></p><p>显示</p><p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号。</p><p>例子：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">$f</span>(x_1,x_2,<span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\l</span>dots&#125;_&#123;<span class="symbol">\r</span>m ldots&#125; ,x_n) = x_1^2 + x_2^2 + <span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\c</span>dots&#125;_&#123;<span class="symbol">\r</span>m cdots&#125; + x_n^2$$</span><br></pre></td></tr></table></figure><p>显示：</p><p>$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</p><h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec{矢量}</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span> <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">vec</span><span class="string">&#123;b&#125;</span>=<span class="number">0</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">overleftarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overleftrightarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overrightarrow</span><span class="string">&#123;xy&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：<br>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 \int_积分下限^积分上限 {被积表达式} 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th>输入</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td><code>\rm</code></td><td>罗马体</td><td>$$\rm Sample$$</td></tr><tr><td><code>\it</code></td><td>意大利体</td><td>$$\it Sample $$</td></tr><tr><td><code>\bf</code></td><td>粗体</td><td>$$\bf Sample $$</td></tr><tr><td><code>\sf</code></td><td>等线体</td><td>$$\sf Sample $$</td></tr><tr><td><code>\tt</code></td><td>打字机体</td><td>$$\tt Sample $$</td></tr><tr><td><code>\frak</code></td><td>旧德式字体</td><td>$$\frak Sample $$</td></tr><tr><td><code>\cal</code></td><td>花体</td><td>$$\cal Sample $$</td></tr><tr><td><code>\Bbb</code></td><td>黑板粗体</td><td>$$\Bbb Sample $$</td></tr><tr><td><code>\mit</code></td><td>数学斜体</td><td>$$\mit Sample $$</td></tr><tr><td>\scr</td><td>手写体</td><td>$$\scr Sample$$</td></tr></tbody></table><h2 id="积分-1"><a href="#积分-1" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_积分下限^积分上限 {被积表达式}</code> 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示<br>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>使用\lim_{变量 \to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \to 符号至任意符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">lim</span></span>_&#123;n <span class="tag">\<span class="name">to</span></span> +<span class="tag">\<span class="name">infty</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">lim</span></span>_&#123;x<span class="tag">\<span class="name">leftarrow</span><span class="string">&#123;示例&#125;</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> $$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/codeep/note/163962" rel="external nofollow noopener noreferrer" target="_blank">Cmd Markdown 公式指导手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown中使用LaTEX 编写含有数学公式的博客。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="markdowm" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/markdowm/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>数学知识一对数指数</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/数据知识/数学基础知识/</id>
    <published>2018-06-25T04:07:12.000Z</published>
    <updated>2018-06-26T03:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>解换底公式为：</p><p>$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \text{(c＞0，c≠1)} $$</p><p>loga（b）=logc（b）/logc（a）（c＞0，c≠1）<br>推导过程</p><p>令 $ \log_a{b} = t $</p><p>即 $ a^t = b$</p><p>即a^t=b</p><p>两边取以c（c＞0，c≠1）的对数</p><p>即 $ \log_c(a^t) =\log_cb $</p><p>即 $t\log_c{a}=log_cb</p><p>由a≠1，即 $ \log_c{a}≠0$</p><p>所以 $t=\frac{log_cb}{log_ca} $ </p><p>所以： $log_ab= \frac{log_cb}{log_ca}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对数&quot;&gt;&lt;a href=&quot;#对数&quot; class=&quot;headerlink&quot; title=&quot;对数&quot;&gt;&lt;/a&gt;对数&lt;/h2&gt;&lt;p&gt;解换底公式为：&lt;/p&gt;
&lt;p&gt;$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \tex
      
    
    </summary>
    
      <category term="数据知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数学知识" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>运算符优先级表</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/运算法/运算符优先级表/</id>
    <published>2018-06-23T04:07:12.000Z</published>
    <updated>2018-07-05T11:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="C-运算符优先级"><a href="#C-运算符优先级" class="headerlink" title="C++ 运算符优先级"></a>C++ 运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;C-运算符优先级&quot;&gt;&lt;a href=&quot;#C-运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;C++ 运算符优先级&quot;&gt;&lt;/a&gt;C++ 运算符优先级&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结合
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="运算法" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="运算符优先级" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>mach-o Viewer 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/Mach_O/machoviewer/"/>
    <id>http://yoursite.com/wiki/IOS/Mach_O/machoviewer/</id>
    <published>2018-06-22T04:07:12.000Z</published>
    <updated>2018-06-22T05:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是 <a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">mach-o Viewer </a>源码学习记录。</p><a id="more"></a><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/datastruct.png" alt="数据结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/overrall.png" alt="代码结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/domainTask.png" alt="domainTask"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是 &lt;a href=&quot;https://github.com/gdbinit/MachOView&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;mach-o Viewer &lt;/a&gt;源码学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="macho" scheme="http://yoursite.com/tags/macho/"/>
    
  </entry>
  
</feed>
