<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-30T09:14:02.741Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10.load_images 函数分析</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/10_load_images/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/10_load_images/</id>
    <published>2018-11-30T02:38:11.000Z</published>
    <updated>2018-11-30T09:14:02.741Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析load_images 函数,该函数完成+load方法的调用。</p><!--more>## load_images 相关的数据结构在_objc_init 函数中，dyld_register_image_state_change_handler 将 load_images 作为回调函数注册给dylib，所以，当镜像的状态变化时，会回调load_images函数。<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析load_images前，先介绍相关的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">load_method_t</span>)</span><span class="params">(id, SEL)</span></span>; <span class="comment">// 用于 +load 方法的 imp 类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> &#123;</span> <span class="comment">// 需要被调用 +load 方法的类</span></span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// +load 方法对应的 imp</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> &#123;</span> <span class="comment">// 需要被调用 +load 方法的分类</span></span><br><span class="line">    Category cat;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// +load 方法对应的 imp</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of classes that need +load called (pending superclass +load)</span></span><br><span class="line"><span class="comment">// This list always has superclasses first because of the way it is constructed</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">loadable_classes</span> = <span class="title">nil</span>;</span> <span class="comment">// 这个列表中存放所有需要调用 +load 方法的类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_classes_used = <span class="number">0</span>; <span class="comment">// loadable_classes 列表中已经被使用了多少个位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_classes_allocated = <span class="number">0</span>; <span class="comment">// loadable_classes 列表开辟了多少位置，如果位置不够用了，会进行扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of categories that need +load called (pending parent class +load)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">loadable_categories</span> = <span class="title">nil</span>;</span> <span class="comment">// 这个列表中存放所有需要执行 +load 方法的分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_categories_used = <span class="number">0</span>; <span class="comment">// loadable_categories 列表中已经被使用了多少个位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_categories_allocated = <span class="number">0</span>; <span class="comment">// loadable_categories 列表开辟了多少位置，如果位置不够用了，会进行扩容</span></span><br></pre></td></tr></table></figure><p>可load 的class相关的数据结构：</p><p><img src="10_load_images/loadable_class.png" alt="_read_images 的意义"></p><p>可load 的category相关的数据结构：</p><p><img src="10_load_images/loadable_category.png" alt="_read_images 的意义"></p><h2 id="load-images-源码分析"><a href="#load-images-源码分析" class="headerlink" title="load_images 源码分析"></a>load_images 源码分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">load_images(<span class="keyword">enum</span> dyld_image_states state, <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">            <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 快速扫描镜像中是否有 +load 方法 (其实只查找了镜像中是否有类或分类）</span></span><br><span class="line">        <span class="comment">// imageLoadAddress 是镜像加载的内存地址</span></span><br><span class="line">        <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> nil; <span class="comment">// 如果没有找到，就直接返回 nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123; <span class="comment">// 加上括号，是为了 runtimeLock 锁，可以在这个块内自动释放，否则下次重入该函数时，会死锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock2(runtimeLock); <span class="comment">// runtimeLock 加写锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做一些准备工作，将需要 +load 的类和分类分别存储到 loadable_classes、loadable_categories 中，</span></span><br><span class="line">        <span class="comment">// 在 call_load_methods() 中才有类可以调 +load</span></span><br><span class="line">        <span class="comment">// 并进一步确认是否真的有类或分类需要调用 +load</span></span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 不加 runtimeLock 锁，是因为 runtimeLock 与递归锁不一样，它是不可重入的，</span></span><br><span class="line">    <span class="comment">// 因为 load_images 中调用 +load 时，会导致其他镜像被 load，</span></span><br><span class="line">    <span class="comment">// 即 load_images 函数会在一个线程上被接连调用多次，如果加上 runtimeLock，就会造成死锁</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123; <span class="comment">// 确实有类或分类需要 +load</span></span><br><span class="line">        call_load_methods(); <span class="comment">// 就调用 +load</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数分为三部分工作：</p><ol><li>hasLoadMethods 判断是否有load函数</li><li>load_images_nolock 将load的信息添加到全局数据结构中</li><li>call_load_methods 调用load方法</li></ol><h3 id="判断是否含有load方法"><a href="#判断是否含有load方法" class="headerlink" title="判断是否含有load方法"></a>判断是否含有load方法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool hasLoadMethods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t <span class="keyword">count</span>;</span><br><span class="line">    <span class="comment">// 扫描类列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;<span class="keyword">count</span>)  &amp;&amp;  <span class="keyword">count</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 扫描分类列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;<span class="keyword">count</span>)  &amp;&amp;  <span class="keyword">count</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果累有load方法，就会被放入<strong>objc_nlclslist section，如果分类有load方法，分类就会被放入</strong>objc_nlcatlist section，所以判断是否有这两个section，就判断出了是否有load方法</p><h3 id="存储含有load方法的类、分类到全局数据中"><a href="#存储含有load方法的类、分类到全局数据中" class="headerlink" title="存储含有load方法的类、分类到全局数据中"></a>存储含有load方法的类、分类到全局数据中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> </span><br><span class="line">load_images_nolock(<span class="keyword">enum</span> dyld_image_states state,<span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">                   <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = NO;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    i = infoCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前遍历 infoList 中所有镜像，如果镜像中有 +load 方法（其实只查找了镜像中是否有类或分类）</span></span><br><span class="line">    <span class="comment">// 就对镜像调用 prepare_load_methods，</span></span><br><span class="line">    <span class="comment">// 并且记录下有 +load 方法，只要有一个镜像有 +load ，就返回 YES</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;</span><br><span class="line">        <span class="keyword">if</span> (!hasLoadMethods(mhdr)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为 +load 做一些准备工作</span></span><br><span class="line">        <span class="comment">// 将需要 +load 的类添加到 loadable_classes 列表，</span></span><br><span class="line">        <span class="comment">// 将需要 +load 的分类添加到 loadable_categories 列表</span></span><br><span class="line">        prepare_load_methods(mhdr);</span><br><span class="line">        found = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用prepare_load_methods 保存信息。</p><figure class="highlight plain"><figcaption><span>prepare_load_methods(const headerType *mhdr)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting(); // runtimeLock 需要事先加好写锁（是在 load_images() 中加的锁）</span><br><span class="line"></span><br><span class="line">    // 获得镜像中所有 objective-2.0 且是非惰性的 类的 列表</span><br><span class="line">    classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 遍历类列表，先取得重映射的类，然后调用 schedule_class_load 函数将其添加到 loadable_classes 列表中</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取得分类列表</span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 遍历分类列表</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls); // 取得 分类所属的类 所对应的 重映射类</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">                             // cls == nil，即 cat-&gt;cls 是 ignored weak-linked 类，就跳过</span><br><span class="line">        realizeClass(cls);  // 将 cls 类 realize 了，里面当然也会一并 realize 了 cls 的祖宗类和元类</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized()); // 确认 realizeClass 是否已经将 cls 的元类也一并 realize 了，</span><br><span class="line">                                          // 见 realizeClass()</span><br><span class="line">        add_category_to_loadable_list(cat); // 将分类 cat 添加到 loadable_categories 列表中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数完成的功能有两个：</p><ol><li>调用schedule_class_load 将含有 +load 的类添加到 loadable_classes 列表；</li><li>调用add_category_to_loadable_list 将含有 +load 的分类添加到 loadable_categories 列表</li></ol><h4 id="保存含有load方法的类到loadable-classes"><a href="#保存含有load方法的类到loadable-classes" class="headerlink" title="保存含有load方法的类到loadable_classes"></a>保存含有load方法的类到loadable_classes</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证 loadable_classes 列表中，父类在前，子类在后，父类的 +load 先被调用</span></span><br><span class="line"><span class="keyword">static</span> void schedule_class_load(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>; <span class="comment">// cls 为 nil，这会出现在根类的时候，结束递归</span></span><br><span class="line">    </span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// cls 必须已经是 realize 的，即 realize 在 load 之前，</span></span><br><span class="line">                                <span class="comment">// realize 是在 _read_images() 中做的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>; <span class="comment">// 如果该类已经被 load 过了，就直接返回，结束递归</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass); <span class="comment">// 递归，确保在 loadable_classes 列表中父类排在前面</span></span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls); <span class="comment">// 将 cls 类添加到 loadable_classes 列表中</span></span><br><span class="line">                                     <span class="comment">// 其中会检查 cls 类是否确实有 +load 方法，只有拥有 +load 方法，才会将其添加到 loadable_classes 列表</span></span><br><span class="line">    </span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); <span class="comment">// 将 cls 类设置为已经 load</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>schedule_class_load  将含有 +load 的类添加到 loadable_classes 列表，需要注意的是：，父类在前，子类在后，父类的 +load 先被调用。内部调用add_class_to_loadable_list 添加到loadable_classes列表中。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked(); <span class="comment">// loadMethodLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    method = <span class="keyword">cls</span>-&gt;getLoadMethod(); <span class="comment">// 取得 cls 类的 +load 方法的 imp</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">                        <span class="comment">// 如果 cls 类压根儿就没有 +load 方法，那也没有将其添加到 loadable_classes 列表的必要</span></span><br><span class="line">                        <span class="comment">// 直接返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     <span class="keyword">cls</span>-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loadable_classes 列表已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        <span class="comment">// 重新计算一下新的大小</span></span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 重新开辟新的内存空间，并将原来的数据拷贝过去</span></span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cls 插入到列表末尾</span></span><br><span class="line">    loadable_classes[loadable_classes_used].<span class="keyword">cls</span> = <span class="keyword">cls</span>;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    </span><br><span class="line">    loadable_classes_used++; <span class="comment">// 元素数量 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用getLoadMethod 获取cls 的load方法的函数指针。然后将cls、method 放入到loadable_classes中。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IMP </span><br><span class="line">objc_class::getLoadMethod()</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// runtimeLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    const method_list_t *mlist;</span><br><span class="line"></span><br><span class="line">    assert(isRealized()); <span class="comment">// 该类必须是 realized 过的</span></span><br><span class="line">    <span class="function"><span class="title">assert</span>(ISA()-&gt;</span>isRealized()); <span class="comment">// 元类也必须是 realized 过的</span></span><br><span class="line">    assert(!isMetaClass()); <span class="comment">// 该类不能是元类</span></span><br><span class="line">    <span class="function"><span class="title">assert</span>(ISA()-&gt;</span>isMetaClass()); <span class="comment">// 该类的 isa 必须是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mlist</span> = ISA()-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span><span class="function"><span class="title">ro</span>-&gt;</span>baseMethods(); <span class="comment">// +load 是类方法，所以存在了元类中，取出元类的 ro 中的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (const auto&amp; meth : *mlist) &#123; <span class="comment">// 遍历元类的方法列表，</span></span><br><span class="line">            const char *<span class="keyword">name</span> = sel_cname(meth.<span class="keyword">name</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcmp(<span class="keyword">name</span>, <span class="string">"load"</span>)) &#123; <span class="comment">// 寻找名字叫 "load" 的方法</span></span><br><span class="line">                return meth.imp; <span class="comment">// 如果找到了，就返回该方法的 imp</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">nil</span>; <span class="comment">// 找不到就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLoadMethod 函数循环比较元类中ro中的baseMethods，如果方法名称一样，就返回对应的IMP。</p><h4 id="保存含有load方法的分类到loadable-categories"><a href="#保存含有load方法的分类到loadable-categories" class="headerlink" title="保存含有load方法的分类到loadable_categories"></a>保存含有load方法的分类到loadable_categories</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分类 cat 添加到 loadable_categories 列表中</span></span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    IMP method;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    loadMethodLock.assertLocked();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    method = _category_getLoadMethod(cat);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // Don't bother if cat has no +load method</span></span><br><span class="line"><span class="comment">    if (!method) return;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (PrintLoading) &#123;</span></span><br><span class="line"><span class="comment">        _objc_inform("LOAD: category '%s(%s)' scheduled for +load", </span></span><br><span class="line"><span class="comment">                     _category_getClassName(cat), _category_getName(cat));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span></span><br><span class="line"><span class="comment">        loadable_categories = (struct loadable_category *)</span></span><br><span class="line"><span class="comment">            realloc(loadable_categories,</span></span><br><span class="line"><span class="comment">                              loadable_categories_allocated *</span></span><br><span class="line"><span class="comment">                              sizeof(struct loadable_category));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用_category_getLoadMethod 获取分类中load方法的IMP，然后将cat、method放入到loadable_categories</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得分类的 +load 方法对应的 imp，如果没有 +load 方法，就返回 nil</span></span><br><span class="line">IMP </span><br><span class="line">_category_getLoadMethod(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// runtimeLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    mlist = cat-&gt;classMethods; <span class="comment">// 取得分类的类方法列表，因为 +load 也是类方法，位于类方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123; <span class="comment">// 遍历类方法列表，查找名为 "load" 的方法</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">"load"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp; <span class="comment">// 如果找到了，就将方法的 imp 返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil; <span class="comment">// 没有 +load 方法，就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call_load_methods 获取分类classMethods中方法列表，循环比较方法名称，如果一致，返回方法的IMP。</p><h3 id="调用load方法"><a href="#调用load方法" class="headerlink" title="调用load方法"></a>调用load方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数中调用类的 +load 方法</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用类的load方法"><a href="#调用类的load方法" class="headerlink" title="调用类的load方法"></a>调用类的load方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span> <span class="comment">// 先将列表暂存起来，即另一个指针指向列表的内存</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used; <span class="comment">// 暂存列表中类的数量</span></span><br><span class="line">    loadable_classes = nil; <span class="comment">// loadable_classes 指向指向 nil，与原来的列表脱离关系</span></span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>; <span class="comment">// 容量清零</span></span><br><span class="line">    loadable_classes_used = <span class="number">0</span>; <span class="comment">// 类的个数清零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123; <span class="comment">// 遍历暂存的列表</span></span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 取得该类的 +load 方法的 imp</span></span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// 如果 imp 不存在，没得玩，跳过</span></span><br><span class="line">                             <span class="comment">// 一般情况下，不会这么糟糕，因为 add_class_to_loadable_list() 中对</span></span><br><span class="line">                             <span class="comment">// 没有 +load imp 的类进行了排除</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"LOAD: +[%s load]\n"</span>, cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        (*load_method)(cls, SEL_load); <span class="comment">// 直接调用 +load 的 imp 函数，跳过 objc_msgSend 速度更快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes); <span class="comment">// 将暂存的列表销毁释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load方法的调用时直接执行函数指针，所以不存在runtime中的消息转发，对子类发送load消息，不会执行父类中的load方法。这样保证每个类的load方法都只调用一次。</p><h4 id="调用分类的load方法"><a href="#调用分类的load方法" class="headerlink" title="调用分类的load方法"></a>调用分类的load方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用分类中的 +load 方法</span></span><br><span class="line"><span class="comment">// 调用者：call_load_methods()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">cats</span> = <span class="title">loadable_categories</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                <span class="built_in">realloc</span>(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将全局中的信息拷贝处理啊，调用分类的load方法。 调用完成之后就将cats[i]中的cat 置位 nil，  对于那些不符合调用load方法的分类不做处理， 这样就会剩下一部分分类。 下面就是整合剩下的分类和新添加到loadable_categories的分类为新的结构。</p><p>上面说明的了分类中的load方法也会调用。并且分类中的load方法不会覆盖本类中的load方法。</p><h2 id="总体的流程图"><a href="#总体的流程图" class="headerlink" title="总体的流程图"></a>总体的流程图</h2><p>这里暂时没有写</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer">Tagged Pointer</a></li><li><a href="https://www.jianshu.com/p/9e0fc8295c4b">Xcode 10 下如何调试objc4-723</a></li></ol>-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文分析load_images 函数,该函数完成+load方法的调用。&lt;/p&gt;
&lt;!--more&gt;

## load_images 相关的数据结构

在_objc_init 函数中，dyld_register_image_state_change_handler 将 loa
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="load_images" scheme="http://yoursite.com/tags/load-images/"/>
    
  </entry>
  
  <entry>
    <title>9. _read_images 从二进制文件中读取类信息</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/9__read_images/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/9__read_images/</id>
    <published>2018-11-27T02:38:11.000Z</published>
    <updated>2018-11-30T06:52:54.328Z</updated>
    
    <content type="html"><![CDATA[<p>_read_images从镜像文件中读取所有类信息、方法信息、分类信息。这篇文章就介绍具体读取了什么信息。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Mach-O 运行的时候，通过dylb加载到内存，须进一步提取出详细的信息，进而使用Mach-O中的类、方法。dylb加载完Mach-O文件后，通知runtime，调用_read_images ，_read_images就是将Mach-O文件中的DATA segment中的数据读入到对应的数据结构中，方便使用。<br><img src="/wiki/IOS/Runtime/objc/9__read_images/read_image_overal.png" alt="_read_images 的意义"></p><p>读取的所有section：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/DATA Segment.png" alt="_read_images 读取的数据示意图"></p><h2 id="read-images函数-代码分析"><a href="#read-images函数-代码分析" class="headerlink" title="_read_images函数 代码分析"></a>_read_images函数 代码分析</h2><h3 id="读取Mach-O指定Section的基础设施"><a href="#读取Mach-O指定Section的基础设施" class="headerlink" title="读取Mach-O指定Section的基础设施"></a>读取Mach-O指定Section的基础设施</h3><p>首先登场的是GETSECT，位于objc-file.mm文件中，GETSECT宏可以生成不同的函数。函数名为name，这些函数完成读取Mach-O文件指定Section的内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">type *name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">    return getDataSection&lt;type&gt;(mhdr, sectname, <span class="literal">nil</span>, outCount);     \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">type *name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">    return getDataSection&lt;type&gt;(hi-&gt;mhdr, sectname, <span class="literal">nil</span>, outCount); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部会调用getDataSection 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">getDataSection</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">const</span> <span class="keyword">char</span> *sectname, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> *outBytes, <span class="keyword">size_t</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> byteCount = <span class="number">0</span>;</span><br><span class="line">    T* data = (T*)getsectiondata(mhdr, <span class="string">"__DATA"</span>, sectname, &amp;byteCount);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_CONST"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_DIRTY"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outBytes) *outBytes = byteCount;</span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = byteCount / <span class="keyword">sizeof</span>(T);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDataSection 函数会读取<strong>DATA、</strong>DATA_CONST、__DATA_DIRTY Segement中名为sectname的section。</p><p>下面是使用GETSECT定义的函数列表。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//      function name                 content type     section name</span><br><span class="line">GETSECT(<span class="name">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">"__objc_selrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2MessageRefs</span>,         message_ref_t,   <span class="string">"__objc_msgrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassRefs</span>,           Class,           <span class="string">"__objc_classrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2SuperRefs</span>,           Class,           <span class="string">"__objc_superrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2NonlazyClassList</span>,    classref_t,      <span class="string">"__objc_nlclslist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2CategoryList</span>,        category_t *,    "__objc_catlist");</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="string">"__objc_nlcatlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ProtocolList</span>,        protocol_t *,    "__objc_protolist");</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="string">"__objc_protorefs"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面10行代码定了了10个函数，分别读取10种section的内容。例如_getObjc2ClassList 函数，会读取 __objc_classlist section，也就是读取镜像中的所有类的列表。 这些函数下面都会用到，是这篇文章的基础。</p><h3 id="首次执行任务—申请存放类的映射表"><a href="#首次执行任务—申请存放类的映射表" class="headerlink" title="首次执行任务—申请存放类的映射表"></a>首次执行任务—申请存放类的映射表</h3><p>_read_images 定义如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(<span class="name">header_info</span> **hList, uint32_t hCount)</span><br></pre></td></tr></table></figure><p>入参是map_images_nolock函数处理过的、非重复的、镜像列表和个数。下面只介绍重要的代码段，有部分代码会被忽略，全部代码请看OBJC4源码库。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!doneOnce) </span><br><span class="line"> &#123; <span class="comment">// 这个块里的代码只会执行一次</span></span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// Count classes. Size various table based on the total.</span></span><br><span class="line">        <span class="comment">// 计算类的总数</span></span><br><span class="line">        int <span class="keyword">total</span> = 0; <span class="comment">// 总数</span></span><br><span class="line">        int unoptimizedTotal = 0; <span class="comment">// 未优化的类的总数，不包括处于 shared cache 中的类</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">            <span class="keyword">if</span> (_getObjc2ClassList(hi, &amp;<span class="keyword">count</span>)) &#123; <span class="comment">// 获得 header 中所有 objective-2.0 类的列表</span></span><br><span class="line">                <span class="keyword">total</span> += (int)<span class="keyword">count</span>; <span class="comment">// 总数累加</span></span><br><span class="line">                <span class="keyword">if</span> (!hi-&gt;inSharedCache) &#123; <span class="comment">// 如果 header 不在 shared cache 的话，未优化的类的总数累加</span></span><br><span class="line">                    unoptimizedTotal += <span class="keyword">count</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// gdb_objc_realized_classes 中装的是不在 shared cache 中的类，所以如果经过了预优化，</span></span><br><span class="line">        <span class="comment">// 那么就只考虑未优化的那些类，即 unoptimizedTotal，否则考虑全部类 total</span></span><br><span class="line">        int namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotal : <span class="keyword">total</span>) * 4 / 3;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// realizedClasses and realizedMetaclasses - less than the full total</span></span><br><span class="line">        realized_class_hash = </span><br><span class="line">            NXCreateHashTable(NXPtrPrototype, <span class="keyword">total</span> / 8, nil);</span><br><span class="line">        realized_metaclass_hash = </span><br><span class="line">            NXCreateHashTable(NXPtrPrototype, <span class="keyword">total</span> / 8, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define EACH_HEADER \                 </span></span><br><span class="line">    hIndex = <span class="number">0</span>;         <span class="string">\</span></span><br><span class="line">    crashlog_header_name(nil) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); <span class="string">\</span></span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><p>上面代码完成的工作：</p><ol><li>这段代码只有第一次进入_read_images才执行，只能执行一次；</li><li>通过_getObjc2ClassList函数获取__objc_classlist section中的所有类的总数 total、不在shared cache中的类的个数unoptimizedTotal；</li><li>创建gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个hash表， 容量由total、unoptimizedTotal 决定。</li></ol><p>gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个表的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/三种全局数据结构.png" alt="存储类的数据结构"></p><h3 id="读取-objc-classlist（所有类列表，存储到gdb-objc-realized-classes-map中"><a href="#读取-objc-classlist（所有类列表，存储到gdb-objc-realized-classes-map中" class="headerlink" title="读取__objc_classlist（所有类列表，存储到gdb_objc_realized_classes map中"></a>读取__objc_classlist（所有类列表，存储到gdb_objc_realized_classes map中</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///代码位于objc-runtime-new文件中</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    bool headerIsBundle = hi-&gt;isBundle(); <span class="comment">// header 是否是 bundle 类型</span></span><br><span class="line">    bool headerIsPreoptimized = hi-&gt;isPreoptimized(); <span class="comment">// header 是否经过预优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 header 中的所有的 objective-c 2.0 的类</span></span><br><span class="line">    classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历类列表</span></span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        <span class="comment">// 读取该类，会做一些处理，取得新类(逻辑很复杂，完全懵圈)</span></span><br><span class="line">        Class <span class="keyword">new</span><span class="type">Cls</span> = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获得的是一个非空的新类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Cls</span> != cls  &amp;&amp;  <span class="keyword">new</span><span class="type">Cls</span>) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 类被移动了，但是没有被删除，</span></span><br><span class="line">            <span class="comment">// 这只会发生在新类 resolve 了一个 future 类的情况下</span></span><br><span class="line">            <span class="comment">// 下面以非惰性的方法 realize 了 newCls</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为 resolvedFutureClasses 数组重新开辟一块更大的空间，并将原来的数据拷贝进来</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                realloc(resolvedFutureClasses, </span><br><span class="line">                                  (resolvedFutureClassCount+<span class="number">1</span>) </span><br><span class="line">                                  * sizeof(Class));</span><br><span class="line">            <span class="comment">// 将 newCls 添加到数组的末尾，resolvedFutureClassCount 加 1</span></span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = <span class="keyword">new</span><span class="type">Cls</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GETSECT(_getObjc2ClassList,           classref_t,      <span class="string">"__objc_classlist"</span>);</span><br></pre></td></tr></table></figure><p>这段代码循环所有镜像，通过_getObjc2ClassList函数，读取每个镜像中的__objc_classlist  section中的所有类，然后对每个类调用readClass函数。readClass如果返回的类是future类，存储到resolvedFutureClasses数组中，后面会实现这些future类。</p><h4 id="objc-classlist-理解"><a href="#objc-classlist-理解" class="headerlink" title="__objc_classlist 理解"></a>__objc_classlist 理解</h4><p>首先创建一个命令行程序，添加如下代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">LJPersion </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> LJPersion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (NSString*) classMethod</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (NSString *) <span class="selector-tag">instanceMethod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>编译完成后，使用mashOView 查看__objc_classlist内容：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_section.png" alt="__objc_classlist section "></p><p>__objc_classlist 就是这个镜像中所有的类的列表，我新建的程序只有一个类LJPersion，根据图所示，LJPersion 应该存储在0x0000000100001150中， 然后用hopper 查看0x0000000100001150处的内容，验证存储的内容是否是LJPersion类。</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_LJPersion.png" alt="LJPersion 反汇编结果"></p><p>可以确定0x0000000100001150地址存储的内容就是LJPersion类，同时可以看出类的数据中保存着instanceMethod方法，元类中保存着classMethod方法。</p><h4 id="readClass代码分析"><a href="#readClass代码分析" class="headerlink" title="readClass代码分析"></a>readClass代码分析</h4><p>通过<code>classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</code>将 hi表示的镜像中的所有类读取到classlist中，然后对classlist中的每个类调用readClass函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 读取一个编译器写的 类 或 元类，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 返回新类的指针，有可能是：</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - cls</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - nil (cls 有一个 missing weak-linked 的父类)</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - 同名的 future 类，该 future 类填充了 cls 类的信息</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 调用者：<span class="emphasis">_read_</span>images() / objc_readClassPair()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line">Class readClass(Class cls,</span><br><span class="line">                <span class="built_in">bool</span> headerIsBundle<span class="comment">/*是否是 bundle*/</span>,</span><br><span class="line">                <span class="built_in">bool</span> headerIsPreoptimized<span class="comment">/*是否被预优化过，即是否来自 shared cache*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> char *mangledName = cls-&gt;mangledName(); <span class="comment">// 取得 cls 的重整后的名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123; <span class="comment">// 查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing</span></span><br><span class="line">        <span class="comment">// 祖宗类里有 missing weak-linked 的</span></span><br><span class="line">        <span class="comment">// 则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -&gt; nil</span></span><br><span class="line">        </span><br><span class="line">        addRemappedClass(cls, nil); <span class="comment">// 将其添加到重映射表里，映射为nil</span></span><br><span class="line">        cls-&gt;superclass = nil; <span class="comment">// 父类指针指向 nil</span></span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class replacing = nil; <span class="comment">// 记录被代替的类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试将 mangledName 对应的 future 的类从 future_named_class_map 中弹出</span></span><br><span class="line">    <span class="comment">// 如果返回的 newCls 有值，则 newcls 类是以前开辟的一个同名的 future 类，</span></span><br><span class="line">    <span class="comment">// 这个 future 类现在得到了兑现，因为有一个同名的新类 cls 进来了，</span></span><br><span class="line">    <span class="comment">// future 类里的信息会由 cls 中的信息填充（原来 future 类只开辟了内存，里面其实是啥都没的）</span></span><br><span class="line">    <span class="comment">// 并将 cls 代替</span></span><br><span class="line">    <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">        <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">        <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">        <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但是 newcls 不能是 swift 类，因为太大了？啥意思？swift类能有多大</span></span><br><span class="line">        <span class="keyword">if</span> (newCls-&gt;isSwift()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                        <span class="string">"because the real class is too big."</span>, </span><br><span class="line">                        cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        class_rw_t *rw = newCls-&gt;data();     <span class="comment">// 取得 newCls 中的 rw，rw 中除了 ro 外的其他数据是需要保留的</span></span><br><span class="line">        <span class="keyword">const</span> class_ro_t *old_ro = rw-&gt;ro;   <span class="comment">// 旧的 ro</span></span><br><span class="line">        memcpy(newCls, cls, sizeof(objc_class)); <span class="comment">// 将 cls 中的数据完整得拷贝到 newCls 中</span></span><br><span class="line">        rw-&gt;ro = (class_ro_t *)newCls-&gt;data();   <span class="comment">// rw 中使用新的 ro</span></span><br><span class="line">        newCls-&gt;setData(rw);        <span class="comment">// 将 rw 赋给 newCls，那么 newCls 中使用的还是原来的 rw，只是其中的 ro 变了</span></span><br><span class="line">        free((<span class="keyword">void</span> *)old_ro-&gt;name); <span class="comment">// 旧 ro 中的 name 是在堆上分配的，所以需要释放</span></span><br><span class="line">        free((<span class="keyword">void</span> *)old_ro);       <span class="comment">// 将旧 ro 释放</span></span><br><span class="line">        </span><br><span class="line">        addRemappedClass(cls, newCls); <span class="comment">// 将 cls -&gt; newCls 的重映射添加到映射表中</span></span><br><span class="line">        </span><br><span class="line">        replacing = cls; <span class="comment">// 记录下 cls 类被代替</span></span><br><span class="line">        cls = newCls;   <span class="comment">// 新类 newCls 赋给 cls</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123; <span class="comment">// 预优化过，且没有被代替</span></span><br><span class="line">        <span class="keyword">assert</span>(getClass(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 mangledName -&gt; cls 的映射添加到 gdb_objc_realized_classes 表中</span></span><br><span class="line">        <span class="comment">// 如果上 cls 被 newCls 代替了，那么 replacing 就是老的 cls，即在 gdb_objc_realized_classes 中</span></span><br><span class="line">        <span class="comment">// 也会将老的 cls 代替</span></span><br><span class="line">        addNamedClass(cls, mangledName, replacing);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的完成的任务用下图表示：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/readClass_liuchengtu.png" alt="LJPersion 反汇编结果"></p><p>其中missingWeakSuperclass 确定cls的祖宗类是否缺失：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 cls 类的祖宗类中是否有类是 weak-linked 的，或者说已经 missing(丢失)</span></span><br><span class="line"><span class="comment">// 这是一个递归函数</span></span><br><span class="line">static <span class="keyword">bool</span> </span><br><span class="line">missingWeakSuperclass(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!<span class="keyword">cls</span>-&gt;isRealized()); <span class="comment">// cls 不能是已经 realized 的类，因为 realized 的类一定是正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>-&gt;superclass) &#123; <span class="comment">// 如果没有父类，则看它是否是根类，若是根类，那么就是正常的，否则它的父类就是丢了</span></span><br><span class="line">                            <span class="comment">// 结束递归</span></span><br><span class="line">        <span class="comment">// superclass nil. This is normal for root classes only.</span></span><br><span class="line">        <span class="keyword">return</span> (!(<span class="keyword">cls</span>-&gt;data()-&gt;flags &amp; RO_ROOT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// superclass not nil. Check if a higher superclass is missing.</span></span><br><span class="line">        <span class="comment">// 如果有父类，则递归调用一直向上查找祖宗类，看是否有丢的了</span></span><br><span class="line">        Class supercls = remapClass(<span class="keyword">cls</span>-&gt;superclass); <span class="comment">// 取得重映射的父类，如果父类是 weak-link 的，</span></span><br><span class="line">                                                      <span class="comment">// 则 remapClass 会返回 nil</span></span><br><span class="line">        assert(<span class="keyword">cls</span> != <span class="keyword">cls</span>-&gt;superclass); <span class="comment">// 这两个断言很奇怪，完全想不到什么奇葩情况下这两个断言会不成立</span></span><br><span class="line">        assert(<span class="keyword">cls</span> != supercls);</span><br><span class="line">        <span class="keyword">if</span> (!supercls) <span class="keyword">return</span> YES; <span class="comment">// 如果父类是 weak-link 的，则 supercls 为 nil，返回 YES，结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;isRealized()) <span class="keyword">return</span> NO; <span class="comment">// 如果父类已经被 realized，则直接返回 NO，因为 realized 的类一定是正常的</span></span><br><span class="line">                                               <span class="comment">// 结束递归</span></span><br><span class="line">        <span class="keyword">return</span> missingWeakSuperclass(supercls); <span class="comment">// 否则递归寻找祖宗类们</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重映射表中查找key为cls的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 cls 类的 live class（活动的类）指针，这个指针可能指向一个已经被 reallocated 的结构体（#疑问：什么意思？？）</span></span><br><span class="line"><span class="comment">// 若 cls 是 weak linking（弱连接），则 cls 会被忽略，而返回 nil</span></span><br><span class="line"><span class="comment">// 调用者 ：_class_remap() / missingWeakSuperclass() / realizeClass() /</span></span><br><span class="line"><span class="comment">//         remapClass() / remapClassRef()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class c2; <span class="comment">// 这里没有初始化为 nil，有没有可能指向一块垃圾内存？？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil; <span class="comment">// 如果 cls 是 nil，则直接返回 nil</span></span><br><span class="line"></span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = remappedClasses(NO); <span class="comment">// 取得 remapped_class_map 映射表，若为空，不创建</span></span><br><span class="line">    <span class="comment">// 如果 map 非空，或者 cls 不是一个 key，NX_MAPNOTAKEY(not a key)，即 cls 压根儿不在 remapped_class_map 映射表里</span></span><br><span class="line">    <span class="comment">// 则将 cls 返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>  ||  NXMapMember(<span class="built_in">map</span>, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;  <span class="comment">// 1. 如果 map 是空，则返回的 c2 == nil（#疑问：有没有可能是垃圾内存？？），因为 || 的断路特点，后面的代码不会执行</span></span><br><span class="line">                    <span class="comment">// 2. 如果 map 不为空，并且 cls 确实是 remapped_class_map 中的 key，则 c2 就是取得的 value</span></span><br><span class="line">                    <span class="comment">//      但是其中 key 如果是 ignored weak-linked class 的话，c2 就是 nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remapClass 函数功能是： 从remapped_class_map表中取key为cls的内容。 如果表位空，或者表中没有，直接返回cls，否则返回表中内容。</p><p>addRemappedClass 添加成员到重映射表：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个 remapped 的类到 remapped_class_map 映射表中</span></span><br><span class="line"><span class="comment">// newcls 是一个已经被 realized 的 future 类，oldcls 是老的 future 类</span></span><br><span class="line"><span class="comment">// 或者 newcls 是 nil，oldcls 是 ignored weak-linked 类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRemappedClass(Class oldcls, Class newcls)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    <span class="comment">// 将 oldcls 为 key，newcls 为 value 插入到 remapped_class_map 映射表 中，</span></span><br><span class="line">    <span class="comment">// remappedClasses(YES) 中 YES 是指定如果 remapped_class_map 为空的话，就创建一个</span></span><br><span class="line">    old = NXMapInsert(remappedClasses(YES), oldcls, newcls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// old 不能为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将oldcls：newcls 添加到 重映射remapped_class_map表中。</p><p>popFutureNamedClass 函数定义如下:</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定 name 对应的 future 类从 future_named_class_map 中移除</span></span><br><span class="line"><span class="comment">// 因为 这个类 已经被 realized 过了，它已经不再处于 future 状态</span></span><br><span class="line"><span class="comment">// 返回 name 对应的 future class，如果没有对应的 future class，就返回 nil</span></span><br><span class="line"><span class="comment">// caller : readClass()</span></span><br><span class="line">static Class popFutureNamedClass(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap) &#123; <span class="comment">// 如果 future_named_class_map 非空</span></span><br><span class="line">        <span class="comment">// 利用 key name 将 future class 从 future_named_class_map 移除</span></span><br><span class="line">        <span class="comment">// NXMapKeyFreeingRemove 与 NXMapRemove 功能一样，但是会释放 key，因为 key 是在堆中分配的，原因见 NXMapKeyCopyingInsert()</span></span><br><span class="line">        cls = (Class)NXMapKeyFreeingRemove(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap, name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 name 确实有对应的 future class，并且当前 future_named_class_map 已经空了</span></span><br><span class="line">        <span class="comment">// 就将 future_named_class_map 释放</span></span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; NXCountMapTable(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap) == <span class="number">0</span>) &#123;</span><br><span class="line">            NXFreeMapTable(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap);</span><br><span class="line">            future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap = nil; <span class="comment">// 防止野指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从future_named_class_map中弹出指定名称的类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>addNamedClass</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Adds name =&gt; cls to </span>the<span class="markdown"> named non-meta class map.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Warns about duplicate class names and keeps </span>the<span class="markdown"> old mapping.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: runtimeLock must be held by </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 添加 name -&gt; cls 对到 named non-meta class map（gdb<span class="emphasis">_objc_</span>realized_classes）中</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 警告有副本，但是会保持老的映射，即会有多份，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 新的映射被存在了 secondary metaclass map(二级元类映射表) 表中，见 addNonMetaClass()，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> replacing : 被代替的老的 cls (见 readClass()) 如果有旧映射，但是与 replacing 不符合，还是会保留旧映射，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">             否则新值会将 gdb_objc_realized_classes 中的旧映射覆盖</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 调用者：objc<span class="emphasis">_duplicateClass() / objc_</span>registerClassPair() / readClass()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addNamedClass(Class cls, <span class="keyword">const</span> char *name, Class replacing = nil)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    Class old;</span><br><span class="line">    <span class="comment">// 先根据 name 查找是否有对应的旧类，如果有，并且 old 与 replacing 不同</span></span><br><span class="line">    <span class="comment">// 则报警告，但是会保持老的映射，插入新的映射</span></span><br><span class="line">    <span class="keyword">if</span> ((old = getClass(name))  &amp;&amp;  old != replacing) &#123;</span><br><span class="line">        </span><br><span class="line">        inform_duplicate(name, old, cls); <span class="comment">// 给出警告：名字为 name 的类有两份实现，但只有一份会被使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getNonMetaClass uses name lookups. Classes not found by name </span></span><br><span class="line">        <span class="comment">// lookup must be in the secondary meta-&gt;nonmeta table.</span></span><br><span class="line">        addNonMetaClass(cls); <span class="comment">// 将 cls 存入 matacls-&gt;cls 的二级映射表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有旧值，或者指定要覆盖旧值（replacing == old），就将新的 name-&gt;cls 对插入 gdb_objc_realized_classes</span></span><br><span class="line">        NXMapInsert(gdb_objc_realized_classes, name, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(!(cls-&gt;data()-&gt;flags &amp; RO_META)); <span class="comment">// cls 不能是元类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类添加到一级或者二级缓存中。</p><p>readClass 做了下面三件事：</p><ol><li>如果class的祖宗类丢失，将类添加到NXMapTable *remapped_class_map表中，key是cls，value是nil。 最后直接返回 nil。</li><li>从future_named_class_map中查找cls是否是future类，如果是，通过cls实现future类，然后将结果添加到remapped_class_map中，key是cls，value是实现完成的future类——newCls。 同时调用addNamedClass函数，将newCls添加到gdb_objc_realized_classes或 nonmeta_class_map表中。</li><li>其他情况，直接调用addNamedClass函数，将类添加到gdb_objc_realized_classes或nonmeta_class_map表中。 返回cls。  一般代码走这一步。</li></ol><p>下面是这段代码使用的几个新表:</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_readImage_data.png" alt="readClass 使用的表汇总 "></p><h4 id="将类读取到gdb-objc-realized-classes的意义"><a href="#将类读取到gdb-objc-realized-classes的意义" class="headerlink" title="将类读取到gdb_objc_realized_classes的意义"></a>将类读取到gdb_objc_realized_classes的意义</h4><p>为了说明读取类到gdb_objc_realized_classes的意义，举个例子，objc_getClass函数就是通过名字获取对应的类：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">look_up_class</span><span class="params">(aClassName, NO, YES)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 look_up_class 函数：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class </span><br><span class="line">look_up_class(<span class="keyword">const</span> <span class="keyword">char</span> *name, </span><br><span class="line">              <span class="keyword">bool</span> includeUnconnected __attribute__((unused)), </span><br><span class="line">              <span class="keyword">bool</span> includeClassHandler __attribute__((unused)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> nil; <span class="comment">// 类名不能为 nil，否则不能查</span></span><br><span class="line"></span><br><span class="line">    Class result;</span><br><span class="line">    <span class="keyword">bool</span> unrealized;</span><br><span class="line">    &#123; <span class="comment">// 加函数块是为了能实现自动释放 runtimeLock 锁，下面也一样</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">rwlock_reader_t <span class="title">lock</span>(<span class="params">runtimeLock</span>)</span>; <span class="comment">// 加读锁</span></span><br><span class="line">        result = getClass(name); <span class="comment">// 利用 getClass 函数查找类</span></span><br><span class="line">        unrealized = result  &amp;&amp;  !result-&gt;isRealized(); <span class="comment">// 如果找到了类，且类没有被 realize，就标记为 unrealized</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unrealized) &#123; <span class="comment">// 类存在，且没有被 realize</span></span><br><span class="line">        <span class="function">rwlock_writer_t <span class="title">lock</span>(<span class="params">runtimeLock</span>)</span>; <span class="comment">// 加写锁</span></span><br><span class="line">        realizeClass(result); <span class="comment">// 将类 realize 了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 getClass函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 name 查找类，实际上调用的还是 getClass_impl，但是需要对 swift 的类做一些处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// 必须事先被加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try name as-is</span></span><br><span class="line">    Class result = getClass_impl(name); <span class="comment">// 先直接用 name 查找</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 找到直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到，就处理成 swift 类的 mangled name 试试</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try Swift-mangled equivalent of the given name.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">char</span> *swName = copySwiftV1MangledName(name)) &#123; <span class="comment">// 尝试转成 swift mangled name，函数里判断 name 是否符合</span></span><br><span class="line">                                                       <span class="comment">// swift unmangled name(重整前的名字) 的格式，如果符合就返回 mangled name，</span></span><br><span class="line">                                                       <span class="comment">// 否则返回 nil</span></span><br><span class="line">        result = getClass_impl(swName); <span class="comment">// 用 mangled name 再去找</span></span><br><span class="line">        <span class="built_in">free</span>(swName); <span class="comment">// 将 swName 释放，原因见 copySwiftV1MangledName()</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 不用再判断 result 是否有值，直接将它返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil; <span class="comment">// 如果连 swift 类都不是，就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用getClass_impl 函数</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据名字查找类，这个类可能没有被 realize 过</span></span><br><span class="line"><span class="comment">// 该函数被 getClass() 函数调用</span></span><br><span class="line"><span class="keyword">static</span> Class getClass_impl(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// 必须事先被加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocated in _read_images </span></span><br><span class="line">    <span class="keyword">assert</span>(gdb_objc_realized_classes); <span class="comment">// gdb_objc_realized_classes 是在 _read_images() 函数中被初始化的(分配内存)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try runtime-allocated table</span></span><br><span class="line">    <span class="comment">// 从 gdb_objc_realized_classes 根据 key 即 name 查找类</span></span><br><span class="line">    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 找到了，就将其返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try table from dyld shared cache</span></span><br><span class="line">    <span class="comment">// 如果在 gdb_objc_realized_classes 中找不到，就去预优化的类中找找看（跟 dyld shared cache 有关）</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getPreoptimizedClass</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面就是使用了gdb_objc_realized_classes。</p><h3 id="读取-getObjc2ClassRefs、-getObjc2SuperRefs（使用的类、父类），修正重映射类表"><a href="#读取-getObjc2ClassRefs、-getObjc2SuperRefs（使用的类、父类），修正重映射类表" class="headerlink" title="读取_getObjc2ClassRefs、_getObjc2SuperRefs（使用的类、父类），修正重映射类表"></a>读取_getObjc2ClassRefs、_getObjc2SuperRefs（使用的类、父类），修正重映射类表</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up remapped classes</span></span><br><span class="line"><span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line"><span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 如果 remapped_class_map 不是空的</span></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">        <span class="comment">// 取得 header 中所有的类引用</span></span><br><span class="line">        Class *classrefs = <span class="variable">_getObjc2ClassRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">        <span class="comment">// 遍历这些类引用，fix-up 类引用，从重映射类表中取出新类，如果旧类新类不一致，就将新类赋给这个类引用</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn't test future1 catch the absence of this?</span></span><br><span class="line">        <span class="comment">// 取得镜像中所有类的父类引用</span></span><br><span class="line">        classrefs = <span class="variable">_getObjc2SuperRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">        <span class="comment">// 遍历父类引用，将其 fix-up 了</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过_getObjc2ClassRefs、_getObjc2SuperRefs读取<strong>objc_classrefs、</strong>objc_superrefs， 也就是读取程序中引用的类、父类，将classrefs分别调用remapClassRef，修正重映射表——–remapped_class_map。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>remapClassRef</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Fix up </span>a<span class="markdown"> class ref, in case </span>the<span class="markdown"> class referenced has been reallocated </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>or is </span>an<span class="markdown"> ignored weak-linked class.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: runtimeLock must be read- or write-locked by </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="comment">// fix-up 一个类引用，万一这个类引用指向的类已经被 reallocated(重新分配？) 或者它是一个 ignored weak-linked 类</span></span><br><span class="line"><span class="comment">// 从重映射类表中用 *clsref 为 key 取出新类，如果 *clsref 不等于新类，则将新类赋给 *clsref</span></span><br><span class="line"><span class="comment">// clsref 是一个二级指针，它指向一个类的指针</span></span><br><span class="line"><span class="comment">// 调用者 ：_read_images()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> remapClassRef(Class *clsref)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class newcls = remapClass(*clsref); <span class="comment">// 用 *clsref 为 key 从重映射类表中取出新类</span></span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) &#123; <span class="comment">// 如果 *clsref 不等于新类，则将新类赋给 *clsref</span></span><br><span class="line">        *clsref = newcls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__objc_classrefs在Mach-O的结构如下。</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classref.png" alt="__objc_classrefs section "></p><h3 id="读取-objc-selrefs（方法列表）–将读取的方法注册到namedSelectors表中"><a href="#读取-objc-selrefs（方法列表）–将读取的方法注册到namedSelectors表中" class="headerlink" title="读取__objc_selrefs（方法列表）–将读取的方法注册到namedSelectors表中"></a>读取__objc_selrefs（方法列表）–将读取的方法注册到namedSelectors表中</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @selector references fixup @selector 引用</span></span><br><span class="line"><span class="keyword">static</span> size_t UnfixedSelectors; <span class="comment">// 记录 hList 中所有镜像中一共有多少 unfixed 的 selector</span></span><br><span class="line">sel_lock(); <span class="comment">// selLock 上写锁</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    <span class="comment">// 只处理没有预优化的，被预优化过的就跳过</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isBundle = hi-&gt;isBundle(); <span class="comment">// 是否是 bundle</span></span><br><span class="line">    <span class="comment">// 取得镜像中所有的 selector 引用</span></span><br><span class="line">    SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">    UnfixedSelectors += count; <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历刚才取出的 selector</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *name = sel_cname(sels[i]); <span class="comment">// 转为char * 字符串</span></span><br><span class="line">        sels[i] = sel_registerNameNoLock(name, isBundle); <span class="comment">// 注册这个 selector 的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取Mach-O中的__objc_selrefs section，调用sel_registerNameNoLock方法注册。 </p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 注册 <span class="type">SEL</span> 的名字，不加锁</span><br><span class="line"><span class="type">SEL</span> sel_registerNameNoLock(<span class="keyword">const</span> <span class="built_in">char</span> *name, <span class="built_in">bool</span> copy) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">0</span>, copy);  // <span class="type">NO</span> lock, maybe copy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 注册 <span class="type">SEL</span> 的名字，能决定是否加锁和拷贝，拷贝即是否深拷贝 name，见 sel_alloc()</span><br><span class="line">// 调用者：sel_getUid() / sel_registerName() / sel_registerNameNoLock()</span><br><span class="line"><span class="keyword">static</span> <span class="type">SEL</span> __sel_registerName(<span class="keyword">const</span> <span class="built_in">char</span> *name, <span class="built_in">int</span> lock, <span class="built_in">int</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">SEL</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!namedSelectors) &#123;</span><br><span class="line">        namedSelectors = <span class="type">NXCreateMapTable</span>(<span class="type">NXStrValueMapPrototype</span>, </span><br><span class="line">                                          (unsigned)<span class="type">SelrefCount</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        // <span class="type">Rescan</span> <span class="keyword">in</span> <span class="keyword">case</span> it was added <span class="keyword">while</span> we dropped the lock</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">SEL</span>)<span class="type">NXMapGet</span>(namedSelectors, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="literal">result</span>) &#123;</span><br><span class="line">        <span class="literal">result</span> = sel_alloc(name, copy);</span><br><span class="line">        // fixme choose a better container (hash <span class="keyword">not</span> map <span class="keyword">for</span> starters)</span><br><span class="line">        <span class="type">NXMapInsert</span>(namedSelectors, sel_getName(<span class="literal">result</span>), <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) selLock.unlockWrite();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sel_registerNameNoLock 内部调用了__sel_registerName方法，将(sel Name：SEL) 对插入到namedSelectors表中。</p><p>为啥注册，下面有一段说明</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* @note You must register a method name with the Objective-C runtime<span class="built_in"> system </span><span class="keyword">to</span> obtain the</span><br><span class="line">*  method’s selector before you can <span class="builtin-name">add</span> the method <span class="keyword">to</span> a class definition. <span class="keyword">If</span> the method name</span><br><span class="line">*  has already been registered, this function simply returns the selector.</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>这里有一个新的表，结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/namedSelectors.png" alt="namedSelectors 表说明"></p><p> 读取的Mach-O 中__objc_selrefs 的内容如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_selref.png" alt="__objc_selrefs 示意图"></p><h4 id="将SEL存储到namedSelectors-Hash表的意义"><a href="#将SEL存储到namedSelectors-Hash表的意义" class="headerlink" title="将SEL存储到namedSelectors Hash表的意义"></a>将SEL存储到namedSelectors Hash表的意义</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Identifies a selector as being valid or invalid.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sel The selector you want to identify.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> YES if selector is valid and has a function implementation, NO otherwise. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@warning</span> On some platforms, an invalid reference (to invalid memory addresses) can cause</span></span><br><span class="line"><span class="comment"> *  a crash. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">BOOL</span> sel_isMapped(SEL sel)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>rumtime 提供了这样一个API，判断SEL 是否被映射，可能其他的系统库会调用。</p><h3 id="读取-objc-msgrefs（OBJC的消息），修正部分SEL的IMP"><a href="#读取-objc-msgrefs（OBJC的消息），修正部分SEL的IMP" class="headerlink" title="读取__objc_msgrefs（OBJC的消息），修正部分SEL的IMP"></a>读取__objc_msgrefs（OBJC的消息），修正部分SEL的IMP</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">       message_ref_t *refs = <span class="variable">_getObjc2MessageRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>) continue;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">           <span class="variable">_objc_inform</span>(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                        <span class="string">"call sites in %s"</span>, <span class="built_in">count</span>, hi-&gt;fname);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">           fixupMessageRef(refs+i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过 _getObjc2MessageRefs 读取Mach-O文件中的 __objc_msgrefs section。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复一个老的 vtable 调度</span></span><br><span class="line"><span class="comment">// 调用者：_read_images()</span></span><br><span class="line">static void </span><br><span class="line">fixupMessageRef(message_ref_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册消息的 sel</span></span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span><span class="function"><span class="title">sel</span> = sel_registerName((const char *)msg-&gt;</span>sel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (ignoreSelector(msg-&gt;</span>sel)) &#123; <span class="comment">// 如果 sel 是需要被忽略的，就将其 imp 设为 _objc_ignored_method</span></span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fixup) &#123; <span class="comment">// 如果消息的 imp 是 objc_msgSend_fixup，即指定了需要将 imp fixup</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>sel == SEL_alloc) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_alloc;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_allocWithZone) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_allocWithZone;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_retain) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_retain;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_release) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_release;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_autorelease) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_autorelease;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fixedup; <span class="comment">// 如果上面都不符合，就将它设置为已经 fixed-up 了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSendSuper2_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSendSuper2_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_stret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_stret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSendSuper2_stret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSendSuper2_stret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#<span class="keyword">if</span> defined(__i386__)  ||  defined(__x86_64__)</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fpret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fpret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> defined(__x86_64__)</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fp2ret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fp2ret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixupMessageRef 函数的作用是修正部分SEL的IMP。</p><h3 id="读取-objc-protolist（协议列表），添加到protocol-map表中"><a href="#读取-objc-protolist（协议列表），添加到protocol-map表中" class="headerlink" title="读取__objc_protolist（协议列表），添加到protocol_map表中"></a>读取__objc_protolist（协议列表），添加到protocol_map表中</h3><h4 id="objc-protolist-理解"><a href="#objc-protolist-理解" class="headerlink" title="__objc_protolist 理解"></a>__objc_protolist 理解</h4><p>编写下面代码，展示协议的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">LJProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">-(<span class="built_in">NSString</span> *) instanceMethod;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *) calssMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) instanceOptMethod;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *) calssOptMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * strProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>用machoview查看：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/protocal_LJProtocal_machoview.png" alt="__objc_protolist 示意图"></p><p>用hopper 查看地址0x 0000000100004260：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/proprotocal_LJProtocla_hoper.png" alt="LJProtocal使用hopper显示结构"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs. 取得镜像中的协议，读出协议</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    extern objc_class OBJC_CLASS_<span class="variable">$_Protocol</span>;</span><br><span class="line">    <span class="keyword">Class</span> cls = (<span class="keyword">Class</span>)&amp;OBJC_CLASS_<span class="variable">$_Protocol</span>;</span><br><span class="line">    <span class="keyword">assert</span>(cls);</span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    bool isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">    bool isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">    protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;<span class="keyword">count</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过_getObjc2ProtocolList 读取__objc_protolist section. 将读取的结果分别调用readProtocol函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个编译器写的协议</span></span><br><span class="line"><span class="comment">// 调用者：_read_images()</span></span><br><span class="line">static void</span><br><span class="line">readProtocol(protocol_t *newproto,</span><br><span class="line">             Class protocol_class,</span><br><span class="line">             NXMapTable *protocol_map, </span><br><span class="line">             bool headerIsPreoptimized,</span><br><span class="line">             bool headerIsBundle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is not enough to make protocols in unloaded bundles safe, </span></span><br><span class="line">    <span class="comment">// but it does prevent crashes when looking up unrelated protocols.</span></span><br><span class="line">    <span class="comment">// 如果镜像是 bundle，就使用 NXMapKeyCopyingInsert 函数，否则使用 NXMapInsert</span></span><br><span class="line">    <span class="comment">// NXMapKeyCopyingInsert 会在堆中拷贝 key</span></span><br><span class="line">    auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新协议的重整名称，去 protocol_map 映射表中查找老的协议</span></span><br><span class="line">    <span class="function"><span class="title">protocol_t</span> *oldproto = (protocol_t *)getProtocol(newproto-&gt;</span>mangledName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldproto) &#123; <span class="comment">// 如果存在老的协议，就只报个警告，因为不允许有重名的协议</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headerIsPreoptimized) &#123; <span class="comment">// 如果不存在老的协议，但是镜像是经过预优化的</span></span><br><span class="line">        <span class="comment">// Shared cache initialized the protocol object itself, </span></span><br><span class="line">        <span class="comment">// but in order to allow out-of-cache replacement we need </span></span><br><span class="line">        <span class="comment">// to add it to the protocol table now.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据新协议的重整名称 查找 预优化的缓存协议</span></span><br><span class="line">        <span class="comment">// 但是 getPreoptimizedProtocol 现在一直返回 nil</span></span><br><span class="line">        protocol_t *cacheproto = (protocol_t *)</span><br><span class="line">            <span class="function"><span class="title">getPreoptimizedProtocol</span>(newproto-&gt;</span>mangledName);</span><br><span class="line">        </span><br><span class="line">        protocol_t *installedproto;</span><br><span class="line">        <span class="keyword">if</span> (cacheproto  &amp;&amp;  cacheproto != newproto) &#123;</span><br><span class="line">            <span class="comment">// Another definition in the shared cache wins (because </span></span><br><span class="line">            <span class="comment">// everything in the cache was fixed up to point to it).</span></span><br><span class="line">            installedproto = cacheproto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 因为 cacheproto 永远是 nil，所以一直走 else 分支</span></span><br><span class="line">            <span class="comment">// This definition wins.</span></span><br><span class="line">            installedproto = newproto;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">assert</span>(installedproto-&gt;</span>getIsa() == protocol_class);</span><br><span class="line">        <span class="function"><span class="title">assert</span>(installedproto-&gt;</span>size &gt;= sizeof(protocol_t));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 新协议的重整名称 -&gt; 新协议 的映射插入 protocol_map 映射表中</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, installedproto-&gt;</span>mangledName, </span><br><span class="line">                 installedproto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (newproto-&gt;</span>size &gt;= sizeof(protocol_t)) &#123; <span class="comment">// 如果不存在老的协议，且没有经过预优化，且新协议的大小</span></span><br><span class="line">                                                     <span class="comment">// 比 protocol_t 的标准尺寸要大</span></span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with sufficient storage. Fix it up in place.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        <span class="function"><span class="title">newproto</span>-&gt;</span>initIsa(protocol_class);  <span class="comment">// fixme pinned</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, newproto-&gt;</span><span class="function"><span class="title">mangledName</span>, newproto); // 就将 新协议的重整名称 -&gt;</span> 新协议 的映射插入</span><br><span class="line">                                                                 <span class="comment">// protocol_map 映射表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在老的协议，且没有经过预优化，且新协议的大小比 protocol_t 的标准尺寸要小</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with insufficient storage. Reallocate it.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取大的 size，这里按照上面的逻辑，应该是 sizeof(protocol_t)</span></span><br><span class="line">        <span class="function"><span class="title">size_t</span> size = max(sizeof(protocol_t), (size_t)newproto-&gt;</span>size);</span><br><span class="line">        <span class="comment">// 新建一个 installedproto 协议，在堆中分配内存，并清零</span></span><br><span class="line">        protocol_t *installedproto = (protocol_t *)calloc(size, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 newproto 内存上的内容 拷贝到 installedproto 中</span></span><br><span class="line">        <span class="function"><span class="title">memcpy</span>(installedproto, newproto, newproto-&gt;</span>size);</span><br><span class="line">        <span class="comment">// 将 installedproto-&gt;size 设为新的 size</span></span><br><span class="line">        <span class="function"><span class="title">installedproto</span>-&gt;</span><span class="function"><span class="title">size</span> = (__typeof__(installedproto-&gt;</span>size))size;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">installedproto</span>-&gt;</span>initIsa(protocol_class); <span class="comment">// 设置 isa  // fixme pinned</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 installedproto 插入 protocol_map 映射表中</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, installedproto-&gt;</span>mangledName, installedproto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readProtocol 将读取的协议，存储到protocol_map 表中。 </p><p>存储协议的hash表的介绍如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/protocol_map.png" alt="LJProtocal使用hopper显示结构"></p><h4 id="将协议存储到表的作用"><a href="#将协议存储到表的作用" class="headerlink" title="将协议存储到表的作用"></a>将协议存储到表的作用</h4><p>这里也是举个例子，例如，  NSObject的conformsToProtocol 方法，判断当前类是否遵守协议protocol：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环所有当前类–&gt;超类，调用 class_conformsToProtocol方法。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_conformsToProtocol(<span class="keyword">Class</span> cls, Protocol *proto_gen)</span><br><span class="line">&#123;</span><br><span class="line">    protocol_t *proto = newprotocol(proto_gen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">if</span> (!proto_gen) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    rwlock_reader_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (const <span class="built_in">auto</span>&amp; proto_ref : cls-&gt;data()-&gt;protocols) &#123;</span><br><span class="line">        protocol_t *p = remapProtocol(proto_ref);</span><br><span class="line">        <span class="keyword">if</span> (p == proto |<span class="type">| protocol_conformsToProtocol_nolock</span>(p, proto)) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出类cls中所有准守的协议，循环调用protocol_conformsToProtocol_nolock，判断两个协议是否一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">**********************************************************************/</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> </span><br><span class="line">protocol_conformsToProtocol_nolock(protocol_t *<span class="keyword">self</span>, protocol_t *other)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>  ||  !other) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// protocols need not be fixed up</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == strcmp(<span class="keyword">self</span>-&gt;mangledName, other-&gt;mangledName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;protocols) &#123;</span><br><span class="line">        uintptr_t i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>-&gt;protocols-&gt;count; i++) &#123;</span><br><span class="line">            protocol_t *proto = remapProtocol(<span class="keyword">self</span>-&gt;protocols-&gt;list[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcmp(other-&gt;mangledName, proto-&gt;mangledName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (protocol_conformsToProtocol_nolock(proto, other)) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果协议的整合名称mangledName一样，认为协议一致，否则循环self中剩下的协议，只要有一个相同，就认为是遵守。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> protocol_t *<span class="title">remapProtocol</span><span class="params">(<span class="keyword">protocol_ref_t</span> proto)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protocol_t</span> *newproto = (<span class="keyword">protocol_t</span> *)</span><br><span class="line">        getProtocol(((<span class="keyword">protocol_t</span> *)proto)-&gt;mangledName);</span><br><span class="line">    <span class="keyword">return</span> newproto ? newproto : (<span class="keyword">protocol_t</span> *)proto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remapProtocol 根据协议的引用在表中找到协议。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Protocol</span> *getProtocol(<span class="keyword">const</span> <span class="built_in">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // <span class="type">Try</span> name <span class="keyword">as</span>-<span class="keyword">is</span>.</span><br><span class="line">    <span class="type">Protocol</span> *<span class="literal">result</span> = (<span class="type">Protocol</span> *)<span class="type">NXMapGet</span>(protocols(), name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Try</span> <span class="type">Swift</span>-mangled equivalent <span class="keyword">of</span> the given name.</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">char</span> *swName = copySwiftV1MangledName(name, <span class="literal">true</span>/*isProtocol*/)) &#123;</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">Protocol</span> *)<span class="type">NXMapGet</span>(protocols(), swName);</span><br><span class="line">        free(swName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getProtocol 通过协议名称找到协议。</p><h3 id="读取-objc-nlclslist（none-lazy类），并实现类"><a href="#读取-objc-nlclslist（none-lazy类），并实现类" class="headerlink" title="读取__objc_nlclslist（none lazy类），并实现类"></a>读取__objc_nlclslist（none lazy类），并实现类</h3><p>__objc_nlclslist section中存储着这样的类：</p><ol><li>类中还有+load方法</li><li>类有静态实例</li></ol><p>这样的类会马上使用，所以需要立马初始化。</p><h4 id="objc-nlclslist-介绍"><a href="#objc-nlclslist-介绍" class="headerlink" title="__objc_nlclslist 介绍"></a>__objc_nlclslist 介绍</h4><p><img src="/wiki/IOS/Runtime/objc/9__read_images/nlclasslist_simple.png" alt="LJProtocal使用hopper显示结构"></p><p>上图说明 如果类中有+load方法，这个类在编译的时候就会放置到__objc_nlclslist section中。 图中上面部分是测试代码，中间部分是machoview查看结果，下面部分是使用hopper查看反汇编地址，证明40e0处存储的是persion类。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        &#123;</span><br><span class="line">        Class <span class="keyword">cls</span> = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">cls</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        realizeClass(<span class="keyword">cls</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类中有+load方法、或者类有静态实例，编译器会将类添加到<strong>objc_nlclslist section中。 上面代码读取</strong>objc_nlclslist 中的所有类，将读出的类调用realizeClass函数实现类。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看 runtimeLock 是否正确得加了写锁</span></span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) return <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果类已经被 realize 过，就不用 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">        return cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert(cls == remapClass(cls)); <span class="comment">// remapClass(cls) 得到的是 cls 对应的重映射类，</span></span><br><span class="line">                                    <span class="comment">// 如果 cls 不存在于 remapped_class_map 映射表，得到的才是 cls 本身，</span></span><br><span class="line">                                    <span class="comment">// 所以这里断言 cls == remapClass(cls) 就是看 cls 是否存在于 remapped_class_map 映射表</span></span><br><span class="line">                                    <span class="comment">// 不存在，就是正确；存在，就是错误</span></span><br><span class="line">                                    <span class="comment">// 不存在，则 cls 既不是 realized future class，也不是 ignored weak-linked class</span></span><br><span class="line">                                    <span class="comment">// 见 remappedClasses()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针</span></span><br><span class="line"><span class="comment">//    初始化一个 class_rw_t 结构体</span></span><br><span class="line"><span class="comment">//    设置结构体中 ro 的值以及 flag</span></span><br><span class="line"><span class="comment">//    最后设置正确的 data。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">ro</span> = (const class_ro_t *)cls-&gt;</span><span class="keyword">data</span>(); <span class="comment">// 因为在 realized 之前，objc_class 中的 class_data_bits_t bits 里</span></span><br><span class="line">                                          <span class="comment">// 本质上存的是 class_ro_t，所以这里只需要转成 class_ro_t 类型就可以了</span></span><br><span class="line">                                          <span class="comment">// 但 future 的类是例外!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 如果 ro 的 flag 里记录了这是一个 future 的类，那么 objc_class 中的 class_data_bits_t bits 里存的是 class_rw_t</span></span><br><span class="line">        <span class="comment">// rw 数据已经被分配好内存了，现在要做的就是填充信息</span></span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        <span class="function"><span class="title">rw</span> = cls-&gt;</span><span class="keyword">data</span>();  <span class="comment">// 取出 rw</span></span><br><span class="line">        <span class="function"><span class="title">ro</span> = cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>ro; <span class="comment">// 取出 ro</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); <span class="comment">// 清除 future 状态，RW_FUTURE 位的值置为 0</span></span><br><span class="line">                                                              <span class="comment">// 设置为 realized + realizing 状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                  <span class="comment">// RW_REALIZED 和 RW_REALIZING 位的值置为 1</span></span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        <span class="comment">// 正常的类的话，就需要开辟内存</span></span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>ro = ro; <span class="comment">// 将原来的 ro 赋给新 rw 中的 ro 字段</span></span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>flags = RW_REALIZED|RW_REALIZING; <span class="comment">// 设置为 realized + realizing 状态</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setData(rw); <span class="comment">// 将新的 rw 替换老的 rw</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">isMeta</span> = ro-&gt;</span>flags &amp; RO_META; <span class="comment">// cls 类是否是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span></span><br><span class="line">                            <span class="comment">// 版本，元类是 7，普通类是 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line">    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// remapClass() 函数是如果参数是一个已经 realized 的 future 类，则返回的是新类，否则返回的是自己</span></span><br><span class="line">    <span class="comment">// 查看 cls 的父类对应的重映射的类，将其 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">supercls</span> = realizeClass(remapClass(cls-&gt;</span>superclass));</span><br><span class="line">    <span class="comment">// 查看 cls 的元类对应的重映射的类，将其 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">metacls</span> = realizeClass(remapClass(cls-&gt;</span>ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>superclass = supercls; <span class="comment">// 更新 cls 的父类</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>initClassIsa(metacls); <span class="comment">// 和元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) &#123; <span class="comment">// 根据父类，调整 cls 类 ro 中实例变量的偏移量和布局</span></span><br><span class="line">                                 <span class="comment">// 可能重新分配 class_ro_t，更新 ro</span></span><br><span class="line">        reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set fastInstanceSize if it wasn't set already.</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">setInstanceSize</span>(ro-&gt;</span>instanceSize); <span class="comment">// 设置成员变量的新的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="comment">// 从 ro 拷贝一些 flag 到 rw 中，可能是为了加快查找速度</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_HAS_CXX_STRUCTORS) &#123; <span class="comment">// 是否有 C++ 构造器/析构器</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxDtor(); <span class="comment">// 设置有 C++ 析构器</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (! (ro-&gt;</span>flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123; <span class="comment">// 不只有 C++ 析构器，那么就是也有 C++ 构造器，真绕啊</span></span><br><span class="line">            <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect this class to its superclass's subclass lists</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 methodizeClass 函数来将分类中的方法列表、属性列表、协议列表加载到 methods、 properties 和 protocols 列表数组中</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isMeta) &#123; <span class="comment">// 如果不是元类</span></span><br><span class="line">        addRealizedClass(cls); <span class="comment">// 就把它添加到 realized_class_hash 哈希表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addRealizedMetaclass(cls); <span class="comment">// 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>realizeClass realize(实现) 指定的 cls 类：</p><ol><li>包括开辟它的 read-write data，也就是 rw，见 class_rw_t 结构体；</li><li>设置类的类型，元类or 普通类；</li><li>递归超类、元类，调用realizeClass。确保超类全部实现过；</li><li>设置superclass指针、元类指针；</li><li>reconcileInstanceVariables ；</li><li>addSubclass 构建类继承体系的链表；</li><li>methodizeClass 调整方法  ；</li><li>添加到全局表中。</li></ol><p>realizeClass 的总体流程如下图：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizeClass.png" alt="realizeClass 的总体流程"></p><h4 id="开辟rw"><a href="#开辟rw" class="headerlink" title="开辟rw"></a>开辟rw</h4><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizemethod_rw.png" alt="realizeClass 的总体流程"></p><p>开辟RW的工作就是：将class_data_bits_t结构中bits的3-&gt;47位指定的RO切断，创建新的class_rw_t结构，3-&gt;47位 重新存储新的class_rw_t结构地址，然后将class_rw_t结构中的ro指针指向原始的class_ro_t结构。</p><h4 id="reconcileInstanceVariables（没看）"><a href="#reconcileInstanceVariables（没看）" class="headerlink" title="reconcileInstanceVariables（没看）"></a>reconcileInstanceVariables（没看）</h4><p>这部分我也不会，没看。</p><h4 id="addSubclass"><a href="#addSubclass" class="headerlink" title="addSubclass"></a>addSubclass</h4><p>构建出的链表如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/addClass.png" alt="addSubclass 构成链表的示意图 "></p><h4 id="methodizeClass"><a href="#methodizeClass" class="headerlink" title="methodizeClass"></a>methodizeClass</h4><p>methodizeClass代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. fix-up cls 类的方法列表、协议列表、属性列表（但是看代码，被 fix-up 的只有方法列表啊）</span></span><br><span class="line"><span class="comment">//    将 cls 类的所有没有被 attach 的分类 attach 到 cls 上</span></span><br><span class="line"><span class="comment">// 2. 即将分类中的方法、属性、协议添加到 methods、 properties 和 protocols 中</span></span><br><span class="line"><span class="comment">//    runtimeLock 读写锁必须被调用者上写锁，保证线程安全</span></span><br><span class="line">static void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看调用者是否已经正确地将 runtimeLock 上了写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bool</span> isMeta = cls-&gt;</span>isMetaClass(); <span class="comment">// 记录 cls 类是否是元类</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> rw = cls-&gt;</span><span class="function"><span class="title">data</span>(); // 取得 cls 中的 rw，因为在 realizeClass() 中已经处理好了 cls-&gt;</span><span class="keyword">data</span>()，</span><br><span class="line">                           <span class="comment">// 所以里面现在存的确定是 rw，而不是 ro</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> ro = rw-&gt;</span><span class="function"><span class="title">ro</span>; // 取得 rw-&gt;</span>ro</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 取得 ro 中的 baseMethodList，在将其 prepare 后，插入 rw 的方法列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">method_list_t</span> *list = ro-&gt;</span>baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>methods.attachLists(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ro 中的 baseProperties 插入 rw 中的属性列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">property_list_t</span> *proplist = ro-&gt;</span>baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ro 中的 baseProtocols 插入 rw 中的协议列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">protocol_list_t</span> *protolist = ro-&gt;</span>baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRootMetaclass()) &#123; <span class="comment">// 如果是根元类</span></span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        <span class="comment">// 给根元类的 SEL_initialize 指定了对应的 IMP - objc_noop_imp</span></span><br><span class="line">        <span class="comment">// 即给根元类发送 SEL_initialize 消息，不会走到它的 +initialize，而是走 objc_noop_imp，里面啥也不干</span></span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="comment">// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing 其实这个参数压根没用*/</span>);</span><br><span class="line">    <span class="comment">// 从分类列表中添加方法列表、属性和协议到 cls 类中</span></span><br><span class="line">    <span class="comment">// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？</span></span><br><span class="line">    <span class="comment">// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的</span></span><br><span class="line">    <span class="comment">//         所以压根儿不用再另外排序</span></span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cats) &#123;</span><br><span class="line">        free(cats); <span class="comment">// 将分类列表释放，见 unattachedCategoriesForClass，</span></span><br><span class="line">                    <span class="comment">// 里面着重强调了调用方需要负责释放分类列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码完成的四个工作用图中的4条虚线表示：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizemethod_method.png" alt="methodizeClass 工作内容 "></p><p>接下来的工作是是分类的处理，这里需要详细的讲下，所以在分出一节 </p><h4 id="分类-处理"><a href="#分类-处理" class="headerlink" title="分类 处理"></a>分类 处理</h4><h5 id="分类的数据结构"><a href="#分类的数据结构" class="headerlink" title="分类的数据结构"></a>分类的数据结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放 locstamped_category_t 的列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count;  <span class="comment">// 数组有几个元素</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">locstamped_category_t</span> <span class="built_in">list</span>[<span class="number">0</span>]; <span class="comment">// 数组的起始地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地的盖了戳的 category，即已经被添加进了 unattachedCategories</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">category_t</span> *cat;   <span class="comment">//  category</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header_info</span> *<span class="title">hi</span>;</span>  <span class="comment">// 所属的 header，即所属的镜像</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 分类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">// 分类所属的类，classref_t 专门用于 unremapped 的类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>     <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>      <span class="comment">// 遵循的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性列表，但是并没有卵用... 唉....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/9__read_images/catogory_class.png" alt="分类数据结构 "></p><h5 id="存储所有分类的Map结构"><a href="#存储所有分类的Map结构" class="headerlink" title="存储所有分类的Map结构"></a>存储所有分类的Map结构</h5><p><img src="/wiki/IOS/Runtime/objc/9__read_images/category_map.png" alt="category_map 表 "></p><h5 id="向category-map中添加新的分类"><a href="#向category-map中添加新的分类" class="headerlink" title="向category_map中添加新的分类"></a>向category_map中添加新的分类</h5><p>向category_map中添加新的分类 调用addUnattachedCategoryForClass方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addUnattachedCategoryForClass</span><span class="params">(<span class="keyword">category_t</span> *cat, Class cls, header_info *catHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span></span><br><span class="line">    NXMapTable *cats = unattachedCategories(); <span class="comment">// 取得存储所有没有被 attached 的分类的列表</span></span><br><span class="line">    category_list *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从所有 unattached 的分类列表中取得 cls 类对应的所有没有被 attach 的分类列表</span></span><br><span class="line">    <span class="built_in">list</span> = (category_list *)NXMapGet(cats, cls);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list</span>) &#123; <span class="comment">// 如果 cls 没有未  attach 的分类</span></span><br><span class="line">        <span class="comment">// 就开辟出一个单位的空间，用来放新来的这个分类</span></span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>) + <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="number">0</span>]), <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则开辟出比原来多一个单位的空间，用来放新来的这个分类，因为 realloc ，所以原来的数据会被拷贝过来</span></span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            <span class="built_in">realloc</span>(<span class="built_in">list</span>, <span class="keyword">sizeof</span>(*<span class="built_in">list</span>) + <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="number">0</span>]) * (<span class="built_in">list</span>-&gt;count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的分类 cat 添加刚刚开辟的位置上</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="built_in">list</span>-&gt;count++] = (<span class="keyword">locstamped_category_t</span>)&#123;cat, catHeader&#125;;</span><br><span class="line">    <span class="comment">// 将新的 list 重新插入 cats 中，会覆盖老的 list</span></span><br><span class="line">    NXMapInsert(cats, cls, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/9__read_images/addUnattachedCategoryForClass.png" alt="category_map中插入cat"></p><h5 id="将分类附着（attachCategories）到类中"><a href="#将分类附着（attachCategories）到类中" class="headerlink" title="将分类附着（attachCategories）到类中"></a>将分类附着（attachCategories）到类中</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="comment">// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类</span></span><br><span class="line">category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing 其实这个参数压根没用*/</span>);</span><br><span class="line"><span class="comment">// 从分类列表中添加方法列表、属性和协议到 cls 类中</span></span><br><span class="line"><span class="comment">// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？</span></span><br><span class="line"><span class="comment">// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的</span></span><br><span class="line"><span class="comment">//         所以压根儿不用再另外排序</span></span><br><span class="line">attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>; <span class="comment">// 如果列表是 nil，直接返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印一些信息</span></span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) &#123;</span><br><span class="line">        printReplacements(cls, cats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass(); <span class="comment">// 记录 cls 类是否是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在堆中为方法列表数组、属性列表数组、协议列表数组分配足够大内存，注意，它们都是二维数组</span></span><br><span class="line">    <span class="comment">// 后面会将所有分类中的方法列表、属性列表、协议列表的首地址放到里面</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>; <span class="comment">// 记录方法的数量</span></span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>; <span class="comment">// 记录属性的数量</span></span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>; <span class="comment">// 记录协议的数量</span></span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count; <span class="comment">// 从后开始，保证先取最新的分类</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO; <span class="comment">// 记录是否是从 bundle 中取的</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i]; <span class="comment">// 分类，locstamped_category_t 类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中的方法列表；如果是元类，取得的是类方法列表；否则取得的是实例方法列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist; <span class="comment">// 将方法列表放入 mlists 方法列表数组中</span></span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle(); <span class="comment">// 分类的头部信息中存储了是否是 bundle，将其记住</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中的属性列表，如果是元类，取得是nil</span></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = entry.cat-&gt;propertiesForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist; <span class="comment">// 将属性列表放入 proplists 属性列表数组中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中遵循的协议列表</span></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist; <span class="comment">// 将协议列表放入 protolists 协议列表数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data(); <span class="comment">// 取出 cls 的 class_rw_t 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 mlists 中的方法列表们</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount<span class="comment">/*方法列表的数量*/</span>, NO<span class="comment">/*不是基本方法*/</span>, fromBundle<span class="comment">/*是否来自bundle*/</span>);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount); <span class="comment">// 将准备完毕的新方法列表们添加到 rw 中的方法列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(mlists); <span class="comment">// 释放 mlists</span></span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果需要清空方法缓存，并且刚才确实有方法列表添加进 rw 中，</span></span><br><span class="line">                                        <span class="comment">// 不然没有新方法加进来，就没有必要清空，清空是为了避免无法命中缓存的错误</span></span><br><span class="line">                                        <span class="comment">// 因为缓存位置是按照 hash 的方法确定的，详情见 cache_t::find() 函数</span></span><br><span class="line">        flushCaches(cls); <span class="comment">// 清空 cls 类 / cls 类的元类 / cls 类的子孙类 的方法缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount); <span class="comment">// 将新属性列表添加到 rw 中的属性列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(proplists); <span class="comment">// 释放 proplists</span></span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount); <span class="comment">// 将新协议列表添加到 rw 中的协议列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(protolists); <span class="comment">// 释放 protolists</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将 category_list *cats 中的list成员表示的方法列表转化为数组mlists：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/attachCategories_ToArray.png" alt="cats-&gt;list-&gt; mlists"></p><p>转化完成后，调用attachLists方法，附着到类上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将List** 中的内容附着到method_array_t 上,原理如图：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/attachLists_1.png" alt="构建list_array_tt结构 "></p><h4 id="添加全局表"><a href="#添加全局表" class="headerlink" title="添加全局表"></a>添加全局表</h4><p>添加的到全局表的代码如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isMeta) &#123; <span class="comment">// 如果不是元类</span></span><br><span class="line">    addRealizedClass(<span class="keyword">cls</span>); <span class="comment">// 就把它添加到 realized_class_hash 哈希表中</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addRealizedMetaclass(<span class="keyword">cls</span>); <span class="comment">// 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据类的类型，元类还是普通类，调用不同的方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRealizedClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = NXHashInsert(realizedClasses(), cls); <span class="comment">// 将 cls 插入 realized_class_hash 哈希表中</span></span><br><span class="line">    objc_addRegisteredClass(cls); <span class="comment">// 将 cls 添加到已注册类的哈希表中(objc-auto.mm 中的 AllClasses)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(!cls-&gt;isMetaClass()); <span class="comment">// cls 不能是元类</span></span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// 不能有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通类调用addRealizedClass方法，将类添加到realizedClasses()表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得存有所有经过 realized 的非元类的哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXHashTable *<span class="title">realizedClasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> realized_class_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回realized_class_hash hash表。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRealizedMetaclass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = NXHashInsert(realizedMetaclasses(), cls); <span class="comment">// 将 cls 元类添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">    <span class="keyword">assert</span>(cls-&gt;isMetaClass()); <span class="comment">// cls 必须是元类</span></span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// 不能有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元类调用addRealizedMetaclass 将类添加到 realizedMetaclasses()表中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得存有所有经过 realized 的元类的哈希表</span></span><br><span class="line"><span class="comment">// 该函数被 addRealizedMetaclass()/flushCaches()/removeRealizedMetaclass()函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXHashTable *<span class="title">realizedMetaclasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> realized_metaclass_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取分类，remethodize类"><a href="#读取分类，remethodize类" class="headerlink" title="读取分类，remethodize类"></a>读取分类，remethodize类</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    <span class="comment">// 取得 hi 镜像中的所有分类</span></span><br><span class="line">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历所有分类</span></span><br><span class="line">        category_t *cat = catlist[i];</span><br><span class="line">        C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls); <span class="comment">// 得到分类所属的类的 live class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123; <span class="comment">// 如果 cls 为空</span></span><br><span class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 分类所属的类丢了，很多可能是 weak-linked 了</span></span><br><span class="line">            <span class="comment">// 这个分类就是不可信的，完全没有什么鸟用了</span></span><br><span class="line">            catlist[i] = <span class="literal">nil</span>; <span class="comment">// 将这个分类从列表中删除</span></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this category. </span></span><br><span class="line">        <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">        <span class="comment">// the class is realized.</span></span><br><span class="line">        </span><br><span class="line">        bool classExists = NO;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span>protocols  </span><br><span class="line">            ||  <span class="function"><span class="title">cat</span>-&gt;</span>instanceProperties) <span class="comment">// 如果分类中存在实例方法 or 协议 or 实例属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加分类到所属的 cls 类上，即把这个分类添加到 cls 对应的所有 unattached 的分类的列表中</span></span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 cls 类已经被 realized</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">                <span class="comment">// 就重新 methodize 一下 cls 类，里面会重新 attachCategories 一下所有未被 attach 的分类</span></span><br><span class="line">                <span class="comment">// 即把这些分类中的方法、协议、属性添加到 cls 类中</span></span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = YES; <span class="comment">// 标记类存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果分类中存在类方法 or 协议</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span>protocols  </span><br><span class="line">            <span class="comment">/* ||  cat-&gt;classProperties */</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加分类到所属类 cls 的元类中</span></span><br><span class="line">            <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">            <span class="comment">// 如果 cls 的元类已经 realized 过了</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                <span class="comment">// 就重新 methodize 一下 cls 类的元类</span></span><br><span class="line">                <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码发现所有的分类，</p><ol><li>如果分类中包含实例方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls：(cat：hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到类中。</li><li>如果分类中包含类方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls-&gt;ISA()：(cat： hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到元类中。</li></ol><p>remethodizeClass 实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看 runtimeLock 是否已经被正确得加上了写锁</span></span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="comment">// 取得 cls 类的未被 attach 的分类列表</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="comment">// 将分类列表 attach 附加到 cls 类上，因为这不是第一次 methodize，所以需要清空缓存，因为原来的缓存也已经废了</span></span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/* 清空方法缓存 flush caches*/</span>);</span><br><span class="line">        <span class="built_in">free</span>(cats); <span class="comment">// 将 cats 释放，原因见 unattachedCategoriesForClass()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remethodizeClass 调用unattachedCategoriesForClass 取得类所属的分类，调用attachCategories将分类中的方法、协议、属性添加的类中。<br>这个方面和上面的methodizeClass 功能基本相同。methodizeClass比remethodizeClass多一个操作————处理base相关的信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>_read_images 主要是读取Mach-O中下面的section ，存储到内存中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(<span class="name">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">"__objc_selrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2MessageRefs</span>,         message_ref_t,   <span class="string">"__objc_msgrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassRefs</span>,           Class,           <span class="string">"__objc_classrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2SuperRefs</span>,           Class,           <span class="string">"__objc_superrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2NonlazyClassList</span>,    classref_t,      <span class="string">"__objc_nlclslist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2CategoryList</span>,        category_t *,    "__objc_catlist");</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="string">"__objc_nlcatlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ProtocolList</span>,        protocol_t *,    "__objc_protolist");</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="string">"__objc_protorefs"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;_read_images从镜像文件中读取所有类信息、方法信息、分类信息。这篇文章就介绍具体读取了什么信息。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="_read_images" scheme="http://yoursite.com/tags/read-images/"/>
    
  </entry>
  
  <entry>
    <title>8. objc4入口函数</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/8__objc_init/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/8__objc_init/</id>
    <published>2018-11-26T03:38:11.000Z</published>
    <updated>2018-11-27T03:01:14.694Z</updated>
    
    <content type="html"><![CDATA[<p>__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。</p><a id="more"></a><h2 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">_objc_init</span>(void)</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">    <span class="comment">// 首先第一步，注册 unmap 函数，万一有的类的 +load 方法需要 unmap 一些东西</span></span><br><span class="line">    <span class="comment">// unmap，即 un-memory-mapped，这里应该就是取消内存映射，移除镜像的意思</span></span><br><span class="line">    <span class="selector-tag">_dyld_register_func_for_remove_image</span>(&amp;unmap_image);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册镜像状态改变时的回调函数</span></span><br><span class="line">    <span class="selector-tag">dyld_register_image_state_change_handler</span>(dyld_image_state_bound,</span><br><span class="line">                                             <span class="number">1</span><span class="comment">/*batch 是否批处理*/</span>, &amp;map_2_images);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册镜像状态改变时的回调函数，镜像加载完成后，需要调用 +load 时会回调 load_images 函数</span></span><br><span class="line">    <span class="comment">// 不进行批处理，所以 load_images 会被调用多次，每次有新的镜像进来时，都会被调用</span></span><br><span class="line">    <span class="selector-tag">dyld_register_image_state_change_handler</span>(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看map_2_images函数，load_images后面一遍介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的镜像，这些镜像被 dyld库 映射</span></span><br><span class="line"><span class="comment">// 这个函数其实是一个回调函数，被 dyld 库调用，参数中的镜像信息也是 dyld 库传进来的，详情见 _objc_init()</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">map_2_images(<span class="keyword">enum</span> dyld_image_states state,</span><br><span class="line">             <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">             <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock); <span class="comment">// runtimeLock 加写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 map_images_nolock 函数中，完成所有 class 的注册、fixup等工作，</span></span><br><span class="line">    <span class="comment">// 还包括初始化自动释放池、初始化 side table 等等工作</span></span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(state, infoCount, infoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map_2_images内部调用了map_images_nolock函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射镜像，在这个函数中，完成所有 class 的注册、fixup等工作，</span></span><br><span class="line"><span class="comment">// 还包括初始化自动释放池、初始化 side table 等工作</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">map_images_nolock(<span class="keyword">enum</span> dyld_image_states state,</span><br><span class="line">                  <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">                  <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> wantsGC = NO;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    header_info *hList[infoCount];</span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line">   ....</span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line">    i = infoCount;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType *)infoList[i].imageLoadAddress;</span><br><span class="line"></span><br><span class="line">        hi = addHeader(mhdr);</span><br><span class="line">        <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">            <span class="comment">// no objc data in this entry</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">            <span class="comment">// Size some data structures based on main executable's size</span></span><br><span class="line">            _getObjcSelectorRefs(hi, &amp;selrefCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hList[hCount++] = hi</span><br><span class="line">    &#125;</span><br><span class="line">   ....</span><br><span class="line">    _read_images(hList, hCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map_images_nolock对所有的镜像列表执行addHeader，主要过滤重复的镜像。</p><p>接着调用_read_images函数。_read_images比较复杂，后面文章分析。下面看看addHeader的具体实现：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> header_info * addHeader(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bad_magic(mhdr)) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Didn't find an hinfo in the dyld shared cache.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Weed out duplicates</span></span><br><span class="line">        <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mhdr == hi-&gt;mhdr) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Locate the __OBJC segment</span></span><br><span class="line">        size_t info_size = <span class="number">0</span>;</span><br><span class="line">        unsigned <span class="keyword">long</span> seg_size;</span><br><span class="line">        <span class="keyword">const</span> objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);</span><br><span class="line">        <span class="keyword">const</span> uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&amp;seg_size);</span><br><span class="line">        <span class="keyword">if</span> (!objc_segment  &amp;&amp;  !image_info) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate a header_info entry.</span></span><br><span class="line">        hi = (header_info *)calloc(sizeof(header_info), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the new header_info entry.</span></span><br><span class="line">        hi-&gt;mhdr = mhdr;</span><br><span class="line">        hi-&gt;info = image_info;</span><br><span class="line">        hi-&gt;fname = dyld_image_path_containing_address(hi-&gt;mhdr);</span><br><span class="line">        hi-&gt;loaded = <span class="keyword">true</span>;</span><br><span class="line">        hi-&gt;inSharedCache = <span class="keyword">false</span>;</span><br><span class="line">        hi-&gt;allClassesRealized = NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dylibs are not allowed to unload</span></span><br><span class="line">    <span class="comment">// ...except those with image_info and nothing else (5359412)</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;mhdr-&gt;filetype == MH_DYLIB  &amp;&amp;  _hasObjcContents(hi)) &#123;</span><br><span class="line">        dlopen(hi-&gt;fname, RTLD_NOLOAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    appendHeader(hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addHeader将传入的headerType参数mhdr 构造出header_info类型，最后调用appendHeader函数：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void appendHeader(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Add the header to the header list. </span></span><br><span class="line">    <span class="comment">// The header is appended to the list, to preserve the bottom-up order.</span></span><br><span class="line">    HeaderCount++;</span><br><span class="line">    <span class="function"><span class="title">hi</span>-&gt;</span>next = NULL;</span><br><span class="line">    <span class="keyword">if</span> (!FirstHeader) &#123;</span><br><span class="line">        <span class="comment">// list is empty</span></span><br><span class="line">        FirstHeader = LastHeader = hi;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LastHeader) &#123;</span><br><span class="line">            <span class="comment">// list is not empty, but LastHeader is invalid - recompute it</span></span><br><span class="line">            LastHeader = FirstHeader;</span><br><span class="line">            <span class="function"><span class="title">while</span> (LastHeader-&gt;</span><span class="function"><span class="title">next</span>) LastHeader = LastHeader-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LastHeader is now valid</span></span><br><span class="line">        L<span class="function"><span class="title">astHeader</span>-&gt;</span>next = hi;</span><br><span class="line">        LastHeader = hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appendHeader 将hi放入FirstHeader的列表中。<br>其中FirstHeader、LastHeader的定义如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">header_info</span> <span class="meta">*FirstHeader</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span>  <span class="string">//</span> <span class="literal">NULL</span> <span class="string">means</span> <span class="string">empty</span> <span class="string">list</span> <span class="string">第一个</span> <span class="string">image(镜像)</span></span><br><span class="line"><span class="string">header_info</span> <span class="meta">*LastHeader</span>  <span class="string">=</span> <span class="number">0</span><span class="string">;</span>  <span class="string">//</span> <span class="literal">NULL</span> <span class="string">means</span> <span class="string">invalid;</span> <span class="string">recompute</span> <span class="string">it</span></span><br><span class="line"><span class="string">int</span> <span class="string">HeaderCount</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>map_2_images  主要完成的工作如下：</p><ol><li>镜像去重复</li><li>对于每个镜像，从dyld_image_info 构造出header_info结构</li><li>将header_info结构添加到列表FirstHeader中，LastHeader 指向列表的最后一个元素。</li><li>执行_read_images，后续讲解。</li></ol><p>转化的header_info结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/8__objc_init/headerInfo.png" alt="dyld_image_info转化为header_info结构"></p><p>FirstHeader 的链表结构如下图所示,这里记录了objc库加载的所有的镜像。</p><p><img src="/wiki/IOS/Runtime/objc/8__objc_init/firstHeader.png" alt="FirstHeader 的链表"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="__objc_init" scheme="http://yoursite.com/tags/objc-init/"/>
    
  </entry>
  
  <entry>
    <title>7. NXMapTable数据结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/7_NXMapTable/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/7_NXMapTable/</id>
    <published>2018-11-22T16:38:11.000Z</published>
    <updated>2018-11-23T11:27:02.923Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍NXMapTable数据结构</p><a id="more"></a><h2 id="NXMapTable-数据结构"><a href="#NXMapTable-数据结构" class="headerlink" title="NXMapTable 数据结构"></a>NXMapTable 数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTable</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private data structure; may change */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTablePrototype</span>*<span class="title">prototype</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span>count;</span><br><span class="line">    <span class="keyword">unsigned</span>nbBucketsMinusOne;</span><br><span class="line">    <span class="keyword">void</span>*buckets;</span><br><span class="line">&#125; NXMapTable OBJC_MAP_AVAILABILITY;</span><br></pre></td></tr></table></figure><p>count 存储的个数， nbBucketsMinusOne 容量减1， buckets 存储数据。</p><p>_NXMapTablePrototype定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTablePrototype</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>(*hash)(NXMapTable *, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span>(*isEqual)(NXMapTable *, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span>(*<span class="built_in">free</span>)(NXMapTable *, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value);</span><br><span class="line">    <span class="keyword">int</span>style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXMapTablePrototype OBJC_MAP_AVAILABILITY;</span><br></pre></td></tr></table></figure><p>_NXMapTablePrototype 结构存储三个函数指针hash、 isEqual、 free。</p><p>类图如下:</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_class.png" alt="NXMapTable类图"></p><h3 id="主要的接口"><a href="#主要的接口" class="headerlink" title="主要的接口"></a>主要的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXMapTable *<span class="title">NXCreateMapTableFromZone</span><span class="params">(NXMapTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">void</span> *z)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"><span class="function">NXMapTable *<span class="title">NXCreateMapTable</span><span class="params">(NXMapTablePrototype prototype, <span class="keyword">unsigned</span> capacity)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NXFreeMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NXResetMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">NXCompareMapTables</span><span class="params">(NXMapTable *table1, NXMapTable *table2)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">NXCountMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapMember</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">void</span> **value)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapGet</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapInsert</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapRemove</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> OBJC_MAP_AVAILABILITY</span>;</span><br></pre></td></tr></table></figure><h3 id="NXCreateMapTableFromZone"><a href="#NXCreateMapTableFromZone" class="headerlink" title="NXCreateMapTableFromZone"></a>NXCreateMapTableFromZone</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NXMapTable *NXCreateMapTableFromZone(NXMapTablePrototype prototype, unsigned capacity, void *z) &#123;</span><br><span class="line">    NXMapTable*<span class="keyword">table</span> = (NXMapTable <span class="comment">*)malloc_zone_malloc((malloc_zone_t *)z, sizeof(NXMapTable))</span>;</span><br><span class="line">    NXMapTablePrototype*proto;</span><br><span class="line">    <span class="keyword">if</span> (! prototypes) prototypes = NXCreateHashTable(protoPrototype, <span class="number">0</span>, NULL);</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash || ! prototype.isEqual || ! prototype.<span class="keyword">free</span> || prototype.style) &#123;</span><br><span class="line">_objc_inform(<span class="string">"*** NXCreateMapTable: invalid creation parameters\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = (NXMapTablePrototype *)NXHashGet(prototypes, &amp;prototype); </span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">proto = (NXMapTablePrototype *)malloc(sizeof(NXMapTablePrototype));</span><br><span class="line">*proto = prototype;</span><br><span class="line">    (void)NXHashInsert(prototypes, proto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>-&gt;prototype <span class="comment">= proto</span>;<span class="comment"> table-&gt;count = 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">= exp2u(log2u(capacity)+1) - 1</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= allocBuckets(z, table-&gt;nbBucketsMinusOne + 1)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NXMapTable *NXCreateMapTable(NXMapTablePrototype prototype, unsigned capacity) &#123;</span><br><span class="line">    return NXCreateMapTableFromZone(prototype, capacity, malloc_default_zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NXCreateMapTableFromZone 主要工作：</p><ol><li>创建table</li><li>处理proto，如果先前没有prototype，存储在prototypes全局hash表中。</li><li>赋值成员。</li></ol><h3 id="NXFreeMapTable"><a href="#NXFreeMapTable" class="headerlink" title="NXFreeMapTable"></a>NXFreeMapTable</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void NXFreeMapTable(NXMapTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    NXResetMapTable(<span class="keyword">table</span>);</span><br><span class="line">    freeBuckets(<span class="keyword">table</span>-&gt;buckets);</span><br><span class="line">    free(<span class="keyword">table</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NXResetMapTable(NXMapTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    void(*freeProc)(struct _NXMapTable *, void *, void *) = <span class="keyword">table</span>-&gt;prototype-&gt;free;</span><br><span class="line">    unsignedindex = <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">+ 1</span>;</span><br><span class="line">    while (index--) &#123;</span><br><span class="line">if (pairs-&gt;key != NX_MAPNOTAKEY) &#123;</span><br><span class="line">    freeProc(<span class="keyword">table</span>, (void <span class="comment">*)pairs-&gt;key, (void *)pairs-&gt;value)</span>;</span><br><span class="line">    pairs-&gt;key = NX_MAPNOTAKEY; pairs-&gt;value = NULL;</span><br><span class="line">&#125;</span><br><span class="line">pairs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环调用free函数， 删除存储的数据。</p><h3 id="NXCountMapTable"><a href="#NXCountMapTable" class="headerlink" title="NXCountMapTable"></a>NXCountMapTable</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned NXCountMapTable(NXMapTable *<span class="keyword">table</span>) &#123; <span class="keyword">return</span> <span class="keyword">table</span>-&gt;<span class="keyword">count</span>; &#125;</span><br></pre></td></tr></table></figure><p>获取table中存储数据的个数。返回NXMapTable的count成员。</p><h3 id="NXMapMember"><a href="#NXMapMember" class="headerlink" title="NXMapMember"></a>NXMapMember</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">void</span> *_NXMapMember(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> **value) &#123;</span><br><span class="line">    MapPair*pairs = (MapPair *)table-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(table, <span class="built_in">key</span>);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">key</span> == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, pair-&gt;<span class="built_in">key</span>, <span class="built_in">key</span>)) &#123;</span><br><span class="line">*value = (<span class="keyword">void</span> *)pair-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)pair-&gt;<span class="built_in">key</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> ((index2 = nextIndex(table, index2)) != index) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">key</span> == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, pair-&gt;<span class="built_in">key</span>, <span class="built_in">key</span>)) &#123;</span><br><span class="line">    *value = (<span class="keyword">void</span> *)pair-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)pair-&gt;<span class="built_in">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *NXMapMember(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> **value) &#123;</span><br><span class="line">    <span class="keyword">return</span> _NXMapMember(table, <span class="built_in">key</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NXMapMember 获取给定key对应的值，该函数首先通过bucketOf取出索引：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> bucketOf(NXMapTable *<span class="keyword">table</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span>hash = (<span class="keyword">table</span>-&gt;prototype-&gt;hash)(<span class="keyword">table</span>, key);</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="keyword">table</span>-&gt;nbBucketsMinusOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bucketOf 函数通过key计算出hash值，然后将hash值和table-&gt;nbBucketsMinusOne按位与，执行的结果一定小于等于 table-&gt;nbBucketsMinusOne，也就是一定小于容量，不会产生一个超出容量的索引。 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapPair*pair = pairs + <span class="keyword">index</span>;</span><br></pre></td></tr></table></figure><p>通过索引找到存储的内容pair，类型是MapPair。</p><p>接着根据pair的内容，分三种情况：</p><ol><li>索引位置位的内容为空，直接返回NX_MAPNOTAKEY,value值不设置。</li><li>索引位置的内容不空，但是key一样，返回key，设置value的内容为当前pair的value。</li><li>索引位置内容不空，并且key不一样，循环查找下一个位置，直到找到一个位置，这个位置的key和传入的key相等。返回key，设置value的内容为当前pair的value。</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br></pre></td></tr></table></figure><p>如果找到的位置没有内容，直接返回NX_MAPNOTAKEY。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isEqual(table, <span class="built_in">pair</span>-&gt;key, key)) &#123;</span><br><span class="line">*value = (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果索引位置的key相同，传出key对应的内容。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> ((index2 = nextIndex(table, index2)) != index) &#123;</span><br><span class="line">    <span class="built_in">pair</span> = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pair</span>-&gt;key == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, <span class="built_in">pair</span>-&gt;key, key)) &#123;</span><br><span class="line">    *value = (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引的位置有值，且key不相等，循环查找下一个位置，直到找到相同的key，或者循环完成。</p><p>其中nextIndex 函数计算出下一个索引。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> nextIndex(NXMapTable *<span class="keyword">table</span>, <span class="keyword">unsigned</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> (index + <span class="number">1</span>) &amp; <span class="keyword">table</span>-&gt;nbBucketsMinusOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以递增的示意图如下：</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_find_next_index.gif" alt="索引完整循环实例"></p><h3 id="NXMapInsert"><a href="#NXMapInsert" class="headerlink" title="NXMapInsert"></a>NXMapInsert</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void *NXMapInsert(NXMapTable *<span class="keyword">table</span>, const <span class="comment">void *key, const void *value) &#123;</span></span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(<span class="keyword">table</span>, key);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    <span class="keyword">if</span> (key == NX_MAPNOTAKEY) &#123;</span><br><span class="line">_objc_inform(<span class="string">"*** NXMapInsert: invalid key: -1\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned numBuckets = <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">+ 1</span>;</span><br><span class="line"></span><br><span class="line">    if (pair-&gt;key == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        pair-&gt;key = key; pair-&gt;value = value;</span><br><span class="line">        <span class="keyword">table</span>-&gt;count++;</span><br><span class="line">        if (<span class="keyword">table</span>-&gt;count <span class="comment">* 4 &gt; numBuckets * 3) _NXMapRehash(table)</span>;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key))</span><br><span class="line">    &#123;</span><br><span class="line">        const void*old = pair-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (old != value) pair-&gt;value = value;<span class="comment">/* avoid writing unless needed! */</span></span><br><span class="line">        return (void *)old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">table</span>-&gt;count <span class="comment">== numBuckets) &#123;</span></span><br><span class="line">        <span class="comment">/* no room: rehash and retry */</span></span><br><span class="line">        _NXMapRehash(<span class="keyword">table</span>);</span><br><span class="line">        return NXMapInsert(<span class="keyword">table</span>, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        unsignedindex2 = index;</span><br><span class="line">        <span class="keyword">while</span> ((index2 = nextIndex(<span class="keyword">table</span>, index2)) != index) &#123;</span><br><span class="line">            pair = pairs + index2;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY)</span><br><span class="line">            &#123;</span><br><span class="line">                  pair-&gt;key = key; pair-&gt;value = value;</span><br><span class="line">                <span class="keyword">table</span>-&gt;count++;</span><br><span class="line">                if (<span class="keyword">table</span>-&gt;count <span class="comment">* 4 &gt; numBuckets * 3) _NXMapRehash(table)</span>;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key))</span><br><span class="line">            &#123;</span><br><span class="line">                const void*old = pair-&gt;value;</span><br><span class="line">                <span class="keyword">if</span> (old != value) pair-&gt;value = value;<span class="comment">/* avoid writing unless needed! */</span></span><br><span class="line">                return (void *)old;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* no room: can't happen! */</span></span><br><span class="line">_objc_inform(<span class="string">"**** NXMapInsert: bug\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码有几个关键的地方：</p><ol><li>容量大于3/4 就扩容，扩大为原来的2倍。</li><li>添加分为三种情况： 索引位置为空，直接插入、索引位置不空，key相同，替换新的内容、索引位置内容不空，key不相同，循环查找下一个内容为空的位置，如果找到，插入，否则什么页不做。</li></ol><p>下面两图分别说明上面的三种情况 。</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_1.gif" alt="插入位置为空  or 插入位置不为空，但key相同"></p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_2.gif" alt="插入位置不空，key相同"></p><h3 id="NXMapRemove"><a href="#NXMapRemove" class="headerlink" title="NXMapRemove"></a>NXMapRemove</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void *NXMapRemove(NXMapTable *<span class="keyword">table</span>, const <span class="comment">void *key) &#123;</span></span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(<span class="keyword">table</span>, key);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    unsignedchain = <span class="number">1</span>; <span class="comment">/* number of non-nil pairs in a row */</span></span><br><span class="line">    intfound = <span class="number">0</span>;</span><br><span class="line">    const void*old = NULL;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) return NULL;</span><br><span class="line">    mapRemove ++;</span><br><span class="line">    <span class="comment">/* compute chain */</span></span><br><span class="line">    &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) &#123;found <span class="comment">++</span>;<span class="comment"> old = pair-&gt;value</span>;<span class="comment"> &#125;</span></span><br><span class="line">while ((index2 = nextIndex(<span class="keyword">table</span>, index2)) != index) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) break;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) &#123;found <span class="comment">++</span>;<span class="comment"> old = pair-&gt;value</span>;<span class="comment"> &#125;</span></span><br><span class="line">    chain++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! found) return NULL;</span><br><span class="line">    <span class="keyword">if</span> (found != <span class="number">1</span>) _objc_inform(<span class="string">"**** NXMapRemove: incorrect table\n"</span>);</span><br><span class="line">    <span class="comment">/* remove then reinsert */</span></span><br><span class="line">    &#123;</span><br><span class="line">MapPairbuffer[<span class="number">16</span>];</span><br><span class="line">MapPair*aux = (chain &gt; <span class="number">16</span>) ? (MapPair *)malloc(sizeof(MapPair)*(chain<span class="number">-1</span>)) : buffer;</span><br><span class="line">unsignedauxnb = <span class="number">0</span>;</span><br><span class="line">intnb = chain;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> (nb--) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (! isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) aux[auxnb++] = *pair;</span><br><span class="line">    pair-&gt;key = NX_MAPNOTAKEY; pair-&gt;value = NULL;</span><br><span class="line">    index2 = nextIndex(<span class="keyword">table</span>, index2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">table</span>-&gt;count <span class="comment">-= chain</span>;</span><br><span class="line">if (auxnb != chain<span class="number">-1</span>) _objc_inform(<span class="string">"**** NXMapRemove: bug\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (auxnb--) NXMapInsert(<span class="keyword">table</span>, aux[auxnb].key, aux[auxnb].value);</span><br><span class="line">if (chain &gt; <span class="number">16</span>) free(aux);</span><br><span class="line">    &#125;</span><br><span class="line">    return (void *)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除指定key的内容分为下面几步：</p><ol><li>通过key找到索引</li><li>如果key对于的MapPair为空，直接返回</li><li>计算key存储数据的实际位置和应该存储位置的距离chain。这段距离内的元素的存储位置可能不是按照对应位置存储的。</li><li>删除chain内的元素，重新插入chain-1 个元素。</li></ol><p>用下面图理解删除的代码。</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_1.png" alt="初始情况有两个元素，5，7"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_2.png" alt="插入元素20"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_3.png" alt="插入元素5，发现5的位置被20占用，往后查找空位置"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_4.png" alt="查找到的空位置是8，保存5，在次基础上开始删除"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_5.png" alt="chain=4，表示和应该存储位置偏移了4个距离"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_6.png" alt="删除四个元素，其中5，6，7保存"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_7.png" alt="重新插入5，6，7，修正了存储数据"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍NXMapTable数据结构&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>6. 上古时代 Objective-C 中哈希表的实现(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/6_NXHashTable/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/6_NXHashTable/</id>
    <published>2018-11-22T02:38:11.000Z</published>
    <updated>2018-11-22T09:42:23.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p><ul><li><code>NXHashTable</code> 的实现</li><li><code>NXHashTable</code> 的性能分析</li><li><code>NXHashTable</code> 的作用</li></ul><p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p><blockquote><p>文中会涉及一些数据结构方面的简单知识，例如<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>。</p><p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p></blockquote><a id="more"></a><h2 id="NXHashTable"><a href="#NXHashTable" class="headerlink" title="NXHashTable"></a>NXHashTable</h2><p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> NXHashTablePrototype *prototype;</span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> nbBuckets;</span><br><span class="line">    <span class="keyword">void</span> *buckets;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *info;</span><br><span class="line">&#125; NXHashTable;</span><br></pre></td></tr></table></figure><p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXHashTable *<span class="title">NXCreateHashTableFromZone</span> <span class="params">(NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">NXCountHashTable</span> <span class="params">(NXHashTable *table)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NXHashMember</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashGet</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashInsert</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashRemove</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p><h3 id="NXCreateHashTableFromZone"><a href="#NXCreateHashTableFromZone" class="headerlink" title="NXCreateHashTableFromZone"></a>NXCreateHashTableFromZone</h3><p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123;</span><br><span class="line">    NXHashTable*<span class="keyword">table</span>;</span><br><span class="line">    NXHashTablePrototype *proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span> = ALLOCTABLE(z);</span><br><span class="line">    if (! prototypes) bootstrap ();</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash) prototype.hash = NXPtrHash;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.<span class="keyword">free</span>) prototype.<span class="keyword">free</span> = NXNoEffectFree;</span><br><span class="line"></span><br><span class="line">    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">        proto = (NXHashTablePrototype *) malloc(sizeof (NXHashTablePrototype));</span><br><span class="line">        bcopy ((const char*)&amp;prototype, (char*)proto, sizeof (NXHashTablePrototype));</span><br><span class="line">        (void) NXHashInsert (prototypes, proto);</span><br><span class="line">        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">table</span>-&gt;prototype <span class="comment">= proto</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;info <span class="comment">= info</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBuckets <span class="comment">= GOOD_CAPACITY(capacity)</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= ALLOCBUCKETS(z, table-&gt;nbBuckets)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123;</span><br><span class="line">    NXHashTable*<span class="keyword">table</span>;</span><br><span class="line">    NXHashTablePrototype *proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span> = ALLOCTABLE(z);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;info <span class="comment">= info</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBuckets <span class="comment">= GOOD_CAPACITY(capacity)</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= ALLOCBUCKETS(z, table-&gt;nbBuckets)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">ALLOCTABLE</span>(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">GOOD_CAPACITY</span>(c) (exp2m1u (log2u (c)+<span class="number">1</span>))</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">ALLOCBUCKETS</span>(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))</span><br></pre></td></tr></table></figure><p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c   binary  result</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>       <span class="number">1</span> </span><br><span class="line"><span class="number">2</span>   <span class="number">10</span>      <span class="number">3</span>(<span class="number">0b11</span>)</span><br><span class="line"><span class="number">6</span>   <span class="number">110</span>     <span class="number">7</span>(<span class="number">0b111</span>)</span><br><span class="line"><span class="number">100</span> <span class="number">1100100</span> <span class="number">127</span>(<span class="number">0b111</span> <span class="number">1111</span>)</span><br></pre></td></tr></table></figure><p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p><blockquote><p>每次返回当前位数下的二进制最大值。</p></blockquote><p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p><h4 id="NXHashTablePrototype"><a href="#NXHashTablePrototype" class="headerlink" title="NXHashTablePrototype"></a>NXHashTablePrototype</h4><p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> (*isEqual)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data1, <span class="keyword">const</span> <span class="keyword">void</span> *data2);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXHashTablePrototype;</span><br></pre></td></tr></table></figure><p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p><p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ISEQUAL(<span class="name">table</span>, data1, data2) ((<span class="name">data1</span> == data2) || (<span class="name">*table-&gt;prototype-&gt;isEqual</span>)(<span class="name">table-&gt;info</span>, data1, data2))</span><br></pre></td></tr></table></figure><p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p><blockquote><p>因为 <code>NXHashTable</code> 使用<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p></blockquote><h4 id="HashBucket"><a href="#HashBucket" class="headerlink" title="HashBucket"></a>HashBucket</h4><p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    oneOrMany elements;</span><br><span class="line">&#125; HashBucket;</span><br></pre></td></tr></table></figure><p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *one;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **many;</span><br><span class="line">&#125; oneOrMany;</span><br></pre></td></tr></table></figure><blockquote><p>这么设计的主要原因是<strong>提升性能</strong>。</p></blockquote><p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p><h3 id="NXCountHashTable"><a href="#NXCountHashTable" class="headerlink" title="NXCountHashTable"></a>NXCountHashTable</h3><p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned NXCountHashTable (NXHashTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    return <span class="keyword">table</span>-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NXHashMember"><a href="#NXHashMember" class="headerlink" title="NXHashMember"></a>NXHashMember</h3><p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *<span class="keyword">table</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(<span class="keyword">table</span>, data);</span><br><span class="line">    <span class="keyword">unsigned</span>j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(<span class="keyword">table</span>, data, bucket-&gt;elements<span class="variable">.one</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements<span class="variable">.many</span>;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(<span class="keyword">table</span>, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function"><span class="title">define</span> BUCKETOF(table, <span class="keyword">data</span>) (((HashBucket *)table-&gt;</span><span class="function"><span class="title">buckets</span>)+((*table-&gt;</span><span class="function"><span class="title">prototype</span>-&gt;</span><span class="function"><span class="title">hash</span>)(table-&gt;</span><span class="function"><span class="title">info</span>, <span class="keyword">data</span>) % table-&gt;</span>nbBuckets))</span><br></pre></td></tr></table></figure><p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ISEQUAL(<span class="built_in">table</span>, data, bucket-&gt;elements.one);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">pairs</span> = bucket-&gt;elements.many;</span><br><span class="line"><span class="keyword">while</span> (j<span class="comment">--) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(<span class="built_in">table</span>, data, *<span class="built_in">pairs</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pairs</span> ++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>count == 0</code>，直接返回</li><li><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code> </li><li><p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p><blockquote><p>你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 <a href="#nxhashinsert">NXHashInsert</a> 中解释。</p></blockquote></li></ul><h3 id="NXHashGet"><a href="#NXHashGet" class="headerlink" title="NXHashGet"></a>NXHashGet</h3><blockquote><p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p><p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p><p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p></blockquote><p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashGet</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one)</span><br><span class="line">        ? (<span class="keyword">void</span> *) bucket-&gt;elements.one : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> (<span class="keyword">void</span> *) *pairs;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NXHashInsert"><a href="#NXHashInsert" class="headerlink" title="NXHashInsert"></a>NXHashInsert</h3><p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void *NXHashInsert (NXHashTable *table, const void *<span class="keyword">data</span>) &#123;</span><br><span class="line">    HashBucket *bucket = BUCKETOF(table, <span class="keyword">data</span>);</span><br><span class="line">    <span class="function"><span class="title">unsigned</span> j = bucket-&gt;</span>count;</span><br><span class="line">    const void **pairs;</span><br><span class="line">    const void **newt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) &#123;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) &#123;</span><br><span class="line">            <span class="function"><span class="title">const</span> void *old = bucket-&gt;</span>elements.one;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">            return (void *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">        <span class="function"><span class="title">newt</span>[1] = bucket-&gt;</span>elements.one;</span><br><span class="line">        *newt = <span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">if</span> (table-&gt;</span><span class="function"><span class="title">count</span> &gt; table-&gt;</span>nbBuckets) _NXHashRehash (table);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">pairs</span> = bucket-&gt;</span>elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">            const void*old = *pairs;</span><br><span class="line">            *pairs = <span class="keyword">data</span>;</span><br><span class="line">            return (void *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">newt</span> = ALLOCPAIRS(z, bucket-&gt;</span>count+<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span> (bucket-&gt;</span><span class="function"><span class="title">count</span>) bcopy ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)(newt+1), bucket-&gt;</span>count * PTRSIZE);</span><br><span class="line">    *newt = <span class="keyword">data</span>;</span><br><span class="line">    FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>count++; </span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">if</span> (table-&gt;</span><span class="function"><span class="title">count</span> &gt; table-&gt;</span>nbBuckets) _NXHashRehash (table);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p><ul><li><code>bucket-&gt;count == 0</code></li><li><code>bucket-&gt;count == 1</code></li><li><code>bucket-&gt;count &gt; 1</code></li></ul><p>如果对应的 <code>bucket</code> 为空：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (! <span class="keyword">j) </span>&#123;</span><br><span class="line">    <span class="keyword">bucket-&gt;count++; </span></span><br><span class="line">    <span class="keyword">bucket-&gt;elements.one </span>= data<span class="comment">;</span></span><br><span class="line">    table-&gt;<span class="built_in">count</span>++<span class="comment">;</span></span><br><span class="line">    return NULL<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：<br>6_NXHashTable/<br><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-empty.gif" alt="objc-hashtable-insert-empty"></p><p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) &#123;</span><br><span class="line">        <span class="function"><span class="title">const</span> void*old = bucket-&gt;</span>elements.one;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">        return (void *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="title">newt</span>[1] = bucket-&gt;</span>elements.one;</span><br><span class="line">    *newt = <span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-one.gif.gif" alt="objc-hashtable-insert-one.gif"></p><p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">        const void*old = *pairs;</span><br><span class="line">        *pairs = <span class="keyword">data</span>;</span><br><span class="line">        return (void *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">newt</span> = ALLOCPAIRS(z, bucket-&gt;</span>count+<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (bucket-&gt;</span><span class="function"><span class="title">count</span>) bcopy ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)(newt+1), bucket-&gt;</span>count * PTRSIZE);</span><br><span class="line">*newt = <span class="keyword">data</span>;</span><br><span class="line">FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line"><span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line"><span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line"><span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br></pre></td></tr></table></figure><p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-many.gif.gif" alt="objc-hashtable-insert-many.gif"></p><p>在每次添加完一个元素之后，都会进行下面的判断：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">table</span>-&gt;<span class="keyword">count</span> &gt; <span class="keyword">table</span>-&gt;nbBuckets) _NXHashRehash (<span class="keyword">table</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p></blockquote><p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p><h4 id="NXHashRehash"><a href="#NXHashRehash" class="headerlink" title="_NXHashRehash"></a>_NXHashRehash</h4><p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _NXHashRehash (NXHashTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    _NXHashRehashToCapacity (<span class="keyword">table</span>, MORE_CAPACITY(<span class="keyword">table</span>-&gt;nbBuckets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MORE_CAPACITY(b) (b*2+1)</span></span><br></pre></td></tr></table></figure><p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void _NXHashRehashToCapacity (NXHashTable *table, unsigned newCapacity) &#123;</span><br><span class="line">    NXHashTable*old;</span><br><span class="line">    NXHashStatestate;</span><br><span class="line">    void*aux;</span><br><span class="line">    __unused void *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    old = ALLOCTABLE(z);</span><br><span class="line">    <span class="function"><span class="title">old</span>-&gt;</span><span class="function"><span class="title">prototype</span> = table-&gt;</span><span class="function"><span class="title">prototype</span>; old-&gt;</span><span class="function"><span class="title">count</span> = table-&gt;</span>count;</span><br><span class="line">    <span class="function"><span class="title">old</span>-&gt;</span><span class="function"><span class="title">nbBuckets</span> = table-&gt;</span><span class="function"><span class="title">nbBuckets</span>; old-&gt;</span><span class="function"><span class="title">buckets</span> = table-&gt;</span>buckets;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>nbBuckets = newCapacity;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span> = 0; table-&gt;</span><span class="function"><span class="title">buckets</span> = ALLOCBUCKETS(z, table-&gt;</span>nbBuckets);</span><br><span class="line">    state = NXInitHashState (old);</span><br><span class="line">    <span class="keyword">while</span> (NXNextHashState (old, &amp;state, &amp;aux))</span><br><span class="line">        (void) NXHashInsert (table, aux);</span><br><span class="line">    freeBuckets (old, NO);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">free</span> (old-&gt;</span>buckets);</span><br><span class="line">    free (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</li><li>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</li><li>重新将元素插入到哈希表中</li><li>释放原哈希表 <code>old</code> 以及 <code>buckets</code></li></ol><h4 id="NXHashState"><a href="#NXHashState" class="headerlink" title="NXHashState"></a>NXHashState</h4><p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125; NXHashState;</span><br></pre></td></tr></table></figure><p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned count = <span class="number">0</span>;</span><br><span class="line">MyData *data;</span><br><span class="line">NXHashState <span class="keyword">state</span> = NXInitHashState(<span class="built_in">table</span>);</span><br><span class="line">while (NXNextHashState(<span class="built_in">table</span>, &amp;<span class="keyword">state</span>, &amp;data)) &#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NXHashState NXInitHashState (NXHashTable *<span class="built_in">table</span>) &#123;</span><br><span class="line">    NXHashState<span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">state</span>.i = table-&gt;nbBuckets;</span><br><span class="line">    <span class="keyword">state</span>.j = <span class="number">0</span>;</span><br><span class="line">    return <span class="keyword">state</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-hash-state-init.png" alt="objc-hashtable-hash-state-init"></p><blockquote><p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p></blockquote><p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int NXNextHashState (NXHashTable *table, NXHashState *state, void **<span class="keyword">data</span>) &#123;</span><br><span class="line">    H<span class="function"><span class="title">ashBucket</span>*buckets = (HashBucket *) table-&gt;</span>buckets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span> (state-&gt;</span>j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (state-&gt;</span>i == <span class="number">0</span>) return NO;</span><br><span class="line">        <span class="function"><span class="title">state</span>-&gt;</span><span class="function"><span class="title">i</span>--; state-&gt;</span><span class="function"><span class="title">j</span> = buckets[state-&gt;</span>i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">state</span>-&gt;</span>j--;</span><br><span class="line">    <span class="function"><span class="title">buckets</span> += state-&gt;</span>i;</span><br><span class="line">    *<span class="function"><span class="title">data</span> = (void *) ((buckets-&gt;</span>count == <span class="number">1</span>)</span><br><span class="line">                      ? <span class="function"><span class="title">buckets</span>-&gt;</span><span class="function"><span class="title">elements</span>.one : buckets-&gt;</span><span class="function"><span class="title">elements</span>.many[state-&gt;</span>j]);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的 gif 为我们展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-hashstate-next.gif" alt="objc-hashtable-hashstate-next"></p><h3 id="NXHashRemove"><a href="#NXHashRemove" class="headerlink" title="NXHashRemove"></a>NXHashRemove</h3><p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void *NXHashRemove (NXHashTable *table, const void *<span class="keyword">data</span>) &#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(table, <span class="keyword">data</span>);</span><br><span class="line">    <span class="function"><span class="title">unsigned</span>j = bucket-&gt;</span>count;</span><br><span class="line">    const void**pairs;</span><br><span class="line">    const void**newt;</span><br><span class="line">    __unused void *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) return NULL;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (! ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) return NULL;</span><br><span class="line">        <span class="function"><span class="title">data</span> = bucket-&gt;</span>elements.one;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>elements.one = NULL;</span><br><span class="line">        return (void *) <span class="keyword">data</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">pairs</span> = bucket-&gt;</span>elements.many;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, pairs[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = pairs[<span class="number">1</span>]; <span class="keyword">data</span> = pairs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, pairs[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = pairs[<span class="number">0</span>]; <span class="keyword">data</span> = pairs[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> return NULL;</span><br><span class="line">        FREEPAIRS (pairs);</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>count--;</span><br><span class="line">        return (void *) <span class="keyword">data</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">            <span class="keyword">data</span> = *pairs;</span><br><span class="line">            <span class="comment">/* we shrink this bucket */</span></span><br><span class="line">            <span class="function"><span class="title">newt</span> = (bucket-&gt;</span>count-<span class="number">1</span>)</span><br><span class="line">            ? ALLOCPAIRS(<span class="function"><span class="title">z</span>, bucket-&gt;</span>count-<span class="number">1</span>) : NULL;</span><br><span class="line">            <span class="function"><span class="title">if</span> (bucket-&gt;</span>count-<span class="number">1</span> != j)</span><br><span class="line">                <span class="function"><span class="title">bcopy</span> ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)newt, PTRSIZE*(bucket-&gt;</span>count-j-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                <span class="function"><span class="title">bcopy</span> ((const char*)(bucket-&gt;</span><span class="function"><span class="title">elements</span>.many + bucket-&gt;</span><span class="function"><span class="title">count</span>-j), (char*)(newt+bucket-&gt;</span>count-j-<span class="number">1</span>), PTRSIZE*j);</span><br><span class="line">            FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line">            <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>elements.many = newt;</span><br><span class="line">            return (void *) <span class="keyword">data</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现也分为三种情况，不过在这里就不多说了。</p><h2 id="NXHashTable-的性能"><a href="#NXHashTable-的性能" class="headerlink" title="NXHashTable 的性能"></a>NXHashTable 的性能</h2><p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"hashtable2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *capacities = @[</span><br><span class="line">            @<span class="number">100</span>,</span><br><span class="line">            @<span class="number">1000</span>,</span><br><span class="line">            @<span class="number">10000</span>,</span><br><span class="line">            @<span class="number">100000</span>,</span><br><span class="line">            @<span class="number">1000000</span>,</span><br><span class="line">            @<span class="number">2000000</span>,</span><br><span class="line">            @<span class="number">3000000</span>,</span><br><span class="line">            @<span class="number">5000000</span>,</span><br><span class="line">            @<span class="number">10000000</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *capacity <span class="keyword">in</span> capacities) &#123;</span><br><span class="line">            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">NSDate</span> *methodStart = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; capacity.integerValue; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)i];</span><br><span class="line">                NXHashInsert(hashTable, (__bridge <span class="keyword">void</span> *)value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSDate</span> *methodFinish = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="built_in">NSTimeInterval</span> executionTime = [methodFinish timeIntervalSinceDate:methodStart];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Capacities: %@, executionTime = %f, meanTime = %.10f"</span>, capacity, executionTime, executionTime / capacity.integerValue);</span><br><span class="line"></span><br><span class="line">            free(hashTable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000334</td><td style="text-align:right">0.0000033402</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.001962</td><td style="text-align:right">0.0000019619</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.022001</td><td style="text-align:right">0.0000022001</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.349998</td><td style="text-align:right">0.0000035000</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">2.622551</td><td style="text-align:right">0.0000026226</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">4.165023</td><td style="text-align:right">0.0000020825</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">6.973098</td><td style="text-align:right">0.0000023244</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">13.179743</td><td style="text-align:right">0.0000026359</td></tr><tr><td style="text-align:right"><strong>10000000</strong></td><td style="text-align:right"><strong>53.387356</strong></td><td style="text-align:right"><strong>0.0000053387</strong></td></tr></tbody></table><p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p><p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p><p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXHashTable *<span class="title">NXCreateHashTable</span> <span class="params">(NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p><blockquote><p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p></blockquote><p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">NXHashTable</span> <span class="meta">*hashTable</span> <span class="string">=</span> <span class="string">NXCreateHashTable(NXPtrPrototype,</span> <span class="string">capacity.integerValue,</span> <span class="literal">NULL</span><span class="string">);</span></span><br></pre></td></tr></table></figure><p>重新运行代码，测量性能：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000740</td><td style="text-align:right">0.0000073999</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.003442</td><td style="text-align:right">0.0000034420</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.023341</td><td style="text-align:right">0.0000023341</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.215209</td><td style="text-align:right">0.0000021521</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.836802</td><td style="text-align:right">0.0000018368</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">3.683246</td><td style="text-align:right">0.0000018416</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">5.474610</td><td style="text-align:right">0.0000018249</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">10.576254</td><td style="text-align:right">0.0000021153</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">46.725459</td><td style="text-align:right">0.0000046725</td></tr></tbody></table><p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p><p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-instrument.png" alt="objc-hashtable-instrument"></p><p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p><h2 id="NSMutableArray-性能"><a href="#NSMutableArray-性能" class="headerlink" title="NSMutableArray 性能"></a>NSMutableArray 性能</h2><blockquote><p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p></blockquote><p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p><blockquote><p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p></blockquote><p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000539</td><td style="text-align:right">0.0000053900</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.003185</td><td style="text-align:right">0.0000031850</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.074033</td><td style="text-align:right">0.0000074033</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.370899</td><td style="text-align:right">0.0000037090</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.504855</td><td style="text-align:right">0.0000015049</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">2.852519</td><td style="text-align:right">0.0000014263</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">3.995536</td><td style="text-align:right">0.0000013318</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">6.833879</td><td style="text-align:right">0.0000013668</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">14.444605</td><td style="text-align:right">0.0000014445</td></tr></tbody></table><p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000256</td><td style="text-align:right">0.0000025600</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.001775</td><td style="text-align:right">0.0000017750</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.015906</td><td style="text-align:right">0.0000015906</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.174376</td><td style="text-align:right">0.0000017438</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.650481</td><td style="text-align:right">0.0000016505</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">2.802310</td><td style="text-align:right">0.0000014012</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">4.451261</td><td style="text-align:right">0.0000014838</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">7.093753</td><td style="text-align:right">0.0000014188</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">14.598415</td><td style="text-align:right">0.0000014598</td></tr></tbody></table><p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p><p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-nsarray-instrument.png" alt="objc-hashtable-nsarray-instrument"></p><p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存空间</strong>。</p><blockquote><p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p></blockquote><h2 id="NXHashTable-的应用"><a href="#NXHashTable-的应用" class="headerlink" title="NXHashTable 的应用"></a>NXHashTable 的应用</h2><p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXHashTable *realized_class_hash = <span class="keyword">nil</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>objc_copyClassList</code> 获取类的数组：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class *</span><br><span class="line">objc_copyClassList(unsigned int *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    realizeAllClasses()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Class *result = nil<span class="comment">;</span></span><br><span class="line">    NXHashTable *classes = realizedClasses()<span class="comment">;</span></span><br><span class="line">    unsigned int <span class="built_in">count</span> = NXCountHashTable(classes)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Class cls<span class="comment">;</span></span><br><span class="line">        NXHashState state = NXInitHashState(classes)<span class="comment">;</span></span><br><span class="line">        result = (Class *)malloc((<span class="number">1</span>+<span class="built_in">count</span>) * sizeof(Class))<span class="comment">;</span></span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        while (NXNextHashState(classes, &amp;state, (void **)&amp;cls)) &#123;</span><br><span class="line">            result[<span class="built_in">count</span>++] = cls<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="built_in">count</span>] = nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    if (outCount) *outCount = <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line">    return result<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</li><li>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></li></ol><p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-copy-class-list.png" alt="objc-hashtable-copy-class-list"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p></blockquote><p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashtable2.mm 文件中</span></span><br><span class="line"></span><br><span class="line">hashtable2.m</span><br><span class="line">Copyright <span class="number">1989</span><span class="number">-1996</span> NeXT Software, Inc.</span><br><span class="line">Created by Bertrand Serlet, Feb <span class="number">89</span></span><br></pre></td></tr></table></figure><p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>实现哈希表。</p><p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 &lt;code&gt;x86_64&lt;/code&gt; 架构下运行的，对于在 arm64 中运行的代码会特别说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章会介绍上古时代 Objective-C 哈希表，也就是 &lt;code&gt;NXHashTable&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的性能分析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中会涉及一些数据结构方面的简单知识，例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;拉链法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;文章中分析的不是 &lt;code&gt;NSHashTable&lt;/code&gt; 而是 &lt;code&gt;NXHashTable&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>5. list_array_tt 结构详解</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/5list_array_tt/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/5list_array_tt/</id>
    <published>2018-11-20T02:38:11.000Z</published>
    <updated>2018-11-21T11:17:50.320Z</updated>
    
    <content type="html"><![CDATA[<p>list_array_tt 是个模板类，可以实例化出method_array_t，method_array_t在class_rw_t中使用，存储多个分类中的方法列表。</p><a id="more"></a><h2 id="list-array-tt-总的源码和类图"><a href="#list-array-tt-总的源码和类图" class="headerlink" title="list_array_tt 总的源码和类图"></a>list_array_tt 总的源码和类图</h2><p>下面是list_array_tt的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> Element 是元数据类型，比如 method_t</span></span><br><span class="line"><span class="comment"> List 是元数据的列表类型，比如 method_list_t</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 一个 list_array_tt 的值可能有三种情况：</span></span><br><span class="line"><span class="comment"> - 空的</span></span><br><span class="line"><span class="comment"> - 一个指针指向一个单独的列表</span></span><br><span class="line"><span class="comment"> - 一个数组，数组中都是指针，每个指针分别指向一个列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">* countLists/beginLists/endLists iterate the metadata lists</span></span><br><span class="line"><span class="comment">* count/begin/end iterate the underlying metadata elements</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list_array_tt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> count;   <span class="comment">/// 有多少个List*</span></span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> size_t <span class="title">byteSize</span><span class="params">(<span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">array_t</span>) + count*<span class="keyword">sizeof</span>(lists[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> byteSize() &#123;</span><br><span class="line">            <span class="keyword">return</span> byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        List **lists;</span><br><span class="line">        List **listsEnd;</span><br><span class="line">        <span class="keyword">typename</span> List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        iterator(List **begin, List **end) </span><br><span class="line">            : lists(begin), listsEnd(end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin != end) &#123;</span><br><span class="line">                m = (*begin)-&gt;begin();</span><br><span class="line">                mEnd = (*begin)-&gt;end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Element&amp; <span class="keyword">operator</span> * () <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *m;</span><br><span class="line">        &#125;</span><br><span class="line">        Element&amp; <span class="keyword">operator</span> * () &#123;</span><br><span class="line">            <span class="keyword">return</span> *m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists != rhs.lists) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (lists == listsEnd) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// m is undefined</span></span><br><span class="line">            <span class="keyword">if</span> (m != rhs.m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">            assert(m != mEnd);</span><br><span class="line">            m++;</span><br><span class="line">            <span class="keyword">if</span> (m == mEnd) &#123;</span><br><span class="line">                assert(lists != listsEnd);</span><br><span class="line">                lists++;</span><br><span class="line">                <span class="keyword">if</span> (lists != listsEnd) &#123;</span><br><span class="line">                    m = (*lists)-&gt;begin();</span><br><span class="line">                    mEnd = (*lists)-&gt;end();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        List* <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasArray</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayAndFlag &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">array_t</span> *<span class="built_in">array</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">array_t</span> *)(arrayAndFlag &amp; ~<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">array_t</span> *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        arrayAndFlag = (<span class="keyword">uintptr_t</span>)<span class="built_in">array</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 所有的list的所有元素总数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count() &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> lists = beginLists(), end = endLists(); </span><br><span class="line">             lists != end;</span><br><span class="line">             ++lists)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (*lists)-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(beginLists(), endLists());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List **e = endLists();</span><br><span class="line">        <span class="keyword">return</span> iterator(e, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> countLists() &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List** <span class="title">beginLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;lists;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List** <span class="title">endLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;lists + <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryFree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>()-&gt;count; i++) &#123;</span><br><span class="line">                try_free(<span class="built_in">array</span>()-&gt;lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            try_free(<span class="built_in">array</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            try_free(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result&gt;</span><br><span class="line">    <span class="function">Result <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">array_t</span> *a = <span class="built_in">array</span>();</span><br><span class="line">            result.setArray((<span class="keyword">array_t</span> *)memdup(a, a-&gt;byteSize()));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; a-&gt;count; i++) &#123;</span><br><span class="line">                result.<span class="built_in">array</span>()-&gt;lists[i] = a-&gt;lists[i]-&gt;duplicate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            result.<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;duplicate();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">list</span> = nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/arraylist_t_class.png" alt="list_array_tt 类结构图"></p><p>由图可以看出，list_array_tt结构的成员是一个匿名的union，或者存储单个类型为List*的list,或者存储多个列表，多个list使用arrayAndFlag表示，arrayAndFlag是个符合结构，低1位存储标志，高63位存储多个列表的地址，低位为1，表示多个列表，为0表示一个列表。</p><p>arrayAndFlag 高位存储一个地址，指向的类型是array_t，array_t有两个成员，第一个count表示列表的个数，lists存储List*类型的指针数组。 </p><h2 id="list-array-tt-部分源码分析"><a href="#list-array-tt-部分源码分析" class="headerlink" title="list_array_tt 部分源码分析"></a>list_array_tt 部分源码分析</h2><p>下面看最基本的三个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasArray</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrayAndFlag &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">array_t</span> *<span class="built_in">array</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">array_t</span> *)(arrayAndFlag &amp; ~<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">array_t</span> *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    arrayAndFlag = (<span class="keyword">uintptr_t</span>)<span class="built_in">array</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasArray 判断存储的是一个列表，还是多个列表。</p><p>array返回多个列表的地址，返回类型是<code>array_t *</code></p><p>setArray设置多个列表。将多个列表的地址和1与操作，存储在arrayAndFlag中。</p><p>下面首先看beginLists、endLists方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>** beginLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>()-&gt;lists;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">List</span>** endLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>()-&gt;lists + <span class="keyword">array</span>()-&gt;count;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beginLists 返回列表的首元素的地址，endLists返回列表尾后元素的地址。为了方便理解，画了下图：</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/begainlist_endlist.png" alt="begainlist、endlist方法结果示意图">  </p><p>图中需要注意命名规则，list表示单个列表，lists表示多个列表。</p><p>如上图所示，当list_array_tt存储一个<code>List*</code>时，beginLists返回list的地址、当list_array_tt存储多个<code>List*</code>时，beginLists返回lists的地址，返回类型是<code>List**</code>。 </p><p>同理，当list_array_tt存储一个<code>List*</code>时，endLists返回list尾后地址、当list_array_tt存储多个<code>List*</code>时，endLists返回lists的尾后地址，就是最后一个List<em>的末尾。返回类型是`List*</em>`</p><p>图中红色的线表示beginLists、endLists指向的地址。</p><p>下面在来看countLists方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> countLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>countLists返回<code>List*</code>的个数，如果是单个列表，返回1，多个列表返回array()-&gt;count。</p><p>下面看最关键的函数attachLists，这个函数个将分类的方法列表添加到原始类的方法列表上面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数分为三部分，分别处理：</p><ol><li>多个列表添加新的列表</li><li>单个列表添加新的列表</li><li>空列表添加新的列表</li></ol><p>多个列表时： 首先计算所有列表的总数，申请大的空间，将原有列表和新addedLists添加到新的空间中。</p><p><code>else if</code>是处理在空列表中添加一个新元素的列表addedLists。</p><p><code>else</code> 分支处理在空列表中添加多个元素的列表、或者在原来一个元素的列表(list)中添加新列表addedLists，添加的结果列表中存储多个列表。所以一起处理。处理的流程和第一个分支类似。</p><p>下面是部分在原有5个元素的列中中添加两个元素的列表addedLists的示意图。</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/attachLists.png" alt="attachLists添加2个元素的示意图">  </p><h2 id="list-array-tt-迭代器"><a href="#list-array-tt-迭代器" class="headerlink" title="list_array_tt 迭代器"></a>list_array_tt 迭代器</h2><p>下面看begin、end方法：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">iterator</span> begin() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">iterator</span>(beginLists(), endLists());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">iterator</span> <span class="keyword">end</span>() &#123;</span><br><span class="line">    <span class="type">List</span> **e = endLists();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">iterator</span>(e, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>begin、end方法返回list_array_tt的首元素迭代器和尾后元素迭代器。</p><p>迭代器有四个元素：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> **lists;</span><br><span class="line"><span class="built_in">List</span> **listsEnd;</span><br><span class="line">typename <span class="built_in">List</span><span class="type">::iterator</span> m, mEnd;</span><br></pre></td></tr></table></figure><p>首迭代器四个成员指向的位置如图所示：</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/arraylist_tt_iterator.png" alt="迭代器示意图">  </p><p>根据上图可以容易的理解迭代器的各个成员的指向。那么迭代器重要的操作++就比较容易理解了。代码如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator&amp; operator ++ () &#123;</span><br><span class="line">    assert(m != mEnd);</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">if</span> (m == mEnd) &#123;</span><br><span class="line">        assert(lists != listsEnd);</span><br><span class="line">        lists++;</span><br><span class="line">        <span class="keyword">if</span> (lists != listsEnd) &#123;</span><br><span class="line">            <span class="function"><span class="title">m</span> = <span class="params">(*lists)</span>-&gt;</span>begin();</span><br><span class="line">            <span class="function"><span class="title">mEnd</span> = <span class="params">(*lists)</span>-&gt;</span>end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在是类别的元素的（method_t）的迭代器指向++操作，即m执行++，如果元素的迭代器迭代完成，即，m==mEnd,退出到外部，指向lists的++操作,然后在继续内部元素的迭代器操作。以此类推。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list_array_tt 是个模板类，可以实例化出method_array_t，method_array_t在class_rw_t中使用，存储多个分类中的方法列表。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>4. 方法列表entsize_list_tt结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/</id>
    <published>2018-11-03T02:38:11.000Z</published>
    <updated>2018-11-21T07:07:58.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中</p><a id="more"></a><h2 id="entsize-list-tt-简单介绍"><a href="#entsize-list-tt-简单介绍" class="headerlink" title="entsize_list_tt 简单介绍"></a>entsize_list_tt 简单介绍</h2><p>类的编译后的数据存储在class_ro_t结构中，其中各种方法列表、变量列表、属性列表的类型分别是method_list_t、ivar_list_t、property_list_t，这些类型全部继承于entsize_list_tt。class_ro_t的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RO 就是 Read Only</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;  <span class="comment">// 基本方法列表，存储编译期确定的方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;       <span class="comment">// 类的成员变量列表，存储编译期确定的成员变量</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 基本属性列表，存储编译期确定的属性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>method_list_t 继承于entsize_list_tt 的源码如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, <span class="number">0x3</span>&gt; &#123; // <span class="number">0x3</span> 就是 <span class="number">0b11</span></span><br><span class="line">                                                                       // 即 flag 占 <span class="number">2</span> 个 bit，用来放 fixedup markers</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面就开始学习entsize_list_tt数据结构。</p><h2 id="entsize-list-tt-详细分析"><a href="#entsize-list-tt-详细分析" class="headerlink" title="entsize_list_tt 详细分析"></a>entsize_list_tt 详细分析</h2><p>entsize_list_tt其实就是一个列表，用来存储编译完成后类的属性。由于位于class_ro_t结构中，所以这个结构是只读的，没有写方法，只有访问的相关方法，定义如下，只包含了部分代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entsize_list_tt 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。</span></span><br><span class="line"><span class="comment">// Element 表示元素类型，List 用于指定容器类型，</span></span><br><span class="line"><span class="comment">// 最后一个参数为标记位, 用来在 entsize field 里存放一些额外的 bits，也就是 flags</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List, <span class="keyword">uint32_t</span> FlagMask&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entsize_list_tt</span> &#123;</span></span><br><span class="line">    <span class="comment">// entsize 和 flags 存在了一起，需要用 FlagMask 进行区分哪些 bits 里存的是 flags</span></span><br><span class="line">    <span class="comment">// entsize 就是每个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsizeAndFlags;</span><br><span class="line">    <span class="keyword">uint32_t</span> count; <span class="comment">// 元素的总数</span></span><br><span class="line">    Element first;  <span class="comment">// 第一个元素，其他的元素紧跟在其后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 entsize 单个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; ~FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出 flags</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素，i &lt;= count</span></span><br><span class="line">    <span class="comment">// 如果 i 等于 count，取得的就是最后一个元素的末尾地址</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">getOrEnd</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt;= count);</span><br><span class="line">        <span class="comment">// 从第一个元素开始，加上偏移量 i * 单个元素的大小</span></span><br><span class="line">        <span class="comment">// 就是 i 索引处的元素</span></span><br><span class="line">        <span class="keyword">return</span> *(Element *)((<span class="keyword">uint8_t</span> *)&amp;first + i*entsize()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素</span></span><br><span class="line">    <span class="comment">// i 必须小于总数</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">get</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt; count);</span><br><span class="line">        <span class="keyword">return</span> getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得整个 entsize_list_tt 对象以及其保存的所有元素占多少内存</span></span><br><span class="line">    <span class="keyword">size_t</span> byteSize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// sizeof(*this) 计算是对象本身占的大小，其中还包括了第一个元素</span></span><br><span class="line">        <span class="comment">// (count-1)*entsize() 计算的是除了第一个元素外，其他所有元素占的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) + (count<span class="number">-1</span>)*entsize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span>;</span></span><br><span class="line">    <span class="comment">// 取得指向容器的第一个元素的迭代器，返回值是变量，可以变</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指向容器尾部的迭代器，注意是尾部，也就是最后一个元素的末尾，并不是最后的一个元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), count); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">        Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line">        <span class="comment">// start 是当前的索引</span></span><br><span class="line">        iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">            : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">            , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">            , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器向后移动 delta 个位置</span></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> += (<span class="keyword">ptrdiff_t</span> delta) &#123;</span><br><span class="line">            <span class="comment">// 计算出新元素的地址，保存起来</span></span><br><span class="line">            element = (Element*)((<span class="keyword">uint8_t</span> *)element + delta*entsize);</span><br><span class="line">            <span class="comment">// 索引也加上 delta</span></span><br><span class="line">            index += (<span class="keyword">int32_t</span>)delta;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....   </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>entsize_list_tt 是个模板，可以实例化出method_list_t、ivar_list_t、property_list_t三种类型。有三个数据成员，entsizeAndFlags 是个复合成员，高位表示元素的大小，低位是个标志位，entsize、Flags具体占用多少位，根据模板参数FlagMask决定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x3 就是 0b11,即 flag 占 2 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">0x3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">ivar_t</span>, <span class="keyword">ivar_list_t</span>, <span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">property_t</span>, <span class="keyword">property_list_t</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><p>method_list_t 实例化时，递给FlagMask的模板实参是0x3，转化为二进制为0b11，占用两位。那么在method_list_t结构中，entsizeAndFlags 表示的entsize占用30位，Flags占用2位。</p><p>count 表示列表中存储元素的个数，first 表示首元素。注意他不是个指针，只是一个首元素，后面的元素会挨着first顺序存储。</p><p>method_list_t 的方法基本都是访问属性的。慢慢看着注释应该嫩看懂。</p><p>类图以方法列表method_list_t为例，里面存储的元素是method_t类型：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt类图.png" alt="entisize_list_tt类图"></p><h2 id="entisize-list-tt-内存布局"><a href="#entisize-list-tt-内存布局" class="headerlink" title="entisize_list_tt 内存布局"></a>entisize_list_tt 内存布局</h2><p>为了进一步理解这个结构，我用hopper抓了一个这样的结构，如图所示，</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_hopper.png" alt="entisize_list_tt 实例数据"></p><p>我们将这个数据放入内存，内存结构大致如下：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_memory.png" alt="entisize_list_tt 内存布局"></p><p>entsizeAndFlags 的值是0x18，转化为二进制，为0b1,1000，那么entsize的值去高20位，还是0b1,1000，十进制为24表示元素的大小是24，然后继续看元素，元素的类型是method_t，大小为24，验证了entsize的含义。flag取低二位，为0 。</p><p>接下来的count的值是3，表示有三个元素。后面紧跟着三个元素。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>既然entsize_list_tt是一个列表，那么就需要一个迭代器，从而枚举列表内部的元素。迭代器是个内部类，重载了很多方法，迭代器类主要的方法是构造函数，剩下的全部是重载运算符，大致雷同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line"><span class="comment">// start 是当前的索引</span></span><br><span class="line">iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">    : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">    , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">    , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><p>下面是迭代器的示意图。</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_iterator.png" alt="entisize_list_tt 迭代器示意图"></p><p>示意图中列出指向首元素的迭代器begin、尾后迭代器end、和begin+2的内存结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="entsize_list_tt" scheme="http://yoursite.com/tags/entsize-list-tt/"/>
    
  </entry>
  
  <entry>
    <title>3. NSObject 基本完整类图</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/</id>
    <published>2018-11-02T02:38:11.000Z</published>
    <updated>2018-11-21T07:07:48.250Z</updated>
    
    <content type="html"><![CDATA[<p>本文保存了NSObject的基本完整类图。方便以后理解。</p><a id="more"></a><h2 id="NSObject-完整类图"><a href="#NSObject-完整类图" class="headerlink" title="NSObject 完整类图"></a>NSObject 完整类图</h2><p>NSObject 基本完整类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/NSObject_picture.png" alt="NSObject 完整类图"></p><p>objc_class 有四个成员，本图说明两个非常重要的成员- isa、bits。 isa指向对象的类（或者类的元类）；bits定义了类的数据，包括类的属性、方法、协议、ivar 。 它的类型是class_data_bits_t，class_data_bits_t 有一个成员，类型是uintptr_t，64位。其中1~3位表示一个属性，3~47位表示一个指针，如果class还没有实现，这个指针指向class_ro_t类型，表示类编译完后的只读属性。当类实现后，这个指针指向了class_rw_t类型，表示runtime实现完class后类的数据，这是，数据里面已经包括了分类的方法信息。</p><h2 id="使用hopper查看类结构"><a href="#使用hopper查看类结构" class="headerlink" title="使用hopper查看类结构"></a>使用hopper查看类结构</h2><p>首先定义类LJObject，头文件如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LJObject.h</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObject </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>实现文件如下 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LJObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LJObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span>*) printDefaultName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span> *)printDefaultValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用hopper查看的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_nsobject.png" alt="hopper 查看类的结构"></p><h2 id="五小结构"><a href="#五小结构" class="headerlink" title="五小结构"></a>五小结构</h2><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>方法的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名，就是 SEL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法类型字符串，有的地方又称 method signature 方法签名</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向方法的函数实现的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3_method_t.png" alt="method_t类图"></p><p>hopper查看的结果如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_method_t.jpg" alt="hopper 查看method_t结构"></p><p>总结method_t值包含三个属性，方法名字、方法签名、方法的实现。</p><h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset; <span class="comment">// 偏移量 用 __OFFSETOFIVAR__ 计算</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 成员变量名  比如 "_name"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type; <span class="comment">// 成员变量的类型 比如 "@\"NSString\""</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">// 对齐</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;  <span class="comment">// 成员变量占多少内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3ivar.png" alt="ivar_t类图"></p><h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 属性名，堆中分配</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// 属性的特性字符串，标识了属性有哪些特性</span></span><br><span class="line">                            <span class="comment">// 该字符串是在堆中分配的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3property.png" alt="property_t 类图"></p><h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><p>定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议结构体，继承自 objc_object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;    <span class="comment">// 重整后的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 它在 objc_allocateProtocol() 中被赋值，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样，</span></span><br><span class="line">                                <span class="comment">// 重整名字是编译器给出的，加了 swift 复杂前缀的，用于混编时区分 oc协议 和 swift协议，</span></span><br><span class="line">                                <span class="comment">// 而 demangledName 取消重整的名称，应该就是去掉前缀的正常的名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>  <span class="comment">// 子协议列表，见 protocol_addProtocol()</span></span><br><span class="line">                                        <span class="comment">// 又可以称为 incorporated protocols 合并的协议</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;  <span class="comment">// 必选(required)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;   <span class="comment">//  必选(required)的类方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods; <span class="comment">// 可选(optional)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;  <span class="comment">// 可选(optional)的类方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;  <span class="comment">// 实例属性，当前协议只支持 required 的实例属性，</span></span><br><span class="line">                                          <span class="comment">// 协议中也是可以添加属性的，</span></span><br><span class="line">                                          <span class="comment">// 不知道会不会生成成员变量，但生成 set 和 get 方法是一定有的</span></span><br><span class="line">                                          <span class="comment">// 比如 NSObject 协议，就有几个 readonly 的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// 这个协议的大小，其中也包括了 extendedMethodTypes 整个数组的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;  <span class="comment">// 标记 跟 PROTOCOL_FIXED_UP_1 / PROTOCOL_FIXED_UP_2 有关系</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 这句话的意思，好像是下面这几个成员变量不一定有，</span></span><br><span class="line">    <span class="comment">// 所以用到它们的时候都检查了下 size 是否足够大，比如 hasExtendedMethodTypesField() 和 protocol_t::demangledName()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **extendedMethodTypes; <span class="comment">// 扩展方法类型数组，每个元素是一个扩展类型字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName; <span class="comment">// 取消重整的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样</span></span><br><span class="line">                                <span class="comment">// 见 demangledName()</span></span><br><span class="line">                                <span class="comment">// demangledName 取消重整的名称，应该就是去掉 swift 前缀的正常的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3protocal.png" alt="protocol_t 类图"></p><h3 id="category-t"><a href="#category-t" class="headerlink" title="category_t"></a>category_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 分类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">// 分类所属的类，classref_t 专门用于 unremapped 的类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>     <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>      <span class="comment">// 遵循的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性列表，但是并没有卵用... 唉....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3category.png" alt="category_t 类图"></p><h3 id="五小结构总图"><a href="#五小结构总图" class="headerlink" title="五小结构总图"></a>五小结构总图</h3><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3five.png" alt="5小结构总图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文保存了NSObject的基本完整类图。方便以后理解。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>2. class_data_bits_t 结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/2_NSObject_objc_object/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/2_NSObject_objc_object/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-22T09:31:13.847Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><p>在上一篇分析 <code>isa</code> 的文章<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解 isa</a> 中曾经说到过实例方法被调用时，会通过其持有 <code>isa</code> 指针寻找对应的类，然后在其中的 <code>class_data_bits_t</code> 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。</p><p>这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。</p><h2 id="方法在内存中的位置"><a href="#方法在内存中的位置" class="headerlink" title="方法在内存中的位置"></a>方法在内存中的位置</h2><p>先来了解一下 ObjC 中类的结构图：<br><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class.png" alt="类的结构图"></p><ul><li><code>isa</code> 是指向元类的指针，不了解元类的可以看 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><code>super_class</code> 指向当前类的父类</li><li><code>cache</code> 用于缓存指针和 <code>vtable</code>，加速方法的调用</li><li><code>bits</code> 就是存储类的方法、属性和遵循的协议等信息的地方</li></ul><h3 id="class-data-bits-t-结构体"><a href="#class-data-bits-t-结构体" class="headerlink" title="class_data_bits_t 结构体"></a><code>class_data_bits_t</code> 结构体</h3><p>这一小结会分析类结构体中的 <code>class_data_bits_t bits</code>。其中只含有一个 64 位的 <code>bits</code> 用于存储与类有关的信息，它的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits; <span class="comment">// 只有这个一个成员变量，所有数据都存在这里，包括 rw 的地址和一些 flag</span></span><br><span class="line">                    <span class="comment">// 1. 在 realized 之前，bits 存的是 ro 的地址，</span></span><br><span class="line">                    <span class="comment">// 2. realized 后，bits 存 rw 的地址，rw 里的存有 ro 的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从定义可以看出，这只用一个成员，但是也类似位域，不同的位有不同的作用，bit不像isa使用位域定义，他使用移位定义，如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)  <span class="comment">// 用于判断 Swift 类</span></span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)  <span class="comment">// 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法</span></span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)  <span class="comment">// 当前类的实例需要 raw isa</span></span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL <span class="comment">// 存 rw 的地址的位置</span></span></span><br></pre></td></tr></table></figure><p>全部是FAST开头，说明可以快速取到，而不用去次级对象中取。还有以RW、RO开头的宏，表示在次级的class_rw_t、class_ro_t结构的标志位。class_data_bits_t的类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class-data-bits-t.png" alt="objc-method-class-data-bits-t"></p><p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 rr/alloc 的标志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><p>它为我们提供了便捷方法用于返回其中的 <code>class_rw_t *</code> 指针：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">class_rw_t</span>* <span class="class"><span class="keyword">data</span>() &#123;</span></span><br><span class="line"><span class="class">   <span class="title">return</span> (<span class="title">class_rw_t</span> *)(<span class="title">bits</span> &amp; <span class="type">FAST_DATA_MASK</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，只取其中的 <code>[3, 47]</code> 位转换成 <code>class_rw_t *</code> 返回。</p><blockquote><p>在 x86_64 架构上，Mac OS <strong>只使用了其中的 47 位来为对象分配地址</strong>。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。</p></blockquote><p>因为 <code>class_rw_t *</code> 指针只存于第 <code>[3, 47]</code> 位，所以可以使用最后三位来存储关于当前类的其他信息：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class_data_bits_t.png" alt="objc-method-class_data_bits_t"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure><ul><li><code>isSwift()</code><ul><li><code>FAST_IS_SWIFT</code> 用于判断 Swift 类</li></ul></li><li><code>hasDefaultRR()</code><ul><li><code>FAST_HAS_DEFAULT_RR</code> 当前类或者父类含有默认的 <code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li></ul></li><li><code>requiresRawIsa()</code><ul><li><code>FAST_REQUIRES_RAW_ISA</code> 当前类的实例需要 raw <code>isa</code></li></ul></li></ul><p>执行 <code>class_data_bits_t</code> 结构体中的 <code>data()</code> 方法或者调用 <code>objc_class</code> 中的 <code>data()</code> 方法会返回同一个 <code>class_rw_t *</code> 指针，因为 <code>objc_class</code> 中的方法只是对 <code>class_data_bits_t</code> 中对应方法的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// objc_class 中的 data() 方法</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123; </span><br><span class="line">   return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_data_bits_t 中的 data() 方法</span><br><span class="line">uintptr_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t-和-class-ro-t"><a href="#class-rw-t-和-class-ro-t" class="headerlink" title="class_rw_t 和 class_ro_t"></a><code>class_rw_t</code> 和 <code>class_ro_t</code></h3><p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 <code>class_rw_t</code> 中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags<span class="comment">;</span></span><br><span class="line">    uint32_t version<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    method_array_t methods<span class="comment">;</span></span><br><span class="line">    property_array_t properties<span class="comment">;</span></span><br><span class="line">    protocol_array_t protocols<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass<span class="comment">;</span></span><br><span class="line">    Class nextSiblingClass<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中还有一个指向常量的指针 <code>ro</code>，其中存储了<strong>当前类在编译期就已经确定的属性、方法以及遵循的协议</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在编译期间</strong>类的结构中的 <code>class_data_bits_t *data</code> 指向的是一个 <code>class_ro_t *</code> 指针：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>然后在加载 <em>ObjC 运行时</em>的时候调用 <code>realizeClass</code> 方法：</p><ol><li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li><li>初始化一个 <code>class_rw_t</code> 结构体</li><li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li><li>最后设置正确的 <code>data</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>下图是 <code>realizeClass</code> 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-realize-class.png" alt="objc-method-after-realize-class"></p><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><h2 id="XXObject"><a href="#XXObject" class="headerlink" title="XXObject"></a>XXObject</h2><p>下面，我们将分析一个类 <code>XXObject</code> 在运行时初始化过程中内存的更改，这是 <code>XXObject</code> 的接口与实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-target.png" alt="objc-method-target"></p><p>这是主程序的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XXObject.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Class cls = [XXObject class];</span><br><span class="line">        NSLog(@&quot;%p&quot;, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译后内存中类的结构"><a href="#编译后内存中类的结构" class="headerlink" title="编译后内存中类的结构"></a>编译后内存中类的结构</h3><p>因为<strong>类在内存中的位置是编译期就确定的</strong>，先运行一次代码获取 <code>XXObject</code> 在内存中的地址。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100001168</span></span><br></pre></td></tr></table></figure><p>接下来，在整个 ObjC 运行时初始化之前，也就是 <code>_objc_init</code> 方法中加入一个断点：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-compile.png" alt="objc-method-after-compile"></p><p>然后在 lldb 中输入以下命令：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)<span class="number">0</span>x100001168</span><br><span class="line">(objc_class *) <span class="variable">$0</span> = <span class="number">0</span>x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0</span>x100001188</span><br><span class="line">(class_data_bits_t *) <span class="variable">$1</span> = <span class="number">0</span>x0000000100001188</span><br><span class="line">(lldb) p <span class="variable">$1</span>-&gt;data()</span><br><span class="line">warning: could not <span class="built_in">load</span> <span class="literal">any</span> Objective-C class information. This will significantly reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) <span class="variable">$2</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p (class_ro_t *)<span class="variable">$2</span> // 将 class_rw_t 强制转化为 class_ro_t</span><br><span class="line">(class_ro_t *) <span class="variable">$3</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$3</span></span><br><span class="line">(class_ro_t) <span class="variable">$4</span> = &#123;</span><br><span class="line">  <span class="keyword">flags</span> = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  name = <span class="number">0</span>x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0</span>x00000001000010c8</span><br><span class="line">  baseProtocols = <span class="number">0</span>x0000000000000000</span><br><span class="line">  ivars = <span class="number">0</span>x0000000000000000</span><br><span class="line">  weakIvarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  baseProperties = <span class="number">0</span>x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-print-before-realize.png" alt="objc-method-lldb-print-before-realize"></p><p>现在我们获取了类经过编译器处理后的只读属性 <code>class_ro_t</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(class_ro_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  flags = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  name = <span class="number">0x0000000100000f7a</span> <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000010c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面只有 <code>baseMethodList</code> 和 <code>name</code> 是有值的，其它的 <code>ivarLayout</code>、 <code>baseProtocols</code>、 <code>ivars</code>、<code>weakIvarLayout</code> 和 <code>baseProperties</code> 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。</p><p>通过下面的命令查看 <code>baseMethodList</code> 中的内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">4</span>.baseMethodList</span><br><span class="line">(method_list_t *) $<span class="number">5</span> = <span class="number">0</span>x00000001000010c8</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">0</span>)</span><br><span class="line">(method_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject<span class="selector-class">.m</span>:<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">1</span>)</span><br><span class="line">Assertion failed: (<span class="selector-tag">i</span> &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new<span class="selector-class">.h</span>, line <span class="number">110</span>.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-print-method-list.png" alt="objc-method-lldb-print-method-list"></p><p>使用 <code>$5-&gt;get(0)</code> 时，成功获取到了 <code>-[XXObject hello]</code> 方法的结构体 <code>method_t</code>。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。</p><h3 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h3><p>这篇文章中不会对 <code>realizeClass</code> 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括：</p><ul><li>分配可读写数据空间</li><li>返回真正的类结构</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">Class</span> realizeClass(<span class="keyword">Class</span> cls)</span><br></pre></td></tr></table></figure><p>上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 <code>XXObject</code>：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-breakpoint.png" alt="objc-method-lldb-breakpoint"></p><p>这里直接判断两个指针是否相等，而不使用 <code>[NSStringFromClass(cls) isEqualToString:@&quot;XXObject&quot;]</code> 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 <code>XXObject</code>。</p><blockquote><p>直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-breakpoint-before-set-rw.png" alt="objc-method-breakpoint-before-set-r"></p><p>这个断点就设置在这里，因为 <code>XXObject</code> 是一个正常的类，所以会走 <code>else</code> 分支为<strong>可写的类数据</strong>分配内存。</p><blockquote><p>运行代码时，因为每次都会判断当前类指针是不是指向的 <code>XXObject</code>，所以会等一会才会进入断点。</p></blockquote><p>在这时打印类结构体中的 <code>data</code> 的值，发现其中的布局依旧是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>在运行完这段代码之后:</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-realize-breakpoint.png" alt="objc-method-after-realize-breakpoint"></p><p>我们再来打印类的结构:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)cls <span class="comment">// 打印类指针</span></span><br><span class="line">(objc_class *) <span class="variable">$262</span> = 0x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100001188 <span class="comment">// 在类指针上加 32 的 offset 打印 class_data_bits_t 指针</span></span><br><span class="line">(class_data_bits_t *) <span class="variable">$263</span> = 0x0000000100001188</span><br><span class="line">(lldb) p *<span class="variable">$263</span> <span class="comment">// 访问 class_data_bits_t 指针的内容</span></span><br><span class="line">(class_data_bits_t) <span class="variable">$264</span> = (bits = 4302315312)</span><br><span class="line">(lldb) p <span class="variable">$264</span>.data() <span class="comment">// 获取 class_rw_t</span></span><br><span class="line">(class_rw_t *) <span class="variable">$265</span> = 0x0000000100701f30</span><br><span class="line">(lldb) p *<span class="variable">$265</span> <span class="comment">// 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了</span></span><br><span class="line">(class_rw_t) <span class="variable">$266</span> = &#123;</span><br><span class="line">  flags = 2148007936</span><br><span class="line">  <span class="keyword">version</span> = 0</span><br><span class="line">  ro = 0x00000001000010e8</span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;method_t, method_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;property_t, property_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = nil</span><br><span class="line">  demangledName = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$266</span>.ro <span class="comment">// 获取 class_ro_t 指针</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) <span class="variable">$267</span> = 0x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$267</span> <span class="comment">// 访问 class_ro_t 指针的内容</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) <span class="variable">$268</span> = &#123;</span><br><span class="line">  flags = 128</span><br><span class="line">  instanceStart = 8</span><br><span class="line">  instanceSize = 8</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  name = 0x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = 0x00000001000010c8</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$268</span>.baseMethodList <span class="comment">// 获取基本方法列表</span></span><br><span class="line">(method_list_t *<span class="keyword">const</span>) <span class="variable">$269</span> = 0x00000001000010c8</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(0) <span class="comment">// 访问第一个方法</span></span><br><span class="line">(method_t) <span class="variable">$270</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = 0x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.<span class="keyword">m</span>:13)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(1) <span class="comment">// 尝试访问第二个方法，越界</span></span><br><span class="line"><span class="keyword">error</span>: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">Assertion failed: (i &lt; <span class="keyword">count</span>), function get, <span class="keyword">file</span> /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.<span class="keyword">h</span>, <span class="keyword">line</span> 110.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-print-class-struct-after-realize.png" alt="objc-method-print-class-struct-after-realize"></p><blockquote><p>最后一个操作实在是截取不到了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>在上述的代码运行之后，类的只读指针 <code>class_ro_t</code> 以及可读写指针 <code>class_rw_t</code> 都被正确的设置了。但是到这里，其 <code>class_rw_t</code> 部分的方法等成员的指针 <code>methods</code>、 <code>protocols</code> 和 <code>properties</code> 均为空，这些会在 <code>methodizeClass</code> 中进行设置：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-methodizeClass.png" alt="objc-method-after-methodizeClass"></p><p>在这里调用了 <code>method_array_t</code> 的 <code>attachLists</code> 方法，将 <code>baseMethods</code> 中的方法添加到 <code>methods</code> 数组之后。我们访问 <code>methods</code> 才会获取当前类的实例方法。</p><h2 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h2><p>说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name<span class="comment">;</span></span><br><span class="line">    const char *types<span class="comment">;</span></span><br><span class="line">    IMP imp<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中包含方法名，类型还有方法的实现指针 <code>IMP</code>：</p><p>上面的 <code>-[XXObject hello]</code> 方法的结构体是这样的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="attr">types</span> = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line"><span class="attr">imp</span> = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject.m:<span class="number">13</span></span><br></pre></td></tr></table></figure><p>方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 <code>&quot;v16@0:8&quot;</code> 这在 ObjC 中叫做<em>类型编码</em>(Type Encoding)，你可以看这篇<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>了解与类型编码相关的信息。</p><p>对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析方法在内存中的位置时，笔者最开始一直在尝试寻找<strong>只读</strong>结构体 <code>class_ro_t</code> 中 <code>baseMethods</code> 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 <code>methodizeClass</code> 方法一直向上找，直到 <code>_obj_init</code> 方法也没有找到设置只读区域的 <code>baseMethods</code> 的方法。</p><p>而且在 runtime 初始化之后，<code>realizeClass</code> 之前，从 <code>class_data_bits_t</code> 结构体中获取的 <code>class_rw_t</code> 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 <code>realizeClass</code> 中发现原来在这时并不是 <code>class_rw_t</code> 结构体，而是<code>class_ro_t</code>，才明白错误的原因。</p><p>后来突然想到类的一些方法、属性和协议实在编译期决定的（<code>baseMethods</code> 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。</p><ol><li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li><li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 <code>realizeClass</code> 执行之后，才放到了 <code>class_rw_t</code> 指向的只读区域 <code>class_ro_t</code>，这样我们即可以在运行时为 <code>class_rw_t</code> 添加方法，也不会影响类的只读结构。</li><li>在 <code>class_ro_t</code> 中的属性在运行期间就不能改变了，再添加方法时，会修改 <code>class_rw_t</code> 中的 <code>methods</code> 列表，而不是 <code>class_ro_t</code> 中的 <code>baseMethods</code>，对于方法的添加会在之后的文章中分析。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 &lt;code&gt;x86_64&lt;/code&gt; 架构下运行的，对于在 arm64 中运行的代码会特别说明
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>1. 从 NSObject 的初始化了解 isa（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/1_NSObject_isa/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/1_NSObject_isa/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-22T09:30:02.116Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件</p><a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><h2 id="OC的类是一个结构体"><a href="#OC的类是一个结构体" class="headerlink" title="OC的类是一个结构体"></a>OC的类是一个结构体</h2><p>所有的OC类其实都是一个c语言的结构体，我们可以通过clang -rewrite-objc 命令重写OC类为C++类。来理解OC的类就是一个C语言的结构体。下面是重写的实例，类的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObjc</span>:NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">LJObjc</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>在从重写后的输出文件中，我们找到LJObjc的定义，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">LJObjc</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出，OC类就是一个C的结构体。</p><p>既然所有的OC对都是一个结构体，这个结构体就是struct objc_object。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>objc_object结构中只有一个 <code>isa_t</code>类型成员。所以我们可以说含有isa的结构体都是一个对象。</p><blockquote><p>所有继承自 <code>NSObject</code> 的类实例化后的对象都会包含一个类型为 <code>isa_t</code> 的结构体。</p></blockquote><p>虽然上面重写LJObjc后的C语言结构体是一个objc_object对象，但实际上他是一个objc_class结构体，由于objc_class继承与objc_object，  所以本质上objc_class 也是一个objc_object结构。<br>objc_class定义如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa<span class="comment">;</span></span><br><span class="line">    Class superclass<span class="comment">;</span></span><br><span class="line">    <span class="keyword">cache_t </span><span class="keyword">cache;</span></span><br><span class="line"><span class="keyword"> </span>   class_data_bits_t <span class="keyword">bits;</span></span><br><span class="line"><span class="keyword">&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的，所以在这里显式地写出了 <code>isa_t isa</code> 这个成员变量。</p></blockquote><p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p><h2 id="isa-指针的作用与元类"><a href="#isa-指针的作用与元类" class="headerlink" title="isa 指针的作用与元类"></a><code>isa</code> 指针的作用与元类</h2><p> <code>isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p><p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p><p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code>isa</code> 来查找对应的类，然后在这里的 <code>class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code>objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code>super_class</code> 用来查找继承的方法。</p><blockquote><p>关于如何在 <code>class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" rel="external nofollow noopener noreferrer" target="_blank">深入解析 ObjC 中方法的结构</a></p></blockquote><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-pointer.png" alt="isa 指针-- 实例找到类"></p><p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-meta-class.png" alt="元类的引入"></p><p>让每一个类的 <code>isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p><ul><li>实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现</li><li>类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现</li></ul><p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-diagram.png" alt="元类"></p><blockquote><p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></p></blockquote><p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code>isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></p><h2 id="结构体-isa-t"><a href="#结构体-isa-t" class="headerlink" title="结构体 isa_t"></a>结构体 <code>isa_t</code></h2><p>其实 <code>isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是在 <code>__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code>__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="#arm64">arm64 上结构体的实现</a></p></blockquote><p><strong>在本篇文章中, 我们会以 <code>__x86_64__</code> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code>isa</code> 指针的理解，不过还是要知道的。</p><p>下面是一张isa_t的类图，便于理解</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-object-class.png" alt="isa类图"></p><p>笔者对这个 <code>isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，对 <code>union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">回答</a>. 也就是说其中的 <code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间。而 <code>isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat.png" alt="isa各个位域的含义"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a><code>isa</code> 的初始化</h2><p>我们可以通过 <code>isa</code> 初始化的方法 <code>initIsa</code> 来初步了解这 64 位的 bits 的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///定义位于objc-object.h文件</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexed-和-magic"><a href="#indexed-和-magic" class="headerlink" title="indexed 和 magic"></a><code>indexed</code> 和 <code>magic</code></h3><p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code>initIsa</code> 方法，由于在 <code>initInstanceIsa</code> 方法中传入了 <code>indexed = true</code>，所以，我们简化一下这个方法的实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void objc_object::initIsa(Class cls, <span class="keyword">bool </span>indexed, <span class="keyword">bool </span>hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.<span class="keyword">bits </span>= ISA_MAGIC_VALUE<span class="comment">;</span></span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br><span class="line">    isa.<span class="keyword">shiftcls </span>= (uintptr_t)cls &gt;&gt; <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对整个 <code>isa</code> 的值 <code>bits</code> 进行设置，传入 <code>ISA_MAGIC_VALUE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br></pre></td></tr></table></figure><p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-bits.png" alt="objc-isa-isat-bits"></p><p>从图中了解到，在使用 <code>ISA_MAGIC_VALUE</code> 设置 <code>isa_t</code> 结构体之后，实际上只是设置了 <code>indexed</code> 以及 <code>magic</code> 这两部分的值。</p><ul><li><p>其中 <code>indexed</code> 表示 <code>isa_t</code> 的类型</p><ul><li><p>0 表示 <code>raw isa</code>，也就是没有结构体的部分，访问对象的 <code>isa</code> 会直接返回一个指向 <code>cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>1 表示当前 <code>isa</code> 不是指针，但是其中也有 <code>cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 <code>shiftcls</code> 中</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>magic</code> 的值为 <code>0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p></li></ul><h3 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a><code>has_cxx_dtor</code></h3><p>在设置 <code>indexed</code> 和 <code>magic</code> 值之后，会设置 <code>isa</code> 的 <code>has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto"></p><h3 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a><code>shiftcls</code></h3><p>在为 <code>indexed</code>、 <code>magic</code> 和 <code>has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code>isa</code> 结构体中了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p><p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing" rel="external nofollow noopener noreferrer" target="_blank">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code>000</code>，我们只会用其中的 30 位来表示对象的地址。 </p></blockquote><p>而 ObjC 中的类指针的地址后三位也为 0，在 <code>_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-cls.png" alt="objc-isa-print-cls"></p><p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code>Class</code> 指针时右移三位是没有问题的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。 </p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-object.png" alt="objc-isa-print-object"></p><blockquote><p>使用整个指针大小的内存来存储 <code>isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code>ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code>isa</code> 留下 34 位用于性能的优化。</p><p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.<br>from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></p></blockquote><p>我尝试运行了下面的代码将 <code>NSObject</code> 的类指针和对象的 <code>isa</code> 打印出来，具体分析一下</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-class-object.png" alt="objc-isa-print-class-object"></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span><span class="number">_p</span>ointer: <span class="number">0000000001011101100000000000000100000000001110101110000011111001</span> <span class="comment">// 补全至 64 位</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_p</span>ointer:                                 <span class="number">100000000001110101110000011111000</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器对直接访问 <code>isa</code> 的操作会有警告，因为直接访问 <code>isa</code> 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 <a href="#ISA(">ISA()</a>) 方法来获取类指针。</p></blockquote><p>代码中的 <code>object</code> 对象的 <code>isa</code> 结构体中的内容是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits"></p><p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code>[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code>isa</code> 时对 <code>initIsa</code> 方法的分析是正确的。它设置了 <code>indexed</code>、<code>magic</code> 以及 <code>shiftcls</code>。</p><h3 id="ISA-方法"><a href="#ISA-方法" class="headerlink" title="ISA() 方法"></a><a id="ISA()"></a>ISA() 方法</h3><p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code>ISA()</code> 来返回类指针。</p><p>其中 <code>ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK 0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">Class</span> </span></span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="class"><span class="keyword">Class</span>)(<span class="title">isa</span>.<span class="title">bits</span> &amp; <span class="title">ISA_MASK</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h3><p>在 <code>isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p><ul><li><code>has_assoc</code><ul><li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li></ul></li><li><code>weakly_referenced</code><ul><li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li></ul></li><li><code>deallocating</code><ul><li>对象正在释放内存</li></ul></li><li><code>has_sidetable_rc</code><ul><li>对象的引用计数太大了，存不下</li></ul></li><li><code>extra_rc</code><ul><li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code>extra_rc</code> 的值就为 9</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="arm64-架构中的-isa-t-结构体"><a href="#arm64-架构中的-isa-t-结构体" class="headerlink" title="arm64 架构中的 isa_t 结构体"></a><a id="arm64"></a>arm64 架构中的 <code>isa_t</code> 结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>对象： 含有isa指针的结构都是对象，包括类，实例。</li><li>isa指针的作用之一，统一类方法和实例方法的调用机制</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a></li><li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></li><li><a href="http://stackoverflow.com/questions/18997362/storing-things-in-isa" rel="external nofollow noopener noreferrer" target="_blank">Storing things in isa</a></li><li><a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">Why do we need C Unions?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Non-pointer_isa</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></li><li><a href="http://blog.xcodev.com/posts/tagged-pointer-and-64-bit/" rel="external nofollow noopener noreferrer" target="_blank">64位与Tagged Pointer</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="isa" scheme="http://yoursite.com/tags/isa/"/>
    
  </entry>
  
  <entry>
    <title>0. 参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/0_refer/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/0_refer/</id>
    <published>2018-10-31T16:38:11.000Z</published>
    <updated>2018-11-26T10:12:35.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.jianshu.com/p/9e0fc8295c4b" rel="external nofollow noopener noreferrer" target="_blank">Xcode 10 下如何调试objc4-723</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Draveness/analyze&quot; rel=&quot;exte
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>关键字使用的位置</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E9%99%84%E5%BD%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/附录/关键字使用的位置/</id>
    <published>2018-09-20T04:07:12.000Z</published>
    <updated>2018-09-20T07:30:27.282Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static</td><td>static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中</td></tr><tr><td>explicit</td><td>explicit只对一个实参的构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外定义时不应该重复使用</td></tr><tr><td>=default</td><td>当我们在类内用=default修饰成员声明时，合成的函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default</td></tr><tr><td>=delete</td><td>必须出现在函数第一次声明的时候</td></tr><tr><td>virtual</td><td>只能出现在类内部的声明语句中之前，不能用于类外部的函数定义</td></tr><tr><td>override</td><td></td></tr><tr><td>final</td><td>类的名字后面，防止继承</td></tr><tr><td>=0</td><td>只能出现在类内部的虚函数声明语句处</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中&lt;/td&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="附录" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E9%99%84%E5%BD%95/"/>
    
    
      <category term="关键字使用的位置" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>动态内存</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/</id>
    <published>2018-09-13T04:07:12.000Z</published>
    <updated>2018-09-14T10:58:46.479Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>动态内存和智能指针</li><li>动态数组</li></ol><a id="more"></a><p>到目前为止，我们程序只使用静态内存和栈内存，静态内存用来保存局部static对象、类static成员、以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁，对于栈对象，仅在其定义的程序块运行时才存在。static对象在使用前分配，在程序结束是销毁。</p><h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>shareed_ptr允许多个指针指向同一个对象；unique_ptr则独占所指的对象。weak_ptr伴随类。</p><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板，当我们创建一个智能指针时，必须提供额外的信息–指针指向的类型。</p><table><thead><tr><th>shared_ptr和unique_ptr都支持的操作</th><th>说明</th></tr></thead><tbody><tr><td>shared_ptr<t> sp  unique_ptr<t> up</t></t></td><td>空智能指针，可以指向类型为T的对象</td></tr><tr><td>p</td><td>将p作为一个条件判断，若p指向一个对象，则为true</td></tr><tr><td>*p</td><td>解引用p，获取它指向的对象</td></tr><tr><td>p-&gt;mem</td><td>等价于(*p)-&gt;mem</td></tr><tr><td>p.get</td><td>返回p中保存的指针，若智能指针释放了其对象，返回的指针所指的对象也消失了</td></tr><tr><td>swap(p,q)</td><td>交换pq中的指针</td></tr><tr><td>p.swap(q)</td></tr></tbody></table><table><thead><tr><th></th><th>share_ptr独有的操作</th></tr></thead><tbody><tr><td>make_shared<t>(args)</t></td><td>返回一个shared_ptr，指向动态分配的类型为T的对象，使用args初始化对象</td></tr><tr><td>shared_ptr<t>p(q)</t></td><td>p 是shared_ptr q的拷贝，此操作会递q中的计算器q中的指针必须能转换为T*</td></tr><tr><td>p = q</td><td>pq 都是shared_ptr，所保存的指针必须能相互转化，次操作会递减p的引用计数器，递增q的引用计数器，若p的引用计数器为0，则将其管理的源内存释放</td></tr><tr><td>p.unique()</td><td>若p.user_count为1，返回true，否则，返回false</td></tr><tr><td>p.use_count()</td><td>返回与p共享对象的智能指针数量，可能很慢，组要用于调试</td></tr></tbody></table><ol><li>shared_ptr的拷贝和赋值</li><li>shared_ptr自动销毁所管理的对象</li></ol><p>使用动态内存处于以下三个原因：</p><ol><li>程序不知道自己需要使用多少对象，典型例子，容器</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间空闲数据</li></ol><p>一般而言，如果。两个对象共享底层的数据，当讴歌对象被销毁时，我们不能单方面的销毁底层数据。</p><p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>使用new动态分配和初始化对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，动态分配的对象是默认初始化的，这意味着，内置类型、组合类型的对象是未定义的，而类类型的对象使用默认构造函数进行初始化。</p><p>我们可以使用直接初始化方式来初始化一个动态分配的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>);</span><br></pre></td></tr></table></figure><p>也可以对动态分配的对象进行值初始化，只需要要类型名后跟一对圆括号即可。</p><p>对于定义了自己的构造函数的类类型来说，不论是值初始化还是默认初始化，都是使用默认构造函数，</p><p>但是对于内置类型来说，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的对象的值是未定义的。</p><p>动态分配的const对象：使用new分配const对象是合法的。一个动态分配的const对象必须初始化。</p><p>内存耗尽： 这里讲了定位new</p><p>delete之后重置指针：在delete之后，指针就变成了人们所说的空悬指针（danglind pointer）。</p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是explicit的，因此，我们将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式来初始化一个智能指针。</p><p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放她所关联的对象。</p><table><thead><tr><th></th><th>定义和改变shared_ptr的其他方法</th></tr></thead><tbody><tr><td>shared_ptr<t>p(q)</t></td><td>p管理内置指针q所指向的对象，q必须指向new分配的内存，且能转化为T*类型</td></tr><tr><td>shared_ptr<t>p(u)</t></td><td>p从unique_ptr哪里接管了对象的所有权，将U置位空</td></tr><tr><td>shared_pte<t>p(q,d)</t></td><td>p接管了内置指针q所指向的对象的所有权，p将使用可调用对象d来代替delete</td></tr><tr><td>shared_ptr<t>p(p2,d)</t></td><td>p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td></tr><tr><td>p.reset()</td><td>若p是唯一指向其对象的shared_ptr，reset将会是否次对象。</td></tr><tr><td>p.reset(q)</td><td>若传递了可选的参数内置指针q，会令p指向q，负责会将p置位空</td></tr><tr><td>p.reset(q,d)</td><td>若还传递了参数d，将会调用d而不是delete来是否q</td></tr></tbody></table><h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>智能指针使用规范</p><ol><li>不能使用相同的内置指针初始化多个智能指针</li><li>不delete get()返回的指针</li><li>不适用get() 初始化或者reset另一个智能指针</li><li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效的指针了。</li><li>如果使用智能指针管理的资源不是new分配的内存，记住传递一个删除器。</li></ol><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象。</p><table><thead><tr><th>unique_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>unique_ptr<t> u1</t></td><td>空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放他的指针，u2 会使用一个类型为D的可调用对象来释放他的指针</td></tr><tr><td>unique_ptr<t,d> u2</t,d></td><td></td></tr><tr><td>unique_ptr<t,d>u(d)</t,d></td><td>空的unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td></tr><tr><td>u = nullptr</td><td>释放u所指的对象，将u置位空</td></tr><tr><td>u.release()</td><td>u放弃对指针的控制权，返回指针，并将u置为空</td></tr><tr><td>u.reset()</td><td>释放u指向的对象</td></tr><tr><td>u.reset(q)</td><td>如果提供了内置指针q，令u指向这个对象，否则u置为空</td></tr><tr><td>u.reset(nullptr)</td></tr></tbody></table><p>传递unique_ptr参数和返回unique_ptr： 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或者赋值一个将要被销毁的unique_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象声明周期的指针。它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数器。</p><table><thead><tr><th>weak_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>weak_ptr<t> w</t></td><td>空的weak_ptr，可以指向类型为T的对象</td></tr><tr><td>weak_ptr<t> w(sp)</t></td><td>与shared_ptr sp指向相同对象的weak_ptr，T必须能转化为sp指向的类型</td></tr><tr><td>w = p</td><td>p 可以是一个shared_ptr 或一个weak_ptr。赋值后，w与p共享对象</td></tr><tr><td>w.reset()</td><td>将w置位空</td></tr><tr><td>w.use_count()</td><td>与w共享对象的shared_ptr的数量</td></tr><tr><td>w.expired()</td><td>若w.use_count()为0，返回true，否则返回false</td></tr><tr><td>w.lock()</td><td>如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++语言和标准库提供了一次分配一个对象数组的方法，C++中定义了另一种new表达式，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。</p><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>分配一个数组得到一个元素类型的指针：  由于分配的内存不是一个数组类型，因此不能对数组调用begin和end  ，我们必须记住，动态数组并不是数组类型。</p><p>初始化动态分配数组：默认情况下使用默认初始化，可以使用圆括号进行值初始化。</p><h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态内存和智能指针&lt;/li&gt;
&lt;li&gt;动态数组&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十二章 动态内存" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
    
      <category term="动态内存" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>泛型算法</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/</id>
    <published>2018-09-12T04:07:12.000Z</published>
    <updated>2018-09-14T02:21:25.708Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>概述</li><li>初始泛型算法</li><li>定制操作</li><li>再探迭代器</li><li>泛型算法结构</li><li>特定容器算法</li></ol><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p><p>算法永远不会执行容器操作：泛型算法本身不执行容器操作，他们只会运行于迭代器之上，执行迭代器的操作。这个特性带来一个非常惊人的编程假定：算法永远不会改变容器的大小。算法可能改变容器中元素的内容，可能在容器内移动元素，但永远不会添加或者删除元素。标准库定义定义了特殊的迭代器，插入迭代器。当算法操作这样的迭代器时迭代器可以完成向容器添加元素的效果，但算法永远不会做这种操作。</p><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>find accumulate equal  </p><p>除了少数算法外，标准库算法都对一个范围内的元素进行操作。我们将此元素的范围称为输入范围。接收输入范围的算法总是使用前两个参数来表示范围。两个参数分别表示第一个要处理的元素、尾元素之后位置的迭代器。</p><p>那些只接收一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p><h3 id="写容器元素算法"><a href="#写容器元素算法" class="headerlink" title="写容器元素算法"></a>写容器元素算法</h3><p>fill copy back_inserter replace_copy</p><h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词：是一个可调用表达式，其返回结果是一个能用作条件的值。</p><p>一元谓词：接受单一参数<br>二元谓词：接受两个参数</p><p>stable_sort算法：维持相等元素的原有顺序</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>find_if算法对输入序列中的每个元素调用这个谓词，它返回第一个使谓词返回非0的元素，如果不存在这样的元素，则返回尾迭代器。</p><p>可调用对象（cllable object）。对于一个对象或者一个表达式，如果可以对其使用调用运算符，则它为可调用对象。</p><p>可调用对象：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda表达式</li></ol><p>可调用对象可以理解为是一个未命名的内联函数</p><p>一个lambda表达式具有一个返回类型、一个参数列表、一个函数体，单与函数不同，lambda表达式可以定义在函数内部，一个lambda表达式的一般形式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">capture list</span>](<span class="link">parameter list</span>)-&gt; return type &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>与普通函数不同，lambda表达式使用尾置返回指定返回类型。</p><p>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。如果忽略返回类型，lambda根据函数体重的代码推断出返回类型。</p><p>与普通函数不同，lambda不能有默认实参。</p><p>一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些局部变量。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p><p>for_each算法接受一个可调用对象，并对输入序列中每个元素调用次对象。</p><p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量、它所在函数之外声明的名字。</p><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当向一个函数传递一个lambda时，同时定义了一个类型和该类型的对象：类似的，当使用auto定义一个用lambda初始化变量时，定义了一个从lambda生产的类型的对象。</p><p>值捕获：与参数不同，被捕获的变量的值在lambda创建时拷贝。而不是调用时拷贝。</p><p>引用捕获：必须确保被引用的对象在lambda执行的时候是存在的。</p><p>隐式捕获： &amp;搞事编译器采用引用捕获，=告诉编译器使用值捕获。混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是&amp;或者=。</p><p>可变lambda：默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变一个被捕获的变量的值。就必须在参数列表首加上关键字mutable。</p><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>bind标准函数 定义在functional中，可以将bind函数看做一个通用的函数适配器，他接受一个可调用对象，生成一个新的可调用对象来适应原来对象的参数。</p><p>bind的一般形式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto newCallable</span> = bind(callable,arglist);</span><br></pre></td></tr></table></figure><p>使用placeholders名字</p><p>_n定义在一个名为placeholders的命名空间。而这个命名空间定义在std命名空间中。</p><h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><ol><li>插入迭代器</li><li>流迭代器</li><li>反向迭代器</li><li>移动迭代器</li></ol><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>接受一个容器，生成一个迭代器，他实现向容器添加元素。当我们通过一个插入迭代器进行赋值时，改迭代器调用容器操作来向给定容器指定的位置插入一个元素。</p><ol><li>back_inserter</li><li>front_inserter</li><li>inserter</li></ol><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="5种迭代器"><a href="#5种迭代器" class="headerlink" title="5种迭代器"></a>5种迭代器</h3><ol><li>输入迭代器</li><li>输出迭代器</li><li>前向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li></ol><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;初始泛型算法&lt;/li&gt;
&lt;li&gt;定制操作&lt;/li&gt;
&lt;li&gt;再探迭代器&lt;/li&gt;
&lt;li&gt;泛型算法结构&lt;/li&gt;
&lt;li&gt;特定容器算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十章 泛型算法" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="泛型算法" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>空间配置器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第二章/空间配置器/</id>
    <published>2018-08-29T04:07:12.000Z</published>
    <updated>2018-08-30T04:02:17.349Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>空间配置器的标准接口</li><li>具备次配置能力的SGI 空间配置器</li><li>内存基本处理工具</li></ol><a id="more"></a><h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocator::</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间配置器的标准接口&lt;/li&gt;
&lt;li&gt;具备次配置能力的SGI 空间配置器&lt;/li&gt;
&lt;li&gt;内存基本处理工具&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第二章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
    
      <category term="空间配置器" scheme="http://yoursite.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>deque</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/deque/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第四章/deque/</id>
    <published>2018-08-28T04:07:12.000Z</published>
    <updated>2018-08-29T09:15:28.164Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>deque 概述</li><li>deque中控器</li><li>deque的迭代器</li><li>deque的数据结构</li><li>deque的构造与内存管理</li><li>deque的元素操作</li></ol><a id="more"></a><h2 id="deque-概述"><a href="#deque-概述" class="headerlink" title="deque 概述"></a>deque 概述</h2><p>vector是单向开口的连续性空间，deque则是一种双向开口的连续性空间，所谓双向开口，意思是头尾两端分别做元素的插入和删除操作.</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque1.png" alt="deque示意"></p><p>deque和vector的最大差异，一、在于deque允许常数时间内对起始头端进行元素的插入或移除操作。二、deque没有容量的概念，因为他是动态的以分段连续空间组合而成，随时可以增加一段空间并连接起来。换句话说，像vector那样“因旧空间不足而重新分配一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留功能。</p><p>虽然，deque也提供了random access iterator，但他的迭代器并不是普通指针。其复杂度和vector不可以道里计，这当然影响了各个运算层面，因此，除非必要，我们应该尽可能选择vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector身上，将vector排序后，再复制回deque。</p><h2 id="deque中控器"><a href="#deque中控器" class="headerlink" title="deque中控器"></a>deque中控器</h2><p>deque是连续空间（至少逻辑上看如此），连续线性空间总令我们联想到array和vector。array无法生长，vector虽可以生长，却只能向尾端成长。而且其所为成长是个假象，事实上是：</p><ol><li>另觅更大空间</li><li>将原数据赋值过去</li><li>释放原空间</li></ol><p>如果不是vector每次配置新空间时留下一些富裕，其成长假象所带来的代价相当昂贵。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在前端或者尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复制的带带器框架。</p><p>收到分段连续性空间的字面影响，我们可能以为，deque的实现复杂度和vector相比，虽不中亦不远矣，其实不然。主要以为，即曰分段连续线性空间，就必须有中央控制，为了维持整体连续的假象，数据结构的设计及迭代器前进后退操作都颇为繁琐。deque的实现代码分量远比vector或list多得多。</p><p>deque采用一块所谓map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处层位一个节点，node）都是指针，指向另一段较大的连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL 允许我们制定缓存区的大小，默认是0，表示将使用512bytes缓存区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">///元素的指针的指针</span></span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">map_poiner <span class="built_in">map</span>;<span class="comment">//指向map，map是快连续空间，其内的每个元素都是一个指针，指向一块缓存区</span></span><br><span class="line">size_type map_size; <span class="comment">//map内可容纳多少指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人头皮发麻的各种类型整理下，我们可发现，map其实是一个T**，也就是说他是一个指针，所指之物又是一个指针，指向类型为T的空间，如下图所示：</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque2.png" alt="deque的结构设计中，map和node-buffer的关系"></p><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><p>deque的分段连续空间，维持其“整体连续”假象的任务，落在了迭代器operator++、 operator– 两个运算子身上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;deque 概述&lt;/li&gt;
&lt;li&gt;deque中控器&lt;/li&gt;
&lt;li&gt;deque的迭代器&lt;/li&gt;
&lt;li&gt;deque的数据结构&lt;/li&gt;
&lt;li&gt;deque的构造与内存管理&lt;/li&gt;
&lt;li&gt;deque的元素操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第四章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>顺序容器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/</id>
    <published>2018-08-27T10:07:12.000Z</published>
    <updated>2018-09-11T11:15:46.987Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li>vector对象是如何生长的</li><li>额外的string操作</li><li>容器适配器</li></ol><a id="more"></a><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>容器在以下方面都有不同的性能折中：</p><ol><li>向容器添加或者删除元素的代价</li><li>非顺序访问容器中元素的代价</li></ol><table><thead><tr><th>容器类型</th><th>性能</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列，支持快速随机访问，在头尾位置插入、删除速度快</td></tr><tr><td>list</td><td>双向链表，只支持双向顺序访问，在list中任何位置插入、删除操作熟读都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问，在链表任何位置插入、删除操作都非常快</td></tr><tr><td>array</td><td>固定大小数组，支持快速随机访问，不能添加或删除元素</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入、删除快</td></tr></tbody></table><p>string、vector将元素保存在连续的内存空间，由于元素是连续存储的，由元素的下标计算其地址非常快。</p><p>list、forword_list两个容器的设计目的是令容器容器的任何位置添加、删除操作都很快</p><h2 id="容器概览"><a href="#容器概览" class="headerlink" title="容器概览"></a>容器概览</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不适用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>forword list 不支持递减运算符</p><p>迭代器范围中的元素包括first所表示的元素以及从first开始，直至last（但不包括last）之间的所有元素，左闭合区间。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">begin</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>使用左闭合范围蕴含的编程假定</p><ol><li>如果begin和end相等，则范围为空</li><li>如果begin和end不相等，则范围至少包含一个元素，且begin指向范围中的第一个元素</li><li>我们可以对begin递增若干次，使得begin==end</li></ol><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;<span class="string">""</span>iterator iter;</span><br></pre></td></tr></table></figure><h3 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h3><p> begin和end操作生成指向容器中第一个元素和尾元素之后的迭代器。</p><h3 id="容器的定义和初始化"><a href="#容器的定义和初始化" class="headerlink" title="容器的定义和初始化"></a>容器的定义和初始化</h3><table><thead><tr><th>容器的定义和初始哈</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数，如果C是一个array，则c中元素默认初始化，否则c为空</td></tr><tr><td>C  c1()c2 C c1 = c2</td><td>c1初始化为c2的拷贝，c1和c2必须类型相同,对于arrary，大小相同</td></tr><tr><td>C c{a,b,c,…} C c = {a,b,c,…}</td><td>c初始化为初始化列表中元素的拷贝</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b，e指定范围中的元素的拷贝</td></tr><tr><td>C seq(n) C seq(n,t)</td><td>seq 包含n个元素，这些元素进行了值初始化，此构造函数是explicit的</td></tr></tbody></table><p>容器的拷贝： 两种方式</p><ol><li>直接拷贝整个容器</li><li><p>拷贝迭代器指定的元素范围</p><p>当将一个容器初始化为另一个容器的拷贝时，两个容器类型和元素类型必须相同。</p><p>列表初始化：对于除了array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。</p><p>标准库array具有固定大小：标准库array的大小是类型的一部分，  array与内置数组的区别：array可以进行拷贝和对象赋值。</p><h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p>赋值运算符将其左边容器中全部元素替换为右边容器中元素的拷贝。</p><h3 id="容器的大小操作"><a href="#容器的大小操作" class="headerlink" title="容器的大小操作"></a>容器的大小操作</h3></li><li><p>size</p></li><li>empty</li><li><p>max_size</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>只有当其元素的类型定义了关系运算符，我们才可以使用关系运算符比较容器</p><h2 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>|操作|说明|<br>|—|—|<br>|这些操作不支持会改版容器的大小，array不支持这些操作||<br>|forward_list有专有版本的insert和emplace||<br>|forward_list不支持push_back和emplace_back，由于没有位指针，算法复杂度是o(n)||<br>|vector和string不支持push_font和emplace_font，也是算法复杂度的原因，整个元素需要移动，单可以通过inser做到||<br>|c.push_back(t)|在C的尾部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_back(args)||<br>|||<br>|c.push_font(t)|在C的首部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_font(args)||<br>|||<br>|c.insert(p,t)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素，  <font color="blue">前插</font>|<br>|c.emplace(p,args)||<br>|||<br>|c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，若n为0，则指向p|<br>|c.insert(p,b,e)|将迭代器b，e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器|<br>|c.insert(p,il)|il是花括号包围的元素值列表|<br>|向一个vector、string、deque插入元素，会使所有指向容器的迭代器、引用、指针失效|</p><p>使用push_back：除了array、forward_list之外，每个顺序容器都支持push_back。</p><p>当我们用一个对象初始化容器时，或将一个对象插入到容器中，实际上，放入到容器中的是对象的一个拷贝，二不是对象本身。</p><p>使用push_font：和vector一样，在deque首位之外的位置插入元素会很耗时。</p><p>在容器中的特定位置插入元素：insert提供了更一般的功能，它允许在容器中的任何位置插入0个或者多个元素。每个insert函数，都接受一个迭代器作为其第一个参数，迭代器指出了在容器的什么位置插入元素。</p><p>为什么是前插：因为迭代器可能只需容器外部之后不存在的元素的位置，所以只能前插。另外，在容器开始位置插入元素是很有用的功能。</p><p>我们可以使用insert将元素插入容器的开始位置，不用担心是否支持push_font。</p><p>如果我们传递给insert一对迭代器，他们不能指向添加元素的目标容器。</p><p>使用insert的返回值：通过使用insert的返回值，可以在容器中的一个特定位置反复插入元素。</p><p>emplace操作：新标准引入了三个成员：emplace、emplace_font 、emplace_back，这些操作构造而不是拷贝元素。</p><p>emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括array在内的所有容器都有一个font函数，而除了forword_list之外的所有容器都有一个back成员函数。这两个成员函数分别返回首元素和尾元素的索引。</p><p>|容器的访问操作|说明|<br>|—|—|<br>||at和下标操作只使用于string、vector、deque、和array|<br>||back不适用forward_list，算法复杂度的问题|<br>|c.back()|返回c的尾元素的引用|<br>|c.font()|返回c的首元素的引用|<br>|c[n]|返回c中下表为n的元素的引用|<br>|c.at(n)|返回下标为n的元素的引用。|</p></li></ol><p> 提供快速随机访问的容器（string、vector、deque、array）都提供下标运算符</p><p> at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range的异常。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table><thead><tr><th>删除操作</th><th>说明</th></tr></thead><tbody><tr><td></td><td>这些操作会给变容器的大小，不适用于array</td></tr><tr><td></td><td>forward_list有特殊版本的erase</td></tr><tr><td></td><td>forward_list不支持pop_back，string、vector不支持pop_font</td></tr><tr><td>c.pop_font()</td><td>删除c中的首元素</td></tr><tr><td>c.pop_back()</td><td>删除c中的尾元素</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器be所指范围内的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素</td></tr></tbody></table><p>###特殊的forward_list操作</p><p>特殊操作的原因：删除或者插入操作，我们需要访问它的前驱，以便改变前驱的链接，但是forward_list中，没有简单的方法获取一个元素的前驱。forward_list定义了insert_after、emplace_after、erase_after操作。before_begain，返回一个首前。</p><p>|forward_list操作|说明|<br>|lst.before_begain()|返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用|<br>|lst.cbefore_begain()||<br>|lst.insert_after(p,t)|在迭代器之后插入一个元素|<br>|lst.insert_after(p,n,t)||<br>|lst.insert_after(p,b,e)||<br>|lst.insert_after(p,il)||<br>|emplace_after(p,args)||<br>|lst.erase_after(p)||<br>|lst.erase_after(b,e)||</p><h3 id="改变容器的大小"><a href="#改变容器的大小" class="headerlink" title="改变容器的大小"></a>改变容器的大小</h3><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><h2 id="vector对象是如何生长的"><a href="#vector对象是如何生长的" class="headerlink" title="vector对象是如何生长的"></a>vector对象是如何生长的</h2><p> |容器大小操作|说明|<br> ||shrink_to_fit 只适用于vector、string、deque|<br> ||capacity和reserve只适用于vector、string|<br> |c.shrink_to_fit|请将capacity（）减少为size相同大小|<br> |c.capacity()|不重新分配内存空间的话，c可以保存多少元素|<br> |c.reserve（）|分配至少容纳那n个元素的内存空间|</p><h2 id="额为的string操作"><a href="#额为的string操作" class="headerlink" title="额为的string操作"></a>额为的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>说明</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标POS2开始的字符的拷贝，若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;vector对象是如何生长的&lt;/li&gt;
&lt;li&gt;额外的string操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第九章顺序容器" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="顺序容器" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO库</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/IO%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第八章io库/IO库/</id>
    <published>2018-08-27T04:07:12.000Z</published>
    <updated>2018-08-27T10:51:38.547Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>IO类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>进行IO操作的函数通常以引用方式传递、返回流。读写一个IO对象会改变其状态，因此，传递和返回的引用不能是const的。</p><h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>strm::iostate</td><td>strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td></tr><tr><td>strm::badbit</td><td>指出输出流已崩溃</td></tr><tr><td>strm::faillbit</td><td>一个IO操作失败</td></tr><tr><td>strm::eofbit</td><td>流达到了文件结尾</td></tr><tr><td>strm::goodbit</td><td>流未处于错误状态，此值保证为0</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若流s的failbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若流s的badbit置位，则返回true</td></tr><tr><td>s.good()</td><td>若流处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流的所有状态复位</td></tr><tr><td>s.clear(flags)</td><td>根据给定的flags标志位，将流s中对应的条件状态位复位</td></tr><tr><td>s.setstate(flags)将流s中对应条件状态位置位</td><td></td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态</td></tr></tbody></table><p>一个流一旦发生错误状态，其后续的IO操作都失败。只有流处于无错状态是，我们才可以从它读取数据、写入数据。</p><p>属性缓存区：</p><ol><li>endl， 换行并刷新缓冲区</li><li>flush ，刷新缓存区，不输出任何额为的字符</li><li>ends，向缓冲区插入一个空字符，然后刷新缓冲区</li></ol><p>unitbuf 操纵符：如果每次输出操作后，都属性缓存区，我们可以使用unitbuf操纵符。</p><p>如果程序崩溃，输出缓冲区不会被刷新。</p><p>tie： 如果本对象关联到一个输出流，则返回的就是这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>fstream fstrm</td><td>创建一个未绑定的文件流</td></tr><tr><td>fstream fstrm(s)</td><td>创建一个fstream，并打开名为s的文件。 s可以是string类型，或者是一个指向C风格字符串类型</td></tr><tr><td>fstream fstrm(s,mode)</td><td>安装mode打开文件</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定，返回void</td></tr><tr><td>fstrm.close()</td><td>关闭于fstrm绑定的文件，返回void</td></tr><tr><td>fstrm.is_open</td><td>返回一个bool，指出与fstrm关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>创建文件流对象时，我们可以提供文件名，如果提供了一个文件名，则open自动被调用。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><table><thead><tr><th>文件模式</th><th>说明</th></tr></thead><tbody><tr><td>in</td><td>以读方式打开</td></tr><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次写操作前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后，立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><h2 id="stirng流"><a href="#stirng流" class="headerlink" title="stirng流"></a>stirng流</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>sstream strm</td><td>strm是未绑定的stringstream对象</td></tr><tr><td>sstram strm(s)</td><td>strm 是一个sstream对象，保存string的一个拷贝，此构造函数是explicit的</td></tr><tr><td>strm.str()</td><td>返回strm中保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s 拷贝到strm中，返回void</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第八章io库" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/"/>
    
    
      <category term="IO库" scheme="http://yoursite.com/tags/IO%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>What’s New in User Notifications</title>
    <link href="http://yoursite.com/wiki/WWDC/What%E2%80%99s%20New%20in%20User%20Notifications/"/>
    <id>http://yoursite.com/wiki/WWDC/What’s New in User Notifications/</id>
    <published>2018-08-23T04:07:12.000Z</published>
    <updated>2018-09-12T05:53:35.631Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.<br>下午好，欢迎大家来这个叫做what’s new in user notifications的session </p><a id="more"></a><p>So there’s a range of topics to be covered today, and let’s begin with looking at grouped notifications. Now up to iOS 11, all new incoming notifications for the users were inserted in a chronological order in the notification list.<br>So these would be interspersed across multiple applications, and it would be hard for the user to find a certain notification or triage multiple notifications together.<br>So starting in iOS 12, we’ve decided to improve this by introducing notification grouping, so now, as you can see here, all notifications across different applications get grouped into their unique groups. Let’s take a deeper look at how grouped notifications works. Now all these notifications will be automatically grouped, so there’s nothing explicit that you need to do to start using notification grouping.<br>However, if you do want to have your own custom groups then you can use the thread identifier, which is an existing property on the UN notification content object.<br>So some of you might already be using the thread identifier and for a local notification.<br>You can set it on the UNMutableNotificationContent object as seen here.<br>And for a remote notification payload, you can also include it as part of your notification payload. Now the thread identifier might be familiar to some of you already. We use it today for forwarding notifications to a notification content extension that is presented for your application, which has the exact same thread identifier, allowing the content extension view to update it based on the new incoming notification. Starting in iOS 11, we started using the thread identifier for doing grouping of notifications, if the user had turned on [inaudible] notification previous. So we’re just taking this concept and expanding it for all notifications in general. So how does this grouping work? So when a new notification comes in to you, the user’s device, if there is no thread identifier set on this notification, then this notifications gets grouped with the application bundle. We can see that from our sample application here, that as new notifications are incoming, they are getting bundled with the same group and the group is getting updated with the latest content.<br>And then the user can simply expand this notification group to see all the notifications that are present in that group. On the other hand, if the notification does have a thread identifier set on it, then it gets grouped with all the other notifications from that same application with that exact same thread ID. What this also means is that the same application can then have multiple different custom groups, depending upon the unique thread identifiers that you’re setting on them. A good example of this is the messages application, where here you can see there are two different threads, and as new notifications are incoming, they are going to their own respective groups.<br>And then the user can expand a specific group to see all the notifications that are part of that group. So by using the thread identifier, messages is able to do so. Now, your application users also have the option of tweaking this notification grouping setting from your per application notification setting’s page.<br>Here, they get three options. If they choose automatic, then they get the behavior that we just described. However, the user also has the option of just grouping by application, where the system will ignore your thread identifier and group all notifications into a single group. And if the user wants the same behavior as it exists in iOS 11 today, then they can simply turn off grouping for your applications’ notifications. So do keep this in mind when you’re creating your own custom groups that they create enough value for users when they receive your applications’ notifications. Now what are the different components of a notification group? The content that we show is for the latest notification that was received as part of that group. And then the user can simply see all the notifications by tapping on this group, and we expand all the notifications’ content. And then the user can interact with all these notifications individually as well. The two buttons at the top give the users much greater control like collapsing the stack as well as clearing all these notifications together. Now, notification grouping also makes triaging of notifications much better. For example, in this case, the user can clear all these notifications together by simply swiping to the right and tapping clear all.<br>Apart from the content of the notification group, we also show a summary text.<br>Now, this summary text, by default, shows the count of all the notifications that are part of that group. However, you can also create a custom summary text so you can give your users much better context of what kind of information is included in that group. Now, we will cover this API and go over much larger use cases of how you can create your custom groups in the advanced session around using group notifications, which will follow this session. So let’s do a quick summary of group notifications as we saw them today. Starting in iOS 12, all application notifications are going to be grouped automatically.<br>You can start using the thread identifier if you want to create your own custom groups for your applications, but the user does have the option of changing this grouping setting for your applications’ notifications. And lastly, you can use the summary text for customizing the information you want to provide the user around the notification groups that you’re creating.<br>All right, so that was group notifications. Now, let’s move on to the next topic and talk about notification content extensions. Now, some of you might already be familiar with these content extensions that we included with iOS 10.<br>Content extensions allow your applications to present a rich notification view around the user’s notifications, so you can have a much more customized and interactive interface for the notification that the user is seeing. Let’s do a quick recap of setting up these content extensions. Xcode gives you a standard template to add a target for the content extensions to your applications and once you set that up, we create a default class for the notification view controller, which implements the UNNotificationContentExtension protocol. Here, the did receive notification method is important because this is your entry point for setting up the view associated with the content extension, and you can use the notification object past here to get all the information around that notification to set up your custom view.<br>The info.plist file associated with your content extension gives you more options.<br>The important thing here is the category identifier. Now, this identifier needs to match the same category identifier you’re setting on your notification requests because that’s how the system knows which content extension to launch with which notification.<br>Along with this, you can do some quick configurations of your content extension such as setting the initial content size ratio, hiding the default content, as well as overriding the title of this content extension. Now, the primary way in which your users interact with these content extensions is through notification actions, and these actions are presented right below the content of the content extension.<br>Let’s summarize how we can set up these actions as well. So doing so is fairly trivial in code. For example, here, we have two actions here for like and comment, and we create a simple UNNotificationAction for like and a text input action for commenting. And once we’ve created these actions, we create a new category giving it the same identifier as the content extension where we want these actions to be presented. And then, we pass it, the two new actions that we created.<br>Once we’ve set up this category, then we call setNotificationCategories on the UNNotificationCenter object associated with our class, giving it the new category that we created. So by simply doing so, the next time when the user goes to your content extension we can see that these actions are now available for them to interact with your notification content. Now let’s take a look at how we can handle the responses from these actions. There are two ways to do that. Firstly, you can handle this response in the AppDelegate that is associated with your application that implements the UNUserNotificationCenter Delegate protocol. Here, the function UserNotificationCenter did receive response, includes the response object which includes information about the request, the notification request from which the user took this action.<br>However, the content extension also allows you to intercept this action response so that you can update your view and make a much more interactive and dynamic experience for users for the content extension. So for our sample here, we enter the did receive response method and checked the action identifier for the like action. And then we update our UI with the new label as well as update our application state. Finally calling the completion block we do not dismiss. If you do want to dismiss your content extension view here, then you can simply change the parameter you’re passing to the completion block to dismiss or dismiss and forward, where we will forward this response to your AppDelegate function as well. All right, so now that we set this up, we can see that when the user takes the like action, the content extension content gets updated right there and then. So it’s a much more interactive experience for your user and they’re getting real-time feedback. However, if you look at the current state of the content extension, we see that there is some redundant information.<br>The user has already taken the like action, so having the action there doesn’t really serve a purpose anymore. Now notification actions, in general, have certain limitations. They are not very dynamic and can’t be updated based on the context of your content extensions. Also, these tend to be tied to the notification categories that you have to define at the time of your application setup.<br>So we wanted to address these issues and we have introduced a new API around notification actions, where now we’re exposing these notification actions as part of the NSExtensionContext tied to your content extension. What this API allows you to do is access the currently presented notification actions to the user as well as replace these actions by setting a brand new array of notification actions for your content extension. So going back to our sample, what if after the user took the like action we wanted to replace it say with the unlike action so that they can do the reverse of the action they just took? So using this new API, let’s take a look of how we can set this up. So we go back to our did receive response method and again identify the like action and update our application state. This time, we also create a new action for unlike, giving it a unique identifier as well as a title.<br>We can also take a look at the currently presented actions so that we can extract the comment action from there without having to create it again. Then we create a new array of these new actions that we’ve created and simply set that on the notification actions variable. So once we’ve done this and the user takes the like action, then the UI will automatically update to show them the new action, and then the user can then toggle between the two actions, depending upon how you handle that state in your content extensions. Now, this API can be used in multiple other ways as well.<br>For example, now you can set your actions at the time you’re setting up your content extension view in the did receive notification method. What this means is your notification requests are no longer tied to the category to define the actions that you want to present around these notifications. You can also now present a secondary set of actions by replacing the currently presented actions.<br>For example, if the leading action was rate, then you can provide a secondary list of the different types of ratings that you want your user to take. And you can also remove all these notification actions if you feel it does not make sense anymore for your content extension to present these actions. So that’s the new API around notification actions. And we feel this will really help you enhance the experience that your users have around your content extensions with the different actions now you can present to them. Let’s move on and talk about user interaction with these content extensions. Now notification actions were important up till this point because till iOS 11 we did not allow user interaction touches with your content extension view. Now we received a lot of feedback around this.<br>And I’m happy to announce that we’re taking away this restriction with iOS 12.<br>So now your content extensions have the option of opting in to receiving user interaction [inaudible] touches, and setting this up, it’s fairly trivial.<br>All you have to do is add a new key value option to your info.plist file.<br>And the key that we’ve added is the UNNotificationExtensionUser InteractionEnabled.<br>So going back to our sample, what if we want to remove the like action from a notification action and make it a UI interaction touch that’s part of the view itself? So once we’ve configured our info.plist file, we can go back to our content extension view and create our own custom button to handle the like gesture. We add a target for our own private method and inside that function, we update the UI as well as update our application state. So here, it’s important that since you’re implementing your own user interactions that you are responsible for handling all these actions, responses, and callbacks from the users yourself. So once we’ve set this up, now when the user goes to your content extension we see the Like button, part of the UI itself, and the user can simply interact with that button right there and then.<br>So that’s the new functionality that we’ve added around content extensions.<br>And coupled with notification actions, along with user interaction touches, you now have a much richer set of tools for creating much more interactive and dynamic content extension experiences for your applications notifications users.<br>Now let’s talk about launching your application from the notification content extension.<br>So today the user can launch your application if touches were not allowed by simply tapping the content extension view. They could also do so by tapping your application icon in the top left corner. Or you could create a foreground action, which then would in turn launch the application. But what if you wanted to do this from your own custom control? What if you wanted to launch the application programmatically? To enable this, there is a new API on the NSExtensionContext called performNotification DefaultAction, which would allow you to do this now. Now, what does the default action mean? So, as we said, it launches the application, but at the same time, it calls the UserNotificationCenter did receive response method in your application delegate. Now the UNNotificationResponse object contains the information of the notification from which the user came, so you can update your application state based on the notification. And the identifier that’s passed here is the UNNotificationDefault ActionIdentifier. So going back to our sample, let’s see how we can set this custom control up. Now again, we create our own UI button for the all comments and then tie it up with our own private function.<br>And in that function, we’re simply calling PerformNotification DefaultAction. So by simply doing that, you get this functionality to call this method programmatically from anywhere in your content extension code.<br>So that was launching the application. What about dismissing the content extension view? Again, let’s take a look at how the user can do that today.<br>They can do that by tapping the Dismiss Button in the top right corner, or you can create your own custom notification action, which would in turn dismiss the content extension view.<br>Which you can set up, as we saw before, by passing dismiss to the completion block.<br>But again, what if we want to dismiss the view through our own custom buttons, and we want to do this programmatically? Say that when the user taps the Like button, then the view dismisses because we feel the user’s done interacting with the content extension.<br>To enable this as well, there’s a new API called dismissNotificationContent Extension that’s on the NSExtensionContext. We go back to how we set up our Like button, and now this time, we also call the new function that we added for dismissing the content extension view. And once we set this up, now when the user takes the like action, the view of the content extension gets dismissed. Now one thing to note here.<br>That calling this method does not withdraw the notification that was posted to the user.<br>If you want to do that then use the existing API for removing delivered notifications with identifiers to get that functionality. All right, now let’s summarize all the new APIs that we’ve looked at today around the notification content extensions.<br>We started with talking about notification actions where now you can access these notification actions as well as replace them dynamically from anywhere in your content extension code. You can now opt in to having user interaction based on touches within your content extension views. You can programmatically launch the application from anywhere in your content extension code as well as dismiss the content extension view, depending upon where you feel it serves best your user’s experience around the content extensions. So that’s a varied list of APIs around content extensions, and we hope this really helps you enhance your user’s experience around your content extensions and then you start using these APIs. So that was notification content extensions. Now, the next topic today we’re going to look at is notification management, and to tell you all about that, let me invite my colleague Teja to the stage.<br>Thank you. Thank you Kritarth.<br>Hi everyone. My name is Teja Kondapalli, and I’m also an engineer on the iOS Notifications’ Team. And, of course, I’m here to talk to you about a couple of the new APIs that we have. The first of which is notification management.<br>But before I dive into this API, I want to cover some of the user facing features to give you some more context and then we can deep dive into the API. As our users get more and more apps on their phones, notifications become the primary way that they interact with these apps. But often, they find themselves in a situation like this.<br>With far too many notifications. And it becomes hard to sift through and find the important ones. So perhaps to make this easier, this user has decided that notifications from podcasts don’t need to be shown on the locked screen.<br>Right now to configure that they’d have to launch the settings app, find notifications, find the podcast app, and then they can configure their settings.<br>We wanted to make this easier. So, in iOS 12, we’re introducing a new management view where the users can configure their notification settings directly from the notification without having to launch the settings app. There’s three really easy ways to get into this management view. The first is what we just saw.<br>You simply swipe over a notification, tap manage, and the management view comes up.<br>The second is if you can go into the rich notification, you can tap in the right corner, and you can also launch the management view. And the third is actually in the list itself. Depending on how your users are interacting with their notifications, they will occasionally see suggestions, like this one, that ask them if they want to keep receiving podcast notifications. And from here, as well, they can tap manage and bring up the management view. Let’s take a closer look at the management view. And we obviously have options here where users can configure their notification settings directly from this view. But if they want to go into the settings app and configure in a more detailed manner, they have a quick link to the settings for this application, the notification settings. A And also from this view, they have some actions they can take directly, the first of which says deliver quietly, which is probably a concept that’s new to all of you. Some of these management views will also have an option that says deliver prominently, so let’s talk about what this means. In iOS, we have a lot of settings that users can configure, and this is really great for the power user. The can customize their settings to every detail, but for the regular user, we think that we can help them out by categorizing their notification settings into two big categories.<br>Notifications that are delivered prominently and notifications that are delivered quietly.<br>Notifications that are delivered prominently are what we’re used to.<br>They show up on the locked screen. They show up in notification center. They roll down as banners. They badge the AP icon and they can play a sound. Notifications that are delivered quietly only show up in notification center and they don’t play a sound. And from the management view, in addition to configuring whether they want their notifications delivered prominently or quietly, users also have the option to turn off their notifications.<br>Now, I know that you might worry that your users are going to turn off the notifications for your app, so we’ve added this extra confirmation sheet just in case they do tap turn off.<br>And from here, they can also turn off their notifications. But we’ve also added an API to add a second option to this confirmation sheet, and podcast has taken advantage of this API, so it says configure in podcast. This is a link that will deep link within the podcast app to a custom settings view that allows the user more granular control about what kind of podcast notifications they want. And as your apps send more and more notifications and various type of notifications, we think it’s really important to allow them this granular level of control over what kind of notifications are important to them.<br>This link can also be accessed from the systems settings app from your apps’ notification settings. And you can see for podcasts it’s right at the bottom.<br>It says podcast notifications settings. Let’s see how we do this in code. In the class that conforms to UNUserNotificationCenter Delegate, we have a new delegate method. Open settings for notification, and as long as you implement this delegate method, those links that we talked about from the management view, or from the settings app, will automatically be populated by the system for you. So when the user taps on any of these links, this delegate method will be called. And it’s really important when this delegate method is called that you immediately take your users into the view where they can configure their notification settings within your app. And if you notice, we have [inaudible] parameter to this method, and it is notification. So depending on where the link was tapped from, if it was tapped from one of the management views, it will have the value of the notification that that management view came from. If it was tapped from the settings app, the value of notification will be nil, and you can use this information to show the appropriate notification settings when this delegate method is called.<br>So that’s what we have for notification management. It’s a new way for your users to configure whether they want their notifications delivered prominently or quietly, or turn them off, or even configure them at a granular level within your app.<br>And to encourage your users to keep getting your notifications delivered, we think it’s really important that you make the content in the notifications relevant.<br>We also encourage you to use thread identifiers to group the notifications when you think it’s appropriate. This will help the users organize their lists better and will make sure that they’re not overwhelmed by the notifications from your app.<br>We also think that as your apps send various types of notifications, it’s really important to provide that custom settings view within that app so that users have more granular control about what kind of notifications are important to them.<br>That’s what we have for notification management. And the next big feature I want to talk to you about is provisional authorization. Right now, when a user installs your app, before they start receiving notifications, at some point they’ll have to respond to a prompt that looks like this, which is asking them if they want these notifications.<br>And the biggest problem with this is, at this point, the user doesn’t know what kind of notifications this app is going to send, so they don’t know if they want them or not.<br>So, in iOS 12, we’re introducing provisional authorization, and this is an automatic trial of the notifications from your app. This will help your users make a more informed decision on whether they want these notifications or not. So you can opt into this, and if you do, your users will not get that authorization prompt that we just saw.<br>Instead, the notifications from your app will automatically start getting delivered.<br>But these notifications will be delivered quietly, and if we recall, notifications that are delivered quietly only show up in notifications center, and they don’t play a sound.<br>Notifications that are delivered with provisional authorization will have a prompt like this on the notification itself. And this will help the users decide after having received a few notifications whether they want to keep getting these notifications or whether they want to turn them off. And this turn off confirmation sheet will also have the custom settings link if you have provided it. Let’s see how you can do this in code. In the location where you regularly request authorization, in addition to whatever options you might be requesting, you can add a dot qualifying option called .provisional. And if you include this, you will automatically start participating in the trial. It’s really important to note that the .provisional option is in addition to whatever other options you may be providing. That’s because if the users decide to keep getting your notifications delivered, we want to know how you want them delivered, with badges or sounds or as alerts. So that’s what provisional authorization is. It’s an automatic trial of the notifications from your app to help your users make a more informed decision about whether they want these notifications.<br>And again, to encourage your users to keep getting your notifications delivered, it’s really important to make the content in your notifications relevant.<br>And also, it’s really important to use .provisional as a qualifier option in addition to whatever other options you’re requesting. That’s what we have for provisional authorization. And the last big feature that I want to talk to you about are critical alerts. Often when I’m in the middle of a meeting or attending something important, my phone looks like this. And as you can see, I have do not disturb turned on. Or at least I have the ringer switch turned off so that I don’t hear any sounds when I get notifications. And usually this is really good, but I would have missed a really important notification like this one.<br>This is a health-related notification. That’s from a glucose monitor that’s warning me of low blood sugar, and this is something I would want to see immediately.<br>Scenarios like this made us realize that we need a new type of notification, and this is what we call critical alerts. Critical alerts are medical- and health-related notifications.<br>Or home- and security-related notifications. Or public safety notifications.<br>And the key to a critical alert is that it requires the user to take action immediately.<br>The way that critical alerts behave is that they bypass both do not disturb and the ringer switch, and they will play a sound. And they can even play a custom sound. But what that means is that these are very disruptive, and for that reason we don’t think that all apps should be able to send critical notifications.<br>Critical alerts. So in order to start sending a critical alert, you will need to apply for entitlement, and you can do that on the developer.apple website.<br>This is what a critical alert looks like, and you can see that it has a unique icon indicating that it’s critical. And it would have also come in with a sound.<br>Critical alerts also have their own section in notifications settings.<br>This means that a user can choose to allow critical alerts for a particular application but choose not to allow any other type of notification. And before users start receiving critical alerts, they will have to accept a prompt that looks like this that’s asking them specifically whether they want to accept critical alerts from a particular application.<br>So, of course, in order to start sending critical alerts, you’ll have to request authorization.<br>So after you apply for entitlement and get it, in the place where you regularly request authorization, in addition to whatever other options you want to request, you can also request a .criticalAlert option. And this will give your users the prompt. And let’s see how it actually set up and send a critical alert. It actually behaves very similarly to a regular notification. You can see that I just set up a notification with the title body and category identifier, but what distinguishes this as a critical alert is that it plays a sound. So I need to set a critical alert sound.<br>And here, you can see that I’m setting the default critical alert sound that’s provided by the framework. I can also set a custom sound. And I can also set a custom audio volume level. And of course, critical alerts can also be push notifications so all of this information can be set in the push payload as well.<br>So that’s what we have for critical alerts. They’re a new type of notification that requires the users to take action immediately.<br>And they’re very disruptive, so you need entitlement to be able to send them.<br>So that’s all the new exciting APIs that we have for you today. I just want to quickly go over all the things that we covered. We talked about how you can use thread identifiers to group your notifications to help your users organize their notification lists better.<br>We talked about all the great new APIs around notification content extensions, which will help you make your rich notifications much more interactive.<br>We talked about how you can provide a custom settings view within your app to allow your users more granular control over what kind of notifications they want to receive.<br>We also talked about provisional authorizations, which is an automatic trial of the notifications from your app, which will help you users make a more informed decision about whether they want these notifications or not. And last, we talked about critical alerts, which are a new type of notification that requires the user to take action immediately and that are disruptive. So we hope you take advantage of all of these great APIs and make the notification experience for your users even better.<br>You can find all the information about this session on our sessions’ page at developer.apple.com. We’re session 710. We have another session just following this one in hall three called using grouped notification where we’ll help you determine how to best group notifications for your app. We have two notifications labs, one today and one tomorrow, where you can come and ask the engineers on our team any questions that you may have. And on Friday morning, we have an interesting session called designing notifications. That’s going to be hosted by the designers who helped us come up with the designs for these, and they’ll be talking about notification best practices.<br>Thank you and have a great dot dot.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.&lt;br&gt;下午好，欢迎大家来这个叫做what’s new in user notifications的session &lt;/p&gt;
    
    </summary>
    
      <category term="WWDC" scheme="http://yoursite.com/categories/WWDC/"/>
    
    
      <category term="Notifications" scheme="http://yoursite.com/tags/Notifications/"/>
    
  </entry>
  
  <entry>
    <title>IOS12 兼容</title>
    <link href="http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/"/>
    <id>http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/</id>
    <published>2018-08-22T04:07:12.000Z</published>
    <updated>2018-09-13T08:02:47.563Z</updated>
    
    <content type="html"><![CDATA[<p>主要遇到的问题：</p><ol><li>Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</li><li>CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中</li></ol><a id="more"></a><h2 id="libstdc-问题"><a href="#libstdc-问题" class="headerlink" title="libstdc++问题"></a>libstdc++问题</h2><ul><li>现象是无法找到libstdc++，编译报错如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">library</span> <span class="selector-tag">not</span> <span class="selector-tag">found</span> <span class="selector-tag">for</span> <span class="selector-tag">-lstdc</span>++<span class="selector-class">.6</span><span class="selector-class">.0</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><ul><li>临时解决办法—-从Xcode9中复制libstdc++库到Xcode10中，命令如下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span></span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span></span><br></pre></td></tr></table></figure><ul><li>最终解决办法：</li></ul><p>需要联系第三方公司，将GMThirdParty/BestPay 、GMF_EaseMobSDK2.2.9更新。</p><h3 id="模拟器无法启动的解决方案"><a href="#模拟器无法启动的解决方案" class="headerlink" title="模拟器无法启动的解决方案"></a>模拟器无法启动的解决方案</h3><p>报错如下：    </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library not <span class="symbol">loaded:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span></span></span><br><span class="line">  Referenced <span class="symbol">from:</span> /Users/lijian/Library/Developer/CoreSimulator/Devices/<span class="number">6</span>CB2CF98-<span class="number">149</span>C-<span class="number">43</span>A1-<span class="number">8</span>A93-<span class="number">516</span>FE4243C8C/data/Containers/Bundle/Application/<span class="number">2</span>C25BADD-A36F-<span class="number">4</span>B11-<span class="number">9885</span>-<span class="number">34E8</span>AEE826AC/GomeStaff.app/GomeStaff</span><br><span class="line">  <span class="symbol">Reason:</span> no suitable image found.  Did <span class="symbol">find:</span></span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span>: <span class="title">mach</span>-<span class="title">o</span>, <span class="title">but</span> <span class="title">not</span> <span class="title">built</span> <span class="title">for</span> <span class="title">iOS</span> <span class="title">simulator</span></span></span><br></pre></td></tr></table></figure><p>原因分析： </p><p>上面的错误的含义是动态链接器无法加载到libstdc++.6.dylib，但是真机上是可以加载出来，所以，推测模拟器的运行环境去掉了这个库，那么，我们如果将模拟器的运行环境中添加上这个库，是不是就可以了？ 答案是肯定的。</p><p>下面的问题是：我么如何找到模拟器运行环境加载库的路径呢？ 我的思路是使用xcode9运行模拟器，然后打印系统库的加载路径，这个路径就是我们要找的路径。</p><p>查找系统库的方法如下,用xcode9运行下面的代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; _dyld_image_count(); i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> char* aa = _dyld_get_image_name(i)<span class="comment">;</span></span><br><span class="line">    NSString *str = [NSString stringWithUTF8String:aa]<span class="comment">;</span></span><br><span class="line">    LOG_LJ_(@<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~%@"</span>,str)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Users/lijian</span><span class="regexp">/Downloads/</span>Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libiconv</span>.2.<span class="title">dylib</span></span></span><br></pre></td></tr></table></figure><p>上面的路径就是模拟器的系统库路径。所以，将xcode9对应目录下的三个libstdc++复制到xcode10的对应目录即可。</p><h2 id="CocoaPods无法复制资源到app中"><a href="#CocoaPods无法复制资源到app中" class="headerlink" title="CocoaPods无法复制资源到app中"></a>CocoaPods无法复制资源到app中</h2><p>现象：登录界面没有图标，或者启动时 NSBundle的initWithUrl方法崩溃。</p><p>解决办法：</p><ol><li>升级CocoaPods到1.4.0，命令是：<code>sudo gem install -n /usr/local/bin cocoapods -v 1.4.0</code> 。</li><li>移除<code>Build Phases</code> 中的 <code>[cp]Copy Pods Resources</code> 。</li><li>重新pod install。</li></ol><h2 id="info-重复问题"><a href="#info-重复问题" class="headerlink" title="info 重复问题"></a>info 重复问题</h2><p>报错如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiple commands produce <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span>:</span><br><span class="line"><span class="number">1</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> <span class="keyword">copy</span> command <span class="keyword">from</span> <span class="string">'/Users/lijian/Desktop/GomeGit/GomeStaff/GomeStaff/Supporting Files/Info.plist'</span> <span class="keyword">to</span> <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br><span class="line"><span class="number">2</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> process command <span class="keyword">with</span> output <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br></pre></td></tr></table></figure><p>原因分析：Xcode自动会将Info.plist复制到GomeStaff.app中，但是在Build Phases-&gt; Copy Bundle Resources中也包含复制Info.plist的功能，这样就两次复制，第二次复制失败。</p><p>解决方法：</p><p>将Build Phases-&gt; Copy Bundle Resources  中的info.plist 去掉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5b1634f0f265da6e61788998" rel="external nofollow noopener noreferrer" target="_blank">Xcode10和iOS12踩坑</a></li><li><a href="http://www.cocoachina.com/ios/20180611/23749.html" rel="external nofollow noopener noreferrer" target="_blank">libstdc++适配Xcode10与iOS12</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要遇到的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。&lt;/li&gt;
&lt;li&gt;CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="IOS12" scheme="http://yoursite.com/categories/IOS/IOS12/"/>
    
    
      <category term="IOS12 兼容" scheme="http://yoursite.com/tags/IOS12-%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
</feed>
