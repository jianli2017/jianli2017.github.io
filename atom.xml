<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-08T10:03:56.896Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>方法列表entsize_list_tt结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/</id>
    <published>2018-11-03T02:38:11.000Z</published>
    <updated>2018-11-08T10:03:56.896Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中</p><a id="more"></a><h2 id="entsize-list-tt-简单介绍"><a href="#entsize-list-tt-简单介绍" class="headerlink" title="entsize_list_tt 简单介绍"></a>entsize_list_tt 简单介绍</h2><p>类的编译后的数据存储在class_ro_t结构中，其中各种方法列表、变量列表、属性列表的类型分别是method_list_t、ivar_list_t、property_list_t，这些类型全部继承于entsize_list_tt。class_ro_t的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RO 就是 Read Only</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;  <span class="comment">// 基本方法列表，存储编译期确定的方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;       <span class="comment">// 类的成员变量列表，存储编译期确定的成员变量</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 基本属性列表，存储编译期确定的属性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>method_list_t 继承于entsize_list_tt 的源码如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, <span class="number">0x3</span>&gt; &#123; // <span class="number">0x3</span> 就是 <span class="number">0b11</span></span><br><span class="line">                                                                       // 即 flag 占 <span class="number">2</span> 个 bit，用来放 fixedup markers</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面就开始学习entsize_list_tt数据结构。</p><h2 id="entsize-list-tt-详细分析"><a href="#entsize-list-tt-详细分析" class="headerlink" title="entsize_list_tt 详细分析"></a>entsize_list_tt 详细分析</h2><p>entsize_list_tt其实就是一个列表，用来存储编译完成后类的属性。由于位于class_ro_t结构中，所以这个结构是只读的，没有写方法，只有访问的相关方法，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entsize_list_tt 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。</span></span><br><span class="line"><span class="comment">// Element 表示元素类型，List 用于指定容器类型，</span></span><br><span class="line"><span class="comment">// 最后一个参数为标记位, 用来在 entsize field 里存放一些额外的 bits，也就是 flags</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List, <span class="keyword">uint32_t</span> FlagMask&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entsize_list_tt</span> &#123;</span></span><br><span class="line">    <span class="comment">// entsize 和 flags 存在了一起，需要用 FlagMask 进行区分哪些 bits 里存的是 flags</span></span><br><span class="line">    <span class="comment">// entsize 就是每个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsizeAndFlags;</span><br><span class="line">    <span class="keyword">uint32_t</span> count; <span class="comment">// 元素的总数</span></span><br><span class="line">    Element first;  <span class="comment">// 第一个元素，其他的元素紧跟在其后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 entsize 单个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; ~FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出 flags</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素，i &lt;= count</span></span><br><span class="line">    <span class="comment">// 如果 i 等于 count，取得的就是最后一个元素的末尾地址</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">getOrEnd</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt;= count);</span><br><span class="line">        <span class="comment">// 从第一个元素开始，加上偏移量 i * 单个元素的大小</span></span><br><span class="line">        <span class="comment">// 就是 i 索引处的元素</span></span><br><span class="line">        <span class="keyword">return</span> *(Element *)((<span class="keyword">uint8_t</span> *)&amp;first + i*entsize()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素</span></span><br><span class="line">    <span class="comment">// i 必须小于总数</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">get</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt; count);</span><br><span class="line">        <span class="keyword">return</span> getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得整个 entsize_list_tt 对象以及其保存的所有元素占多少内存</span></span><br><span class="line">    <span class="keyword">size_t</span> byteSize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// sizeof(*this) 计算是对象本身占的大小，其中还包括了第一个元素</span></span><br><span class="line">        <span class="comment">// (count-1)*entsize() 计算的是除了第一个元素外，其他所有元素占的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) + (count<span class="number">-1</span>)*entsize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝对象</span></span><br><span class="line">    <span class="function">List *<span class="title">duplicate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// memdup 里用 malloc 在堆中开辟了一块长度为 this-&gt;byteSize() 大小的内存</span></span><br><span class="line">        <span class="comment">// 并将 this 也就是当前对象的内存拷贝到其中</span></span><br><span class="line">        <span class="keyword">return</span> (List *)memdup(<span class="keyword">this</span>, <span class="keyword">this</span>-&gt;byteSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取得指向容器的第一个元素的迭代器，返回值是常量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指向容器的第一个元素的迭代器，返回值是变量，可以变</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指向容器尾部的迭代器，注意是尾部，也就是最后一个元素的末尾，并不是最后的一个元素，返回值是常量</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), count); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指向容器尾部的迭代器，注意是尾部，也就是最后一个元素的末尾，并不是最后的一个元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), count); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">        </span><br><span class="line">        Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">typedef</span> <span class="built_in">std</span>::random_access_iterator_tag iterator_category; <span class="comment">// 迭代器的类型</span></span><br><span class="line">        <span class="keyword">typedef</span> Element value_type;  <span class="comment">// 元素类型</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;  <span class="comment">// 索引的差值 delta 的类型</span></span><br><span class="line">        <span class="keyword">typedef</span> Element* pointer;    <span class="comment">// 指针类型</span></span><br><span class="line">        <span class="keyword">typedef</span> Element&amp; reference;  <span class="comment">// 引用类型</span></span><br><span class="line"></span><br><span class="line">        iterator() &#123; &#125;   <span class="comment">// 默认的空的构造函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line">        <span class="comment">// start 是当前的索引</span></span><br><span class="line">        iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">            : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">            , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">            , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器向后移动 delta 个位置</span></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> += (<span class="keyword">ptrdiff_t</span> delta) &#123;</span><br><span class="line">            <span class="comment">// 计算出新元素的地址，保存起来</span></span><br><span class="line">            element = (Element*)((<span class="keyword">uint8_t</span> *)element + delta*entsize);</span><br><span class="line">            <span class="comment">// 索引也加上 delta</span></span><br><span class="line">            index += (<span class="keyword">int32_t</span>)delta;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 与 += 相反，迭代器向前移动 delta 个位置</span></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> -= (<span class="keyword">ptrdiff_t</span> delta) &#123;</span><br><span class="line">            element = (Element*)((<span class="keyword">uint8_t</span> *)element - delta*entsize);</span><br><span class="line">            index -= (<span class="keyword">int32_t</span>)delta;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ....   </span><br><span class="line">        <span class="comment">// 判断 当前迭代器保存的元素的地址 是否比 另一个迭代器保存的元素的地址 靠前</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;element &lt; rhs.element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断 当前迭代器保存的元素的地址 是否比 另一个迭代器保存的元素的地址 靠后</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;element &gt; rhs.element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>entsize_list_tt 是个模板，可以实例化出method_list_t、ivar_list_t、property_list_t三种类型。有三个数据成员，entsizeAndFlags 是个复合成员，高位表示元素的大小，低位是个标志位，entsize、Flags具体占用多少位，根据模板参数FlagMask决定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x3 就是 0b11,即 flag 占 2 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">0x3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">ivar_t</span>, <span class="keyword">ivar_list_t</span>, <span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">property_t</span>, <span class="keyword">property_list_t</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><p>method_list_t 实例化时，递给FlagMask的模板实参是0x3，转化为二进制为0b11，占用两位。那么在method_list_t结构中，entsizeAndFlags 表示的entsize占用30位，Flags占用2位。</p><p>count 表示列表中存储元素的个数，first 表示首元素。注意他不是个指针，只是一个首元素，后面的元素会挨着first顺序存储。</p><p>method_list_t 的方法基本都是访问属性的。慢慢看着注释应该嫩看懂。</p><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>既然entsize_list_tt是一个列表，那么就需要一个迭代器，从而枚举列表内部的元素。迭代器是个内部类，重载了很多方法，迭代器类主要的方法是构造函数，剩下的全部是重载运算符，大致雷同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line"><span class="comment">// start 是当前的索引</span></span><br><span class="line">iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">    : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">    , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">    , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><p>下面是迭代器的示意图。</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_iterator.png" alt="entisize_list_tt 迭代器示意图"></p><p>示意图中列出指向首元素的迭代器begin、尾后迭代器end、和begin+2的内存结构。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>类图以方法列表method_list_t为例，里面存储的元素是method_t类型：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt类图.png" alt="entisize_list_tt类图"></p><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p>为了进一步理解这个结构，我用hopper抓了一个这样的结构，如图所示，</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_hopper.png" alt="entisize_list_tt 实例数据"></p><p>我们将这个数据放入内存，内存结构大致如下：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_memory.png" alt="entisize_list_tt 内存布局"></p><p>entsizeAndFlags 的值是0x18，转化为二进制，为0b1,1000，那么entsize的值去高20位，还是0b1,1000，十进制为24表示元素的大小是24，然后继续看元素，元素的类型是method_t，大小为24，验证了entsize的含义。flag取低二位，为0 。</p><p>接下来的count的值是3，表示有三个元素。后面紧跟着三个元素。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="entsize_list_tt" scheme="http://yoursite.com/tags/entsize-list-tt/"/>
    
  </entry>
  
  <entry>
    <title>NSObject 基本完整类图</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/</id>
    <published>2018-11-02T02:38:11.000Z</published>
    <updated>2018-11-08T08:17:06.597Z</updated>
    
    <content type="html"><![CDATA[<p>本文保存了NSObject的基本完整类图。方便以后理解。</p><a id="more"></a><h2 id="NSObject-完整类图"><a href="#NSObject-完整类图" class="headerlink" title="NSObject 完整类图"></a>NSObject 完整类图</h2><p>NSObject 基本完整类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/NSObject_picture.png" alt="NSObject 完整类图"></p><p>objc_class 有四个成员，本图说明两个非常重要的成员- isa、bits。 isa指向对象的类（或者类的元类）；bits定义了类的数据，包括类的属性、方法、协议、ivar 。 它的类型是class_data_bits_t，class_data_bits_t 有一个成员，类型是uintptr_t，64位。其中1~3位表示一个属性，3~47位表示一个指针，如果class还没有实现，这个指针指向class_ro_t类型，表示类编译完后的只读属性。当类实现后，这个指针指向了class_rw_t类型，表示runtime实现完class后类的数据，这是，数据里面已经包括了分类的方法信息。</p><h2 id="使用hopper查看类结构"><a href="#使用hopper查看类结构" class="headerlink" title="使用hopper查看类结构"></a>使用hopper查看类结构</h2><p>首先定义类LJObject，头文件如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LJObject.h</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObject </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>实现文件如下 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LJObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LJObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span>*) printDefaultName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span> *)printDefaultValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用hopper查看的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_nsobject.png" alt="hopper 查看类的结构"></p><h2 id="五小结构"><a href="#五小结构" class="headerlink" title="五小结构"></a>五小结构</h2><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>方法的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名，就是 SEL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法类型字符串，有的地方又称 method signature 方法签名</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向方法的函数实现的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3_method_t.png" alt="method_t类图"></p><p>hopper查看的结果如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_method_t.jpg" alt="hopper 查看method_t结构"></p><p>总结method_t值包含三个属性，方法名字、方法签名、方法的实现。</p><h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset; <span class="comment">// 偏移量 用 __OFFSETOFIVAR__ 计算</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 成员变量名  比如 "_name"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type; <span class="comment">// 成员变量的类型 比如 "@\"NSString\""</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">// 对齐</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;  <span class="comment">// 成员变量占多少内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3ivar.png" alt="ivar_t类图"></p><h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 属性名，堆中分配</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// 属性的特性字符串，标识了属性有哪些特性</span></span><br><span class="line">                            <span class="comment">// 该字符串是在堆中分配的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3property.png" alt="property_t 类图"></p><h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><p>定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议结构体，继承自 objc_object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;    <span class="comment">// 重整后的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 它在 objc_allocateProtocol() 中被赋值，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样，</span></span><br><span class="line">                                <span class="comment">// 重整名字是编译器给出的，加了 swift 复杂前缀的，用于混编时区分 oc协议 和 swift协议，</span></span><br><span class="line">                                <span class="comment">// 而 demangledName 取消重整的名称，应该就是去掉前缀的正常的名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>  <span class="comment">// 子协议列表，见 protocol_addProtocol()</span></span><br><span class="line">                                        <span class="comment">// 又可以称为 incorporated protocols 合并的协议</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;  <span class="comment">// 必选(required)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;   <span class="comment">//  必选(required)的类方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods; <span class="comment">// 可选(optional)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;  <span class="comment">// 可选(optional)的类方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;  <span class="comment">// 实例属性，当前协议只支持 required 的实例属性，</span></span><br><span class="line">                                          <span class="comment">// 协议中也是可以添加属性的，</span></span><br><span class="line">                                          <span class="comment">// 不知道会不会生成成员变量，但生成 set 和 get 方法是一定有的</span></span><br><span class="line">                                          <span class="comment">// 比如 NSObject 协议，就有几个 readonly 的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// 这个协议的大小，其中也包括了 extendedMethodTypes 整个数组的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;  <span class="comment">// 标记 跟 PROTOCOL_FIXED_UP_1 / PROTOCOL_FIXED_UP_2 有关系</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 这句话的意思，好像是下面这几个成员变量不一定有，</span></span><br><span class="line">    <span class="comment">// 所以用到它们的时候都检查了下 size 是否足够大，比如 hasExtendedMethodTypesField() 和 protocol_t::demangledName()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **extendedMethodTypes; <span class="comment">// 扩展方法类型数组，每个元素是一个扩展类型字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName; <span class="comment">// 取消重整的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样</span></span><br><span class="line">                                <span class="comment">// 见 demangledName()</span></span><br><span class="line">                                <span class="comment">// demangledName 取消重整的名称，应该就是去掉 swift 前缀的正常的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3protocal.png" alt="protocol_t 类图"></p><h3 id="category-t"><a href="#category-t" class="headerlink" title="category_t"></a>category_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 分类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">// 分类所属的类，classref_t 专门用于 unremapped 的类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>     <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>      <span class="comment">// 遵循的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性列表，但是并没有卵用... 唉....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3category.png" alt="category_t 类图"></p><h3 id="五小结构总图"><a href="#五小结构总图" class="headerlink" title="五小结构总图"></a>五小结构总图</h3><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3five.png" alt="5小结构总图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文保存了NSObject的基本完整类图。方便以后理解。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>从 NSObject 的初始化了解 isa（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/NSObject_isa/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/NSObject_isa/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-07T08:13:16.993Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件</p><a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><h2 id="OC的类是一个结构体"><a href="#OC的类是一个结构体" class="headerlink" title="OC的类是一个结构体"></a>OC的类是一个结构体</h2><p>所有的OC类其实都是一个c语言的结构体，我们可以通过clang -rewrite-objc 命令重写OC类为C++类。来理解OC的类就是一个C语言的结构体。下面是重写的实例，类的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObjc</span>:NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">LJObjc</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>在从重写后的输出文件中，我们找到LJObjc的定义，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">LJObjc</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出，OC类就是一个C的结构体。</p><p>既然所有的OC对都是一个结构体，这个结构体就是struct objc_object。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>objc_object结构中只有一个 <code>isa_t</code>类型成员。所以我们可以说含有isa的结构体都是一个对象。</p><blockquote><p>所有继承自 <code>NSObject</code> 的类实例化后的对象都会包含一个类型为 <code>isa_t</code> 的结构体。</p></blockquote><p>虽然上面重写LJObjc后的C语言结构体是一个objc_object对象，但实际上他是一个objc_class结构体，由于objc_class继承与objc_object，  所以本质上objc_class 也是一个objc_object结构。<br>objc_class定义如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa<span class="comment">;</span></span><br><span class="line">    Class superclass<span class="comment">;</span></span><br><span class="line">    <span class="keyword">cache_t </span><span class="keyword">cache;</span></span><br><span class="line"><span class="keyword"> </span>   class_data_bits_t <span class="keyword">bits;</span></span><br><span class="line"><span class="keyword">&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的，所以在这里显式地写出了 <code>isa_t isa</code> 这个成员变量。</p></blockquote><p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p><h2 id="isa-指针的作用与元类"><a href="#isa-指针的作用与元类" class="headerlink" title="isa 指针的作用与元类"></a><code>isa</code> 指针的作用与元类</h2><p> <code>isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p><p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p><p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code>isa</code> 来查找对应的类，然后在这里的 <code>class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code>objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code>super_class</code> 用来查找继承的方法。</p><blockquote><p>关于如何在 <code>class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" rel="external nofollow noopener noreferrer" target="_blank">深入解析 ObjC 中方法的结构</a></p></blockquote><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-class-pointer.png" alt="isa 指针-- 实例找到类"></p><p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-meta-class.png" alt="元类的引入"></p><p>让每一个类的 <code>isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p><ul><li>实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现</li><li>类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现</li></ul><p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-class-diagram.png" alt="元类"></p><blockquote><p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></p></blockquote><p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code>isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></p><h2 id="结构体-isa-t"><a href="#结构体-isa-t" class="headerlink" title="结构体 isa_t"></a>结构体 <code>isa_t</code></h2><p>其实 <code>isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是在 <code>__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code>__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="#arm64">arm64 上结构体的实现</a></p></blockquote><p><strong>在本篇文章中, 我们会以 <code>__x86_64__</code> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code>isa</code> 指针的理解，不过还是要知道的。</p><p>下面是一张isa_t的类图，便于理解</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-class-object-class.png" alt="isa类图"></p><p>笔者对这个 <code>isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，对 <code>union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">回答</a>. 也就是说其中的 <code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间。而 <code>isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-isat.png" alt="isa各个位域的含义"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a><code>isa</code> 的初始化</h2><p>我们可以通过 <code>isa</code> 初始化的方法 <code>initIsa</code> 来初步了解这 64 位的 bits 的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///定义位于objc-object.h文件</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexed-和-magic"><a href="#indexed-和-magic" class="headerlink" title="indexed 和 magic"></a><code>indexed</code> 和 <code>magic</code></h3><p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code>initIsa</code> 方法，由于在 <code>initInstanceIsa</code> 方法中传入了 <code>indexed = true</code>，所以，我们简化一下这个方法的实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void objc_object::initIsa(Class cls, <span class="keyword">bool </span>indexed, <span class="keyword">bool </span>hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.<span class="keyword">bits </span>= ISA_MAGIC_VALUE<span class="comment">;</span></span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br><span class="line">    isa.<span class="keyword">shiftcls </span>= (uintptr_t)cls &gt;&gt; <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对整个 <code>isa</code> 的值 <code>bits</code> 进行设置，传入 <code>ISA_MAGIC_VALUE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br></pre></td></tr></table></figure><p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-isat-bits.png" alt="objc-isa-isat-bits"></p><p>从图中了解到，在使用 <code>ISA_MAGIC_VALUE</code> 设置 <code>isa_t</code> 结构体之后，实际上只是设置了 <code>indexed</code> 以及 <code>magic</code> 这两部分的值。</p><ul><li><p>其中 <code>indexed</code> 表示 <code>isa_t</code> 的类型</p><ul><li><p>0 表示 <code>raw isa</code>，也就是没有结构体的部分，访问对象的 <code>isa</code> 会直接返回一个指向 <code>cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>1 表示当前 <code>isa</code> 不是指针，但是其中也有 <code>cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 <code>shiftcls</code> 中</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>magic</code> 的值为 <code>0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p></li></ul><h3 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a><code>has_cxx_dtor</code></h3><p>在设置 <code>indexed</code> 和 <code>magic</code> 值之后，会设置 <code>isa</code> 的 <code>has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto"></p><h3 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a><code>shiftcls</code></h3><p>在为 <code>indexed</code>、 <code>magic</code> 和 <code>has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code>isa</code> 结构体中了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p><p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing" rel="external nofollow noopener noreferrer" target="_blank">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code>000</code>，我们只会用其中的 30 位来表示对象的地址。 </p></blockquote><p>而 ObjC 中的类指针的地址后三位也为 0，在 <code>_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-print-cls.png" alt="objc-isa-print-cls"></p><p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code>Class</code> 指针时右移三位是没有问题的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。 </p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-print-object.png" alt="objc-isa-print-object"></p><blockquote><p>使用整个指针大小的内存来存储 <code>isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code>ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code>isa</code> 留下 34 位用于性能的优化。</p><p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.<br>from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></p></blockquote><p>我尝试运行了下面的代码将 <code>NSObject</code> 的类指针和对象的 <code>isa</code> 打印出来，具体分析一下</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-print-class-object.png" alt="objc-isa-print-class-object"></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span><span class="number">_p</span>ointer: <span class="number">0000000001011101100000000000000100000000001110101110000011111001</span> <span class="comment">// 补全至 64 位</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_p</span>ointer:                                 <span class="number">100000000001110101110000011111000</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器对直接访问 <code>isa</code> 的操作会有警告，因为直接访问 <code>isa</code> 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 <a href="#ISA(">ISA()</a>) 方法来获取类指针。</p></blockquote><p>代码中的 <code>object</code> 对象的 <code>isa</code> 结构体中的内容是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_isa/objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits"></p><p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code>[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code>isa</code> 时对 <code>initIsa</code> 方法的分析是正确的。它设置了 <code>indexed</code>、<code>magic</code> 以及 <code>shiftcls</code>。</p><h3 id="ISA-方法"><a href="#ISA-方法" class="headerlink" title="ISA() 方法"></a><a id="ISA()"></a>ISA() 方法</h3><p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code>ISA()</code> 来返回类指针。</p><p>其中 <code>ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK 0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">Class</span> </span></span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="class"><span class="keyword">Class</span>)(<span class="title">isa</span>.<span class="title">bits</span> &amp; <span class="title">ISA_MASK</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h3><p>在 <code>isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p><ul><li><code>has_assoc</code><ul><li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li></ul></li><li><code>weakly_referenced</code><ul><li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li></ul></li><li><code>deallocating</code><ul><li>对象正在释放内存</li></ul></li><li><code>has_sidetable_rc</code><ul><li>对象的引用计数太大了，存不下</li></ul></li><li><code>extra_rc</code><ul><li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code>extra_rc</code> 的值就为 9</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="arm64-架构中的-isa-t-结构体"><a href="#arm64-架构中的-isa-t-结构体" class="headerlink" title="arm64 架构中的 isa_t 结构体"></a><a id="arm64"></a>arm64 架构中的 <code>isa_t</code> 结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>对象： 含有isa指针的结构都是对象，包括类，实例。</li><li>isa指针的作用之一，统一类方法和实例方法的调用机制</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a></li><li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></li><li><a href="http://stackoverflow.com/questions/18997362/storing-things-in-isa" rel="external nofollow noopener noreferrer" target="_blank">Storing things in isa</a></li><li><a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">Why do we need C Unions?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Non-pointer_isa</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></li><li><a href="http://blog.xcodev.com/posts/tagged-pointer-and-64-bit/" rel="external nofollow noopener noreferrer" target="_blank">64位与Tagged Pointer</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="isa" scheme="http://yoursite.com/tags/isa/"/>
    
  </entry>
  
  <entry>
    <title>2.深入解析 ObjC 中方法的结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/NSObject_objc_object/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/NSObject_objc_object/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-07T09:43:34.822Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><p>在上一篇分析 <code>isa</code> 的文章<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解 isa</a> 中曾经说到过实例方法被调用时，会通过其持有 <code>isa</code> 指针寻找对应的类，然后在其中的 <code>class_data_bits_t</code> 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。</p><p>这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。</p><h2 id="方法在内存中的位置"><a href="#方法在内存中的位置" class="headerlink" title="方法在内存中的位置"></a>方法在内存中的位置</h2><p>先来了解一下 ObjC 中类的结构图：<br><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-class.png" alt="类的结构图"></p><ul><li><code>isa</code> 是指向元类的指针，不了解元类的可以看 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><code>super_class</code> 指向当前类的父类</li><li><code>cache</code> 用于缓存指针和 <code>vtable</code>，加速方法的调用</li><li><code>bits</code> 就是存储类的方法、属性和遵循的协议等信息的地方</li></ul><h3 id="class-data-bits-t-结构体"><a href="#class-data-bits-t-结构体" class="headerlink" title="class_data_bits_t 结构体"></a><code>class_data_bits_t</code> 结构体</h3><p>这一小结会分析类结构体中的 <code>class_data_bits_t bits</code>。其中只含有一个 64 位的 <code>bits</code> 用于存储与类有关的信息，它的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits; <span class="comment">// 只有这个一个成员变量，所有数据都存在这里，包括 rw 的地址和一些 flag</span></span><br><span class="line">                    <span class="comment">// 1. 在 realized 之前，bits 存的是 ro 的地址，</span></span><br><span class="line">                    <span class="comment">// 2. realized 后，bits 存 rw 的地址，rw 里的存有 ro 的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从定义可以看出，这只用一个成员，但是也类似位域，不同的位有不同的作用，bit不像isa使用位域定义，他使用移位定义，如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)  <span class="comment">// 用于判断 Swift 类</span></span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)  <span class="comment">// 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法</span></span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)  <span class="comment">// 当前类的实例需要 raw isa</span></span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL <span class="comment">// 存 rw 的地址的位置</span></span></span><br></pre></td></tr></table></figure><p>全部是FAST开头，说明可以快速取到，而不用去次级对象中取。还有以RW、RO开头的宏，表示在次级的class_rw_t、class_ro_t结构的标志位。class_data_bits_t的类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-class-data-bits-t.png" alt="objc-method-class-data-bits-t"></p><p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 rr/alloc 的标志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><p>它为我们提供了便捷方法用于返回其中的 <code>class_rw_t *</code> 指针：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">class_rw_t</span>* <span class="class"><span class="keyword">data</span>() &#123;</span></span><br><span class="line"><span class="class">   <span class="title">return</span> (<span class="title">class_rw_t</span> *)(<span class="title">bits</span> &amp; <span class="type">FAST_DATA_MASK</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，只取其中的 <code>[3, 47]</code> 位转换成 <code>class_rw_t *</code> 返回。</p><blockquote><p>在 x86_64 架构上，Mac OS <strong>只使用了其中的 47 位来为对象分配地址</strong>。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。</p></blockquote><p>因为 <code>class_rw_t *</code> 指针只存于第 <code>[3, 47]</code> 位，所以可以使用最后三位来存储关于当前类的其他信息：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-class_data_bits_t.png" alt="objc-method-class_data_bits_t"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure><ul><li><code>isSwift()</code><ul><li><code>FAST_IS_SWIFT</code> 用于判断 Swift 类</li></ul></li><li><code>hasDefaultRR()</code><ul><li><code>FAST_HAS_DEFAULT_RR</code> 当前类或者父类含有默认的 <code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li></ul></li><li><code>requiresRawIsa()</code><ul><li><code>FAST_REQUIRES_RAW_ISA</code> 当前类的实例需要 raw <code>isa</code></li></ul></li></ul><p>执行 <code>class_data_bits_t</code> 结构体中的 <code>data()</code> 方法或者调用 <code>objc_class</code> 中的 <code>data()</code> 方法会返回同一个 <code>class_rw_t *</code> 指针，因为 <code>objc_class</code> 中的方法只是对 <code>class_data_bits_t</code> 中对应方法的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// objc_class 中的 data() 方法</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123; </span><br><span class="line">   return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_data_bits_t 中的 data() 方法</span><br><span class="line">uintptr_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t-和-class-ro-t"><a href="#class-rw-t-和-class-ro-t" class="headerlink" title="class_rw_t 和 class_ro_t"></a><code>class_rw_t</code> 和 <code>class_ro_t</code></h3><p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 <code>class_rw_t</code> 中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags<span class="comment">;</span></span><br><span class="line">    uint32_t version<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    method_array_t methods<span class="comment">;</span></span><br><span class="line">    property_array_t properties<span class="comment">;</span></span><br><span class="line">    protocol_array_t protocols<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass<span class="comment">;</span></span><br><span class="line">    Class nextSiblingClass<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中还有一个指向常量的指针 <code>ro</code>，其中存储了<strong>当前类在编译期就已经确定的属性、方法以及遵循的协议</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在编译期间</strong>类的结构中的 <code>class_data_bits_t *data</code> 指向的是一个 <code>class_ro_t *</code> 指针：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>然后在加载 <em>ObjC 运行时</em>的时候调用 <code>realizeClass</code> 方法：</p><ol><li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li><li>初始化一个 <code>class_rw_t</code> 结构体</li><li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li><li>最后设置正确的 <code>data</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>下图是 <code>realizeClass</code> 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-after-realize-class.png" alt="objc-method-after-realize-class"></p><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><h2 id="XXObject"><a href="#XXObject" class="headerlink" title="XXObject"></a>XXObject</h2><p>下面，我们将分析一个类 <code>XXObject</code> 在运行时初始化过程中内存的更改，这是 <code>XXObject</code> 的接口与实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-target.png" alt="objc-method-target"></p><p>这是主程序的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XXObject.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Class cls = [XXObject class];</span><br><span class="line">        NSLog(@&quot;%p&quot;, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译后内存中类的结构"><a href="#编译后内存中类的结构" class="headerlink" title="编译后内存中类的结构"></a>编译后内存中类的结构</h3><p>因为<strong>类在内存中的位置是编译期就确定的</strong>，先运行一次代码获取 <code>XXObject</code> 在内存中的地址。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100001168</span></span><br></pre></td></tr></table></figure><p>接下来，在整个 ObjC 运行时初始化之前，也就是 <code>_objc_init</code> 方法中加入一个断点：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-after-compile.png" alt="objc-method-after-compile"></p><p>然后在 lldb 中输入以下命令：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)<span class="number">0</span>x100001168</span><br><span class="line">(objc_class *) <span class="variable">$0</span> = <span class="number">0</span>x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0</span>x100001188</span><br><span class="line">(class_data_bits_t *) <span class="variable">$1</span> = <span class="number">0</span>x0000000100001188</span><br><span class="line">(lldb) p <span class="variable">$1</span>-&gt;data()</span><br><span class="line">warning: could not <span class="built_in">load</span> <span class="literal">any</span> Objective-C class information. This will significantly reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) <span class="variable">$2</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p (class_ro_t *)<span class="variable">$2</span> // 将 class_rw_t 强制转化为 class_ro_t</span><br><span class="line">(class_ro_t *) <span class="variable">$3</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$3</span></span><br><span class="line">(class_ro_t) <span class="variable">$4</span> = &#123;</span><br><span class="line">  <span class="keyword">flags</span> = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  name = <span class="number">0</span>x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0</span>x00000001000010c8</span><br><span class="line">  baseProtocols = <span class="number">0</span>x0000000000000000</span><br><span class="line">  ivars = <span class="number">0</span>x0000000000000000</span><br><span class="line">  weakIvarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  baseProperties = <span class="number">0</span>x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-lldb-print-before-realize.png" alt="objc-method-lldb-print-before-realize"></p><p>现在我们获取了类经过编译器处理后的只读属性 <code>class_ro_t</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(class_ro_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  flags = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  name = <span class="number">0x0000000100000f7a</span> <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000010c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面只有 <code>baseMethodList</code> 和 <code>name</code> 是有值的，其它的 <code>ivarLayout</code>、 <code>baseProtocols</code>、 <code>ivars</code>、<code>weakIvarLayout</code> 和 <code>baseProperties</code> 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。</p><p>通过下面的命令查看 <code>baseMethodList</code> 中的内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">4</span>.baseMethodList</span><br><span class="line">(method_list_t *) $<span class="number">5</span> = <span class="number">0</span>x00000001000010c8</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">0</span>)</span><br><span class="line">(method_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject<span class="selector-class">.m</span>:<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">1</span>)</span><br><span class="line">Assertion failed: (<span class="selector-tag">i</span> &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new<span class="selector-class">.h</span>, line <span class="number">110</span>.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-lldb-print-method-list.png" alt="objc-method-lldb-print-method-list"></p><p>使用 <code>$5-&gt;get(0)</code> 时，成功获取到了 <code>-[XXObject hello]</code> 方法的结构体 <code>method_t</code>。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。</p><h3 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h3><p>这篇文章中不会对 <code>realizeClass</code> 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括：</p><ul><li>分配可读写数据空间</li><li>返回真正的类结构</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">Class</span> realizeClass(<span class="keyword">Class</span> cls)</span><br></pre></td></tr></table></figure><p>上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 <code>XXObject</code>：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-lldb-breakpoint.png" alt="objc-method-lldb-breakpoint"></p><p>这里直接判断两个指针是否相等，而不使用 <code>[NSStringFromClass(cls) isEqualToString:@&quot;XXObject&quot;]</code> 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 <code>XXObject</code>。</p><blockquote><p>直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-breakpoint-before-set-rw.png" alt="objc-method-breakpoint-before-set-r"></p><p>这个断点就设置在这里，因为 <code>XXObject</code> 是一个正常的类，所以会走 <code>else</code> 分支为<strong>可写的类数据</strong>分配内存。</p><blockquote><p>运行代码时，因为每次都会判断当前类指针是不是指向的 <code>XXObject</code>，所以会等一会才会进入断点。</p></blockquote><p>在这时打印类结构体中的 <code>data</code> 的值，发现其中的布局依旧是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>在运行完这段代码之后:</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-after-realize-breakpoint.png" alt="objc-method-after-realize-breakpoint"></p><p>我们再来打印类的结构:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)cls <span class="comment">// 打印类指针</span></span><br><span class="line">(objc_class *) <span class="variable">$262</span> = 0x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100001188 <span class="comment">// 在类指针上加 32 的 offset 打印 class_data_bits_t 指针</span></span><br><span class="line">(class_data_bits_t *) <span class="variable">$263</span> = 0x0000000100001188</span><br><span class="line">(lldb) p *<span class="variable">$263</span> <span class="comment">// 访问 class_data_bits_t 指针的内容</span></span><br><span class="line">(class_data_bits_t) <span class="variable">$264</span> = (bits = 4302315312)</span><br><span class="line">(lldb) p <span class="variable">$264</span>.data() <span class="comment">// 获取 class_rw_t</span></span><br><span class="line">(class_rw_t *) <span class="variable">$265</span> = 0x0000000100701f30</span><br><span class="line">(lldb) p *<span class="variable">$265</span> <span class="comment">// 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了</span></span><br><span class="line">(class_rw_t) <span class="variable">$266</span> = &#123;</span><br><span class="line">  flags = 2148007936</span><br><span class="line">  <span class="keyword">version</span> = 0</span><br><span class="line">  ro = 0x00000001000010e8</span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;method_t, method_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;property_t, property_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = nil</span><br><span class="line">  demangledName = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$266</span>.ro <span class="comment">// 获取 class_ro_t 指针</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) <span class="variable">$267</span> = 0x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$267</span> <span class="comment">// 访问 class_ro_t 指针的内容</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) <span class="variable">$268</span> = &#123;</span><br><span class="line">  flags = 128</span><br><span class="line">  instanceStart = 8</span><br><span class="line">  instanceSize = 8</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  name = 0x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = 0x00000001000010c8</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$268</span>.baseMethodList <span class="comment">// 获取基本方法列表</span></span><br><span class="line">(method_list_t *<span class="keyword">const</span>) <span class="variable">$269</span> = 0x00000001000010c8</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(0) <span class="comment">// 访问第一个方法</span></span><br><span class="line">(method_t) <span class="variable">$270</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = 0x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.<span class="keyword">m</span>:13)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(1) <span class="comment">// 尝试访问第二个方法，越界</span></span><br><span class="line"><span class="keyword">error</span>: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">Assertion failed: (i &lt; <span class="keyword">count</span>), function get, <span class="keyword">file</span> /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.<span class="keyword">h</span>, <span class="keyword">line</span> 110.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-print-class-struct-after-realize.png" alt="objc-method-print-class-struct-after-realize"></p><blockquote><p>最后一个操作实在是截取不到了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>在上述的代码运行之后，类的只读指针 <code>class_ro_t</code> 以及可读写指针 <code>class_rw_t</code> 都被正确的设置了。但是到这里，其 <code>class_rw_t</code> 部分的方法等成员的指针 <code>methods</code>、 <code>protocols</code> 和 <code>properties</code> 均为空，这些会在 <code>methodizeClass</code> 中进行设置：</p><p><img src="/wiki/IOS/Runtime/objc/NSObject_objc_object/objc-method-after-methodizeClass.png" alt="objc-method-after-methodizeClass"></p><p>在这里调用了 <code>method_array_t</code> 的 <code>attachLists</code> 方法，将 <code>baseMethods</code> 中的方法添加到 <code>methods</code> 数组之后。我们访问 <code>methods</code> 才会获取当前类的实例方法。</p><h2 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h2><p>说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name<span class="comment">;</span></span><br><span class="line">    const char *types<span class="comment">;</span></span><br><span class="line">    IMP imp<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中包含方法名，类型还有方法的实现指针 <code>IMP</code>：</p><p>上面的 <code>-[XXObject hello]</code> 方法的结构体是这样的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="attr">types</span> = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line"><span class="attr">imp</span> = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject.m:<span class="number">13</span></span><br></pre></td></tr></table></figure><p>方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 <code>&quot;v16@0:8&quot;</code> 这在 ObjC 中叫做<em>类型编码</em>(Type Encoding)，你可以看这篇<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>了解与类型编码相关的信息。</p><p>对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析方法在内存中的位置时，笔者最开始一直在尝试寻找<strong>只读</strong>结构体 <code>class_ro_t</code> 中 <code>baseMethods</code> 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 <code>methodizeClass</code> 方法一直向上找，直到 <code>_obj_init</code> 方法也没有找到设置只读区域的 <code>baseMethods</code> 的方法。</p><p>而且在 runtime 初始化之后，<code>realizeClass</code> 之前，从 <code>class_data_bits_t</code> 结构体中获取的 <code>class_rw_t</code> 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 <code>realizeClass</code> 中发现原来在这时并不是 <code>class_rw_t</code> 结构体，而是<code>class_ro_t</code>，才明白错误的原因。</p><p>后来突然想到类的一些方法、属性和协议实在编译期决定的（<code>baseMethods</code> 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。</p><ol><li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li><li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 <code>realizeClass</code> 执行之后，才放到了 <code>class_rw_t</code> 指向的只读区域 <code>class_ro_t</code>，这样我们即可以在运行时为 <code>class_rw_t</code> 添加方法，也不会影响类的只读结构。</li><li>在 <code>class_ro_t</code> 中的属性在运行期间就不能改变了，再添加方法时，会修改 <code>class_rw_t</code> 中的 <code>methods</code> 列表，而不是 <code>class_ro_t</code> 中的 <code>baseMethods</code>，对于方法的添加会在之后的文章中分析。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 &lt;code&gt;x86_64&lt;/code&gt; 架构下运行的，对于在 arm64 中运行的代码会特别说明
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>关键字使用的位置</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E9%99%84%E5%BD%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/附录/关键字使用的位置/</id>
    <published>2018-09-20T04:07:12.000Z</published>
    <updated>2018-09-20T07:30:27.282Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static</td><td>static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中</td></tr><tr><td>explicit</td><td>explicit只对一个实参的构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外定义时不应该重复使用</td></tr><tr><td>=default</td><td>当我们在类内用=default修饰成员声明时，合成的函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default</td></tr><tr><td>=delete</td><td>必须出现在函数第一次声明的时候</td></tr><tr><td>virtual</td><td>只能出现在类内部的声明语句中之前，不能用于类外部的函数定义</td></tr><tr><td>override</td><td></td></tr><tr><td>final</td><td>类的名字后面，防止继承</td></tr><tr><td>=0</td><td>只能出现在类内部的虚函数声明语句处</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中&lt;/td&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="附录" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E9%99%84%E5%BD%95/"/>
    
    
      <category term="关键字使用的位置" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>动态内存</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/</id>
    <published>2018-09-13T04:07:12.000Z</published>
    <updated>2018-09-14T10:58:46.479Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>动态内存和智能指针</li><li>动态数组</li></ol><a id="more"></a><p>到目前为止，我们程序只使用静态内存和栈内存，静态内存用来保存局部static对象、类static成员、以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁，对于栈对象，仅在其定义的程序块运行时才存在。static对象在使用前分配，在程序结束是销毁。</p><h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>shareed_ptr允许多个指针指向同一个对象；unique_ptr则独占所指的对象。weak_ptr伴随类。</p><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板，当我们创建一个智能指针时，必须提供额外的信息–指针指向的类型。</p><table><thead><tr><th>shared_ptr和unique_ptr都支持的操作</th><th>说明</th></tr></thead><tbody><tr><td>shared_ptr<t> sp  unique_ptr<t> up</t></t></td><td>空智能指针，可以指向类型为T的对象</td></tr><tr><td>p</td><td>将p作为一个条件判断，若p指向一个对象，则为true</td></tr><tr><td>*p</td><td>解引用p，获取它指向的对象</td></tr><tr><td>p-&gt;mem</td><td>等价于(*p)-&gt;mem</td></tr><tr><td>p.get</td><td>返回p中保存的指针，若智能指针释放了其对象，返回的指针所指的对象也消失了</td></tr><tr><td>swap(p,q)</td><td>交换pq中的指针</td></tr><tr><td>p.swap(q)</td></tr></tbody></table><table><thead><tr><th></th><th>share_ptr独有的操作</th></tr></thead><tbody><tr><td>make_shared<t>(args)</t></td><td>返回一个shared_ptr，指向动态分配的类型为T的对象，使用args初始化对象</td></tr><tr><td>shared_ptr<t>p(q)</t></td><td>p 是shared_ptr q的拷贝，此操作会递q中的计算器q中的指针必须能转换为T*</td></tr><tr><td>p = q</td><td>pq 都是shared_ptr，所保存的指针必须能相互转化，次操作会递减p的引用计数器，递增q的引用计数器，若p的引用计数器为0，则将其管理的源内存释放</td></tr><tr><td>p.unique()</td><td>若p.user_count为1，返回true，否则，返回false</td></tr><tr><td>p.use_count()</td><td>返回与p共享对象的智能指针数量，可能很慢，组要用于调试</td></tr></tbody></table><ol><li>shared_ptr的拷贝和赋值</li><li>shared_ptr自动销毁所管理的对象</li></ol><p>使用动态内存处于以下三个原因：</p><ol><li>程序不知道自己需要使用多少对象，典型例子，容器</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间空闲数据</li></ol><p>一般而言，如果。两个对象共享底层的数据，当讴歌对象被销毁时，我们不能单方面的销毁底层数据。</p><p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>使用new动态分配和初始化对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，动态分配的对象是默认初始化的，这意味着，内置类型、组合类型的对象是未定义的，而类类型的对象使用默认构造函数进行初始化。</p><p>我们可以使用直接初始化方式来初始化一个动态分配的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>);</span><br></pre></td></tr></table></figure><p>也可以对动态分配的对象进行值初始化，只需要要类型名后跟一对圆括号即可。</p><p>对于定义了自己的构造函数的类类型来说，不论是值初始化还是默认初始化，都是使用默认构造函数，</p><p>但是对于内置类型来说，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的对象的值是未定义的。</p><p>动态分配的const对象：使用new分配const对象是合法的。一个动态分配的const对象必须初始化。</p><p>内存耗尽： 这里讲了定位new</p><p>delete之后重置指针：在delete之后，指针就变成了人们所说的空悬指针（danglind pointer）。</p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是explicit的，因此，我们将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式来初始化一个智能指针。</p><p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放她所关联的对象。</p><table><thead><tr><th></th><th>定义和改变shared_ptr的其他方法</th></tr></thead><tbody><tr><td>shared_ptr<t>p(q)</t></td><td>p管理内置指针q所指向的对象，q必须指向new分配的内存，且能转化为T*类型</td></tr><tr><td>shared_ptr<t>p(u)</t></td><td>p从unique_ptr哪里接管了对象的所有权，将U置位空</td></tr><tr><td>shared_pte<t>p(q,d)</t></td><td>p接管了内置指针q所指向的对象的所有权，p将使用可调用对象d来代替delete</td></tr><tr><td>shared_ptr<t>p(p2,d)</t></td><td>p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td></tr><tr><td>p.reset()</td><td>若p是唯一指向其对象的shared_ptr，reset将会是否次对象。</td></tr><tr><td>p.reset(q)</td><td>若传递了可选的参数内置指针q，会令p指向q，负责会将p置位空</td></tr><tr><td>p.reset(q,d)</td><td>若还传递了参数d，将会调用d而不是delete来是否q</td></tr></tbody></table><h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>智能指针使用规范</p><ol><li>不能使用相同的内置指针初始化多个智能指针</li><li>不delete get()返回的指针</li><li>不适用get() 初始化或者reset另一个智能指针</li><li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效的指针了。</li><li>如果使用智能指针管理的资源不是new分配的内存，记住传递一个删除器。</li></ol><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象。</p><table><thead><tr><th>unique_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>unique_ptr<t> u1</t></td><td>空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放他的指针，u2 会使用一个类型为D的可调用对象来释放他的指针</td></tr><tr><td>unique_ptr<t,d> u2</t,d></td><td></td></tr><tr><td>unique_ptr<t,d>u(d)</t,d></td><td>空的unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td></tr><tr><td>u = nullptr</td><td>释放u所指的对象，将u置位空</td></tr><tr><td>u.release()</td><td>u放弃对指针的控制权，返回指针，并将u置为空</td></tr><tr><td>u.reset()</td><td>释放u指向的对象</td></tr><tr><td>u.reset(q)</td><td>如果提供了内置指针q，令u指向这个对象，否则u置为空</td></tr><tr><td>u.reset(nullptr)</td></tr></tbody></table><p>传递unique_ptr参数和返回unique_ptr： 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或者赋值一个将要被销毁的unique_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象声明周期的指针。它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数器。</p><table><thead><tr><th>weak_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>weak_ptr<t> w</t></td><td>空的weak_ptr，可以指向类型为T的对象</td></tr><tr><td>weak_ptr<t> w(sp)</t></td><td>与shared_ptr sp指向相同对象的weak_ptr，T必须能转化为sp指向的类型</td></tr><tr><td>w = p</td><td>p 可以是一个shared_ptr 或一个weak_ptr。赋值后，w与p共享对象</td></tr><tr><td>w.reset()</td><td>将w置位空</td></tr><tr><td>w.use_count()</td><td>与w共享对象的shared_ptr的数量</td></tr><tr><td>w.expired()</td><td>若w.use_count()为0，返回true，否则返回false</td></tr><tr><td>w.lock()</td><td>如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++语言和标准库提供了一次分配一个对象数组的方法，C++中定义了另一种new表达式，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。</p><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>分配一个数组得到一个元素类型的指针：  由于分配的内存不是一个数组类型，因此不能对数组调用begin和end  ，我们必须记住，动态数组并不是数组类型。</p><p>初始化动态分配数组：默认情况下使用默认初始化，可以使用圆括号进行值初始化。</p><h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态内存和智能指针&lt;/li&gt;
&lt;li&gt;动态数组&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十二章 动态内存" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
    
      <category term="动态内存" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>泛型算法</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/</id>
    <published>2018-09-12T04:07:12.000Z</published>
    <updated>2018-09-14T02:21:25.708Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>概述</li><li>初始泛型算法</li><li>定制操作</li><li>再探迭代器</li><li>泛型算法结构</li><li>特定容器算法</li></ol><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p><p>算法永远不会执行容器操作：泛型算法本身不执行容器操作，他们只会运行于迭代器之上，执行迭代器的操作。这个特性带来一个非常惊人的编程假定：算法永远不会改变容器的大小。算法可能改变容器中元素的内容，可能在容器内移动元素，但永远不会添加或者删除元素。标准库定义定义了特殊的迭代器，插入迭代器。当算法操作这样的迭代器时迭代器可以完成向容器添加元素的效果，但算法永远不会做这种操作。</p><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>find accumulate equal  </p><p>除了少数算法外，标准库算法都对一个范围内的元素进行操作。我们将此元素的范围称为输入范围。接收输入范围的算法总是使用前两个参数来表示范围。两个参数分别表示第一个要处理的元素、尾元素之后位置的迭代器。</p><p>那些只接收一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p><h3 id="写容器元素算法"><a href="#写容器元素算法" class="headerlink" title="写容器元素算法"></a>写容器元素算法</h3><p>fill copy back_inserter replace_copy</p><h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词：是一个可调用表达式，其返回结果是一个能用作条件的值。</p><p>一元谓词：接受单一参数<br>二元谓词：接受两个参数</p><p>stable_sort算法：维持相等元素的原有顺序</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>find_if算法对输入序列中的每个元素调用这个谓词，它返回第一个使谓词返回非0的元素，如果不存在这样的元素，则返回尾迭代器。</p><p>可调用对象（cllable object）。对于一个对象或者一个表达式，如果可以对其使用调用运算符，则它为可调用对象。</p><p>可调用对象：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda表达式</li></ol><p>可调用对象可以理解为是一个未命名的内联函数</p><p>一个lambda表达式具有一个返回类型、一个参数列表、一个函数体，单与函数不同，lambda表达式可以定义在函数内部，一个lambda表达式的一般形式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">capture list</span>](<span class="link">parameter list</span>)-&gt; return type &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>与普通函数不同，lambda表达式使用尾置返回指定返回类型。</p><p>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。如果忽略返回类型，lambda根据函数体重的代码推断出返回类型。</p><p>与普通函数不同，lambda不能有默认实参。</p><p>一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些局部变量。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p><p>for_each算法接受一个可调用对象，并对输入序列中每个元素调用次对象。</p><p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量、它所在函数之外声明的名字。</p><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当向一个函数传递一个lambda时，同时定义了一个类型和该类型的对象：类似的，当使用auto定义一个用lambda初始化变量时，定义了一个从lambda生产的类型的对象。</p><p>值捕获：与参数不同，被捕获的变量的值在lambda创建时拷贝。而不是调用时拷贝。</p><p>引用捕获：必须确保被引用的对象在lambda执行的时候是存在的。</p><p>隐式捕获： &amp;搞事编译器采用引用捕获，=告诉编译器使用值捕获。混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是&amp;或者=。</p><p>可变lambda：默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变一个被捕获的变量的值。就必须在参数列表首加上关键字mutable。</p><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>bind标准函数 定义在functional中，可以将bind函数看做一个通用的函数适配器，他接受一个可调用对象，生成一个新的可调用对象来适应原来对象的参数。</p><p>bind的一般形式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto newCallable</span> = bind(callable,arglist);</span><br></pre></td></tr></table></figure><p>使用placeholders名字</p><p>_n定义在一个名为placeholders的命名空间。而这个命名空间定义在std命名空间中。</p><h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><ol><li>插入迭代器</li><li>流迭代器</li><li>反向迭代器</li><li>移动迭代器</li></ol><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>接受一个容器，生成一个迭代器，他实现向容器添加元素。当我们通过一个插入迭代器进行赋值时，改迭代器调用容器操作来向给定容器指定的位置插入一个元素。</p><ol><li>back_inserter</li><li>front_inserter</li><li>inserter</li></ol><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="5种迭代器"><a href="#5种迭代器" class="headerlink" title="5种迭代器"></a>5种迭代器</h3><ol><li>输入迭代器</li><li>输出迭代器</li><li>前向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li></ol><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;初始泛型算法&lt;/li&gt;
&lt;li&gt;定制操作&lt;/li&gt;
&lt;li&gt;再探迭代器&lt;/li&gt;
&lt;li&gt;泛型算法结构&lt;/li&gt;
&lt;li&gt;特定容器算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十章 泛型算法" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="泛型算法" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>空间配置器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第二章/空间配置器/</id>
    <published>2018-08-29T04:07:12.000Z</published>
    <updated>2018-08-30T04:02:17.349Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>空间配置器的标准接口</li><li>具备次配置能力的SGI 空间配置器</li><li>内存基本处理工具</li></ol><a id="more"></a><h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocator::</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间配置器的标准接口&lt;/li&gt;
&lt;li&gt;具备次配置能力的SGI 空间配置器&lt;/li&gt;
&lt;li&gt;内存基本处理工具&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第二章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
    
      <category term="空间配置器" scheme="http://yoursite.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>deque</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/deque/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第四章/deque/</id>
    <published>2018-08-28T04:07:12.000Z</published>
    <updated>2018-08-29T09:15:28.164Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>deque 概述</li><li>deque中控器</li><li>deque的迭代器</li><li>deque的数据结构</li><li>deque的构造与内存管理</li><li>deque的元素操作</li></ol><a id="more"></a><h2 id="deque-概述"><a href="#deque-概述" class="headerlink" title="deque 概述"></a>deque 概述</h2><p>vector是单向开口的连续性空间，deque则是一种双向开口的连续性空间，所谓双向开口，意思是头尾两端分别做元素的插入和删除操作.</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque1.png" alt="deque示意"></p><p>deque和vector的最大差异，一、在于deque允许常数时间内对起始头端进行元素的插入或移除操作。二、deque没有容量的概念，因为他是动态的以分段连续空间组合而成，随时可以增加一段空间并连接起来。换句话说，像vector那样“因旧空间不足而重新分配一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留功能。</p><p>虽然，deque也提供了random access iterator，但他的迭代器并不是普通指针。其复杂度和vector不可以道里计，这当然影响了各个运算层面，因此，除非必要，我们应该尽可能选择vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector身上，将vector排序后，再复制回deque。</p><h2 id="deque中控器"><a href="#deque中控器" class="headerlink" title="deque中控器"></a>deque中控器</h2><p>deque是连续空间（至少逻辑上看如此），连续线性空间总令我们联想到array和vector。array无法生长，vector虽可以生长，却只能向尾端成长。而且其所为成长是个假象，事实上是：</p><ol><li>另觅更大空间</li><li>将原数据赋值过去</li><li>释放原空间</li></ol><p>如果不是vector每次配置新空间时留下一些富裕，其成长假象所带来的代价相当昂贵。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在前端或者尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复制的带带器框架。</p><p>收到分段连续性空间的字面影响，我们可能以为，deque的实现复杂度和vector相比，虽不中亦不远矣，其实不然。主要以为，即曰分段连续线性空间，就必须有中央控制，为了维持整体连续的假象，数据结构的设计及迭代器前进后退操作都颇为繁琐。deque的实现代码分量远比vector或list多得多。</p><p>deque采用一块所谓map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处层位一个节点，node）都是指针，指向另一段较大的连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL 允许我们制定缓存区的大小，默认是0，表示将使用512bytes缓存区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">///元素的指针的指针</span></span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">map_poiner <span class="built_in">map</span>;<span class="comment">//指向map，map是快连续空间，其内的每个元素都是一个指针，指向一块缓存区</span></span><br><span class="line">size_type map_size; <span class="comment">//map内可容纳多少指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人头皮发麻的各种类型整理下，我们可发现，map其实是一个T**，也就是说他是一个指针，所指之物又是一个指针，指向类型为T的空间，如下图所示：</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque2.png" alt="deque的结构设计中，map和node-buffer的关系"></p><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><p>deque的分段连续空间，维持其“整体连续”假象的任务，落在了迭代器operator++、 operator– 两个运算子身上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;deque 概述&lt;/li&gt;
&lt;li&gt;deque中控器&lt;/li&gt;
&lt;li&gt;deque的迭代器&lt;/li&gt;
&lt;li&gt;deque的数据结构&lt;/li&gt;
&lt;li&gt;deque的构造与内存管理&lt;/li&gt;
&lt;li&gt;deque的元素操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第四章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>顺序容器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/</id>
    <published>2018-08-27T10:07:12.000Z</published>
    <updated>2018-09-11T11:15:46.987Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li>vector对象是如何生长的</li><li>额外的string操作</li><li>容器适配器</li></ol><a id="more"></a><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>容器在以下方面都有不同的性能折中：</p><ol><li>向容器添加或者删除元素的代价</li><li>非顺序访问容器中元素的代价</li></ol><table><thead><tr><th>容器类型</th><th>性能</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列，支持快速随机访问，在头尾位置插入、删除速度快</td></tr><tr><td>list</td><td>双向链表，只支持双向顺序访问，在list中任何位置插入、删除操作熟读都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问，在链表任何位置插入、删除操作都非常快</td></tr><tr><td>array</td><td>固定大小数组，支持快速随机访问，不能添加或删除元素</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入、删除快</td></tr></tbody></table><p>string、vector将元素保存在连续的内存空间，由于元素是连续存储的，由元素的下标计算其地址非常快。</p><p>list、forword_list两个容器的设计目的是令容器容器的任何位置添加、删除操作都很快</p><h2 id="容器概览"><a href="#容器概览" class="headerlink" title="容器概览"></a>容器概览</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不适用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>forword list 不支持递减运算符</p><p>迭代器范围中的元素包括first所表示的元素以及从first开始，直至last（但不包括last）之间的所有元素，左闭合区间。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">begin</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>使用左闭合范围蕴含的编程假定</p><ol><li>如果begin和end相等，则范围为空</li><li>如果begin和end不相等，则范围至少包含一个元素，且begin指向范围中的第一个元素</li><li>我们可以对begin递增若干次，使得begin==end</li></ol><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;<span class="string">""</span>iterator iter;</span><br></pre></td></tr></table></figure><h3 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h3><p> begin和end操作生成指向容器中第一个元素和尾元素之后的迭代器。</p><h3 id="容器的定义和初始化"><a href="#容器的定义和初始化" class="headerlink" title="容器的定义和初始化"></a>容器的定义和初始化</h3><table><thead><tr><th>容器的定义和初始哈</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数，如果C是一个array，则c中元素默认初始化，否则c为空</td></tr><tr><td>C  c1()c2 C c1 = c2</td><td>c1初始化为c2的拷贝，c1和c2必须类型相同,对于arrary，大小相同</td></tr><tr><td>C c{a,b,c,…} C c = {a,b,c,…}</td><td>c初始化为初始化列表中元素的拷贝</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b，e指定范围中的元素的拷贝</td></tr><tr><td>C seq(n) C seq(n,t)</td><td>seq 包含n个元素，这些元素进行了值初始化，此构造函数是explicit的</td></tr></tbody></table><p>容器的拷贝： 两种方式</p><ol><li>直接拷贝整个容器</li><li><p>拷贝迭代器指定的元素范围</p><p>当将一个容器初始化为另一个容器的拷贝时，两个容器类型和元素类型必须相同。</p><p>列表初始化：对于除了array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。</p><p>标准库array具有固定大小：标准库array的大小是类型的一部分，  array与内置数组的区别：array可以进行拷贝和对象赋值。</p><h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p>赋值运算符将其左边容器中全部元素替换为右边容器中元素的拷贝。</p><h3 id="容器的大小操作"><a href="#容器的大小操作" class="headerlink" title="容器的大小操作"></a>容器的大小操作</h3></li><li><p>size</p></li><li>empty</li><li><p>max_size</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>只有当其元素的类型定义了关系运算符，我们才可以使用关系运算符比较容器</p><h2 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>|操作|说明|<br>|—|—|<br>|这些操作不支持会改版容器的大小，array不支持这些操作||<br>|forward_list有专有版本的insert和emplace||<br>|forward_list不支持push_back和emplace_back，由于没有位指针，算法复杂度是o(n)||<br>|vector和string不支持push_font和emplace_font，也是算法复杂度的原因，整个元素需要移动，单可以通过inser做到||<br>|c.push_back(t)|在C的尾部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_back(args)||<br>|||<br>|c.push_font(t)|在C的首部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_font(args)||<br>|||<br>|c.insert(p,t)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素，  <font color="blue">前插</font>|<br>|c.emplace(p,args)||<br>|||<br>|c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，若n为0，则指向p|<br>|c.insert(p,b,e)|将迭代器b，e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器|<br>|c.insert(p,il)|il是花括号包围的元素值列表|<br>|向一个vector、string、deque插入元素，会使所有指向容器的迭代器、引用、指针失效|</p><p>使用push_back：除了array、forward_list之外，每个顺序容器都支持push_back。</p><p>当我们用一个对象初始化容器时，或将一个对象插入到容器中，实际上，放入到容器中的是对象的一个拷贝，二不是对象本身。</p><p>使用push_font：和vector一样，在deque首位之外的位置插入元素会很耗时。</p><p>在容器中的特定位置插入元素：insert提供了更一般的功能，它允许在容器中的任何位置插入0个或者多个元素。每个insert函数，都接受一个迭代器作为其第一个参数，迭代器指出了在容器的什么位置插入元素。</p><p>为什么是前插：因为迭代器可能只需容器外部之后不存在的元素的位置，所以只能前插。另外，在容器开始位置插入元素是很有用的功能。</p><p>我们可以使用insert将元素插入容器的开始位置，不用担心是否支持push_font。</p><p>如果我们传递给insert一对迭代器，他们不能指向添加元素的目标容器。</p><p>使用insert的返回值：通过使用insert的返回值，可以在容器中的一个特定位置反复插入元素。</p><p>emplace操作：新标准引入了三个成员：emplace、emplace_font 、emplace_back，这些操作构造而不是拷贝元素。</p><p>emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括array在内的所有容器都有一个font函数，而除了forword_list之外的所有容器都有一个back成员函数。这两个成员函数分别返回首元素和尾元素的索引。</p><p>|容器的访问操作|说明|<br>|—|—|<br>||at和下标操作只使用于string、vector、deque、和array|<br>||back不适用forward_list，算法复杂度的问题|<br>|c.back()|返回c的尾元素的引用|<br>|c.font()|返回c的首元素的引用|<br>|c[n]|返回c中下表为n的元素的引用|<br>|c.at(n)|返回下标为n的元素的引用。|</p></li></ol><p> 提供快速随机访问的容器（string、vector、deque、array）都提供下标运算符</p><p> at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range的异常。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table><thead><tr><th>删除操作</th><th>说明</th></tr></thead><tbody><tr><td></td><td>这些操作会给变容器的大小，不适用于array</td></tr><tr><td></td><td>forward_list有特殊版本的erase</td></tr><tr><td></td><td>forward_list不支持pop_back，string、vector不支持pop_font</td></tr><tr><td>c.pop_font()</td><td>删除c中的首元素</td></tr><tr><td>c.pop_back()</td><td>删除c中的尾元素</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器be所指范围内的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素</td></tr></tbody></table><p>###特殊的forward_list操作</p><p>特殊操作的原因：删除或者插入操作，我们需要访问它的前驱，以便改变前驱的链接，但是forward_list中，没有简单的方法获取一个元素的前驱。forward_list定义了insert_after、emplace_after、erase_after操作。before_begain，返回一个首前。</p><p>|forward_list操作|说明|<br>|lst.before_begain()|返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用|<br>|lst.cbefore_begain()||<br>|lst.insert_after(p,t)|在迭代器之后插入一个元素|<br>|lst.insert_after(p,n,t)||<br>|lst.insert_after(p,b,e)||<br>|lst.insert_after(p,il)||<br>|emplace_after(p,args)||<br>|lst.erase_after(p)||<br>|lst.erase_after(b,e)||</p><h3 id="改变容器的大小"><a href="#改变容器的大小" class="headerlink" title="改变容器的大小"></a>改变容器的大小</h3><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><h2 id="vector对象是如何生长的"><a href="#vector对象是如何生长的" class="headerlink" title="vector对象是如何生长的"></a>vector对象是如何生长的</h2><p> |容器大小操作|说明|<br> ||shrink_to_fit 只适用于vector、string、deque|<br> ||capacity和reserve只适用于vector、string|<br> |c.shrink_to_fit|请将capacity（）减少为size相同大小|<br> |c.capacity()|不重新分配内存空间的话，c可以保存多少元素|<br> |c.reserve（）|分配至少容纳那n个元素的内存空间|</p><h2 id="额为的string操作"><a href="#额为的string操作" class="headerlink" title="额为的string操作"></a>额为的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>说明</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标POS2开始的字符的拷贝，若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;vector对象是如何生长的&lt;/li&gt;
&lt;li&gt;额外的string操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第九章顺序容器" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="顺序容器" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO库</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/IO%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第八章io库/IO库/</id>
    <published>2018-08-27T04:07:12.000Z</published>
    <updated>2018-08-27T10:51:38.547Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>IO类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>进行IO操作的函数通常以引用方式传递、返回流。读写一个IO对象会改变其状态，因此，传递和返回的引用不能是const的。</p><h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>strm::iostate</td><td>strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td></tr><tr><td>strm::badbit</td><td>指出输出流已崩溃</td></tr><tr><td>strm::faillbit</td><td>一个IO操作失败</td></tr><tr><td>strm::eofbit</td><td>流达到了文件结尾</td></tr><tr><td>strm::goodbit</td><td>流未处于错误状态，此值保证为0</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若流s的failbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若流s的badbit置位，则返回true</td></tr><tr><td>s.good()</td><td>若流处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流的所有状态复位</td></tr><tr><td>s.clear(flags)</td><td>根据给定的flags标志位，将流s中对应的条件状态位复位</td></tr><tr><td>s.setstate(flags)将流s中对应条件状态位置位</td><td></td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态</td></tr></tbody></table><p>一个流一旦发生错误状态，其后续的IO操作都失败。只有流处于无错状态是，我们才可以从它读取数据、写入数据。</p><p>属性缓存区：</p><ol><li>endl， 换行并刷新缓冲区</li><li>flush ，刷新缓存区，不输出任何额为的字符</li><li>ends，向缓冲区插入一个空字符，然后刷新缓冲区</li></ol><p>unitbuf 操纵符：如果每次输出操作后，都属性缓存区，我们可以使用unitbuf操纵符。</p><p>如果程序崩溃，输出缓冲区不会被刷新。</p><p>tie： 如果本对象关联到一个输出流，则返回的就是这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>fstream fstrm</td><td>创建一个未绑定的文件流</td></tr><tr><td>fstream fstrm(s)</td><td>创建一个fstream，并打开名为s的文件。 s可以是string类型，或者是一个指向C风格字符串类型</td></tr><tr><td>fstream fstrm(s,mode)</td><td>安装mode打开文件</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定，返回void</td></tr><tr><td>fstrm.close()</td><td>关闭于fstrm绑定的文件，返回void</td></tr><tr><td>fstrm.is_open</td><td>返回一个bool，指出与fstrm关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>创建文件流对象时，我们可以提供文件名，如果提供了一个文件名，则open自动被调用。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><table><thead><tr><th>文件模式</th><th>说明</th></tr></thead><tbody><tr><td>in</td><td>以读方式打开</td></tr><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次写操作前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后，立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><h2 id="stirng流"><a href="#stirng流" class="headerlink" title="stirng流"></a>stirng流</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>sstream strm</td><td>strm是未绑定的stringstream对象</td></tr><tr><td>sstram strm(s)</td><td>strm 是一个sstream对象，保存string的一个拷贝，此构造函数是explicit的</td></tr><tr><td>strm.str()</td><td>返回strm中保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s 拷贝到strm中，返回void</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第八章io库" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/"/>
    
    
      <category term="IO库" scheme="http://yoursite.com/tags/IO%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>What’s New in User Notifications</title>
    <link href="http://yoursite.com/wiki/WWDC/What%E2%80%99s%20New%20in%20User%20Notifications/"/>
    <id>http://yoursite.com/wiki/WWDC/What’s New in User Notifications/</id>
    <published>2018-08-23T04:07:12.000Z</published>
    <updated>2018-09-12T05:53:35.631Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.<br>下午好，欢迎大家来这个叫做what’s new in user notifications的session </p><a id="more"></a><p>So there’s a range of topics to be covered today, and let’s begin with looking at grouped notifications. Now up to iOS 11, all new incoming notifications for the users were inserted in a chronological order in the notification list.<br>So these would be interspersed across multiple applications, and it would be hard for the user to find a certain notification or triage multiple notifications together.<br>So starting in iOS 12, we’ve decided to improve this by introducing notification grouping, so now, as you can see here, all notifications across different applications get grouped into their unique groups. Let’s take a deeper look at how grouped notifications works. Now all these notifications will be automatically grouped, so there’s nothing explicit that you need to do to start using notification grouping.<br>However, if you do want to have your own custom groups then you can use the thread identifier, which is an existing property on the UN notification content object.<br>So some of you might already be using the thread identifier and for a local notification.<br>You can set it on the UNMutableNotificationContent object as seen here.<br>And for a remote notification payload, you can also include it as part of your notification payload. Now the thread identifier might be familiar to some of you already. We use it today for forwarding notifications to a notification content extension that is presented for your application, which has the exact same thread identifier, allowing the content extension view to update it based on the new incoming notification. Starting in iOS 11, we started using the thread identifier for doing grouping of notifications, if the user had turned on [inaudible] notification previous. So we’re just taking this concept and expanding it for all notifications in general. So how does this grouping work? So when a new notification comes in to you, the user’s device, if there is no thread identifier set on this notification, then this notifications gets grouped with the application bundle. We can see that from our sample application here, that as new notifications are incoming, they are getting bundled with the same group and the group is getting updated with the latest content.<br>And then the user can simply expand this notification group to see all the notifications that are present in that group. On the other hand, if the notification does have a thread identifier set on it, then it gets grouped with all the other notifications from that same application with that exact same thread ID. What this also means is that the same application can then have multiple different custom groups, depending upon the unique thread identifiers that you’re setting on them. A good example of this is the messages application, where here you can see there are two different threads, and as new notifications are incoming, they are going to their own respective groups.<br>And then the user can expand a specific group to see all the notifications that are part of that group. So by using the thread identifier, messages is able to do so. Now, your application users also have the option of tweaking this notification grouping setting from your per application notification setting’s page.<br>Here, they get three options. If they choose automatic, then they get the behavior that we just described. However, the user also has the option of just grouping by application, where the system will ignore your thread identifier and group all notifications into a single group. And if the user wants the same behavior as it exists in iOS 11 today, then they can simply turn off grouping for your applications’ notifications. So do keep this in mind when you’re creating your own custom groups that they create enough value for users when they receive your applications’ notifications. Now what are the different components of a notification group? The content that we show is for the latest notification that was received as part of that group. And then the user can simply see all the notifications by tapping on this group, and we expand all the notifications’ content. And then the user can interact with all these notifications individually as well. The two buttons at the top give the users much greater control like collapsing the stack as well as clearing all these notifications together. Now, notification grouping also makes triaging of notifications much better. For example, in this case, the user can clear all these notifications together by simply swiping to the right and tapping clear all.<br>Apart from the content of the notification group, we also show a summary text.<br>Now, this summary text, by default, shows the count of all the notifications that are part of that group. However, you can also create a custom summary text so you can give your users much better context of what kind of information is included in that group. Now, we will cover this API and go over much larger use cases of how you can create your custom groups in the advanced session around using group notifications, which will follow this session. So let’s do a quick summary of group notifications as we saw them today. Starting in iOS 12, all application notifications are going to be grouped automatically.<br>You can start using the thread identifier if you want to create your own custom groups for your applications, but the user does have the option of changing this grouping setting for your applications’ notifications. And lastly, you can use the summary text for customizing the information you want to provide the user around the notification groups that you’re creating.<br>All right, so that was group notifications. Now, let’s move on to the next topic and talk about notification content extensions. Now, some of you might already be familiar with these content extensions that we included with iOS 10.<br>Content extensions allow your applications to present a rich notification view around the user’s notifications, so you can have a much more customized and interactive interface for the notification that the user is seeing. Let’s do a quick recap of setting up these content extensions. Xcode gives you a standard template to add a target for the content extensions to your applications and once you set that up, we create a default class for the notification view controller, which implements the UNNotificationContentExtension protocol. Here, the did receive notification method is important because this is your entry point for setting up the view associated with the content extension, and you can use the notification object past here to get all the information around that notification to set up your custom view.<br>The info.plist file associated with your content extension gives you more options.<br>The important thing here is the category identifier. Now, this identifier needs to match the same category identifier you’re setting on your notification requests because that’s how the system knows which content extension to launch with which notification.<br>Along with this, you can do some quick configurations of your content extension such as setting the initial content size ratio, hiding the default content, as well as overriding the title of this content extension. Now, the primary way in which your users interact with these content extensions is through notification actions, and these actions are presented right below the content of the content extension.<br>Let’s summarize how we can set up these actions as well. So doing so is fairly trivial in code. For example, here, we have two actions here for like and comment, and we create a simple UNNotificationAction for like and a text input action for commenting. And once we’ve created these actions, we create a new category giving it the same identifier as the content extension where we want these actions to be presented. And then, we pass it, the two new actions that we created.<br>Once we’ve set up this category, then we call setNotificationCategories on the UNNotificationCenter object associated with our class, giving it the new category that we created. So by simply doing so, the next time when the user goes to your content extension we can see that these actions are now available for them to interact with your notification content. Now let’s take a look at how we can handle the responses from these actions. There are two ways to do that. Firstly, you can handle this response in the AppDelegate that is associated with your application that implements the UNUserNotificationCenter Delegate protocol. Here, the function UserNotificationCenter did receive response, includes the response object which includes information about the request, the notification request from which the user took this action.<br>However, the content extension also allows you to intercept this action response so that you can update your view and make a much more interactive and dynamic experience for users for the content extension. So for our sample here, we enter the did receive response method and checked the action identifier for the like action. And then we update our UI with the new label as well as update our application state. Finally calling the completion block we do not dismiss. If you do want to dismiss your content extension view here, then you can simply change the parameter you’re passing to the completion block to dismiss or dismiss and forward, where we will forward this response to your AppDelegate function as well. All right, so now that we set this up, we can see that when the user takes the like action, the content extension content gets updated right there and then. So it’s a much more interactive experience for your user and they’re getting real-time feedback. However, if you look at the current state of the content extension, we see that there is some redundant information.<br>The user has already taken the like action, so having the action there doesn’t really serve a purpose anymore. Now notification actions, in general, have certain limitations. They are not very dynamic and can’t be updated based on the context of your content extensions. Also, these tend to be tied to the notification categories that you have to define at the time of your application setup.<br>So we wanted to address these issues and we have introduced a new API around notification actions, where now we’re exposing these notification actions as part of the NSExtensionContext tied to your content extension. What this API allows you to do is access the currently presented notification actions to the user as well as replace these actions by setting a brand new array of notification actions for your content extension. So going back to our sample, what if after the user took the like action we wanted to replace it say with the unlike action so that they can do the reverse of the action they just took? So using this new API, let’s take a look of how we can set this up. So we go back to our did receive response method and again identify the like action and update our application state. This time, we also create a new action for unlike, giving it a unique identifier as well as a title.<br>We can also take a look at the currently presented actions so that we can extract the comment action from there without having to create it again. Then we create a new array of these new actions that we’ve created and simply set that on the notification actions variable. So once we’ve done this and the user takes the like action, then the UI will automatically update to show them the new action, and then the user can then toggle between the two actions, depending upon how you handle that state in your content extensions. Now, this API can be used in multiple other ways as well.<br>For example, now you can set your actions at the time you’re setting up your content extension view in the did receive notification method. What this means is your notification requests are no longer tied to the category to define the actions that you want to present around these notifications. You can also now present a secondary set of actions by replacing the currently presented actions.<br>For example, if the leading action was rate, then you can provide a secondary list of the different types of ratings that you want your user to take. And you can also remove all these notification actions if you feel it does not make sense anymore for your content extension to present these actions. So that’s the new API around notification actions. And we feel this will really help you enhance the experience that your users have around your content extensions with the different actions now you can present to them. Let’s move on and talk about user interaction with these content extensions. Now notification actions were important up till this point because till iOS 11 we did not allow user interaction touches with your content extension view. Now we received a lot of feedback around this.<br>And I’m happy to announce that we’re taking away this restriction with iOS 12.<br>So now your content extensions have the option of opting in to receiving user interaction [inaudible] touches, and setting this up, it’s fairly trivial.<br>All you have to do is add a new key value option to your info.plist file.<br>And the key that we’ve added is the UNNotificationExtensionUser InteractionEnabled.<br>So going back to our sample, what if we want to remove the like action from a notification action and make it a UI interaction touch that’s part of the view itself? So once we’ve configured our info.plist file, we can go back to our content extension view and create our own custom button to handle the like gesture. We add a target for our own private method and inside that function, we update the UI as well as update our application state. So here, it’s important that since you’re implementing your own user interactions that you are responsible for handling all these actions, responses, and callbacks from the users yourself. So once we’ve set this up, now when the user goes to your content extension we see the Like button, part of the UI itself, and the user can simply interact with that button right there and then.<br>So that’s the new functionality that we’ve added around content extensions.<br>And coupled with notification actions, along with user interaction touches, you now have a much richer set of tools for creating much more interactive and dynamic content extension experiences for your applications notifications users.<br>Now let’s talk about launching your application from the notification content extension.<br>So today the user can launch your application if touches were not allowed by simply tapping the content extension view. They could also do so by tapping your application icon in the top left corner. Or you could create a foreground action, which then would in turn launch the application. But what if you wanted to do this from your own custom control? What if you wanted to launch the application programmatically? To enable this, there is a new API on the NSExtensionContext called performNotification DefaultAction, which would allow you to do this now. Now, what does the default action mean? So, as we said, it launches the application, but at the same time, it calls the UserNotificationCenter did receive response method in your application delegate. Now the UNNotificationResponse object contains the information of the notification from which the user came, so you can update your application state based on the notification. And the identifier that’s passed here is the UNNotificationDefault ActionIdentifier. So going back to our sample, let’s see how we can set this custom control up. Now again, we create our own UI button for the all comments and then tie it up with our own private function.<br>And in that function, we’re simply calling PerformNotification DefaultAction. So by simply doing that, you get this functionality to call this method programmatically from anywhere in your content extension code.<br>So that was launching the application. What about dismissing the content extension view? Again, let’s take a look at how the user can do that today.<br>They can do that by tapping the Dismiss Button in the top right corner, or you can create your own custom notification action, which would in turn dismiss the content extension view.<br>Which you can set up, as we saw before, by passing dismiss to the completion block.<br>But again, what if we want to dismiss the view through our own custom buttons, and we want to do this programmatically? Say that when the user taps the Like button, then the view dismisses because we feel the user’s done interacting with the content extension.<br>To enable this as well, there’s a new API called dismissNotificationContent Extension that’s on the NSExtensionContext. We go back to how we set up our Like button, and now this time, we also call the new function that we added for dismissing the content extension view. And once we set this up, now when the user takes the like action, the view of the content extension gets dismissed. Now one thing to note here.<br>That calling this method does not withdraw the notification that was posted to the user.<br>If you want to do that then use the existing API for removing delivered notifications with identifiers to get that functionality. All right, now let’s summarize all the new APIs that we’ve looked at today around the notification content extensions.<br>We started with talking about notification actions where now you can access these notification actions as well as replace them dynamically from anywhere in your content extension code. You can now opt in to having user interaction based on touches within your content extension views. You can programmatically launch the application from anywhere in your content extension code as well as dismiss the content extension view, depending upon where you feel it serves best your user’s experience around the content extensions. So that’s a varied list of APIs around content extensions, and we hope this really helps you enhance your user’s experience around your content extensions and then you start using these APIs. So that was notification content extensions. Now, the next topic today we’re going to look at is notification management, and to tell you all about that, let me invite my colleague Teja to the stage.<br>Thank you. Thank you Kritarth.<br>Hi everyone. My name is Teja Kondapalli, and I’m also an engineer on the iOS Notifications’ Team. And, of course, I’m here to talk to you about a couple of the new APIs that we have. The first of which is notification management.<br>But before I dive into this API, I want to cover some of the user facing features to give you some more context and then we can deep dive into the API. As our users get more and more apps on their phones, notifications become the primary way that they interact with these apps. But often, they find themselves in a situation like this.<br>With far too many notifications. And it becomes hard to sift through and find the important ones. So perhaps to make this easier, this user has decided that notifications from podcasts don’t need to be shown on the locked screen.<br>Right now to configure that they’d have to launch the settings app, find notifications, find the podcast app, and then they can configure their settings.<br>We wanted to make this easier. So, in iOS 12, we’re introducing a new management view where the users can configure their notification settings directly from the notification without having to launch the settings app. There’s three really easy ways to get into this management view. The first is what we just saw.<br>You simply swipe over a notification, tap manage, and the management view comes up.<br>The second is if you can go into the rich notification, you can tap in the right corner, and you can also launch the management view. And the third is actually in the list itself. Depending on how your users are interacting with their notifications, they will occasionally see suggestions, like this one, that ask them if they want to keep receiving podcast notifications. And from here, as well, they can tap manage and bring up the management view. Let’s take a closer look at the management view. And we obviously have options here where users can configure their notification settings directly from this view. But if they want to go into the settings app and configure in a more detailed manner, they have a quick link to the settings for this application, the notification settings. A And also from this view, they have some actions they can take directly, the first of which says deliver quietly, which is probably a concept that’s new to all of you. Some of these management views will also have an option that says deliver prominently, so let’s talk about what this means. In iOS, we have a lot of settings that users can configure, and this is really great for the power user. The can customize their settings to every detail, but for the regular user, we think that we can help them out by categorizing their notification settings into two big categories.<br>Notifications that are delivered prominently and notifications that are delivered quietly.<br>Notifications that are delivered prominently are what we’re used to.<br>They show up on the locked screen. They show up in notification center. They roll down as banners. They badge the AP icon and they can play a sound. Notifications that are delivered quietly only show up in notification center and they don’t play a sound. And from the management view, in addition to configuring whether they want their notifications delivered prominently or quietly, users also have the option to turn off their notifications.<br>Now, I know that you might worry that your users are going to turn off the notifications for your app, so we’ve added this extra confirmation sheet just in case they do tap turn off.<br>And from here, they can also turn off their notifications. But we’ve also added an API to add a second option to this confirmation sheet, and podcast has taken advantage of this API, so it says configure in podcast. This is a link that will deep link within the podcast app to a custom settings view that allows the user more granular control about what kind of podcast notifications they want. And as your apps send more and more notifications and various type of notifications, we think it’s really important to allow them this granular level of control over what kind of notifications are important to them.<br>This link can also be accessed from the systems settings app from your apps’ notification settings. And you can see for podcasts it’s right at the bottom.<br>It says podcast notifications settings. Let’s see how we do this in code. In the class that conforms to UNUserNotificationCenter Delegate, we have a new delegate method. Open settings for notification, and as long as you implement this delegate method, those links that we talked about from the management view, or from the settings app, will automatically be populated by the system for you. So when the user taps on any of these links, this delegate method will be called. And it’s really important when this delegate method is called that you immediately take your users into the view where they can configure their notification settings within your app. And if you notice, we have [inaudible] parameter to this method, and it is notification. So depending on where the link was tapped from, if it was tapped from one of the management views, it will have the value of the notification that that management view came from. If it was tapped from the settings app, the value of notification will be nil, and you can use this information to show the appropriate notification settings when this delegate method is called.<br>So that’s what we have for notification management. It’s a new way for your users to configure whether they want their notifications delivered prominently or quietly, or turn them off, or even configure them at a granular level within your app.<br>And to encourage your users to keep getting your notifications delivered, we think it’s really important that you make the content in the notifications relevant.<br>We also encourage you to use thread identifiers to group the notifications when you think it’s appropriate. This will help the users organize their lists better and will make sure that they’re not overwhelmed by the notifications from your app.<br>We also think that as your apps send various types of notifications, it’s really important to provide that custom settings view within that app so that users have more granular control about what kind of notifications are important to them.<br>That’s what we have for notification management. And the next big feature I want to talk to you about is provisional authorization. Right now, when a user installs your app, before they start receiving notifications, at some point they’ll have to respond to a prompt that looks like this, which is asking them if they want these notifications.<br>And the biggest problem with this is, at this point, the user doesn’t know what kind of notifications this app is going to send, so they don’t know if they want them or not.<br>So, in iOS 12, we’re introducing provisional authorization, and this is an automatic trial of the notifications from your app. This will help your users make a more informed decision on whether they want these notifications or not. So you can opt into this, and if you do, your users will not get that authorization prompt that we just saw.<br>Instead, the notifications from your app will automatically start getting delivered.<br>But these notifications will be delivered quietly, and if we recall, notifications that are delivered quietly only show up in notifications center, and they don’t play a sound.<br>Notifications that are delivered with provisional authorization will have a prompt like this on the notification itself. And this will help the users decide after having received a few notifications whether they want to keep getting these notifications or whether they want to turn them off. And this turn off confirmation sheet will also have the custom settings link if you have provided it. Let’s see how you can do this in code. In the location where you regularly request authorization, in addition to whatever options you might be requesting, you can add a dot qualifying option called .provisional. And if you include this, you will automatically start participating in the trial. It’s really important to note that the .provisional option is in addition to whatever other options you may be providing. That’s because if the users decide to keep getting your notifications delivered, we want to know how you want them delivered, with badges or sounds or as alerts. So that’s what provisional authorization is. It’s an automatic trial of the notifications from your app to help your users make a more informed decision about whether they want these notifications.<br>And again, to encourage your users to keep getting your notifications delivered, it’s really important to make the content in your notifications relevant.<br>And also, it’s really important to use .provisional as a qualifier option in addition to whatever other options you’re requesting. That’s what we have for provisional authorization. And the last big feature that I want to talk to you about are critical alerts. Often when I’m in the middle of a meeting or attending something important, my phone looks like this. And as you can see, I have do not disturb turned on. Or at least I have the ringer switch turned off so that I don’t hear any sounds when I get notifications. And usually this is really good, but I would have missed a really important notification like this one.<br>This is a health-related notification. That’s from a glucose monitor that’s warning me of low blood sugar, and this is something I would want to see immediately.<br>Scenarios like this made us realize that we need a new type of notification, and this is what we call critical alerts. Critical alerts are medical- and health-related notifications.<br>Or home- and security-related notifications. Or public safety notifications.<br>And the key to a critical alert is that it requires the user to take action immediately.<br>The way that critical alerts behave is that they bypass both do not disturb and the ringer switch, and they will play a sound. And they can even play a custom sound. But what that means is that these are very disruptive, and for that reason we don’t think that all apps should be able to send critical notifications.<br>Critical alerts. So in order to start sending a critical alert, you will need to apply for entitlement, and you can do that on the developer.apple website.<br>This is what a critical alert looks like, and you can see that it has a unique icon indicating that it’s critical. And it would have also come in with a sound.<br>Critical alerts also have their own section in notifications settings.<br>This means that a user can choose to allow critical alerts for a particular application but choose not to allow any other type of notification. And before users start receiving critical alerts, they will have to accept a prompt that looks like this that’s asking them specifically whether they want to accept critical alerts from a particular application.<br>So, of course, in order to start sending critical alerts, you’ll have to request authorization.<br>So after you apply for entitlement and get it, in the place where you regularly request authorization, in addition to whatever other options you want to request, you can also request a .criticalAlert option. And this will give your users the prompt. And let’s see how it actually set up and send a critical alert. It actually behaves very similarly to a regular notification. You can see that I just set up a notification with the title body and category identifier, but what distinguishes this as a critical alert is that it plays a sound. So I need to set a critical alert sound.<br>And here, you can see that I’m setting the default critical alert sound that’s provided by the framework. I can also set a custom sound. And I can also set a custom audio volume level. And of course, critical alerts can also be push notifications so all of this information can be set in the push payload as well.<br>So that’s what we have for critical alerts. They’re a new type of notification that requires the users to take action immediately.<br>And they’re very disruptive, so you need entitlement to be able to send them.<br>So that’s all the new exciting APIs that we have for you today. I just want to quickly go over all the things that we covered. We talked about how you can use thread identifiers to group your notifications to help your users organize their notification lists better.<br>We talked about all the great new APIs around notification content extensions, which will help you make your rich notifications much more interactive.<br>We talked about how you can provide a custom settings view within your app to allow your users more granular control over what kind of notifications they want to receive.<br>We also talked about provisional authorizations, which is an automatic trial of the notifications from your app, which will help you users make a more informed decision about whether they want these notifications or not. And last, we talked about critical alerts, which are a new type of notification that requires the user to take action immediately and that are disruptive. So we hope you take advantage of all of these great APIs and make the notification experience for your users even better.<br>You can find all the information about this session on our sessions’ page at developer.apple.com. We’re session 710. We have another session just following this one in hall three called using grouped notification where we’ll help you determine how to best group notifications for your app. We have two notifications labs, one today and one tomorrow, where you can come and ask the engineers on our team any questions that you may have. And on Friday morning, we have an interesting session called designing notifications. That’s going to be hosted by the designers who helped us come up with the designs for these, and they’ll be talking about notification best practices.<br>Thank you and have a great dot dot.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.&lt;br&gt;下午好，欢迎大家来这个叫做what’s new in user notifications的session &lt;/p&gt;
    
    </summary>
    
      <category term="WWDC" scheme="http://yoursite.com/categories/WWDC/"/>
    
    
      <category term="Notifications" scheme="http://yoursite.com/tags/Notifications/"/>
    
  </entry>
  
  <entry>
    <title>IOS12 兼容</title>
    <link href="http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/"/>
    <id>http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/</id>
    <published>2018-08-22T04:07:12.000Z</published>
    <updated>2018-09-13T08:02:47.563Z</updated>
    
    <content type="html"><![CDATA[<p>主要遇到的问题：</p><ol><li>Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</li><li>CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中</li></ol><a id="more"></a><h2 id="libstdc-问题"><a href="#libstdc-问题" class="headerlink" title="libstdc++问题"></a>libstdc++问题</h2><ul><li>现象是无法找到libstdc++，编译报错如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">library</span> <span class="selector-tag">not</span> <span class="selector-tag">found</span> <span class="selector-tag">for</span> <span class="selector-tag">-lstdc</span>++<span class="selector-class">.6</span><span class="selector-class">.0</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><ul><li>临时解决办法—-从Xcode9中复制libstdc++库到Xcode10中，命令如下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span></span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span></span><br></pre></td></tr></table></figure><ul><li>最终解决办法：</li></ul><p>需要联系第三方公司，将GMThirdParty/BestPay 、GMF_EaseMobSDK2.2.9更新。</p><h3 id="模拟器无法启动的解决方案"><a href="#模拟器无法启动的解决方案" class="headerlink" title="模拟器无法启动的解决方案"></a>模拟器无法启动的解决方案</h3><p>报错如下：    </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library not <span class="symbol">loaded:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span></span></span><br><span class="line">  Referenced <span class="symbol">from:</span> /Users/lijian/Library/Developer/CoreSimulator/Devices/<span class="number">6</span>CB2CF98-<span class="number">149</span>C-<span class="number">43</span>A1-<span class="number">8</span>A93-<span class="number">516</span>FE4243C8C/data/Containers/Bundle/Application/<span class="number">2</span>C25BADD-A36F-<span class="number">4</span>B11-<span class="number">9885</span>-<span class="number">34E8</span>AEE826AC/GomeStaff.app/GomeStaff</span><br><span class="line">  <span class="symbol">Reason:</span> no suitable image found.  Did <span class="symbol">find:</span></span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span>: <span class="title">mach</span>-<span class="title">o</span>, <span class="title">but</span> <span class="title">not</span> <span class="title">built</span> <span class="title">for</span> <span class="title">iOS</span> <span class="title">simulator</span></span></span><br></pre></td></tr></table></figure><p>原因分析： </p><p>上面的错误的含义是动态链接器无法加载到libstdc++.6.dylib，但是真机上是可以加载出来，所以，推测模拟器的运行环境去掉了这个库，那么，我们如果将模拟器的运行环境中添加上这个库，是不是就可以了？ 答案是肯定的。</p><p>下面的问题是：我么如何找到模拟器运行环境加载库的路径呢？ 我的思路是使用xcode9运行模拟器，然后打印系统库的加载路径，这个路径就是我们要找的路径。</p><p>查找系统库的方法如下,用xcode9运行下面的代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; _dyld_image_count(); i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> char* aa = _dyld_get_image_name(i)<span class="comment">;</span></span><br><span class="line">    NSString *str = [NSString stringWithUTF8String:aa]<span class="comment">;</span></span><br><span class="line">    LOG_LJ_(@<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~%@"</span>,str)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Users/lijian</span><span class="regexp">/Downloads/</span>Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libiconv</span>.2.<span class="title">dylib</span></span></span><br></pre></td></tr></table></figure><p>上面的路径就是模拟器的系统库路径。所以，将xcode9对应目录下的三个libstdc++复制到xcode10的对应目录即可。</p><h2 id="CocoaPods无法复制资源到app中"><a href="#CocoaPods无法复制资源到app中" class="headerlink" title="CocoaPods无法复制资源到app中"></a>CocoaPods无法复制资源到app中</h2><p>现象：登录界面没有图标，或者启动时 NSBundle的initWithUrl方法崩溃。</p><p>解决办法：</p><ol><li>升级CocoaPods到1.4.0，命令是：<code>sudo gem install -n /usr/local/bin cocoapods -v 1.4.0</code> 。</li><li>移除<code>Build Phases</code> 中的 <code>[cp]Copy Pods Resources</code> 。</li><li>重新pod install。</li></ol><h2 id="info-重复问题"><a href="#info-重复问题" class="headerlink" title="info 重复问题"></a>info 重复问题</h2><p>报错如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiple commands produce <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span>:</span><br><span class="line"><span class="number">1</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> <span class="keyword">copy</span> command <span class="keyword">from</span> <span class="string">'/Users/lijian/Desktop/GomeGit/GomeStaff/GomeStaff/Supporting Files/Info.plist'</span> <span class="keyword">to</span> <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br><span class="line"><span class="number">2</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> process command <span class="keyword">with</span> output <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br></pre></td></tr></table></figure><p>原因分析：Xcode自动会将Info.plist复制到GomeStaff.app中，但是在Build Phases-&gt; Copy Bundle Resources中也包含复制Info.plist的功能，这样就两次复制，第二次复制失败。</p><p>解决方法：</p><p>将Build Phases-&gt; Copy Bundle Resources  中的info.plist 去掉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5b1634f0f265da6e61788998" rel="external nofollow noopener noreferrer" target="_blank">Xcode10和iOS12踩坑</a></li><li><a href="http://www.cocoachina.com/ios/20180611/23749.html" rel="external nofollow noopener noreferrer" target="_blank">libstdc++适配Xcode10与iOS12</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要遇到的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。&lt;/li&gt;
&lt;li&gt;CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="IOS12" scheme="http://yoursite.com/categories/IOS/IOS12/"/>
    
    
      <category term="IOS12 兼容" scheme="http://yoursite.com/tags/IOS12-%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>类</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/%E7%B1%BB/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第七章类/类/</id>
    <published>2018-08-20T04:07:12.000Z</published>
    <updated>2018-09-19T10:52:28.140Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>定义抽象数据类型</li><li>访问控制与封装</li><li>类的其他特性</li><li>类的作用域</li><li>构造函数再探</li><li>类的静态成员</li></ol><p>数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。</p><a id="more"></a><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="一、设计Sales-data类"><a href="#一、设计Sales-data类" class="headerlink" title="一、设计Sales_data类"></a>一、设计Sales_data类</h3><ol><li>一个isbn成员函数，返回对象的ISBN编号</li><li>一个combine成员函数，用于将一个Sales_data对象加到另一个对象上</li><li>一个名为add的函数，执行两个Sales_data对象的加法</li><li>一个read函数，将数据从istream读入到Sales_data对象中</li><li>一个print函数，将Sales_data对象的值输入到ostream </li></ol><h3 id="二、定义改进的Sales-data类"><a href="#二、定义改进的Sales-data类" class="headerlink" title="二、定义改进的Sales_data类"></a>二、定义改进的Sales_data类</h3><p>定义在类内部的函数隐式的inline函数。</p><p>成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。对我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">total</span><span class="selector-class">.isbn</span>()</span><br></pre></td></tr></table></figure><p>则编译器负责把total的地址传给isbn的隐式参数this，可以等价的认为编译器将该调用重写成如下形式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Sales_data:</span>:isbn(<span class="variable">&amp;total</span>);</span><br></pre></td></tr></table></figure><p>this是常量指针，我们不允许改变this中保存的地址。</p><p>const成员函数： 紧随参数列表后面的const关键字表示const成员函数。这里的const的所用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。这也意味着我们不能把this绑定到一个常量对象上。不能在一个常量对象上调用普通成员函数。</p><p>常量对象以及常量对象的引用或者指针都只能调用常量成员函数。</p><p>类的作用域和成员函数： </p><ol><li>返回类型、参数列表、函数名都得于类内部的声明一样</li><li>如果成员被定义成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。</li><li>类外部定义的成员的名字必须包含所属的类名</li></ol><h3 id="三、定义类相关的非成员函数"><a href="#三、定义类相关的非成员函数" class="headerlink" title="三、定义类相关的非成员函数"></a>三、定义类相关的非成员函数</h3><p>IO类属于不能拷贝的类型，所以只能通过引用来传递他们，而且，因为读取和写入的操作会改变流的内容，所以两个函数接受都是普通引用，而非对常量的引用。</p><h3 id="四、构造函数"><a href="#四、构造函数" class="headerlink" title="四、构造函数"></a>四、构造函数</h3><p>类通过特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时，只要类的对象被创建，就会执行构造函数。</p><p>构造函数的名字和和类名相同，和其他函数不一样的是，构造函数没有返回类型。</p><p>构造函数不能声明为const的，当我们创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得常量属性，所以构造函数在const对象构造的过程中，是可以向其写值的。</p><p>合成的默认构造函数：类通过特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。合成默认构造函数初始化规则：</p><ol><li>如果存在类内初始值，用它初始化</li><li>否则，默认初始化</li></ol><p>某些类不能依赖合成的默认构造函数，原因有三：</p><ol><li>只有当类内没有声明任何构造函数时，编译器才会自动的生产默认构造函数。</li><li>如果累内部有内置类型或者符合类型成员，则只有当这些成员全部被赋予了类内初始值时，这个类才适合使用合成的默认构造函数。</li><li>有些类不能合成默认的构造函数</li></ol><p>=default： 如果我们定义了其他的构造函数，同时，也需要默认构造函数，并且默认构造函数的功能等同于合成的默认构造函数，使用=default来要求编译器生成构造函数。如果=default在类的内部，则是内联的。</p><p>构造函数初始值列表：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(const <span class="attribute">std</span>::string &amp; s,unsinged n, double p)<span class="selector-pseudo">:bookNo(s)</span>,<span class="selector-tag">unit_sold</span>(n),<span class="selector-tag">revenue</span>(p*n)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>冒号和花括号之间的代码称为构造函数初始值列表。当某个数据成员被构造函数初始值列表忽略时，他将以合成默认构造函数相同的方式隐式初始化。</p><h3 id="拷贝、赋值、析构"><a href="#拷贝、赋值、析构" class="headerlink" title="拷贝、赋值、析构"></a>拷贝、赋值、析构</h3><p>拷贝、赋值、析构发生的场景</p><ol><li>拷贝：初始化变量、以值的方式传递、返回一个对象。（用同类型的对象或者自己类型的对象）</li><li>赋值：使用赋值运算符时发送。</li><li>析构：当对象不存在时销毁，超出作用域、vector容器销毁时存储在其中的对象销毁</li><li>构造： 用成员的值创建（不是自己的类型）</li></ol><p>如果我们不主动定义这些操作。编译器将替我们合成默认的。编译器生成的版本将对对象的每个成员执行拷贝、赋值、销毁操作。</p><p>某些类不能依赖合成的版本：例如动态类型。vector、string能避免分配和释放内存带来的复杂性。如果类中包含vector、string，合成的版本能正常工作</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符（access specifiers）控制类的封装性</p><ol><li>定义在public说明符后面的成员在整个程序内可以被访问。public成员定义类的接口</li><li>定义在private说明符之后的成员可以被类的成员访问，但不能被类的使用者访问。private部分封装了类的实现细节。</li></ol><p>使用class、struct关键字：class和struct定义的唯一区别是默认的访问权限。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的。如果是class，则是private。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他的类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元（friend），如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。</p><p>友元声明只能出现在类定义的内部，但是在类内部出现的位置不限，友元不是类的成员，也不受它所在区域访问控制级别的约束。</p><p>封装的优点：</p><ol><li>用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ol><p>友元的声明：友元的声明仅仅指定了访问权限，而非一个通常意义上的声明，如果我们需要类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。</p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>这些特性包括：类型成员、类的成员的类内初始值、可变数据成员、从成员返回this* 、关于如何定义并使用类类型及友元类。</p><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>类型成员： 某种类型在类中的别名。类定义的类型名字和其他成员一样，存在访问控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pos cursor = <span class="number">0</span>;</span><br><span class="line">pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型成员必须先定义后使用。 和类的其他成员的区别</p><p>因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认构造函数，如果我们的类需要默认构造函数，必须显示的把他声明出来。</p><p>令成员作为内联函数：定义在类内部的成员函数自动是inline的。</p><p>我们无需在声明和定义的地方同时说明inline，单这么做是合法的。不过最好只在类的外部定义的地方说明inline，这样可以使类更容易理解。</p><p>inline成员函数也应该与相应的类定义在同一个头文件中。</p><p>重载成员函数：和普通成员函数一样。</p><p>可变数据成员： 有时，我们希望能修改类的某个数据成员，即使是在一个const成员函数。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员永远不会是const的，即使const对象的成员。</p><p>类内初始值：必须使用等号或者花括号</p><h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>从const成员函数返回<em>this，一个const成员函数如果以引用的形式返回</em>this，那么他的返回类型将是常量引用。</p><p>基于const的重载：通过成员函数是否是const的，我们可以对其进行重载。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>类的声明： class Screen </p><p>对于类型Screen来说，在它的声明之后定义之前，是一个不完全类型（incomlete type）。也就是说，此时我们已知Screen是一个类类型，但是不清楚他到底包含哪些成员。</p><p>不完全类型只能在非常有限的情景下使用，可以定义指向这种类型的指针或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数</p><h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把其他的类定义成友元，也可以把其他类（之前定义过的）的成员函数定义成友元</p><p>类之间的友元：如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元不存在传递性</p><p>令成员函数作为友元：</p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了。这里的剩余部分包括参数列表、函数体。</p><p>函数的返回类型通常出现在函数名之前，因此，当成员杉树定义在类的外部，返回类型中使用的名字都位于类的作用域之外。</p><h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p>名字查找（name lookup）</p><p>普通名字查找：</p><ol><li>在名字所在的块中寻找其声明语句，只考虑名字的使用之前出现的声明</li><li>如果没有找到，继续查找外层作用域</li><li>如果最终没有找到匹配的声明，则程序报错</li></ol><p>类的定义步骤：</p><ol><li>首先，编译成员的声明</li><li>知道类全部可见后，编译函数体</li></ol><p>编译器处理完类中的全部声明后，才会处理成员函数的定义</p><p>用于类成员声明的名字查找：上面两阶段的处理方式只适用于成员函数中适用的名字，声明中使用的名字，包括返回类型、参数列表中使用的名字，都必须在使用前确保可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal;&#125;;</span><br><span class="line"></span><br><span class="line">Money bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money 出现在声明中，所有从使用处开始找名字，找到了外层的double。 balance 函数体，等成员声明编译完后，处理，所以bal是成员。不是外层的string。</p><p>类型名需要特殊处理：类内部不能重新定义外层作用域中的类型名字，类内部的类型名字定义放在类的开始处，</p><p>成员定义中的普通块作用域中的名字查找：</p><ol><li>首先在成员函数内查找名字的声明，只有在函数使用前面出现的声明才被考虑</li><li>如果在成员函数内没有找到，则在类内继续查找，这是类的所有成员都可以考虑</li><li>如果类内也没有该名字的声明，在成员函数定义之前的作用域内继续查找。</li></ol><p>不建议成员的名字作为某个成员函数的参数。</p><p>类作用域之后，在外围作用域中查找：  可以使用::访问隐藏的外层中的名字 。</p><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示的初始化成员，则该成员在构造函数体之前执行默认初始化。</p><p>构造函数的初始值有时必不可少：有时候我们可以忽略数据成员的初始化和赋值之间的差异，单并非总是这样，如果成员有const或者引用的话，必须将其初始哈。</p><p>随着构造函数体的开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。</p><p>成员是const、引用或者属于某种未提供默认构造函数的类型。我们必须通过构造函数初始值列表为这些成员提供初始值。</p><p>成员初始化顺序：成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者把他自己的一些职责委托给了其他构造函数 。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(<span class="attribute">std</span>::string s, unsigned cnt , double price )<span class="selector-pseudo">:bookNo(s)</span>, <span class="selector-tag">units_sold</span>(cnt),<span class="selector-tag">revenue</span>(cnt*price)&#123;&#125;</span><br><span class="line"><span class="selector-tag">Sales_data</span>()<span class="selector-pseudo">:Sales_data(""</span>,<span class="selector-tag">0</span>,<span class="selector-tag">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体一次被执行，然后将控制权交给委托函数体。</p><h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或者值初始化时，自动执行默认构造函数。 默认初始化发送的场景：</p><ol><li>当我们在快作用域内，不适用任何初始值定义一个非静态变量。</li><li>当一个类本身还有一个类类型的成员，且使用合成的默认构造函数。</li><li>当类类型成员没有在构造函数初始值列表中显示的初始化时。</li></ol><p>值初始化发生的场景：</p><ol><li>在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时。</li><li>当我们不适用初始值定义一个局部静态变量时</li><li>当我们通过书写形如T()的表达式显示的请求值初始化时。</li></ol><p>实际中，如果定义了其他的构造函数，那么最好定义一个默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>; <span class="comment">///声明了一个函数，而非对象</span></span><br><span class="line">Sales_data obj2;  <span class="comment">///obj2是一个对象，默认初始化</span></span><br></pre></td></tr></table></figure><h3 id="隐式的类类型转化"><a href="#隐式的类类型转化" class="headerlink" title="隐式的类类型转化"></a>隐式的类类型转化</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转化机制，有时候，我们把这样的构造函数称为转换构造函数。</p><p>能通过一个实参调用的构造函数，定义了一条从构造函数的参数类型向类类型隐式转化的规则。</p><p>只允许一步类型转换</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.combine(<span class="string">"9-999-9999"</span>); <span class="regexp">//</span>错误，两步转化，<span class="number">1</span>、char * -&gt;string <span class="number">2</span>. string-&gt;Sales_data</span><br></pre></td></tr></table></figure><p><strong>抑制构造函数定义的隐式转化：</strong> 我们可以通过将构造函数声明成explicit加以阻止。</p><p>关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式类型转换，所以无需将这些构造函数指定为explicit，只能在类内声明构造函数时使用explicit关键字，在类外部定义时，不应该重复。</p><p>explicit构造函数只能用于直接初始化：不能将explicit构造函数用于拷贝形式的初始化过程。当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，而且，编译器不会再自动类型转换过程中使用该构造函数。</p><p>显示类型转换可以使用explicit构造函数。</p><p>标准库中含有显示构造函数的类：</p><ol><li>接受一个参数const char*的string的构造函数不是explicit的</li><li>接受一个容量参数的vector的构造函数是explicit的。</li></ol><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>特定：</p><ol><li>所有成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类、virturl函数。</li></ol><p>可以提供一个花括号括起来的成员初始值列表。列表中成员的顺序和聚合类的成员的顺序一直， 如果初始值列表的元素的个数少于成员数量，后面的被值初始化。</p><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h3 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h3><p>类的静态成员和类本身直接相关。静态函数没有this，静态成员函数不能声明成const的。而且我们也不能再static函数体内使用this指针</p><h3 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h3><ol><li>使用作用域访问静态成员</li><li>通过对象访问静态成员</li><li>成员函数可以不通过作用域直接访问静态成员。</li></ol><h3 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h3><p>我们可以在类的内部、外部定义静态成员函数。在类的外部定义静态成员时，不能重复static关键字，该关键字只能在类的内部声明语句中。静态成员不属于任何一个对象，他们不是在类创建的时候定义的，这意味着不能由类的构造函数初始化。</p><h3 id="静态成员类内初始值"><a href="#静态成员类内初始值" class="headerlink" title="静态成员类内初始值"></a>静态成员类内初始值</h3><p>通常情况下，静态成员不应该在类的内部初始化，然而，我们可以为静态成员提供const整数类型的类内初始值。</p><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下，他们也应该在类外部定义下该成员。</p><h3 id="静态数据成员的特殊功能"><a href="#静态数据成员的特殊功能" class="headerlink" title="静态数据成员的特殊功能"></a>静态数据成员的特殊功能</h3><ol><li>可以是不完全类型</li><li>可以作为默认实参。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义抽象数据类型&lt;/li&gt;
&lt;li&gt;访问控制与封装&lt;/li&gt;
&lt;li&gt;类的其他特性&lt;/li&gt;
&lt;li&gt;类的作用域&lt;/li&gt;
&lt;li&gt;构造函数再探&lt;/li&gt;
&lt;li&gt;类的静态成员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第七章类" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>表达式</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第四章 表达式/表达式/</id>
    <published>2018-08-14T04:07:12.000Z</published>
    <updated>2018-08-16T02:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>基础</li><li>算术运算符</li><li>逻辑和关系运算符</li><li>赋值运算符</li><li>递增和递减运算符</li><li>成员访问运算符</li><li>条件运算符</li><li>位运算符</li><li>sizeof运算符</li><li>逗号运算符</li><li>类型转换运算符</li><li>运算符优先级</li></ol><p>运算符优先级大概层级：</p><ol><li>作用域运算符</li><li>成员选择、下标、函数调用</li><li>后置加加减减、类型id，类型转化</li><li>一元运算符</li><li>乘法</li><li>加法</li><li>移位</li><li>关系</li><li>位</li><li>逻辑</li><li>条件</li><li>赋值</li><li>逗号</li></ol><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>优先级（precedence）</li><li>结合律（asscociativity）</li><li>求值顺序</li></ol><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存的位置）。</p><ol><li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也是一个左值。</li><li>取地址运算符作用域左值运算对象，返回一个指向改运算对象的指针，这个指针是一个右值。</li><li>内置解引用、下标运算符、迭代器解引用求值结果是左值.</li><li>内置类型、迭代器递增运算符作用域左值，前置版本结果左值.</li></ol><p>使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。</p><ol><li>优先级</li><li>结合律</li><li>求值顺序</li></ol><p>有4种表达式明确规定了求值顺序</p><ol><li>逻辑与&amp;&amp;</li><li>逻辑或||</li><li>条件运算符？：</li><li>逗号表达式</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>(-m)/n = m/(-n) = -(m/n)</p><p>m%(-n) = m%n</p><p>(-m)%n = -(m%n)</p><p>m%n的符号和m的相同</p><h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>逻辑与、逻辑或求值短路</p><p>几个关系运算符链子一起会产生意想不到的结果</p><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的结果是左侧运算对象，并且是左值。如果赋值运算符的两个运算对象类型不同，右侧对象将转换为左侧运行对象类型。</p><p>赋值运算符满足右结合律，这个和其他的二元运算符不太一样。</p><p>赋值运算符的优先级低于关系运算符</p><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>为啥有？ 某些迭代器不支持算术运算</p><ol><li>前置版本递增：首先将运算对象加1，然后将改变后的对象作为求值结果。</li><li>后置版本的递增：将运算对象加1，但是求值结果是运算对象改变之前的那个值的副本。</li></ol><p>优先使用前置版本，前置版本的递增运算符避免了不必要的功过，把加1后的对象直接返回，相反：后置版本需要将原始值存储下来，以便返回未修改的内容，对于复杂的迭代器，这种额外的工作消耗巨大。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*iter++  <span class="comment">//这种写法比较普遍，后置++的优先级高,等价于下面两行代码</span></span><br><span class="line">*iter;</span><br><span class="line">++iter</span><br><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">while</span>(pbeg != v.<span class="built_in">end</span>() )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">end</span> ;  <span class="comment">//输出当前值，并将pbeg向前移动一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span> (<span class="built_in">begin</span> != v.<span class="built_in">end</span> &amp;&amp; !isspace(*<span class="built_in">begin</span>))</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>++);  <span class="comment">//错误：该语句未定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///可以解释为下面的任何一种</span></span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>);</span><br><span class="line">*(<span class="built_in">begin</span>+<span class="number">1</span>) = touper(*<span class="built_in">begin</span>)</span><br></pre></td></tr></table></figure><p>所以，如果一条子表达式改变了某个运算对象的值，另一个表达式又要使用该值的话，运算符的求值顺序非常关键。</p><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>表达式ptr-&gt;mem 等价于 (*ptr).mem。</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种两种情况：如果成员所属的对象是左值，结果是左值，反之，如果成员所属的对象是右值，那么结果是右值。</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符将简单的if else 逻辑切入到单个表达式当中。基本形式</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond</span>? <span class="symbol">expr1:</span> expr2</span><br></pre></td></tr></table></figure><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>二进制移位，移出边界之外的位就被舍弃掉了</p><p>位求反运算符~ 将运算对象逐位求反。</p><p>如果运算对象是小整数，它的值会被自动提升。</p><ol><li>位于 &amp;</li><li>位或 |</li><li>位异或 ^</li></ol><h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof返回一个表达式或者一个类型名字所占的字节数，满足右结合律，返回值类型是size_t类型。sizeof并不计算运算对象的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure><p>sizeof *p  sizeof不需要解引用指针也能知道它所指对象的类型，所以即使p是无效指针也不会有什么影响。</p><ol><li>对char或者类型是char的表达式执行sizeof运算，结果是1.</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li><li>对指针执行sizeof运算，得到指针本身所占内存的大小</li><li>对解引用指针指向sizeof运算，得到指针所指对象所占空间的大小，指针不需要有效</li><li>对数组执行sizeof运算，得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算，并求和。sizeof不会把数组转化为指针。</li><li>对string、vector对象执行sizeof运算，只返回该类型固定部分大小。不会计算对象中元素所占空间。</li></ol><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么求值结果是左值。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则，设法将运算对象的类型统一后再求值。</p><p>隐式类型转换发生场景</p><ol><li>在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。</li><li>在条件中，非布尔类型转换为布尔类型。</li><li>初始化过程中，初始值转换为变量的类型。在赋值语句中，右侧对象转换为左侧运算对象类型</li><li>算术或者关系运算对象有多种类型，需要转换为同一种类型</li><li>函数调用时会发生类型转换</li></ol><h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>整数提示：char signed char、 unsigned char、 short 、unsigned short 、bool 一般会提升为int </p><p>有符号的转化为无符号的（大小相等）<br>整数转化为浮点数<br>转化为宽类型</p><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><ol><li>数组转成指针： 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作decltyoe关键字参数，或者取地址&amp;，sizeof及typeid等运算对象时，上述转化不会发生。如果用引用初始化数组，也不会发生转化。</li><li>指针的转化：常量整数0或者字面值nullptr能转化成任意指针类型。指向任何非常量指针能转换成void<em> 指向任何对象的指针能转化成const void </em></li><li>转换成布尔类型：存在一种从算术类型或者指针类型向布尔类型自动转化的机制，如果指针或算术类型值为0，转换结果是false，否则转换结果是true。</li><li>转换成常量：允许冲非常量类型的指针转化为常量类型的指针。</li><li>命名的强制类型转换。</li></ol><p>static_cast：任何具有明确定义的类型转化，只要不包含底层const，都可以使用<br>const_cast：只能改变运算对象的底层const<br>reinterpret_cast: 通常为运算对象的位模式提供较底层次上的重新解释。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础&lt;/li&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;逻辑和关系运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;递增和递减运算符&lt;/li&gt;
&lt;li&gt;成员访问运算符&lt;/li&gt;
&lt;li&gt;条件运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;sizeof运算符&lt;/li&gt;
&lt;li&gt;逗号运算符&lt;/li&gt;
&lt;li&gt;类型转换运算符&lt;/li&gt;
&lt;li&gt;运算符优先级&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运算符优先级大概层级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用域运算符&lt;/li&gt;
&lt;li&gt;成员选择、下标、函数调用&lt;/li&gt;
&lt;li&gt;后置加加减减、类型id，类型转化&lt;/li&gt;
&lt;li&gt;一元运算符&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;移位&lt;/li&gt;
&lt;li&gt;关系&lt;/li&gt;
&lt;li&gt;位&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;条件&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;逗号&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第四章 表达式" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串、向量、数组</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/</id>
    <published>2018-08-10T04:07:12.000Z</published>
    <updated>2018-08-14T09:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>命令空间的using声明</li><li>标准库类型string</li><li>标准库类型vector</li><li>迭代器介绍</li><li>数组</li><li>多维数组</li></ol><p>基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。</p><a id="more"></a><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>std::cin中作用域运算符的含义：编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。</p><p>using声明的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>using 声明每次只能引入一个名字。using 声明必须以分号结束。</p><p>头文件不应该包括using声明。</p><h2 id="标准库string"><a href="#标准库string" class="headerlink" title="标准库string"></a>标准库string</h2><p>C++标准一方面对库类型所提供的操作做了详细的规定、另一方面也对库的实现者做了性能的要求。</p><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化对象由类的本身决定的。</p><p>初始化sting对象的方式</p><table><thead><tr><th>初始化形式</th><th>说明</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1是空串</td></tr><tr><td>string s2(s1)</td><td>s2是s1的一个副本</td></tr><tr><td>string s2= s1</td><td>等价于s2(s1)</td></tr><tr><td>string s3(“value”)</td><td>s3是字面值value的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于s3(“value”)</td></tr><tr><td>string s4(n,’c’)</td><td>初始化为连续n个字符c组成的字符串</td></tr></tbody></table><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><ol><li>拷贝初始化（copy initialization）：使用等号（=）初始化一个变量</li><li>直接初始化：不用等号</li></ol><p>当初始值只有一个时，使用直接初始化和拷贝初始化都行，如果用到多个初始值，一般来说只能直接初始化。如果非要用拷贝初始化也可以，需要显示的创建一个临时对象用于拷贝。</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>一个类除了规定初始化对象的方式外，还要定义对象上所能执行的操作。</p><table><thead><tr><th>操作示例</th><th>说明</th></tr></thead><tbody><tr><td>os&lt;&lt;s</td><td>将s写到输出流os当中，返回os</td></tr><tr><td>is&gt;&gt;s</td><td>从is中读取字符串赋给s，字符串以空白介绍，返回s</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用</td></tr><tr><td>s1+s2</td><td>返回s1、s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1 == s2</td><td>如果s1和s2所含的字符完全一样，则他们相等</td></tr><tr><td>s1 != s2</td><td></td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较</td></tr></tbody></table><h4 id="读取string对象"><a href="#读取string对象" class="headerlink" title="读取string对象"></a>读取string对象</h4><p>string对象会自动忽略开头的空白（空格，换行、制表符）并从第一个真正的字符开始算起，知道遇到下一处空白为止。</p><p>sting对象的此类输入输出操作返回运算符左侧的运算对象，所以，如果多个输入或者多个输出可以连在一起写。</p><h4 id="使用getline读取一行"><a href="#使用getline读取一行" class="headerlink" title="使用getline读取一行"></a>使用getline读取一行</h4><p>getline函数从给定的输入流中读入内容，直到遇到换行符为止，换行符的内容也被读入进来。然后将所读的内容从存入到string中。</p><p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。</p><h4 id="string的empty、size操作"><a href="#string的empty、size操作" class="headerlink" title="string的empty、size操作"></a>string的empty、size操作</h4><p>size返回的是string:size_type</p><p>string的相等意味着长度相同，且所包含的字符也完全相等。</p><p>当把string对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个加法的两侧的运算符对象至少有一个是string。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>cctype头文件中定义了一组标准函数处理字符：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>当c是字母或数字时为真</td></tr><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符时为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不为空格，单可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真，空格，可视字符</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(空格、制表符、回车、换行、进制符)</td></tr><tr><td>issupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母，否则原样输出</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大小字母，否则原因输出</td></tr></tbody></table><p>c语言的头文件形如name.h，在C++中将这些文件命名为cname，也就是去掉了.h后缀，在name名字前添加了字母c，这里的c表示是一个属于c语言标准库的头文件。cnmae的头文件中定义的明智属于命名空间std。而定义在.h的名字则不在。</p><h4 id="范围for语句（range-for）"><a href="#范围for语句（range-for）" class="headerlink" title="范围for语句（range for）"></a>范围for语句（range for）</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : <span class="type">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>其中expression部分是一个对象，表示序列。declaration是定义一个变量，用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> c : str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///对字符串c的每个字符c做某种操作</span></span><br></pre></td></tr></table></figure><p>如果想改变string对象中的字符的值，必须把循环变量定义成引用类型。这个变量实际上绑定到序列中的每个元素。</p><p>下标运算符：通过位置，返回该位置上字符的引用。 使用超出下标范围将引发不可预知的结果，使用下标访问空string也引发不可预知结果。</p><p>不管什么时候，只要对string对象使用下标，都要确认在那个位置上确实有值。</p><p>只要字符串不为常量，就能为下标运算符返回的字符串赋新值。</p><h2 id="标准库vector"><a href="#标准库vector" class="headerlink" title="标准库vector"></a>标准库vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，索引可以访问对象。因为vector“容纳着”其他对象，所以，所以他被称为容器（container）。</p><p>模板本身不是类或者函数，相反，可以看做是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称为<code>实例化</code>（instantiation），当使用模板时，需要指出编译器应把类或者函数实例化成何种形式。</p><p>提供信息的方式：即在类模板名字后面跟一对尖括号，括号内放类型信息。</p><p>vector是模板，而不是类。</p><h3 id="定义、初始化vector对象"><a href="#定义、初始化vector对象" class="headerlink" title="定义、初始化vector对象"></a>定义、初始化vector对象</h3><p>|初始化示例|说明|<br>|vector<t> v1| v1是一个空vector，他潜在的元素是T类型，执行默认初始化|<br>|vector<t> v2(v1)|v2中包含v1所有元素副本|<br>|vector<t> v2 = v1|等价于v2(v1)|<br>|vector<t> v3(n,val)|v3包含那个重复的元素。每个元素的值是val|<br>|vector<t> v4(n)|v4 包含了n个重复的执行了值初始化的元素|<br>|vector<t> v5{a,b,c,…}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>|vector<t> v5 = {a,b,c,…}|等价于v5{a,b,c,…}|</t></t></t></t></t></t></t></p><p><strong>列表初始化</strong>vector对象。</p><p>值初始化：通常情况下，可以只提供vector对象容纳元素数量，而略去初始值，此时，库会创建一个值初始化的元素初值，并且把它赋值给容器中所有元素。这个初始值由vector元素类型决定。</p><p>如果是内置类型，如int，元素初始值自动设置为0，如果是类类型，比如string，元素由类默认初始化。</p><p>如果只提供元素的数量而没有设定初始值，只能使用直接初始化。不让就是将数量拷贝给string对象了。</p><p>初始化过程中，尽可能地把花括号内的值当做是元素初始值列表处理，但是如果花括号形式所提供的值不能进行列表初始化，就要考虑用这样的值构造vector对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125; <span class="comment">//列表初始化，v5有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>); <span class="comment">//错误不能构建</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;   <span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;; <span class="comment">//v8有10个值为“hi” 的元素</span></span><br></pre></td></tr></table></figure><p> 在确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p><h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><p>vector对象能高效的增长，如果初始化的时候指定大小，可能效率会低。</p><p>范围for循环体内不应改变其所遍历序列的大小。</p><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><table><thead><tr><th>vector操作</th><th>说明</th></tr></thead><tbody><tr><td>v.empty()</td><td>如果v不含有任何元素，返回真，否则，返回假</td></tr><tr><td>v.size()</td><td>返回v中元素个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾部添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素的拷贝替换v1中的元素</td></tr><tr><td>v1 = {a,b,c…}</td><td>用列表中元素的拷贝替换v1中的元素</td></tr><tr><td>v1== v2</td><td>元素数目相同、对应位置上的元素值相同</td></tr><tr><td>v1 != v2</td><td></td></tr><tr><td>&lt; ,&lt;=, &gt; ,&gt;=</td><td>以字典的顺序进行比较</td></tr></tbody></table><p>vector对象的类型总是包含元素的类型。只有当元素的类型可以比较时，vector对象才能比较。vector可以使用下标读写元素，不能通过下标添加元素。<br>只能对已经存在的元素</p><p>缓冲区溢出（buffer overflow） 就是指的下标越界这类错误。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>类似指针类型，迭代器提供了对对象的间接访问。就迭代器而言，其对象是容器中元素或者string对象中的字符。</p><p>和指针不同，获取迭代器不是使用取地址符，有迭代器的类型，同时拥有返回迭代器的成员。比如begin、end成员。</p><ol><li>begin成员负责返回指向第一个元素的迭代器。</li><li>end成员负责返回指向容器 <strong>尾元素的下一个位置</strong>的迭代器。</li><li>end成员返回的迭代器通常称为尾后迭代器。</li><li>如果容器为空，则begin、end返回的是同一个迭代器。都是尾后迭代器。</li></ol><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>迭代器的运算符如下：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>*iter</td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter)-&gt;mem</td></tr><tr><td>++iter</td><td>令iter指示容器的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个元素是否相等，如果两个迭代器指示的是同一个元素，或者他们是同一个容器的尾后迭代器，则他们相等，否则不行等</td></tr><tr><td>iter1 != iter2</td></tr></tbody></table><p>指针和迭代器的相同点：</p><ol><li>可以解引用来获取它所指元素</li><li>也有有效和无效之分，有效：迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他所有情况都无效</li><li>提供了对对象的间接访问</li><li>都可以移动到下一个元素、上一个元素</li><li>视图解引用非法迭代器或者尾后迭代器都是未定义的，  解引用非法指针也是非法的</li></ol><p>指针和迭代器的不同点：</p><ol><li>获取方式不同，指针：取地址； 迭代器：通过容器的成员。</li></ol><p>迭代器使用实例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string </span>s(<span class="string">"some string"</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">if</span>(s.<span class="keyword">begin() </span>!= s<span class="meta">.end</span>())</span><br><span class="line">&#123;</span><br><span class="line">auto <span class="keyword">it </span>= s.<span class="keyword">begin();</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= touper(*<span class="keyword">it);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>因为end返回的迭代器并不实际指示元素，所以不能对其进行递增或者解引用的操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>(auto <span class="keyword">it </span>= s.<span class="keyword">begin(); </span><span class="keyword">it </span>!= s<span class="meta">.end</span>() &amp;&amp; !isspace(*<span class="keyword">it); </span>++<span class="keyword">it)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= toupper(*<span class="keyword">ite);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>只有string、vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库的迭代器都定义了==、!=，但是他们中的大多数没有定义&lt; 运算符，因此， 我们要养成使用迭代器和!=运算符的习惯。</p><p>实际上，那些拥有迭代器的标准库使用iterator、const_iterator表示迭代器类型。</p><p>const_iterator和常量指针差不多。能读取，不能修改。</p><p>如果vector、string对象是一个常量，只能使用const_iterator，如果vector、string不是常量，既能使用iterator，也能使用const_iterator</p><p>begin和end运算符： begin和end返回的具体类型由对象是否常量觉得，如果对象是常量，begin和end返回const_iterator，如果不是，返回iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v2;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v1.begin(); <span class="comment">//iter1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = v2.begin(); <span class="comment">//iter2 的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>cbegin()、cend() 返回const_iterator类型迭代器。</p><p>箭头-&gt;运算符将解引用和成员访问两个操作结合在一起。也就是it-&gt;mem和(*it).mem表达式的意思相同。</p><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><table><thead><tr><th>迭代器运算</th><th>说明</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上整数值，扔是一个迭代器类型。迭代器指示的新位置与原来的位置相比，向前移动了n个元素。结果迭代器或者指向容器的下一个元素，或者指向容器尾元素的下一个位置</td></tr><tr><td>iter - n</td><td></td></tr><tr><td>iter += n</td><td></td></tr><tr><td>iter1= n</td><td></td></tr><tr><td>iter 1 - iter2</td><td></td></tr><tr><td>&lt;, &lt;=, &gt;,&gt;=</td></tr></tbody></table><p>两个迭代器的间距的类型是diffrence 类型。带符号的。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义、初始化内置数组"><a href="#定义、初始化内置数组" class="headerlink" title="定义、初始化内置数组"></a>定义、初始化内置数组</h3><p>数组中元素的个数也属于数组类型的一部分，编译的时候纬度应该已知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>]  ; <span class="comment">//含有10个整形指针的数组。</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>定义数组的时候必须指定数组的类型。不允许使用auto关键字由初始值的列表来推断类型。</p><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的纬度。如果声明时没有指定纬度，编译器会根据初始值的数量计算并推断出来，如果指定了维度，那么初始值的总数量不应该超过指定的大小。</p><p>字符数组的特殊性： 一定要注意，字符串字面值的结尾还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">a</span>[] = <span class="string">"C++"</span> ;<span class="comment"> // 容量4</span></span><br></pre></td></tr></table></figure><p>不能讲数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">int a2[] = a; <span class="comment">//错误不能用一个数组初始化另一个数组</span></span><br><span class="line">a2 =a; <span class="comment">//错误不能把一个数组赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>理解复杂数组声明</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">ptrs</span><span class="selector-attr">[10]</span>; <span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">&amp;</span><span class="selector-tag">refs</span><span class="selector-attr">[10]</span>; <span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (*parray)<span class="selector-attr">[10]</span>; <span class="comment">//parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (&amp;arrRef)<span class="selector-attr">[10]</span>;<span class="comment">//parray引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><p>对数组而言，由内向外阅读比较合适。parray是一个指针，指向一个含有10个元素的数组，数组的元素类型是整形。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组的特性：在很多用到数组名字的地方，编译器都会自动的将其替换为一个指向数组首元素的指针。<br>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。</p><p>decltype不会执行数组到指针的转化。</p><p>指针也是迭代器</p><p>标注库函数begin、end。由于数组不是类类型，因此这两个函数不是成员函数。begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一个位置的指针。</p><p>尾后迭代器不能执行解引用和递增操作。</p><p>两个指针递减的结果类型是一种名为ptrdiff_t的标准库类型。定义在cstddef头文件中。</p><p>很多情况下，使用数组的名字，其实用的是一个指向数组首元素的指针。</p><p>内置下标运算符所用的索引值不是无符号类型，这一点和vector和string不一样。</p><h3 id="C分格字符串"><a href="#C分格字符串" class="headerlink" title="C分格字符串"></a>C分格字符串</h3><table><thead><tr><th>c分格字符串的函数</th><th>说明</th></tr></thead><tbody><tr><td>strlen()</td><td>返回p的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1,p2)</td><td>比较p1、p2的相等性，如果p1==p2 返回0，如果p1&gt;p2，返回一个正值，如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1,p2)</td><td>将p2附加到p1之后，返回p1</td></tr><tr><td>strcpy(p1,p2)</td><td>将p2拷贝给P1，返回p1</td></tr></tbody></table><p>当使用数组的时候其实真正用的是指向数组首元素的指针。所以比较字符串实际上比较的是指针。</p><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><ol><li>允许使用 以空字符结束的字符数组来初始哈动态string对象或者为string对象赋值</li><li>在string对象的加法运算中，允许使用空字符结束的字符数组作为其中一个运算对象。</li></ol><p>string对象的c_str函数返回一个C风格的字符串。</p><p>可以使用数组初始化vector对象。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言没有多维数组，通常所说的多维数组其实是数组的数组。</p><p>要使用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。<br>类型别名简化多维数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_ary = <span class="keyword">int</span>[<span class="number">4</span>];  <span class="comment">//int_ary 是含有4个整型元素的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_ary[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令空间的using声明&lt;/li&gt;
&lt;li&gt;标准库类型string&lt;/li&gt;
&lt;li&gt;标准库类型vector&lt;/li&gt;
&lt;li&gt;迭代器介绍&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第三章 字符串、向量、数组" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>特殊工具和技术</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/</id>
    <published>2018-08-02T01:07:12.000Z</published>
    <updated>2018-08-02T11:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制内存"><a href="#控制内存" class="headerlink" title="控制内存"></a>控制内存</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用new表达式时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> * sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a string"</span>);</span><br><span class="line"><span class="built_in">string</span> * arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际执行了三步：</p><ol><li>new 表达式调用 operator new 或operator new [] 标准库，分配一块足够大、原始的、未命名的内存空间。</li><li>编译器运行相应的构造函数，并传入初始值。</li><li>返回一个指向该对象的指针。</li></ol><p>当我们使用delete表达式时</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure><ol><li>调用析构函数</li><li>调用名为operator delete 或者operator delete [] 释放空间。</li></ol><p>发现new、delete表达式，如果对象是类类型，首先在类类型中查找，然后是全局作用域。也可以使用::new直接使用全局作用域的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>类作用域的new、delete是静态的。因为operator new 用在对象构造之前，operator delete 用在对象销毁后。而且不能操作类的任何成员。</p><p>new表达式和 operator new 函数：不能改变new表达式、delete表达式的含义。</p><p>malloc函数接受一个表示带分配字节数的size_t，返回指向分配空间的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">void</span>* mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* mem)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address)<span class="built_in"> type </span>(initializers)</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size]</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size] &#123;braced initializer list&#125;</span><br></pre></td></tr></table></figure><p>定位new 使用 operation new (size_t ,void *)函数<br>定位new 可以构造对象，单不分配内存</p><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>allcator</td></tr><tr><td>allocate</td><td>construct</td></tr><tr><td>destroy</td><td>deallocate</td></tr></tbody></table><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>new的形式</td></tr><tr><td>operator new</td><td>构造函数（定位new可以只构造对象，不申请空间）</td></tr><tr><td>free</td><td>析构函数（可以直接调用）</td></tr></tbody></table><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><ol><li>typeid 运算符，返回表达式的类型</li><li>dynamic_cast运算符 用于将基类指针或引用安全的转化为派生类的指针或者引用</li></ol><p>当操作被定义为虚函数时，编译器将根据对象的动态类型自动的选择正确的版本 。</p><ol><li>dynamic_cast<type*> (e)</type*></li><li>dynamci_cast<type&> (e)</type&></li><li>dynamic_cast<type&&> (e)</type&&></li></ol><p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p><p>type_info 类的name成员函数返回一个C风格的字符串，表示对象的类型名字。type_info 只能通过typeid运算符创建。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型使我们可以将一组整形常量组织在一起。 </p><ol><li>限定作用域</li><li>不限定作用域</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> 枚举名 &#123; 逗号分隔的枚举列表&#125;;</span></span><br></pre></td></tr></table></figure><p>枚举值可以不唯一，枚举成员是常量表达式。</p><p>和类一样，枚举也定义新的类型，也能定义变量。enum对象赋值必须使用该类型的一个枚举成员，或该类型的另一个对象。</p><p>指定enum的大小</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValue</span> : <span class="title">unsigned</span> <span class="title">long</span> <span class="title">long</span> </span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>枚举类型的前置声明</p><h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针，是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员。</p><p>成员指针的类型囊括了类的类型、成员的类型。当初始化一个这样的指针时，我们另其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p><h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><p>声明成员指针时，必须包含成员所属的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> className:: * pdata;</span><br><span class="line">pdata = &amp;Screen::contents <span class="comment">//指向某个非特定Screen对象的contents成员</span></span><br></pre></td></tr></table></figure><p>当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员，而非该成员所属的对象。只有当解引用成员指针时，我们才提供对象的信息。 也就是解引用时候绑定到特定的对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*  data()</span><br><span class="line">&#123;</span><br><span class="line">retrun &amp;Screen::contents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data 指向Screen类const string 成员指针。</span></span><br></pre></td></tr></table></figure><h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p><code>char (Screen::*pmf2)(int,int ) const;</code></p><h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>成员函数指针不是可调用对象，调用前必须使用.<em>或者-&gt;</em>绑定到特定对象上。所以不能直接将成员函数指针传递给算法。</p><font color="red"><br>以下内容无法理解：<br><br>1. 可以使用function生成一个可调用对象。<br>2. 可以使用mem_fn生成一个可调用对象。<br>3. 使用bind 生成一个可调用对象。<br><br></font><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class） ，后者称为嵌套类型（nested type）。</p><p>嵌套类是一个独立的类，与外层基本没有什么关系，特别是，外层类对象和嵌套类对象是相互独立的，嵌套类的对象不能包括任何外层类定义的成员；类似的，在外层类的对象也不能报考任何嵌套类定义的成员。嵌套类的名字在外层作用域内是可见的。之外不可见。 嵌套类对外层类的成员也没有特殊的访问权限。</p><h2 id="union-一种节省空间的类"><a href="#union-一种节省空间的类" class="headerlink" title="union 一种节省空间的类"></a>union 一种节省空间的类</h2><p>union可以定义多个数据成员，但在任何时刻，只有一个数据成员可以有值。union可以定义包括构造函数和析构函数在内的成员函数。但union不能继承自其它类，也不能作为基类使用。 不能有虚函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;控制内存&quot;&gt;&lt;a href=&quot;#控制内存&quot; class=&quot;headerlink&quot; title=&quot;控制内存&quot;&gt;&lt;/a&gt;控制内存&lt;/h2&gt;&lt;h3 id=&quot;重载new和delete&quot;&gt;&lt;a href=&quot;#重载new和delete&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十九章特殊工具和技术" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="特殊工具和技术" scheme="http://yoursite.com/tags/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>模板和泛型编程</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-09-25T07:36:16.526Z</updated>
    
    <content type="html"><![CDATA[<ol><li>名义模板</li><li>模板实参推断</li><li>重载与模板</li><li>可变参数模板</li><li>模板的特例化</li></ol><p>面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;名义模板&lt;/li&gt;
&lt;li&gt;模板实参推断&lt;/li&gt;
&lt;li&gt;重载与模板&lt;/li&gt;
&lt;li&gt;可变参数模板&lt;/li&gt;
&lt;li&gt;模板的特例化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十六章 模板和泛型编程" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="模板和泛型编程" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>变量和基本类型</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-08-13T05:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。</p><p>主要内容 ：</p><ol><li>基本内置类型</li><li>变量</li><li>复合类型</li><li>const限定符</li><li>处理类型</li><li>自定义数据类型</li></ol><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++ 定义了一套包括算术类型和空类型的基本数据类型。</p><p>算术类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32</td></tr><tr><td>short</td><td>短整形</td><td>16</td></tr><tr><td>int</td><td>整形</td><td>16</td></tr><tr><td>long</td><td>长整形</td><td>32</td></tr><tr><td>long long</td><td>长整形</td><td>64</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10 位有效数字</td></tr></tbody></table><ol><li>寻址的最小内存块为 <strong>字节(byte)</strong> 大多数的字节由8个bit构成。</li><li>存储的基本单元称为 <strong>字(word) </strong>一般32或64bit。</li></ol><p>通常，float一个字，double两个字，long double4个字，类型float和double 分别有<strong>7</strong>个和<strong>16</strong>个有效位。</p><p>与其他类型不同，字符型被分为三种：char、signed char 、 unsigned char。char 和signed char 并不是一种，尽管类型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种的一种，具体由编译器决定。</p><p>如何选择类型：</p><ol><li>在算术表达式中不要使用char 、bool 只有在存放字符或者bool值时候才使用它们，因为类型char在一些机器上有符号，而在另外一些机器上又是无符号的，所以，如果使用char 进行运算特别容易出问题。如果使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。</li><li>执行浮点运算选用double，这是因为float通常进度不够。对于某些机器，双精度运算甚至比单精度还快。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当给某种类型的对象强制赋予了另一种类型的值时，到底发生了什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span><span class="keyword">b </span>= <span class="number">42</span><span class="comment">;</span></span><br><span class="line">int i = <span class="keyword">b </span><span class="comment">; ///i的值时1</span></span><br></pre></td></tr></table></figure><ol><li>当把一个非布尔类型的算术值赋给布尔类型时，初始值0是false，否则为true。</li><li>当把一个布尔值赋值给非布尔类型时，初始值false 是0，true是1.</li><li>浮点数赋值给整数类型时，进行近视处理，保留小数部分之前的。</li><li>将超出范围的值赋值给无符号类型：结果是初始值对无符号类型表示的总数取模后的余数。</li><li>将超出范围的值赋给带符号类型，结果未定义。</li></ol><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p><font color="red"></font></p><ol><li>无符号数递减不能是负值，如果为负值，会是取模的余数。</li><li>切勿混用带符号和无符号类型。如果表达式里面既有带符号的，又有无符号的，带符号的数会转化为无符号的数。<br><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3></li></ol><table><thead><tr><th>字面常量</th><th>进制</th></tr></thead><tbody><tr><td>20</td><td>十进制</td></tr><tr><td>024</td><td>八进制</td></tr><tr><td>0x14</td><td>十六进制</td></tr></tbody></table><ol><li>字面值常量的类型是能容纳该数值的尺寸最小的那个（int long， long long），默认是带符号的。类型short没有对应的字面值。浮点型字面值类型是double。</li><li><strong>字符串字面值的类型实际上是由常量字符构成的数组，末尾添加‘\0’。</strong></li><li><strong>如果两个字符串字面值位置紧邻且仅由空格，缩进、换行符分隔，则他们实际上是一个整体</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really"</span> </span><br><span class="line">              <span class="string">"that spans"</span>;</span><br></pre></td></tr></table></figure><p>有两种类型字符不能直接使用，需要转义：</p><ol><li>不可打印</li><li>特殊含义字符：单引号、双引号、问号、反斜杠</li></ol><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>指定字符和字符串字面值：指定的方法如下表：</p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode 16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode 32 字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8(仅用于字符串字面常量)</td><td>char</td></tr></tbody></table><p>指定整数字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>u U</td><td>unsigned</td></tr><tr><td>l L</td><td>long</td></tr><tr><td>ll LL</td><td>long long</td></tr></tbody></table><p>指定浮点字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>f F</td><td>float</td></tr><tr><td>l L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供具名的、可供程序操作的存储空间。C++每个变量都有数据类型，数据类型决定着变量所占内存空间的大小、布局方式、该空间能存储的值的范围、以及变量能参与的运算。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>基本形式：类型说明符（type specifier） + 变量名</p><p>string表示可变长字符序列  的数据类型</p><p>对象是指能存储数据并具有某种类型的存储空间。</p><p>当一次定义了两个或多个变量时，对象的名字随着定义也马上可以使用了。因此在同一条语句中，可以用先定义的变量去初始化后定义的其他变量。</p><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p><p>初始化的四种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>花括号的初始化形式称为<strong>初始化列表</strong>。</p><p>初始化列表用于内置类型的变量时：<strong>如果初始值存在丢失信息的风险，编译器报错。</strong></p><p>如果定义变量时没有指定值，则变量被默认初始化（default initialized），此时变量被赋予了默认值。</p><p>函数体之外的内置变量被初始化为0；函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示初始化，则其值由类确定。</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明：规定了变量的类型和名字，这一点上和定义相同。<br>定义：除了规定变量的类型和名字，还申请存储空间、为变量赋一个初始值。</p><p>声明代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">//声明i，而非定义i，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; 任何包含了显示初始化的声明既变为定义。</span><br></pre></td></tr></table></figure><p>变量能且只能别定义一次，但是可以被多次声明。</p><p>这相当于为分离式编程提供了支持</p><p>C++是一种静态类型语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查。 编译器知道每一个实体对象的类型是通过类型声明。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>用户定义的标识符不能连续出现两个下划线、不能以下划线紧连大写字母开头、定义在函数体外的标识符不能以下划线开头。</p><p>变量命名规范：</p><ol><li>标识符要能体现实际含义</li><li>变量一般用小写字母</li><li>用户定义的类名一般以大写字母开头</li><li>标识符由多个单词组成，则单词间应该有明显区分</li></ol><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>名字的有效区域始于名字的声明语句，以声明语句所在的作用域未端为结束。</p><p>第一次使用变量时再定义变量，这样好处：</p><ol><li>更容易找到变量的定义</li><li>容易赋值合理的初始值</li></ol><ol><li>全局作用域</li><li>块作用域</li><li>嵌套作用域</li></ol><ol><li>内层作用域可以访问外层作用域中的名字</li><li>内层作用域中可以重新定义外层作用域中的名字</li><li>使用作用域运算符可以直接访问外层作用域中的名字</li></ol><h2 id="符合类型（引用、指针）"><a href="#符合类型（引用、指针）" class="headerlink" title="符合类型（引用、指针）"></a>符合类型（引用、指针）</h2><p>符合类型是基于其他类型定义的类型（compound type）</p><p>基本数据类型  + 声明符</p><p><strong>声明符</strong>命令了一个变量，并指定该变量的相关类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference） 为对象起了另一个名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中，然而，定义引用时，程序把引用和它的初始值绑定在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此，引用必须初始化。</p><p>定义一个引用后，对其进行的所有操作都是在与之绑定的对象进行的。</p><ol><li>获取引用的值：实际上是获取了与引用绑定的对象的值。</li><li>以引用为初始值： 实际上是以与引用绑定的对象作为初始值。</li></ol><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p><p>用于在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。</p><p>引用的类型要和与之绑定的对象严格匹配。引用只能绑定在一个对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与引用类型，指针也实现了对其他对象的间接访问。</p><p>指针和引用的区别：</p><ol><li>指针本身也是对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。</li><li>指针无需在定义的时候赋值。</li></ol><p>指针存放某个对象的地址。要想获取该地址，使用取地址符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//p存放变量ival的地址。 或者说p是指向变量ival的指针。</span></span><br></pre></td></tr></table></figure><p>指针的类型都要和它所指向的对象严格匹配。</p><p>指针值：指针的值（即地址）应属于下列4中转态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>解引用来访问该对象，解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p>空指针使用nullptr，新标准使用NULL，NULL是预处理变量。</p><p>如果使用了未经初始化的指针，则该指针所占内存空间的当前内容被看做是一个地址值，访问该指针，相当于去访问一个本不存在的位置上的</p><p>指针和引用都能踢动对其他对象的间接访问，然而，在具体实现细节上，二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法领其在绑定到另外的对象。之后每次使用这个引用都是访问他最初绑定的那个对象。</p><p>给指针赋值，就是令其存放一个新地址。</p><p>如果两个指针存放的地址值相同，则他们相等。</p><p>void<em> 是一种特殊的指针类型，可用于存放任何对象的地址。一个`void</em><code>指针存放着一个地址。这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象不了解。 不能直接操作</code>void*` 指针所指的对象。因为我们不知道这个对象到底是什么类型。</p><h3 id="理解符合类型"><a href="#理解符合类型" class="headerlink" title="理解符合类型"></a>理解符合类型</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//p是<span class="built_in">int</span>型指针、r是一个<span class="built_in">int</span>型引用</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">int</span> *<span class="built_in">pi</span> = &amp;ival;</span><br><span class="line"><span class="built_in">int</span> **ppi = &amp;<span class="built_in">pi</span>; ///ppi指向一个<span class="built_in">int</span>型的指针</span><br></pre></td></tr></table></figure><p>ppi  -&gt; pi -&gt; ival (1024)</p><h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p ;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r 引用了一个指针，因此给r赋值，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><p>离变量名最近的符号对变量类型有最直接的影响。所以r是引用。</p><p>##const限定符</p><p>默认情况下，const对象仅仅在文件内有效。如果想在多个文件中共享const对象，就对const变量不管是声明还是定义都添加extern关键字。这样只需定义一次就可以了。</p><h3 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h3><p>可以把引用绑定到const 对象上，我们称为对常量的引用（refernce to const） 。一定要记住，</p><h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>引用的类型必须和其所引用对象的类型一致，但是有两个例外，第一种例外情况是初始化常量引用时允许用任何表达式作为初始值，只要改表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span> <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1* <span class="number">2</span>;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><p>必须认识到：常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>指向常量的指针（pointer to const） 不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">//pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr  = &amp;pi;  <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure><p>指针的类型必须与其所指对象的类型一致，但是有两个例外，其中一个是：允许一个指向常量的指针指向一个非常量对象。</p><p>试试这样想吧：所谓指向常量的指针和引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以自觉的不去改变所指对象的值。</p><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>指针是对象而引用不是，所以就像其他对象类型一样，允许指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量。即不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pip <span class="comment">//pip 是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><p>要想弄清楚这些声明的含义，最行之有效的方法是从右向左阅读</p><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题，用名词顶层const表示指针本身是一个常量，而用名词底层const 表示指针所指的对象是一个常量。</p><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。</p><p>当执行对象的拷贝操作时，常量的顶层const还是底层const区别名下，其中顶层const不受影响：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci <span class="comment">//允许改变p2的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;  <span class="comment">//正确，底层一样</span></span><br></pre></td></tr></table></figure><p>另一方面，底层const的限制不能忽视</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误，p指向的值可以通过p改变，但p指向的值是常量，所以错误</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式</p><p>constexpr变量：如果认定变量是一个常量表达式，那就把它声明为constexpr类型</p><h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>字面值类型： 比较简单，值也显而易见，容易得到，算术类型、引用类型、指针都属于字面值类型。  string 不属于，也就不能被定义成constexpr。</p><p>函数体内定义的变量，一般来说并非存放固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于多有函数体之外的对象，其地址固定不变，能用来初始哈constexpr指针。</p><h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>  <span class="comment">//p是一个指向整型常量的 指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">//q是一个指向整形的向量指针。</span></span><br></pre></td></tr></table></figure><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>为了简化复杂类型的定义</p><h3 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wage base,*p ;<span class="comment">// base 是double的同义词，p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//SI 是sales_item的同义词</span></span><br></pre></td></tr></table></figure><p>using 把等号左侧的名字规定成等号右侧类型的别名。</p><h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr 是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>pstring 的基本数据类型是指针 。 不能展开，如果展开就错了</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> * <span class="built_in">cstr</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>展开就成了底层常量了</p><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器通过初始值来推断变量的类型，显然，auto的定义必须有初始值。</p><ol><li>引用： 编译器以引用对象的类型作为auto的类型，希望推断引用，需要 auto &amp;</li><li>顶层const常量： 忽略，希望推断顶层const常量，需要用const auto</li><li>底层const常量： 保留</li></ol><h3 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h3><p>场景：希望从表达式的类型推断出要定义的变量类型，但是不想用改表达式的值初始化变量。decltype不实际计算表达式的值。</p><p>decltype处理顶层const和引用的方式与auto有些不同，如果decltyoe使用的表达式时一个表里，则decltype返回改变量的类型，包括顶层const和引用在内。</p><p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外。</p><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此，decltype（*p）的结果类型就是int&amp;，而非int。</p><p>decltype的表达式如果是加上括号的变量，结果是引用。</p><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名，以表示该类型对象的定义，所以分号必不可少。</p><p>可以为数据成员提供一个<strong>类内初始值</strong>，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p>头文件通常包含哪些只能被定义一次的实体。例如类、const、constexpr变量等。</p><p>确保头文件多次包含仍能安全工作的技术是<strong>预处理器</strong>，预处理器是在编译之前执行的一段程序。#include就是预处理，当预处理器看到#include标记时，就会用指定的头文件内容替换#include</p><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义、未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义。#ifdef、#ifndef、#endif。</p><p>预处理变量无视C++语言中关于作用域的规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。&lt;/p&gt;
&lt;p&gt;主要内容 ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内置类型&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;复合类型&lt;/li&gt;
&lt;li&gt;const限定符&lt;/li&gt;
&lt;li&gt;处理类型&lt;/li&gt;
&lt;li&gt;自定义数据类型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第二章变量和基本类型" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="变量和基本类型" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>组件化-库</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BA%93/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/IOS/库/组件化-库/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20170427/19136.html" rel="external nofollow noopener noreferrer" target="_blank">组件化-动态库实战</a>    </p><p><a href="https://blog.csdn.net/u013604612/article/details/43197465" rel="external nofollow noopener noreferrer" target="_blank">iOS开发——创建你自己的Framework</a>  </p><p><a href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" rel="external nofollow noopener noreferrer" target="_blank">iOS - Umbrella Header在framework中的应用</a></p><p><a href="https://www.jianshu.com/p/48aff237e8ff" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发中的『库』(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170427/19136.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件化-动态库实战&lt;/a&gt;    
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/IOS/%E5%BA%93/"/>
    
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
</feed>
