<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-13T11:17:53.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拷贝控制</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十三章/拷贝控制/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-13T11:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们将学到：拷贝、赋值、移动、销毁做什么？</p><ol><li>拷贝构造函数  </li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li><li>析构函数</li></ol><p>函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。</p><p>如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。</p><a id="more"></a><h2 id="拷贝、赋值、销毁"><a href="#拷贝、赋值、销毁" class="headerlink" title="拷贝、赋值、销毁"></a>拷贝、赋值、销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   plublic:</span><br><span class="line">   Foo(canst Foo&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h4><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。</p><p>合成拷贝构造函数如何拷贝：</p><ol><li>类类型：使用其拷贝构造函数来拷贝</li><li>内置类型：直接拷贝</li><li>数组：逐个拷贝数组成员</li></ol><p>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig):</span><br><span class="line"><span class="function"><span class="title">bookNO</span><span class="params">(orig.bookNO)</span></span>,</span><br><span class="line"><span class="function"><span class="title">units_sold</span><span class="params">(orig.units_sold)</span></span>,</span><br><span class="line"><span class="function"><span class="title">revenue</span><span class="params">(orig.revenue)</span></span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><ol><li>直接初始化：我们实际上要求编译器用普通的函数匹配类选择与我们提供的参数最匹配的构造函数</li><li>拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。</li></ol><p>拷贝初始化发生的场景：</p><ol><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li><li>insert 、push（emplace 直接初始化）</li></ol><h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>当一个函数具有非引用类型的返回值类型时，返回值会被用来初始化调用方的结果</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。<br>如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;);</span><br></pre></td></tr></table></figure></p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">booNO = rhs.bookNO;</span><br><span class="line">units_sold = rhs.units_sold;</span><br><span class="line">revenue = rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>构造函数初始化对象的非static数据成员。</li><li>析构函数释放对象使用的资源，并销毁对象的非静态成员。</li></ol><p>析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">~Foo()</span>;</span><br></pre></td></tr></table></figure></p><ol><li>在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。</li><li>在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。</li></ol><p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。</p><p>什么时候会调用析构函数：</p><ol><li>变量在离开其作用域时</li><li>对象被销毁，其成员被销毁</li><li>容器被销毁，其成员被销毁</li><li>动态分配的对象，delete 运算符时会被销毁</li><li>对于临时对象，当创建他的完整表达式结束时被销毁</li></ol><p><font color="red">析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的</font></p><h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><p>需要析构函数的类也需要拷贝和赋值。<br>需要拷贝操作的类也需要赋值操作。</p><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。</p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。<br>删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。</p><p>=default 、=delete区别：</p><ol><li>=delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。</li><li>可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。</li></ol><p>析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。</p><p>对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。</p><p>合成的拷贝成员可能是删除的：如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。</p><p>对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，次运算符视图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。</p><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>管理类外资源的类必须定义拷贝控制函数。</p><ol><li>类值拷贝</li><li>类指针拷贝</li></ol><p>赋值运算符通常组合了析构函数和构造函数的操作。类型析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">//拷贝底层String</span></span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">//是否旧内存</span></span><br><span class="line">ps = newp;</span><br><span class="line">i=rhs.i;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它吱声，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</p><p>引用计数的工作方式：</p><ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li><li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。</li><li>析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将学到：拷贝、赋值、移动、销毁做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拷贝构造函数  &lt;/li&gt;
&lt;li&gt;拷贝赋值运算符&lt;/li&gt;
&lt;li&gt;移动构造函数&lt;/li&gt;
&lt;li&gt;移动赋值运算符&lt;/li&gt;
&lt;li&gt;析构函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么&lt;br&gt;运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。&lt;/p&gt;
&lt;p&gt;如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十三章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    
    
      <category term="拷贝控制" scheme="http://yoursite.com/tags/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>为什么`forward_list`不支持`push_back`操作？</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/forward_list%E4%B8%8D%E6%94%AF%E6%8C%81push_back%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/forward_list不支持push_back操作/</id>
    <published>2018-06-27T02:07:12.000Z</published>
    <updated>2018-06-27T02:40:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么forward-list不支持push-back操作？"><a href="#为什么forward-list不支持push-back操作？" class="headerlink" title="为什么forward_list不支持push_back操作？"></a>为什么forward_list不支持push_back操作？</h2><p>由于forward_list是单向链表，所以我们如果想要访问尾元素，都要从首元素开始跌代，算法复杂度为O(n)。而对于list为双向链表，直接通过尾指针可以访问尾元素，实现在尾元素添加元素，函数复杂度为O(1)，而vector，string,deque,也可以通过尾指针来添加元素，函数复杂度为O(1)。</p><p>同样的原因也有forward_list不支持pop_back。<br>由于类似原因(算法的复杂度)，有vector，string，不支持push_front，pop_front，但是通过insert，和erase操作仍然可以完成添加/删除首元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么forward-list不支持push-back操作？&quot;&gt;&lt;a href=&quot;#为什么forward-list不支持push-back操作？&quot; class=&quot;headerlink&quot; title=&quot;为什么forward_list不支持push_back操作？&quot;&gt;
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="forward_list" scheme="http://yoursite.com/tags/forward-list/"/>
    
  </entry>
  
  <entry>
    <title>容器基本操作</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/容器基本操作/</id>
    <published>2018-06-26T08:07:12.000Z</published>
    <updated>2018-06-26T08:19:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文列举C++中容器的通用操作。来源于C++ primer</p><a id="more"></a><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不使用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文列举C++中容器的通用操作。来源于C++ primer&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="容器操作" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库中的list的实现原理</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/list/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84list%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/C++语言/container/list/C++标准库中的list的实现原理/</id>
    <published>2018-06-26T07:07:12.000Z</published>
    <updated>2018-06-26T07:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/loveyou11111111/article/details/49763197" rel="external nofollow noopener noreferrer" target="_blank">C++标准库中的list的实现原理</a></p><a id="more"></a><p>在C++中采用了大量的标志模板库（STL）实现程序的设计，这种设计方式使得不同类型的对象都能通用，而不再是C语言中的通常对于不同的类型需要重新设计或者或者比较采用间接的指针操作。C++中的这种方式简化了写代码的复杂度，但是增加了编译器的复杂度和难度。</p><p>在数据结构中链表是比较基本的类型，在C++中链表是基于模板的类，因此在实际的使用过程中需要涉及到实际的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lint;</span><br></pre></td></tr></table></figure><p>在C++中关于list的接口比较丰富，主要是关于大小，数据的插入、删除等。但是在C++中引入了迭代器的概念，这个迭代器是关于关于容器中比较重要的一部分，因为这种迭代器使得算法等问题与容器独立开来，迭代器实质上还是指针，准确的将是一个封装了指针的类。</p><p>迭代器类的创建应该包含下面的操作，首先应该支持的操作符至少包括如下（operator*()，operator++()，operator++(int)，operator==()， operator!=()）,当然也会存在const_iterator这样的常迭代器，也就是只允许访问，不能修改对象的迭代器，当然存在迭代器的构造函数、复制控制函数，这些函数都是必须要存在的，因为设计到了指针的操作问题，构造函数应该存在参数是链表节点指针的定义，只有存在这个定义才能间接的访问节点对象。<br>当然在类中至少存在返回迭代器的begin()和end()函数，这两个函数返回的迭代器分别指向链表的开始和链表结束的下一个地址，这是迭代器中经常容易理解错误的地方。</p><p>在C++中通常创建const_iterator类，然后iterator直接继承const_iterator。</p><p>下面说说list类设计的基本思路：<br>首先、创建链表节点对象，实质上是完成对传递进来的类型的封装操作，同时构成一个双向链表的基本要素（prev、next指针）。节点肯定要存在构造函数，而且是直接初始化三个成员变量。<br>其次、创建迭代器类，实质上就是封装一个节点指针，通过节点指针实现操作，至少要实现的操作符已说明。这两个类都要设置List为友元类，因为这样才能用List直接操作迭代器的相关操作。<br>最后、依靠上面的迭代器类和节点类，创建一个List类，该类中主要完成一些基本操作。其中需要注意的就是迭代器的操作，比如删除元素和插入元素以后迭代器的变化问题等。</p><p>需要注意的是在List中采用了哨兵节点，这个哨兵节点并不算实际的操作对象，也就是为了保证肯定有目标所指向，存在一个head对象，这个对象的next就是实际的数据，而tail是迭代器所能到达的最后一个对象，但是这个对象并不是合理的区域，实际上end()实际上就是指向了tail节点，这两个节点head和tail就是哨兵节点。具体的参看代码。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>实现的基本形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYLIST_H_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYLIST_H_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        templateObject&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*封装对象，形成链表节点*/</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                        Object data;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*节点构造函数*/</span></span><br><span class="line">                        Node(<span class="keyword">const</span> Object &amp;d = Object(), Node *p = <span class="literal">NULL</span>, Node *n = <span class="literal">NULL</span>)</span><br><span class="line">                        :data(d), prev(p), next(n)&#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">/*创建一个常量迭代器类，这是容器设计的关键*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">const_iterator</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        const_iterator():current(<span class="literal">NULL</span>)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*重载迭代器的值*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object &amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载前向++操作符*/</span></span><br><span class="line">                        const_iterator &amp; <span class="keyword">operator</span>++ ()</span><br><span class="line">                        &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载后向++操作符，因为是一个局部对象不能返回引用*/</span></span><br><span class="line">                        const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                const_iterator old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*判断迭代器是否相同，实质上就是判断指向的节点是否相同*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> const_iterator &amp;rhs) <span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> current == rhs.current;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*调用==操作符*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> const_iterator &amp;rhs)<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> (!(*<span class="keyword">this</span> == rhs));</span><br><span class="line">                        &#125;</span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*迭代器实质就是一个节点指针*/</span></span><br><span class="line">                        Node *current;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*获得链表中的内容*/</span></span><br><span class="line">                        <span class="function">Object &amp; <span class="title">retrieve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">                        </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于指针参数的迭代器构造函数，保证只有List使用*/</span></span><br><span class="line">                        const_iterator(Node *p):current (p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*友元类，可以调用迭代器的私有成员*/</span></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*一般迭代器，直接继承const_iterator*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> :</span> <span class="keyword">public</span> const_iterator</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        iterator():const_iterator()</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*得到对象的值*/</span></span><br><span class="line">                        Object &amp;<span class="keyword">operator</span>*()</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于const的重载*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> const_iterator::<span class="keyword">operator</span>*();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*前向++操作符*/</span></span><br><span class="line">                        iterator &amp;<span class="keyword">operator</span>++()</span><br><span class="line">                       &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*后向++操作符*/</span></span><br><span class="line">                        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                iterator *old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*基于节点的迭代器构造函数*/</span></span><br><span class="line">                        iterator(Node *p):const_iterator(p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                List()</span><br><span class="line">                &#123;</span><br><span class="line">                        init();</span><br><span class="line">                &#125;</span><br><span class="line">                ~List()</span><br><span class="line">                &#123;</span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="keyword">delete</span> head;</span><br><span class="line">                        <span class="keyword">delete</span> tail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                       <span class="comment">/*创建哨兵节点*/</span></span><br><span class="line">                        init();</span><br><span class="line">                        <span class="comment">/*复制数据*/</span></span><br><span class="line">                        *<span class="keyword">this</span> = rhs;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> List &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        <span class="comment">/*清除原有的信息*/</span></span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="comment">/*添加新的对象*/</span></span><br><span class="line">                        <span class="keyword">for</span>(const_iterator itr = rhs.begin(); itr != rhs.end(); ++ itr)</span><br><span class="line">                                push_back(*itr);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到迭代器，实质上就是得到节点指针*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*iterator()是构造函数*/</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> theSize;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>( !empty())</span><br><span class="line">                                pop_front();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到第一个元素*/</span></span><br><span class="line">                <span class="function">Object &amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*采用了迭代器begin()*/</span></span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">front</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">Object &amp;<span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*end()指向最后一个对象的下一个地址，因此需要--*/</span></span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">back</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">                *从头插入新的节点，这时候的begin已经不再是begin</span></span><br><span class="line"><span class="comment">                *因此插入操作会导致迭代器出错</span></span><br><span class="line"><span class="comment">                ***********************************************/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(begin(), x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*从后插入新的节点，这时候会将end后移*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(end(), x);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*从头弹出一个对象*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        erase(begin());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                       erase(--end());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*插入对象，参数是迭代器和数据*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">insert</span><span class="params">(iterator itr, <span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        theSize ++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        *Node *np = Node(x,p-&gt;prev,p);</span></span><br><span class="line"><span class="comment">                        this means that np-&gt;prev = p-&gt;prev,</span></span><br><span class="line"><span class="comment">                        and np-&gt;next = p;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        update the p-&gt;prev and p-&gt;prev-&gt;next;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev-&gt;next = np;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev = np;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(p-&gt;prev=p-&gt;prev-&gt;next= <span class="keyword">new</span> Node(x,p-&gt;prev, p));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器处的对象,因此删除也会导致迭代器破坏*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator itr)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        <span class="comment">/*得到新的迭代器，并初始化*/</span></span><br><span class="line">                        <span class="function">iterator <span class="title">retVal</span><span class="params">(p-&gt;next)</span></span>;</span><br><span class="line">                        <span class="comment">/*更新链表的链接关系*/</span></span><br><span class="line">                        p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">                        p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">                        <span class="comment">/*删除对象*/</span></span><br><span class="line">                        <span class="keyword">delete</span> p;</span><br><span class="line">                        <span class="comment">/*使得对象数减少*/</span></span><br><span class="line">                        theSize --;</span><br><span class="line">                        <span class="comment">/*返回新的迭代器*/</span></span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器指向的对象*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator start, iterator end)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*for中不使用++itr的原因是erase之后</span></span><br><span class="line"><span class="comment">                         *就是下一个迭代器，因此不需要++操作*/</span></span><br><span class="line">                        <span class="keyword">for</span>(iterator itr = start; itr != end; )</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">/*该操作会导致迭代器更新到下一个*/</span></span><br><span class="line">                                itr = erase(itr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> itr;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*链表中的数据成员*/</span></span><br><span class="line">                <span class="keyword">int</span> theSize;</span><br><span class="line">                Node *head;</span><br><span class="line">                Node *tail;</span><br><span class="line">                <span class="comment">/*初始化函数*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        theSize = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">/*create two sentinel node*/</span></span><br><span class="line">                        <span class="comment">/*构建两个哨兵节点，也就是两个并不算在结构体中的对象*/</span></span><br><span class="line">                        head = <span class="keyword">new</span> Node;</span><br><span class="line">                        tail = <span class="keyword">new</span> Node;</span><br><span class="line">                        <span class="comment">/*绑定起来*/</span></span><br><span class="line">                        head-&gt;next = tail;</span><br><span class="line">                        tail-&gt;prev = head;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/loveyou11111111/article/details/49763197&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;C++标准库中的list的实现原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="list" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/list/"/>
    
    
      <category term="list" scheme="http://yoursite.com/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>deque的实现原理和使用方法详解</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/deque/deque%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/</id>
    <published>2018-06-26T02:07:12.000Z</published>
    <updated>2018-06-26T07:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a>。只用于本人学习。</p><a id="more"></a><h2 id="Deque-简介"><a href="#Deque-简介" class="headerlink" title="Deque 简介"></a>Deque 简介</h2><ol><li>deque是“double—ended queue”的缩写，和vector一样都是STL的容器，deque 是双端数组，而 vector 是单端的。</li><li>deque 在接口上和 vector 非常相似，在许多操作的地方可以直接替换。</li><li>deque 可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法，这个等下会详讲）。</li><li>deque 头部和尾部添加或移除元素都非常快速。但是在中间插入元素或移除元素比较费时。</li><li>使用时需要包含头文件 #include<deque> 。</deque></li></ol><h2 id="Deque-实现原理"><a href="#Deque-实现原理" class="headerlink" title="Deque 实现原理"></a>Deque 实现原理</h2><h3 id="deque-的中控器"><a href="#deque-的中控器" class="headerlink" title="deque 的中控器"></a>deque 的中控器</h3><p>deque是连续空间（至少逻辑上看来如此），连续线性空间总令我们联想到array或vector。<strong>array无法成长，vector虽可成长</strong>，却只能向尾端成长，而且其所谓的成长原是个假象，事实上是<font color="blue"><strong>（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。</strong></font>如果不是vector每次配置新空间时都有留下一些余裕，其成长假象所带来的代价将是相当高昂。</p><font color="blue"><strong>deque系由一段一段的定量连续空间构成。</strong></font>一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。<br><br>受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。<br><br><font color="blue"><strong>deque采用一块所谓的map作为主控</strong>。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，<strong>指向另一段（较大的）连续线性空间，称为缓冲区</strong>。<strong>缓冲区才是deque的储存空间主体</strong>。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。</font><p>deque的整体架构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequeStruct.png" alt="deque的整体架构"></p><h3 id="deque-的迭代器"><a href="#deque-的迭代器" class="headerlink" title="deque 的迭代器"></a>deque 的迭代器</h3><p>让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针，分别为cur, first, last, node。</p><p>指针结构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequePointer.png" alt="指针结构"></p><p>在上面介绍中我们大致了解了deque 的基本概念和实现原理，现在我就开始介绍如何使用 deque。</p><h2 id="deque-使用"><a href="#deque-使用" class="headerlink" title="deque 使用"></a>deque 使用</h2><h3 id="deque-对象的默认构造"><a href="#deque-对象的默认构造" class="headerlink" title="deque 对象的默认构造"></a>deque 对象的默认构造</h3><p>deque 采用模板类实现，deque 对象的默认构造形式：deque<t> dequeT；   </t></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deqInt;            <span class="comment">//一个存放int的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">float</span>&gt; deqFloat;       <span class="comment">//一个存放float的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; deqString;     <span class="comment">//一个存放string的deque容器。  </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>尖括号内还可以设置指针类型或自定义类型。</p><h3 id="deque-元素添加移除操作"><a href="#deque-元素添加移除操作" class="headerlink" title="deque 元素添加移除操作"></a>deque 元素添加移除操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.push_back(elem);       <span class="comment">//在容器尾部添加一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.push_front(elem);     <span class="comment">//在容器头部插入一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_back();           <span class="comment">//删除容器最后一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_front();          <span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-的数据存取"><a href="#deque-的数据存取" class="headerlink" title="deque 的数据存取"></a>deque 的数据存取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.at(idx);    <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。  </span></span><br><span class="line"><span class="built_in">deque</span>[idx];      <span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。  </span></span><br><span class="line"><span class="built_in">deque</span>.front();   <span class="comment">//返回第一个数据。  </span></span><br><span class="line"><span class="built_in">deque</span>.back();    <span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-与迭代器"><a href="#deque-与迭代器" class="headerlink" title="deque 与迭代器"></a>deque 与迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.begin();  <span class="comment">//返回容器中第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.end();  <span class="comment">//返回容器中最后一个元素之后的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rbegin();  <span class="comment">//返回容器中倒数第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rend();   <span class="comment">//返回容器中倒数最后一个元素之后的迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="deque-对象的带参数构造"><a href="#deque-对象的带参数构造" class="headerlink" title="deque 对象的带参数构造"></a>deque 对象的带参数构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(beg,end);    <span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);   <span class="comment">//构造函数将n个elem拷贝给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);  <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的赋值"><a href="#deque-的赋值" class="headerlink" title="deque 的赋值"></a>deque 的赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.assign(beg,end);   <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>.assign(n,elem);  <span class="comment">//将n个elem拷贝赋值给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); <span class="comment">//重载等号操作符   </span></span><br><span class="line"><span class="built_in">deque</span>.swap(deq);  <span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD;  </span><br><span class="line">deqIntA.push_back(<span class="number">1</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">3</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">5</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">7</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">9</span>);  </span><br><span class="line">  </span><br><span class="line">deqIntB.assign(deqIntA.begin(),deqIntA.end());  <span class="comment">// 1 3 5 7 9  </span></span><br><span class="line">      </span><br><span class="line">deqIntC.assign(<span class="number">5</span>,<span class="number">8</span>);        <span class="comment">//8 8 8 8 8  </span></span><br><span class="line">  </span><br><span class="line">deqIntD = deqIntA;      <span class="comment">//1 3 5 7 9  </span></span><br><span class="line">  </span><br><span class="line">deqIntC.swap(deqIntD);      <span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h3 id="deque-的大小"><a href="#deque-的大小" class="headerlink" title="deque 的大小"></a>deque 的大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();      <span class="comment">//返回容器中元素的个数  </span></span><br><span class="line"><span class="built_in">deque</span>.empty();     <span class="comment">//判断容器是否为空  </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);   <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。  </span></span><br><span class="line">                    <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。     </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。  </span></span><br><span class="line">                        <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的插入"><a href="#deque-的插入" class="headerlink" title="deque 的插入"></a>deque 的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.insert(pos,elem);   <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,n,elem);   <span class="comment">//在pos位置插入n个elem数据，无返回值。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,beg,end);   <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的删除"><a href="#deque-的删除" class="headerlink" title="deque 的删除"></a>deque 的删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.clear();  <span class="comment">//移除容器的所有数据  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(beg,end);  <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(pos);    <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> 让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针。<br>在进行迭代器的移动时，需要考虑跨缓冲区的情况。</p><p>重载前加(减)，在实现后加(减)时，调用重载的前加(减)。<br>重载+=,实现+时，直接调用+=,实现-=时，调用+=负数，实现-时，调用-=.<br>//当需要实现新的功能时，最好使用已经重载好的操作，即方便有安全。。。。</p><p>另外，deque在效率上来说是不够vector好的，因此有时候在对deque进行sort的时候，需要先将元素移到vector再进行sort，然后移回来。</p><p>构造函数：根据缓冲区设置大小和元素个数，决定map的大小；给map分配空间，根据缓冲区的个数，分配缓冲区，默认指定一个缓冲区；<br> 设置start和finish迭代器，满足左闭右开的原则。<br> push_back:如果空间满足，直接插入；不满足，调用push_back_aux。<br> push_back_aux:先调用reverse_map_at_back,若符合某种条件，重换一个map；分配空间。<br> reserve_map_at_back:看看map有没有满，满的话，调用reallocate_map。<br> reallocate_map:如果前端或后端pop过多，就会导致大量的空闲空间，如果是这种情况，则不用新分配空间，调整一下start的位置即可；<br> 如果不够，则需要重新申请空间。<br> pop：析构元素，如果是最后一块还需要删除空间。<br> erase：需要判断，前面的元素少还是后面的元素少，移动较少的部分。<br> insert：判断位置，如果为前端或后端直接调用push操作，否则，移动较少的一端。</p><p>deque的构造与内存管理：</p><p>由于deque的设计思想就是由一块块的缓存区连接起来的，因此它的内存管理会比较复杂。插入的时候要考虑是否要跳转缓存区、是否要新建map节点（和vector一样，其实是重新分配一块空间给map，删除原来空间）、插入后元素是前面元素向前移动还是后面元素向后面移动（谁小移动谁）。而在删除元素的时候，考虑是将前面元素后移覆盖需要移除元素的地方还是后面元素前移覆盖（谁小移动谁）。移动完以后要析构冗余的元素，释放冗余的缓存区。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//   deque的特性:  </span></span><br><span class="line"><span class="regexp">//</span>   对于任何一个迭代器i  </span><br><span class="line"><span class="regexp">//     i.node是map array中的某元素的地址. i.node的内容是一个指向某个结点的头的指针  </span></span><br><span class="line"><span class="regexp">//</span>     i.first == *(i.node)  </span><br><span class="line"><span class="regexp">//     i.last  == i.first + node_size  </span></span><br><span class="line"><span class="regexp">//</span>     i.cur是一个指向[i.first, i.last)之间的指针  </span><br><span class="line"><span class="regexp">//       注意: 这意味着i.cur永远是一个可以解引用的指针,  </span></span><br><span class="line"><span class="regexp">//</span>            即使其是一个指向结尾后元素的迭代器  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   起点和终点总是非奇异(nonsingular)的迭代器.  </span><br><span class="line"><span class="regexp">//     注意: 这意味着空deque一定有一个node, 而一个具有N个元素的deque  </span></span><br><span class="line"><span class="regexp">//</span>          (N是Buffer Size)一定有有两个nodes  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   对于除了start.node和finish.node之外的每一个node, 每一个node中的元素  </span><br><span class="line"><span class="regexp">//   都是一个初始化过的对象. 如果start.node == finish.node,  </span></span><br><span class="line"><span class="regexp">//</span>   那么[start.cur, finish.cur)都是未初始化的空间.  </span><br><span class="line"><span class="regexp">//   否则, [start.cur, start.last)和[finish.first, finish.cur)都是初始化的对象,  </span></span><br><span class="line"><span class="regexp">//</span>   而[start.first, start.cur)和[finish.cur, finish.last)是未初始化的空间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   [map, map + map_size)是一个合法的非空区间  </span><br><span class="line"><span class="regexp">//   [start.node, finish.node]是内含在[map, map + map_size)区间的合法区间  </span></span><br><span class="line"><span class="regexp">//</span>   一个在[map, map + map_size)区间内的指针指向一个分配过的node,  </span><br><span class="line"><span class="regexp">//   当且仅当此指针在[start.node, finish.node]区间内  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">inline size_t __deque_buf_size(size_t n, size_t sz)    </span></span><br><span class="line"><span class="regexp">&#123;    </span></span><br><span class="line"><span class="regexp">  return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));    </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> __deque_iterator的数据结构  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;  </span></span><br><span class="line">struct __deque_iterator  </span><br><span class="line">&#123;  </span><br><span class="line">    typedef __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">    typedef __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">    static size_t buffer_size() &#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, sizeof(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">    typedef random_access_iterator_tag iterator_category;  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef Ptr pointer;  </span><br><span class="line">    typedef Ref reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">    typedef T** map_pointer;  </span><br><span class="line">  </span><br><span class="line">    typedef __deque_iterator self;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 保持与容器的联结  </span></span><br><span class="line"><span class="regexp">    T* cur;       //</span> 此迭代器所指之缓冲区中的现行元素  </span><br><span class="line">    T* first;     <span class="regexp">// 此迭代器所指之缓冲区的头  </span></span><br><span class="line"><span class="regexp">    T* last;      //</span> 此迭代器所指之缓冲区的尾（含备用空间）  </span><br><span class="line">    map_pointer node;    <span class="regexp">// 指向管控中心  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 这个是deque内存管理的关键, 其模型如下  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------  </span><br><span class="line"><span class="regexp">// map--&gt;|   |   |   |   |   |   | ..... |   |   |   |&lt;------------------  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------                  |  </span><br><span class="line"><span class="regexp">//             |                                                        |  </span></span><br><span class="line"><span class="regexp">//</span>             |                                                        |  </span><br><span class="line"><span class="regexp">//             |   node                                                 |  </span></span><br><span class="line"><span class="regexp">//</span>             |   缓冲区buffer, 这里实际存储元素                          |  </span><br><span class="line"><span class="regexp">//             |   ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>             -<span class="function">--&gt;</span>|   |   |   |   |   |   | ..... |   |   | X |        |  </span><br><span class="line"><span class="regexp">//                 ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>                   ↑       ↑                             ↑            |  </span><br><span class="line"><span class="regexp">//             ------        |                             |            |  </span></span><br><span class="line"><span class="regexp">//</span>             |             |                             |            |  </span><br><span class="line"><span class="regexp">//             |   -----------   ---------------------------            |  </span></span><br><span class="line"><span class="regexp">//</span>             ----|-----        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>                 |    |        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------                             |  </span><br><span class="line"><span class="regexp">//              | cur | first | end | map |------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------  </span><br><span class="line"><span class="regexp">//              迭代器, 其内部维护着一个缓冲区状态  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(T* x, map_pointer y)  </span></span><br><span class="line"><span class="regexp">        : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator() : cur(0), first(0), last(0), node(0) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(const iterator&amp; x)  </span></span><br><span class="line"><span class="regexp">        : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference operator*() const &#123; return *cur; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 判断两个迭代器间的距离  </span><br><span class="line">    difference_type operator-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">            (cur - first) + (x.last - x.cur);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 下面重载的这些运算符是让deque从外界看上去维护的是一段连续空间的关键!!!  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 前缀自增  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 如果当前迭代器指向元素是当前缓冲区的最后一个元素,  </span></span><br><span class="line"><span class="regexp">//</span> 则将迭代器状态调整为下一个缓冲区的第一个元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 不是当前缓冲区最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first          cur                     end  </span><br><span class="line"><span class="regexp">// ↓               ↓                       ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first              cur                 end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                   ↓                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 当前元素为当前缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first                              cur end  </span><br><span class="line"><span class="regexp">// ↓                                   ↓   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first                                  end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                                       ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 下一缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> ↑  </span><br><span class="line"><span class="regexp">// cur  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">    self&amp; operator++()  </span><br><span class="line">    &#123;  </span><br><span class="line">        ++cur;    <span class="regexp">// 切换至下一个元素  </span></span><br><span class="line"><span class="regexp">        if (cur == last)    //</span> 如果已达到缓冲区的尾端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node + <span class="number">1</span>);    <span class="regexp">// 就切换至下一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = first;           //</span> 的第一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 后缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增  </span><br><span class="line">    self operator++(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        ++*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 前缀自减, 处理方式类似于前缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 如果当前迭代器指向元素是当前缓冲区的第一个元素  </span><br><span class="line">    <span class="regexp">// 则将迭代器状态调整为前一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    self&amp; operator--()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (cur == first)    //</span> 如果已达到缓冲区的头端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node - <span class="number">1</span>);    <span class="regexp">// 就切换至前一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = last;            //</span> 的最后一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        --cur;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator--(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        --*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 将迭代器向前移动n个元素, n可以为负  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                     operator+=(difference_type n)  </span><br><span class="line"><span class="regexp">//                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span>                      offset = n + (cur - first)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------- offset &gt; <span class="number">0</span> ? &amp;&amp;  </span><br><span class="line"><span class="regexp">//                                   |           移动后是否超出当前缓冲区?  </span></span><br><span class="line"><span class="regexp">//</span>               ----------------------------  </span><br><span class="line"><span class="regexp">//           No  |                          |  Yes  </span></span><br><span class="line"><span class="regexp">//</span>               |                          |  </span><br><span class="line"><span class="regexp">//               ↓                          |---------- offset &gt; 0?  </span></span><br><span class="line"><span class="regexp">//</span>           cur += n;                      |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                          Yes |                          | No  </span><br><span class="line"><span class="regexp">//                              |                          |  </span></span><br><span class="line"><span class="regexp">//</span>                              ↓                          |  </span><br><span class="line"><span class="regexp">//                   计算要向后移动多少个缓冲区                |  </span></span><br><span class="line"><span class="regexp">//</span>                   node_offset =                         |  </span><br><span class="line"><span class="regexp">//                   offset / difference_type              |  </span></span><br><span class="line"><span class="regexp">//</span>                   (buffer_size());                      ↓  </span><br><span class="line"><span class="regexp">//                              |           计算要向前移动多少个缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              |           node_offset = -difference_type  </span><br><span class="line"><span class="regexp">//                              |           ((-offset - 1) / buffer_size()) - 1;  </span></span><br><span class="line"><span class="regexp">//</span>                              |                          |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                                           |  </span><br><span class="line"><span class="regexp">//                                           |  </span></span><br><span class="line"><span class="regexp">//</span>                                           ↓  </span><br><span class="line"><span class="regexp">//                                       调整缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              set_node(node + node_offset);  </span><br><span class="line"><span class="regexp">//                                    计算并调整cur指针  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    //</span> 以下实现随机存取。迭代器可以直接跳跃n个距离  </span><br><span class="line">    self&amp; operator+=(difference_type n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type offset = n + (cur - first);  </span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">            cur += n;        <span class="regexp">// 目标位置在同一缓冲区内  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">        &#123;           //</span> 目标位置不在同一缓冲区内  </span><br><span class="line">            difference_type node_offset =  </span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">            <span class="regexp">// 切换至正确的节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            set_node(node + node_offset);  </span></span><br><span class="line"><span class="regexp">            //</span> 切换至正确的元素  </span><br><span class="line">            cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator+(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 这里调用了operator +=()可以自动调整指针状态  </span></span><br><span class="line"><span class="regexp">        return tmp += n;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 将n变为-n就可以使用operator +=()了,  </span><br><span class="line">    self&amp; operator-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator-(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp -= n;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    reference operator[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  </span><br><span class="line">    bool operator==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">    bool operator!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">    bool operator&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> set_node(map_pointer new_node)  </span><br><span class="line">    &#123;  </span><br><span class="line">        node = new_node;  </span><br><span class="line">        first = *new_node;  </span><br><span class="line">        last = first + difference_type(buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// deque的数据结构  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;  </span></span><br><span class="line"><span class="regexp">class deque  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Basic types  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef value_type* pointer;  </span><br><span class="line">    typedef value_type&amp; reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Iterators  </span></span><br><span class="line"><span class="regexp">    typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;       iterator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:                      //</span> Internal typedefs  </span><br><span class="line">  </span><br><span class="line">    typedef pointer* map_pointer;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 这个提供STL标准的allocator接口, 见&lt;stl_alloc.h&gt;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 获取缓冲区最大存储元素数量  </span><br><span class="line">    static size_type buffer_size()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> __deque_buf_size(BufSiz, sizeof(value_type));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static size_type initial_map_size() &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;  </span><br><span class="line">  </span><br><span class="line">protected:                      <span class="regexp">// Data members  </span></span><br><span class="line"><span class="regexp">    iterator start;               //</span> 起始缓冲区  </span><br><span class="line">    iterator finish;              <span class="regexp">// 最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 指向map, map是一个连续的空间, 其每个元素都是一个指针，指向一个节点（缓冲区）  </span><br><span class="line">    map_pointer map;  </span><br><span class="line">    size_type map_size;   <span class="regexp">// map容量  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:  </span></span><br><span class="line"><span class="regexp">    iterator begin() &#123; return start; &#125;  </span></span><br><span class="line"><span class="regexp">    iterator end() &#123; return finish; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 提供随机访问能力, 其调用的是迭代器重载的operator []  </span><br><span class="line">    <span class="regexp">// 其实际地址需要进行一些列的计算, 效率有损失  </span></span><br><span class="line"><span class="regexp">    reference operator[](size_type n) &#123; return start[difference_type(n)]; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference front() &#123; return *start; &#125;  </span></span><br><span class="line"><span class="regexp">    reference back()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        iterator tmp = finish;  </span></span><br><span class="line"><span class="regexp">        --tmp;  </span></span><br><span class="line"><span class="regexp">        return *tmp;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 当前容器拥有的元素个数, 调用迭代器重载的operator -  </span><br><span class="line">    size_type size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> finish - start;; &#125;  </span><br><span class="line">    size_type max_size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// deque为空的时, 只有一个缓冲区  </span></span><br><span class="line"><span class="regexp">    bool empty() const &#123; return finish == start; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Constructor, destructor.  </span><br><span class="line">    deque() : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        create_map_and_nodes(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(size_type n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(int n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    ~deque()  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start, finish);     <span class="regexp">// &lt;stl_construct.h&gt;  </span></span><br><span class="line"><span class="regexp">        destroy_map_and_nodes();  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    deque&amp; operator= (const deque&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 其实我觉得把这个操作放在<span class="keyword">if</span>内效率更高  </span><br><span class="line">        <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">        <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 当前容器比x容器拥有元素多, 析构多余元素  </span></span><br><span class="line"><span class="regexp">            if (len &gt;= x.size())  </span></span><br><span class="line"><span class="regexp">                erase(copy(x.begin(), x.end(), start), finish);  </span></span><br><span class="line"><span class="regexp">            //</span> 将x所有超出部分的元素使用insert()追加进去  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">                copy(x.begin(), mid, start);  </span><br><span class="line">                insert(finish, mid, x.end());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:  </span><br><span class="line">    <span class="literal">void</span> push_back(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 最后缓冲区尚有两个（含）以上的元素备用空间  </span></span><br><span class="line"><span class="regexp">        if (finish.cur != finish.last - 1)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(finish.cur, t);     //</span> 直接在备用空间上构造元素  </span><br><span class="line">            ++finish.cur;     <span class="regexp">// 调整最后缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 容量已满就要新申请内存了  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            push_back_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> push_front(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (start.cur != start.first)      <span class="regexp">// 第一缓冲区尚有备用空间  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(start.cur - 1, t);   //</span> 直接在备用空间上构造元素  </span><br><span class="line">            --start.cur;     <span class="regexp">// 调整第一缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else    //</span> 第一缓冲区已无备用空间  </span><br><span class="line">            push_front_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> pop_back()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (finish.cur != finish.first)    <span class="regexp">// 最后缓冲区有一个（或更多）元素  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            --finish.cur;    //</span> 调整指针，相当于排除了最后元素  </span><br><span class="line">            destroy(finish.cur);    <span class="regexp">// 将最后元素析构  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">            //</span> 最后缓冲区没有任何元素  </span><br><span class="line">            pop_back_aux();    <span class="regexp">// 这里将进行缓冲区的释放工作  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void pop_front()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (start.cur != start.last - 1)    //</span> 第一缓冲区有两个（或更多）元素  </span><br><span class="line">        &#123;  </span><br><span class="line">            destroy(start.cur);    <span class="regexp">// 将第一元素析构  </span></span><br><span class="line"><span class="regexp">            ++start.cur;           //</span>调整指针，相当于排除了第一元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="regexp">// 第一缓冲区仅有一个元素  </span></span><br><span class="line"><span class="regexp">            pop_front_aux();    //</span> 这里将进行缓冲区的释放工作  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Insert  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//             insert(iterator position, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |---------------- 判断插入位置  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> deque.begin() |          deque.emd() |                      |  </span><br><span class="line"><span class="regexp">//               |                      |                      |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                      ↓                      |  </span><br><span class="line"><span class="regexp">//         push_front(x);         push_back(x);                |  </span></span><br><span class="line"><span class="regexp">//</span>                                                             ↓  </span><br><span class="line"><span class="regexp">//                                                 insert_aux(position, x);  </span></span><br><span class="line"><span class="regexp">//</span>                                                 具体剖析见后面实现  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 如果是在deque的最前端插入, 那么直接push_front()即可  </span></span><br><span class="line"><span class="regexp">        if (position.cur == start.cur)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            push_front(x);  </span></span><br><span class="line"><span class="regexp">            return start;  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 如果是在deque的末尾插入, 直接调用push_back()  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur)  </span><br><span class="line">        &#123;  </span><br><span class="line">            push_back(x);  </span><br><span class="line">            iterator tmp = finish;  </span><br><span class="line">            --tmp;  </span><br><span class="line">            <span class="keyword">return</span> tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> insert_aux(position, x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position) &#123; <span class="keyword">return</span> insert(position, value_type()); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 详解见实现部分  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, size_type n, const value_type&amp; x);  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, int n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, long n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void resize(size_type new_size) &#123; resize(new_size, value_type()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Erase  </span><br><span class="line">  </span><br><span class="line">    iterator erase(iterator pos)  </span><br><span class="line">    &#123;  </span><br><span class="line">        iterator next = pos;  </span><br><span class="line">        ++next;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 清除点之前的元素个数  </span></span><br><span class="line"><span class="regexp">        difference_type index = pos - start;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">        //</span> 如果清除点之前的元素个数比较少, 哪部分少就移动哪部分  </span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 就移动清除点之前的元素  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, pos, next);  </span></span><br><span class="line"><span class="regexp">            pop_front();   //</span> 移动完毕，最前一个元素冗余，去除之  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   <span class="regexp">// 如果清除点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(next, finish, pos);  //</span> 就移动清除点之后的元素  </span><br><span class="line">            pop_back();   <span class="regexp">// 移动完毕，最后一个元素冗余，去除之  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        return start + index;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    iterator erase(iterator first, iterator last);  </span></span><br><span class="line"><span class="regexp">    void clear();  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 详解见实现部分  </span><br><span class="line">    <span class="literal">void</span> push_back_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> push_front_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> pop_back_aux();  </span><br><span class="line">    <span class="literal">void</span> pop_front_aux();  </span><br><span class="line">  </span><br><span class="line">    iterator insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">    <span class="literal">void</span> insert_aux(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 分配内存, 不进行构造  </span></span><br><span class="line"><span class="regexp">    pointer allocate_node() &#123; return data_allocator::allocate(buffer_size()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 释放内存, 不进行析构  </span><br><span class="line">    <span class="literal">void</span> deallocate_node(pointer n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        data_allocator::deallocate(n, buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 清除[first, last)区间的所有元素  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                  erase(iterator first, iterator last)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------------- 是否要删除整个区间?  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>               ------------------------------------------  </span><br><span class="line"><span class="regexp">//           Yes |                                        | No  </span></span><br><span class="line"><span class="regexp">//</span>               |                                        |  </span><br><span class="line"><span class="regexp">//               ↓                                        | --- 判断哪侧元素少  </span></span><br><span class="line"><span class="regexp">//</span>            clear();                                    ↓  </span><br><span class="line"><span class="regexp">//       -----------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> 左侧少 |                                                         右侧少 |  </span><br><span class="line"><span class="regexp">//       |                                                               |  </span></span><br><span class="line"><span class="regexp">//</span>       ↓                                                               ↓  </span><br><span class="line"><span class="regexp">//   copy_backward(start, first, last);            copy(last, finish, first);  </span></span><br><span class="line"><span class="regexp">//</span>   new_start = start + n;                        new_finish = finish - n;  </span><br><span class="line"><span class="regexp">//   析构多余的元素                                  析构多余的元素  </span></span><br><span class="line"><span class="regexp">//</span>   destroy(start, new_start);                    destroy(new_finish, finish);  </span><br><span class="line"><span class="regexp">//   释放多余内存空间                                释放多余内存空间  </span></span><br><span class="line"><span class="regexp">//</span>   <span class="keyword">for</span> (...)                                     <span class="keyword">for</span> (...)  </span><br><span class="line"><span class="regexp">//      ...                                             ...  </span></span><br><span class="line"><span class="regexp">//</span>   更新map状态                                    更新map状态  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish)   <span class="regexp">// 如果清除区间是整个deque  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        clear();              //</span> 直接调用clear()即可  </span><br><span class="line">        <span class="keyword">return</span> finish;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type n = last - first;   <span class="regexp">// 清除区间的长度  </span></span><br><span class="line"><span class="regexp">        difference_type elems_before = first - start;   //</span> 清除区间前方的元素个数  </span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>)   <span class="regexp">// 如果前方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, first, last);  //</span> 向后移动前方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_start = start + n;     <span class="regexp">// 标记deque的新起点  </span></span><br><span class="line"><span class="regexp">            destroy(start, new_start);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            start = new_start;   //</span> 设定deque的新起点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>    <span class="regexp">// 如果清除区间后方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(last, finish, first);  //</span> 向前移动后方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_finish = finish - n;     <span class="regexp">// 标记deque的新尾点  </span></span><br><span class="line"><span class="regexp">            destroy(new_finish, finish);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            finish = new_finish;   //</span> 设定deque的新尾点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::clear()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="regexp">// 以下针对头尾以外的每一个缓冲区  </span></span><br><span class="line"><span class="regexp">    for (map_pointer node = start.node + 1; node &lt; finish.node; ++node)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 将缓冲区内的所有元素析构  </span><br><span class="line">        destroy(*node, *node + buffer_size());  </span><br><span class="line">        <span class="regexp">// 释放缓冲区内存  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(*node, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    if (start.node != finish.node)   //</span> 至少有头尾两个缓冲区  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start.cur, start.last);  <span class="regexp">// 将头缓冲区的目前所有元素析构  </span></span><br><span class="line"><span class="regexp">        destroy(finish.first, finish.cur);  //</span> 将尾缓冲区的目前所有元素析构  </span><br><span class="line">        <span class="regexp">// 以下释放尾缓冲区。注意：头缓冲区保留  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(finish.first, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    else   //</span> 只有一个缓冲区  </span><br><span class="line">        destroy(start.cur, finish.cur);   <span class="regexp">// 将此唯一缓冲区内的所有元素析构  </span></span><br><span class="line"><span class="regexp">        //</span> 注意：并不释放缓冲区空间，这唯一的缓冲区将保留  </span><br><span class="line">  </span><br><span class="line">    finish = start;   <span class="regexp">// 调整状态  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当finish.cur == finish.last - <span class="number">1</span> 时才会被调用  </span><br><span class="line"><span class="regexp">// 也就是说，只有当最后一个缓冲区只剩下一个备用元素空间时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t)  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    value_type t_copy = t;  </span></span><br><span class="line"><span class="regexp">    reserve_map_at_back();  </span></span><br><span class="line"><span class="regexp">    *(finish.node + 1) = allocate_node();    //</span> 配置一个新节点（缓冲区）  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        construct(finish.cur, t_copy);         <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">        finish.set_node(finish.node + 1);      //</span> 改变finish，令其指向新节点  </span><br><span class="line">        finish.cur = finish.first;             <span class="regexp">// 设定finish的状态  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    __STL_UNWIND(deallocate_node(*(finish.node + 1)));  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> Called only <span class="keyword">if</span> start.cur == start.first.  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">&#123;  </span><br><span class="line">    value_type t_copy = t;  </span><br><span class="line">    reserve_map_at_front();  </span><br><span class="line">    *(start.node - <span class="number">1</span>) = allocate_node();  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        start.set_node(start.node - <span class="number">1</span>);        <span class="regexp">// 改变start，令其指向新节点  </span></span><br><span class="line"><span class="regexp">        start.cur = start.last - 1;            //</span> 设定start的状态  </span><br><span class="line">        construct(start.cur, t_copy);          <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    catch(...)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        start.set_node(start.node + 1);  </span></span><br><span class="line"><span class="regexp">        start.cur = start.first;  </span></span><br><span class="line"><span class="regexp">        deallocate_node(*(start.node - 1));  </span></span><br><span class="line"><span class="regexp">        throw;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当 finish.cur == finish.first 时才会被调用  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;:: pop_back_aux()  </span><br><span class="line">&#123;  </span><br><span class="line">    deallocate_node(finish.first);      <span class="regexp">// 释放最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">    finish.set_node(finish.node - 1);   //</span> 调整finish状态，使指向  </span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;       <span class="regexp">// 上一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    destroy(finish.cur);                //</span> 将该元素析构  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// 只有当 start.cur == start.last - 1 时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux()  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    destroy(start.cur);    //</span> 将第一个缓冲区的第一个（也是最后一个、唯一一个）元素析构  </span><br><span class="line">    deallocate_node(start.first);    <span class="regexp">// 释放第一缓冲区  </span></span><br><span class="line"><span class="regexp">    start.set_node(start.node + 1);  //</span> 调整start状态，使指向  </span><br><span class="line">    start.cur = start.first;         <span class="regexp">// 下一个缓冲区的第一个元素  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//              insert_aux(iterator pos, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |----------- 判断pos前端元素少还是后端元素少  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         前端少 |                                       后端少 |  </span><br><span class="line"><span class="regexp">//               |                                             |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                                             |  </span><br><span class="line"><span class="regexp">//           进行相关操作                                   进行相关操作  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 下面以pos前面元素少的情形进行说明, 为了简化, 假设操作不会超过一个缓冲区区间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 插入前状态  </span><br><span class="line"><span class="regexp">//           start            pos                                 end  </span></span><br><span class="line"><span class="regexp">//</span>             ↓               ↓                                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 需要进行操作的区间  </span></span><br><span class="line"><span class="regexp">//</span>                需要拷贝的区间  </span><br><span class="line"><span class="regexp">//                 -------------  </span></span><br><span class="line"><span class="regexp">//</span>       start     |           |                                  end  </span><br><span class="line"><span class="regexp">//         ↓       ↓           ↓                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">//             ↑   ↑       ↑   ↑  </span></span><br><span class="line"><span class="regexp">//</span>        front1   |       |   |  </span><br><span class="line"><span class="regexp">//                 |       |   |  </span></span><br><span class="line"><span class="regexp">//</span>            front2       |   |  </span><br><span class="line"><span class="regexp">//                         |   |  </span></span><br><span class="line"><span class="regexp">//</span>                       pos   |  </span><br><span class="line"><span class="regexp">//                             |  </span></span><br><span class="line"><span class="regexp">//</span>                          pos1  </span><br><span class="line"><span class="regexp">// 拷贝操作完成后  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">//         这是[front2, pos1)  </span></span><br><span class="line"><span class="regexp">//</span>             ------------- --------- 这里是给待插入元素预留的空间  </span><br><span class="line"><span class="regexp">//       start |           | |                                    end  </span></span><br><span class="line"><span class="regexp">//</span>         ↓   ↓           ↓ ↓                                     ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         ↑  </span><br><span class="line"><span class="regexp">//   这里存储的是原来的front()  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">typename deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">&#123;  </span><br><span class="line">    difference_type index = pos - start;   <span class="regexp">// 插入点之前的元素个数  </span></span><br><span class="line"><span class="regexp">    value_type x_copy = x;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 前面的时候用的移位操作, 这里怎么不用了呢^_^?  </span><br><span class="line">    <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>)    <span class="regexp">// 如果插入点之前的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_front(front());       //</span> 在最前端加入与第一元素同值的元素  </span><br><span class="line">        iterator front1 = start;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        ++front1;  </span></span><br><span class="line"><span class="regexp">        iterator front2 = front1;  </span></span><br><span class="line"><span class="regexp">        ++front2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        iterator pos1 = pos;  </span></span><br><span class="line"><span class="regexp">        ++pos1;  </span></span><br><span class="line"><span class="regexp">        copy(front2, pos1, front1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>    <span class="regexp">// 插入点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_back(back());         //</span> 在最尾端加入与最后元素同值的元素  </span><br><span class="line">        iterator back1 = finish;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        --back1;  </span></span><br><span class="line"><span class="regexp">        iterator back2 = back1;  </span></span><br><span class="line"><span class="regexp">        --back2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        copy_backward(pos, back2, back1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    *pos = x_copy;    <span class="regexp">// 在插入点上设定新值  </span></span><br><span class="line"><span class="regexp">    return pos;  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="源网址"><a href="#源网址" class="headerlink" title="源网址"></a>源网址</h2><ul><li><a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a></li><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7729451" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析—deque</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/baidu_28312631/article/details/48000123&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;STL源码剖析——deque的实现原理和使用方法详解&lt;/a&gt;。只用于本人学习。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="deque" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/deque/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>Markdown公式编辑</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/markdowm/Markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/wiki/工具/markdowm/Markdown公式编辑学习笔记/</id>
    <published>2018-06-25T04:11:12.000Z</published>
    <updated>2018-06-26T03:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown中使用LaTEX 编写含有数学公式的博客。</p><a id="more"></a><h2 id="如何插入公式"><a href="#如何插入公式" class="headerlink" title="如何插入公式"></a>如何插入公式</h2><ol><li>行中公式（放在文中与其他文字编辑）：可以用如下方法表示：<code>$数学公式$</code></li><li>独立公式可以用下面的方法表示：<code>$$数学公式$$</code></li><li>自动编号的公式可以用如下的方法表示：<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">数学公式</span><br><span class="line"><span class="tag">\<span class="name">label</span><span class="string">&#123;eq:当前公式名&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">自动编号后的公式可在全文任意处使用 <span class="tag">\<span class="name">eqref</span><span class="string">&#123;eq:公式名&#125;</span></span> 语句引用。</span><br></pre></td></tr></table></figure></li></ol><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，not one line &#125; $</span></span><br></pre></td></tr></table></figure><p>显示$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，not one line } $</p><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，独立公式示例&#125;$$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p><code>^</code> 表示上标， <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>{}</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</p><p>例子</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> x^&#123;y^z&#125;=(<span class="number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="number">-2</span>xy^w&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</p><p>另外，如果要在左右两边都有上下标，可以用<code>\sideset</code> 命令</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \sideset&#123;^<span class="number">1</span>_2&#125;&#123;^<span class="number">3</span>_4&#125;\bigotimes <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p><h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code>。当要显示大号的括号或分隔符时，要用 \left 和 \right 命令。<br>一些特殊的括号：</p><table><thead><tr><th>输入</th><th>显示</th></tr></thead><tbody><tr><td><code>$$\langle表达式\rangle$$</code></td><td>$$\langle表达式\rangle$$</td></tr><tr><td><code>$$\lceil表达式\rceil$$</code></td><td>$$\lceil表达式\rceil$$</td></tr><tr><td><code>$$\lfloor表达式\rfloor$$</code></td><td>$$\lfloor表达式\rfloor$$</td></tr><tr><td><code>$$\lbrace表达式\rbrace$$</code></td><td>$$\lbrace表达式\rbrace$$</td></tr></tbody></table><p>例子</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x,y,z) = <span class="number">3</span>y^<span class="number">2</span>z \left( <span class="number">3</span>+\frac&#123;<span class="number">7</span>x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) $$</span><br></pre></td></tr></table></figure><p>显示<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac {分子} {分母}</code>命令产生一个分数<code>\frac {分子} {分母}</code>，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built-in">frac</span>&#123;a<span class="number">-1</span>&#125;&#123;b<span class="number">-1</span>&#125; \quad <span class="keyword">and</span> \quad &#123;a+<span class="number">1</span>\over b+<span class="number">1</span>&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] {被开方数}</code>命令输入开方。</p><p>例子：</p><p><code>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</code></p><p>显示</p><p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号。</p><p>例子：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">$f</span>(x_1,x_2,<span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\l</span>dots&#125;_&#123;<span class="symbol">\r</span>m ldots&#125; ,x_n) = x_1^2 + x_2^2 + <span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\c</span>dots&#125;_&#123;<span class="symbol">\r</span>m cdots&#125; + x_n^2$$</span><br></pre></td></tr></table></figure><p>显示：</p><p>$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</p><h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec{矢量}</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span> <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">vec</span><span class="string">&#123;b&#125;</span>=<span class="number">0</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">overleftarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overleftrightarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overrightarrow</span><span class="string">&#123;xy&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：<br>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 \int_积分下限^积分上限 {被积表达式} 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th>输入</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td><code>\rm</code></td><td>罗马体</td><td>$$\rm Sample$$</td></tr><tr><td><code>\it</code></td><td>意大利体</td><td>$$\it Sample $$</td></tr><tr><td><code>\bf</code></td><td>粗体</td><td>$$\bf Sample $$</td></tr><tr><td><code>\sf</code></td><td>等线体</td><td>$$\sf Sample $$</td></tr><tr><td><code>\tt</code></td><td>打字机体</td><td>$$\tt Sample $$</td></tr><tr><td><code>\frak</code></td><td>旧德式字体</td><td>$$\frak Sample $$</td></tr><tr><td><code>\cal</code></td><td>花体</td><td>$$\cal Sample $$</td></tr><tr><td><code>\Bbb</code></td><td>黑板粗体</td><td>$$\Bbb Sample $$</td></tr><tr><td><code>\mit</code></td><td>数学斜体</td><td>$$\mit Sample $$</td></tr><tr><td>\scr</td><td>手写体</td><td>$$\scr Sample$$</td></tr></tbody></table><h2 id="积分-1"><a href="#积分-1" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_积分下限^积分上限 {被积表达式}</code> 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示<br>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>使用\lim_{变量 \to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \to 符号至任意符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">lim</span></span>_&#123;n <span class="tag">\<span class="name">to</span></span> +<span class="tag">\<span class="name">infty</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">lim</span></span>_&#123;x<span class="tag">\<span class="name">leftarrow</span><span class="string">&#123;示例&#125;</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> $$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/codeep/note/163962" rel="external nofollow noopener noreferrer" target="_blank">Cmd Markdown 公式指导手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown中使用LaTEX 编写含有数学公式的博客。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="markdowm" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/markdowm/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>数学知识一对数指数</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/数据知识/数学基础知识/</id>
    <published>2018-06-25T04:07:12.000Z</published>
    <updated>2018-06-26T03:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>解换底公式为：</p><p>$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \text{(c＞0，c≠1)} $$</p><p>loga（b）=logc（b）/logc（a）（c＞0，c≠1）<br>推导过程</p><p>令 $ \log_a{b} = t $</p><p>即 $ a^t = b$</p><p>即a^t=b</p><p>两边取以c（c＞0，c≠1）的对数</p><p>即 $ \log_c(a^t) =\log_cb $</p><p>即 $t\log_c{a}=log_cb</p><p>由a≠1，即 $ \log_c{a}≠0$</p><p>所以 $t=\frac{log_cb}{log_ca} $ </p><p>所以： $log_ab= \frac{log_cb}{log_ca}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对数&quot;&gt;&lt;a href=&quot;#对数&quot; class=&quot;headerlink&quot; title=&quot;对数&quot;&gt;&lt;/a&gt;对数&lt;/h2&gt;&lt;p&gt;解换底公式为：&lt;/p&gt;
&lt;p&gt;$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \tex
      
    
    </summary>
    
      <category term="数据知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数学知识" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>运算符优先级表</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/运算符优先级表/</id>
    <published>2018-06-23T04:07:12.000Z</published>
    <updated>2018-07-05T11:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="C-运算符优先级"><a href="#C-运算符优先级" class="headerlink" title="C++ 运算符优先级"></a>C++ 运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;C-运算符优先级&quot;&gt;&lt;a href=&quot;#C-运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;C++ 运算符优先级&quot;&gt;&lt;/a&gt;C++ 运算符优先级&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结合
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="运算符优先级" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>mach-o Viewer 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/Mach_O/machoviewer/"/>
    <id>http://yoursite.com/wiki/IOS/Mach_O/machoviewer/</id>
    <published>2018-06-22T04:07:12.000Z</published>
    <updated>2018-06-22T05:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是 <a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">mach-o Viewer </a>源码学习记录。</p><a id="more"></a><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/datastruct.png" alt="数据结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/overrall.png" alt="代码结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/domainTask.png" alt="domainTask"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是 &lt;a href=&quot;https://github.com/gdbinit/MachOView&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;mach-o Viewer &lt;/a&gt;源码学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="macho" scheme="http://yoursite.com/tags/macho/"/>
    
  </entry>
  
  <entry>
    <title>图解fishhook</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/fishHookPicture/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/fishhook/fishHookPicture/</id>
    <published>2018-06-21T04:07:12.000Z</published>
    <updated>2018-06-22T10:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试9图片解释fishhook原理<br><a id="more"></a></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP1.jpg" alt="图1 __la_symbol_ptr section"></p><p>图1. load command中_DATA segement中<code>__la_symbol_ptr</code> section结构图,说明该section和动态符号表对应的起始索引是146</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP2.jpg" alt="图2 数据区域中__la_symbol_ptr的结构"></p><p>图2.数据区域中<code>__la_symbol_ptr</code>的结构,可以看出该section的起始地址是0x00240B0，图2和图3是为了找malloc函数指针的位置</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP3.jpg" alt="图3 __la_symbol_ptr 中malloc"></p><p>图3.数据区域中__la_symbol_ptr的结构,  偏移了一定的位置。文件0x000242B0地址出存储的是malloc函数指针。</p><p>计算偏移数量的方法：0x242B0  - 0x240B0 = 0x200<br>每个条目占用8个字节0x200/0x8 = 0x40  = 64<br>得出：在符号表中，malloc偏移64个条目</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP4.jpg" alt="图4 动态符号表起始地址"></p><p>图4 .转到数据区域中动态符号表的起始位置处，该图说明动态符号表的起始地址是0x3B0A4</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP5.jpg" alt="图5 动态符号表 __la_symbol_ptr对应处"></p><p>图5 。 计算<strong>la_symbol_ptr 对应的符号在动态符号表中的位置： 0x3B060 + 146*4 = 0x3B060 + 0x248 = 0x3B2A8，<br>地址0x0003B2A8处后面的符号和</strong>la_symbol_ptr中的条目对应。 </p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP6.jpg" alt="图6 动态符号表 __la_symbol_ptr 内部146偏移处"></p><p>图6 .  查找64个偏移后的动态符号表的地址：0x3B2A8 + 0x40*x4 = 0x3B3A8，地址0x3B3A8中存储的值是符号表中的索引，<br>为0xb32。由于machoviewer看不到符号表，所以用代码查看符号表中索引为0xB32 的符号信息。</p><p>查看代码：struct nlist_64 const * mallocNlist =[self getSymbol64ByIndex:0xB32];</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP7.jpg" alt="图7 符号表"></p><p>图7 .代码查看符号表示意图。符号表的索引为0xB32的符号的信息。可以看出n_strx的值是0x2B07，<br>这个值指的是string表中的偏移量 </p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP8.jpg" alt="图8 string表起始地址 "></p><p>图8 .string 表，string表的起始地址是0x3B498</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP9.jpg" alt="图9 String表偏移0x2B07"><br>图9 .string 表， 偏移0x2B07 后的结果—— 0x3B498 + 0x2B07 = 0x3DF9F， 这个地址存储的字符串就是图3中</p><p>地址为0x10001ef10的函数指针的名称，名称是malloc。这个名称和我么要替换的名称一致，所以替换图3中的<br>0x10001ef10，替换成新指定函数指针地址。实现替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试9图片解释fishhook原理&lt;br&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="fishhook" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/"/>
    
    
      <category term="图解fishhook" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A7%A3fishhook/"/>
    
  </entry>
  
  <entry>
    <title>fishhook学习记录</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/learn_fishhook/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/fishhook/learn_fishhook/</id>
    <published>2018-06-20T04:07:12.000Z</published>
    <updated>2018-06-22T10:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/fishhook" rel="external nofollow noopener noreferrer" target="_blank">fishhook</a>是一个可以替换C函数的开源库，官网的readme讲解了重新绑定的原理。本文从源码的角度去学习fishhook。</p><a id="more"></a><h2 id="源码示意图"><a href="#源码示意图" class="headerlink" title="源码示意图"></a>源码示意图</h2><p>先给个简单的源码示意图。循序渐进理解啊。直接上源码有点懵，几个函数名称太相似了。不过呢，看图，好像就四个函数、247行代码而已。</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhook_code_struct.png" alt="源码示意图"></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>源码使用OOMDetector，OOMDetector使用fishhook替换malloc函数。使用OOMDetector的目的是顺便可以学习fishhook api的调用方式，同时也能学习fishhook源码。</p><p>首先，fishhook定义了一个结构体，存储绑定的数据。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">//替换的函数名字</span></span><br><span class="line">  <span class="keyword">void</span> *replacement; <span class="comment">//替换后的函数指针</span></span><br><span class="line">  <span class="keyword">void</span> **replaced;   <span class="comment">//原始的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的替换malloc等函数的入口函数，该函数调用了fishhook的<code>rebind_symbols_for_imagename</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookMalloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        beSureAllRebindingFuncBeenCalled();</span><br><span class="line">        </span><br><span class="line">        orig_malloc = <span class="built_in">malloc</span>;</span><br><span class="line">        orig_calloc = <span class="built_in">calloc</span>;</span><br><span class="line">        orig_valloc = valloc;</span><br><span class="line">        orig_realloc = <span class="built_in">realloc</span>;</span><br><span class="line">        orig_block_copy = _Block_copy;</span><br><span class="line">        </span><br><span class="line">        rebind_symbols_for_imagename(</span><br><span class="line">                                     (struct rebinding[<span class="number">5</span>])&#123;</span><br><span class="line">                                         &#123;<span class="string">"realloc"</span>,(<span class="keyword">void</span>*)new_realloc,(<span class="keyword">void</span>**)&amp;orig_realloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"malloc"</span>, (<span class="keyword">void</span>*)new_malloc, (<span class="keyword">void</span> **)&amp;orig_malloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"valloc"</span>,(<span class="keyword">void</span>*)new_valloc,(<span class="keyword">void</span>**)&amp;orig_valloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"calloc"</span>,(<span class="keyword">void</span>*)new_calloc,(<span class="keyword">void</span>**)&amp;orig_calloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"_Block_copy"</span>,(<span class="keyword">void</span>*)new_block_copy,(<span class="keyword">void</span>**)&amp;orig_block_copy&#125;&#125;,</span><br><span class="line">                                     <span class="number">5</span>,</span><br><span class="line">                                     getImagename());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        isPaused = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hookMalloc</code>替换了<code>realloc</code>、<code>malloc</code>、<code>valloc</code>、<code>calloc</code>、<code>_Block_copy</code>这几个函数。</p><p>下面是新的<code>new_malloc</code>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">new_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = orig_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        global_leakChecker-&gt;recordMallocStack((<span class="keyword">vm_address_t</span>)ptr, (<span class="keyword">uint32_t</span>)size,<span class="string">"malloc"</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __enable_malloc_logger__</span></span><br><span class="line">    malloc_printf(<span class="string">"malloc ptr:%p size:%lu thread:%lu\n"</span>,ptr, size,mach_thread_self());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new_malloc</code>函数首先会调用原来的<code>malloc</code>函数，接着会记录申请的内存的堆栈。</p><p>下面是原始函数的定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void* (<span class="name">*orig_malloc</span>)(<span class="name">size_t</span>)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_calloc</span>)(<span class="name">size_t</span>, size_t)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_realloc</span>)(<span class="name">void</span> *, size_t);</span><br><span class="line">static void* (<span class="name">*orig_valloc</span>)(<span class="name">size_t</span>)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_block_copy</span>)(<span class="name">const</span> void *aBlock);</span><br></pre></td></tr></table></figure><p>下面是rebind_symbols_for_imagename第三个入参————镜像名称的获取方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getImagename</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">        name = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>&lt;mach-o/dyld.h&gt;</code> 头文件中的<code>_dyld_get_image_name</code>函数。 <code>_dyld_get_image_name</code> 根据镜像的索引，获取镜像的名称。<code>strrchr</code>函数是反向查找第一个给定字符。返回第一次匹配到的地址指针。</p><p>下面代码进入fishhook的入口函数<code>rebind_symbols_for_imagename</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebind_symbols_for_imagename</span><span class="params">(struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> rebindings_nel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span> *imagename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">mach_header_t</span>* header = (<span class="keyword">const</span> <span class="keyword">mach_header_t</span>*)_dyld_get_image_header(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">long</span> slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">            name = tmp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,imagename) == <span class="number">0</span>)&#123;</span><br><span class="line">            rebind_symbols_image((<span class="keyword">void</span> *)header,</span><br><span class="line">                                 slide,</span><br><span class="line">                                 rebindings,</span><br><span class="line">                                 rebindings_nel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebindings</code>承载重新绑定的所有信息，<code>rebindings_nel</code>是<code>rebindings</code>的个数，<code>imagename</code>要替换函数指针镜像名称，也就是只替换名称为<code>imagename</code>文件中的函数指针，其他库不做替换。</p><p><code>_dyld_get_image_header</code> 获取镜像的header头，<code>_dyld_get_image_vmaddr_slide</code>获取镜像的随机启动地址。<code>rebind_symbols_for_imagename</code>函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考<a href="https://stackoverflow.com/questions/13574933/ios-crash-reports-atos-not-working-as-expected/13576028#13576028" rel="external nofollow noopener noreferrer" target="_blank">iOS crash reports: atos not working as expected</a>、<font color="red"> <a href="https://www.cnblogs.com/feng9exe/p/7988360.html" rel="external nofollow noopener noreferrer" target="_blank">iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol</a></font> 。</p><p>下面为了理解ALSR中的slide，贴出一段测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">understandALSR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///枚举所有镜像</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *image_name = (<span class="keyword">char</span> *)_dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> *<span class="title">mh</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">i</span>);</span></span><br><span class="line">        <span class="keyword">intptr_t</span> vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\n"</span>,</span><br><span class="line">               image_name, (<span class="keyword">mach_vm_address_t</span>)mh, vmaddr_slide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image name <span class="regexp">/Users/</span>lijian<span class="regexp">/Library/</span>Developer<span class="regexp">/CoreSimulator/</span>Devices<span class="regexp">/21045765-7E1F-499B-A985-1BCCFC70B079/</span>data<span class="regexp">/Containers/</span>Bundle<span class="regexp">/Application/</span><span class="number">0975</span>D79D-<span class="number">5079</span>-<span class="number">4258</span>-<span class="number">8</span>A0F-<span class="number">48175818</span>A28A<span class="regexp">/LearnMachO.app/</span>LearnMachO ,image header <span class="number">0</span>x10dff0000 , ASLR slide <span class="number">0</span>xdff0000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libBacktraceRecording.dylib ,image header <span class="number">0</span>x10e07c000 , ASLR slide <span class="number">0</span>x10e07c000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libMainThreadChecker.dylib ,image header <span class="number">0</span>x10e08b000 , ASLR slide <span class="number">0</span>x10e08b000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/</span>Developer<span class="regexp">/Library/</span>PrivateFrameworks<span class="regexp">/DTDDISupport.framework/</span>libViewDebuggerSupport.dylib ,image header <span class="number">0</span>x10e27d000 , ASLR slide <span class="number">0</span>x10e27d000.</span><br></pre></td></tr></table></figure><p>代码对应的二进制文件中的加载地址（链接时load address）示意图：<br><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/learnMachO.jpg" alt="learnMachO"><br><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/libbacktraceRecording.jpg" alt="learnMachO"><br>结合上面的示例代码和二进制内容图片，可以诠释下面的公式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slide = (运行时)load<span class="built_in"> address </span>- (链接时)load address;</span><br><span class="line">symble<span class="built_in"> address </span>＝ stack<span class="built_in"> address </span>－slide；</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>stack address ： 程序运行时线程栈中 所有 函数调用的地址</li><li>symble address ： dsym文件中函数符号对应的地址，用此地址在dsym 文件中可以查出对应的符号信息。 </li></ol><p>可以看出，没有ASLR时：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symble<span class="built_in"> address </span>=  stack address</span><br></pre></td></tr></table></figure><p>好了，接着看<code>rebind_symbols_image</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                         struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">rebindings_head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_image</code> 主要工作是通过<code>prepend_rebindings</code>构造绑定的结构体<code>struct rebindings_entry</code>，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int prepend_rebindings(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> **rebindings_head,</span><br><span class="line">                              <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span> rebindings[],</span><br><span class="line">                              size_t nel) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///申请new_entry地址                  </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *new_entry = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span>));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///给new_entry-&gt;rebindings分配内存</span></span><br><span class="line">  new_entry-&gt;rebindings = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///拷贝重新绑定信息到new_entry-&gt;rebindings</span></span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者</span></span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepend_rebindings 只是将绑定的struct rebinding类型参数转化为struct rebindings_entry结构，这种结构类似链表，可以方便的管理多个struct rebinding结构。下面看rebind_symbols_for_image：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void rebind_symbols_for_image(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span> *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="comment">///find the image containing a given address</span></span><br><span class="line">  <span class="comment">///验证库是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">///SEG_LINKEDIT commond指针</span></span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  <span class="comment">///LC_SYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>* symtab_cmd = NULL;</span><br><span class="line">  <span class="comment">///LC_DYSYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>* dysymtab_cmd = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">///定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针</span></span><br><span class="line">  uintptr_t cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      symtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      dysymtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses 查找符号表和string表</span></span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="built_in">char</span> *strtab = (<span class="built_in">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) </span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + <span class="keyword">sizeof</span>(segment_command_t)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_for_image</code> 函数主要定位到三表、类型为<code>S_LAZY_SYMBOL_POINTERS</code>、<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section。然后调用<code>perform_rebinding_with_section</code> 函数。其中部分宏定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SEG_LINKEDIT<span class="meta-string">"__LINKEDIT"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_NON_LAZY_SYMBOL_POINTERS 0x6  <span class="comment">/* section with only non-lazy symbol pointers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_LAZY_SYMBOL_POINTERS 0x7     <span class="comment">/* section with only lazy symbol</span></span></span><br></pre></td></tr></table></figure><p>上面的宏定义于<code>&lt;mach-o/loader.h&gt;</code>文件中，位于458行。<font color="red"> 在S_NON_LAZY_SYMBOL_POINTERS宏的上面有一段注释。这段注释非常的关键。说明了S_NON_LAZY_SYMBOL_POINTERS类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。</font></p><p>For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries. </p><p>对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。 </p><p>For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure. </p><p>间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。</p><p>Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries  in the section is 4 bytes (看结构是8bytes，可能是64位的缘故)</p><p>由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节</p><p>下面是<code>perform_rebinding_with_section</code>函数源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,  <span class="comment">//section</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,     <span class="comment">//基址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,  <span class="comment">//符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,  <span class="comment">//sting 表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab <span class="comment">//动态符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///section加载到内存的虚拟地址（是要替换这里面的东西）</span></span><br><span class="line">    <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///section中替换函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。</span></span><br><span class="line">        <span class="comment">///下面目的是获取section中存储的函数指针的符号  动态符号表-&gt; 符号表-&gt; string表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引</span></span><br><span class="line">        <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">        <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">            symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。</span></span><br><span class="line">        <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">        <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">        <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///如果符号名称和替换的名称一样，进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                      indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">///保存原始的指针地址，只保存一次</span></span><br><span class="line">                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。   </span></span><br><span class="line">                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">                    <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        symbol_loop:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perform_rebinding_with_section函数完成替换的关键函数。 将section中的函数指针替换为新的函数指针。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/78444203?locationNum=3&amp;fps=1" rel="external nofollow noopener noreferrer" target="_blank">Fishhook替换C函数的原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/facebook/fishhook&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;fishhook&lt;/a&gt;是一个可以替换C函数的开源库，官网的readme讲解了重新绑定的原理。本文从源码的角度去学习fishhook。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="fishhook" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/"/>
    
    
      <category term="fishhook" scheme="http://yoursite.com/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>合并真机模拟器静态库(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%8A%A8%E6%80%81%E5%BA%93/static_lib_aggregate_script/"/>
    <id>http://yoursite.com/wiki/IOS/动态库/static_lib_aggregate_script/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T09:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章解释合并真机模拟器静态库的脚本</p><a id="more"></a><h2 id="合成脚本"><a href="#合成脚本" class="headerlink" title="合成脚本"></a>合成脚本</h2><p>合并的脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/build</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"build_DIR=<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/include/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_INCLUDE=<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_A=<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphonesimulator/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"SIMULATOR_DIR_A=<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line">open <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="铺路"><a href="#铺路" class="headerlink" title="铺路"></a>铺路</h2><p>本代码中用到的核心命令：</p><h3 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h3><p>苹果给的一个命令。主要用来编译Xcode的工程。<br>可以在终端中输入xcodebuild -h来查看命令的详情，介绍一下本脚本中用到的几个参数</p><ul><li>clean:clean一下工程</li><li>-configuration Release<br>使用Release方式编译，还可以使用Debug</li><li>-sdk iphoneos<br>真机编译，还可以使用-sdk iphonesimulator模拟器编译</li></ul><h3 id="cp-“源文件路径”-“目标文件路径”"><a href="#cp-“源文件路径”-“目标文件路径”" class="headerlink" title="cp “源文件路径” “目标文件路径”"></a>cp “源文件路径” “目标文件路径”</h3><p>复制”源文件路径”的文件到 “目标文件路径”</p><h3 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h3><p>lipo -create “模拟器.a文件路径” “真机.a文件路径” -output “目标.a文件路径”</p><p>将模拟器和真机的.a包合成。</p><h3 id="用到的一些shell脚本基础命令"><a href="#用到的一些shell脚本基础命令" class="headerlink" title="用到的一些shell脚本基础命令"></a>用到的一些shell脚本基础命令</h3><h4 id="echo-“你要写的东西”"><a href="#echo-“你要写的东西”" class="headerlink" title="echo “你要写的东西”"></a>echo “你要写的东西”</h4><p>打印的log,将”你要写的东西”打印出来，相当于OC中的NSLog<br>Xcode的话，运行脚本后，可以在这里找到log</p><h4 id="赋值命令。-变量名-变量值"><a href="#赋值命令。-变量名-变量值" class="headerlink" title="赋值命令。 变量名=变量值"></a>赋值命令。 变量名=变量值</h4><p>比如将”CrazyStone”赋值给MyName变量</p><p>MyName=CrazyStone</p><h4 id="变量名"><a href="#变量名" class="headerlink" title="${变量名}"></a>${变量名}</h4><p>取出变量名的内容。<br>比如：取出变量MyName中的内容<br>${MyName}</p><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>if [ 条件语句 ]then<br>…<br>fi<br>条件语句为真就执行then后面的语句，不成立就结束判断语句</p><h4 id="本脚本中用到的判断语句："><a href="#本脚本中用到的判断语句：" class="headerlink" title="本脚本中用到的判断语句："></a>本脚本中用到的判断语句：</h4><p>[ -d “文件夹路径” ] ：判断是否为文件夹</p><h2 id="脚本结构解释"><a href="#脚本结构解释" class="headerlink" title="脚本结构解释"></a>脚本结构解释</h2><p>看完上面，我想你再看一下代码应该就能理解脚本，然后可以做一些简单的改动了。下面再介绍一下脚本的结构。</p><h3 id="执行条件–-编译"><a href="#执行条件–-编译" class="headerlink" title="执行条件– 编译"></a>执行条件– 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#我们的大部分脚本代码</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本的时候做个判断，在Xcode里面build这个工程的时候就执行then后面的脚本</p><h3 id="工程名称定义"><a href="#工程名称定义" class="headerlink" title="工程名称定义"></a>工程名称定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>变量target_Name是我们要编译的target的名字，在这里指的是工程的名字${PROJECT_NAME}，也就是MySDK。</p><p>顺便说一下，ACTION和PROJECT_NAME都是Xcode里面定义的，这是在Xcode里面写脚本的一个好处。</p><h3 id="build-路径"><a href="#build-路径" class="headerlink" title="build 路径"></a>build 路径</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=$&#123;SRCROOT&#125;/build</span><br><span class="line">    echo <span class="string">"build_DIR=$&#123;build_DIR&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=$&#123;build_DIR&#125;/Release-iphoneos/<span class="keyword">include</span>/$&#123;PROJECT_NAME&#125;</span><br><span class="line">    echo <span class="string">"DEVICE_DIR_INCLUDE=$&#123;DEVICE_DIR_INCLUDE&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=$&#123;build_DIR&#125;/Release-iphoneos/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"DEVICE_DIR_A=$&#123;DEVICE_DIR_A&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=$&#123;build_DIR&#125;/Release-iphonesimulator/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"SIMULATOR_DIR_A=$&#123;SIMULATOR_DIR_A&#125;"</span></span><br></pre></td></tr></table></figure><p>这里是定义的build之后各个文件的路径。我们执行了xcodebuild命令之后，会在工程目录生成一个build文件夹，里面有build之后生成的文件。打开Finder看看就知道各个文件的路径了。</p><h3 id="build目录的位置"><a href="#build目录的位置" class="headerlink" title="build目录的位置"></a>build目录的位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是定义目标变量的路径了。你想把文件放在哪里？在这里定义咯。${SRCROOT}表示工程的根目录。用了这么久的Xcode，这个有用过吧(全局头文件配置过吧？)？</p><h3 id="文件状态判断"><a href="#文件状态判断" class="headerlink" title="文件状态判断"></a>文件状态判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是文件的操作了。如果有这两个文件夹，就删除掉。为什么？为了保证我们工程的纯净啊。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br></pre></td></tr></table></figure><p>这里就跟平常操作一样了。先clean一下工程，然后模拟器编译一次，真机编译一次。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line"><span class="attribute">cp</span> -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>关键代码。拷贝头文件到我们的目标位置去。合成.a包。大功告成。</p><h3 id="打开目标文件夹"><a href="#打开目标文件夹" class="headerlink" title="打开目标文件夹"></a>打开目标文件夹</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line"><span class="keyword">open</span> <span class="string">"<span class="subst">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>最后，打开文件夹。检查一下文件是否真正生成了。</p><h2 id="shell脚本基础知识"><a href="#shell脚本基础知识" class="headerlink" title="shell脚本基础知识"></a>shell脚本基础知识</h2><p>如果你想了解更多关于shell脚本的知识，可以看看这篇文章：Linux shell脚本基础学习详细介绍</p><h2 id="xcworkspace-工程对应的脚本"><a href="#xcworkspace-工程对应的脚本" class="headerlink" title="xcworkspace 工程对应的脚本"></a>xcworkspace 工程对应的脚本</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphoneos</span><br></pre></td></tr></table></figure><p>对于xcworkspace工程，需要将编译的脚本替换 ，其中–workspace、-scheme是必须的 ，scheme 可以通过xcodebuild -list 查看。</p><h2 id="iOS设备架构"><a href="#iOS设备架构" class="headerlink" title="iOS设备架构"></a>iOS设备架构</h2><p>模拟器：<br>iPhone4s-iPnone5：i386<br>iPhone5s-iPhone7 Plus：x86_64</p><p>真机:<br>iPhone3gs-iPhone4s：     armv7<br>iPhone5-iPhone5c：        armv7s<br>iPhone5s-iPhone7 Plus： arm64</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9cf90b9537fd" rel="external nofollow noopener noreferrer" target="_blank">【iOS开发】静态库.a文件合成脚本解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章解释合并真机模拟器静态库的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="动态库" scheme="http://yoursite.com/categories/IOS/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Xcode编译环境变量</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/wiki/工具/Xcode编译常量/xcode编译环境变量/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T08:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看图吧</p><p><img src="http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="xcode 环境变量"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Xcode编译常量" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>查看虚拟内存</title>
    <link href="http://yoursite.com/wiki/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B2/"/>
    <id>http://yoursite.com/wiki/IOS/虚拟内存/虚拟内存之2/</id>
    <published>2018-06-02T04:07:12.000Z</published>
    <updated>2018-06-02T04:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.<br>如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。</p><p>The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">Instruments User Guide</a> and the other articles in this document. For information on how to use the top tool,<br>以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">仪器用户指南</a>和本文中的其他文章。有关如何使用顶部工具的信息，请参见<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">2</a>。see <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">Performance Overview</a>.</p><a id="more"></a><h2 id="Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）"><a href="#Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）" class="headerlink" title="Viewing Virtual Memory Statistics（查看虚拟内存统计信息）"></a>Viewing Virtual Memory Statistics（查看虚拟内存统计信息）</h2><p>The vm_stat tool displays high-level statistics about the current virtual memory usage of the system. By default, vm_stat displays these statistics once, but you can specify an interval value (in seconds) to update these statistics continuously. For information on the usage of this tool, see the vm_stat man page.<br>vm_stat工具显示关于系统当前虚拟内存使用情况的高级统计信息。默认情况下，vm_stat只显示这些统计信息一次，但是您可以指定一个间隔值(以秒为单位)来持续更新这些统计信息。有关此工具使用的信息，请参见vm_stat手册页。</p><p>Listing 1 shows an example of the output from vm_stat. </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mach Virtual Memory Statistics: (page size <span class="keyword">of</span> <span class="number">4096</span> bytes)</span><br><span class="line">Pages free:                     <span class="number">3194</span>.</span><br><span class="line">Pages active:                  <span class="number">34594</span>.</span><br><span class="line">Pages inactive:                <span class="number">17870</span>.</span><br><span class="line">Pages wired down:               <span class="number">9878</span>.</span><br><span class="line"><span class="string">"Translation faults"</span>:        <span class="number">6333197</span>.</span><br><span class="line">Pages copy-on-write:           <span class="number">81385</span>.</span><br><span class="line">Pages zero filled:           <span class="number">3180051</span>.</span><br><span class="line">Pages reactivated:            <span class="number">343961</span>.</span><br><span class="line">Pageins:                       <span class="number">33043</span>.</span><br><span class="line">Pageouts:                      <span class="number">78496</span>.</span><br><span class="line">Object cache: <span class="number">66227</span> hits <span class="keyword">of</span> <span class="number">96952</span> lookups (<span class="number">68</span><span class="comment">% hit rate)</span></span><br></pre></td></tr></table></figure><h2 id="Viewing-Mach-O-Code-Pages"><a href="#Viewing-Mach-O-Code-Pages" class="headerlink" title="Viewing Mach-O Code Pages"></a>Viewing Mach-O Code Pages</h2><p>The pagestufftool displays information about the specified logical pages of a file conforming to the Mach-O executable format. For each specified page of code, symbols (function and static data structure names) are displayed. All pages in the <strong>TEXT, </strong>text section are displayed if no page numbers are given.<br>pagestufftool显示符合Mach-O可执行格式的文件的指定逻辑页的信息。对于每个指定的代码页，将显示符号(函数和静态数据结构名称)。如果没有给出页码，则显示__TEXT节中的所有页面。</p><p>Listing 2 shows part of the output from pagestuff for the TextEdit application. This output is the result of running the tool with the -a option, which prints information about all of the executable’s code pages. It includes the virtual address locations of each page and the type of information on that page.<br>清单2显示了TextEdit应用程序的页面内容的部分输出。此输出是使用-a选项运行工具的结果，该选项打印关于可执行文件的所有代码页的信息。它包括每个页面的虚拟地址位置和页面上的信息类型。</p><p>Listing 2  Partial output of pagestuff tool</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">File<span class="built_in"> Page </span>0 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>1 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>2 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>2 virtual<span class="built_in"> address </span>0x3a08 <span class="keyword">to</span> 0x4000</span><br><span class="line">File<span class="built_in"> Page </span>3 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>3 virtual<span class="built_in"> address </span>0x4000 <span class="keyword">to</span> 0x5000</span><br><span class="line">File<span class="built_in"> Page </span>4 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>4 virtual<span class="built_in"> address </span>0x5000 <span class="keyword">to</span> 0x6000</span><br><span class="line"> </span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__cstring)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal4)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal8)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__const)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>22 virtual<span class="built_in"> address </span>0x17000 <span class="keyword">to</span> 0x17ffc</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__data)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__la_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__nl_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__dyld)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__cfstring)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__bss)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__common)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>23 virtual<span class="built_in"> address </span>0x18000 <span class="keyword">to</span> 0x18d48</span><br><span class="line"> 0x00018000 _NXArgc</span><br><span class="line"> 0x00018004 _NXArgv</span><br><span class="line"> 0x00018008 _environ</span><br><span class="line"> 0x0001800c ___progname</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>In the preceding listing, if a page exports any symbols, those symbols are also displayed by the -a option. If you want to view the symbols for a single page, pass in the desired page number instead of the -a option. For more information about the pagestuff tool and its supported options, see the pagestuff man page.</p><p>在前面的列表中，如果一个页面导出任何符号，那么这些符号也会被a选项显示。如果要查看单个页面的符号，请输入所需的页码，而不是-a选项。有关pagestuff工具及其支持选项的更多信息，请参见pagestuff man页面。</p><h2 id="Viewing-Virtual-Memory-Regions"><a href="#Viewing-Virtual-Memory-Regions" class="headerlink" title="Viewing Virtual Memory Regions"></a>Viewing Virtual Memory Regions</h2><p>The vmmap and vmmap64 tools display the virtual memory regions allocated for a specified process. These tools provide access to the virtual memory of 32-bit and 64-bit applications, respectively. You can use them to understand the purpose of memory at a given address and how that memory is being used. For each virtual-memory region, these tools display the type of page, the starting address, region size (in kilobytes), read/write permissions, sharing mode, and the purpose of the pages in that region.<br>vmmap和vmmap64工具显示为指定进程分配的虚拟内存区域。这些工具分别提供对32位和64位应用程序的虚拟内存的访问。您可以使用它们来理解给定地址的内存用途以及内存的使用方式。对于每个虚拟内存区域，这些工具显示页面的类型、起始地址、区域大小(单位为千字节)、读/写权限、共享模式和该区域的页面用途。</p><p>The following sections show you how to interpret the output from the vmmap tool. For more information about the vmmap and vmmap64 tools, see the vmmap or vmmap64 man pages.<br>以下部分将向您展示如何解释vmmap工具的输出。有关vmmap和vmmap64工具的更多信息，请参见vmmap或vmmap64手册页面。</p><p>Sample Output From vmmap<br>Listing 3 shows some sample output from the vmmap tool. This example is not a full listing of the tool’s output but is an abbreviated version showing the primary sections.</p><p>Listing 3  Typical output of vmmap</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">==== Non-writable regions <span class="keyword">for</span> process 313</span><br><span class="line">__PAGEZERO              0 [   4K] ---/--- <span class="attribute">SM</span>=NUL <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__TEXT               1000 [  40K] r-x/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__LINKEDIT           e000 [   4K] r--/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/w/Clock</span><br><span class="line">                    90000 [   4K] r--/r-- <span class="attribute">SM</span>=SHM</span><br><span class="line">                   340000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">                   789000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">Submap           90000000-9fffffff r--/r-- machine-wide submap</span><br><span class="line">__TEXT           90000000  [ 932K] r-x/r-x <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__LINKEDIT       900e9000   [ 260K] r--/r-- <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__TEXT           90130000 [ 740K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__LINKEDIT       901e9000 [ 188K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__TEXT           90220000 [2144K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">__LINKEDIT       90438000 [ 296K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">==== Writable regions <span class="keyword">for</span> process 606</span><br><span class="line">__DATA             18000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV /Contents/MacOS/TextEdit</span><br><span class="line">__OBJC             19000 [   8K] rw-/rwx <span class="attribute">SM</span>=COW /Contents/MacOS/TextEdit</span><br><span class="line">MALLOC_OTHER       1d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(DefaultMallocZone_0x5d2c0)     5d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                   9d000 [ 372K] rw-/rwx <span class="attribute">SM</span>=COW 33320000 00000020 00000000 00001b84<span class="built_in">..</span>.</span><br><span class="line">VALLOC_USED(DefaultMallocZone_0x5d2c0)     ff000 [  36K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsDefaultZone_0x10  108000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsRegionZone_0x148  148000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">Submap           a000b000-a012ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0130000 [  28K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">Submap           a0137000-a021ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0220000 [  20K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">Submap           a0225000-a048ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0490000 [  12K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./IOKit.framework/Versions/A/IOKit</span><br><span class="line">Submap           a0493000-a050ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0510000 [  36K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/OSServices</span><br><span class="line">                 b959e000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b95a0000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b9630000 [ 164K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b965a000 [ 896K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 bff80000 [ 504K] rw-/rwx <span class="attribute">SM</span>=ZER</span><br><span class="line">STACK[0]         bfffe000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 bffff000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">__DATA           c000c000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV <span class="built_in">..</span>./Versions/A/ApplicationEnhancer</span><br><span class="line">STACK[1]         f0001000 [ 512K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 ff002000 [12272K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 </span><br><span class="line">                 ==== Legend</span><br><span class="line"><span class="attribute">SM</span>=sharing mode:</span><br><span class="line">    <span class="attribute">COW</span>=copy_on_write <span class="attribute">PRV</span>=private <span class="attribute">NUL</span>=empty <span class="attribute">ALI</span>=aliased</span><br><span class="line">    <span class="attribute">SHM</span>=shared <span class="attribute">ZER</span>=zero_filled S/<span class="attribute">A</span>=shared_alias</span><br><span class="line"> </span><br><span class="line">==== Summary <span class="keyword">for</span> process 313</span><br><span class="line">ReadOnly portion of Libraries: <span class="attribute">Total</span>=27420KB <span class="attribute">resident</span>=12416KB(45%) <span class="attribute">swapped_out_or_unallocated</span>=15004KB(55%)</span><br><span class="line">Writable regions: <span class="attribute">Total</span>=21632KB <span class="attribute">written</span>=536KB(2%) <span class="attribute">resident</span>=1916KB(9%) <span class="attribute">swapped_out</span>=0KB(0%) <span class="attribute">unallocated</span>=19716KB(91%)</span><br></pre></td></tr></table></figure><p>If you specify the -d parameter (plus an interval in seconds), vmmap takes two snapshots of virtual-memory usage—one at the beginning of a specified interval and the other at the end—and displays the differences. It shows three sets of differences:</p><ul><li>individual differences</li><li>regions in the first snapshot that are not in the second</li><li>regions in the second snapshot that are not in the first</li></ul><p>如果您指定-d参数(加上以秒为单位的间隔)，vmmap将获取两个虚拟内存使用快照(一个在指定的间隔开始，另一个在结束)，并显示差异。它显示了三组差异:</p><ul><li>个体差异</li><li>第一个快照中的区域而不是第二个快照中的区域</li><li>第二个快照中不属于第一个快照的区域</li></ul><p>Interpreting vmmap’s Output<br>The columns of vmmap output have no headings. Instead you can interpret the type of data in each column by its format. Table 1 describes these columns.</p><p>Table 1  Column descriptions for vmmap</p><p><strong>Table 1</strong>  Column descriptions for vmmap</p><table><thead><tr><th>Column Number</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td><code>__TEXT</code>, <code>__LINKEDIT</code>, <code>MALLOC_USED</code>, <code>STACK</code>, and so on</td><td>The purpose of the memory. This column can contain the name of a Mach-O segment or the memory allocation technique.</td></tr><tr><td>2</td><td><code>(DefaultMallocZone_0x5d2c0)</code></td><td>If present, the zone used for allocation.</td></tr><tr><td>3</td><td><code>4eee000</code></td><td>The virtual memory address of the region.</td></tr><tr><td>4</td><td><code>[ 124K]</code></td><td>The size of the region, measured in kilobytes</td></tr><tr><td>5</td><td><code>rw-/rwx</code></td><td>Read, write and execution permissions for the region. The first set of flags specifies the current protection for the region. The second set of values specifies the maximum protection for the region. If an entry contains a dash (<code>-</code>), the process does not have the target permission.</td></tr><tr><td>6</td><td><code>SM=PRV</code></td><td>Sharing mode for the region, either <code>COW</code> (copy-on-write), <code>PRV</code> (private), <code>NUL</code> (empty), <code>ALI</code> (aliased), or <code>SHM</code> (shared).</td></tr><tr><td>7</td><td><code>...ts/MacOS/Clock</code></td><td>The end of the pathname identifying the executable mapped into this region of virtual memory. If the region is stack or heap memory, nothing is displayed in this column.</td></tr></tbody></table><p>Column 1 identifies the purpose of the memory. A <strong>TEXT segment contains read-only code and data. A </strong>DATA segment contains data that may be both readable and writable. For allocated data, this column shows how the memory was allocated, such as on the stack, using malloc, and so on. For regions loaded from a library, the far right column shows the name of the library loaded into memory.<br>第1列标识内存的用途。<strong>TEXT段包含只读代码和数据。</strong>DATA段包含可读和可写的数据。对于已分配的数据，这一列显示如何分配内存，例如使用malloc在堆栈上，等等。对于从库中加载的区域，最右边的列显示加载到内存中的库的名称。</p><p>The size of the virtual memory region (column 4) represents the total size reserved for that region. This number may not reflect the actual number of memory pages allocated for the region. For example, calling vm_allocate reserves a set of memory pages but does not allocate any physical memory until the pages are actually touched. Similarly, a memory-mapped file may reserve a set of pages, but the system does not load pages until a read or write event occurs on the file.<br>虚拟内存区域的大小(第4列)表示该区域保留的总大小。这个数字可能不能反映为该区域分配的内存页的实际数量。例如，调用vm_allocation会保留一组内存页，但在实际操作这些页之前不会分配任何物理内存。类似地，内存映射文件可以保留一组页面，但是系统在文件上发生读或写事件之前不会加载页面。</p><p>The protection mode (column 5) describes the access restrictions for the memory region. A memory region contains separate flags for read, write, and execution permissions. Each virtual memory region has a current permission, and a maximum permission. In the output from vmmap, the current permission appears first followed by the maximum permission. Thus, if the permissions are “r–/rwx“ the page is currently read-only but allows read, write, and execution access as its maximum allowed permissions. Typically, the current permissions do not permit writing to a region. However, these permissions may change under certain circumstances. For example, a debugger may request write access to a page in order to set a breakpoint.<br>保护模式(第5列)描述了内存区域的访问限制。内存区域包含用于读取、写入和执行权限的单独标志。每个虚拟内存区域都有一个当前权限和最大权限。在vmmap的输出中，当前权限首先显示为最大权限。因此，如果权限是“r- /rwx”，页面当前是只读的，但允许读、写和执行访问作为其最大允许的权限。通常，当前权限不允许写入区域。但是，这些权限在某些情况下可能会改变。例如，调试器可以请求对页面的写访问，以便设置断点。</p><p>The sharing mode (SM= field) tells you whether pages are shared between processes and what happens when pages are modified. Private pages (PRV) are visible only to the process and are allocated as they are used. Private pages can also be paged out to disk. Copy-on-write (COW) pages are shared by multiple processes (or shared by a single process in multiple locations). When the page is modified, the writing process then receives its own copy of the page. Empty (NUL) sharing implies that the page does not really exist in physical memory. Aliased (ALI) and shared (SHM) memory are shared between processes.<br>共享模式(SM= field)告诉您进程之间是否共享页面，以及修改页面时会发生什么。私有页面(PRV)只对进程可见，并在使用它们时进行分配。还可以将私有页面分页到磁盘。写时复制(COW)页面由多个进程共享(或由多个位置的单个进程共享)。当页面被修改时，编写过程将收到它自己的页面副本。空(NUL)共享意味着页面并不真正存在于物理内存中。别名(ALI)和共享(SHM)内存在进程之间共享。</p><p>The sharing mode typically describes the general mode controlling the region. For example, as copy-on-write pages are modified, they become private to the application. However, the region containing those private pages is still copy-on-write until all pages become private. Once all pages are private, the sharing mode changes to private.<br>共享模式通常描述控制该区域的通用模式。例如，当对写后复制的页面进行修改时，它们将成为应用程序的私有页面。但是，包含这些私有页面的区域仍然是“写时复制”，直到所有页面变为私有。一旦所有页面都是私有的，共享模式就会变为私有。</p><p>Some lines in the output of vmmap describe submaps. A submap is a shared set of virtual memory page descriptions that the operating system can reuse between multiple processes. For example, the memory between 0x90000000 and 0xAFFFFFFF is a submap containing the most common dynamic libraries. Submaps minimize the operating system’s memory usage by representing the virtual memory regions only once. Submaps can either be shared by all processes (machine-wide) or be local to the process (process-only). If the contents of a machine-wide submap are changed—for example, the debugger makes a section of memory for a dynamic library writable so it can insert debugging traps—then the submap becomes local, and the kernel allocates memory to store the extra copy.<br>vmmap输出中的一些行描述子映射。子映射是操作系统可以在多个进程之间重用的一组共享的虚拟内存页面描述。例如，0x90000000和0xAFFFFFFF之间的内存是包含最常见动态库的子映射。子映射只表示一次虚拟内存区域，从而最小化操作系统的内存使用。子映射可以由所有进程(机器范围内)共享，也可以是进程(仅处理)的本地映射。如果修改了机器范围的子映射的内容(例如，调试器为动态库编写一个内存段，以便它可以插入调试trap)，那么子映射就变成本地的，内核分配内存来存储额外的副本。</p><p>[a]:</p><p>[a]:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.&lt;br&gt;如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。&lt;/p&gt;
&lt;p&gt;The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Instruments User Guide&lt;/a&gt; and the other articles in this document. For information on how to use the top tool,&lt;br&gt;以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅&lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;仪器用户指南&lt;/a&gt;和本文中的其他文章。有关如何使用顶部工具的信息，请参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;。see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Performance Overview&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存之一----关于</title>
    <link href="http://yoursite.com/wiki/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/IOS/虚拟内存/虚拟内存/</id>
    <published>2018-06-01T04:07:12.000Z</published>
    <updated>2018-06-02T04:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译下<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" rel="external nofollow noopener noreferrer" target="_blank">Memory Usage Performance Guidelines</a></p><a id="more"></a><h2 id="About-Virtual-Memory"><a href="#About-Virtual-Memory" class="headerlink" title="About Virtual Memory"></a>About Virtual Memory</h2><p>Virtual memory allows an operating system to escape the limitations of physical RAM. The virtual memory manager creates a logical address space (or “virtual” address space) for each process and divides it up into uniformly-sized chunks of memory called pages. The processor and its memory management unit (MMU) maintain a page table to map pages in the program’s logical address space to hardware addresses in the computer’s RAM. When a program’s code accesses an address in memory, the MMU uses the page table to translate the specified logical address into the actual hardware memory address. This translation occurs automatically and is transparent to the running application. </p><p><font color="red">虚拟内存允许操作系统摆脱物理RAM的限制。虚拟内存管理器为每个进程创建一个逻辑地址空间(或“虚拟”地址空间)，</font>并将其划分为大小相同的称为页面的内存块。处理器及其内存管理单元(MMU)维护一个页表，将程序逻辑地址空间中的页映射到计算机RAM中的硬件地址。当程序的代码访问内存中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动进行的，对正在运行的应用程序是透明的。</p><p>As far as a program is concerned, addresses in its logical address space are always available. 就程序而言，其逻辑地址空间中的地址总是可用的。<br>However, if an application accesses an address on a memory page that is not currently in physical RAM, a page fault occurs.但是，如果应用程序访问当前不在物理RAM中的内存页上的地址，则会发生页面错误。 When that happens, the virtual memory system invokes a special page-fault handler to respond to the fault immediately.当发生这种情况时，虚拟内存系统调用一个特殊的页面错误处理程序来立即响应错误。 The page-fault handler stops the currently executing code, locates a free page of physical memory, loads the page containing the needed data from disk, updates the page table, and then returns control to the program’s code, which can then access the memory address normally. This process is known as paging. 页面错误处理程序停止当前执行的代码，定位物理内存的空闲页面，从磁盘装载包含所需数据的页面，更新页面表，然后返回对程序代码的控制，然后程序代码就可以正常地访问内存地址。这个过程称为分页。</p><p>If there are no free pages available in physical memory, the handler must first release an existing page to make room for the new page.如果在物理内存中没有可用的空闲页面，处理程序必须首先释放一个现有页面，以便为新页面腾出空间。 How the system release pages depends on the platform. 系统释放页面的方式取决于平台。In OS X, the virtual memory system often writes pages to the backing store.在OS X中，虚拟内存系统经常将页面写入后备存储器。 The backing store is a disk-based repository containing a copy of the memory pages used by a given process.后备存储是一个基于磁盘的存储库，其中包含给定进程使用的内存页的副本。 Moving data from physical memory to the backing store is called paging out (or “swapping out”);将数据从物理内存移动到后台存储被称为分页(或“交换出”); moving data from the backing store back in to physical memory is called paging in (or “swapping in”). 将数据从后台存储恢复到物理内存称为分页in(或“交换in”)。In iOS, there is no backing store and so pages are are never paged out to disk, but read-only pages are still be paged in from disk as needed.在iOS中，没有备份存储，所以不会将页面调出到磁盘，但是只读页面仍然根据需要从磁盘调入。</p><p>In OS X and in earlier versions of iOS, the size of a page is 4 kilobytes.在OS X和iOS的早期版本中，页面的大小是4千字节。 In later versions of iOS, A7- and A8-based systems expose 16-kilobyte pages to the 64-bit userspace backed by 4-kilobyte physical pages,在iOS的后续版本中，基于A7和基于a8的系统将16千字节的页暴露给由4千字节物理页支持的64位用户空间， while A9 systems expose 16-kilobyte pages backed by 16-kilobyte physical pages. 而A9系统将16千字节的页暴露给由16千字节物理页支持的64位用户空间。These sizes determine how many kilobytes the system reads from disk when a page fault occurs. 这些大小决定了当发生页面错误时系统从磁盘读取多少千字节。Disk thrashing can occur when the system spends a disproportionate amount of time handling page faults and reading and writing pages, rather than executing code for a program. 当系统花费过多的时间处理页面错误、读写页面，而不是为程序执行代码时，就会发生磁盘抖动。</p><p>Paging of any kind, and disk thrashing in particular, affects performance negatively because it forces the system to spend a lot of time reading and writing to disk. Reading a page in from the backing store takes a significant amount of time and is much slower than reading directly from RAM. If the system has to write a page to disk before it can read another page from disk, the performance impact is even worse.<br>任何类型的分页，特别是磁盘抖动，都会对性能产生负面影响，因为这会迫使系统花费大量时间对磁盘进行读写。从后台存储读取页面需要大量的时间，而且比直接从RAM读取要慢得多。如果系统必须在从磁盘读取另一个页面之前将一个页面写到磁盘，那么性能的影响甚至更糟。</p><h2 id="Details-of-the-Virtual-Memory-System"><a href="#Details-of-the-Virtual-Memory-System" class="headerlink" title="Details of the Virtual Memory System"></a>Details of the Virtual Memory System</h2><p>The logical address space of a process consists of mapped regions of memory. Each mapped memory region contains a known number of virtual memory pages. Each region has specific attributes controlling such things as inheritance (portions of the region may be mapped from “parent” regions), write-protection, and whether it is wired (that is, it cannot be paged out). Because regions contain a known number of pages, they are page-aligned, meaning the starting address of the region is also the starting address of a page and the ending address also defines the end of a page.<br>进程的逻辑地址空间由内存的映射区域组成。每个映射内存区域包含已知数量的虚拟内存页。每个区域都有特定的属性来控制诸如继承(该区域的一部分可以从“父”区域映射)、写保护以及它是否连接(也就是说，它不能被分页)。因为区域包含已知的页数，所以它们是页面对齐的，这意味着该区域的起始地址也是页面的起始地址，而结尾地址也定义了页面的结束地址。</p><p>The kernel associates a VM object with each region of the logical address space.<font color="red">内核将VM对象与逻辑地址空间的每个区域关联起来。</font> The kernel uses VM objects to track and manage the resident and nonresident pages of the associated regions.内核使用VM对象跟踪和管理关联区域的驻留页和非驻留页。 A region can map to part of the backing store or to a memory-mapped file in the file system.区域可以映射到备份存储的一部分，或者映射到文件系统中的内存映射文件。 Each VM object contains a map that associates regions with either the default pager or the vnode pager. 每个VM对象都包含一个映射，该映射将区域与默认分页器或vnode分页器关联起来。The default pager is a system manager that manages the nonresident virtual memory pages in the backing store and fetches those pages when requested. 默认分页器是一个系统管理器，它管理后台存储中的非驻留虚拟内存页，并在请求时获取这些页。The vnode pager implements memory-mapped file access. vnode分页器实现内存映射文件访问。The vnode pager uses the paging mechanism to provide a window directly into a file. vnode分页器使用分页机制直接向文件提供一个窗口。This mechanism lets you read and write portions of the file as if they were located in memory.该机制允许您读取和写入文件的部分，就像它们位于内存中一样。</p><p>In addition to mapping regions to either the default or vnode pager, a VM object may also map regions to another VM object. The kernel uses this self referencing technique to implement copy-on-write regions. Copy-on-write regions allow different processes (or multiple blocks of code within a process) to share a page as long as none of them write to that page. When a process attempts to write to the page, a copy of the page is created in the logical address space of the process doing the writing. From that point forward, the writing process maintains its own separate copy of the page, which it can write to at any time. Copy-on-write regions let the system share large quantities of data efficiently in memory while still letting processes manipulate those pages directly (and safely) if needed. These types of regions are most commonly used for the data pages loaded from system frameworks.<br>除了将区域映射到默认或vnode页导航之外，VM对象还可以将区域映射到另一个VM对象。内核使用这种自引用技术来实现写时复制区域。写后复制区域允许不同的进程(或一个进程中的多个代码块)共享一个页面，只要它们中没有一个写入该页。当进程试图写入页面时，将在执行写入操作的进程的逻辑地址空间中创建页面的副本。从那时起，编写过程就维护了它自己的页面的独立拷贝，它可以在任何时候对其进行写入。写后复制区域允许系统在内存中有效地共享大量数据，同时还允许进程在需要时直接(和安全地)操作这些页面。这些类型的区域通常用于从系统框架加载的数据页。<br>每个VM对象包含几个字段，如表1所示。</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Resident pages</td><td>A list of the pages of this region that are currently resident in physical memory.</td></tr><tr><td>Size</td><td>The size of the region, in bytes.</td></tr><tr><td>Pager</td><td>The pager responsible for tracking and handling the pages of this region in backing store.</td></tr><tr><td>Shadow</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Copy</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Attributes</td><td>Flags indicating the state of various implementation detai<em>**</em>ls.</td></tr></tbody></table><p>If the VM object is involved in a copy-on-write (<code>vm_copy</code>) operation, the shadow and copy fields may point to other VM objects. Otherwise both fields are usually <code>NULL</code>.</p><h2 id="Wired-Memory"><a href="#Wired-Memory" class="headerlink" title="Wired Memory"></a>Wired Memory</h2><p>Wired memory (also called resident memory) stores kernel code and data structures that must never be paged out to disk. Applications, frameworks, and other user-level software cannot allocate wired memory. However, they can affect how much wired memory exists at any time. For example, an application that creates threads and ports implicitly allocates wired memory for the required kernel resources that are associated with them.<br>Wired memory(也称为常驻内存)存储内核代码和数据结构，这些代码和数据结构永远不能被分页到磁盘上。应用程序、框架和其他用户级软件不能分配Wired memory。然而，它们可以影响在任何时候存在多少Wired memory。例如，创建线程和端口的应用程序隐式申请了Wired memory，这些内存是内核资源需要的。</p><p>Table 2 lists some of the wired-memory costs for application-generated entities.</p><table><thead><tr><th>Resource</th><th>Wired Memory Used by Kernel</th></tr></thead><tbody><tr><td>Process</td><td>16 kilobytes</td></tr><tr><td>Thread</td><td>blocked in a continuation—5 kilobytes; blocked—21 kilobyte</td></tr><tr><td>Mach port</td><td>116 bytes</td></tr><tr><td>Mapping</td><td>32 byte</td></tr><tr><td>Library</td><td>2 kilobytes plus 200 bytes for each task that uses it</td></tr><tr><td>Memory region</td><td>160 bytes</td></tr></tbody></table><p>As you can see, every thread, process, and library contributes to the resident footprint of the system. In addition to your application using wired memory, however, the kernel itself requires wired memory for the following entities:<br>如您所见，每个线程、进程和库都会影响系统的驻留内存。但是，除了使用Wired memory的应用程序之外，内核本身的以下实体会使用有线内存:</p><ol><li>VM objects</li><li>the virtual memory buffer cache</li><li>I/O buffer caches</li><li>drivers</li></ol><p>Wired data structures are also associated with the physical page and map tables used to store virtual-memory mapping information, Both of these entities scale with the amount of available physical memory. Consequently, when you add memory to a system, the amount of wired memory increases even if nothing else changes. When a computer is first booted into the Finder, with no other applications running, wired memory can consume approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system.<br>Wired data structures还与物理页面、用于存储虚拟内存映射信息的映射表相关联，这两个实体都与可用物理内存的大小相关联。因此，当您向系统添加内存时，即使没有其他变化，wired-memory的数量也会增加。当一台计算机第一次启动Finder时，没有其他应用程序运行时，在64兆系统中wired-memory可以消耗大约14兆字节 在128兆系统中消耗17兆字节。</p><p>Wired memory pages are not immediately moved back to the free list when they become invalid. Instead they are “garbage collected” when the free-page count falls below the threshold that triggers page out events.<br>Wired memory页在无效时不会立即移回空闲列表。相反，当空闲页面数低于触发page out事件的阈值时，它们会被“垃圾收集”。</p><h2 id="Page-Lists-in-the-Kernel"><a href="#Page-Lists-in-the-Kernel" class="headerlink" title="Page Lists in the Kernel"></a>Page Lists in the Kernel</h2><p>The kernel maintains and queries three system-wide lists of physical memory pages:<br>内核维护和查询三个系统范围的物理内存页列表:。</p><ul><li>The active list contains pages that are currently mapped into memory and have been recently accessed.</li><li>The inactive list contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be removed from memory at any time.</li><li>The free list contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them.</li></ul><ul><li>活动列表包含当前映射到内存和最近访问的页面。</li><li>非活动列表包含当前驻留在物理内存中但最近未被访问的页面。这些页面包含有效的数据，但是可以随时从内存中删除。</li><li>空闲列表包含 没有和任何VM对象关联的物理内存页。任何需要这些页面的进程都可以立即使用这些页面。</li></ul><p>When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list. If a page has been accessed recently, it is reactivated and placed on the end of the active list. In OS X, if an inactive page contains data that has not been written to the backing store recently, its contents must be paged out to disk before it can be placed on the free list. (In iOS, modified but inactive pages must remain in memory and be cleaned up by the application that owns them.) If an inactive page has not been modified and is not permanently resident (wired), it is stolen (any current virtual mappings to it are destroyed) and added to the free list. Once the free list size exceeds the target threshold, the pager rests.<br>当空闲列表中的页面数低于阈值(由物理内存大小决定)时，pager将尝试平衡队列。它通过从非活动列表中提取页面来实现这一点。如果最近访问了某个页面，则重新激活该页面并将其放置在活动列表的末尾。在OS X中，如果一个不活动的页面包含了最近没有写到后台存储的数据，那么在它被放到空闲列表之前，它的内容必须被分页到磁盘上。(在iOS中，修改但不活跃的页面必须保留在内存中，并由拥有它们的应用程序进行清理。) 如果一个不活动的页面没有被修改，并且不是永久驻留(wired)，那么它将被窃取(它的任何当前虚拟映射都将被销毁)并添加到空闲列表中。一旦空闲列表大小超过目标阈值，pager就会停止。</p><p>The kernel moves pages from the active list to the inactive list if they are not accessed; it moves pages from the inactive list to the active list on a soft fault (see Paging In Process). When virtual pages are swapped out, the associated physical pages are placed in the free list. Also, when processes explicitly free memory, the kernel moves the affected pages to the free list.<br>内核将未访问的页面从活动列表移动到非活动列表;通过soft fault将页面从非活动列表移动到活动列表 (请参阅分页In Process)。当虚拟页面交换出去时，相关的物理页面被放在空闲列表中。此外，当进程显式地释放内存时，内核将受影响的页面移动到空闲列表。</p><h2 id="Paging-Out-Process"><a href="#Paging-Out-Process" class="headerlink" title="Paging Out Process"></a>Paging Out Process</h2><p>In OS X, when the number of pages in the free list dips below a computed threshold, the kernel reclaims physical pages for the free list by swapping inactive pages out of memory. To do this, the kernel iterates all resident pages in the active and inactive lists, performing the following steps:</p><ol><li>If a page in the active list is not recently touched, it is moved to the inactive list.</li><li>If a page in the inactive list is not recently touched, the kernel finds the page’s VM object.</li><li>If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object.</li><li>The VM object’s default pager attempts to write the page out to the backing store.</li><li>If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list.</li></ol><p>在OS X中，当空闲列表中的页面数量低于计算的阈值时，内核通过将不活动的页面从内存中交换出来，从而回收空闲列表的物理页面。为此，内核遍历活动和非活动列表中的所有驻留页面，执行以下步骤:</p><ol><li>如果活动列表中的某个页面最近未被触摸，它将被移到非活动列表。</li><li>如果非活动列表中的一个页面最近没有被使用，内核将找到页面的VM对象。</li><li>如果VM对象以前从未被分页，那么内核将调用一个初始化例程，该例程创建并分配一个默认的分页器对象。</li><li>VM对象的默认分页器尝试将页面写到后台存储。</li><li>如果pager成功，内核释放页面占用的物理内存，并将页面从非活动列表移动到空闲列表。</li></ol><h2 id="Paging-In-Process"><a href="#Paging-In-Process" class="headerlink" title="Paging In Process"></a>Paging In Process</h2><p>The final phase of virtual memory management moves pages into physical memory, either from the backing store or from the file containing the page data. A memory access fault initiates the page-in process. A memory access fault occurs when code tries to access data at a virtual address that is not mapped to physical memory. There are two kinds of faults:<br>虚拟内存管理的最后一个阶段是将页面移动到物理内存中，或者从后台存储区，或者从包含页面数据的文件中。内存访问错误启动page-in进程。当代码试图访问没有映射到物理内存的虚拟地址中的数据时，会发生内存访问错误。有两种错误:</p><ol><li>A soft fault occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process.</li><li><p>A hard fault occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault.</p></li><li><p>soft fault：当引用地址的页驻留在物理内存中，但当前没有映射到此进程的地址空间时，就会发生此错误。</p></li><li>hard fault：当引用地址的页面不在物理内存中，而是被交换到后备存储器(或从映射文件中可用)时，就会出现。这就是通常所说的页面错误。</li></ol><p>When any type of fault occurs, the kernel locates the map entry and VM object for the accessed region. The kernel then goes through the VM object’s list of resident pages. If the desired page is in the list of resident pages, the kernel generates a soft fault. If the page is not in the list of resident pages, it generates a hard fault.<br>当发生任何类型的错误时，内核为被访问区域定位映射条目和VM对象。内核然后遍历VM对象的常驻页面列表。如果希望的页面位于驻留页面的列表中，内核会生成一个软错误。如果页面不在常驻页面列表中，则会产生硬错误。</p><p>For soft faults, the kernel maps the physical memory containing the pages to the virtual address space of the process. The kernel then marks the specific page as active. If the fault involved a write operation, the page is also marked as modified so that it will be written to backing store if it needs to be freed later.<br>对于软故障，内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将特定页面标记为活动页面。如果该错误涉及到写操作，那么该页面也会被标记为修改，以便在以后需要释放时写入到后备存储器中。</p><p>For hard faults, the VM object’s pager finds the page in the backing store or from the file on disk, depending on the type of pager. After making the appropriate adjustments to the map information, the pager moves the page into physical memory and places the page on the active list. As with a soft fault, if the fault involved a write operation, the page is marked as modified.<br>对于硬故障，VM对象的寻呼机根据寻呼机的类型在备份存储中或从磁盘上的文件中查找页面。在对映射信息进行适当的调整之后，寻呼机将页面移动到物理内存中，并将页面放在活动列表中。与软错误一样，如果错误涉及写操作，则将页面标记为已修改。</p><h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><p>Mac的内存使用：Wired, Active, Inactive和Free</p><ul><li>Wired(联动): 系统核心占用的，永远不会从系统物【[内存】中去除。</li><li>Active(活跃): 表示这些内存数据正在使用种，或者刚被使用过。</li><li>Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。</li><li>Free(可用空间): 表示这些内存中的数据是无效的，即内存剩余量！</li></ul><p>当Free的【内存】低于某个key值时，这个key值是由你的物理内存大小决定的，系统则会按照以下顺序使用Inactive的资源。</p><ul><li>首先，如果Inactive的数据最近被调用了，系统会把它们的状态改变成Active,并且在原有Active内存逻辑地址的后面；</li><li>其次，如果Inactive的内存数据最近没有被使用过，但是曾经被更改过，而还没有在硬盘的相应虚拟[内存]中做修改，系统会对相应硬盘的虚拟内存做修改，并把这部分物理内存释放为free供程序使用。</li><li>再次，如果inactive[内存]中得数据被在映射到硬盘后再没有被更改过，则直接释放成free。</li><li>最后如果active的内存一段时间没有被使用，会被暂时改变状态为inactive。</li></ul><p>　　所以，如果你的系统里有少量的free memeory和大量的inactive的memeory，说明你的内存是够用的，系统运行在最佳状态，只要需要,系统就会使用它们，不用担心。</p><pre><code>如果系统的free memory和inactive memory都很少，而active memory很多，说明你的[内存]不够了。当然一开机，大部分[内存]都是free,这时系统反而不在最佳状态，因为很多数据都需要从硬盘调用，速度反而慢了。</code></pre><h4 id="Free-memory"><a href="#Free-memory" class="headerlink" title="Free memory"></a>Free memory</h4><p>This is RAM that’s not being used.</p><h4 id="Wired-memory"><a href="#Wired-memory" class="headerlink" title="Wired memory"></a>Wired memory</h4><p>Information in this memory can’t be moved to the hard disk, so it must stay in RAM. The amount of Wired memory depends on the applications you are using.</p><h4 id="Active-memory"><a href="#Active-memory" class="headerlink" title="Active memory"></a>Active memory</h4><p>This information is currently in memory, and has been recently used.</p><h4 id="Inactive-memory"><a href="#Inactive-memory" class="headerlink" title="Inactive memory"></a>Inactive memory</h4><p>This information in memory is not actively being used, but was recently used.</p><p>For example, if you’ve been using Mail and then quit it, the RAM that Mail was using is marked as Inactive memory. This Inactive memory is available for use by another application, just like Free memory.  However, if you open Mail before its Inactive memory is used by a different application, Mail will open quicker because its Inactive memory is converted to Active memory, instead of loading Mail from the slower hard disk.</p><h4 id="Used"><a href="#Used" class="headerlink" title="Used"></a>Used</h4><p>This is the total amount of memory used.</p><h4 id="VM-size"><a href="#VM-size" class="headerlink" title="VM size"></a>VM size</h4><p>This is the total amount of Virtual Memory for all processes on your Mac. </p><h4 id="Page-ins-Page-outs"><a href="#Page-ins-Page-outs" class="headerlink" title="Page ins / Page outs"></a>Page ins / Page outs</h4><p>This refers to the amount of information moved between RAM and the hard disk. This number is a cumulative amount of data that Mac OS X has moved between RAM and disk space.</p><p>Tip: Page outs occur when your Mac has to write information from RAM to the hard drive (because RAM is full).  Adding more RAM may reduce page outs.</p><h4 id="Swap-used"><a href="#Swap-used" class="headerlink" title="Swap used"></a>Swap used</h4><p>This is the amount of information copied to the swap file on your hard drive.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译下&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Memory Usage Performance Guidelines&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存1" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/"/>
    
  </entry>
  
  <entry>
    <title>Mach-o文件结构理解</title>
    <link href="http://yoursite.com/wiki/IOS/Mach_O/Mach_O_File_Struct/"/>
    <id>http://yoursite.com/wiki/IOS/Mach_O/Mach_O_File_Struct/</id>
    <published>2018-05-16T04:07:12.000Z</published>
    <updated>2018-06-22T08:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：</p><ol><li>有助于理解崩溃日志解析的原理。理解KSCrash源码；</li><li>有助于理解开源代码fishhook的原理；</li><li>有助于理解腾讯OOMDetector开源库源码；</li><li>好处应该不止这些。</li></ol><a id="more"></a><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>它的组成结构如下图所示，包括了Header、Load commands、Data（包含Segement的具体数据）。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/mach-o-overall_small.jpg" alt="mach-o 文件结构"></p><p>这张图片说明了几点：</p><ol><li>mach-o由三部分构成，header、Load Commands、Data区域。</li><li>commond指定了各种数据在Data区域的位置。 可以将header比喻为文章的摘要，Load Commands为文章的目录、Data是文章的正文。 目录的特点是可以定位内容在文章的位置。Load Commands其实就是这个作用。</li><li>每个segment下面可以有一个或多个section。 可以理解为一级目录下的子二级目录~~。</li></ol><p>也可以从另外角度认识Mach-O结构，如图所示。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_O_new_overall_small.png" alt="mach-o 内部详细结构"></p><p>这张图表达了更多的细节信息：</p><ol><li>segment 的类型有__TEXT(程序的代码区域，只读) 、__DATA(程序的数据区域，可读写)</li><li>__DATA segment 后面跟随着多个section，包括__nl__symbol_ptr （not layz符号）__la__symbol_ptr</li></ol><p>下面来聊聊Header部分</p><h2 id="mach-header"><a href="#mach-header" class="headerlink" title="mach-header"></a>mach-header</h2><p>mach-header 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>magic;<span class="comment">/* mach magic number identifier */</span></span><br><span class="line"><span class="keyword">cpu_type_t</span>cputype;<span class="comment">/* cpu specifier */</span></span><br><span class="line"><span class="keyword">cpu_subtype_t</span>cpusubtype;<span class="comment">/* machine specifier */</span></span><br><span class="line"><span class="keyword">uint32_t</span>filetype;<span class="comment">/* type of file */</span></span><br><span class="line"><span class="keyword">uint32_t</span>ncmds;<span class="comment">/* number of load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>sizeofcmds;<span class="comment">/* the size of all the load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>magic：魔数，用于快速确认该文件的种类（用于64位还是32位）。可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64 0xcffaedfe <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></span><br></pre></td></tr></table></figure><ul><li>cputype：CPU类型，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386CPU_TYPE_X86  <span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>CPU_TYPE_X86_64(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM((cpu_type_t) 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br></pre></td></tr></table></figure><ul><li>cpusubtype：对应的具体类型，比如arm64、armv7，可取值（部分）如下：</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_SUBTYPE_X86_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_X86_64_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7((<span class="name">cpu_subtype_t</span>) <span class="number">9</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7S((<span class="name">cpu_subtype_t</span>) <span class="number">11</span>) /* Swift */</span><br></pre></td></tr></table></figure><ul><li>filetype：文件类型，比如可执行文件、库文件、Dsym文件，例如：MH_EXECUTE值是2，代表可执行文件，可取值如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * Constants <span class="keyword">for</span> the filetype field of the mach_header</span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_OBJECT   0x1     <span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_EXECUTE  0x2     <span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FVMLIB   0x3     <span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CORE     0x4     <span class="comment">/* core file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PRELOAD  0x5     <span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB    0x6     <span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLINKER 0x7     <span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BUNDLE   0x8     <span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB_STUB   0x9     <span class="comment">/* shared library stub for static */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DSYM     0xa     <span class="comment">/* companion file with only debug */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_KEXT_BUNDLE  0xb     <span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure><ul><li>ncmds ：加载命令条数</li><li>sizeofcmds：所有加载命令的大小</li><li>reserved：保留字段</li><li>flags：标志位，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK0x4<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="meta"><span class="comment">   dynamic linker and can't be staticly</span></span></span><br><span class="line"><span class="meta"><span class="comment">   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBOUND0x10<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">   references prebound. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS0x20<span class="comment">/* the file has its read-only and</span></span></span><br><span class="line"><span class="meta"><span class="comment">   read-write segments split */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL0x80<span class="comment">/* the image is using two-level name</span></span></span><br><span class="line"><span class="meta"><span class="comment">   space bindings */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOMULTIDEFS0x200<span class="comment">/* this umbrella guarantees no multiple</span></span></span><br><span class="line"><span class="meta"><span class="comment">   defintions of symbols in its</span></span></span><br><span class="line"><span class="meta"><span class="comment">   sub-images so the two-level namespace</span></span></span><br><span class="line"><span class="meta"><span class="comment">   hints can always be used. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CANONICAL    0x4000<span class="comment">/* the binary has been canonicalized</span></span></span><br><span class="line"><span class="meta"><span class="comment">   via the unprebind operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES0x8000<span class="comment">/* the final linked image contains</span></span></span><br><span class="line"><span class="meta"><span class="comment">   external weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000<span class="comment">/* the final linked image uses</span></span></span><br><span class="line"><span class="meta"><span class="comment">   weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_PIE 0x200000<span class="comment">/* When this bit is set, the OS will</span></span></span><br><span class="line"><span class="meta"><span class="comment">   load the main executable at a</span></span></span><br><span class="line"><span class="meta"><span class="comment">   random address.  Only used in</span></span></span><br><span class="line"><span class="meta"><span class="comment">   MH_EXECUTE filetypes. */</span></span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>下图是借用machoview查看header的结构：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/machview-header.png" alt="header 结构"></p><p>可以看出：</p><ol><li>该文件是可执行文件</li><li>文件的构架是x86_64</li><li>number of Load commands表示有74个load commond</li><li>MH_TWOLEVEL二级名字空间</li><li>MH_PIE 随机地址空间</li></ol><p>接下来介绍head后的load command部分。</p><h2 id="load-command"><a href="#load-command" class="headerlink" title="load command"></a>load command</h2><p>Load commands紧跟在头部之后。Load commands指定了文件的布局结构和链接特征。有很多很多种Load commands。这些加载指令清晰地告诉加载器如何处理二进制数据，有些命令是由内核处理的，有些是由动态链接器处理的。  </p><p>这里列举几个看上去比较熟悉的….</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT0x1<span class="comment">/* segment of this file to be mapped  被映射到内存的段*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SYMTAB0x2<span class="comment">/* link-edit stab symbol table info  符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_DYSYMTAB0xb<span class="comment">/* dynamic link-edit symbol table info 动态符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_DYLIB0xc<span class="comment">/* load a dynamically linked shared library 动态链接库*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load a dynamically linked shared library that is allowed to be missing</span></span><br><span class="line"><span class="comment"> * (all symbols are weak imported).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT_640x19<span class="comment">/* 64-bit segment of this file to be</span></span></span><br><span class="line"><span class="meta"><span class="comment">   mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_UUID0x1b<span class="comment">/* the uuid */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_RPATH       (0x1c | LC_REQ_DYLD)    <span class="comment">/* runpath additions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_CODE_SIGNATURE 0x1d<span class="comment">/* local of code signature */</span></span></span><br></pre></td></tr></table></figure><p>load command的基本定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;       <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;   <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体只表示了所有的command都需要包含的属性—-命令类型和命令的大小。具体对于不同的命令都会有不同的定义。但是必须包含上面两个字段。</p><p>下面就来看具体的命令—LC_SEGMENT_64类型命令的定义。</p><h3 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The segment load command indicates <span class="keyword">that</span> a part <span class="keyword">of</span> this <span class="built_in">file</span> <span class="keyword">is</span> <span class="keyword">to</span> be</span><br><span class="line"> * mapped <span class="keyword">into</span> <span class="keyword">the</span> task's address <span class="literal">space</span>.  The size <span class="keyword">of</span> this segment <span class="keyword">in</span> memory,</span><br><span class="line"> * vmsize, maybe <span class="keyword">equal</span> <span class="keyword">to</span> <span class="keyword">or</span> larger than <span class="keyword">the</span> amount <span class="keyword">to</span> map <span class="keyword">from</span> this <span class="built_in">file</span>,</span><br><span class="line"> * filesize.  The <span class="built_in">file</span> <span class="keyword">is</span> mapped starting <span class="keyword">at</span> fileoff <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">beginning</span> <span class="keyword">of</span></span><br><span class="line"> * <span class="keyword">the</span> segment <span class="keyword">in</span> memory, vmaddr.  The <span class="built_in">rest</span> <span class="keyword">of</span> <span class="keyword">the</span> memory <span class="keyword">of</span> <span class="keyword">the</span> segment,</span><br><span class="line"> * <span class="keyword">if</span> any, <span class="keyword">is</span> allocated zero fill <span class="keyword">on</span> demand.  The segment's maximum virtual</span><br><span class="line"> * memory protection <span class="keyword">and</span> initial virtual memory protection are specified</span><br><span class="line"> * <span class="keyword">by</span> <span class="keyword">the</span> maxprot <span class="keyword">and</span> initprot fields.  If <span class="keyword">the</span> segment has sections <span class="keyword">then</span> <span class="keyword">the</span></span><br><span class="line"> * section structures directly follow <span class="keyword">the</span> segment command <span class="keyword">and</span> their size <span class="keyword">is</span></span><br><span class="line"> * reflected <span class="keyword">in</span> cmdsize.</span><br><span class="line">段加载命令指定了：文件需要映射到程序地址空间的某个部分。 </span><br><span class="line">段在内存中的大小用vmsize指定。内存中段的大小可能等于或大于文件大小（filesize），文件大小使用filesize指定。</span><br><span class="line">映射的源起始文件地址是fileoff，目的起始地址是vmaddr。内存中剩余的段内存用<span class="number">0</span>填充。</span><br><span class="line">段的最大内存权限和初始内存权限用maxprot、initprot字段指定。</span><br><span class="line">如果段有section，那么section的结构紧跟着段。section的大小包括在cmdsize字段中。</span><br><span class="line"> */</span><br><span class="line">struct segment_command &#123; /* <span class="keyword">for</span> <span class="number">32</span>-bit architectures */</span><br><span class="line">uint32_tcmd;/* LC_SEGMENT */</span><br><span class="line">uint32_tcmdsize;/* includes sizeof section structs */</span><br><span class="line">charsegname[<span class="number">16</span>];/* segment <span class="built_in">name</span> */</span><br><span class="line">uint32_tvmaddr;/* memory address <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tvmsize;/* memory size <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfileoff;/* <span class="built_in">file</span> <span class="built_in">offset</span> <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfilesize;/* amount <span class="keyword">to</span> map <span class="keyword">from</span> <span class="keyword">the</span> <span class="built_in">file</span> */</span><br><span class="line">vm_prot_tmaxprot;/* maximum VM protection */</span><br><span class="line">vm_prot_tinitprot;/* initial VM protection */</span><br><span class="line">uint32_tnsects;/* <span class="built_in">number</span> <span class="keyword">of</span> sections <span class="keyword">in</span> segment */</span><br><span class="line">uint32_tflags;/* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出segment_command包含了命令必须的属性cmd、cmdsize。剩下的属性是segment_command特有的属性。</p><p>下面是名称为_DATA的segment commond的截图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/DATA_Segment.png" alt="segement"></p><p>可以看出：</p><ol><li>命令类型是LC_SEGMENT_64</li><li>命令的大小1832</li><li>segment 命令的名称是__DATA</li><li>映射的内存地址是4360744960（十进制）</li><li>内存的大小12488704</li><li>文件的偏移量是65777664</li><li>需要映射的文件的大小10424320</li><li>最大内存保护权限：读写执行</li><li>初始内存权限：读写</li><li>这个端附属了22个 section，也就是说1832大小的segment_command包括了22个section命令的大小。</li><li>看的方法：offset代表文件的便宜量、Data表示内存地址中存储的值、description表示这段内存地址的名称的描述、value表示存储的值的可视描述。</li></ol><p>下面看看22个section的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/sections.png" alt="22sections"></p><p>下面讲解section的结构,section 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></span><br><span class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></span><br><span class="line"><span class="keyword">uint64_t</span>addr;<span class="comment">/* memory address of this section */</span></span><br><span class="line"><span class="keyword">uint64_t</span>size;<span class="comment">/* size in bytes of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>offset;<span class="comment">/* file offset of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>align;<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reloff;<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nreloc;<span class="comment">/* number of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved1;<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved2;<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved3;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图是__nl_symbol_ptr section 的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/nl_symbol_ptr_section.png" alt="nl_symbol_ptr_section"></p><p>可以看出：</p><ol><li>section的名称是__nl_symbol_ptr</li><li>该section所属的segment的名称 _DATA 。segment名称大写，section名称小写，这个是默认的规定。</li><li>内存地址4360744960</li><li>该section在内存中的大小是16</li><li>该section在物理文件的偏移量65777664</li><li>内存对齐大小 8</li><li>间接符号索引是1198 （这里不太懂什么意思）</li></ol><p>segment 常用的有四种，如图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/segment_types.png" alt="segment_types"></p><p>可以看出有<strong>PAGEZERO、</strong>TEXT、<strong>DATA、</strong>LINKEDIT。下面是这四个segement的基本介绍。</p><ol><li>The static linker creates a __PAGEZERO segment as the first segment of an executable file. This segment is located at virtual memory location 0 and has no protection rights assigned, the combination of which causes accesses to NULL, a common C programming error, to immediately crash. The __PAGEZERO segment is the size of one full VM page for the current architecture (for Intel-based and PowerPC-based Macintosh computers, this is 4096 bytes or 0x1000 in hexadecimal). Because there is no data in the __PAGEZERO segment, it occupies no space in the file (the file size in the segment command is 0).</li><li>The <code>__TEXT</code> segment contains executable code and other read-only data. To allow the kernel to map it directly from the executable into sharable memory, the static linker sets this segment’s virtual memory permissions to disallow writing. When the segment is mapped into memory, it can be shared among all processes interested in its contents. (This is primarily used with frameworks, bundles, and shared libraries, but it is possible to run multiple copies of the same executable in OS X, and this applies in that case as well.) The read-only attribute also means that the pages that make up the <code>__TEXT</code> segment never need to be written back to disk. When the kernel needs to free up physical memory, it can simply discard one or more __TEXT pages and re-read them from disk when they are next needed.</li><li>The <code>__DATA</code> segment contains writable data. The static linker sets the virtual memory permissions of this segment to allow both reading and writing. Because it is writable, the <code>__DATA</code> segment of a framework or other shared library is logically copied for each process linking with the library. When memory pages such as those making up the <code>__DATA</code> segment are readable and writable, the kernel marks them copy- on-write; therefore when a process writes to one of these pages, that process receives its own private copy of the page.</li><li>The <code>__LINKEDIT</code> segment contains raw data used by the dynamic linker, such as symbol, string, and relocation table entries.</li></ol><h3 id="LC-SYMTAB"><a href="#LC-SYMTAB" class="headerlink" title="LC_SYMTAB"></a>LC_SYMTAB</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD</span></span><br><span class="line"><span class="comment"> * "stab" style symbol table information as described in the header files</span></span><br><span class="line"><span class="comment"> * &lt;nlist.h&gt; and &lt;stab.h&gt;.</span></span><br><span class="line"><span class="comment"> * symtab_command 包含了符号表、字符串索引表 的偏移量和大小 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_SYMTAB */</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct symtab_command) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>symoff;<span class="comment">/* symbol table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nsyms;<span class="comment">/* number of symbol table entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>stroff;<span class="comment">/* string table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>strsize;<span class="comment">/* string table size in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是LC_SYMTAB command示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/systab.png" alt="symbol table"></p><p>由表中可以看出</p><ol><li>命令的大小是24 （十进制）</li><li>符号表在物理文件的偏移量是 77360448</li><li>符号表的大小 1069179</li><li>String表的物理文件偏移量是94479244</li><li>string表的大小是22093264</li></ol><p>这个commond同时指定了两个表(符号表、String表)的位置信息。</p><h3 id="LC-UUID"><a href="#LC-UUID" class="headerlink" title="LC_UUID"></a>LC_UUID</h3><p>LC_UUID 用来标识唯一APP，命令的定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_UUID */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct uuid_command) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>uuid[<span class="number">16</span>];<span class="comment">/* the 128-bit uuid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/uuid.png" alt="uuid"></p><p>每个可执行程序都有一个uuid，这样根据不同的uuid能确定包。比如崩溃日志中就会包含uuid字段。表示是哪个包崩溃了。</p><h3 id="LC-DYSYMTAB（动态符号表）"><a href="#LC-DYSYMTAB（动态符号表）" class="headerlink" title="LC_DYSYMTAB（动态符号表）"></a>LC_DYSYMTAB（动态符号表）</h3><p>下面的描述摘至<code>&lt;mach-o/loader.h&gt;</code> 的459行。</p><p>  This is the second set of the symbolic information which is used to support  the data structures for the dynamically link editor.<br>LC_DYSYMTAB 是第二种类型符号集，这个符号集被动态连接器的数据结构使用。</p><p>  The original set of symbolic information in the symtab_command which contains the symbol and string tables must also be present when this load command is present.<br>当这个command（动态符号command）出现的时候，symtab_command必须出现，symtab_command包含符号表和String表。</p><p>  When this load command is present the symbol table is organized into three groups of symbols:<br>当这个加载命令出现的时候，符号表被组织为三部分：</p><ol><li>local symbols (static and debugging symbols) - grouped by module</li><li>defined external symbols - grouped by module (sorted by name if not lib)</li><li>undefined external symbols (sorted by name if MH_BINDATLOAD is not set, and in order the were seen by the static linker if MH_BINDATLOAD is set)</li></ol><p>In this load command there are offsets and counts to each of the three groups of symbols.<br>这个命令指定了每个部分的偏移量和符号个数：</p><p>This load command contains a the offsets and sizes of the following new symbolic information tables:<br>这个命令包含下面新的符号：</p><ol><li>table of contents</li><li>module table</li><li>reference symbol table</li><li>indirect symbol table</li></ol><p>The first three tables above (the table of contents, module table and reference symbol table) are only present if the file is a dynamically linked shared library.<br>前三个只有文件是动态库的时候才出现。 </p><p>For executable and object modules, which are files containing only one module, the information that would be in these three tables is determined as follows:</p><ol><li>table of contents - the defined external symbols are sorted by name</li><li>module table - the file contains only one module so everything in the file is part of the module.</li><li>reference symbol table - is the defined and undefined external symbols</li></ol><p>For dynamically linked shared library files this load command also contains offsets and sizes to the pool of relocation entries for all sections separated into two groups:</p><ol><li>external relocation entries</li><li>local relocation entries</li></ol><p>For executable and object modules the relocation entries continue to hang off the section structures.</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>cmd</td><td>uint32_t</td><td>LC_DYSYMTAB</td></tr><tr><td>cmdsize</td><td>uint32_t</td><td>sizeof(struct dysymtab_command)</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td>ilocalsym</td><td>uint32_t</td><td>index to local symbols</td></tr><tr><td>nlocalsym</td><td>uint32_t</td><td>number of local symbols</td></tr><tr><td>iextdefsym</td><td>uint32_t</td><td>index to externally defined symbols</td></tr><tr><td>nextdefsym</td><td>uint32_t</td><td>number of externally defined symbols</td></tr><tr><td>iundefsym</td><td>uint32_t</td><td>index to undefined symbols</td></tr><tr><td>nundefsym</td><td>uint32_t</td><td>number of undefined symbols</td></tr><tr><td>-</td><td>-</td><td>-</td></tr><tr><td>tocoff</td><td>uint32_t</td><td>file offset to table of contents</td></tr><tr><td>ntoc</td><td>uint32_t</td><td>number of entries in table of contents</td></tr><tr><td>modtaboff</td><td>uint32_t</td><td>file offset to module table</td></tr><tr><td>nmodtab</td><td>uint32_t</td><td>number of module table entries</td></tr><tr><td>extrefsymoff</td><td>uint32_t</td><td>offset to referenced symbol table</td></tr><tr><td>nextrefsyms</td><td>uint32_t</td><td>number of referenced symbol table entries</td></tr><tr><td>indirectsymoff</td><td>uint32_t</td><td>file offset to the indirect symbol table</td></tr><tr><td>nindirectsyms</td><td>uint32_t</td><td>number of indirect symbol table entries</td></tr><tr><td>–</td><td>–</td><td>–</td></tr><tr><td>extreloff</td><td>uint32_t</td><td>offset to external relocation entries</td></tr><tr><td>nextrel</td><td>uint32_t</td><td>number of external relocation entries</td></tr><tr><td>locreloff</td><td>uint32_t</td><td>offset to local relocation entries</td></tr><tr><td>nlocrel</td><td>uint32_t</td><td>number of local relocation entries</td></tr></tbody></table><p>又表得：动态符号command定义了各种符号的偏移量和各种符号的个数(9种)。</p><h2 id="DATA部分"><a href="#DATA部分" class="headerlink" title="DATA部分"></a>DATA部分</h2><p>DATA部分是Mach-O文件的主体，存储着各种类型的实际数据，例如LC_SEGMENT（<strong>TEXT）指定的代码段, LC_SEGMENT（</strong>DATA）指定的数据段。 LC_SYMTAB（__LINKEDIT）段指定的符号表和String表、以及动态符号表，等等。<br>这里只了解三种结构：</p><ul><li>符号表</li><li>String表</li><li>动态符号表</li></ul><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>符号表的数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Symbols with a index into the string table of zero (n_un.n_strx == 0) are</span></span><br><span class="line"><span class="comment"> * defined to have a null, "", name.  Therefore all string indexes to non null</span></span><br><span class="line"><span class="comment"> * names must not have a zero string index.  This is bit historical information</span></span><br><span class="line"><span class="comment"> * that has never been well documented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The n_type field really contains four fields:</span></span><br><span class="line"><span class="comment"> *unsigned char N_STAB:3,</span></span><br><span class="line"><span class="comment"> *      N_PEXT:1,</span></span><br><span class="line"><span class="comment"> *      N_TYPE:3,</span></span><br><span class="line"><span class="comment"> *      N_EXT:1;</span></span><br><span class="line"><span class="comment"> * which are used via the following masks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_STAB0xe0  <span class="comment">/* if any of these bits set, a symbolic debugging entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_PEXT0x10  <span class="comment">/* private external symbol bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_TYPE0x0e  <span class="comment">/* mask for the type bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_EXT0x01  <span class="comment">/* external symbol bit, set for external symbols */</span></span></span><br></pre></td></tr></table></figure><p>示意图如下：<br><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/system_detail.png" alt="symbol"></p><p>可以看出：</p><ol><li>String表的偏移量是0xbbff8, 翻译后是[GMRYouHaoHuoReq getRequestURL]</li><li>地址是0x100003300，</li></ol><h3 id="string表"><a href="#string表" class="headerlink" title="string表"></a>string表</h3><p>String表顺序列出了二进制mach-O文件的中的所有可见字符串。串之间通过0x00分隔。可以通过相对String表起始位置的偏移量随机访问String表中的字符串。符号表结构中的n_strx指定的就是String表中的偏移量。通过这个偏移量可以访问到符号对应的具体字符串。</p><p>例如： String表的0xbbf8处是不是[GMRYouHaoHuoReq getRequestURL]，string表的地址是0x049C6D40 加上偏移量0x000BBFB1 ，等于0x54d633d。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/stringtable.png" alt="string table"></p><p>可以看出string表的0x54d633d地址出就是：[GMRYouHaoHuoReq getRequestURL]。  </p><h3 id="动态符号表。"><a href="#动态符号表。" class="headerlink" title="动态符号表。"></a>动态符号表。</h3><p>动态符号表中存储着动态连接器使用的相关符号。 每个符号一般占用32bit的存储空间。存储的内容是符号表中的索引。</p><h2 id="注意啦"><a href="#注意啦" class="headerlink" title="注意啦"></a>注意啦</h2><p>网上直接下载的MachOView经常崩溃，是由于有段代码没有做非空判断，所以为了有效使用MachOView，请从<a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">官网</a>下载代码，然后在崩溃的地方添加非空判断。就OK拉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h" rel="external nofollow noopener noreferrer" target="_blank">mach-o/loader.h</a></li><li><a href="https://www.jianshu.com/p/54d842db3f69" rel="external nofollow noopener noreferrer" target="_blank">趣探 Mach-O：文件格式分析</a></li><li><a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">MachOView 源码地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有助于理解崩溃日志解析的原理。理解KSCrash源码；&lt;/li&gt;
&lt;li&gt;有助于理解开源代码fishhook的原理；&lt;/li&gt;
&lt;li&gt;有助于理解腾讯OOMDetector开源库源码；&lt;/li&gt;
&lt;li&gt;好处应该不止这些。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="Mach-O" scheme="http://yoursite.com/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>weex系列抄之一---事件处理</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/Weex_six_events/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/Weex_six_events/</id>
    <published>2018-05-04T05:07:12.000Z</published>
    <updated>2018-06-25T09:44:33.000Z</updated>
    
    <content type="html"><![CDATA[<!--<p align='center'><img src='http://upload-images.jianshu.io/upload_images/1194012-cc51f3fa785a0464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240'></p>--><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前两篇文章里面分别谈了 Weex 如何在 Native 端初始化的和 Weex 是如何高效的渲染 Native 的原生 UI 的。Native 这边还缺一块，那就是 Native 产生的一些事件，是怎么传回给 JS 的。这篇文章就详细分析这一部分。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li>1.Weex 的事件类型</li><li>2.Weex 的事件传递</li></ul><h2 id="一-Weex的事件类型"><a href="#一-Weex的事件类型" class="headerlink" title="一.Weex的事件类型"></a>一.Weex的事件类型</h2><p>在 Weex 中，目前最新版本中事件总共分为 4 种类型，通用事件，Appear 事件，Disappear 事件，Page 事件。</p><p>在 Weex 的组件里面只包含前三种事件，即通用事件，Appear 事件，Disappear 事件。</p><p>当 WXComponent 添加事件的时候，会调用以下函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_addEventOnMainThread:(<span class="built_in">NSString</span> *)addEventName</span><br><span class="line">&#123;</span><br><span class="line">    WX_ADD_EVENT(appear, addAppearEvent)</span><br><span class="line">    WX_ADD_EVENT(disappear, addDisappearEvent)</span><br><span class="line">    </span><br><span class="line">    WX_ADD_EVENT(click, addClickEvent)</span><br><span class="line">    WX_ADD_EVENT(swipe, addSwipeEvent)</span><br><span class="line">    WX_ADD_EVENT(longpress, addLongPressEvent)</span><br><span class="line">    </span><br><span class="line">    WX_ADD_EVENT(panstart, addPanStartEvent)</span><br><span class="line">    WX_ADD_EVENT(panmove, addPanMoveEvent)</span><br><span class="line">    WX_ADD_EVENT(panend, addPanEndEvent)</span><br><span class="line">    </span><br><span class="line">    WX_ADD_EVENT(horizontalpan, addHorizontalPanEvent)</span><br><span class="line">    WX_ADD_EVENT(verticalpan, addVerticalPanEvent)</span><br><span class="line">    </span><br><span class="line">    WX_ADD_EVENT(touchstart, addTouchStartEvent)</span><br><span class="line">    WX_ADD_EVENT(touchmove, addTouchMoveEvent)</span><br><span class="line">    WX_ADD_EVENT(touchend, addTouchEndEvent)</span><br><span class="line">    WX_ADD_EVENT(touchcancel, addTouchCancelEvent)</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> addEvent:addEventName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WX_ADD_EVENT 是一个宏：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#define WX_ADD_EVENT(eventName, addSelector) \</span></span><br><span class="line"><span class="keyword">if</span> ([addEventName isEqualToString:@<span class="meta">#eventName]) &#123;\</span></span><br><span class="line">    [<span class="keyword">self</span> addSelector];\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即是判断待添加的事件 addEventName 的名字和默认支持的事件名字 eventName 是否一致，如果一致，就执行 addSelector 方法。</p><p>最后会执行一个 addEvent: 方法，每个组件里面会可以重写这个方法。在这个方法里面做的就是对组件的状态的标识。</p><p>比如 WXWebComponent 组件里面的 addEvent: 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addEvent:(<span class="built_in">NSString</span> *)eventName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([eventName isEqualToString:<span class="string">@"pagestart"</span>]) &#123;</span><br><span class="line">        _startLoadEvent = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([eventName isEqualToString:<span class="string">@"pagefinish"</span>]) &#123;</span><br><span class="line">        _finishLoadEvent = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([eventName isEqualToString:<span class="string">@"error"</span>]) &#123;</span><br><span class="line">        _failLoadEvent = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法里面即对 Web 组件里面的状态进行了标识。</p><p>接下来就看看这几个组件是怎么识别事件的触发的。</p><h3 id="1-通用事件"><a href="#1-通用事件" class="headerlink" title="1. 通用事件"></a>1. 通用事件</h3><p>在 WXComponent 的定义里，定义了如下和事件相关的变量：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXComponent</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@package</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> _appearEvent;</span><br><span class="line">    <span class="built_in">BOOL</span> _disappearEvent;</span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *_tapGesture;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_swipeGestures;</span><br><span class="line">    <span class="built_in">UILongPressGestureRecognizer</span> *_longPressGesture;</span><br><span class="line">    <span class="built_in">UIPanGestureRecognizer</span> *_panGesture;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> _listenPanStart;</span><br><span class="line">    <span class="built_in">BOOL</span> _listenPanMove;</span><br><span class="line">    <span class="built_in">BOOL</span> _listenPanEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> _listenHorizontalPan;</span><br><span class="line">    <span class="built_in">BOOL</span> _listenVerticalPan;</span><br><span class="line">    </span><br><span class="line">    WXTouchGestureRecognizer* _touchGesture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述变量里面就包含有4个手势识别器和1个自定义手势识别器。所以Weex的通用事件里面就包含这5种，点击事件，轻扫事件，长按事件，拖动事件，通用触摸事件。</p><h3 id="（一）点击事件"><a href="#（一）点击事件" class="headerlink" title="（一）点击事件"></a>（一）点击事件</h3><p>首先看点击事件：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WX_ADD_EVENT(click, addClickEvent)</span><br></pre></td></tr></table></figure><p>点击事件是通过上面这个宏加到指定视图上的。这个宏上面提到过了。这里直接把宏展开</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#define WX_ADD_EVENT(click, addClickEvent) \</span></span><br><span class="line"><span class="keyword">if</span> ([addEventName isEqualToString:@“click”]) &#123;\</span><br><span class="line">    [<span class="keyword">self</span> addClickEvent];\</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 addEventName 传进来 event 的是 @“click”，那么就是执行 addClickEvent 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addClickEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_tapGesture) &#123;</span><br><span class="line">        _tapGesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(onClick:)];</span><br><span class="line">        _tapGesture.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.view addGestureRecognizer:_tapGesture];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给当前的视图增加一个点击手势，触发的方法是 onClick: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onClick:(__unused <span class="built_in">UITapGestureRecognizer</span> *)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *position = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = <span class="keyword">self</span>.weexInstance.pixelScaleFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.calculatedFrame, <span class="built_in">CGRectZero</span>)) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> frame = [<span class="keyword">self</span>.view.superview convertRect:<span class="keyword">self</span>.calculatedFrame toView:<span class="keyword">self</span>.view.window];</span><br><span class="line">        position[<span class="string">@"x"</span>] = @(frame.origin.x/scaleFactor);</span><br><span class="line">        position[<span class="string">@"y"</span>] = @(frame.origin.y/scaleFactor);</span><br><span class="line">        position[<span class="string">@"width"</span>] = @(frame.size.width/scaleFactor);</span><br><span class="line">        position[<span class="string">@"height"</span>] = @(frame.size.height/scaleFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> fireEvent:<span class="string">@"click"</span> params:@&#123;<span class="string">@"position"</span>:position&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦用户点击屏幕，就会触发点击手势，点击手势就会执行上述的 onClick: 方法。在这个方法中，Weex 会计算点击出点击到的视图的坐标以及宽高尺寸。</p><p>说到这里就需要提到 Weex 的坐标计算方法了。</p><h3 id="（1）计算缩放比例因子"><a href="#（1）计算缩放比例因子" class="headerlink" title="（1）计算缩放比例因子"></a>（1）计算缩放比例因子</h3><p>在日常 iOS 开发中，开发者使用的计算单位是 pt。</p><p>iPhone5 分辨率320pt x 568pt<br>iPhone6 分辨率375pt x 667pt<br>iPhone6 Plus 分辨率414pt x 736pt  </p><p>由于每个屏幕的 ppi 不同(ppi:Pixels Per Inch，即每英寸所拥有的像素数目，屏幕像素密度。)，最终会导致分辨率的不同。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-a02a52ecc0fd8691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-07d0847d907f8fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这也就是我们日常说的@1x，@2x，@3x，目前 iPhone 手机也就3种 ppi</p><p>@1x，163ppi（iPhone3gs）<br>@2x，326ppi（iPhone4、4s、5、5s、6，6s，7）<br>@3x，401ppi（iPhone6+、6s+、7+）  </p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-7a8ad495c476db65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>px 即 pixels 像素，1px 代表屏幕上一个物理的像素点。</p><p>iPhone5 像素640px x 1136px<br>iPhone6 像素750px x 1334px<br>iPhone6 Plus 像素1242px x 2208px  </p><p>而 Weex 的开发中，目前都是用的 px，而且 <strong>Weex 对于长度值目前只支持像素 px 值，还不支持相对单位（em、rem）</strong>。</p><p>那么就需要 pt 和 px 的换算了。</p><p>在 Weex 的世界里，定义了一个默认屏幕尺寸，用来适配 iOS，Android 各种不同大小的屏幕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// The default screen width which helps us to calculate the real size or scale in different devices.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> CGFloat WXDefaultScreenWidth = <span class="number">750.0</span>;</span><br></pre></td></tr></table></figure><p>在 Weex 中定义的默认的屏幕宽度是750，注意是宽度。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)defaultPixelScaleFactor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">CGFloat</span> defaultScaleFactor;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        defaultScaleFactor = [<span class="keyword">self</span> portraitScreenSize].width / WXDefaultScreenWidth;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> defaultScaleFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里计算了一个默认的缩放比例因子，portraitScreenSize 里面计算出了屏幕在 portrait 方向下的大小，即如果方向是 landscape，那么缩放比例因子应该等于 WXScreenSize().height / WXDefaultScreenWidth，反之应该等于 WXScreenSize().width / WXDefaultScreenWidth。</p><p>这里计算的是 pt。</p><p>iPhone 4、4s、5、5s、5c、SE的比例因子是 0.42666667<br>iPhone 6、6s、7比例因子是0.5<br>iPhone 6+、6s+、7+比例因子是0.552  </p><h3 id="（2）计算视图的缩放尺寸"><a href="#（2）计算视图的缩放尺寸" class="headerlink" title="（2）计算视图的缩放尺寸"></a>（2）计算视图的缩放尺寸</h3><p>计算视图的缩放尺寸主要在这个方法里面被计算。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_calculateFrameWithSuperAbsolutePosition:(<span class="built_in">CGPoint</span>)superAbsolutePosition</span><br><span class="line">                           gatherDirtyComponents:(<span class="built_in">NSMutableSet</span>&lt;WXComponent *&gt; *)dirtyComponents</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_cssNode-&gt;layout.should_update) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _cssNode-&gt;layout.should_update = <span class="literal">false</span>;</span><br><span class="line">    _isLayoutDirty = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算视图的Frame</span></span><br><span class="line">    <span class="built_in">CGRect</span> newFrame = <span class="built_in">CGRectMake</span>(WXRoundPixelValue(_cssNode-&gt;layout.position[CSS_LEFT]),</span><br><span class="line">                                 WXRoundPixelValue(_cssNode-&gt;layout.position[CSS_TOP]),</span><br><span class="line">                                 WXRoundPixelValue(_cssNode-&gt;layout.dimensions[CSS_WIDTH]),</span><br><span class="line">                                 WXRoundPixelValue(_cssNode-&gt;layout.dimensions[CSS_HEIGHT]));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> isFrameChanged = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">// 比较newFrame和_calculatedFrame，第一次_calculatedFrame为CGRectZero</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectEqualToRect</span>(newFrame, _calculatedFrame)) &#123;</span><br><span class="line">        isFrameChanged = <span class="literal">YES</span>;</span><br><span class="line">        _calculatedFrame = newFrame;</span><br><span class="line">        [dirtyComponents addObject:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> newAbsolutePosition = [<span class="keyword">self</span> computeNewAbsolutePosition:superAbsolutePosition];</span><br><span class="line">    </span><br><span class="line">    _cssNode-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">    _cssNode-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line">    _cssNode-&gt;layout.position[CSS_LEFT] = <span class="number">0</span>;</span><br><span class="line">    _cssNode-&gt;layout.position[CSS_TOP] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _frameDidCalculated:isFrameChanged];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (WXComponent *subcomponent <span class="keyword">in</span> _subcomponents) &#123;</span><br><span class="line">        [subcomponent _calculateFrameWithSuperAbsolutePosition:newAbsolutePosition gatherDirtyComponents:dirtyComponents];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newFrame 就是计算出来的缩放过的 Frame。</p><p>如果尝试自己手动计算 Vue.js 上设置的 px 与实际的视图坐标值相比，你会发现永远都差一点，虽然偏差不多，但是总有误差，原因在哪里呢？就在 WXRoundPixelValue 这个函数里面。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> WXRoundPixelValue(<span class="built_in">CGFloat</span> value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> scale = WXScreenScale();</span><br><span class="line">    <span class="keyword">return</span> round(value * scale) / scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WXRoundPixelValue 这个函数里面进行了一次四舍五入的计算，这里会对精度有所损失，所以就会导致最终 Native 的组件的坐标会偏差一点。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">    .pic&#123;</span><br><span class="line">        width: <span class="number">200</span>px;</span><br><span class="line">        height: <span class="number">200</span>px;</span><br><span class="line">        margin-top: <span class="number">100</span>px;</span><br><span class="line">        left: <span class="number">200</span>px;</span><br><span class="line">        background-color: #a88859;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure><p>这里是一个 imageComponent，坐标是距离上边距 100px，距离左边距 200px，宽 200px，高 200px。</p><p>假设我们是在 iPhone 7+ 的屏幕上，ppi 对应的应该是 scale = 3（即@3x）。</p><p>按照 Weex 的上述的计算方法算，那么对应缩放的 px 为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = <span class="number">200</span> * ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">110.400000</span></span><br><span class="line">y = <span class="number">100</span> * ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">55.200000</span></span><br><span class="line">width = <span class="number">200</span> * ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">110.400000</span></span><br><span class="line">height = <span class="number">200</span> * ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">110.400000</span></span><br></pre></td></tr></table></figure><p>再转换成 pt：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = round ( <span class="number">110.400000</span> * <span class="number">3</span> ) / <span class="number">3</span> = <span class="number">110.333333</span></span><br><span class="line">y = round ( <span class="number">55.200000</span> * <span class="number">3</span> ) / <span class="number">3</span> = <span class="number">55.333333</span></span><br><span class="line">width = round ( <span class="number">110.400000</span> * <span class="number">3</span> ) / <span class="number">3</span> = <span class="number">110.333333</span></span><br><span class="line">height = round ( <span class="number">110.400000</span> * <span class="number">3</span> ) / <span class="number">3</span> = <span class="number">110.333333</span></span><br></pre></td></tr></table></figure><p>如果只是单纯的认为是针对 750 的成比缩放，那么这里 110.333333 / ( 414.0 / 750.0 ) = 199.87922101，你会发现这个数字距离 200 还是差了零点几。精度就是损失在了 round函数上了</p><p>那么当前的 imageComponent 在父视图里面的 Frame = （110.333333，55.333333，110.333333，110.333333）。</p><p>回到 onClick: 方法里面。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onClick:(__unused <span class="built_in">UITapGestureRecognizer</span> *)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *position = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = <span class="keyword">self</span>.weexInstance.pixelScaleFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.calculatedFrame, <span class="built_in">CGRectZero</span>)) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> frame = [<span class="keyword">self</span>.view.superview convertRect:<span class="keyword">self</span>.calculatedFrame toView:<span class="keyword">self</span>.view.window];</span><br><span class="line">        position[<span class="string">@"x"</span>] = @(frame.origin.x/scaleFactor);</span><br><span class="line">        position[<span class="string">@"y"</span>] = @(frame.origin.y/scaleFactor);</span><br><span class="line">        position[<span class="string">@"width"</span>] = @(frame.size.width/scaleFactor);</span><br><span class="line">        position[<span class="string">@"height"</span>] = @(frame.size.height/scaleFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> fireEvent:<span class="string">@"click"</span> params:@&#123;<span class="string">@"position"</span>:position&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果点击到视图，就会触发点击手势的处理方法，就会进入到上述方法里。</p><p>这里会计算出点击到的视图相对于 window 的绝对坐标。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">CGRect</span> frame = [<span class="keyword">self</span>.view.superview convertRect:<span class="keyword">self</span>.calculatedFrame toView:<span class="keyword">self</span>.view.window];</span><br></pre></td></tr></table></figure><p>上面这句话会进行一个坐标转换。坐标系转换到全局的 window 的左边。</p><p>还是按照上面举的例子，如果 imageComponent 经过转换以后，frame = （110.33333333333333, 119.33333333333334, 110.33333333333333, 110.33333333333331），这里就是 y 轴的距离发生了变化，因为就加上了 navigation + statusBar 的64的高度。</p><p>计算出了这个 window 绝对坐标之后，还要还原成相对于 750.0 宽度的“尺寸”。这里之所以打引号，就是因为这里有精度损失，在 round 函数那里丢了一些精度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">x = <span class="number">110.33333333333333</span> / ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">199.8792270531401</span></span><br><span class="line">y = <span class="number">119.33333333333334</span> / ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">216.1835748792271</span></span><br><span class="line">width = <span class="number">110.33333333333333</span> / ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">199.8792270531401</span></span><br><span class="line">height = <span class="number">110.33333333333333</span> / ( <span class="number">414.0</span> / <span class="number">750.0</span> ) = <span class="number">199.8792270531401</span></span><br></pre></td></tr></table></figure><p>上述就是点击以后经过转换最终得到的坐标，这个坐标会传递给 JS。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-9bf2beec8ba1fb3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="（二）轻扫事件"><a href="#（二）轻扫事件" class="headerlink" title="（二）轻扫事件"></a>（二）轻扫事件</h3><p>接着是轻扫事件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WX_ADD_EVENT(swipe, addSwipeEvent)</span><br></pre></td></tr></table></figure><p>这个宏和上面点击事件的展开原理一样，这里不再赘述。</p><p>如果 addEventName 传进来event的是@“swipe”，那么就是执行 addSwipeEvent 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addSwipeEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_swipeGestures) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _swipeGestures = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面的代码写的比较“奇怪”，原因在于UISwipeGestureRecognizer的direction属性，是一个可选的位掩码，但是每个手势识别器又只能处理一个方向的手势，所以就导致了下面需要生成四个UISwipeGestureRecognizer的手势识别器。</span></span><br><span class="line"></span><br><span class="line">    SEL selector = <span class="keyword">@selector</span>(onSwipe:);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个upSwipeRecognizer</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *upSwipeRecognizer = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                                                                                            action:selector];</span><br><span class="line">    upSwipeRecognizer.direction = <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>;</span><br><span class="line">    upSwipeRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [_swipeGestures addObject:upSwipeRecognizer];</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:upSwipeRecognizer];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个downSwipeRecognizer</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *downSwipeRecognizer = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                                                                                              action:selector];</span><br><span class="line">    downSwipeRecognizer.direction = <span class="built_in">UISwipeGestureRecognizerDirectionDown</span>;</span><br><span class="line">    downSwipeRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [_swipeGestures addObject:downSwipeRecognizer];</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:downSwipeRecognizer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建一个rightSwipeRecognizer</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *rightSwipeRecognizer = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                                                                                               action:selector];</span><br><span class="line">    rightSwipeRecognizer.direction = <span class="built_in">UISwipeGestureRecognizerDirectionRight</span>;</span><br><span class="line">    rightSwipeRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [_swipeGestures addObject:rightSwipeRecognizer];</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:rightSwipeRecognizer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建一个leftSwipeRecognizer</span></span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizer</span> *leftSwipeRecognizer = [[<span class="built_in">UISwipeGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span></span><br><span class="line">                                                                                              action:selector];</span><br><span class="line">    leftSwipeRecognizer.direction = <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>;</span><br><span class="line">    leftSwipeRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [_swipeGestures addObject:leftSwipeRecognizer];</span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:leftSwipeRecognizer];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面会新建4个方向上的手势识别器。因为每个手势识别器又只能处理一个方向的手势，所以就导致了需要生成四个 UISwipeGestureRecognizer 的手势识别器。</p><p>给当前的视图增加一个轻扫手势，触发的方法是 onSwipe: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onSwipe:(<span class="built_in">UISwipeGestureRecognizer</span> *)gesture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UISwipeGestureRecognizerDirection</span> direction = gesture.direction;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *directionString;</span><br><span class="line">    <span class="keyword">switch</span>(direction) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>:</span><br><span class="line">            directionString = <span class="string">@"left"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UISwipeGestureRecognizerDirectionRight</span>:</span><br><span class="line">            directionString = <span class="string">@"right"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UISwipeGestureRecognizerDirectionUp</span>:</span><br><span class="line">            directionString = <span class="string">@"up"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">UISwipeGestureRecognizerDirectionDown</span>:</span><br><span class="line">            directionString = <span class="string">@"down"</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            directionString = <span class="string">@"unknown"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGPoint</span> screenLocation = [gesture locationInView:<span class="keyword">self</span>.view.window];</span><br><span class="line">    <span class="built_in">CGPoint</span> pageLoacation = [gesture locationInView:<span class="keyword">self</span>.weexInstance.rootView];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *resultTouch = [<span class="keyword">self</span> touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier];</span><br><span class="line">    [<span class="keyword">self</span> fireEvent:<span class="string">@"swipe"</span> params:@&#123;<span class="string">@"direction"</span>:directionString, <span class="string">@"changedTouches"</span>:resultTouch ? @[resultTouch] : @[]&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户轻扫以后，会触发轻扫手势，于是会在 window 上和 rootView 上会获取到2个坐标。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)touchResultWithScreenLocation:(<span class="built_in">CGPoint</span>)screenLocation pageLocation:(<span class="built_in">CGPoint</span>)pageLocation identifier:(<span class="built_in">NSNumber</span> *)identifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *resultTouch = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">5</span>];</span><br><span class="line">    <span class="built_in">CGFloat</span> scaleFactor = <span class="keyword">self</span>.weexInstance.pixelScaleFactor;</span><br><span class="line">    resultTouch[<span class="string">@"screenX"</span>] = @(screenLocation.x/scaleFactor);</span><br><span class="line">    resultTouch[<span class="string">@"screenY"</span>] = @(screenLocation.y/scaleFactor);</span><br><span class="line">    resultTouch[<span class="string">@"pageX"</span>] = @(pageLocation.x/scaleFactor);</span><br><span class="line">    resultTouch[<span class="string">@"pageY"</span>] = @(pageLocation.y/scaleFactor);</span><br><span class="line">    resultTouch[<span class="string">@"identifier"</span>] = identifier;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultTouch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>screenLocation 和 pageLocation 两个坐标点，还是会根据缩放比例还原成相对于750宽度的页面的坐标。screenLocation 的 X 值和 Y 值、pageLocation 的 X 值和 Y 值分别封装到 resultTouch 字典里。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIGestureRecognizer</span> (<span class="title">WXGesture</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSNumber</span> *)wx_identifier</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSNumber</span> *identifier = objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">    <span class="keyword">if</span> (!identifier) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">NSUInteger</span> _gestureIdentifier;</span><br><span class="line">        identifier = @(_gestureIdentifier++);</span><br><span class="line">        <span class="keyword">self</span>.wx_identifier = identifier;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> identifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWx_identifier:(<span class="built_in">NSNumber</span> *)wx_identifier</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(wx_identifier), wx_identifier, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>最后 resultTouch 里面还包含一个 identifier 的参数，这个 identifier 是一个全局唯一的 NSUInteger。wx_identifier 被关联到了各个手势识别器上了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-d539c86914cdc7ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="（三）长按事件"><a href="#（三）长按事件" class="headerlink" title="（三）长按事件"></a>（三）长按事件</h3><p>接着是轻扫事件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WX_ADD_EVENT(longpress, addLongPressEvent)</span><br></pre></td></tr></table></figure><p>这个宏和上面点击事件的展开原理一样，这里不再赘述。</p><p>如果 addEventName 传进来 event 的是 @“longpress”，那么就是执行 addLongPressEvent 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addLongPressEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_longPressGesture) &#123;</span><br><span class="line">        _longPressGesture = [[<span class="built_in">UILongPressGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(onLongPress:)];</span><br><span class="line">        _longPressGesture.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.view addGestureRecognizer:_longPressGesture];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给当前的视图增加一个长按手势，触发的方法是 onLongPress: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onLongPress:(<span class="built_in">UILongPressGestureRecognizer</span> *)gesture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateBegan</span>) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> screenLocation = [gesture locationInView:<span class="keyword">self</span>.view.window];</span><br><span class="line">        <span class="built_in">CGPoint</span> pageLoacation = [gesture locationInView:<span class="keyword">self</span>.weexInstance.rootView];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultTouch = [<span class="keyword">self</span> touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier];</span><br><span class="line">        [<span class="keyword">self</span> fireEvent:<span class="string">@"longpress"</span> params:@&#123;<span class="string">@"changedTouches"</span>:resultTouch ? @[resultTouch] : @[]&#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gesture.state == <span class="built_in">UIGestureRecognizerStateEnded</span>) &#123;</span><br><span class="line">        gesture.wx_identifier = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长按手势传给 JS 的参数和轻扫的参数 changedTouches 几乎一致。在长按手势开始的时候就传递给 JS 两个 Point，screenLocation 和 pageLoacation，以及手势的wx_identifier。这部分和轻扫手势基本一样，不多赘述。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-f55d817e6397b58d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="（四）拖动事件"><a href="#（四）拖动事件" class="headerlink" title="（四）拖动事件"></a>（四）拖动事件</h3><p>拖动事件在 Weex 里面包含5个事件。分别对应着拖动的5种状态：拖动开始，拖动中，拖动结束，水平拖动，竖直拖动。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WX_ADD_EVENT(panstart, addPanStartEvent)</span><br><span class="line">WX_ADD_EVENT(panmove, addPanMoveEvent)</span><br><span class="line">WX_ADD_EVENT(panend, addPanEndEvent)</span><br><span class="line">WX_ADD_EVENT(horizontalpan, addHorizontalPanEvent)</span><br><span class="line">WX_ADD_EVENT(verticalpan, addVerticalPanEvent)</span><br></pre></td></tr></table></figure><p>为了区分上面5种状态，Weex 还对每个状态增加了一个 BOOL 变量来判断当前的状态。分别如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> _listenPanStart;</span><br><span class="line"><span class="built_in">BOOL</span> _listenPanMove;</span><br><span class="line"><span class="built_in">BOOL</span> _listenPanEnd;</span><br><span class="line"><span class="built_in">BOOL</span> _listenHorizontalPan;</span><br><span class="line"><span class="built_in">BOOL</span> _listenVerticalPan;</span><br></pre></td></tr></table></figure><p>通过宏增加的5个事件，实质都是执行了 addPanGesture 方法，只不过每个状态的事件都会跟对应的BOOL变量。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPanStartEvent</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 拖动开始</span></span><br><span class="line">    _listenPanStart = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addPanGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPanMoveEvent</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 拖动中</span></span><br><span class="line">    _listenPanMove = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addPanGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPanEndEvent</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 拖动结束</span></span><br><span class="line">    _listenPanEnd = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addPanGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addHorizontalPanEvent</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 水平拖动</span></span><br><span class="line">    _listenHorizontalPan = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addPanGesture];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addVerticalPanEvent</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 竖直拖动</span></span><br><span class="line">    _listenVerticalPan = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> addPanGesture];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终都是调用addPanGesture方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addPanGesture</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_panGesture) &#123;</span><br><span class="line">        _panGesture = [[<span class="built_in">UIPanGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(onPan:)];</span><br><span class="line">        _panGesture.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">self</span>.view addGestureRecognizer:_panGesture];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给当前的视图增加一个拖动手势，触发的方法是 onPan: 方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)onPan:(UIPanGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">    CGPoint screenLocation = [gesture locationInView:self.view.window];</span><br><span class="line">    CGPoint pageLoacation = [gesture locationInView:self.weexInstance.rootView];</span><br><span class="line">    NSString *eventName;</span><br><span class="line">    NSString *state = @&quot;&quot;;</span><br><span class="line">    NSDictionary *resultTouch = [self touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier];</span><br><span class="line">    </span><br><span class="line">    if (gesture.state == UIGestureRecognizerStateBegan) &#123;</span><br><span class="line">        if (_listenPanStart) &#123;</span><br><span class="line">            eventName = @&quot;panstart&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        state = @&quot;start&quot;;</span><br><span class="line">    &#125; else if (gesture.state == UIGestureRecognizerStateEnded) &#123;</span><br><span class="line">        if (_listenPanEnd) &#123;</span><br><span class="line">            eventName = @&quot;panend&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        state = @&quot;end&quot;;</span><br><span class="line">        gesture.wx_identifier = nil;</span><br><span class="line">    &#125; else if (gesture.state == UIGestureRecognizerStateChanged) &#123;</span><br><span class="line">        if (_listenPanMove) &#123;</span><br><span class="line">             eventName = @&quot;panmove&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        state = @&quot;move&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    CGPoint translation = [_panGesture translationInView:self.view];</span><br><span class="line">    </span><br><span class="line">    if (_listenHorizontalPan &amp;&amp; fabs(translation.y) &lt;= fabs(translation.x)) &#123;</span><br><span class="line">        [self fireEvent:@&quot;horizontalpan&quot; params:@&#123;@&quot;state&quot;:state, @&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    if (_listenVerticalPan &amp;&amp; fabs(translation.y) &gt; fabs(translation.x)) &#123;</span><br><span class="line">        [self fireEvent:@&quot;verticalpan&quot; params:@&#123;@&quot;state&quot;:state, @&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    if (eventName) &#123;</span><br><span class="line">        [self fireEvent:eventName params:@&#123;@&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拖动事件最终传给 JS 的 resultTouch 字典和前两个手势的原理一样，也是需要传入两个 Point，screenLocation 和 pageLoacation，这里不再赘述。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-7045d54290886db8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据 _listenPanStart，_listenPanEnd，_listenPanMove 判断当前的状态，并生成与之对应的 eventName 和 state 字符串。</p><p>根据 _panGesture 在当前视图上拖动形成的有方向的向量，进行判断当前拖动的方向。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-f5bc628a35e0623e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="（五）通用触摸事件"><a href="#（五）通用触摸事件" class="headerlink" title="（五）通用触摸事件"></a>（五）通用触摸事件</h3><p>最后就是通用的触摸事件。</p><p>Weex 里面对每个 Component 都新建了一个手势识别器。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXTouchGestureRecognizer</span> : <span class="title">UIGestureRecognizer</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> listenTouchStart;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> listenTouchMove;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> listenTouchEnd;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> listenTouchCancel;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> listenPseudoTouch;</span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">weak</span> WXComponent *_component;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _touchIdentifier;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithComponent:(WXComponent *)component <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>WXTouchGestureRecognizer 是继承自 UIGestureRecognizer。里面就5个 BOOL。分别表示5种状态。</p><p>WXTouchGestureRecognizer 会弱引用当前的 WXComponent，并且也依旧有touchIdentifier。</p><p>Weex 通过以下4个宏注册触摸事件方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">WX_ADD_EVENT(touchstart, addTouchStartEvent)</span><br><span class="line">WX_ADD_EVENT(touchmove, addTouchMoveEvent)</span><br><span class="line">WX_ADD_EVENT(touchend, addTouchEndEvent)</span><br><span class="line">WX_ADD_EVENT(touchcancel, addTouchCancelEvent)</span><br></pre></td></tr></table></figure><p>通过上述宏增加的4个事件，实质都是改变每个状态的事件都会跟对应的BOOL变量。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addTouchStartEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.touchGesture.listenTouchStart = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addTouchMoveEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.touchGesture.listenTouchMove = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addTouchEndEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.touchGesture.listenTouchEnd = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addTouchCancelEvent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.touchGesture.listenTouchCancel = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户开始触摸屏幕，在屏幕上移动，手指从屏幕上结束触摸，取消触摸，分别都会触发touchesBegan:，touchesMoved:，touchesEnded:，touchesCancelled:方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_listenTouchStart) &#123;</span><br><span class="line">        [<span class="keyword">self</span> fireTouchEvent:<span class="string">@"touchstart"</span> withTouches:touches];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_listenPseudoTouch) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *styles = [_component getPseudoClassStyles:<span class="string">@"active"</span>];</span><br><span class="line">        [_component updatePseudoClassStyles:styles];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_listenTouchMove) &#123;</span><br><span class="line">        [<span class="keyword">self</span> fireTouchEvent:<span class="string">@"touchmove"</span> withTouches:touches];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_listenTouchEnd) &#123;</span><br><span class="line">        [<span class="keyword">self</span> fireTouchEvent:<span class="string">@"touchend"</span> withTouches:touches];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_listenPseudoTouch) &#123;</span><br><span class="line">        [<span class="keyword">self</span> recoveryPseudoStyles:_component.styles];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesCancelled:touches withEvent:event];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_listenTouchCancel) &#123;</span><br><span class="line">        [<span class="keyword">self</span> fireTouchEvent:<span class="string">@"touchcancel"</span> withTouches:touches];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_listenPseudoTouch) &#123;</span><br><span class="line">        [<span class="keyword">self</span> recoveryPseudoStyles:_component.styles];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的4个事件里面实质都是在调用 fireTouchEvent:withTouches: 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireTouchEvent:(<span class="built_in">NSString</span> *)eventName withTouches:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *resultTouches = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UITouch</span> *touch <span class="keyword">in</span> touches) &#123;</span><br><span class="line">        <span class="built_in">CGPoint</span> screenLocation = [touch locationInView:touch.window];</span><br><span class="line">        <span class="built_in">CGPoint</span> pageLocation = [touch locationInView:_component.weexInstance.rootView];</span><br><span class="line">        <span class="keyword">if</span> (!touch.wx_identifier) &#123;</span><br><span class="line">            touch.wx_identifier = @(_touchIdentifier++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *resultTouch = [_component touchResultWithScreenLocation:screenLocation pageLocation:pageLocation identifier:touch.wx_identifier];</span><br><span class="line">        [resultTouches addObject:resultTouch];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [_component fireEvent:eventName params:@&#123;<span class="string">@"changedTouches"</span>:resultTouches ?: @[]&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终这个方法和前3个手势一样，都需要给 resultTouches 传入2个Point和1个wx_identifier。原理一致。</p><p>至于坐标如何传递给JS见第二章。</p><h3 id="2-Appear-事件"><a href="#2-Appear-事件" class="headerlink" title="2. Appear 事件"></a>2. Appear 事件</h3><p>如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。</p><p>所以绑定了 Appear 事件的都是可以滚动的视图。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-54c227c43a2d3c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WX_ADD_EVENT(appear, addAppearEvent)</span><br></pre></td></tr></table></figure><p>通过上述的宏给可以滚动的视图增加 Appear 事件。也就是当前视图执行 addAppearEvent 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addAppearEvent</span><br><span class="line">&#123;</span><br><span class="line">    _appearEvent = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.ancestorScroller addScrollToListener:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Weex 的每个组件里面都有2个 BOOL 记录着当前 _appearEvent 和 _disappearEvent 的状态。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> _appearEvent;</span><br><span class="line"><span class="built_in">BOOL</span> _disappearEvent;</span><br></pre></td></tr></table></figure><p>当增加对应的事件的时候，就会把对应的 BOOL 变成 YES。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;WXScrollerProtocol&gt;)ancestorScroller</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_ancestorScroller) &#123;</span><br><span class="line">        WXComponent *supercomponent = <span class="keyword">self</span>.supercomponent;</span><br><span class="line">        <span class="keyword">while</span> (supercomponent) &#123;</span><br><span class="line">            <span class="keyword">if</span>([supercomponent conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">WXScrollerProtocol</span>)]) </span>&#123;</span><br><span class="line">                _ancestorScroller = (<span class="keyword">id</span>&lt;WXScrollerProtocol&gt;)supercomponent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            supercomponent = supercomponent.supercomponent;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _ancestorScroller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Appear 事件和 Disappear 事件都必须要求是滚动视图，所以这里会遍历当前视图的 supercomponent，直到找到一个遵循 WXScrollerProtocol 的 supercomponent。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addScrollToListener:(WXComponent *)target</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> has = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (WXScrollToTarget *targetData <span class="keyword">in</span> <span class="keyword">self</span>.listenerArray) &#123;</span><br><span class="line">        <span class="keyword">if</span> (targetData.target == target) &#123;</span><br><span class="line">            has = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">        WXScrollToTarget *scrollTarget = [[WXScrollToTarget alloc] init];</span><br><span class="line">        scrollTarget.target = target;</span><br><span class="line">        scrollTarget.hasAppear = <span class="literal">NO</span>;</span><br><span class="line">        [<span class="keyword">self</span>.listenerArray addObject:scrollTarget];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在滚动视图里面包含有一个 listenerArray，数组里面装的都是被监听的对象。添加进这个数组会先判断当前是否有相同的 WXScrollToTarget，避免重复添加，如果没有重复的就新建一个 WXScrollToTarget，再添加进 listenerArray中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXScrollToTarget</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>)   WXComponent *target;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasAppear;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>WXScrollToTarget 是一个普通的对象，里面弱引用了当前需要监听的 WXComponent，以及一个 BOOL 变量记录当前是否 Appear 了。</p><p>当滚动视图滚动的时候，就会触发 scrollViewDidScroll: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//apply block which are registered</span></span><br><span class="line">    WXSDKInstance *instance = <span class="keyword">self</span>.weexInstance;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.ref isEqualToString:WX_SDK_ROOT_REF] &amp;&amp;</span><br><span class="line">        [<span class="keyword">self</span> isKindOfClass:[WXScrollerComponent <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance.onScroll) &#123;</span><br><span class="line">            instance.onScroll(scrollView.contentOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_lastContentOffset.x &gt; scrollView.contentOffset.x) &#123;</span><br><span class="line">        _direction = <span class="string">@"right"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lastContentOffset.x &lt; scrollView.contentOffset.x) &#123;</span><br><span class="line">        _direction = <span class="string">@"left"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(_lastContentOffset.y &gt; scrollView.contentOffset.y) &#123;</span><br><span class="line">        _direction = <span class="string">@"down"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(_lastContentOffset.y &lt; scrollView.contentOffset.y) &#123;</span><br><span class="line">        _direction = <span class="string">@"up"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _lastContentOffset = scrollView.contentOffset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// check sticky</span></span><br><span class="line">    [<span class="keyword">self</span> adjustSticky];</span><br><span class="line">    [<span class="keyword">self</span> handleLoadMore];</span><br><span class="line">    [<span class="keyword">self</span> handleAppear];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.onScroll) &#123;</span><br><span class="line">        <span class="keyword">self</span>.onScroll(scrollView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的方法中[self handleAppear]就是触发了判断是否 Appear 了。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)handleAppear</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isViewLoaded]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">UIScrollView</span> *scrollView = (<span class="built_in">UIScrollView</span> *)<span class="keyword">self</span>.view;</span><br><span class="line">    <span class="built_in">CGFloat</span> vx = scrollView.contentInset.left + scrollView.contentOffset.x;</span><br><span class="line">    <span class="built_in">CGFloat</span> vy = scrollView.contentInset.top + scrollView.contentOffset.y;</span><br><span class="line">    <span class="built_in">CGFloat</span> vw = scrollView.frame.size.width - scrollView.contentInset.left - scrollView.contentInset.right;</span><br><span class="line">    <span class="built_in">CGFloat</span> vh = scrollView.frame.size.height - scrollView.contentInset.top - scrollView.contentInset.bottom;</span><br><span class="line">    <span class="built_in">CGRect</span> scrollRect = <span class="built_in">CGRectMake</span>(vx, vy, vw, vh);;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// notify action for appear</span></span><br><span class="line">    <span class="keyword">for</span>(WXScrollToTarget *target <span class="keyword">in</span> <span class="keyword">self</span>.listenerArray)&#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollToTarget:target scrollRect:scrollRect];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法会把 listenerArray 数组里面的每个 WXScrollToTarget 对象都调用 scrollToTarget:scrollRect: 方法。根据当前滚动的情况传入一个 CGRect，这个 CGRect 就是当前滚动到那个矩形区域的坐标信息以及宽和高。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollToTarget:(WXScrollToTarget *)target scrollRect:(<span class="built_in">CGRect</span>)rect</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *component = target.target;</span><br><span class="line">    <span class="keyword">if</span> (![component isViewLoaded]) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算出当前的可见区域的顶部坐标</span></span><br><span class="line">    <span class="built_in">CGFloat</span> ctop;</span><br><span class="line">    <span class="keyword">if</span> (component &amp;&amp; component-&gt;_view &amp;&amp; component-&gt;_view.superview) &#123;</span><br><span class="line">        ctop = [component-&gt;_view.superview convertPoint:component-&gt;_view.frame.origin toView:_view].y;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ctop = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算出当前的可见区域的底部坐标</span></span><br><span class="line">    <span class="built_in">CGFloat</span> cbottom = ctop + <span class="built_in">CGRectGetHeight</span>(component.calculatedFrame);</span><br><span class="line">    <span class="comment">// 计算出当前的可见区域的左边界坐标</span></span><br><span class="line">    <span class="built_in">CGFloat</span> cleft;</span><br><span class="line">    <span class="keyword">if</span> (component &amp;&amp; component-&gt;_view &amp;&amp; component-&gt;_view.superview) &#123;</span><br><span class="line">        cleft = [component-&gt;_view.superview convertPoint:component-&gt;_view.frame.origin toView:_view].x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cleft = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算出当前的可见区域的右边界坐标</span></span><br><span class="line">    <span class="built_in">CGFloat</span> cright = cleft + <span class="built_in">CGRectGetWidth</span>(component.calculatedFrame);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取传入的滚动的区域</span></span><br><span class="line">    <span class="built_in">CGFloat</span> vtop = <span class="built_in">CGRectGetMinY</span>(rect), vbottom = <span class="built_in">CGRectGetMaxY</span>(rect), vleft = <span class="built_in">CGRectGetMinX</span>(rect), vright = <span class="built_in">CGRectGetMaxX</span>(rect);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断当前可见区域是否包含在传入的滚动区域内，如果在，并且监听了appear事件，就触发appear事件，否则如果监听了disappear事件就触发disappear事件</span></span><br><span class="line">    <span class="keyword">if</span>(cbottom &gt; vtop &amp;&amp; ctop &lt;= vbottom &amp;&amp; cleft &lt;= vright &amp;&amp; cright &gt; vleft)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!target.hasAppear &amp;&amp; component)&#123;</span><br><span class="line">            target.hasAppear = <span class="literal">YES</span>;</span><br><span class="line">            <span class="comment">// 如果当前监听了appear，就触发appear事件</span></span><br><span class="line">            <span class="keyword">if</span> (component-&gt;_appearEvent) &#123;</span><br><span class="line">                [component fireEvent:<span class="string">@"appear"</span> params:_direction ? @&#123;<span class="string">@"direction"</span>:_direction&#125; : <span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(target.hasAppear &amp;&amp; component)&#123;</span><br><span class="line">            target.hasAppear = <span class="literal">NO</span>;</span><br><span class="line">            <span class="comment">// 如果当前监听了disappear，就触发disappear事件</span></span><br><span class="line">            <span class="keyword">if</span>(component-&gt;_disappearEvent)&#123;</span><br><span class="line">                [component fireEvent:<span class="string">@"disappear"</span> params:_direction ? @&#123;<span class="string">@"direction"</span>:_direction&#125; : <span class="literal">nil</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1194012-4ce6ab0c48383c8b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>scrollToTarget:scrollRect: 方法的核心就是拿当前可视区域和传入的滚动区域进行对比，如果在该区域内，且监听了 appear 事件，就会触发 appear 事件，如果不在该区域内，且监听了 disappear 事件，就会触发 disappear 事件。</p><h3 id="3-Disappear-事件"><a href="#3-Disappear-事件" class="headerlink" title="3. Disappear 事件"></a>3. Disappear 事件</h3><p>如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。</p><p>同理，绑定了 Disappear 事件的都是可以滚动的视图。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-18f16117ad60e038.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">WX_ADD_EVENT(disappear, addDisappearEvent)</span><br></pre></td></tr></table></figure><p>通过上述的宏给可以滚动的视图增加 Disappear 事件。也就是当前视图执行 addDisappearEvent 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addDisappearEvent</span><br><span class="line">&#123;</span><br><span class="line">    _disappearEvent = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span>.ancestorScroller addScrollToListener:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下去的和 Appear 事件的原理就一模一样了。</p><h3 id="4-Page-事件"><a href="#4-Page-事件" class="headerlink" title="4. Page 事件"></a>4. Page 事件</h3><p><strong>暂时 Weex 只支持 iOS 和 Android，H5 暂不支持。</strong></p><p>Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。</p><p>viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。</p><p>与组件 Component的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。</p><p>特殊情况下，这两个事件也能被绑定到非根元素的 body 组件上，例如 wxc-navpage 组件。</p><p>举个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_updateInstanceState:(WXState)state</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_instance &amp;&amp; _instance.state != state) &#123;</span><br><span class="line">        _instance.state = state;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (state == WeexInstanceAppear) &#123;</span><br><span class="line">            [[WXSDKManager bridgeMgr] fireEvent:_instance.instanceId ref:WX_SDK_ROOT_REF type:<span class="string">@"viewappear"</span> params:<span class="literal">nil</span> domChanges:<span class="literal">nil</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == WeexInstanceDisappear) &#123;</span><br><span class="line">            [[WXSDKManager bridgeMgr] fireEvent:_instance.instanceId ref:WX_SDK_ROOT_REF type:<span class="string">@"viewdisappear"</span> params:<span class="literal">nil</span> domChanges:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如在 WXBaseViewController 里面，有这样一个更新当前 Instance 状态的方法，这个方法里面就会触发 viewappear 和 viewdisappear 事件。</p><p>其中 WX_SDK_ROOT_REF 就是 _root</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#define WX_SDK_ROOT_REF     @<span class="meta-string">"_root"</span></span></span><br></pre></td></tr></table></figure><p>上述更新状态的方法同样出现在 WXEmbedComponent 组件中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_updateState:(WXState)state</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_renderFinished &amp;&amp; _embedInstance &amp;&amp; _embedInstance.state != state) &#123;</span><br><span class="line">        _embedInstance.state = state;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (state == WeexInstanceAppear) &#123;</span><br><span class="line">            [<span class="keyword">self</span> setNavigationWithStyles:<span class="keyword">self</span>.embedInstance.naviBarStyles];</span><br><span class="line">            [[WXSDKManager bridgeMgr] fireEvent:<span class="keyword">self</span>.embedInstance.instanceId ref:WX_SDK_ROOT_REF type:<span class="string">@"viewappear"</span> params:<span class="literal">nil</span> domChanges:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == WeexInstanceDisappear) &#123;</span><br><span class="line">            [[WXSDKManager bridgeMgr] fireEvent:<span class="keyword">self</span>.embedInstance.instanceId ref:WX_SDK_ROOT_REF type:<span class="string">@"viewdisappear"</span> params:<span class="literal">nil</span> domChanges:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二-Weex-的事件传递"><a href="#二-Weex-的事件传递" class="headerlink" title="二.Weex 的事件传递"></a>二.Weex 的事件传递</h2><p>在 Weex 中，iOS Native 把事件传递给 JS 目前只有2种方式，一是 Module 模块的 callback，二是通过 Component 组件自定义的通知事件。</p><h3 id="（1）callback"><a href="#（1）callback" class="headerlink" title="（1）callback"></a>（1）callback</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-489fe952c028acc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在 WXModuleProtocol 中定义了2种可以 callback 给 JS 的闭包。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @abstract the module callback , result can be string or dictionary.</span></span><br><span class="line"><span class="comment"> * @discussion callback data to js, the id of callback function will be removed to save memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^WXModuleCallback)(<span class="keyword">id</span> result);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @abstract the module callback , result can be string or dictionary.</span></span><br><span class="line"><span class="comment"> * @discussion callback data to js, you can specify the keepAlive parameter to keep callback function id keepalive or not. If the keepAlive is true, it won't be removed until instance destroyed, so you can call it repetitious.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^WXModuleKeepAliveCallback)(<span class="keyword">id</span> result, <span class="built_in">BOOL</span> keepAlive);</span><br></pre></td></tr></table></figure><p>两个闭包都可以 callback 把 data 传递回给 JS，data 可以是字符串或者字典。</p><p>这两个闭包的区别在于：</p><ol><li>WXModuleCallback 用于 Module 组件，为了节约内存，该回调只能回调通知 JS 一次，之后会被释放，多用于一次结果。</li><li>WXModuleKeepAliveCallback 同样是用于 Module 组件，但是该回调可以设置是否为多次回调类型，如果设置了 keepAlive，那么可以进行持续监听变化，多次回调，并返回给 JS。</li></ol><p>在 Weex 中使用 WXModuleCallback 回调，很多情况是把状态回调给 JS，比如成功或者失败的状态，还有一些出错的信息回调给 JS。</p><p>比如在 WXStorageModule 中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setItem:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSString</span> *)value callback:(WXModuleCallback)callback</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> checkInput:key]) &#123;</span><br><span class="line">        callback(@&#123;<span class="string">@"result"</span>:<span class="string">@"failed"</span>,<span class="string">@"data"</span>:<span class="string">@"key must a string or number!"</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> checkInput:value]) &#123;</span><br><span class="line">        callback(@&#123;<span class="string">@"result"</span>:<span class="string">@"failed"</span>,<span class="string">@"data"</span>:<span class="string">@"value must a string or number!"</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([key isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        key = [((<span class="built_in">NSNumber</span> *)key) stringValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        value = [((<span class="built_in">NSNumber</span> *)value) stringValue];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([WXUtility isBlankString:key]) &#123;</span><br><span class="line">        callback(@&#123;<span class="string">@"result"</span>:<span class="string">@"failed"</span>,<span class="string">@"data"</span>:<span class="string">@"invalid_param"</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> setObject:value forKey:key persistent:<span class="literal">NO</span> callback:callback];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 setItem:value:callback: 方法里面，如果 setKey-value 的时候失败了，会把错误信息通过 WXModuleCallback 回调给JS。</p><p>当然，如果调用存储模块 WXStorageModule 的某些查询信息的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)length:(WXModuleCallback)callback</span><br><span class="line">&#123;</span><br><span class="line">    callback(@&#123;<span class="string">@"result"</span>:<span class="string">@"success"</span>,<span class="string">@"data"</span>:@([[WXStorageModule memory] count])&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)getAllKeys:(WXModuleCallback)callback</span><br><span class="line">&#123;</span><br><span class="line">    callback(@&#123;<span class="string">@"result"</span>:<span class="string">@"success"</span>,<span class="string">@"data"</span>:[WXStorageModule memory].allKeys&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>length: 和 getAllKeys: 方法调用成功，会把成功的状态和数据通过 WXModuleCallback 回调给JS。</p><p>在 Weex 中使用了 WXModuleKeepAliveCallback 的模块总共只有以下4个：</p><p>WXDomModule，WXStreamModule，WXWebSocketModule，WXGlobalEventModule</p><p>在 WXDomModule 模块中，JS 调用获取 Component 组件的位置信息和宽高信息的时候，需要把这些坐标和尺寸信息回调给 JS，不过这里虽然用到了WXModuleKeepAliveCallback，但是 keepAlive 是 false，并没有用到多次回调的功能。</p><p>在 WXStreamModule 模块中，由于这是一个传输流的模块，所以肯定需要用到WXModuleKeepAliveCallback，需要持续不断的监听数据的变化，并把进度回调给 JS，这里用到了 keepAlive。WXStreamModule 模块中也会用到 WXModuleCallback，WXModuleCallback 会即时把各个状态回调给 JS。</p><p>在 WXWebSocketModule 模块中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXWebSocketModule</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)WXModuleKeepAliveCallback errorCallBack;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)WXModuleKeepAliveCallback messageCallBack;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)WXModuleKeepAliveCallback openCallBack;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>)WXModuleKeepAliveCallback closeCallBack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>用到了4个 WXModuleKeepAliveCallback 回调，这4个 callback 分别是把 error 错误信息，message 收到的数据，open 打开链接的状态，close 关闭链接的状态，持续的回调给 JS。</p><p>在 WXGlobalEventModule 模块中，有一个 fireGlobalEvent: 方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireGlobalEvent:(<span class="built_in">NSNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> * userInfo = notification.userInfo;</span><br><span class="line">    <span class="built_in">NSString</span> * userWeexInstanceId = userInfo[<span class="string">@"weexInstance"</span>];</span><br><span class="line"></span><br><span class="line">    WXSDKInstance * userWeexInstance = [WXSDKManager instanceForID:userWeexInstanceId];</span><br><span class="line">   <span class="comment">// 防止userInstanceId存在，但是instance实际已经被销毁了</span></span><br><span class="line">    <span class="keyword">if</span> (!userWeexInstanceId || userWeexInstance == weexInstance) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (WXModuleKeepAliveCallback callback <span class="keyword">in</span> _eventCallback[notification.name]) &#123;</span><br><span class="line">            callback(userInfo[<span class="string">@"param"</span>], <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发者可以通过 WXGlobalEventModule 进行全局的通知，在 userInfo 里面可以夹带 weexInstance 的参数。native 是不需要关心 userWeexInstanceId，这个参数是给 JS 用的。</p><p>Native 开发者只需要在用到了 WXGlobalEventModule 的模块里加上事件的监听者，然后发送全局通知即可。userInfo[@”param”]会被回调给 JS。</p><h3 id="（2）fireEvent-params-domChanges"><a href="#（2）fireEvent-params-domChanges" class="headerlink" title="（2）fireEvent:params:domChanges:"></a>（2）fireEvent:params:domChanges:</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-38a401738793eae9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在开头我们介绍的 Weex 事件的4种类型，通用事件，Appear 事件，Disappear 事件，Page 事件，全部都是通过 fireEvent:params:domChanges: 这种方式，Native 触发事件之后，Native 把参数传递给 JS 的。</p><p>在 WXComponent 里面定义了2个可以给 JS 发送消息的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @abstract Fire an event to the component in Javascript.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param eventName The name of the event to fire</span></span><br><span class="line"><span class="comment"> * @param params The parameters to fire with</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)params;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @abstract Fire an event to the component and tell Javascript which value has been changed. </span></span><br><span class="line"><span class="comment"> * Used for two-way data binding.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param eventName The name of the event to fire</span></span><br><span class="line"><span class="comment"> * @param params The parameters to fire with</span></span><br><span class="line"><span class="comment"> * @param domChanges The values has been changed, used for two-way data binding.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)params domChanges:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)domChanges;</span><br></pre></td></tr></table></figure><p>这两个方法的区别就在于最后一个 domChanges 的参数，有这个参数的方法主要多用于 Weex 的 Native 和 JS 的双向数据绑定。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> fireEvent:eventName params:params domChanges:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params domChanges:(<span class="built_in">NSDictionary</span> *)domChanges</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeSp = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>;</span><br><span class="line">    [dict setObject:@(timeSp) forKey:<span class="string">@"timestamp"</span>];</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">        [dict addEntriesFromDictionary:params];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[WXSDKManager bridgeMgr] fireEvent:<span class="keyword">self</span>.weexInstance.instanceId ref:<span class="keyword">self</span>.ref type:eventName params:dict domChanges:domChanges];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述就是两个方法的具体实现。可以看到 fireEvent:params: 方法就是调用了 fireEvent:params:domChanges: 方法，只不过最后的 domChanges 参数传了 nil。</p><p>在fireEvent:params:domChanges: 方法中会对 params 字典做了一次加工，加上了 timestamp 的键值。最终还是会调用 WXBridgeManager 里面的 fireEvent:ref: type:params:domChanges: 方法。</p><p>在 WXBridgeManager 中具体实现了上述的两个方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)instanceId ref:(<span class="built_in">NSString</span> *)ref type:(<span class="built_in">NSString</span> *)type params:(<span class="built_in">NSDictionary</span> *)params</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> fireEvent:instanceId ref:ref type:type params:params domChanges:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)instanceId ref:(<span class="built_in">NSString</span> *)ref type:(<span class="built_in">NSString</span> *)type params:(<span class="built_in">NSDictionary</span> *)params domChanges:(<span class="built_in">NSDictionary</span> *)domChanges</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!type || !ref) &#123;</span><br><span class="line">        WXLogError(<span class="string">@"Event type and component ref should not be nil"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *args = @[ref, type, params?:@&#123;&#125;, domChanges?:@&#123;&#125;];</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    WXCallJSMethod *method = [[WXCallJSMethod alloc] initWithModuleName:<span class="literal">nil</span> methodName:<span class="string">@"fireEvent"</span> arguments:args instance:instance];</span><br><span class="line">    [<span class="keyword">self</span> callJsMethod:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>入参 ref, type, params, domChanges 封装到最终的 args 参数数组里面，最后会封装出 WXCallJSMethod 方法，通过 WXBridgeManager 的 callJsMethod 调用到 JS 的 fireEvent 方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-c8282fcd911caaa2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这里可以举个例子：</p><p>假设一个场景，用户点击了一张图片，于是就会改变 label 上的一段文字。</p><p>首先图片是 imageComponent，用户点击会触发该 Component 的 onclick: 方法</p><p>组件里面会调用 fireEvent:params: 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="keyword">self</span> fireEvent:<span class="string">@"click"</span> params:@&#123;<span class="string">@"position"</span>:position&#125;];</span><br></pre></td></tr></table></figure><p>最终通过 fireEvent:params:domChanges: 方法，发送给 JS 的参数字典大概如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">args:(</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">        (</span><br><span class="line">                &#123;</span><br><span class="line">            args =             (</span><br><span class="line">                <span class="number">3</span>,</span><br><span class="line">                click,</span><br><span class="line">                                &#123;</span><br><span class="line">                    position =                     &#123;</span><br><span class="line">                        height = <span class="string">"199.8792270531401"</span>;</span><br><span class="line">                        width = <span class="string">"199.8792270531401"</span>;</span><br><span class="line">                        x = <span class="string">"274.7584541062802"</span>;</span><br><span class="line">                        y = <span class="string">"115.9420289855072"</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    timestamp = <span class="string">"1489932655404.133"</span>;</span><br><span class="line">                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">            method = fireEvent;</span><br><span class="line">            <span class="keyword">module</span> = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>JSFramework 收到了 fireEvent 方法调用以后，处理完，知道 label 需要更新，于是又会开始 call Native，调用 Native 的方法。调用 Native 的 callNative 方法，发过来的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">            <span class="number">4</span>,</span><br><span class="line">                        &#123;</span><br><span class="line">                value = <span class="string">"\U56fe\U7247\U88ab\U70b9\U51fb"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        method = updateAttrs;</span><br><span class="line">        <span class="keyword">module</span> = dom;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最终会调用 Dom 的 updateAttrs 方法，会去更新 id 为4的 value，id 为4对应的就是 label，更新它的值就是刷新 label。</p><p>接着 JSFramework 还会继续调用 Native 的 callNative 方法，发过来的参数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">        );</span><br><span class="line">        method = updateFinish;</span><br><span class="line">        <span class="keyword">module</span> = dom;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>调用 Dom 的 updateFinish 方法，即页面刷新完毕。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>至此，Weex 从 View 的创建，到渲染，产生事件回调 JSFramework，这一系列的流程源码都解析完成了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-c990ddac97537e7b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>中间涉及到了3个子线程，mainThread，com.taobao.weex.component，com.taobao.weex.bridge，分别是 UI 主线程，DOM 线程，JSbridge 线程。</p><p>Native 端目前还差神秘的 JSFramework 的源码解析。请大家多多指点。</p><hr><p>Weex 源码解析系列文章：</p><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_how_to_work_in_iOS.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 是如何在 iOS 客户端上跑起来的</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_layout_engine_powered_by_Flexbox&#39;s_algorithm.md" rel="external nofollow noopener noreferrer" target="_blank">由 FlexBox 算法强力驱动的 Weex 布局引擎</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_events.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 事件传递的那些事儿</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_ingenuity_JS_framework.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 中别具匠心的 JS Framework</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a>  </p><hr>]]></content>
    
    <summary type="html">
    
      &lt;!--
&lt;p align=&#39;center&#39;&gt;
&lt;img src=&#39;http://upload-images.jianshu.io/upload_images/1194012-cc51f3fa785a0464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#39;&gt;
&lt;/p&gt;
--&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>weex系列抄之二---weex原理</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/weex_two/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/weex_two/</id>
    <published>2018-05-04T04:07:12.000Z</published>
    <updated>2018-06-22T06:09:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于Weex"><a href="#关于Weex" class="headerlink" title="关于Weex"></a>关于Weex</h2><p>Weex是一套跨平台的动态页面解决方案，让开发者可以用前端的语法写出Native级别的体验，这一点核心功能与React Native是相同的，但RN并不是今天的主角， 这里也不多花笔墨介绍。WEEX宣称「Write Once, Run Everywhere」，同一份代码可以在不同端上运行。Weex是如何做到的呢？</p><p>话不多说，先上一张上镜率特别高的流程图，了解一下Weex的工作流程：</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex1.jpg" alt=""></p><p>在服务端，开发者将写好的Weex文件转换成JS bundle并部署到服务器上供终端下载；终端会在合适的时机拉取JS Bundle，同时利用WeexSDK 中预先准备好的 JavaScript 引擎解析执行JS bundle，在执行过程中通过JS-Native Bridge产生各种终端能够识别的命令进行界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践。</p><h2 id="Weex框架"><a href="#Weex框架" class="headerlink" title="Weex框架"></a>Weex框架</h2><p>Weex源码可以在Github(<a href="https://github.com/apache/incubator-weex)上下载到，先看下0.16.1版本下的文件目录结构：" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-weex)上下载到，先看下0.16.1版本下的文件目录结构：</a></p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex2.jpg" alt=""></p><p>目录的划分比较清楚，一个目录基本就是对应一个功能模块，我们可以对其做一个归类，把它分为三端：JS端、桥接端和纯Native端。见下图：（灰色的方块代表一个文件目录）</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex3.jpg" alt=""></p><h2 id="JS端"><a href="#JS端" class="headerlink" title="JS端"></a>JS端</h2><p>JS端主要内容是Weex源码中的native-bundle-main.js文件，它提供了一系列Weex的基础JS方法，作用相当于一个库，因此我们又称之为JS Framework。Weex把JS Bundle拆分为基础JS库和业务JS代码， 并把JS库带到安装包中，这样一来，页面请求的JS Bundle就只需要包含业务代码，体积会变得很小，对于加载速度提升大有裨益。JS Framework会在WeexSDK初始化时被加载到内存中。</p><h2 id="桥接端（Bridge）"><a href="#桥接端（Bridge）" class="headerlink" title="桥接端（Bridge）"></a>桥接端（Bridge）</h2><p>桥接层负责JS和Native的通信，主要依靠一个全局的JSContext作为媒介。WeexSDK初始化时会往这个全局的JSContext中注入一些方法，举个栗子：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">JSValue* </span>(^callNativeBlock)(<span class="keyword">JSValue </span>*, <span class="keyword">JSValue </span>*, <span class="keyword">JSValue </span>*) = ^<span class="keyword">JSValue*(JSValue </span>*<span class="keyword">instance, </span><span class="keyword">JSValue </span>*tasks, <span class="keyword">JSValue </span>*callback)&#123;</span><br><span class="line">        NSString *<span class="keyword">instanceId </span>= [<span class="keyword">instance </span>toString]<span class="comment">;</span></span><br><span class="line">        NSArray *tasksArray = [tasks toArray]<span class="comment">;</span></span><br><span class="line">        NSString *callbackId = [callback toString]<span class="comment">;  </span></span><br><span class="line">      return [<span class="keyword">JSValue </span>valueWithInt32:(int32_t)callNative(<span class="keyword">instanceId, </span>tasksArray, callbackId) inContext:[<span class="keyword">JSContext </span>currentContext]]<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    _jsContext[@<span class="string">"callNative"</span>] = callNativeBlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而终端调用JS也是通过取JSContext对象，调用invokeMethod:withArguments:方法实现。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (JSValue *)callJSMethod:(NSString *)<span class="function"><span class="keyword">method</span> <span class="title">args</span>:</span>(NSArray *)args</span><br><span class="line"><span class="comment">&#123;    </span></span><br><span class="line"><span class="comment">    return [[_jsContext globalObject] invokeMethod:method withArguments:args];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="纯Native端"><a href="#纯Native端" class="headerlink" title="纯Native端"></a>纯Native端</h2><font color="red">主要的业务都代码都是这一端，包括JS Bundle的请求、UI渲染、性能统计等等。功能层面对其自上而下划分，又可拆分为接口层（Interface）、功能层（Function）、基础层（Basic）。</font><p>接口层顾名思义，就是对外暴露API的模块，是最贴近开发者的一层。通过Engine可以对SDK进行初始化，同时注册一些通用的Component和Module，JS Framework会在此时被加载。Controller不必多说，可以使用这个现成的Controller创建一个weex页面，我们需要做的仅仅是传递一个url给它。但如果想要自已实现一个Weex Controller而不是继承它，这个时候就需要用到Model中的WXSDKInstance，Weex渲染过程的各个阶段都会在WXSDKInstance中有回调，JS Bundle的请求也是在这个类中发出。</p><p>先绕过功能层，看基础层。基础层提供了一些基础的、与业务无强相关的功能。如Network就是对NSURLSession进行一次再封装，提供基础的下载功能；Event用来定义一些标准手势事件；Layout则是页面布局相关实现，布局引擎采用C语言，可以跨平台使用。Event和Layout最终都服务于Component。</p><p>最后是代码最重的功能层，其中Monitor和DevTool是相对比较独立的，Monitor是测速模块，DevTool用来支持远程调试的，可以不集成到代码中，不影响编译，此处不谈。</p><p>Module、Component和Handler是Weex三贱客，它们都是采用插件的形式集合到SDK中，很方便扩展。注册的时机也相同，SDK会在初始化时调用registerDefaultModules/Compoents/Handlers加载一些标准的插件。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)registerDefaults</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">self _registerDefaultComponents</span>];</span><br><span class="line">    [<span class="meta">self _registerDefaultModules</span>];</span><br><span class="line">    [<span class="meta">self _registerDefaultHandlers</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register some default components when the engine initializes.+ (void)_registerDefaultComponents</span></span><br><span class="line">&#123;</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"container"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXDivComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"div"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"text"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXTextComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"image"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXImageComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注册时的命名上不难看出，<font color="red">Component实现的是UIKit的功能。</font>那还有两贱客是干吗的？<font color="red">我们可以认为Module是终端提供给JS的功能模块，为了让JS获得终端的能力，例如网络请求的能力（WXStreamModule）、定时器的能力（WXTimerModule）等。三贱客里，Component和Module都是可以直接和JS通信的，而Handler不行，Handler仅仅作为面向协议编程的一种手段，在纯Native端使用</font>。</p><p>Loader就是采用了Handler的形式对Network进行了进一步的再封装，用这种方式会让Loader模块更灵活一些，开发者完全可以通过重新注册Handler来挂载新的网络请求方法，实现一些自定义的功能。</p><font color="red">除了Component和Module，还有一个模块可以直接和JS通信，就是结构图中与桥接端相邻的Manager（与桥接端相邻代表二者可以直接通信），Manager模块主要包括WXComponentManager和Factory，WXComponentManager用来做Component的调度，而Factory用来保存Component和Module的配置。</font><p>讲完了WeexSDK源码框架，或许读者还是会有不少疑问：说了那么一堆高大上的名词，然并卵，我还是不知道Weex是怎么跑起来的。那我们就更具体一点，去看看Module和Component的世界吧。</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>前面有一个高频词汇：注册。<font color="red">所谓注册，其实在实现上就是往全局字典里面以Key-Value的形式保存一些模块的信息。</font>Weex三贱客都需要注册，Handler的注册上文提到过，其实就是以Protocol Name为Key，往全局字典里面写入一个实现了该Protocol的对象。Module和Component的注册则更接近一些，都是以注册时的标签为Key，而保存的value是一个WXInvocationConfig派生类对象，可以瞄一眼WXInvocationConfig携带的信息，包括：标签名、类名、同步方法和异步方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXInvocationConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *clazz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *asyncMethods;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *syncMethods;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="keyword">class</span>:(<span class="built_in">NSString</span> *)clazz;</span><br><span class="line">- (<span class="keyword">void</span>)registerMethods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>以WXDomModule为例，在WXDomModule的类实现文件中有一坨被WX_EXPORT_METHOD宏定义包裹的selector：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">createBody</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">addElement</span>:<span class="attribute">element</span>:<span class="attribute">atIndex</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">removeElement</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">moveElement</span>:<span class="attribute">parentRef</span>:<span class="attribute">index</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">addEvent</span>:<span class="attribute">event</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">removeEvent</span>:<span class="attribute">event</span>:))</span><br><span class="line">……</span><br></pre></td></tr></table></figure><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define WX_EXPORT_METHOD(<span class="function"><span class="keyword">method</span>) <span class="title">WX_EXPORT_METHOD_INTERNAL</span><span class="params">(<span class="keyword">method</span>,wx_export_method_)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WX_EXPORT_METHOD_INTERNAL</span><span class="params">(<span class="keyword">method</span>, token)</span> \</span></span><br><span class="line"><span class="function">+ <span class="params">(NSString *)</span><span class="title">WX_CONCAT_WRAPPER</span><span class="params">(token, __LINE__)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment"> \    return NSStringFromSelector(method); \</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WX_CONCAT_WRAPPER</span><span class="params">(a, b)</span>    <span class="title">WX_CONCAT</span><span class="params">(a, b)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)wx_export_method_40 &#123;   </span><br><span class="line"> <span class="keyword">return</span> NSStringFromSelector(<span class="meta">@selector(createBody:)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerMethods</span><br><span class="line">&#123;</span><br><span class="line">    Class currentClass = <span class="built_in">NSClassFromString</span>(_clazz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentClass != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">        Method *methodList = class_copyMethodList(object_getClass(currentClass), &amp;methodCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *selStr = [<span class="built_in">NSString</span> stringWithCString:sel_getName(method_getName(methodList[i])) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="built_in">BOOL</span> isSyncMethod = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> ([selStr hasPrefix:<span class="string">@"wx_export_method_sync_"</span>]) &#123;</span><br><span class="line">                isSyncMethod = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([selStr hasPrefix:<span class="string">@"wx_export_method_"</span>]) &#123;</span><br><span class="line">                isSyncMethod = <span class="literal">NO</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *name = <span class="literal">nil</span>, *method = <span class="literal">nil</span>;</span><br><span class="line">            SEL selector = <span class="built_in">NSSelectorFromString</span>(selStr);</span><br><span class="line">            <span class="keyword">if</span> ([currentClass respondsToSelector:selector]) &#123;</span><br><span class="line">                method = ((<span class="built_in">NSString</span>* (*)(<span class="keyword">id</span>, SEL))[currentClass methodForSelector:selector])(currentClass, selector);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSRange</span> range = [method rangeOfString:<span class="string">@":"</span>];</span><br><span class="line">            <span class="keyword">if</span> (range.location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                name = [method substringToIndex:range.location];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                name = method;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *methods = isSyncMethod ? _syncMethods : _asyncMethods;</span><br><span class="line">            [methods setObject:method forKey:name];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free(methodList);</span><br><span class="line">        currentClass = class_getSuperclass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用完registerMethods方法后，WXDomModule的Config包含的信息如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex4.jpg" alt=""></p><font color="red">同步方法和异步方法存储的Key列表就是JS端可调用的函数名列表。</font>趁热打铁，继续看下JS端是具体是怎么调用这些暴露出去的方法。<br><br>在前文第二节Weex框架中有提到，WeexSDK会在桥接层往JSContext注入一些方法作为JS调用Native的通道，其中callNativeModule方法就是用来调用Native Module的（JS调用Module不仅限于callNativeModule方法）。<br><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">_jsBridge</span> registerCallNativeModule:^NSInvocation*(<span class="name">NSString</span> *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [<span class="name">WXSDKManager</span> instanceForID:instanceId]<span class="comment">;</span></span><br><span class="line">    WXModuleMethod *method = [[<span class="name">WXModuleMethod</span> alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments options:options instance:instance]<span class="comment">; </span></span><br><span class="line">   return [<span class="name">method</span> invoke]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br>| Moudule | 能力<br>| — | — |<br>| WXDomModule | 提供Demo解析能力 |<br>| WXNavigatorModule | 提供控制UI能力 |<br>| WXStreamModule | 提供网络请求能力 |<br>| WXAnimationModule | 提供动画能力<br> |<br>| WXModalUIModule | 提供alert、toast等模态UI展示能力 |<br>| WXWebViewModule | 提供webview基础能力<br> |<br>| WXInstanceWrap | 提供访问终端instance实例能力 |<br>| WXTimerModule | 提供定时器能力 |<br>| WXStorageModule | 提供持久化能力 |<br>| WXClipboardModule | 提供剪切板能力 |<br>| WXGlobalEventModule | 提供全局事件(监听通知)能力 |<br>| WXCanvasModule | 提供绘图能力 |<br>| WXPickerModule | 提供DatePicker和TimePicker能力 |<br>| WXMetaModule | 提供设置视口(viewport)能力 |<br>| WXWebSocketModule | 提供WebSocket能力 |<br>| WXVoiceOverModule | 提供VoiceOver能力 |<br><br>## Component<br><br>理解了Module后再来看一下Component。前面提到过Component的主要作用对应UIKit,每一个Component类就与一种UI类型强相关，如tableView、imageView。Component维护了一个生命周期，这一点跟UIViewController有点相似：<br><br><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex5.jpg" alt=""><br><br>Component的init方法有许多参数要传，包括样式、属性、事件等都可以在初始化时传入；loadView时，WXComponent的派生类需要返回一个UI类型实例，它会被赋值给Component的view属性，跟Component关联起来；loadView之后会走到addEvent，这里允许我们添加一些自定义的事件（常用的单击、长按等事件已经实现，在初始化时传入即可，不需要操作addEvent方法）；在viewDidLoad中可以对view做个性化的配置，然后启动布局。<br><br>Weex允许在view加载出来了以后再去updateStyles/Attributes，JS可以直接访问到这个Component对象。<br><br>JS调用Component的原理和Module基本一样，通过注入的callNativeComponent、callUpdateAttrs等一系列方法，在调用过程中生成一个WXComponentMethod对象，然后再利用NSInvocation invoke触达Native。除此之外，JS还可以通过WXComponentManager间接调用Component。<br><br><font color="red">WXComponentManager是Component的调度器，可以直接和JS通信。注入JSContext的方法中与其相关的有callAddElement、callRemoveElement、callAddEvent等,通过这些方法直接调用WXComponentManager即图示中的链路①。而在首屏渲染时通常走的是链路②，即JS Framework在解析JS Bundle时会先访问WXDomModule，然后再由WXDomModule间接地调用WXComponentManager，两种方式其实没有太大差别，在首屏全部使用WXDomModule会更容易监控Dom解析过程而已。</font><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex6.jpg" alt=""></p><p>addComponent的作用类似于addSubview，WXComponentManager会先用JS传递过来的componentData创建Component对象，然后再把生成的Component添加到它supercomponent的树结构中，同时把Component关联的view加到视图层级上去，之后再对它的children结点递归调用addComponent。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">_recursivelyAddComponent:</span>(NSDictionary *)componentData <span class="string">toSupercomponent:</span>(WXComponent *)supercomponent <span class="string">atIndex:</span>(NSInteger)index <span class="string">appendingInTree:</span>(BOOL)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *component = [self <span class="string">_buildComponentForData:</span>componentData <span class="string">supercomponent:</span>supercomponent];</span><br><span class="line">    [supercomponent <span class="string">_insertSubcomponent:</span>component <span class="string">atIndex:</span>index];</span><br><span class="line">    <span class="keyword">if</span> (!component-&gt;_isTemplate) &#123;</span><br><span class="line">        [supercomponent <span class="string">insertSubview:</span>component <span class="string">atIndex:</span>index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray *subcomponentsData = [componentData <span class="string">valueForKey:</span>@<span class="string">"children"</span>];</span><br><span class="line">    BOOL appendTree = !appendingInTree &amp;&amp; [component.attributes[@<span class="string">"append"</span>] <span class="string">isEqualToString:</span>@<span class="string">"tree"</span>];   </span><br><span class="line">     <span class="comment">// if ancestor is appending tree, child should not be laid out again even it is appending tree.</span></span><br><span class="line">    <span class="keyword">for</span>(NSDictionary *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [self <span class="string">_recursivelyAddComponent:</span>subcomponentData <span class="string">toSupercomponent:</span>component <span class="string">atIndex:</span><span class="number">-1</span> <span class="string">appendingInTree:</span>appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    [component _didInserted];  </span><br><span class="line">      <span class="keyword">if</span> (appendTree) &#123;   </span><br><span class="line">           <span class="comment">// If appending tree，force layout in case of too much tasks piling up in syncQueue</span></span><br><span class="line">        [self _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex7.jpg" alt=""></p><p>WXComponentManager中会起一个DisplayLink，在每个定时周期循环遍历各个元素，检查是否需要更新布局，需要布局的cssNode会在is_dirty字段标识。<font color="red">如果超过1s没有布局任务，DisplayLink会进入休眠状态直至下一次唤醒。</font></p><h2 id="WXSDKInstance"><a href="#WXSDKInstance" class="headerlink" title="WXSDKInstance"></a>WXSDKInstance</h2><font color="red">在了解过Module和Component的大致原理后，对Weex已经有一个基本认知，但距离整个流程跑通还欠缺一点。分散的Module和Component本身是不会工作的，还需要一个动力，这时我们的WXSDKInstance就要粉墨登场了。</font><p>还记得最初的那张Weex框架图吗？ WXSDKInstance（在Model模块里）是整个Weex页面加载的起点，它会去服务端请求JS Bundle，没有JS Bundle我们什么事都干不了！</p><p>WXSDKInstance下载JS Bundle后，会把它传给JS Framework，JS Framework解析JS Bundle并通过WXDomModule往RootView上渲染视图。每个WXSDKInstance都会绑定一个独立的WXComponentManager。</p><p>用图表示的话，流程大概是下面这样子，WXSDKInstace负责串联各部分模块并带动整个流程：</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex8.jpg" alt=""></p><p>在一些关键的流程上，WXSDKInstance都会有回调，如图上标注出的onCreate()是在下载完JS Bundle，RootView被创建出时回调；renderFinish()是在首屏Dom解析完成后回调；除此之外，还有onFailed()会在加载失败时回调，onJSRuntimeException()在JS执行异常时回调。这些回调都是对外暴露的，我们可以这些回调上做一些定制化的内容。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">官方手册</a></li><li><a href="https://mp.weixin.qq.com/s/Hh3vXjQ8nZDJny1bd0xYOw" rel="external nofollow noopener noreferrer" target="_blank">企鹅电竞weex实践—— iOS SDK的小九九</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于Weex&quot;&gt;&lt;a href=&quot;#关于Weex&quot; class=&quot;headerlink&quot; title=&quot;关于Weex&quot;&gt;&lt;/a&gt;关于Weex&lt;/h2&gt;&lt;p&gt;Weex是一套跨平台的动态页面解决方案，让开发者可以用前端的语法写出Native级别的体验，这一点核心功能与
      
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/Weex_five/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/Weex_five/</id>
    <published>2018-05-04T04:07:12.000Z</published>
    <updated>2018-06-22T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。</p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>1.Weex布局算法</li><li>2.Weex布局算法性能分析</li><li>3.Weex是如何布局原生界面的</li></ul><h3 id="一-Weex布局算法"><a href="#一-Weex布局算法" class="headerlink" title="一. Weex布局算法"></a>一. Weex布局算法</h3><p>打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。</p><p>Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。</p><p>当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-de7f409bd683080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(<a href="https://facebook.github.io/yoga/" rel="external nofollow noopener noreferrer" target="_blank">Yoga官网</a>)。</p><p>那么Flexbox是什么呢？</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-a85be95bcb08cc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。</p><p>关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">官方文档链接</a></p><p>Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-8c812635119a366c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>故以下源码分析都基于v0.10.0这个版本。</p><h4 id="（一）FlexBox中的基本数据结构"><a href="#（一）FlexBox中的基本数据结构" class="headerlink" title="（一）FlexBox中的基本数据结构"></a>（一）FlexBox中的基本数据结构</h4><p>Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。</p><p>在FlexBox的世界里，存在着主轴和侧轴的概念。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-b476d0e771837826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-951af0f2fc01b0a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。</p><p><strong>主轴（main axis）：</strong>父视图的主轴，子视图主要沿着这条轴进行排列布局。</p><p><strong>主轴起点（main-start）和主轴终点（main-end）：</strong>子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。</p><p><strong>主轴尺寸（main size）：</strong>子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。</p><p><strong>侧轴（cross axis）：</strong>垂直于主轴称为侧轴。它的方向主要取决于主轴方向。</p><p><strong>侧轴起点（cross-start）和侧轴终点（cross-end）：</strong>子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</p><p><strong>侧轴尺寸（cross size）：</strong>子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。</p><p>接下来看看Layout是怎么定义FlexBox里面的元素的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_DIRECTION_INHERIT = <span class="number">0</span>,</span><br><span class="line">  CSS_DIRECTION_LTR,</span><br><span class="line">  CSS_DIRECTION_RTL</span><br><span class="line">&#125; <span class="keyword">css_direction_t</span>;</span><br></pre></td></tr></table></figure><p>这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN = <span class="number">0</span>,</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN_REVERSE,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW_REVERSE</span><br><span class="line">&#125; <span class="keyword">css_flex_direction_t</span>;</span><br></pre></td></tr></table></figure><p>这里定义的是Flex的方向。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-74e4b1f77d6fa40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是COLUMN。布局的走向是从上往下。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-d34a0fea4404545e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是COLUMN_REVERSE。布局的走向是从下往上。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-8a6e7643a60e2906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ROW。布局的走向是从左往右。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-569f2a299797e27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ROW_REVERSE。布局的走向是从右往左。</p><p>这里可以看出来，在LTR的上下文中，ROW_REVERSE即等于RTL的上下文中的ROW。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_JUSTIFY_FLEX_START = <span class="number">0</span>,</span><br><span class="line">  CSS_JUSTIFY_CENTER,</span><br><span class="line">  CSS_JUSTIFY_FLEX_END,</span><br><span class="line">  CSS_JUSTIFY_SPACE_BETWEEN,</span><br><span class="line">  CSS_JUSTIFY_SPACE_AROUND</span><br><span class="line">&#125; <span class="keyword">css_justify_t</span>;</span><br></pre></td></tr></table></figure><p>这是定义的子视图在主轴上的排列方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-7dd84c06eabd1ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是JUSTIFY_FLEX_START</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-d86b61dabc5a97fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是JUSTIFY_CENTER</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-945bde67f5931fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是JUSTIFY_FLEX_END</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-3823fed50bd98895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是JUSTIFY_SPACE_BETWEEN</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-5c514b364e470dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是JUSTIFY_SPACE_AROUND。这种方式是每个视图的左右都保持着一定的宽度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_ALIGN_AUTO = <span class="number">0</span>,</span><br><span class="line">  CSS_ALIGN_FLEX_START,</span><br><span class="line">  CSS_ALIGN_CENTER,</span><br><span class="line">  CSS_ALIGN_FLEX_END,</span><br><span class="line">  CSS_ALIGN_STRETCH</span><br><span class="line">&#125; <span class="keyword">css_align_t</span>;</span><br></pre></td></tr></table></figure><p>这是定义的子视图在侧轴上的对齐方式。</p><p>在Weex这里定义了三种属于css_align_t类型的方式，align_content，align_items，align_self。这三种类型的对齐方式略有不同。</p><p>ALIGN_AUTO只是针对align_self的一个默认值，但是对于align_content，align_items子视图的对齐方式是无效的值。</p><h4 id="1-align-items"><a href="#1-align-items" class="headerlink" title="1.align_items"></a>1.align_items</h4><p>align_items定义的是子视图在一行里面侧轴上排列的方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-e756eec5a022f74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_FLEX_START</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-5e200b8d742b01a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_CENTER</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-ceab624ccd23e978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_FLEX_END</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-7bb4781738e20528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_STRETCH</p><p>align_items在W3C的定义里面其实还有一个种baseline的对齐方式，这里在定义里面并没有。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-10e077f6a05f4fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>注意，上面这种baseline的对齐方式在Weex的定义里面并没有！</p><h4 id="2-align-content"><a href="#2-align-content" class="headerlink" title="2. align_content"></a>2. align_content</h4><p><strong>align_content定义的是子视图行与行之间在侧轴上排列的方式。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-c4e6c4930823f326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_FLEX_START</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-3425b3876c3d665b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_CENTER</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-c5358bd9b76e9aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_FLEX_END</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-6a98ea3472c5b20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是ALIGN_STRETCH</p><p>在FlexBox的W3C的定义里面其实还有两种方式在Weex没有定义。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-b5b1500aa720593a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_AROUND，align-content里面的space-around这种对齐方式在Weex是没有的。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-77e9ab8a8268646f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_BETWEEN，align-content里面的space-between这种对齐方式在Weex是没有的。</p><h4 id="3-align-self"><a href="#3-align-self" class="headerlink" title="3.align_self"></a>3.align_self</h4><p>最后这一种对齐方式是可以在align_items的基础上再分别自定义每个子视图的对齐方式。如果是auto，是与align_items方式相同。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-964d7fb4451fb0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_POSITION_RELATIVE = <span class="number">0</span>,</span><br><span class="line">  CSS_POSITION_ABSOLUTE</span><br><span class="line">&#125; <span class="keyword">css_position_type_t</span>;</span><br></pre></td></tr></table></figure><p>这个是定义坐标地址的类型，有相对坐标和绝对坐标两种。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_NOWRAP = <span class="number">0</span>,</span><br><span class="line">  CSS_WRAP</span><br><span class="line">&#125; <span class="keyword">css_wrap_type_t</span>;</span><br></pre></td></tr></table></figure><p>在Weex里面wrap只有两种类型。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-d982430a883bd70e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是NOWRAP。所有的子视图都会排列在一行之中。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-40c4c59a6237ebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是WRAP。所有的子视图会从左到右，从上到下排列。</p><p>在W3C的标准里面还有一种wrap_reverse的排列方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-40d7272e17d5b429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>这种排列方式，是从左到右，从下到上进行排列，目前在Weex里面没有定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_LEFT = <span class="number">0</span>,</span><br><span class="line">  CSS_TOP,</span><br><span class="line">  CSS_RIGHT,</span><br><span class="line">  CSS_BOTTOM,</span><br><span class="line">  CSS_START,</span><br><span class="line">  CSS_END,</span><br><span class="line">  CSS_POSITION_COUNT</span><br><span class="line">&#125; <span class="keyword">css_position_t</span>;</span><br></pre></td></tr></table></figure><p>这里定义的是坐标的描述。Left和Top因为会出现在position[2] 和 position[4]中，所以它们两个排列在Right和Bottom前面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_MEASURE_MODE_UNDEFINED = <span class="number">0</span>,</span><br><span class="line">  CSS_MEASURE_MODE_EXACTLY,</span><br><span class="line">  CSS_MEASURE_MODE_AT_MOST</span><br><span class="line">&#125; <span class="keyword">css_measure_mode_t</span>;</span><br></pre></td></tr></table></figure><p>这里定义的是计算的方式，一种是精确计算，另外一种是估算近视值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_WIDTH = <span class="number">0</span>,</span><br><span class="line">  CSS_HEIGHT</span><br><span class="line">&#125; <span class="keyword">css_dimension_t</span>;</span><br></pre></td></tr></table></figure><p>这里定义的是子视图的尺寸，宽和高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存一些信息防止每次Layout过程都要重复计算</span></span><br><span class="line">  <span class="keyword">bool</span> should_update;</span><br><span class="line">  <span class="keyword">float</span> last_requested_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_width;</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_height;</span><br><span class="line">  <span class="keyword">float</span> last_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_position[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> last_direction;</span><br><span class="line">&#125; <span class="keyword">css_layout_t</span>;</span><br></pre></td></tr></table></figure><p>这里定义了一个css_layout_t结构体。结构体里面position和dimensions数组里面分别存储的是四周的位置和宽高的尺寸。direction里面存储的就是LTR还是RTL的方向。</p><p>至于下面那些变量信息都是缓存，用来防止没有改变的Lauout还会重复计算的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_dim_t</span>;</span><br></pre></td></tr></table></figure><p>css_dim_t结构体里面装的就是子视图的尺寸信息，宽和高。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 整个页面CSS的方向，LTR、RTL</span></span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line">  <span class="comment">// Flex 的方向</span></span><br><span class="line">  <span class="keyword">css_flex_direction_t</span> flex_direction;</span><br><span class="line">  <span class="comment">// 子视图在主轴上的排列对齐方式</span></span><br><span class="line">  <span class="keyword">css_justify_t</span> justify_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上行与行之间的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_items;</span><br><span class="line">  <span class="comment">// 子视图自己本身的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_self;</span><br><span class="line">  <span class="comment">// 子视图的坐标系类型(相对坐标系，绝对坐标系)</span></span><br><span class="line">  <span class="keyword">css_position_type_t</span> position_type;</span><br><span class="line">  <span class="comment">// wrap类型</span></span><br><span class="line">  <span class="keyword">css_wrap_type_t</span> flex_wrap;</span><br><span class="line">  <span class="keyword">float</span> flex;</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> margin[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> padding[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> border[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 宽，高</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最小的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> minDimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最大的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> maxDimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_style_t</span>;</span><br></pre></td></tr></table></figure><p>css_style_t记录了整个style的所有信息。每个变量的意义见上面注释。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> <span class="title">css_node_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">css_style_t</span> style;</span><br><span class="line">  <span class="keyword">css_layout_t</span> layout;</span><br><span class="line">  <span class="keyword">int</span> children_count;</span><br><span class="line">  <span class="keyword">int</span> line_index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_node_t</span> *next_absolute_child;</span><br><span class="line">  <span class="keyword">css_node_t</span> *next_flex_child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_dim_t</span> (*measure)(<span class="keyword">void</span> *context, <span class="keyword">float</span> width, <span class="keyword">css_measure_mode_t</span> widthMode, <span class="keyword">float</span> height, <span class="keyword">css_measure_mode_t</span> heightMode);</span><br><span class="line">  <span class="keyword">void</span> (*print)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span>* (*<span class="title">get_child</span>)(<span class="title">void</span> *<span class="title">context</span>, <span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line">  <span class="keyword">bool</span> (*is_dirty)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="keyword">void</span> *context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>css_node定义的是FlexBox的一个节点的数据结构。它包含了之前的css_style_t和css_layout_t。由于结构体里面无法定义成员函数，所以下面包含4个函数指针。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-9192b10f6607271c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">css_node_t</span> *new_css_node(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure><p>上面3个函数是关于css_node的生命周期相关的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="keyword">css_node_t</span> *new_css_node() &#123;</span><br><span class="line">  <span class="keyword">css_node_t</span> *node = (<span class="keyword">css_node_t</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*node));</span><br><span class="line">  init_css_node(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建节点的时候就是调用的init_css_node方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;style.align_items = CSS_ALIGN_STRETCH;</span><br><span class="line">  node-&gt;style.align_content = CSS_ALIGN_FLEX_START;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.direction = CSS_DIRECTION_INHERIT;</span><br><span class="line">  node-&gt;style.flex_direction = CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意下面这些数组里面的值初始化为undefined，而不是0</span></span><br><span class="line">  node-&gt;style.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.minDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.minDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.maxDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.maxDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.position[CSS_LEFT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_TOP] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_RIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_BOTTOM] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.margin[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.margin[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_END] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下这些用来对比是否发生变化的缓存变量，初始值都为 -1。</span></span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_WIDTH] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_HEIGHT] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_width = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_height = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_direction = (<span class="keyword">css_direction_t</span>)<span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.should_update = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>css_node的初始化的align_items是ALIGN_STRETCH，align_content是ALIGN_FLEX_START，direction是继承自父类，flex_direction是按照列排列的。</p><p>接着下面数组里面存的都是UNDEFINED，而不是0，因为0会和结构体里面的0冲突。</p><p>最后缓存的变量初始化都为-1。</p><p>接下来定义了4个全局的数组，这4个数组非常有用，它会决定接下来layout的方向和属性。4个数组和轴的方向是相互关联的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> leading[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果主轴在COLUMN垂直方向，那么子视图的leading就是CSS_TOP，方向如果是COLUMN_REVERSE，那么子视图的leading就是CSS_BOTTOM；如果主轴在ROW水平方向，那么子视图的leading就是CSS_LEFT，方向如果是ROW_REVERSE，那么子视图的leading就是CSS_RIGHT。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> trailing[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_RIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_LEFT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果主轴在COLUMN垂直方向，那么子视图的trailing就是CSS_BOTTOM，方向如果是COLUMN_REVERSE，那么子视图的trailing就是CSS_TOP；如果主轴在ROW水平方向，那么子视图的trailing就是CSS_RIGHT，方向如果是ROW_REVERSE，那么子视图的trailing就是CSS_LEFT。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> pos[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果主轴在COLUMN垂直方向，那么子视图的position就是以CSS_TOP开始的，方向如果是COLUMN_REVERSE，那么子视图的position就是以CSS_BOTTOM开始的；如果主轴在ROW水平方向，那么子视图的position就是以CSS_LEFT开始的，方向如果是ROW_REVERSE，那么子视图的position就是以CSS_RIGHT开始的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_dimension_t</span> dim[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_WIDTH,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_WIDTH</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果主轴在COLUMN垂直方向，那么子视图在这个方向上的尺寸就是CSS_HEIGHT，方向如果是COLUMN_REVERSE，那么子视图在这个方向上的尺寸也是CSS_HEIGHT；如果主轴在ROW水平方向，那么子视图在这个方向上的尺寸就是CSS_WIDTH，方向如果是ROW_REVERSE，那么子视图在这个方向上的尺寸是CSS_WIDTH。</p><h4 id="（二）FlexBox中的布局算法"><a href="#（二）FlexBox中的布局算法" class="headerlink" title="（二）FlexBox中的布局算法"></a>（二）FlexBox中的布局算法</h4><p>Weex 盒模型基于 <a href="https://www.w3.org/TR/css3-box/" rel="external nofollow noopener noreferrer" target="_blank">CSS 盒模型</a>，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。</p><p>盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-2968e2f04c41c140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>盒子模型如上，这个图是基于LTR，并且主轴在水平方向的。</p><p>所以主轴在不同方向可能就会有不同的情况。</p><blockquote><p>注意：<br>Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容content、内边距padding和边框的宽度border，不包含外边距的宽度margin。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是水平方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRowDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_ROW ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_ROW_REVERSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是垂直方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isColumnDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_COLUMN ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_COLUMN_REVERSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断轴的方向的方向就是上面这两个。</p><p>然后接着还要计算4个方向上的padding、border、margin。这里就举一个方向的例子。</p><p>首先如何计算Margin的呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_START])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[leading[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断轴的方向是不是水平方向，如果是水平方向就直接取node的margin里面的CSS_START即是LeadingMargin，如果是竖直方向，就取出在竖直轴上面的leading方向的margin的值。</p><p>如果取TrailingMargin那么就取margin[CSS_END]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getTrailingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_END])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_END];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[trailing[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下padding、border、margin三个值的数组存储有6个值，如果是水平方向，那么CSS_START存储的都是Leading，CSS_END存储的都是Trailing。下面没有特殊说明，都按照这个规则来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingPadding</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.padding[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.padding[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.padding[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取Padding的思路也和取Margin的思路一样，水平方向就是取出数组里面的padding[CSS_START]，如果是竖直方向，就对应得取出padding[leading[axis]]的值即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingBorder</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.border[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.border[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.border[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这是Border的计算方法，和上述Padding，Margin一模一样，这里就不再赘述了。</p><p>四周边距的计算方法都实现了，接下来就是如何layout了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算布局的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> maxWidth, <span class="keyword">float</span> maxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用layoutNode之前，可以重置node节点的layout</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure><p>重置node节点的方法就是把节点的坐标重置为0，然后把宽和高都重置为UNDEFINED。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.position[CSS_LEFT] = <span class="number">0</span>;</span><br><span class="line">  node-&gt;layout.position[CSS_TOP] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，布局方法就是如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">css_layout_t</span> *layout = &amp;node-&gt;layout;</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction = node-&gt;style.direction;</span><br><span class="line">  layout-&gt;should_update = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比当前环境是否“干净”，以及比较待布局的node节点和上次节点是否完全一致。</span></span><br><span class="line">  <span class="keyword">bool</span> skipLayout =</span><br><span class="line">    !node-&gt;is_dirty(node-&gt;context) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_WIDTH], layout-&gt;dimensions[CSS_WIDTH]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_HEIGHT], layout-&gt;dimensions[CSS_HEIGHT]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_width, parentMaxWidth) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_height, parentMaxHeight) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_direction, direction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skipLayout) &#123;</span><br><span class="line">    <span class="comment">// 把缓存的值直接赋值给当前的layout</span></span><br><span class="line">    layout-&gt;dimensions[CSS_WIDTH] = layout-&gt;last_dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;dimensions[CSS_HEIGHT] = layout-&gt;last_dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;position[CSS_TOP] = layout-&gt;last_position[CSS_TOP];</span><br><span class="line">    layout-&gt;position[CSS_LEFT] = layout-&gt;last_position[CSS_LEFT];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存node节点</span></span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_parent_max_width = parentMaxWidth;</span><br><span class="line">    layout-&gt;last_parent_max_height = parentMaxHeight;</span><br><span class="line">    layout-&gt;last_direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有子视图node的尺寸和位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = node-&gt;children_count; i &lt; childCount; i++) &#123;</span><br><span class="line">      resetNodeLayout(node-&gt;get_child(node-&gt;context, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局视图的核心实现</span></span><br><span class="line">    layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局完成，把此次的布局缓存起来，防止下次重复的布局重复计算</span></span><br><span class="line">    layout-&gt;last_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_position[CSS_TOP] = layout-&gt;position[CSS_TOP];</span><br><span class="line">    layout-&gt;last_position[CSS_LEFT] = layout-&gt;position[CSS_LEFT];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每步都注释了，见上述代码注释，在调用布局的核心实现layoutNodeImpl之前，会循环调用resetNodeLayout，初始化所有子视图。</p><p>所有的核心实现就在layoutNodeImpl这个方法里面了。Weex里面的这个方法实现有700多行，在Yoga的实现中，布局算法有1000多行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">layoutNodeImpl</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里分析一下这个算法的主要流程。在Weex的这个实现中，有7个循环，假设依次分别标上A，B，C，D，E，F，G。</p><p>先来看循环A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainContentDim = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 存在3类子视图，支持flex的子视图，不支持flex的子视图，绝对布局的子视图，我们需要知道哪些子视图是在等待分配空间。</span></span><br><span class="line"><span class="keyword">int</span> flexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> totalFlexible = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nonFlexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在主轴上简单的堆叠子视图，在循环C中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackMain =</span><br><span class="line">    (isMainDimDefined &amp;&amp; justifyContent == CSS_JUSTIFY_FLEX_START) ||</span><br><span class="line">    (!isMainDimDefined &amp;&amp; justifyContent != CSS_JUSTIFY_CENTER);</span><br><span class="line"><span class="keyword">int</span> firstComplexMain = (isSimpleStackMain ? childCount : startLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在侧轴上简单的堆叠子视图，在循环D中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackCross = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> firstComplexCross = childCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">css_node_t</span>* firstFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">css_node_t</span>* currentFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainDim = leadingPaddingAndBorderMain;</span><br><span class="line"><span class="keyword">float</span> crossDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> maxWidth = CSS_UNDEFINED;</span><br><span class="line"><span class="keyword">float</span> maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环A从这里开始</span></span><br><span class="line"><span class="keyword">for</span> (i = startLine; i &lt; childCount; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line">  child-&gt;line_index = linesCount;</span><br><span class="line"></span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">  child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在递归layout之前，先预填充侧轴上可以被拉伸的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH &amp;&amp;</span><br><span class="line">      child-&gt;style.position_type == CSS_POSITION_RELATIVE &amp;&amp;</span><br><span class="line">      isCrossDimDefined &amp;&amp;</span><br><span class="line">      !isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 这里要进行一个比较，比较子视图在侧轴上的尺寸 和 侧轴上减去两边的Margin、padding、Border剩下的可拉伸的空间 进行比较，因为拉伸是不会压缩原始的大小的。</span></span><br><span class="line">    child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">      boundAxis(child, crossAxis, node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">        paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">      getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE) &#123;</span><br><span class="line">    <span class="comment">// 这里会储存一个绝对布局子视图的链表。这样我们在后面布局的时候可以快速的跳过它们。</span></span><br><span class="line">    <span class="keyword">if</span> (firstAbsoluteChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      firstAbsoluteChild = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      currentAbsoluteChild-&gt;next_absolute_child = child;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAbsoluteChild = child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预填充子视图，这里需要用到视图在轴上面的绝对坐标，如果是水平轴，需要用到左右的偏移量，如果是竖直轴，需要用到上下的偏移量。</span></span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">      axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">          !isStyleDimDefined(child, axis) &amp;&amp;</span><br><span class="line">          isPosDefined(child, leading[axis]) &amp;&amp;</span><br><span class="line">          isPosDefined(child, trailing[axis])) &#123;</span><br><span class="line">        child-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">          <span class="comment">// 这里是绝对布局，还需要减去leading和trailing</span></span><br><span class="line">          boundAxis(child, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">            getPaddingAndBorderAxis(node, axis) -</span><br><span class="line">            getMarginAxis(child, axis) -</span><br><span class="line">            getPosition(child, leading[axis]) -</span><br><span class="line">            getPosition(child, trailing[axis])),</span><br><span class="line">          getPaddingAndBorderAxis(child, axis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>循环A的具体实现如上，注释见代码。<br>循环A主要是实现的是layout布局中不可以flex的子视图的布局，mainContentDim变量是用来记录所有的尺寸以及所有不能flex的子视图的margin的总和。它被用来设置node节点的尺寸，和计算剩余空间以便供可flex子视图进行拉伸适配。</p><p>每个node节点的next_absolute_child维护了一个链表，这里存储的依次是绝对布局视图的链表。</p><p>接着需要再统计可以被拉伸的子视图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">float</span> nextContentDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计可以拉伸flex的子视图</span></span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined &amp;&amp; isFlex(child)) &#123;</span><br><span class="line">  flexibleChildrenCount++;</span><br><span class="line">  totalFlexible += child-&gt;style.flex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储一个链表维护可以flex的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (firstFlexChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    firstFlexChild = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    currentFlexChild-&gt;next_flex_child = child;</span><br><span class="line">  &#125;</span><br><span class="line">  currentFlexChild = child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这时我们虽然不知道确切的尺寸信息，但是已经知道了padding , border , margin，我们可以利用这些信息来给子视图确定一个最小的size，计算剩余可用的空间。</span></span><br><span class="line">  <span class="comment">// 下一个content的距离等于当前子视图Leading和Trailing的padding , border , margin6个尺寸之和。</span></span><br><span class="line">  nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +</span><br><span class="line">    getMarginAxis(child, mainAxis);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  maxWidth = CSS_UNDEFINED;</span><br><span class="line">  maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算出最大宽度和最大高度</span></span><br><span class="line">  <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">          paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用layout函数，进行不能拉伸的子视图的布局。</span></span><br><span class="line">  <span class="keyword">if</span> (alreadyComputedNextLayout == <span class="number">0</span>) &#123;</span><br><span class="line">    layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于绝对布局的子视图的位置和layout无关，所以我们不能用它们来计算mainContentDim</span></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">    nonFlexibleChildrenCount++;</span><br><span class="line">    nextContentDim = getDimWithMargin(child, mainAxis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码就确定出了不可拉伸的子视图的布局。</p><p>每个node节点的next_flex_child维护了一个链表，这里存储的依次是可以flex拉伸视图的链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="comment">// 将要加入的元素可能会被挤到下一行</span></span><br><span class="line">      <span class="keyword">if</span> (isNodeFlexWrap &amp;&amp;</span><br><span class="line">          isMainDimDefined &amp;&amp;</span><br><span class="line">          mainContentDim + nextContentDim &gt; definedMainDim &amp;&amp;</span><br><span class="line">          <span class="comment">// 如果这里只有一个元素，它可能就需要单独占一行</span></span><br><span class="line">          i != startLine) &#123;</span><br><span class="line">        nonFlexibleChildrenCount--;</span><br><span class="line">        alreadyComputedNextLayout = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在主轴上堆叠子视图，剩余的子视图都在循环C里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE || isFlex(child))) &#123;</span><br><span class="line">        isSimpleStackMain = <span class="literal">false</span>;</span><br><span class="line">        firstComplexMain = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在侧轴上堆叠子视图，剩余的子视图都在循环D里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE ||</span><br><span class="line">              (alignItem != CSS_ALIGN_STRETCH &amp;&amp; alignItem != CSS_ALIGN_FLEX_START) ||</span><br><span class="line">              (alignItem == CSS_ALIGN_STRETCH &amp;&amp; !isCrossDimDefined))) &#123;</span><br><span class="line">        isSimpleStackCross = <span class="literal">false</span>;</span><br><span class="line">        firstComplexCross = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line">        <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图主轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, mainAxis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以算出了主轴上的尺寸了</span></span><br><span class="line">        mainDim += getDimWithMargin(child, mainAxis);</span><br><span class="line">        <span class="comment">// 可以算出侧轴上的尺寸了</span></span><br><span class="line">        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;</span><br><span class="line">        <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图侧轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, crossAxis);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      alreadyComputedNextLayout = <span class="number">0</span>;</span><br><span class="line">      mainContentDim += nextContentDim;</span><br><span class="line">      endLine = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 循环A 至此结束</span></span><br></pre></td></tr></table></figure><p>循环A结束以后，会计算出endLine，计算出主轴上的尺寸，侧轴上的尺寸。不可拉伸的子视图的布局也会被确定。</p><p>接下来进入循环B的阶段。</p><p>循环B主要分为2个部分，第一个部分是用来布局可拉伸的子视图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为了在主轴上布局，需要控制两个space，一个是第一个子视图和最左边的距离，另一个是两个子视图之间的距离</span></span><br><span class="line"><span class="keyword">float</span> leadingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> betweenMainDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录剩余的可用空间</span></span><br><span class="line"><span class="keyword">float</span> remainingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">  remainingMainDim = definedMainDim - mainContentDim;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  remainingMainDim = fmaxf(mainContentDim, <span class="number">0</span>) - mainContentDim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前还有可拉伸的子视图，它们就要填充剩余的可用空间</span></span><br><span class="line"><span class="keyword">if</span> (flexibleChildrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">float</span> flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line">  <span class="keyword">float</span> baseMainDim;</span><br><span class="line">  <span class="keyword">float</span> boundMainDim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果剩余的空间不能提供给可拉伸的子视图，不能满足它们的最大或者最小的bounds，那么这些子视图也要排除到计算拉伸的过程之外</span></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    baseMainDim = flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">        getPaddingAndBorderAxis(currentFlexChild, mainAxis);</span><br><span class="line">    boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseMainDim != boundMainDim) &#123;</span><br><span class="line">      remainingMainDim -= boundMainDim;</span><br><span class="line">      totalFlexible -= currentFlexChild-&gt;style.flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">  &#125;</span><br><span class="line">  flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不可以拉伸的子视图可以在父视图内部overflow，在这种情况下，假设没有可用的拉伸space</span></span><br><span class="line">  <span class="keyword">if</span> (flexibleMainDim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    flexibleMainDim = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这层循环里面我们已经可以确认子视图的最终大小了</span></span><br><span class="line">    currentFlexChild-&gt;layout.dimensions[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,</span><br><span class="line">      flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">          getPaddingAndBorderAxis(currentFlexChild, mainAxis)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算水平方向轴上子视图的最大宽度</span></span><br><span class="line">    maxWidth = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算垂直方向轴上子视图的最大高度</span></span><br><span class="line">    maxHeight = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMainRowDirection) &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次递归完成可拉伸的子视图的布局</span></span><br><span class="line">    layoutNode(currentFlexChild, maxWidth, maxHeight, direction);</span><br><span class="line"></span><br><span class="line">    child = currentFlexChild;</span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">    child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述2个while结束以后，所有可以被拉伸的子视图就都布局完成了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (justifyContent != CSS_JUSTIFY_FLEX_START) &#123;</span><br><span class="line">     <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_CENTER) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_FLEX_END) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_BETWEEN) &#123;</span><br><span class="line">       remainingMainDim = fmaxf(remainingMainDim, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">         betweenMainDim = remainingMainDim /</span><br><span class="line">           (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         betweenMainDim = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_AROUND) &#123;</span><br><span class="line">       <span class="comment">// 这里是实现SPACE_AROUND的代码</span></span><br><span class="line">       betweenMainDim = remainingMainDim /</span><br><span class="line">         (flexibleChildrenCount + nonFlexibleChildrenCount);</span><br><span class="line">       leadingMainDim = betweenMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可flex拉伸的视图布局完成以后，这里是收尾工作，根据justifyContent，更改betweenMainDim和leadingMainDim的大小。</p><p>接着再是循环C。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在这个循环中，所有子视图的宽和高都将被确定下来。在确定各个子视图的坐标的时候，同时也将确定父视图的宽和高。</span></span><br><span class="line">mainDim += leadingMainDim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照Line，一层层的循环</span></span><br><span class="line"><span class="keyword">for</span> (i = firstComplexMain; i &lt; endLine; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">      isPosDefined(child, leading[mainAxis])) &#123;</span><br><span class="line">    <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，左边距和上边距已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +</span><br><span class="line">      getLeadingBorder(node, mainAxis) +</span><br><span class="line">      getLeadingMargin(child, mainAxis);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果子视图不是绝对坐标，坐标是相对的，或者还没有确定下来左边距和上边距，那么就根据当前位置确定坐标</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定trailing的坐标位置</span></span><br><span class="line">    <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来开始处理相对坐标的子视图，具有绝对坐标的子视图不会参与下述的布局计算中</span></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">      <span class="comment">// 主轴上的宽度是由所有的子视图的宽度累加而成</span></span><br><span class="line">      mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);</span><br><span class="line">      <span class="comment">// 侧轴的高度是由最高的子视图决定的</span></span><br><span class="line">      crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> containerCrossAxis = node-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  containerCrossAxis = fmaxf(</span><br><span class="line">    <span class="comment">// 计算父视图的时候需要加上，上下的padding和Border。</span></span><br><span class="line">    boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环C中，会在主轴上计算出所有子视图的坐标，包括各个子视图的宽和高。</p><p>接下来就到循环D的流程了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = firstComplexCross; i &lt; endLine; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">        isPosDefined(child, leading[crossAxis])) &#123;</span><br><span class="line">      <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，上下左右至少有一边的坐标已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +</span><br><span class="line">        getLeadingBorder(node, crossAxis) +</span><br><span class="line">        getLeadingMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">float</span> leadingCrossDim = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在侧轴上，针对相对坐标的子视图，我们利用父视图的alignItems或者子视图的alignSelf来确定具体的坐标位置</span></span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="comment">// 获取子视图的AlignItem属性值</span></span><br><span class="line">        <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line">        <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">          <span class="comment">// 如果在侧轴上子视图还没有确定尺寸，那么才会相应STRETCH拉伸。</span></span><br><span class="line">          <span class="keyword">if</span> (!isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">            <span class="keyword">float</span> dimCrossAxis = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">            child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">              boundAxis(child, crossAxis, containerCrossAxis -</span><br><span class="line">                paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">              getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果视图的大小变化了，连带该视图的子视图还需要再次layout</span></span><br><span class="line">            <span class="keyword">if</span> (dimCrossAxis != child-&gt;layout.dimensions[dim[crossAxis]] &amp;&amp; child-&gt;children_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Reset child margins before re-layout as they are added back in layoutNode and would be doubled</span></span><br><span class="line">              child-&gt;layout.position[leading[mainAxis]] -= getLeadingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[mainAxis]] -= getTrailingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[leading[crossAxis]] -= getLeadingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[crossAxis]] -= getTrailingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 递归子视图的布局</span></span><br><span class="line">              layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignItem != CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">          <span class="comment">// 在侧轴上剩余的空间等于父视图在侧轴上的高度减去子视图的在侧轴上padding、Border、Margin以及高度</span></span><br><span class="line">          <span class="keyword">float</span> remainingCrossDim = containerCrossAxis -</span><br><span class="line">            paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (alignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">            leadingCrossDim += remainingCrossDim / <span class="number">2</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// CSS_ALIGN_FLEX_END</span></span><br><span class="line">            leadingCrossDim += remainingCrossDim;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定子视图在侧轴上的坐标位置</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingCrossDim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定trailing的坐标</span></span><br><span class="line">      <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        setTrailingPosition(node, child, crossAxis);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  linesCrossDim += crossDim;</span><br><span class="line">  linesMainDim = fmaxf(linesMainDim, mainDim);</span><br><span class="line">  linesCount += <span class="number">1</span>;</span><br><span class="line">  startLine = endLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的循环D中主要是在侧轴上计算子视图的坐标。如果视图发生了大小变化，还需要递归子视图，重新布局一次。</p><p>再接着是循环E</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (linesCount &gt; <span class="number">1</span> &amp;&amp; isCrossDimDefined) &#123;</span><br><span class="line">  <span class="keyword">float</span> nodeCrossAxisInnerSize = node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">      paddingAndBorderAxisCross;</span><br><span class="line">  <span class="keyword">float</span> remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> crossDimLead = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> currentLead = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 布局alignContent</span></span><br><span class="line">  <span class="keyword">css_align_t</span> alignContent = node-&gt;style.align_content;</span><br><span class="line">  <span class="keyword">if</span> (alignContent == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim / <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeCrossAxisInnerSize &gt; linesCrossDim) &#123;</span><br><span class="line">      crossDimLead = (remainingAlignContentDim / linesCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; linesCount; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每一行的行高，行高根据lineHeight和子视图在侧轴上的高度加上下的Margin之和比较，取最大值</span></span><br><span class="line">    <span class="keyword">float</span> lineHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; childCount; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;line_index != i) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(child, crossAxis)) &#123;</span><br><span class="line">        lineHeight = fmaxf(</span><br><span class="line">          lineHeight,</span><br><span class="line">          child-&gt;layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endIndex = ii;</span><br><span class="line">    lineHeight += crossDimLead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; endIndex; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 布局AlignItem</span></span><br><span class="line">      <span class="keyword">css_align_t</span> alignContentAlignItem = getAlignItem(node, child);</span><br><span class="line">      <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">        <span class="keyword">float</span> childHeight = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">        <span class="comment">// TODO(prenaux): Correctly set the height of items with undefined</span></span><br><span class="line">        <span class="comment">//                (auto) crossAxis dimension.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentLead += lineHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行循环E有一个前提，就是，行数至少要超过一行，并且侧轴上有高度定义。满足了这个前提条件以后才会开始下面的align规则。</p><p>在循环E中会处理侧轴上的align拉伸规则。这里会布局alignContent和AlignItem。</p><p>这块代码实现的算法原理请参见<a href="http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm" rel="external nofollow noopener noreferrer" target="_blank">http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm</a> section 9.4部分。</p><p>至此可能还存在一些没有指定宽和高的视图，接下来将会做最后一次的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个视图没有被指定宽或者高，并且也没有被父视图设置宽和高，那么在这里通过子视图来设置宽和高</span></span><br><span class="line"><span class="keyword">if</span> (!isMainDimDefined) &#123;</span><br><span class="line">  <span class="comment">// 视图的宽度等于内部子视图的宽度加上Trailing的Padding、Border的宽度和主轴上Leading的Padding、Border+ Trailing的Padding、Border，两者取最大值。</span></span><br><span class="line">  node-&gt;layout.dimensions[dim[mainAxis]] = fmaxf(</span><br><span class="line">    boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),</span><br><span class="line">    paddingAndBorderAxisMain</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsMainTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  node-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">    <span class="comment">// 视图的高度等于内部子视图的高度加上上下的Padding、Border的宽度和侧轴上Padding、Border，两者取最大值。</span></span><br><span class="line">    boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsCrossTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些没有确定宽和高的子视图的宽和高会根据父视图来决定。方法见上述代码。</p><p>再就是循环F了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsMainTrailingPos || needsCrossTrailingPos) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; childCount; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsMainTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsCrossTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, crossAxis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步是设置当前node节点的Trailing坐标，如果有必要的话。如果不需要，这一步会直接跳过。</p><p>最后一步就是循环G了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">currentAbsoluteChild = firstAbsoluteChild;</span><br><span class="line"><span class="keyword">while</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">    axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">        !isStyleDimDefined(currentAbsoluteChild, axis) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, leading[axis]) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, trailing[axis])) &#123;</span><br><span class="line">      <span class="comment">// 绝对坐标的子视图在主轴上的宽度，在侧轴上的高度都不能比Padding、Border的总和小。</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">        boundAxis(currentAbsoluteChild, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">          getBorderAxis(node, axis) -</span><br><span class="line">          getMarginAxis(currentAbsoluteChild, axis) -</span><br><span class="line">          getPosition(currentAbsoluteChild, leading[axis]) -</span><br><span class="line">          getPosition(currentAbsoluteChild, trailing[axis])</span><br><span class="line">        ),</span><br><span class="line">        getPaddingAndBorderAxis(currentAbsoluteChild, axis)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPosDefined(currentAbsoluteChild, trailing[axis]) &amp;&amp;</span><br><span class="line">        !isPosDefined(currentAbsoluteChild, leading[axis])) &#123;</span><br><span class="line">      <span class="comment">// 当前子视图的坐标等于当前视图的宽度减去子视图的宽度再减去trailing</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.position[leading[axis]] =</span><br><span class="line">        node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        getPosition(currentAbsoluteChild, trailing[axis]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  child = currentAbsoluteChild;</span><br><span class="line">  currentAbsoluteChild = currentAbsoluteChild-&gt;next_absolute_child;</span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后这一步循环G是用来给绝对坐标的子视图计算宽度和高度。</p><p>执行完上述7个循环以后，所有的子视图就都layout完成了。</p><p>总结一下上述的流程，如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-fc141fa8e3dc0433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="二-Weex布局算法性能分析"><a href="#二-Weex布局算法性能分析" class="headerlink" title="二. Weex布局算法性能分析"></a>二. Weex布局算法性能分析</h3><h4 id="1-算法实现分析"><a href="#1-算法实现分析" class="headerlink" title="1.算法实现分析"></a>1.算法实现分析</h4><p>上一章节看了Weex的layout算法实现。这里就分析一下在这个实现下，布局能力究竟有多强。</p><p>Weex的实现是FaceBook的开源库Yoga的前身，所以这里可以把两个看成是一种实现。</p><p>Weex的这种FlexBox的实现其实只是W3C标准的一个实现的子集，因为FlexBox的官方标准里面还有一些并没有实现出来。W3C上定义的FlexBox的标准，文档在<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p><p>FlexBox标准定义：</p><p>针对父视图 (flex container):</p><ol><li>display</li><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ol><p>针对子视图 (flex items):</p><ol><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/1194012-63e820c1ee9472cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>相比官方的定义，上述的实现有一些限制：</p><ol><li>所有显示属性的node节点都默认假定是Flex的视图，当然这里要除去文本节点，因为它会被假定为inline-flex。</li><li>不支持zIndex的属性，包括任何z上的排序。所有的node节点都是按照代码书写的先后顺序进行排列的。Weex 目前也不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。</li><li>FlexBox里面定义的order属性，也不支持。flex item默认按照代码书写顺序。</li><li>visibility属性默认都是可见的，暂时不支持边缘塌陷合并(collapse)和隐藏(hidden)属性。</li><li>不支持forced breaks。</li><li>不支持垂直方向的inline(比如从上到下的text，或者从下到上的text)</li></ol><p>关于Flexbox 在iOS这边的具体实现上一章节已经分析过了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-2a97e349befdc557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>接下来仔细分析一下Autolayout的具体实现</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b994236e0c27d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>原来我们用Frame进行布局的时候，需要知道一个点（origin或者center）和宽高就可以确定一个View。</p><p>现在换成了Autolayout，每个View需要知道4个尺寸。left，top，width，height。</p><p>但是一个View的约束是相对于另一个View的，比如说相对于父视图，或者是相对于两两View之间的。</p><p>那么两两个View之间的约束就会变成一个八元一次的方程组。</p><p>解这个方程组可能有以下3种情况：</p><ol><li>当方程组的解的个数有无穷多个，最终会得到欠约束的有歧义的布局。</li><li>当方程无解时，则表示约束有冲突。</li><li>只有当方程组有唯一解的时候，才能得到一个稳定的布局。</li></ol><p><strong>Autolayout 本质是一个线性方程解析器，该解析器试图找到一种可满足其规则的几何表达式。</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-09b7902e4c7c67e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>Autolayout的底层数学模型是线性算术约束问题。</p><p>关于这个问题，早在1940年，由Dantzig提出了一个the simplex algorithm算法，但是由于这个算法实在很难用在UI应用上面，所以没有得到很广泛的应用，直到1997年，澳大利亚的莫纳什大学（Monash University）的两名学生，Alan Borning 和 Kim Marriott实现了Cassowary线性约束算法，才得以在UI应用上被大量的应用起来。</p><p>Cassowary线性约束算法是基于双simplex算法的，在增加约束或者一个对象被移除的时候，通过局部误差增益 和 加权求和比较 ，能够完美的增量处理不同层次的约束。Cassowary线性约束算法适合GUI布局系统，被用来计算view之间的位置的。开发者可以指定不同View之间的位置关系和约束关系，Cassowary线性约束算法会去求处符合条件的最优值。</p><p>下面是两位学生写的相关的论文，有兴趣的可以读一下，了解一下算法的具体实现：</p><ol><li>Alan Borning, Kim Marriott, Peter Stuckey, and Yi Xiao, <a href="https://constraints.cs.washington.edu/solvers/uist97.pdf" rel="external nofollow noopener noreferrer" target="_blank">Solving Linear Arithmetic Constraints for User Interface Applications</a>, Proceedings of the 1997 ACM Symposium on User Interface Software and Technology, October 1997, pages 87-96.</li><li>Greg J. Badros and Alan Borning, “The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation”, Technical Report UW-CSE-98-06-04, June 1998 (<a href="https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li><li>Greg J. Badros, Alan Borning, and Peter J. Stuckey, “The Cassowary Linear Arithmetic Constraint Solving Algorithm,” <em>ACM Transactions on Computer Human Interaction</em>, Vol. 8 No. 4, December 2001, pages 267-306. (<a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li></ol><p>Cassowary线性约束算法的伪代码如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-2f208ced7d958ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>关于这个算法已经被人们实现成了各个版本。1年以后，又出了一个新的QOCA算法。以下这段话摘抄自1997年ACM权威论文上的一篇文章：</p><blockquote><p>Both of our algorithms have been implemented, Cassowary<br>in Smalltalk and QOCA in C++. They perform surprisingly<br>well. The QOCA implementation is considerably more sophisticated<br>and has much better performance than the current version of<br>Cassowary. However, QOCA is inherently a more complex<br>algorithm, and re-implementing it with a comparable level<br>of performance would be a daunting task. In contrast, Cassowary<br>is straightforward, and a reimplementation based on<br>this paper is more reasonable, given a knowledge of the simplex<br>algorithm.</p></blockquote><p>Cassowary（<a href="https://constraints.cs.washington.edu/cassowary/" rel="external nofollow noopener noreferrer" target="_blank">项目主页</a>）也是优先被Smalltalk实现了，也是用在Autolayout技术上。另外还有更加复杂的QOCA算法，这里就不再细谈了，有兴趣的同学可以看看上面三篇论文，里面有详细的描述。</p><h4 id="2-算法性能测试准备工作"><a href="#2-算法性能测试准备工作" class="headerlink" title="2.算法性能测试准备工作"></a>2.算法性能测试准备工作</h4><p>开始笔者是打算连带Weex的布局性能一起测试的，但是由于Weex的布局都在子线程，刷新渲染回到主线程，需要测试都在主线程的情况需要改动一些代码，而且Weex原生的布局是从JS调用方法，如果用这种方法又会多损耗一些性能，对测试结果有影响。于是换成Weex相同布局方式的Yoga算法进行测试。由于Facebook对它进行了很好的封装，使用起来也很方便。虽然Layout算法和Weex有些差异，但是不影响定性的比较。</p><p>确定下来测试对象：Frame，FlexBox(Yoga实现)，Autolayout。</p><p>测试前，还需要准备测试模型，这里选出了3种测试模型。</p><p>第一种测试模型是随机生成完全不相关联的View。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-a7a0d48cba94f3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第二种测试模型是生成相互嵌套的View。嵌套规则设置一个简单的：子视图依次比父视图高度少一个像素。类似下图，这是500个View相互嵌套的结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-0828ddc58f8d30ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>第三种测试模型是针对Autolayout专门加的。由于Autolayout约束的特殊性，这里针对链式约束额外增加的测试模型。规则是前后两个相连的View之间依次加上约束。类似下图，这是500个View链式的约束结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-1b8f68cd9debed67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>根据测试模型，我们可以得到如下的7组需要测试的测试用例：</p><p>1.Frame<br>2.嵌套的Frame<br>3.Yoga<br>4.嵌套的Yoga<br>5.Autolayout<br>6.嵌套的Autolayout<br>7.链式的Autolayout</p><p>测试样本：由于需要考虑到测试的通用性，测试样本要尽量随机。于是针对随机生成的坐标全部都随机生成，View的颜色也全部都随机生成，这样保证了通用公正公平性质。</p><p>测试次数：为了保证测试数据能尽量真实，笔者在这里花了大量的时间。每组测试用例都针对从100，200，300，400，500，600，700，800，900，1000个视图进行测试，为了保证测试的普遍性，这里每次测试都测试10000次，然后对10000次的结果进行加和平均。加和平均取小数点后5位。（10000次的统计是用计算机来算的，但是真的非常非常非常的耗时，有兴趣的可以自己用电脑试试）</p><p>最后展示一下测试机器的配置和系统版本：</p><p>（由于iPhone真机对每个App的内存有限制，产生1000个嵌套的视图，并且进行10000次试验，iPhone真机完全受不了这种计算量，App直接闪退，所以用真机测试到一半，改用模拟器测试，借助Mac的性能，咬着牙从零开始，重新统计了所有测试用例的数据）</p><p>如果有性能更强的Mac电脑（垃圾桶），测试全过程花的时间可能会更少。</p><p>笔者用的电脑的配置如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-510c7d7ab97e2330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>测试用的模拟器是iPad Pro（12.9 inch）iOS 10.3（14E269）</p><p>我所用的测试代码也公布出来，有兴趣的可以自己测试测试。<a href="https://github.com/halfrost/Halfrost-Field/tree/master/contents/iOS/AutoLayoutProfiling-master" rel="external nofollow noopener noreferrer" target="_blank">测试代码在这里</a>  </p><h4 id="3-算法性能测试结果"><a href="#3-算法性能测试结果" class="headerlink" title="3.算法性能测试结果"></a>3.算法性能测试结果</h4><p>公布测试结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-34171d65db564340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图数据是10，20，30，40，50，60，70，80，90，100个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-f9468b0f10f0ef95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>结果依旧是Autolayout的3种方式都高于其他4种布局方式。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-7f51f5e34c9e5485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-64f5f7c2e89e2661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-409f0c3e820c5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最后这张图也是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，嵌套的Autolayout的性能依旧是最差的！</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b338b4507694268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图数据是100，200，300，400，500，600，700，800，900，1000个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-e60d70a0eaa4a67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>当视图多到900，1000的时候，嵌套的Autolayout直接就导致模拟器崩溃了。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-4560c9da3bfa0968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-cad15676ac4504b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-c71dbeba866e73fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最后这张图是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，平时我们使用嵌套的Autolayout的性能是最差的！</p><h3 id="三-Weex是如何布局原生界面的"><a href="#三-Weex是如何布局原生界面的" class="headerlink" title="三. Weex是如何布局原生界面的"></a>三. Weex是如何布局原生界面的</h3><p>上一章节看了FlexBox算法的强大布局能力，这一章节就来看看Weex究竟是如何利用这个能力的对原生View进行Layout。</p><p>在解答上面这个问题之前，先让我们回顾一下上篇文章<a href="http://www.jianshu.com/p/41cde2c62b81" rel="external nofollow noopener noreferrer" target="_blank">《Weex 是如何在 iOS 客户端上跑起来的》</a>里面提到的，在JSFramework转换从网络上下载下来的JS文件之前，本地先注册了4个重要的回调函数。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallNative)(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallAddElement)(<span class="built_in">NSString</span> *instanceId,  <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInvocation</span> *(^WXJSCallNativeModule)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^WXJSCallNativeComponent)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br></pre></td></tr></table></figure><p>这4个block非常重要，是JS和OC进行相互调用的四大函数。</p><p>先来回顾一下这四大函数注册的时候分别封装了哪些闭包。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXBridgeContext</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;WXBridgeProtocol&gt;  jsBridge;</span><br></pre></td></tr></table></figure><p>在WXBridgeContext类里面有一个jsBridge。jsBridge初始化的时候会注册这4个全局函数。</p><p>第一个闭包函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallNative:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> [weakSelf invokeNative:instance tasks:tasks callback:callback];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这里的闭包函数会被传入到下面这个函数中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceId = [instance toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *tasksArray = [tasks toArray];</span><br><span class="line">        <span class="built_in">NSString</span> *callbackId = [callback toString];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"Calling native... instance:%@, tasks:%@, callback:%@"</span>, instanceId, tasksArray, callbackId);</span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _jsContext[<span class="string">@"callNative"</span>] = callNativeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就封装了一个函数，暴露给JS用。方法名叫callNative，函数参数为3个，分别是instanceId，tasksArray任务数组，callbackId回调ID。</p><p>所有的OC的闭包都需要封装一层，因为暴露给JS的方法不能有冒号，所有的参数都是直接跟在小括号的参数列表里面的，因为JS的函数是这样定义的。</p><p>当JS调用callNative方法之后，就会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p><p>第二个闭包函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个闭包会被传到下面的函数中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *componentData = [element toDictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *parentRef = [ref toString];</span><br><span class="line">        <span class="built_in">NSInteger</span> insertIndex = [[index toNumber] integerValue];</span><br><span class="line">        </span><br><span class="line">         WXLogDebug(<span class="string">@"callAddElement...%@, %@, %@, %ld"</span>, instanceIdString, parentRef, componentData, (<span class="keyword">long</span>)insertIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _jsContext[<span class="string">@"callAddElement"</span>] = callAddElementBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的包装方法和第一个方法是相同的。这里暴露给JS的方法名叫callAddElement，函数参数为4个，分别是instanceIdString，componentData组件的数据，parentRef引用编号，insertIndex插入视图的index。</p><p>当JS调用callAddElement方法，就会最终执行WXBridgeContext类里面的WXPerformBlockOnComponentThread闭包。</p><p>第三个闭包函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeModule:^<span class="built_in">NSInvocation</span>*(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *arguments, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found for callNativeModule:%@.%@, maybe already destroyed"</span>, moduleName, methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">    <span class="keyword">return</span> [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个闭包会被传到下面的函数中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeModule"</span>] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *moduleNameString = [moduleName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeModule...%@,%@,%@,%@"</span>, instanceIdString, moduleNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = callNativeModuleBlock(instanceIdString, moduleNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">        JSValue *returnValue = [JSValue wx_valueWithReturnValueFromInvocation:invocation inContext:[JSContext currentContext]];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暴露给JS的方法名叫callNativeModule，函数参数为5个，分别是instanceIdString，moduleNameString模块名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p><p>当JS调用callNativeModule方法，就会最终执行WXBridgeContext类里面的WXModuleMethod方法。</p><p>第四个闭包函数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeComponent:^<span class="keyword">void</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:componentRef methodName:methodName arguments:args instance:instance];</span><br><span class="line">    [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>这个闭包会被传到下面的函数中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeComponent:(WXJSCallNativeComponent)callNativeComponentBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeComponent"</span>] = ^<span class="keyword">void</span>(JSValue *instanceId, JSValue *componentName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *componentNameString = [componentName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeComponent...%@,%@,%@,%@"</span>, instanceIdString, componentNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        callNativeComponentBlock(instanceIdString, componentNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里暴露给JS的方法名叫callNativeComponent，函数参数为5个，分别是instanceIdString，componentNameString组件名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p><p>当JS调用callNativeComponent方法，就会最终执行WXBridgeContext类里面的WXComponentMethod方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-23bfe161375b750a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>总结一下上述暴露给JS的4个方法：</p><ol><li><p>callNative<br>这个方法是JS用来调用任意一个Native方法的。</p></li><li><p>callAddElement<br>这个方法是JS用来给当前页面添加视图元素的。</p></li><li><p>callNativeModule<br>这个方法是JS用来调用模块里面暴露出来的方法。</p></li><li><p>callNativeComponent<br>这个方法是JS用来调用组件里面暴露出来的方法。</p></li></ol><p>Weex在布局的时候就只会用到前2个方法。</p><p>####（一）createRoot:</p><p>当JSFramework把JS文件转换类似JSON的文件之后，就开始调用Native的callNative方法。</p><p>callNative方法会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p><p>当前操作处于子线程“com.taobao.weex.bridge”中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)invokeNative:(<span class="built_in">NSString</span> *)instanceId tasks:(<span class="built_in">NSArray</span> *)tasks callback:(<span class="built_in">NSString</span> __unused*)callback</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertBridgeThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instanceId || !tasks) &#123;</span><br><span class="line">        WX_MONITOR_FAIL(WXMTNativeRender, WX_ERR_JSFUNC_PARAM, <span class="string">@"JS call Native params error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance already destroyed, task ignored"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据JS发送过来的方法，进行转换成Native方法调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *methodName = task[<span class="string">@"method"</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *arguments = task[<span class="string">@"args"</span>];</span><br><span class="line">        <span class="keyword">if</span> (task[<span class="string">@"component"</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *ref = task[<span class="string">@"ref"</span>];</span><br><span class="line">            WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:ref methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *moduleName = task[<span class="string">@"module"</span>];</span><br><span class="line">            WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有回调，回调给JS</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_sendQueueLoop) withObject:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会把JS从发送过来的callNative方法转换成Native的组件component的方法调用或者模块module的方法调用。</p><p>举个例子：</p><p>JS从callNative方法传过来3个参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">instance:0,</span><br><span class="line"></span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">                        &#123;</span><br><span class="line">                attr =                 &#123;</span><br><span class="line">                &#125;;</span><br><span class="line">                ref = &quot;_root&quot;;</span><br><span class="line">                style =                 &#123;</span><br><span class="line">                    alignItems = center;</span><br><span class="line">                &#125;;</span><br><span class="line">                type = div;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        method = createBody;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line"></span><br><span class="line">callback:-1</span><br></pre></td></tr></table></figure><p>tasks数组里面会解析出各个方法和调用者。</p><p>这个例子里面就会解析出Dom模块的createBody方法。</p><p>接着就会调用Dom模块的createBody方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="keyword">return</span> invocation;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法之前，有一个线程切换的步骤。如果是同步方法，那么就直接调用，如果是异步方法，那么嗨需要进行线程转换。</p><p>Dom模块的createBody方法是异步的方法，于是就需要调用_dispatchInvocation: moduleInstance:方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_dispatchInvocation:(<span class="built_in">NSInvocation</span> *)invocation moduleInstance:(<span class="keyword">id</span>&lt;WXModuleProtocol&gt;)moduleInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dispatch to user specified queue or thread, default is main thread</span></span><br><span class="line">    dispatch_block_t dispatchBlock = ^ ()&#123;</span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *targetThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteQueue)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Queue，如果没有，就返回main_queue，如果有，就切换到targetQueue</span></span><br><span class="line">        targetQueue = [moduleInstance targetExecuteQueue] ?: dispatch_get_main_queue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteThread)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Thread，如果没有，就返回主线程，如果有，就切换到targetThread</span></span><br><span class="line">        targetThread = [moduleInstance targetExecuteThread] ?: [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetThread = [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXAssert(targetQueue || targetThread, <span class="string">@"No queue or thread found for module:%@"</span>, moduleInstance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (targetQueue) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(targetQueue, dispatchBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WXPerformBlockOnThread(^&#123;</span><br><span class="line">            dispatchBlock();</span><br><span class="line">        &#125;, targetThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个Weex模块中，目前只有2个模块是有targetQueue的，一个是WXClipboardModule，另一个是WXStorageModule。所以这里没有targetQueue，就只能切换到对应的targetThread上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> WXPerformBlockOnThread(<span class="keyword">void</span> (^ _Nonnull block)(), <span class="built_in">NSThread</span> *thread)</span><br><span class="line">&#123;</span><br><span class="line">    [WXUtility performBlock:block onThread:thread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)performBlock:(<span class="keyword">void</span> (^)())block onThread:(<span class="built_in">NSThread</span> *)thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!thread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程不是目标线程上，就要切换线程</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] == thread) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_performBlock:)</span><br><span class="line">                     onThread:thread</span><br><span class="line">                   withObject:[block <span class="keyword">copy</span>]</span><br><span class="line">                waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是切换线程的操作，如果当前线程不是目标线程，就要切换线程。在目标线程上调用_performBlock:方法，入参还是最初传进来的block闭包。</p><p>切换前线程处于子线程“com.taobao.weex.bridge”中。</p><p>在WXDomModule中调用targetExecuteThread方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSThread</span> *)targetExecuteThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [WXComponentManager componentThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切换线程之后，当前线程变成了“com.taobao.weex.component”。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createBody:(<span class="built_in">NSDictionary</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createRoot:body];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performBlockOnComponentManager:(<span class="keyword">void</span>(^)(WXComponentManager *))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = weakSelf.weexInstance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启组件任务</span></span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        block(manager);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用了Dom模块的createBody方法以后，会先调用WXComponentManager的startComponentTasks方法，再调用createRoot:方法。</p><p>这里会初始化一个WXComponentManager。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponentManager *)componentManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_componentManager) &#123;</span><br><span class="line">        _componentManager = [[WXComponentManager alloc] initWithWeexInstance:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _componentManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWeexInstance:(<span class="keyword">id</span>)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        </span><br><span class="line">        _indexDict = [<span class="built_in">NSMapTable</span> strongToWeakObjectsMapTable];</span><br><span class="line">        _fixedComponents = [<span class="built_in">NSMutableArray</span> wx_mutableArrayUsingWeakReferences];</span><br><span class="line">        _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _isValid = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> _startDisplayLink];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WXComponentManager的初始化重点是会开启DisplayLink，它会开启一个runloop。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_startDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!_displayLink)&#123;</span><br><span class="line">        _displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_handleDisplayLink)];</span><br><span class="line">        [_displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>displayLink一旦开启，被加入到当前runloop之中，每次runloop循环一次都会执行刷新布局的方法_handleDisplayLink。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startComponentTasks</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> _awakeDisplayLink];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_awakeDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    <span class="keyword">if</span>(_displayLink &amp;&amp; _displayLink.paused) &#123;</span><br><span class="line">        _displayLink.paused = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WXComponentManager的startComponentTasks方法仅仅是更改了CADisplayLink的paused的状态。CADisplayLink就是用来刷新layout的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WXComponentManager</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对WXSDKInstance的弱引用</span></span><br><span class="line">    __<span class="keyword">weak</span> WXSDKInstance *_weexInstance;</span><br><span class="line">    <span class="comment">// 当前WXComponentManager是否可用</span></span><br><span class="line">    <span class="built_in">BOOL</span> _isValid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否停止刷新布局</span></span><br><span class="line">    <span class="built_in">BOOL</span> _stopRunning;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _noTaskTickCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// access only on component thread</span></span><br><span class="line">    <span class="built_in">NSMapTable</span>&lt;<span class="built_in">NSString</span> *, WXComponent *&gt; *_indexDict;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;dispatch_block_t&gt; *_uiTaskQueue;</span><br><span class="line">    </span><br><span class="line">    WXComponent *_rootComponent;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_fixedComponents;</span><br><span class="line">    </span><br><span class="line">    css_node_t *_rootCSSNode;</span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_displayLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是WXComponentManager的所有属性，可以看出WXComponentManager就是用来处理UI任务的。</p><p>再来看看createRoot:方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createRoot:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    WXAssertParam(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建WXComponent，作为rootComponent</span></span><br><span class="line">    _rootComponent = [<span class="keyword">self</span> _buildComponentForData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.初始化css_node_t，作为rootCSSNode</span></span><br><span class="line">    [<span class="keyword">self</span> _initRootCSSNode];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 3.添加UI任务到uiTaskQueue数组中</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">        [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里干了3件事情:</p><h4 id="1-创建WXComponent"><a href="#1-创建WXComponent" class="headerlink" title="1.创建WXComponent"></a>1.创建WXComponent</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponent *)_buildComponentForData:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *ref = data[<span class="string">@"ref"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *type = data[<span class="string">@"type"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *styles = data[<span class="string">@"style"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = data[<span class="string">@"attr"</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *events = data[<span class="string">@"event"</span>];</span><br><span class="line">        </span><br><span class="line">    Class clazz = [WXComponentFactory classWithComponentName:type];</span><br><span class="line">    WXComponent *component = [[clazz alloc] initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:<span class="keyword">self</span>.weexInstance];</span><br><span class="line">    WXAssert(component, <span class="string">@"Component build failed for data:%@"</span>, data);</span><br><span class="line">    </span><br><span class="line">    [_indexDict setObject:component forKey:component.ref];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的入参data是之前的tasks数组。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                     styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pthread_mutexattr_init(&amp;_propertMutexAttr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;_propertMutexAttr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        pthread_mutex_init(&amp;_propertyMutex, &amp;_propertMutexAttr);</span><br><span class="line">        </span><br><span class="line">        _ref = ref;</span><br><span class="line">        _type = type;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        _styles = [<span class="keyword">self</span> parseStyles:styles];</span><br><span class="line">        _attributes = attributes ? [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:attributes] : [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _events = events ? [<span class="built_in">NSMutableArray</span> arrayWithArray:events] : [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _subcomponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        _absolutePosition = <span class="built_in">CGPointMake</span>(NAN, NAN);</span><br><span class="line">        </span><br><span class="line">        _isNeedJoinLayoutSystem = <span class="literal">YES</span>;</span><br><span class="line">        _isLayoutDirty = <span class="literal">YES</span>;</span><br><span class="line">        _isViewFrameSyncWithCalculated = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        _async = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//TODO set indicator style </span></span><br><span class="line">        <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"indicator"</span>]) &#123;</span><br><span class="line">            _styles[<span class="string">@"position"</span>] = <span class="string">@"absolute"</span>;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"left"</span>] &amp;&amp; !_styles[<span class="string">@"right"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"left"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"top"</span>] &amp;&amp; !_styles[<span class="string">@"bottom"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"top"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置NavBar的Style</span></span><br><span class="line">        [<span class="keyword">self</span> _setupNavBarWithStyles:_styles attributes:_attributes];</span><br><span class="line">        <span class="comment">// 根据style初始化cssNode数据结构</span></span><br><span class="line">        [<span class="keyword">self</span> _initCSSNodeWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 根据style初始化View的各个属性</span></span><br><span class="line">        [<span class="keyword">self</span> _initViewPropertyWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 处理Border的圆角，边线宽度，背景颜色等属性</span></span><br><span class="line">        [<span class="keyword">self</span> _handleBorders:styles isUpdating:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述函数就是初始化WXComponent的布局的各个属性。这里会用到FlexBox里面的一些计算属性的方法就在_initCSSNodeWithStyles:方法里面。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initCSSNodeWithStyles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">&#123;</span><br><span class="line">    _cssNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    _cssNode-&gt;print = cssNodePrint;</span><br><span class="line">    _cssNode-&gt;get_child = cssNodeGetChild;</span><br><span class="line">    _cssNode-&gt;is_dirty = cssNodeIsDirty;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> measureBlock]) &#123;</span><br><span class="line">        _cssNode-&gt;measure = cssNodeMeasure;</span><br><span class="line">    &#125;</span><br><span class="line">    _cssNode-&gt;context = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新计算_cssNode需要布局的子视图个数</span></span><br><span class="line">    [<span class="keyword">self</span> _recomputeCSSNodeChildren];</span><br><span class="line">    <span class="comment">// 将style各个属性都填充到cssNode数据结构中</span></span><br><span class="line">    [<span class="keyword">self</span> _fillCSSNode:styles];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// To be in conformity with Android/Web, hopefully remove this in the future.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.ref isEqualToString:WX_SDK_ROOT_REF]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_HEIGHT]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.height) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_HEIGHT] = <span class="keyword">self</span>.weexInstance.frame.size.height;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_WIDTH]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.width) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_WIDTH] = <span class="keyword">self</span>.weexInstance.frame.size.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在_fillCSSNode:方法里面会对FlexBox算法里面定义的各个属性值就行赋值。</p><h4 id="2-初始化css-node-t"><a href="#2-初始化css-node-t" class="headerlink" title="2.初始化css_node_t"></a>2.初始化css_node_t</h4><p>在这里，准备开始Layout之前，我们需要先初始化rootCSSNode</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initRootCSSNode</span><br><span class="line">&#123;</span><br><span class="line">    _rootCSSNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据页面weexInstance设置rootCSSNode的坐标和宽高尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> _applyRootFrame:<span class="keyword">self</span>.weexInstance.frame toRootCSSNode:_rootCSSNode];</span><br><span class="line">    </span><br><span class="line">    _rootCSSNode-&gt;style.flex_wrap = CSS_NOWRAP;</span><br><span class="line">    _rootCSSNode-&gt;is_dirty = rootNodeIsDirty;</span><br><span class="line">    _rootCSSNode-&gt;get_child = rootNodeGetChild;</span><br><span class="line">    _rootCSSNode-&gt;context = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    _rootCSSNode-&gt;children_count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述方法中，会初始化rootCSSNode的坐标和宽高尺寸。</p><h4 id="3-添加UI任务到uiTaskQueue数组中"><a href="#3-添加UI任务到uiTaskQueue数组中" class="headerlink" title="3.添加UI任务到uiTaskQueue数组中"></a>3.添加UI任务到uiTaskQueue数组中</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">    [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>WXComponentManager会把当前的组件以及它对应的View添加到页面Instance的rootView上面的这个任务，添加到uiTaskQueue数组中。</p><p>_rootComponent.view会创建组件对应的WXView，这个是继承自UIView的。所以Weex通过JS代码创建出来的控件都是原生的，都是WXView类型的，实质就是UIView。创建UIView这一步又是回到主线程中执行的。</p><p>最后显示到页面上的工作，是由displayLink的刷新方法在主线程刷新UI显示的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_handleDisplayLink</span><br><span class="line">&#123; </span><br><span class="line">    [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layoutAndSyncUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Flexbox布局</span></span><br><span class="line">    [<span class="keyword">self</span> _layout];</span><br><span class="line">    <span class="keyword">if</span>(_uiTaskQueue.count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 同步执行UI任务</span></span><br><span class="line">        [<span class="keyword">self</span> _syncUITasks];</span><br><span class="line">        _noTaskTickCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前一秒内没有任务，那么智能的挂起displaylink，以节约CPU时间</span></span><br><span class="line">        _noTaskTickCount ++;</span><br><span class="line">        <span class="keyword">if</span> (_noTaskTickCount &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _suspendDisplayLink];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_layoutAndSyncUI是布局和刷新UI的核心流程。每次刷新一次，都会先调用Flexbox算法的Layout进行布局，这个布局是在子线程“com.taobao.weex.component”执行的。接着再去查看当前是否有UI任务需要执行，如果有，就切换到主线程进行UI刷新操作。</p><p>这里还会有一个智能的挂起操作。就是判断一秒内如果都没有任务，那么就挂起displaylink，以节约CPU时间。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> needsLayout = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = [_indexDict objectEnumerator];</span><br><span class="line">    WXComponent *component;</span><br><span class="line">    <span class="comment">// 判断当前是否需要布局，即是判断当前组件的_isLayoutDirty这个BOLL属性值</span></span><br><span class="line">    <span class="keyword">while</span> ((component = [enumerator nextObject])) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([component needsLayout]) &#123;</span><br><span class="line">            needsLayout = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!needsLayout) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Flexbox的算法核心函数</span></span><br><span class="line">    layoutNode(_rootCSSNode, _rootCSSNode-&gt;style.dimensions[CSS_WIDTH], _rootCSSNode-&gt;style.dimensions[CSS_HEIGHT], CSS_DIRECTION_INHERIT);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableSet</span>&lt;WXComponent *&gt; *dirtyComponents = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    [_rootComponent _calculateFrameWithSuperAbsolutePosition:<span class="built_in">CGPointZero</span> gatherDirtyComponents:dirtyComponents];</span><br><span class="line">    <span class="comment">// 计算当前weexInstance的rootView.frame，并且重置rootCSSNode的Layout</span></span><br><span class="line">    [<span class="keyword">self</span> _calculateRootFrame];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在每个需要布局的组件之间</span></span><br><span class="line">    <span class="keyword">for</span> (WXComponent *dirtyComponent <span class="keyword">in</span> dirtyComponents) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">            [dirtyComponent _layoutDidFinish];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_indexDict里面维护了一张整个页面的布局结构的Map，举个例子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMapTable</span> &#123;</span><br><span class="line">[<span class="number">7</span>] _root -&gt; &lt;div ref=_root&gt; &lt;WXView: <span class="number">0x7fc59a416140</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">331.333</span> <span class="number">331.333</span>); layer = &lt;WXLayer: <span class="number">0x608000223180</span>&gt;&gt;</span><br><span class="line">[<span class="number">12</span>] <span class="number">5</span> -&gt; &lt;image ref=<span class="number">5</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a724430</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">192.333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; layer = &lt;WXLayer: <span class="number">0x60000002f780</span>&gt;&gt;</span><br><span class="line">[<span class="number">13</span>] <span class="number">3</span> -&gt; &lt;image ref=<span class="number">3</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a617a00</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">55.3333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; opaque = <span class="literal">NO</span>; gestureRecognizers = &lt;<span class="built_in">NSArray</span>: <span class="number">0x60000024b760</span>&gt;; layer = &lt;WXLayer: <span class="number">0x60000003e8c0</span>&gt;&gt;</span><br><span class="line">[<span class="number">15</span>] <span class="number">4</span> -&gt; &lt;text ref=<span class="number">4</span>&gt; &lt;WXText: <span class="number">0x7fc59a509840</span>; text: hello Weex; frame:<span class="number">0.000000</span>,<span class="number">441.666667</span>,<span class="number">331.333333</span>,<span class="number">26.666667</span> frame = (<span class="number">0</span> <span class="number">441.667</span>; <span class="number">331.333</span> <span class="number">26.6667</span>); opaque = <span class="literal">NO</span>; layer = &lt;WXLayer: <span class="number">0x608000223480</span>&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的组件都是由ref引用值作为Key存储的，只要知道这个页面上全局唯一的ref，就可以拿到这个ref对应的组件。</p><p>_layout会先判断当前是否有需要布局的组件，如果有，就从rootCSSNode开始进行Flexbox算法的Layout。执行完成以后还需要调整一次rootView的frame，最后添加一个UI任务到taskQueue中，这个任务标记的是组件布局完成。</p><p>注意上述所有布局操作都是在子线程“com.taobao.weex.component”中执行的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_syncUITasks</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用blocks接收原来uiTaskQueue里面的所有任务</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;dispatch_block_t&gt; *blocks = _uiTaskQueue;</span><br><span class="line">    <span class="comment">// 清空uiTaskQueue</span></span><br><span class="line">    _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 在主线程中依次执行uiTaskQueue里面的所有闭包</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">for</span>(dispatch_block_t block <span class="keyword">in</span> blocks) &#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>布局完成以后就调用同步的UI刷新方法。注意这里要对UI进行操作，一定要切换回主线程。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b16532cf00e3f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>####（二）callAddElement</p><p>在子线程“com.taobao.weex.bridge”中，会一直相应来自JSFramework调用Native的方法。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>当JSFramework调用callAddElement方法，就会执行上述代码的闭包函数。这里会接收来自JS的4个入参。</p><p>举个例子，JSFramework可能会通过callAddElement方法传过来这样4个参数：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">_root, </span><br><span class="line">&#123;</span><br><span class="line">    attr =     &#123;</span><br><span class="line">        value = <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ref = <span class="number">4</span>;</span><br><span class="line">    style =     &#123;</span><br><span class="line">        color = <span class="string">"#000000"</span>;</span><br><span class="line">        fontSize = <span class="number">40</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    type = text;</span><br><span class="line">&#125;, </span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure><p>这里的insertIndex为0，parentRef是_root，componentData是当前要创建的组件的信息，instanceIdString是-1。</p><p>之后WXComponentManager就会调用startComponentTasks开始displaylink继续准备刷新布局，最后调用addComponent: toSupercomponent: atIndex: appendingInTree:方法添加新的组件。</p><p>注意，WXComponentManager的这两步操作，又要切换线程，切换到“com.taobao.weex.component”子线程中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(<span class="built_in">NSString</span> *)superRef atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *supercomponent = [_indexDict objectForKey:superRef];</span><br><span class="line">    WXAssertComponentExist(supercomponent);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _recursivelyAddComponent:componentData toSupercomponent:supercomponent atIndex:index appendingInTree:appendingInTree];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WXComponentManager会在“com.taobao.weex.component”子线程中递归的添加子组件。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_recursivelyAddComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据componentData构建组件</span></span><br><span class="line">    WXComponent *component = [<span class="keyword">self</span> _buildComponentForData:componentData];</span><br><span class="line">    </span><br><span class="line">    index = (index == <span class="number">-1</span> ? supercomponent-&gt;_subcomponents.count : index);</span><br><span class="line">    </span><br><span class="line">    [supercomponent _insertSubcomponent:component atIndex:index];</span><br><span class="line">    <span class="comment">// 用_lazyCreateView标识懒加载</span></span><br><span class="line">    <span class="keyword">if</span>(supercomponent &amp;&amp; component &amp;&amp; supercomponent-&gt;_lazyCreateView) &#123;</span><br><span class="line">        component-&gt;_lazyCreateView = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入一个UI任务</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        [supercomponent insertSubview:component atIndex:index];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *subcomponentsData = [componentData valueForKey:<span class="string">@"children"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class="string">@"append"</span>] isEqualToString:<span class="string">@"tree"</span>];</span><br><span class="line">    <span class="comment">// 再次递归的规则：如果父视图是一个树状结构，子视图即使也是一个树状结构，也不能再次Layout</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSDictionary</span> *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [<span class="keyword">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class="number">-1</span> appendingInTree:appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (appendTree) &#123;</span><br><span class="line">        <span class="comment">// 如果当前组件是树状结构，强制刷新layout，以防在syncQueue中堆积太多的同步任务。</span></span><br><span class="line">        [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在递归的添加子组件的时候，如果是树状结构，还需要再次强制进行一次layout，同步一次UI。这里调用[self _layoutAndSyncUI]方法和createRoot:时候实现是完全一样的，下面就不再赘述了。</p><p>这里会循环添加多个子视图，相应的也会调用多次Layout方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-d1f730e3bee34bdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="（三）createFinish"><a href="#（三）createFinish" class="headerlink" title="（三）createFinish"></a>（三）createFinish</h4><p>当所有的视图都添加完成以后，JSFramework就是再次调用callNative方法。</p><p>还是会传过来3个参数。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">instance:<span class="number">0</span>, </span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">        );</span><br><span class="line">        method = createFinish;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line">callback:<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>callNative通过这个参数会调用到WXDomModule的createFinish方法。这里的具体实现见第一步的callNative，这里不再赘述。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createFinish];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终也是会调用到WXComponentManager的createFinish。当然这里是会进行线程切换，切换到WXComponentManager的线程“com.taobao.weex.component”子线程上。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    WXSDKInstance *instance  = <span class="keyword">self</span>.weexInstance;</span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;        </span><br><span class="line">        <span class="built_in">UIView</span> *rootView = instance.rootView;</span><br><span class="line">        </span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTFirstScreenRender, instance);</span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTAllRender, instance);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTJSBridge);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTNativeRender);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(instance.renderFinish)&#123;</span><br><span class="line">            instance.renderFinish(rootView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WXComponentManager的createFinish方法最后就是添加一个UI任务，回调到主线程的renderFinish方法里面。</p><p><img src="http://upload-images.jianshu.io/upload_images/1194012-2896c636f11b2202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>至此，Weex的布局流程就完成了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-caf559cea2e73cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>虽然Autolayout是苹果原生就支持的自动布局方案，但是在稍微复杂的界面就会出现性能问题。大半年前，Draveness的这篇<a href="http://draveness.me/layout-performance/" rel="external nofollow noopener noreferrer" target="_blank">《从 Auto Layout 的布局算法谈性能》</a>文章里面也稍微“批判”了Autolayout的性能问题，但是文章里面最后提到的是用ASDK的方法来解决问题。本篇文章则献上另外一种可用的布局方法——FlexBox，并且带上了经过大量测试的测试数据，向大左的这篇经典文章致敬！</p><p>如今，iOS平台上几大可用的布局方法有：Frame原生布局，Autolayout原生自动布局，FlexBox的Yoga实现，ASDK。</p><p>当然，基于这4种基本方案以外，还有一些组合方法，比如Weex的这种，用JS的CSS解析成类似JSON的DOM，再调用Native的FlexBox算法进行布局。前段时间还有来自美团的<a href="http://tech.meituan.com/the_future_of_layout.html" rel="external nofollow noopener noreferrer" target="_blank">《布局编码的未来》</a>里面提到的毕加索（picasso）布局方法。原理也是会用到JSCore，将JS写的JSON或者自定义的DSL，经过本地的picassoEngine布局引擎转换成Native布局，最终利用锚点的概念做到高效的布局。</p><p>最后，推荐2个iOS平台上比较优秀的利用了FlexBox的原理的开源库：</p><p>来自Facebook的<strong><a href="https://github.com/facebook/yoga" rel="external nofollow noopener noreferrer" target="_blank">yoga</a></strong><br>来自饿了么的<strong><a href="https://github.com/LPD-iOS/FlexBoxLayout" rel="external nofollow noopener noreferrer" target="_blank">FlexBoxLayout</a></strong></p><hr><p>Weex 源码解析系列文章：</p><p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_how_to_work_in_iOS.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 是如何在 iOS 客户端上跑起来的</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_layout_engine_powered_by_Flexbox&#39;s_algorithm.md" rel="external nofollow noopener noreferrer" target="_blank">由 FlexBox 算法强力驱动的 Weex 布局引擎</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_events.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 事件传递的那些事儿</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_ingenuity_JS_framework.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 中别具匠心的 JS Framework</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a>  </p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局
      
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>weex系列抄之一---环境搭建</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/weex_one/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/weex_one/</id>
    <published>2018-05-04T04:07:12.000Z</published>
    <updated>2018-06-22T06:07:03.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-Native-和-Weex"><a href="#React-Native-和-Weex" class="headerlink" title="React Native 和 Weex"></a>React Native 和 Weex</h2><p>自从Weex出生的那一天起，就无法摆脱和React Native相互比较的命运。React Native宣称“Learn once, write anywhere”，而Weex宣称“Write Once, Run Everywhere”。Weex从出生那天起，就被给予了一统三端的厚望。React Native可以支持iOS、Android，而Weex可以支持iOS、Android、HTML5。</p><p>在Native端，两者的最大的区别可能就是在对JSBundle是否分包。React Native官方只允许将React Native基础JS库和业务JS一起打成一个JS bundle，没有提供分包的功能，所以如果想节约流量就必须制作分包打包工具。而Weex默认打的JS bundle只包含业务JS代码，体积小很多，基础JS库包含在Weex SDK中，这一点Weex与Facebook的React Native和微软的Cordova相比，Weex更加轻量，体积小巧。</p><p>在JS端，Weex又被人称为Vue Native，所以 React Native 和 Weex 的区别就在 React 和 Vue 两者上了。</p><p>笔者没有写过React Native，所以也没法客观的去比较两者。不过知乎上有一个关于Weex 和 React Native很好的对比文章<a href="https://zhuanlan.zhihu.com/p/21677103" rel="external nofollow noopener noreferrer" target="_blank">《weex&amp;React Native对比》</a>，推荐大家阅读。</p><p>前两天<a href="http://www.weibo.com/122678100" rel="external nofollow noopener noreferrer" target="_blank">@Allen 许帅</a>也在<a href="http://tech.glowing.com/cn/" rel="external nofollow noopener noreferrer" target="_blank">Glow 技术团队博客</a>上面发布了一篇<a href="http://tech.glowing.com/cn/react-native-at-glow/" rel="external nofollow noopener noreferrer" target="_blank">《React Native 在 Glow 的实践》</a>这篇文章里面也谈了很多关于React Native实践相关的点，也强烈推荐大家去阅读。</p><h2 id="入门手册"><a href="#入门手册" class="headerlink" title="入门手册"></a>入门手册</h2><p>关于小白想入门Weex，当然最基础的还是要通读文档，文档是官方最好的学习资料。官方的基础文档有两份：</p><p><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">教程文档</a><br><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">手册文档</a></p><p>在文档手册里面包含了Weex所有目前有的组件，模块，每个组件和模块的用法和属性。遇到问题可以先过来翻翻。很有可能有些组件和模块没有那些属性。</p><h2 id="Weex系列工具"><a href="#Weex系列工具" class="headerlink" title="Weex系列工具"></a>Weex系列工具</h2><p>看完官方文档以后，就可以开始上手构建工程项目了。</p><p>Weex也和前端项目一样，拥有它自己的脚手架全家桶。</p><ol><li>weex-toolkit </li><li>weexpack </li><li>playground </li><li>code snippets </li><li>weex-devtool。</li></ol><h4 id="weex-toolkit"><a href="#weex-toolkit" class="headerlink" title="weex-toolkit"></a>weex-toolkit</h4><p>weex-toolkit是用来初始化项目，编译，运行，debug所有工具。</p><p>通过下面的命令安装 </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g weex-toolkit</span><br></pre></td></tr></table></figure><p>安装完成后就可以使用weex 命令了 </p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex-toolkit.png" alt=""></p><p>我们主要用的就是debug 和 compile命令。debug 是启动chrome调试器 、compile命令是将写好的js文件编译为JS bundle。</p><h4 id="weexpack"><a href="#weexpack" class="headerlink" title="weexpack"></a>weexpack</h4><p>weexpack是用来打包JSBundle的，实际也是对Webpack的封装。</p><h4 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h4><p>playground是一个上架的App，这个可以用来通过扫码实时在手机上显示出实际的页面。</p><p> <img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/playground.png" alt=""></p><h4 id="code-snippets"><a href="#code-snippets" class="headerlink" title="code snippets"></a>code snippets</h4><p>code snippets这个是一个在线的playground。</p><p> <img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/dotwe.png" alt=""></p><h4 id="weex-devtool"><a href="#weex-devtool" class="headerlink" title="weex-devtool"></a>weex-devtool</h4><p>weex-devtool 可以使用chrome调试JS 代码。  这个工具我认为主要方便前端开发使用。</p><p>使用步骤，首先启动调试服务，终端输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">weex</span> <span class="literal">debug</span></span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebug.png" alt=""></p><p>同时启动chrome。然后在代码中将host换为图中的host。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSString *strHost =  [[NSUserDefaults standardUserDefaults] <span class="string">objectForKey:</span>GWX_WEEX_DEBUG_HOST];</span><br><span class="line">    <span class="keyword">if</span>(strHost.length&gt;<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NSString *strURL = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"ws://%@/debugProxy/native"</span>,strHost];</span><br><span class="line">        [WXDevTool <span class="string">setDebug:</span>YES];</span><br><span class="line">        [WXLog <span class="string">setLogLevel:</span>WXLogLevelLog];</span><br><span class="line">        [WXDevTool <span class="string">launchDevToolDebugWithUrl:</span>strURL];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [WXDebugTool <span class="string">setDebug:</span>NO];</span><br><span class="line">        [WXLog <span class="string">setLogLevel:</span>WXLogLevelError];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>启动app，看到app链接到了 chrome调试服务器 </p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugapp.png" alt=""></p><p>下图是debuger 截图 ：</p><p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugdebug.png" alt=""></p><p>下图是inspect截图：<br><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugpage.png" alt=""></p><p>具体使用方法看这两篇文章即可：</p><ol><li><p><a href="https://zhuanlan.zhihu.com/p/25331465" rel="external nofollow noopener noreferrer" target="_blank">《Weex 入坑指南：Debug 调试是一门手艺活》</a>  </p></li><li><p><a href="https://github.com/weexteam/article/issues/50" rel="external nofollow noopener noreferrer" target="_blank">《Weex调试神器——Weex Devtools使用手册》</a></p></li></ol><h2 id="Weex-Market插件"><a href="#Weex-Market插件" class="headerlink" title="Weex Market插件"></a><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md#2-weex-market%E6%8F%92%E4%BB%B6" rel="external nofollow noopener noreferrer" target="_blank">Weex Market插件</a></h2><p>在日常开发中，我们可以全部自己开发完所有的Weex界面，当然还可以用一些已有的优秀的轮子。Weex的所有优秀的轮子都在Weex Market里面。</p><p> <a href="https://camo.githubusercontent.com/bdaba9a49b7d7b32486fb7d68a1c5c965c07b19c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313139343031322d353631643838663562333739353763352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" rel="external nofollow noopener noreferrer" target="_blank">Weex Market</a> </p><p>在这个Market里面有很多已经写好的轮子，直接拿来用，可以节约很多时间。</p><p>比如这里很火的weex-chart。weex-chart图表插件是通过g2-mobile依赖[gcanvas插件][23]实现的</p><p>如果你想使用[Weex Market][24]的Plugin插件，你可以使用weex plugin 命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="keyword">add</span><span class="bash"> plugin_name</span></span><br></pre></td></tr></table></figure><p>你只需要输入插件的名称就可以从远程添加插件到你本地的项目，比如添加 weex-chart，我们可以输入命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="keyword">add</span><span class="bash"> weex-chart</span></span><br></pre></td></tr></table></figure><p>我们可以使用plugin remove移除插件，比如移除安装好的 weex-cahrt：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="builtin-name">remove</span> weex-chart</span><br></pre></td></tr></table></figure><p>这个插件库里面我用过weex-router，还不错，用它来做weex的路由管理。推荐使用。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">官方手册</a></li><li><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md#ios-开发者的-weex-伪最佳实践指北" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-Native-和-Weex&quot;&gt;&lt;a href=&quot;#React-Native-和-Weex&quot; class=&quot;headerlink&quot; title=&quot;React Native 和 Weex&quot;&gt;&lt;/a&gt;React Native 和 Weex&lt;/h2&gt;&lt;p&gt;自从
      
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
</feed>
