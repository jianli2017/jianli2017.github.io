<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-20T07:30:27.282Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关键字使用的位置</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E9%99%84%E5%BD%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/附录/关键字使用的位置/</id>
    <published>2018-09-20T04:07:12.000Z</published>
    <updated>2018-09-20T07:30:27.282Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static</td><td>static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中</td></tr><tr><td>explicit</td><td>explicit只对一个实参的构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外定义时不应该重复使用</td></tr><tr><td>=default</td><td>当我们在类内用=default修饰成员声明时，合成的函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default</td></tr><tr><td>=delete</td><td>必须出现在函数第一次声明的时候</td></tr><tr><td>virtual</td><td>只能出现在类内部的声明语句中之前，不能用于类外部的函数定义</td></tr><tr><td>override</td><td></td></tr><tr><td>final</td><td>类的名字后面，防止继承</td></tr><tr><td>=0</td><td>只能出现在类内部的虚函数声明语句处</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中&lt;/td&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="附录" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E9%99%84%E5%BD%95/"/>
    
    
      <category term="关键字使用的位置" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>动态内存</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/</id>
    <published>2018-09-13T04:07:12.000Z</published>
    <updated>2018-09-14T10:58:46.479Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>动态内存和智能指针</li><li>动态数组</li></ol><a id="more"></a><p>到目前为止，我们程序只使用静态内存和栈内存，静态内存用来保存局部static对象、类static成员、以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁，对于栈对象，仅在其定义的程序块运行时才存在。static对象在使用前分配，在程序结束是销毁。</p><h2 id="动态内存和智能指针"><a href="#动态内存和智能指针" class="headerlink" title="动态内存和智能指针"></a>动态内存和智能指针</h2><p>shareed_ptr允许多个指针指向同一个对象；unique_ptr则独占所指的对象。weak_ptr伴随类。</p><h3 id="shared-ptr类"><a href="#shared-ptr类" class="headerlink" title="shared_ptr类"></a>shared_ptr类</h3><p>智能指针也是模板，当我们创建一个智能指针时，必须提供额外的信息–指针指向的类型。</p><table><thead><tr><th>shared_ptr和unique_ptr都支持的操作</th><th>说明</th></tr></thead><tbody><tr><td>shared_ptr<t> sp  unique_ptr<t> up</t></t></td><td>空智能指针，可以指向类型为T的对象</td></tr><tr><td>p</td><td>将p作为一个条件判断，若p指向一个对象，则为true</td></tr><tr><td>*p</td><td>解引用p，获取它指向的对象</td></tr><tr><td>p-&gt;mem</td><td>等价于(*p)-&gt;mem</td></tr><tr><td>p.get</td><td>返回p中保存的指针，若智能指针释放了其对象，返回的指针所指的对象也消失了</td></tr><tr><td>swap(p,q)</td><td>交换pq中的指针</td></tr><tr><td>p.swap(q)</td></tr></tbody></table><table><thead><tr><th></th><th>share_ptr独有的操作</th></tr></thead><tbody><tr><td>make_shared<t>(args)</t></td><td>返回一个shared_ptr，指向动态分配的类型为T的对象，使用args初始化对象</td></tr><tr><td>shared_ptr<t>p(q)</t></td><td>p 是shared_ptr q的拷贝，此操作会递q中的计算器q中的指针必须能转换为T*</td></tr><tr><td>p = q</td><td>pq 都是shared_ptr，所保存的指针必须能相互转化，次操作会递减p的引用计数器，递增q的引用计数器，若p的引用计数器为0，则将其管理的源内存释放</td></tr><tr><td>p.unique()</td><td>若p.user_count为1，返回true，否则，返回false</td></tr><tr><td>p.use_count()</td><td>返回与p共享对象的智能指针数量，可能很慢，组要用于调试</td></tr></tbody></table><ol><li>shared_ptr的拷贝和赋值</li><li>shared_ptr自动销毁所管理的对象</li></ol><p>使用动态内存处于以下三个原因：</p><ol><li>程序不知道自己需要使用多少对象，典型例子，容器</li><li>程序不知道所需对象的准确类型</li><li>程序需要在多个对象间空闲数据</li></ol><p>一般而言，如果。两个对象共享底层的数据，当讴歌对象被销毁时，我们不能单方面的销毁底层数据。</p><p>使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p><h3 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h3><p>使用new动态分配和初始化对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * pi = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure><p>默认情况下，动态分配的对象是默认初始化的，这意味着，内置类型、组合类型的对象是未定义的，而类类型的对象使用默认构造函数进行初始化。</p><p>我们可以使用直接初始化方式来初始化一个动态分配的对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> *sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'9'</span>);</span><br></pre></td></tr></table></figure><p>也可以对动态分配的对象进行值初始化，只需要要类型名后跟一对圆括号即可。</p><p>对于定义了自己的构造函数的类类型来说，不论是值初始化还是默认初始化，都是使用默认构造函数，</p><p>但是对于内置类型来说，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的对象的值是未定义的。</p><p>动态分配的const对象：使用new分配const对象是合法的。一个动态分配的const对象必须初始化。</p><p>内存耗尽： 这里讲了定位new</p><p>delete之后重置指针：在delete之后，指针就变成了人们所说的空悬指针（danglind pointer）。</p><h3 id="shared-ptr和new结合使用"><a href="#shared-ptr和new结合使用" class="headerlink" title="shared_ptr和new结合使用"></a>shared_ptr和new结合使用</h3><p>接受指针参数的智能指针构造函数是explicit的，因此，我们将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式来初始化一个智能指针。</p><p>默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放她所关联的对象。</p><table><thead><tr><th></th><th>定义和改变shared_ptr的其他方法</th></tr></thead><tbody><tr><td>shared_ptr<t>p(q)</t></td><td>p管理内置指针q所指向的对象，q必须指向new分配的内存，且能转化为T*类型</td></tr><tr><td>shared_ptr<t>p(u)</t></td><td>p从unique_ptr哪里接管了对象的所有权，将U置位空</td></tr><tr><td>shared_pte<t>p(q,d)</t></td><td>p接管了内置指针q所指向的对象的所有权，p将使用可调用对象d来代替delete</td></tr><tr><td>shared_ptr<t>p(p2,d)</t></td><td>p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete</td></tr><tr><td>p.reset()</td><td>若p是唯一指向其对象的shared_ptr，reset将会是否次对象。</td></tr><tr><td>p.reset(q)</td><td>若传递了可选的参数内置指针q，会令p指向q，负责会将p置位空</td></tr><tr><td>p.reset(q,d)</td><td>若还传递了参数d，将会调用d而不是delete来是否q</td></tr></tbody></table><h3 id="智能指针和异常"><a href="#智能指针和异常" class="headerlink" title="智能指针和异常"></a>智能指针和异常</h3><p>智能指针使用规范</p><ol><li>不能使用相同的内置指针初始化多个智能指针</li><li>不delete get()返回的指针</li><li>不适用get() 初始化或者reset另一个智能指针</li><li>如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效的指针了。</li><li>如果使用智能指针管理的资源不是new分配的内存，记住传递一个删除器。</li></ol><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象。</p><table><thead><tr><th>unique_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>unique_ptr<t> u1</t></td><td>空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放他的指针，u2 会使用一个类型为D的可调用对象来释放他的指针</td></tr><tr><td>unique_ptr<t,d> u2</t,d></td><td></td></tr><tr><td>unique_ptr<t,d>u(d)</t,d></td><td>空的unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</td></tr><tr><td>u = nullptr</td><td>释放u所指的对象，将u置位空</td></tr><tr><td>u.release()</td><td>u放弃对指针的控制权，返回指针，并将u置为空</td></tr><tr><td>u.reset()</td><td>释放u指向的对象</td></tr><tr><td>u.reset(q)</td><td>如果提供了内置指针q，令u指向这个对象，否则u置为空</td></tr><tr><td>u.reset(nullptr)</td></tr></tbody></table><p>传递unique_ptr参数和返回unique_ptr： 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或者赋值一个将要被销毁的unique_ptr。</p><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指对象声明周期的指针。它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数器。</p><table><thead><tr><th>weak_ptr操作</th><th>说明</th></tr></thead><tbody><tr><td>weak_ptr<t> w</t></td><td>空的weak_ptr，可以指向类型为T的对象</td></tr><tr><td>weak_ptr<t> w(sp)</t></td><td>与shared_ptr sp指向相同对象的weak_ptr，T必须能转化为sp指向的类型</td></tr><tr><td>w = p</td><td>p 可以是一个shared_ptr 或一个weak_ptr。赋值后，w与p共享对象</td></tr><tr><td>w.reset()</td><td>将w置位空</td></tr><tr><td>w.use_count()</td><td>与w共享对象的shared_ptr的数量</td></tr><tr><td>w.expired()</td><td>若w.use_count()为0，返回true，否则返回false</td></tr><tr><td>w.lock()</td><td>如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr</td></tr></tbody></table><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>C++语言和标准库提供了一次分配一个对象数组的方法，C++中定义了另一种new表达式，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。</p><h3 id="new和数组"><a href="#new和数组" class="headerlink" title="new和数组"></a>new和数组</h3><p>分配一个数组得到一个元素类型的指针：  由于分配的内存不是一个数组类型，因此不能对数组调用begin和end  ，我们必须记住，动态数组并不是数组类型。</p><p>初始化动态分配数组：默认情况下使用默认初始化，可以使用圆括号进行值初始化。</p><h3 id="allocator"><a href="#allocator" class="headerlink" title="allocator"></a>allocator</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;动态内存和智能指针&lt;/li&gt;
&lt;li&gt;动态数组&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十二章 动态内存" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
    
      <category term="动态内存" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>泛型算法</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/</id>
    <published>2018-09-12T04:07:12.000Z</published>
    <updated>2018-09-14T02:21:25.708Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>概述</li><li>初始泛型算法</li><li>定制操作</li><li>再探迭代器</li><li>泛型算法结构</li><li>特定容器算法</li></ol><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。</p><p>算法永远不会执行容器操作：泛型算法本身不执行容器操作，他们只会运行于迭代器之上，执行迭代器的操作。这个特性带来一个非常惊人的编程假定：算法永远不会改变容器的大小。算法可能改变容器中元素的内容，可能在容器内移动元素，但永远不会添加或者删除元素。标准库定义定义了特殊的迭代器，插入迭代器。当算法操作这样的迭代器时迭代器可以完成向容器添加元素的效果，但算法永远不会做这种操作。</p><h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>find accumulate equal  </p><p>除了少数算法外，标准库算法都对一个范围内的元素进行操作。我们将此元素的范围称为输入范围。接收输入范围的算法总是使用前两个参数来表示范围。两个参数分别表示第一个要处理的元素、尾元素之后位置的迭代器。</p><p>那些只接收一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。</p><h3 id="写容器元素算法"><a href="#写容器元素算法" class="headerlink" title="写容器元素算法"></a>写容器元素算法</h3><p>fill copy back_inserter replace_copy</p><h3 id="重排元素的算法"><a href="#重排元素的算法" class="headerlink" title="重排元素的算法"></a>重排元素的算法</h3><h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="向算法传递函数"><a href="#向算法传递函数" class="headerlink" title="向算法传递函数"></a>向算法传递函数</h3><p>谓词：是一个可调用表达式，其返回结果是一个能用作条件的值。</p><p>一元谓词：接受单一参数<br>二元谓词：接受两个参数</p><p>stable_sort算法：维持相等元素的原有顺序</p><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>find_if算法对输入序列中的每个元素调用这个谓词，它返回第一个使谓词返回非0的元素，如果不存在这样的元素，则返回尾迭代器。</p><p>可调用对象（cllable object）。对于一个对象或者一个表达式，如果可以对其使用调用运算符，则它为可调用对象。</p><p>可调用对象：</p><ol><li>函数</li><li>函数指针</li><li>重载了函数调用运算符的类</li><li>lambda表达式</li></ol><p>可调用对象可以理解为是一个未命名的内联函数</p><p>一个lambda表达式具有一个返回类型、一个参数列表、一个函数体，单与函数不同，lambda表达式可以定义在函数内部，一个lambda表达式的一般形式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">capture list</span>](<span class="link">parameter list</span>)-&gt; return type &#123;function body&#125;</span><br></pre></td></tr></table></figure><p>与普通函数不同，lambda表达式使用尾置返回指定返回类型。</p><p>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。如果忽略返回类型，lambda根据函数体重的代码推断出返回类型。</p><p>与普通函数不同，lambda不能有默认实参。</p><p>一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些局部变量。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p><p>for_each算法接受一个可调用对象，并对输入序列中每个元素调用次对象。</p><p>捕获列表只用于局部非static变量，lambda可以直接使用局部static变量、它所在函数之外声明的名字。</p><h3 id="lambda捕获和返回"><a href="#lambda捕获和返回" class="headerlink" title="lambda捕获和返回"></a>lambda捕获和返回</h3><p>当向一个函数传递一个lambda时，同时定义了一个类型和该类型的对象：类似的，当使用auto定义一个用lambda初始化变量时，定义了一个从lambda生产的类型的对象。</p><p>值捕获：与参数不同，被捕获的变量的值在lambda创建时拷贝。而不是调用时拷贝。</p><p>引用捕获：必须确保被引用的对象在lambda执行的时候是存在的。</p><p>隐式捕获： &amp;搞事编译器采用引用捕获，=告诉编译器使用值捕获。混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是&amp;或者=。</p><p>可变lambda：默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变一个被捕获的变量的值。就必须在参数列表首加上关键字mutable。</p><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>bind标准函数 定义在functional中，可以将bind函数看做一个通用的函数适配器，他接受一个可调用对象，生成一个新的可调用对象来适应原来对象的参数。</p><p>bind的一般形式：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">auto newCallable</span> = bind(callable,arglist);</span><br></pre></td></tr></table></figure><p>使用placeholders名字</p><p>_n定义在一个名为placeholders的命名空间。而这个命名空间定义在std命名空间中。</p><h2 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h2><ol><li>插入迭代器</li><li>流迭代器</li><li>反向迭代器</li><li>移动迭代器</li></ol><h3 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h3><p>接受一个容器，生成一个迭代器，他实现向容器添加元素。当我们通过一个插入迭代器进行赋值时，改迭代器调用容器操作来向给定容器指定的位置插入一个元素。</p><ol><li>back_inserter</li><li>front_inserter</li><li>inserter</li></ol><h3 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h3><h2 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h2><h3 id="5种迭代器"><a href="#5种迭代器" class="headerlink" title="5种迭代器"></a>5种迭代器</h3><ol><li>输入迭代器</li><li>输出迭代器</li><li>前向迭代器</li><li>双向迭代器</li><li>随机访问迭代器</li></ol><h3 id="算法形参模式"><a href="#算法形参模式" class="headerlink" title="算法形参模式"></a>算法形参模式</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;初始泛型算法&lt;/li&gt;
&lt;li&gt;定制操作&lt;/li&gt;
&lt;li&gt;再探迭代器&lt;/li&gt;
&lt;li&gt;泛型算法结构&lt;/li&gt;
&lt;li&gt;特定容器算法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十章 泛型算法" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="泛型算法" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>空间配置器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第二章/空间配置器/</id>
    <published>2018-08-29T04:07:12.000Z</published>
    <updated>2018-08-30T04:02:17.349Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>空间配置器的标准接口</li><li>具备次配置能力的SGI 空间配置器</li><li>内存基本处理工具</li></ol><a id="more"></a><h2 id="空间配置器的标准接口"><a href="#空间配置器的标准接口" class="headerlink" title="空间配置器的标准接口"></a>空间配置器的标准接口</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocator::</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间配置器的标准接口&lt;/li&gt;
&lt;li&gt;具备次配置能力的SGI 空间配置器&lt;/li&gt;
&lt;li&gt;内存基本处理工具&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第二章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    
    
      <category term="空间配置器" scheme="http://yoursite.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>deque</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/deque/"/>
    <id>http://yoursite.com/wiki/C++语言/STL源码剖析/第四章/deque/</id>
    <published>2018-08-28T04:07:12.000Z</published>
    <updated>2018-08-29T09:15:28.164Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>deque 概述</li><li>deque中控器</li><li>deque的迭代器</li><li>deque的数据结构</li><li>deque的构造与内存管理</li><li>deque的元素操作</li></ol><a id="more"></a><h2 id="deque-概述"><a href="#deque-概述" class="headerlink" title="deque 概述"></a>deque 概述</h2><p>vector是单向开口的连续性空间，deque则是一种双向开口的连续性空间，所谓双向开口，意思是头尾两端分别做元素的插入和删除操作.</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque1.png" alt="deque示意"></p><p>deque和vector的最大差异，一、在于deque允许常数时间内对起始头端进行元素的插入或移除操作。二、deque没有容量的概念，因为他是动态的以分段连续空间组合而成，随时可以增加一段空间并连接起来。换句话说，像vector那样“因旧空间不足而重新分配一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留功能。</p><p>虽然，deque也提供了random access iterator，但他的迭代器并不是普通指针。其复杂度和vector不可以道里计，这当然影响了各个运算层面，因此，除非必要，我们应该尽可能选择vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector身上，将vector排序后，再复制回deque。</p><h2 id="deque中控器"><a href="#deque中控器" class="headerlink" title="deque中控器"></a>deque中控器</h2><p>deque是连续空间（至少逻辑上看如此），连续线性空间总令我们联想到array和vector。array无法生长，vector虽可以生长，却只能向尾端成长。而且其所为成长是个假象，事实上是：</p><ol><li>另觅更大空间</li><li>将原数据赋值过去</li><li>释放原空间</li></ol><p>如果不是vector每次配置新空间时留下一些富裕，其成长假象所带来的代价相当昂贵。</p><p>deque系由一段一段的定量连续空间构成。一旦有必要在前端或者尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复制的带带器框架。</p><p>收到分段连续性空间的字面影响，我们可能以为，deque的实现复杂度和vector相比，虽不中亦不远矣，其实不然。主要以为，即曰分段连续线性空间，就必须有中央控制，为了维持整体连续的假象，数据结构的设计及迭代器前进后退操作都颇为繁琐。deque的实现代码分量远比vector或list多得多。</p><p>deque采用一块所谓map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处层位一个节点，node）都是指针，指向另一段较大的连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL 允许我们制定缓存区的大小，默认是0，表示将使用512bytes缓存区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>=<span class="title">alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span> = 0&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">deque</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="comment">///元素的指针的指针</span></span><br><span class="line"><span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"></span><br><span class="line">map_poiner <span class="built_in">map</span>;<span class="comment">//指向map，map是快连续空间，其内的每个元素都是一个指针，指向一块缓存区</span></span><br><span class="line">size_type map_size; <span class="comment">//map内可容纳多少指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>令人头皮发麻的各种类型整理下，我们可发现，map其实是一个T**，也就是说他是一个指针，所指之物又是一个指针，指向类型为T的空间，如下图所示：</p><p><img src="/wiki/C++语言/STL源码剖析/第四章/deque/dequeImage/deque2.png" alt="deque的结构设计中，map和node-buffer的关系"></p><h2 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h2><p>deque的分段连续空间，维持其“整体连续”假象的任务，落在了迭代器operator++、 operator– 两个运算子身上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;deque 概述&lt;/li&gt;
&lt;li&gt;deque中控器&lt;/li&gt;
&lt;li&gt;deque的迭代器&lt;/li&gt;
&lt;li&gt;deque的数据结构&lt;/li&gt;
&lt;li&gt;deque的构造与内存管理&lt;/li&gt;
&lt;li&gt;deque的元素操作&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="STL源码剖析" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    
      <category term="第四章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/STL%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>顺序容器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/</id>
    <published>2018-08-27T10:07:12.000Z</published>
    <updated>2018-09-11T11:15:46.987Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li>vector对象是如何生长的</li><li>额外的string操作</li><li>容器适配器</li></ol><a id="more"></a><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2><p>容器在以下方面都有不同的性能折中：</p><ol><li>向容器添加或者删除元素的代价</li><li>非顺序访问容器中元素的代价</li></ol><table><thead><tr><th>容器类型</th><th>性能</th></tr></thead><tbody><tr><td>vector</td><td>可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢</td></tr><tr><td>deque</td><td>双端队列，支持快速随机访问，在头尾位置插入、删除速度快</td></tr><tr><td>list</td><td>双向链表，只支持双向顺序访问，在list中任何位置插入、删除操作熟读都很快</td></tr><tr><td>forward_list</td><td>单向链表。只支持单向顺序访问，在链表任何位置插入、删除操作都非常快</td></tr><tr><td>array</td><td>固定大小数组，支持快速随机访问，不能添加或删除元素</td></tr><tr><td>string</td><td>与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入、删除快</td></tr></tbody></table><p>string、vector将元素保存在连续的内存空间，由于元素是连续存储的，由元素的下标计算其地址非常快。</p><p>list、forword_list两个容器的设计目的是令容器容器的任何位置添加、删除操作都很快</p><h2 id="容器概览"><a href="#容器概览" class="headerlink" title="容器概览"></a>容器概览</h2><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不适用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>forword list 不支持递减运算符</p><p>迭代器范围中的元素包括first所表示的元素以及从first开始，直至last（但不包括last）之间的所有元素，左闭合区间。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">begin</span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>使用左闭合范围蕴含的编程假定</p><ol><li>如果begin和end相等，则范围为空</li><li>如果begin和end不相等，则范围至少包含一个元素，且begin指向范围中的第一个元素</li><li>我们可以对begin递增若干次，使得begin==end</li></ol><h3 id="容器类型成员"><a href="#容器类型成员" class="headerlink" title="容器类型成员"></a>容器类型成员</h3> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;<span class="string">""</span>iterator iter;</span><br></pre></td></tr></table></figure><h3 id="begin和end成员"><a href="#begin和end成员" class="headerlink" title="begin和end成员"></a>begin和end成员</h3><p> begin和end操作生成指向容器中第一个元素和尾元素之后的迭代器。</p><h3 id="容器的定义和初始化"><a href="#容器的定义和初始化" class="headerlink" title="容器的定义和初始化"></a>容器的定义和初始化</h3><table><thead><tr><th>容器的定义和初始哈</th><th></th></tr></thead><tbody><tr><td>C c</td><td>默认构造函数，如果C是一个array，则c中元素默认初始化，否则c为空</td></tr><tr><td>C  c1()c2 C c1 = c2</td><td>c1初始化为c2的拷贝，c1和c2必须类型相同,对于arrary，大小相同</td></tr><tr><td>C c{a,b,c,…} C c = {a,b,c,…}</td><td>c初始化为初始化列表中元素的拷贝</td></tr><tr><td>C c(b,e)</td><td>c初始化为迭代器b，e指定范围中的元素的拷贝</td></tr><tr><td>C seq(n) C seq(n,t)</td><td>seq 包含n个元素，这些元素进行了值初始化，此构造函数是explicit的</td></tr></tbody></table><p>容器的拷贝： 两种方式</p><ol><li>直接拷贝整个容器</li><li><p>拷贝迭代器指定的元素范围</p><p>当将一个容器初始化为另一个容器的拷贝时，两个容器类型和元素类型必须相同。</p><p>列表初始化：对于除了array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。</p><p>标准库array具有固定大小：标准库array的大小是类型的一部分，  array与内置数组的区别：array可以进行拷贝和对象赋值。</p><h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><p>赋值运算符将其左边容器中全部元素替换为右边容器中元素的拷贝。</p><h3 id="容器的大小操作"><a href="#容器的大小操作" class="headerlink" title="容器的大小操作"></a>容器的大小操作</h3></li><li><p>size</p></li><li>empty</li><li><p>max_size</p><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>只有当其元素的类型定义了关系运算符，我们才可以使用关系运算符比较容器</p><h2 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h2><h3 id="向顺序容器添加元素"><a href="#向顺序容器添加元素" class="headerlink" title="向顺序容器添加元素"></a>向顺序容器添加元素</h3><p>|操作|说明|<br>|—|—|<br>|这些操作不支持会改版容器的大小，array不支持这些操作||<br>|forward_list有专有版本的insert和emplace||<br>|forward_list不支持push_back和emplace_back，由于没有位指针，算法复杂度是o(n)||<br>|vector和string不支持push_font和emplace_font，也是算法复杂度的原因，整个元素需要移动，单可以通过inser做到||<br>|c.push_back(t)|在C的尾部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_back(args)||<br>|||<br>|c.push_font(t)|在C的首部创建一个值为t或由args创建的创建的元素，返回void|<br>|c.emplace_font(args)||<br>|||<br>|c.insert(p,t)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素，  <font color="blue">前插</font>|<br>|c.emplace(p,args)||<br>|||<br>|c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，若n为0，则指向p|<br>|c.insert(p,b,e)|将迭代器b，e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器|<br>|c.insert(p,il)|il是花括号包围的元素值列表|<br>|向一个vector、string、deque插入元素，会使所有指向容器的迭代器、引用、指针失效|</p><p>使用push_back：除了array、forward_list之外，每个顺序容器都支持push_back。</p><p>当我们用一个对象初始化容器时，或将一个对象插入到容器中，实际上，放入到容器中的是对象的一个拷贝，二不是对象本身。</p><p>使用push_font：和vector一样，在deque首位之外的位置插入元素会很耗时。</p><p>在容器中的特定位置插入元素：insert提供了更一般的功能，它允许在容器中的任何位置插入0个或者多个元素。每个insert函数，都接受一个迭代器作为其第一个参数，迭代器指出了在容器的什么位置插入元素。</p><p>为什么是前插：因为迭代器可能只需容器外部之后不存在的元素的位置，所以只能前插。另外，在容器开始位置插入元素是很有用的功能。</p><p>我们可以使用insert将元素插入容器的开始位置，不用担心是否支持push_font。</p><p>如果我们传递给insert一对迭代器，他们不能指向添加元素的目标容器。</p><p>使用insert的返回值：通过使用insert的返回值，可以在容器中的一个特定位置反复插入元素。</p><p>emplace操作：新标准引入了三个成员：emplace、emplace_font 、emplace_back，这些操作构造而不是拷贝元素。</p><p>emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。</p><h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>包括array在内的所有容器都有一个font函数，而除了forword_list之外的所有容器都有一个back成员函数。这两个成员函数分别返回首元素和尾元素的索引。</p><p>|容器的访问操作|说明|<br>|—|—|<br>||at和下标操作只使用于string、vector、deque、和array|<br>||back不适用forward_list，算法复杂度的问题|<br>|c.back()|返回c的尾元素的引用|<br>|c.font()|返回c的首元素的引用|<br>|c[n]|返回c中下表为n的元素的引用|<br>|c.at(n)|返回下标为n的元素的引用。|</p></li></ol><p> 提供快速随机访问的容器（string、vector、deque、array）都提供下标运算符</p><p> at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range的异常。</p><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table><thead><tr><th>删除操作</th><th>说明</th></tr></thead><tbody><tr><td></td><td>这些操作会给变容器的大小，不适用于array</td></tr><tr><td></td><td>forward_list有特殊版本的erase</td></tr><tr><td></td><td>forward_list不支持pop_back，string、vector不支持pop_font</td></tr><tr><td>c.pop_font()</td><td>删除c中的首元素</td></tr><tr><td>c.pop_back()</td><td>删除c中的尾元素</td></tr><tr><td>c.erase(p)</td><td>删除迭代器p所指定的元素</td></tr><tr><td>c.erase(b,e)</td><td>删除迭代器be所指范围内的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素</td></tr></tbody></table><p>###特殊的forward_list操作</p><p>特殊操作的原因：删除或者插入操作，我们需要访问它的前驱，以便改变前驱的链接，但是forward_list中，没有简单的方法获取一个元素的前驱。forward_list定义了insert_after、emplace_after、erase_after操作。before_begain，返回一个首前。</p><p>|forward_list操作|说明|<br>|lst.before_begain()|返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用|<br>|lst.cbefore_begain()||<br>|lst.insert_after(p,t)|在迭代器之后插入一个元素|<br>|lst.insert_after(p,n,t)||<br>|lst.insert_after(p,b,e)||<br>|lst.insert_after(p,il)||<br>|emplace_after(p,args)||<br>|lst.erase_after(p)||<br>|lst.erase_after(b,e)||</p><h3 id="改变容器的大小"><a href="#改变容器的大小" class="headerlink" title="改变容器的大小"></a>改变容器的大小</h3><h3 id="容器操作可能使迭代器失效"><a href="#容器操作可能使迭代器失效" class="headerlink" title="容器操作可能使迭代器失效"></a>容器操作可能使迭代器失效</h3><h2 id="vector对象是如何生长的"><a href="#vector对象是如何生长的" class="headerlink" title="vector对象是如何生长的"></a>vector对象是如何生长的</h2><p> |容器大小操作|说明|<br> ||shrink_to_fit 只适用于vector、string、deque|<br> ||capacity和reserve只适用于vector、string|<br> |c.shrink_to_fit|请将capacity（）减少为size相同大小|<br> |c.capacity()|不重新分配内存空间的话，c可以保存多少元素|<br> |c.reserve（）|分配至少容纳那n个元素的内存空间|</p><h2 id="额为的string操作"><a href="#额为的string操作" class="headerlink" title="额为的string操作"></a>额为的string操作</h2><h3 id="构造string的其他方法"><a href="#构造string的其他方法" class="headerlink" title="构造string的其他方法"></a>构造string的其他方法</h3><table><thead><tr><th>构造string的其他方法</th><th>说明</th></tr></thead><tbody><tr><td>string s(cp,n)</td><td>s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符</td></tr><tr><td>string s(s2,pos2)</td><td>s是string s2从下标POS2开始的字符的拷贝，若pos2&gt;s2.size()，构造函数的行为未定义</td></tr><tr><td>string s(s2,pos2,len2)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;vector对象是如何生长的&lt;/li&gt;
&lt;li&gt;额外的string操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第九章顺序容器" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="顺序容器" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO库</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/IO%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第八章io库/IO库/</id>
    <published>2018-08-27T04:07:12.000Z</published>
    <updated>2018-08-27T10:51:38.547Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>IO类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>进行IO操作的函数通常以引用方式传递、返回流。读写一个IO对象会改变其状态，因此，传递和返回的引用不能是const的。</p><h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>strm::iostate</td><td>strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td></tr><tr><td>strm::badbit</td><td>指出输出流已崩溃</td></tr><tr><td>strm::faillbit</td><td>一个IO操作失败</td></tr><tr><td>strm::eofbit</td><td>流达到了文件结尾</td></tr><tr><td>strm::goodbit</td><td>流未处于错误状态，此值保证为0</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若流s的failbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若流s的badbit置位，则返回true</td></tr><tr><td>s.good()</td><td>若流处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流的所有状态复位</td></tr><tr><td>s.clear(flags)</td><td>根据给定的flags标志位，将流s中对应的条件状态位复位</td></tr><tr><td>s.setstate(flags)将流s中对应条件状态位置位</td><td></td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态</td></tr></tbody></table><p>一个流一旦发生错误状态，其后续的IO操作都失败。只有流处于无错状态是，我们才可以从它读取数据、写入数据。</p><p>属性缓存区：</p><ol><li>endl， 换行并刷新缓冲区</li><li>flush ，刷新缓存区，不输出任何额为的字符</li><li>ends，向缓冲区插入一个空字符，然后刷新缓冲区</li></ol><p>unitbuf 操纵符：如果每次输出操作后，都属性缓存区，我们可以使用unitbuf操纵符。</p><p>如果程序崩溃，输出缓冲区不会被刷新。</p><p>tie： 如果本对象关联到一个输出流，则返回的就是这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>fstream fstrm</td><td>创建一个未绑定的文件流</td></tr><tr><td>fstream fstrm(s)</td><td>创建一个fstream，并打开名为s的文件。 s可以是string类型，或者是一个指向C风格字符串类型</td></tr><tr><td>fstream fstrm(s,mode)</td><td>安装mode打开文件</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定，返回void</td></tr><tr><td>fstrm.close()</td><td>关闭于fstrm绑定的文件，返回void</td></tr><tr><td>fstrm.is_open</td><td>返回一个bool，指出与fstrm关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>创建文件流对象时，我们可以提供文件名，如果提供了一个文件名，则open自动被调用。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><table><thead><tr><th>文件模式</th><th>说明</th></tr></thead><tbody><tr><td>in</td><td>以读方式打开</td></tr><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次写操作前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后，立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><h2 id="stirng流"><a href="#stirng流" class="headerlink" title="stirng流"></a>stirng流</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>sstream strm</td><td>strm是未绑定的stringstream对象</td></tr><tr><td>sstram strm(s)</td><td>strm 是一个sstream对象，保存string的一个拷贝，此构造函数是explicit的</td></tr><tr><td>strm.str()</td><td>返回strm中保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s 拷贝到strm中，返回void</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第八章io库" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/"/>
    
    
      <category term="IO库" scheme="http://yoursite.com/tags/IO%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>What’s New in User Notifications</title>
    <link href="http://yoursite.com/wiki/WWDC/What%E2%80%99s%20New%20in%20User%20Notifications/"/>
    <id>http://yoursite.com/wiki/WWDC/What’s New in User Notifications/</id>
    <published>2018-08-23T04:07:12.000Z</published>
    <updated>2018-09-12T05:53:35.631Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.<br>下午好，欢迎大家来这个叫做what’s new in user notifications的session </p><a id="more"></a><p>So there’s a range of topics to be covered today, and let’s begin with looking at grouped notifications. Now up to iOS 11, all new incoming notifications for the users were inserted in a chronological order in the notification list.<br>So these would be interspersed across multiple applications, and it would be hard for the user to find a certain notification or triage multiple notifications together.<br>So starting in iOS 12, we’ve decided to improve this by introducing notification grouping, so now, as you can see here, all notifications across different applications get grouped into their unique groups. Let’s take a deeper look at how grouped notifications works. Now all these notifications will be automatically grouped, so there’s nothing explicit that you need to do to start using notification grouping.<br>However, if you do want to have your own custom groups then you can use the thread identifier, which is an existing property on the UN notification content object.<br>So some of you might already be using the thread identifier and for a local notification.<br>You can set it on the UNMutableNotificationContent object as seen here.<br>And for a remote notification payload, you can also include it as part of your notification payload. Now the thread identifier might be familiar to some of you already. We use it today for forwarding notifications to a notification content extension that is presented for your application, which has the exact same thread identifier, allowing the content extension view to update it based on the new incoming notification. Starting in iOS 11, we started using the thread identifier for doing grouping of notifications, if the user had turned on [inaudible] notification previous. So we’re just taking this concept and expanding it for all notifications in general. So how does this grouping work? So when a new notification comes in to you, the user’s device, if there is no thread identifier set on this notification, then this notifications gets grouped with the application bundle. We can see that from our sample application here, that as new notifications are incoming, they are getting bundled with the same group and the group is getting updated with the latest content.<br>And then the user can simply expand this notification group to see all the notifications that are present in that group. On the other hand, if the notification does have a thread identifier set on it, then it gets grouped with all the other notifications from that same application with that exact same thread ID. What this also means is that the same application can then have multiple different custom groups, depending upon the unique thread identifiers that you’re setting on them. A good example of this is the messages application, where here you can see there are two different threads, and as new notifications are incoming, they are going to their own respective groups.<br>And then the user can expand a specific group to see all the notifications that are part of that group. So by using the thread identifier, messages is able to do so. Now, your application users also have the option of tweaking this notification grouping setting from your per application notification setting’s page.<br>Here, they get three options. If they choose automatic, then they get the behavior that we just described. However, the user also has the option of just grouping by application, where the system will ignore your thread identifier and group all notifications into a single group. And if the user wants the same behavior as it exists in iOS 11 today, then they can simply turn off grouping for your applications’ notifications. So do keep this in mind when you’re creating your own custom groups that they create enough value for users when they receive your applications’ notifications. Now what are the different components of a notification group? The content that we show is for the latest notification that was received as part of that group. And then the user can simply see all the notifications by tapping on this group, and we expand all the notifications’ content. And then the user can interact with all these notifications individually as well. The two buttons at the top give the users much greater control like collapsing the stack as well as clearing all these notifications together. Now, notification grouping also makes triaging of notifications much better. For example, in this case, the user can clear all these notifications together by simply swiping to the right and tapping clear all.<br>Apart from the content of the notification group, we also show a summary text.<br>Now, this summary text, by default, shows the count of all the notifications that are part of that group. However, you can also create a custom summary text so you can give your users much better context of what kind of information is included in that group. Now, we will cover this API and go over much larger use cases of how you can create your custom groups in the advanced session around using group notifications, which will follow this session. So let’s do a quick summary of group notifications as we saw them today. Starting in iOS 12, all application notifications are going to be grouped automatically.<br>You can start using the thread identifier if you want to create your own custom groups for your applications, but the user does have the option of changing this grouping setting for your applications’ notifications. And lastly, you can use the summary text for customizing the information you want to provide the user around the notification groups that you’re creating.<br>All right, so that was group notifications. Now, let’s move on to the next topic and talk about notification content extensions. Now, some of you might already be familiar with these content extensions that we included with iOS 10.<br>Content extensions allow your applications to present a rich notification view around the user’s notifications, so you can have a much more customized and interactive interface for the notification that the user is seeing. Let’s do a quick recap of setting up these content extensions. Xcode gives you a standard template to add a target for the content extensions to your applications and once you set that up, we create a default class for the notification view controller, which implements the UNNotificationContentExtension protocol. Here, the did receive notification method is important because this is your entry point for setting up the view associated with the content extension, and you can use the notification object past here to get all the information around that notification to set up your custom view.<br>The info.plist file associated with your content extension gives you more options.<br>The important thing here is the category identifier. Now, this identifier needs to match the same category identifier you’re setting on your notification requests because that’s how the system knows which content extension to launch with which notification.<br>Along with this, you can do some quick configurations of your content extension such as setting the initial content size ratio, hiding the default content, as well as overriding the title of this content extension. Now, the primary way in which your users interact with these content extensions is through notification actions, and these actions are presented right below the content of the content extension.<br>Let’s summarize how we can set up these actions as well. So doing so is fairly trivial in code. For example, here, we have two actions here for like and comment, and we create a simple UNNotificationAction for like and a text input action for commenting. And once we’ve created these actions, we create a new category giving it the same identifier as the content extension where we want these actions to be presented. And then, we pass it, the two new actions that we created.<br>Once we’ve set up this category, then we call setNotificationCategories on the UNNotificationCenter object associated with our class, giving it the new category that we created. So by simply doing so, the next time when the user goes to your content extension we can see that these actions are now available for them to interact with your notification content. Now let’s take a look at how we can handle the responses from these actions. There are two ways to do that. Firstly, you can handle this response in the AppDelegate that is associated with your application that implements the UNUserNotificationCenter Delegate protocol. Here, the function UserNotificationCenter did receive response, includes the response object which includes information about the request, the notification request from which the user took this action.<br>However, the content extension also allows you to intercept this action response so that you can update your view and make a much more interactive and dynamic experience for users for the content extension. So for our sample here, we enter the did receive response method and checked the action identifier for the like action. And then we update our UI with the new label as well as update our application state. Finally calling the completion block we do not dismiss. If you do want to dismiss your content extension view here, then you can simply change the parameter you’re passing to the completion block to dismiss or dismiss and forward, where we will forward this response to your AppDelegate function as well. All right, so now that we set this up, we can see that when the user takes the like action, the content extension content gets updated right there and then. So it’s a much more interactive experience for your user and they’re getting real-time feedback. However, if you look at the current state of the content extension, we see that there is some redundant information.<br>The user has already taken the like action, so having the action there doesn’t really serve a purpose anymore. Now notification actions, in general, have certain limitations. They are not very dynamic and can’t be updated based on the context of your content extensions. Also, these tend to be tied to the notification categories that you have to define at the time of your application setup.<br>So we wanted to address these issues and we have introduced a new API around notification actions, where now we’re exposing these notification actions as part of the NSExtensionContext tied to your content extension. What this API allows you to do is access the currently presented notification actions to the user as well as replace these actions by setting a brand new array of notification actions for your content extension. So going back to our sample, what if after the user took the like action we wanted to replace it say with the unlike action so that they can do the reverse of the action they just took? So using this new API, let’s take a look of how we can set this up. So we go back to our did receive response method and again identify the like action and update our application state. This time, we also create a new action for unlike, giving it a unique identifier as well as a title.<br>We can also take a look at the currently presented actions so that we can extract the comment action from there without having to create it again. Then we create a new array of these new actions that we’ve created and simply set that on the notification actions variable. So once we’ve done this and the user takes the like action, then the UI will automatically update to show them the new action, and then the user can then toggle between the two actions, depending upon how you handle that state in your content extensions. Now, this API can be used in multiple other ways as well.<br>For example, now you can set your actions at the time you’re setting up your content extension view in the did receive notification method. What this means is your notification requests are no longer tied to the category to define the actions that you want to present around these notifications. You can also now present a secondary set of actions by replacing the currently presented actions.<br>For example, if the leading action was rate, then you can provide a secondary list of the different types of ratings that you want your user to take. And you can also remove all these notification actions if you feel it does not make sense anymore for your content extension to present these actions. So that’s the new API around notification actions. And we feel this will really help you enhance the experience that your users have around your content extensions with the different actions now you can present to them. Let’s move on and talk about user interaction with these content extensions. Now notification actions were important up till this point because till iOS 11 we did not allow user interaction touches with your content extension view. Now we received a lot of feedback around this.<br>And I’m happy to announce that we’re taking away this restriction with iOS 12.<br>So now your content extensions have the option of opting in to receiving user interaction [inaudible] touches, and setting this up, it’s fairly trivial.<br>All you have to do is add a new key value option to your info.plist file.<br>And the key that we’ve added is the UNNotificationExtensionUser InteractionEnabled.<br>So going back to our sample, what if we want to remove the like action from a notification action and make it a UI interaction touch that’s part of the view itself? So once we’ve configured our info.plist file, we can go back to our content extension view and create our own custom button to handle the like gesture. We add a target for our own private method and inside that function, we update the UI as well as update our application state. So here, it’s important that since you’re implementing your own user interactions that you are responsible for handling all these actions, responses, and callbacks from the users yourself. So once we’ve set this up, now when the user goes to your content extension we see the Like button, part of the UI itself, and the user can simply interact with that button right there and then.<br>So that’s the new functionality that we’ve added around content extensions.<br>And coupled with notification actions, along with user interaction touches, you now have a much richer set of tools for creating much more interactive and dynamic content extension experiences for your applications notifications users.<br>Now let’s talk about launching your application from the notification content extension.<br>So today the user can launch your application if touches were not allowed by simply tapping the content extension view. They could also do so by tapping your application icon in the top left corner. Or you could create a foreground action, which then would in turn launch the application. But what if you wanted to do this from your own custom control? What if you wanted to launch the application programmatically? To enable this, there is a new API on the NSExtensionContext called performNotification DefaultAction, which would allow you to do this now. Now, what does the default action mean? So, as we said, it launches the application, but at the same time, it calls the UserNotificationCenter did receive response method in your application delegate. Now the UNNotificationResponse object contains the information of the notification from which the user came, so you can update your application state based on the notification. And the identifier that’s passed here is the UNNotificationDefault ActionIdentifier. So going back to our sample, let’s see how we can set this custom control up. Now again, we create our own UI button for the all comments and then tie it up with our own private function.<br>And in that function, we’re simply calling PerformNotification DefaultAction. So by simply doing that, you get this functionality to call this method programmatically from anywhere in your content extension code.<br>So that was launching the application. What about dismissing the content extension view? Again, let’s take a look at how the user can do that today.<br>They can do that by tapping the Dismiss Button in the top right corner, or you can create your own custom notification action, which would in turn dismiss the content extension view.<br>Which you can set up, as we saw before, by passing dismiss to the completion block.<br>But again, what if we want to dismiss the view through our own custom buttons, and we want to do this programmatically? Say that when the user taps the Like button, then the view dismisses because we feel the user’s done interacting with the content extension.<br>To enable this as well, there’s a new API called dismissNotificationContent Extension that’s on the NSExtensionContext. We go back to how we set up our Like button, and now this time, we also call the new function that we added for dismissing the content extension view. And once we set this up, now when the user takes the like action, the view of the content extension gets dismissed. Now one thing to note here.<br>That calling this method does not withdraw the notification that was posted to the user.<br>If you want to do that then use the existing API for removing delivered notifications with identifiers to get that functionality. All right, now let’s summarize all the new APIs that we’ve looked at today around the notification content extensions.<br>We started with talking about notification actions where now you can access these notification actions as well as replace them dynamically from anywhere in your content extension code. You can now opt in to having user interaction based on touches within your content extension views. You can programmatically launch the application from anywhere in your content extension code as well as dismiss the content extension view, depending upon where you feel it serves best your user’s experience around the content extensions. So that’s a varied list of APIs around content extensions, and we hope this really helps you enhance your user’s experience around your content extensions and then you start using these APIs. So that was notification content extensions. Now, the next topic today we’re going to look at is notification management, and to tell you all about that, let me invite my colleague Teja to the stage.<br>Thank you. Thank you Kritarth.<br>Hi everyone. My name is Teja Kondapalli, and I’m also an engineer on the iOS Notifications’ Team. And, of course, I’m here to talk to you about a couple of the new APIs that we have. The first of which is notification management.<br>But before I dive into this API, I want to cover some of the user facing features to give you some more context and then we can deep dive into the API. As our users get more and more apps on their phones, notifications become the primary way that they interact with these apps. But often, they find themselves in a situation like this.<br>With far too many notifications. And it becomes hard to sift through and find the important ones. So perhaps to make this easier, this user has decided that notifications from podcasts don’t need to be shown on the locked screen.<br>Right now to configure that they’d have to launch the settings app, find notifications, find the podcast app, and then they can configure their settings.<br>We wanted to make this easier. So, in iOS 12, we’re introducing a new management view where the users can configure their notification settings directly from the notification without having to launch the settings app. There’s three really easy ways to get into this management view. The first is what we just saw.<br>You simply swipe over a notification, tap manage, and the management view comes up.<br>The second is if you can go into the rich notification, you can tap in the right corner, and you can also launch the management view. And the third is actually in the list itself. Depending on how your users are interacting with their notifications, they will occasionally see suggestions, like this one, that ask them if they want to keep receiving podcast notifications. And from here, as well, they can tap manage and bring up the management view. Let’s take a closer look at the management view. And we obviously have options here where users can configure their notification settings directly from this view. But if they want to go into the settings app and configure in a more detailed manner, they have a quick link to the settings for this application, the notification settings. A And also from this view, they have some actions they can take directly, the first of which says deliver quietly, which is probably a concept that’s new to all of you. Some of these management views will also have an option that says deliver prominently, so let’s talk about what this means. In iOS, we have a lot of settings that users can configure, and this is really great for the power user. The can customize their settings to every detail, but for the regular user, we think that we can help them out by categorizing their notification settings into two big categories.<br>Notifications that are delivered prominently and notifications that are delivered quietly.<br>Notifications that are delivered prominently are what we’re used to.<br>They show up on the locked screen. They show up in notification center. They roll down as banners. They badge the AP icon and they can play a sound. Notifications that are delivered quietly only show up in notification center and they don’t play a sound. And from the management view, in addition to configuring whether they want their notifications delivered prominently or quietly, users also have the option to turn off their notifications.<br>Now, I know that you might worry that your users are going to turn off the notifications for your app, so we’ve added this extra confirmation sheet just in case they do tap turn off.<br>And from here, they can also turn off their notifications. But we’ve also added an API to add a second option to this confirmation sheet, and podcast has taken advantage of this API, so it says configure in podcast. This is a link that will deep link within the podcast app to a custom settings view that allows the user more granular control about what kind of podcast notifications they want. And as your apps send more and more notifications and various type of notifications, we think it’s really important to allow them this granular level of control over what kind of notifications are important to them.<br>This link can also be accessed from the systems settings app from your apps’ notification settings. And you can see for podcasts it’s right at the bottom.<br>It says podcast notifications settings. Let’s see how we do this in code. In the class that conforms to UNUserNotificationCenter Delegate, we have a new delegate method. Open settings for notification, and as long as you implement this delegate method, those links that we talked about from the management view, or from the settings app, will automatically be populated by the system for you. So when the user taps on any of these links, this delegate method will be called. And it’s really important when this delegate method is called that you immediately take your users into the view where they can configure their notification settings within your app. And if you notice, we have [inaudible] parameter to this method, and it is notification. So depending on where the link was tapped from, if it was tapped from one of the management views, it will have the value of the notification that that management view came from. If it was tapped from the settings app, the value of notification will be nil, and you can use this information to show the appropriate notification settings when this delegate method is called.<br>So that’s what we have for notification management. It’s a new way for your users to configure whether they want their notifications delivered prominently or quietly, or turn them off, or even configure them at a granular level within your app.<br>And to encourage your users to keep getting your notifications delivered, we think it’s really important that you make the content in the notifications relevant.<br>We also encourage you to use thread identifiers to group the notifications when you think it’s appropriate. This will help the users organize their lists better and will make sure that they’re not overwhelmed by the notifications from your app.<br>We also think that as your apps send various types of notifications, it’s really important to provide that custom settings view within that app so that users have more granular control about what kind of notifications are important to them.<br>That’s what we have for notification management. And the next big feature I want to talk to you about is provisional authorization. Right now, when a user installs your app, before they start receiving notifications, at some point they’ll have to respond to a prompt that looks like this, which is asking them if they want these notifications.<br>And the biggest problem with this is, at this point, the user doesn’t know what kind of notifications this app is going to send, so they don’t know if they want them or not.<br>So, in iOS 12, we’re introducing provisional authorization, and this is an automatic trial of the notifications from your app. This will help your users make a more informed decision on whether they want these notifications or not. So you can opt into this, and if you do, your users will not get that authorization prompt that we just saw.<br>Instead, the notifications from your app will automatically start getting delivered.<br>But these notifications will be delivered quietly, and if we recall, notifications that are delivered quietly only show up in notifications center, and they don’t play a sound.<br>Notifications that are delivered with provisional authorization will have a prompt like this on the notification itself. And this will help the users decide after having received a few notifications whether they want to keep getting these notifications or whether they want to turn them off. And this turn off confirmation sheet will also have the custom settings link if you have provided it. Let’s see how you can do this in code. In the location where you regularly request authorization, in addition to whatever options you might be requesting, you can add a dot qualifying option called .provisional. And if you include this, you will automatically start participating in the trial. It’s really important to note that the .provisional option is in addition to whatever other options you may be providing. That’s because if the users decide to keep getting your notifications delivered, we want to know how you want them delivered, with badges or sounds or as alerts. So that’s what provisional authorization is. It’s an automatic trial of the notifications from your app to help your users make a more informed decision about whether they want these notifications.<br>And again, to encourage your users to keep getting your notifications delivered, it’s really important to make the content in your notifications relevant.<br>And also, it’s really important to use .provisional as a qualifier option in addition to whatever other options you’re requesting. That’s what we have for provisional authorization. And the last big feature that I want to talk to you about are critical alerts. Often when I’m in the middle of a meeting or attending something important, my phone looks like this. And as you can see, I have do not disturb turned on. Or at least I have the ringer switch turned off so that I don’t hear any sounds when I get notifications. And usually this is really good, but I would have missed a really important notification like this one.<br>This is a health-related notification. That’s from a glucose monitor that’s warning me of low blood sugar, and this is something I would want to see immediately.<br>Scenarios like this made us realize that we need a new type of notification, and this is what we call critical alerts. Critical alerts are medical- and health-related notifications.<br>Or home- and security-related notifications. Or public safety notifications.<br>And the key to a critical alert is that it requires the user to take action immediately.<br>The way that critical alerts behave is that they bypass both do not disturb and the ringer switch, and they will play a sound. And they can even play a custom sound. But what that means is that these are very disruptive, and for that reason we don’t think that all apps should be able to send critical notifications.<br>Critical alerts. So in order to start sending a critical alert, you will need to apply for entitlement, and you can do that on the developer.apple website.<br>This is what a critical alert looks like, and you can see that it has a unique icon indicating that it’s critical. And it would have also come in with a sound.<br>Critical alerts also have their own section in notifications settings.<br>This means that a user can choose to allow critical alerts for a particular application but choose not to allow any other type of notification. And before users start receiving critical alerts, they will have to accept a prompt that looks like this that’s asking them specifically whether they want to accept critical alerts from a particular application.<br>So, of course, in order to start sending critical alerts, you’ll have to request authorization.<br>So after you apply for entitlement and get it, in the place where you regularly request authorization, in addition to whatever other options you want to request, you can also request a .criticalAlert option. And this will give your users the prompt. And let’s see how it actually set up and send a critical alert. It actually behaves very similarly to a regular notification. You can see that I just set up a notification with the title body and category identifier, but what distinguishes this as a critical alert is that it plays a sound. So I need to set a critical alert sound.<br>And here, you can see that I’m setting the default critical alert sound that’s provided by the framework. I can also set a custom sound. And I can also set a custom audio volume level. And of course, critical alerts can also be push notifications so all of this information can be set in the push payload as well.<br>So that’s what we have for critical alerts. They’re a new type of notification that requires the users to take action immediately.<br>And they’re very disruptive, so you need entitlement to be able to send them.<br>So that’s all the new exciting APIs that we have for you today. I just want to quickly go over all the things that we covered. We talked about how you can use thread identifiers to group your notifications to help your users organize their notification lists better.<br>We talked about all the great new APIs around notification content extensions, which will help you make your rich notifications much more interactive.<br>We talked about how you can provide a custom settings view within your app to allow your users more granular control over what kind of notifications they want to receive.<br>We also talked about provisional authorizations, which is an automatic trial of the notifications from your app, which will help you users make a more informed decision about whether they want these notifications or not. And last, we talked about critical alerts, which are a new type of notification that requires the user to take action immediately and that are disruptive. So we hope you take advantage of all of these great APIs and make the notification experience for your users even better.<br>You can find all the information about this session on our sessions’ page at developer.apple.com. We’re session 710. We have another session just following this one in hall three called using grouped notification where we’ll help you determine how to best group notifications for your app. We have two notifications labs, one today and one tomorrow, where you can come and ask the engineers on our team any questions that you may have. And on Friday morning, we have an interesting session called designing notifications. That’s going to be hosted by the designers who helped us come up with the designs for these, and they’ll be talking about notification best practices.<br>Thank you and have a great dot dot.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.&lt;br&gt;下午好，欢迎大家来这个叫做what’s new in user notifications的session &lt;/p&gt;
    
    </summary>
    
      <category term="WWDC" scheme="http://yoursite.com/categories/WWDC/"/>
    
    
      <category term="Notifications" scheme="http://yoursite.com/tags/Notifications/"/>
    
  </entry>
  
  <entry>
    <title>IOS12 兼容</title>
    <link href="http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/"/>
    <id>http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/</id>
    <published>2018-08-22T04:07:12.000Z</published>
    <updated>2018-09-13T08:02:47.563Z</updated>
    
    <content type="html"><![CDATA[<p>主要遇到的问题：</p><ol><li>Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</li><li>CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中</li></ol><a id="more"></a><h2 id="libstdc-问题"><a href="#libstdc-问题" class="headerlink" title="libstdc++问题"></a>libstdc++问题</h2><ul><li>现象是无法找到libstdc++，编译报错如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">library</span> <span class="selector-tag">not</span> <span class="selector-tag">found</span> <span class="selector-tag">for</span> <span class="selector-tag">-lstdc</span>++<span class="selector-class">.6</span><span class="selector-class">.0</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><h3 id="临时解决方案"><a href="#临时解决方案" class="headerlink" title="临时解决方案"></a>临时解决方案</h3><ul><li>临时解决办法—-从Xcode9中复制libstdc++库到Xcode10中，命令如下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span></span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span></span><br></pre></td></tr></table></figure><ul><li>最终解决办法：</li></ul><p>需要联系第三方公司，将GMThirdParty/BestPay 、GMF_EaseMobSDK2.2.9更新。</p><h3 id="模拟器无法启动的解决方案"><a href="#模拟器无法启动的解决方案" class="headerlink" title="模拟器无法启动的解决方案"></a>模拟器无法启动的解决方案</h3><p>报错如下：    </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">dyld:</span> Library not <span class="symbol">loaded:</span> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span></span></span><br><span class="line">  Referenced <span class="symbol">from:</span> /Users/lijian/Library/Developer/CoreSimulator/Devices/<span class="number">6</span>CB2CF98-<span class="number">149</span>C-<span class="number">43</span>A1-<span class="number">8</span>A93-<span class="number">516</span>FE4243C8C/data/Containers/Bundle/Application/<span class="number">2</span>C25BADD-A36F-<span class="number">4</span>B11-<span class="number">9885</span>-<span class="number">34E8</span>AEE826AC/GomeStaff.app/GomeStaff</span><br><span class="line">  <span class="symbol">Reason:</span> no suitable image found.  Did <span class="symbol">find:</span></span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libstdc</span>++.6.<span class="title">dylib</span>: <span class="title">mach</span>-<span class="title">o</span>, <span class="title">but</span> <span class="title">not</span> <span class="title">built</span> <span class="title">for</span> <span class="title">iOS</span> <span class="title">simulator</span></span></span><br></pre></td></tr></table></figure><p>原因分析： </p><p>上面的错误的含义是动态链接器无法加载到libstdc++.6.dylib，但是真机上是可以加载出来，所以，推测模拟器的运行环境去掉了这个库，那么，我们如果将模拟器的运行环境中添加上这个库，是不是就可以了？ 答案是肯定的。</p><p>下面的问题是：我么如何找到模拟器运行环境加载库的路径呢？ 我的思路是使用xcode9运行模拟器，然后打印系统库的加载路径，这个路径就是我们要找的路径。</p><p>查找系统库的方法如下,用xcode9运行下面的代码：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach-o/dyld.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span><span class="comment">; i &lt; _dyld_image_count(); i++)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> char* aa = _dyld_get_image_name(i)<span class="comment">;</span></span><br><span class="line">    NSString *str = [NSString stringWithUTF8String:aa]<span class="comment">;</span></span><br><span class="line">    LOG_LJ_(@<span class="string">"~~~~~~~~~~~~~~~~~~~~~~~~%@"</span>,str)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="regexp">/Users/lijian</span><span class="regexp">/Downloads/</span>Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libiconv</span>.2.<span class="title">dylib</span></span></span><br></pre></td></tr></table></figure><p>上面的路径就是模拟器的系统库路径。所以，将xcode9对应目录下的三个libstdc++复制到xcode10的对应目录即可。</p><h2 id="CocoaPods无法复制资源到app中"><a href="#CocoaPods无法复制资源到app中" class="headerlink" title="CocoaPods无法复制资源到app中"></a>CocoaPods无法复制资源到app中</h2><p>现象：登录界面没有图标，或者启动时 NSBundle的initWithUrl方法崩溃。</p><p>解决办法：</p><ol><li>升级CocoaPods到1.4.0，命令是：<code>sudo gem install -n /usr/local/bin cocoapods -v 1.4.0</code> 。</li><li>移除<code>Build Phases</code> 中的 <code>[cp]Copy Pods Resources</code> 。</li><li>重新pod install。</li></ol><h2 id="info-重复问题"><a href="#info-重复问题" class="headerlink" title="info 重复问题"></a>info 重复问题</h2><p>报错如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Multiple commands produce <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span>:</span><br><span class="line"><span class="number">1</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> <span class="keyword">copy</span> command <span class="keyword">from</span> <span class="string">'/Users/lijian/Desktop/GomeGit/GomeStaff/GomeStaff/Supporting Files/Info.plist'</span> <span class="keyword">to</span> <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br><span class="line"><span class="number">2</span>) Target <span class="string">'GomeStaff'</span> (project <span class="string">'GomeStaff'</span>) <span class="keyword">has</span> process command <span class="keyword">with</span> output <span class="string">'/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'</span></span><br></pre></td></tr></table></figure><p>原因分析：Xcode自动会将Info.plist复制到GomeStaff.app中，但是在Build Phases-&gt; Copy Bundle Resources中也包含复制Info.plist的功能，这样就两次复制，第二次复制失败。</p><p>解决方法：</p><p>将Build Phases-&gt; Copy Bundle Resources  中的info.plist 去掉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5b1634f0f265da6e61788998" rel="external nofollow noopener noreferrer" target="_blank">Xcode10和iOS12踩坑</a></li><li><a href="http://www.cocoachina.com/ios/20180611/23749.html" rel="external nofollow noopener noreferrer" target="_blank">libstdc++适配Xcode10与iOS12</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要遇到的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。&lt;/li&gt;
&lt;li&gt;CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="IOS12" scheme="http://yoursite.com/categories/IOS/IOS12/"/>
    
    
      <category term="IOS12 兼容" scheme="http://yoursite.com/tags/IOS12-%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>类</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/%E7%B1%BB/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第七章类/类/</id>
    <published>2018-08-20T04:07:12.000Z</published>
    <updated>2018-09-19T10:52:28.140Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>定义抽象数据类型</li><li>访问控制与封装</li><li>类的其他特性</li><li>类的作用域</li><li>构造函数再探</li><li>类的静态成员</li></ol><p>数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。</p><a id="more"></a><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="一、设计Sales-data类"><a href="#一、设计Sales-data类" class="headerlink" title="一、设计Sales_data类"></a>一、设计Sales_data类</h3><ol><li>一个isbn成员函数，返回对象的ISBN编号</li><li>一个combine成员函数，用于将一个Sales_data对象加到另一个对象上</li><li>一个名为add的函数，执行两个Sales_data对象的加法</li><li>一个read函数，将数据从istream读入到Sales_data对象中</li><li>一个print函数，将Sales_data对象的值输入到ostream </li></ol><h3 id="二、定义改进的Sales-data类"><a href="#二、定义改进的Sales-data类" class="headerlink" title="二、定义改进的Sales_data类"></a>二、定义改进的Sales_data类</h3><p>定义在类内部的函数隐式的inline函数。</p><p>成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。对我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">total</span><span class="selector-class">.isbn</span>()</span><br></pre></td></tr></table></figure><p>则编译器负责把total的地址传给isbn的隐式参数this，可以等价的认为编译器将该调用重写成如下形式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Sales_data:</span>:isbn(<span class="variable">&amp;total</span>);</span><br></pre></td></tr></table></figure><p>this是常量指针，我们不允许改变this中保存的地址。</p><p>const成员函数： 紧随参数列表后面的const关键字表示const成员函数。这里的const的所用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。这也意味着我们不能把this绑定到一个常量对象上。不能在一个常量对象上调用普通成员函数。</p><p>常量对象以及常量对象的引用或者指针都只能调用常量成员函数。</p><p>类的作用域和成员函数： </p><ol><li>返回类型、参数列表、函数名都得于类内部的声明一样</li><li>如果成员被定义成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。</li><li>类外部定义的成员的名字必须包含所属的类名</li></ol><h3 id="三、定义类相关的非成员函数"><a href="#三、定义类相关的非成员函数" class="headerlink" title="三、定义类相关的非成员函数"></a>三、定义类相关的非成员函数</h3><p>IO类属于不能拷贝的类型，所以只能通过引用来传递他们，而且，因为读取和写入的操作会改变流的内容，所以两个函数接受都是普通引用，而非对常量的引用。</p><h3 id="四、构造函数"><a href="#四、构造函数" class="headerlink" title="四、构造函数"></a>四、构造函数</h3><p>类通过特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时，只要类的对象被创建，就会执行构造函数。</p><p>构造函数的名字和和类名相同，和其他函数不一样的是，构造函数没有返回类型。</p><p>构造函数不能声明为const的，当我们创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得常量属性，所以构造函数在const对象构造的过程中，是可以向其写值的。</p><p>合成的默认构造函数：类通过特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。合成默认构造函数初始化规则：</p><ol><li>如果存在类内初始值，用它初始化</li><li>否则，默认初始化</li></ol><p>某些类不能依赖合成的默认构造函数，原因有三：</p><ol><li>只有当类内没有声明任何构造函数时，编译器才会自动的生产默认构造函数。</li><li>如果累内部有内置类型或者符合类型成员，则只有当这些成员全部被赋予了类内初始值时，这个类才适合使用合成的默认构造函数。</li><li>有些类不能合成默认的构造函数</li></ol><p>=default： 如果我们定义了其他的构造函数，同时，也需要默认构造函数，并且默认构造函数的功能等同于合成的默认构造函数，使用=default来要求编译器生成构造函数。如果=default在类的内部，则是内联的。</p><p>构造函数初始值列表：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(const <span class="attribute">std</span>::string &amp; s,unsinged n, double p)<span class="selector-pseudo">:bookNo(s)</span>,<span class="selector-tag">unit_sold</span>(n),<span class="selector-tag">revenue</span>(p*n)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>冒号和花括号之间的代码称为构造函数初始值列表。当某个数据成员被构造函数初始值列表忽略时，他将以合成默认构造函数相同的方式隐式初始化。</p><h3 id="拷贝、赋值、析构"><a href="#拷贝、赋值、析构" class="headerlink" title="拷贝、赋值、析构"></a>拷贝、赋值、析构</h3><p>拷贝、赋值、析构发生的场景</p><ol><li>拷贝：初始化变量、以值的方式传递、返回一个对象。（用同类型的对象或者自己类型的对象）</li><li>赋值：使用赋值运算符时发送。</li><li>析构：当对象不存在时销毁，超出作用域、vector容器销毁时存储在其中的对象销毁</li><li>构造： 用成员的值创建（不是自己的类型）</li></ol><p>如果我们不主动定义这些操作。编译器将替我们合成默认的。编译器生成的版本将对对象的每个成员执行拷贝、赋值、销毁操作。</p><p>某些类不能依赖合成的版本：例如动态类型。vector、string能避免分配和释放内存带来的复杂性。如果类中包含vector、string，合成的版本能正常工作</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符（access specifiers）控制类的封装性</p><ol><li>定义在public说明符后面的成员在整个程序内可以被访问。public成员定义类的接口</li><li>定义在private说明符之后的成员可以被类的成员访问，但不能被类的使用者访问。private部分封装了类的实现细节。</li></ol><p>使用class、struct关键字：class和struct定义的唯一区别是默认的访问权限。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的。如果是class，则是private。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他的类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元（friend），如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。</p><p>友元声明只能出现在类定义的内部，但是在类内部出现的位置不限，友元不是类的成员，也不受它所在区域访问控制级别的约束。</p><p>封装的优点：</p><ol><li>用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ol><p>友元的声明：友元的声明仅仅指定了访问权限，而非一个通常意义上的声明，如果我们需要类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。</p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>这些特性包括：类型成员、类的成员的类内初始值、可变数据成员、从成员返回this* 、关于如何定义并使用类类型及友元类。</p><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>类型成员： 某种类型在类中的别名。类定义的类型名字和其他成员一样，存在访问控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pos cursor = <span class="number">0</span>;</span><br><span class="line">pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型成员必须先定义后使用。 和类的其他成员的区别</p><p>因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认构造函数，如果我们的类需要默认构造函数，必须显示的把他声明出来。</p><p>令成员作为内联函数：定义在类内部的成员函数自动是inline的。</p><p>我们无需在声明和定义的地方同时说明inline，单这么做是合法的。不过最好只在类的外部定义的地方说明inline，这样可以使类更容易理解。</p><p>inline成员函数也应该与相应的类定义在同一个头文件中。</p><p>重载成员函数：和普通成员函数一样。</p><p>可变数据成员： 有时，我们希望能修改类的某个数据成员，即使是在一个const成员函数。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员永远不会是const的，即使const对象的成员。</p><p>类内初始值：必须使用等号或者花括号</p><h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>从const成员函数返回<em>this，一个const成员函数如果以引用的形式返回</em>this，那么他的返回类型将是常量引用。</p><p>基于const的重载：通过成员函数是否是const的，我们可以对其进行重载。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>类的声明： class Screen </p><p>对于类型Screen来说，在它的声明之后定义之前，是一个不完全类型（incomlete type）。也就是说，此时我们已知Screen是一个类类型，但是不清楚他到底包含哪些成员。</p><p>不完全类型只能在非常有限的情景下使用，可以定义指向这种类型的指针或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数</p><h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把其他的类定义成友元，也可以把其他类（之前定义过的）的成员函数定义成友元</p><p>类之间的友元：如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元不存在传递性</p><p>令成员函数作为友元：</p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了。这里的剩余部分包括参数列表、函数体。</p><p>函数的返回类型通常出现在函数名之前，因此，当成员杉树定义在类的外部，返回类型中使用的名字都位于类的作用域之外。</p><h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p>名字查找（name lookup）</p><p>普通名字查找：</p><ol><li>在名字所在的块中寻找其声明语句，只考虑名字的使用之前出现的声明</li><li>如果没有找到，继续查找外层作用域</li><li>如果最终没有找到匹配的声明，则程序报错</li></ol><p>类的定义步骤：</p><ol><li>首先，编译成员的声明</li><li>知道类全部可见后，编译函数体</li></ol><p>编译器处理完类中的全部声明后，才会处理成员函数的定义</p><p>用于类成员声明的名字查找：上面两阶段的处理方式只适用于成员函数中适用的名字，声明中使用的名字，包括返回类型、参数列表中使用的名字，都必须在使用前确保可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal;&#125;;</span><br><span class="line"></span><br><span class="line">Money bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money 出现在声明中，所有从使用处开始找名字，找到了外层的double。 balance 函数体，等成员声明编译完后，处理，所以bal是成员。不是外层的string。</p><p>类型名需要特殊处理：类内部不能重新定义外层作用域中的类型名字，类内部的类型名字定义放在类的开始处，</p><p>成员定义中的普通块作用域中的名字查找：</p><ol><li>首先在成员函数内查找名字的声明，只有在函数使用前面出现的声明才被考虑</li><li>如果在成员函数内没有找到，则在类内继续查找，这是类的所有成员都可以考虑</li><li>如果类内也没有该名字的声明，在成员函数定义之前的作用域内继续查找。</li></ol><p>不建议成员的名字作为某个成员函数的参数。</p><p>类作用域之后，在外围作用域中查找：  可以使用::访问隐藏的外层中的名字 。</p><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示的初始化成员，则该成员在构造函数体之前执行默认初始化。</p><p>构造函数的初始值有时必不可少：有时候我们可以忽略数据成员的初始化和赋值之间的差异，单并非总是这样，如果成员有const或者引用的话，必须将其初始哈。</p><p>随着构造函数体的开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。</p><p>成员是const、引用或者属于某种未提供默认构造函数的类型。我们必须通过构造函数初始值列表为这些成员提供初始值。</p><p>成员初始化顺序：成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者把他自己的一些职责委托给了其他构造函数 。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(<span class="attribute">std</span>::string s, unsigned cnt , double price )<span class="selector-pseudo">:bookNo(s)</span>, <span class="selector-tag">units_sold</span>(cnt),<span class="selector-tag">revenue</span>(cnt*price)&#123;&#125;</span><br><span class="line"><span class="selector-tag">Sales_data</span>()<span class="selector-pseudo">:Sales_data(""</span>,<span class="selector-tag">0</span>,<span class="selector-tag">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体一次被执行，然后将控制权交给委托函数体。</p><h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或者值初始化时，自动执行默认构造函数。 默认初始化发送的场景：</p><ol><li>当我们在快作用域内，不适用任何初始值定义一个非静态变量。</li><li>当一个类本身还有一个类类型的成员，且使用合成的默认构造函数。</li><li>当类类型成员没有在构造函数初始值列表中显示的初始化时。</li></ol><p>值初始化发生的场景：</p><ol><li>在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时。</li><li>当我们不适用初始值定义一个局部静态变量时</li><li>当我们通过书写形如T()的表达式显示的请求值初始化时。</li></ol><p>实际中，如果定义了其他的构造函数，那么最好定义一个默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>; <span class="comment">///声明了一个函数，而非对象</span></span><br><span class="line">Sales_data obj2;  <span class="comment">///obj2是一个对象，默认初始化</span></span><br></pre></td></tr></table></figure><h3 id="隐式的类类型转化"><a href="#隐式的类类型转化" class="headerlink" title="隐式的类类型转化"></a>隐式的类类型转化</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转化机制，有时候，我们把这样的构造函数称为转换构造函数。</p><p>能通过一个实参调用的构造函数，定义了一条从构造函数的参数类型向类类型隐式转化的规则。</p><p>只允许一步类型转换</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.combine(<span class="string">"9-999-9999"</span>); <span class="regexp">//</span>错误，两步转化，<span class="number">1</span>、char * -&gt;string <span class="number">2</span>. string-&gt;Sales_data</span><br></pre></td></tr></table></figure><p><strong>抑制构造函数定义的隐式转化：</strong> 我们可以通过将构造函数声明成explicit加以阻止。</p><p>关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式类型转换，所以无需将这些构造函数指定为explicit，只能在类内声明构造函数时使用explicit关键字，在类外部定义时，不应该重复。</p><p>explicit构造函数只能用于直接初始化：不能将explicit构造函数用于拷贝形式的初始化过程。当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，而且，编译器不会再自动类型转换过程中使用该构造函数。</p><p>显示类型转换可以使用explicit构造函数。</p><p>标准库中含有显示构造函数的类：</p><ol><li>接受一个参数const char*的string的构造函数不是explicit的</li><li>接受一个容量参数的vector的构造函数是explicit的。</li></ol><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>特定：</p><ol><li>所有成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类、virturl函数。</li></ol><p>可以提供一个花括号括起来的成员初始值列表。列表中成员的顺序和聚合类的成员的顺序一直， 如果初始值列表的元素的个数少于成员数量，后面的被值初始化。</p><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><h3 id="声明静态成员"><a href="#声明静态成员" class="headerlink" title="声明静态成员"></a>声明静态成员</h3><p>类的静态成员和类本身直接相关。静态函数没有this，静态成员函数不能声明成const的。而且我们也不能再static函数体内使用this指针</p><h3 id="使用类的静态成员"><a href="#使用类的静态成员" class="headerlink" title="使用类的静态成员"></a>使用类的静态成员</h3><ol><li>使用作用域访问静态成员</li><li>通过对象访问静态成员</li><li>成员函数可以不通过作用域直接访问静态成员。</li></ol><h3 id="定义静态成员"><a href="#定义静态成员" class="headerlink" title="定义静态成员"></a>定义静态成员</h3><p>我们可以在类的内部、外部定义静态成员函数。在类的外部定义静态成员时，不能重复static关键字，该关键字只能在类的内部声明语句中。静态成员不属于任何一个对象，他们不是在类创建的时候定义的，这意味着不能由类的构造函数初始化。</p><h3 id="静态成员类内初始值"><a href="#静态成员类内初始值" class="headerlink" title="静态成员类内初始值"></a>静态成员类内初始值</h3><p>通常情况下，静态成员不应该在类的内部初始化，然而，我们可以为静态成员提供const整数类型的类内初始值。</p><p>即使一个常量静态数据成员在类内部被初始化了，通常情况下，他们也应该在类外部定义下该成员。</p><h3 id="静态数据成员的特殊功能"><a href="#静态数据成员的特殊功能" class="headerlink" title="静态数据成员的特殊功能"></a>静态数据成员的特殊功能</h3><ol><li>可以是不完全类型</li><li>可以作为默认实参。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义抽象数据类型&lt;/li&gt;
&lt;li&gt;访问控制与封装&lt;/li&gt;
&lt;li&gt;类的其他特性&lt;/li&gt;
&lt;li&gt;类的作用域&lt;/li&gt;
&lt;li&gt;构造函数再探&lt;/li&gt;
&lt;li&gt;类的静态成员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第七章类" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>表达式</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第四章 表达式/表达式/</id>
    <published>2018-08-14T04:07:12.000Z</published>
    <updated>2018-08-16T02:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>基础</li><li>算术运算符</li><li>逻辑和关系运算符</li><li>赋值运算符</li><li>递增和递减运算符</li><li>成员访问运算符</li><li>条件运算符</li><li>位运算符</li><li>sizeof运算符</li><li>逗号运算符</li><li>类型转换运算符</li><li>运算符优先级</li></ol><p>运算符优先级大概层级：</p><ol><li>作用域运算符</li><li>成员选择、下标、函数调用</li><li>后置加加减减、类型id，类型转化</li><li>一元运算符</li><li>乘法</li><li>加法</li><li>移位</li><li>关系</li><li>位</li><li>逻辑</li><li>条件</li><li>赋值</li><li>逗号</li></ol><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>优先级（precedence）</li><li>结合律（asscociativity）</li><li>求值顺序</li></ol><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存的位置）。</p><ol><li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也是一个左值。</li><li>取地址运算符作用域左值运算对象，返回一个指向改运算对象的指针，这个指针是一个右值。</li><li>内置解引用、下标运算符、迭代器解引用求值结果是左值.</li><li>内置类型、迭代器递增运算符作用域左值，前置版本结果左值.</li></ol><p>使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。</p><ol><li>优先级</li><li>结合律</li><li>求值顺序</li></ol><p>有4种表达式明确规定了求值顺序</p><ol><li>逻辑与&amp;&amp;</li><li>逻辑或||</li><li>条件运算符？：</li><li>逗号表达式</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>(-m)/n = m/(-n) = -(m/n)</p><p>m%(-n) = m%n</p><p>(-m)%n = -(m%n)</p><p>m%n的符号和m的相同</p><h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>逻辑与、逻辑或求值短路</p><p>几个关系运算符链子一起会产生意想不到的结果</p><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的结果是左侧运算对象，并且是左值。如果赋值运算符的两个运算对象类型不同，右侧对象将转换为左侧运行对象类型。</p><p>赋值运算符满足右结合律，这个和其他的二元运算符不太一样。</p><p>赋值运算符的优先级低于关系运算符</p><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>为啥有？ 某些迭代器不支持算术运算</p><ol><li>前置版本递增：首先将运算对象加1，然后将改变后的对象作为求值结果。</li><li>后置版本的递增：将运算对象加1，但是求值结果是运算对象改变之前的那个值的副本。</li></ol><p>优先使用前置版本，前置版本的递增运算符避免了不必要的功过，把加1后的对象直接返回，相反：后置版本需要将原始值存储下来，以便返回未修改的内容，对于复杂的迭代器，这种额外的工作消耗巨大。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*iter++  <span class="comment">//这种写法比较普遍，后置++的优先级高,等价于下面两行代码</span></span><br><span class="line">*iter;</span><br><span class="line">++iter</span><br><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">while</span>(pbeg != v.<span class="built_in">end</span>() )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">end</span> ;  <span class="comment">//输出当前值，并将pbeg向前移动一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span> (<span class="built_in">begin</span> != v.<span class="built_in">end</span> &amp;&amp; !isspace(*<span class="built_in">begin</span>))</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>++);  <span class="comment">//错误：该语句未定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///可以解释为下面的任何一种</span></span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>);</span><br><span class="line">*(<span class="built_in">begin</span>+<span class="number">1</span>) = touper(*<span class="built_in">begin</span>)</span><br></pre></td></tr></table></figure><p>所以，如果一条子表达式改变了某个运算对象的值，另一个表达式又要使用该值的话，运算符的求值顺序非常关键。</p><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>表达式ptr-&gt;mem 等价于 (*ptr).mem。</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种两种情况：如果成员所属的对象是左值，结果是左值，反之，如果成员所属的对象是右值，那么结果是右值。</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符将简单的if else 逻辑切入到单个表达式当中。基本形式</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond</span>? <span class="symbol">expr1:</span> expr2</span><br></pre></td></tr></table></figure><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>二进制移位，移出边界之外的位就被舍弃掉了</p><p>位求反运算符~ 将运算对象逐位求反。</p><p>如果运算对象是小整数，它的值会被自动提升。</p><ol><li>位于 &amp;</li><li>位或 |</li><li>位异或 ^</li></ol><h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof返回一个表达式或者一个类型名字所占的字节数，满足右结合律，返回值类型是size_t类型。sizeof并不计算运算对象的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure><p>sizeof *p  sizeof不需要解引用指针也能知道它所指对象的类型，所以即使p是无效指针也不会有什么影响。</p><ol><li>对char或者类型是char的表达式执行sizeof运算，结果是1.</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li><li>对指针执行sizeof运算，得到指针本身所占内存的大小</li><li>对解引用指针指向sizeof运算，得到指针所指对象所占空间的大小，指针不需要有效</li><li>对数组执行sizeof运算，得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算，并求和。sizeof不会把数组转化为指针。</li><li>对string、vector对象执行sizeof运算，只返回该类型固定部分大小。不会计算对象中元素所占空间。</li></ol><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么求值结果是左值。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则，设法将运算对象的类型统一后再求值。</p><p>隐式类型转换发生场景</p><ol><li>在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。</li><li>在条件中，非布尔类型转换为布尔类型。</li><li>初始化过程中，初始值转换为变量的类型。在赋值语句中，右侧对象转换为左侧运算对象类型</li><li>算术或者关系运算对象有多种类型，需要转换为同一种类型</li><li>函数调用时会发生类型转换</li></ol><h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>整数提示：char signed char、 unsigned char、 short 、unsigned short 、bool 一般会提升为int </p><p>有符号的转化为无符号的（大小相等）<br>整数转化为浮点数<br>转化为宽类型</p><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><ol><li>数组转成指针： 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作decltyoe关键字参数，或者取地址&amp;，sizeof及typeid等运算对象时，上述转化不会发生。如果用引用初始化数组，也不会发生转化。</li><li>指针的转化：常量整数0或者字面值nullptr能转化成任意指针类型。指向任何非常量指针能转换成void<em> 指向任何对象的指针能转化成const void </em></li><li>转换成布尔类型：存在一种从算术类型或者指针类型向布尔类型自动转化的机制，如果指针或算术类型值为0，转换结果是false，否则转换结果是true。</li><li>转换成常量：允许冲非常量类型的指针转化为常量类型的指针。</li><li>命名的强制类型转换。</li></ol><p>static_cast：任何具有明确定义的类型转化，只要不包含底层const，都可以使用<br>const_cast：只能改变运算对象的底层const<br>reinterpret_cast: 通常为运算对象的位模式提供较底层次上的重新解释。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础&lt;/li&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;逻辑和关系运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;递增和递减运算符&lt;/li&gt;
&lt;li&gt;成员访问运算符&lt;/li&gt;
&lt;li&gt;条件运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;sizeof运算符&lt;/li&gt;
&lt;li&gt;逗号运算符&lt;/li&gt;
&lt;li&gt;类型转换运算符&lt;/li&gt;
&lt;li&gt;运算符优先级&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运算符优先级大概层级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用域运算符&lt;/li&gt;
&lt;li&gt;成员选择、下标、函数调用&lt;/li&gt;
&lt;li&gt;后置加加减减、类型id，类型转化&lt;/li&gt;
&lt;li&gt;一元运算符&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;移位&lt;/li&gt;
&lt;li&gt;关系&lt;/li&gt;
&lt;li&gt;位&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;条件&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;逗号&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第四章 表达式" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串、向量、数组</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/</id>
    <published>2018-08-10T04:07:12.000Z</published>
    <updated>2018-08-14T09:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>命令空间的using声明</li><li>标准库类型string</li><li>标准库类型vector</li><li>迭代器介绍</li><li>数组</li><li>多维数组</li></ol><p>基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。</p><a id="more"></a><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>std::cin中作用域运算符的含义：编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。</p><p>using声明的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>using 声明每次只能引入一个名字。using 声明必须以分号结束。</p><p>头文件不应该包括using声明。</p><h2 id="标准库string"><a href="#标准库string" class="headerlink" title="标准库string"></a>标准库string</h2><p>C++标准一方面对库类型所提供的操作做了详细的规定、另一方面也对库的实现者做了性能的要求。</p><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化对象由类的本身决定的。</p><p>初始化sting对象的方式</p><table><thead><tr><th>初始化形式</th><th>说明</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1是空串</td></tr><tr><td>string s2(s1)</td><td>s2是s1的一个副本</td></tr><tr><td>string s2= s1</td><td>等价于s2(s1)</td></tr><tr><td>string s3(“value”)</td><td>s3是字面值value的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于s3(“value”)</td></tr><tr><td>string s4(n,’c’)</td><td>初始化为连续n个字符c组成的字符串</td></tr></tbody></table><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><ol><li>拷贝初始化（copy initialization）：使用等号（=）初始化一个变量</li><li>直接初始化：不用等号</li></ol><p>当初始值只有一个时，使用直接初始化和拷贝初始化都行，如果用到多个初始值，一般来说只能直接初始化。如果非要用拷贝初始化也可以，需要显示的创建一个临时对象用于拷贝。</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>一个类除了规定初始化对象的方式外，还要定义对象上所能执行的操作。</p><table><thead><tr><th>操作示例</th><th>说明</th></tr></thead><tbody><tr><td>os&lt;&lt;s</td><td>将s写到输出流os当中，返回os</td></tr><tr><td>is&gt;&gt;s</td><td>从is中读取字符串赋给s，字符串以空白介绍，返回s</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用</td></tr><tr><td>s1+s2</td><td>返回s1、s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1 == s2</td><td>如果s1和s2所含的字符完全一样，则他们相等</td></tr><tr><td>s1 != s2</td><td></td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较</td></tr></tbody></table><h4 id="读取string对象"><a href="#读取string对象" class="headerlink" title="读取string对象"></a>读取string对象</h4><p>string对象会自动忽略开头的空白（空格，换行、制表符）并从第一个真正的字符开始算起，知道遇到下一处空白为止。</p><p>sting对象的此类输入输出操作返回运算符左侧的运算对象，所以，如果多个输入或者多个输出可以连在一起写。</p><h4 id="使用getline读取一行"><a href="#使用getline读取一行" class="headerlink" title="使用getline读取一行"></a>使用getline读取一行</h4><p>getline函数从给定的输入流中读入内容，直到遇到换行符为止，换行符的内容也被读入进来。然后将所读的内容从存入到string中。</p><p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。</p><h4 id="string的empty、size操作"><a href="#string的empty、size操作" class="headerlink" title="string的empty、size操作"></a>string的empty、size操作</h4><p>size返回的是string:size_type</p><p>string的相等意味着长度相同，且所包含的字符也完全相等。</p><p>当把string对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个加法的两侧的运算符对象至少有一个是string。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>cctype头文件中定义了一组标准函数处理字符：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>当c是字母或数字时为真</td></tr><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符时为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不为空格，单可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真，空格，可视字符</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(空格、制表符、回车、换行、进制符)</td></tr><tr><td>issupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母，否则原样输出</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大小字母，否则原因输出</td></tr></tbody></table><p>c语言的头文件形如name.h，在C++中将这些文件命名为cname，也就是去掉了.h后缀，在name名字前添加了字母c，这里的c表示是一个属于c语言标准库的头文件。cnmae的头文件中定义的明智属于命名空间std。而定义在.h的名字则不在。</p><h4 id="范围for语句（range-for）"><a href="#范围for语句（range-for）" class="headerlink" title="范围for语句（range for）"></a>范围for语句（range for）</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : <span class="type">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>其中expression部分是一个对象，表示序列。declaration是定义一个变量，用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> c : str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///对字符串c的每个字符c做某种操作</span></span><br></pre></td></tr></table></figure><p>如果想改变string对象中的字符的值，必须把循环变量定义成引用类型。这个变量实际上绑定到序列中的每个元素。</p><p>下标运算符：通过位置，返回该位置上字符的引用。 使用超出下标范围将引发不可预知的结果，使用下标访问空string也引发不可预知结果。</p><p>不管什么时候，只要对string对象使用下标，都要确认在那个位置上确实有值。</p><p>只要字符串不为常量，就能为下标运算符返回的字符串赋新值。</p><h2 id="标准库vector"><a href="#标准库vector" class="headerlink" title="标准库vector"></a>标准库vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，索引可以访问对象。因为vector“容纳着”其他对象，所以，所以他被称为容器（container）。</p><p>模板本身不是类或者函数，相反，可以看做是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称为<code>实例化</code>（instantiation），当使用模板时，需要指出编译器应把类或者函数实例化成何种形式。</p><p>提供信息的方式：即在类模板名字后面跟一对尖括号，括号内放类型信息。</p><p>vector是模板，而不是类。</p><h3 id="定义、初始化vector对象"><a href="#定义、初始化vector对象" class="headerlink" title="定义、初始化vector对象"></a>定义、初始化vector对象</h3><p>|初始化示例|说明|<br>|vector<t> v1| v1是一个空vector，他潜在的元素是T类型，执行默认初始化|<br>|vector<t> v2(v1)|v2中包含v1所有元素副本|<br>|vector<t> v2 = v1|等价于v2(v1)|<br>|vector<t> v3(n,val)|v3包含那个重复的元素。每个元素的值是val|<br>|vector<t> v4(n)|v4 包含了n个重复的执行了值初始化的元素|<br>|vector<t> v5{a,b,c,…}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>|vector<t> v5 = {a,b,c,…}|等价于v5{a,b,c,…}|</t></t></t></t></t></t></t></p><p><strong>列表初始化</strong>vector对象。</p><p>值初始化：通常情况下，可以只提供vector对象容纳元素数量，而略去初始值，此时，库会创建一个值初始化的元素初值，并且把它赋值给容器中所有元素。这个初始值由vector元素类型决定。</p><p>如果是内置类型，如int，元素初始值自动设置为0，如果是类类型，比如string，元素由类默认初始化。</p><p>如果只提供元素的数量而没有设定初始值，只能使用直接初始化。不让就是将数量拷贝给string对象了。</p><p>初始化过程中，尽可能地把花括号内的值当做是元素初始值列表处理，但是如果花括号形式所提供的值不能进行列表初始化，就要考虑用这样的值构造vector对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125; <span class="comment">//列表初始化，v5有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>); <span class="comment">//错误不能构建</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;   <span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;; <span class="comment">//v8有10个值为“hi” 的元素</span></span><br></pre></td></tr></table></figure><p> 在确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p><h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><p>vector对象能高效的增长，如果初始化的时候指定大小，可能效率会低。</p><p>范围for循环体内不应改变其所遍历序列的大小。</p><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><table><thead><tr><th>vector操作</th><th>说明</th></tr></thead><tbody><tr><td>v.empty()</td><td>如果v不含有任何元素，返回真，否则，返回假</td></tr><tr><td>v.size()</td><td>返回v中元素个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾部添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素的拷贝替换v1中的元素</td></tr><tr><td>v1 = {a,b,c…}</td><td>用列表中元素的拷贝替换v1中的元素</td></tr><tr><td>v1== v2</td><td>元素数目相同、对应位置上的元素值相同</td></tr><tr><td>v1 != v2</td><td></td></tr><tr><td>&lt; ,&lt;=, &gt; ,&gt;=</td><td>以字典的顺序进行比较</td></tr></tbody></table><p>vector对象的类型总是包含元素的类型。只有当元素的类型可以比较时，vector对象才能比较。vector可以使用下标读写元素，不能通过下标添加元素。<br>只能对已经存在的元素</p><p>缓冲区溢出（buffer overflow） 就是指的下标越界这类错误。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>类似指针类型，迭代器提供了对对象的间接访问。就迭代器而言，其对象是容器中元素或者string对象中的字符。</p><p>和指针不同，获取迭代器不是使用取地址符，有迭代器的类型，同时拥有返回迭代器的成员。比如begin、end成员。</p><ol><li>begin成员负责返回指向第一个元素的迭代器。</li><li>end成员负责返回指向容器 <strong>尾元素的下一个位置</strong>的迭代器。</li><li>end成员返回的迭代器通常称为尾后迭代器。</li><li>如果容器为空，则begin、end返回的是同一个迭代器。都是尾后迭代器。</li></ol><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>迭代器的运算符如下：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>*iter</td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter)-&gt;mem</td></tr><tr><td>++iter</td><td>令iter指示容器的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个元素是否相等，如果两个迭代器指示的是同一个元素，或者他们是同一个容器的尾后迭代器，则他们相等，否则不行等</td></tr><tr><td>iter1 != iter2</td></tr></tbody></table><p>指针和迭代器的相同点：</p><ol><li>可以解引用来获取它所指元素</li><li>也有有效和无效之分，有效：迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他所有情况都无效</li><li>提供了对对象的间接访问</li><li>都可以移动到下一个元素、上一个元素</li><li>视图解引用非法迭代器或者尾后迭代器都是未定义的，  解引用非法指针也是非法的</li></ol><p>指针和迭代器的不同点：</p><ol><li>获取方式不同，指针：取地址； 迭代器：通过容器的成员。</li></ol><p>迭代器使用实例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string </span>s(<span class="string">"some string"</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">if</span>(s.<span class="keyword">begin() </span>!= s<span class="meta">.end</span>())</span><br><span class="line">&#123;</span><br><span class="line">auto <span class="keyword">it </span>= s.<span class="keyword">begin();</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= touper(*<span class="keyword">it);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>因为end返回的迭代器并不实际指示元素，所以不能对其进行递增或者解引用的操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>(auto <span class="keyword">it </span>= s.<span class="keyword">begin(); </span><span class="keyword">it </span>!= s<span class="meta">.end</span>() &amp;&amp; !isspace(*<span class="keyword">it); </span>++<span class="keyword">it)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= toupper(*<span class="keyword">ite);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>只有string、vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库的迭代器都定义了==、!=，但是他们中的大多数没有定义&lt; 运算符，因此， 我们要养成使用迭代器和!=运算符的习惯。</p><p>实际上，那些拥有迭代器的标准库使用iterator、const_iterator表示迭代器类型。</p><p>const_iterator和常量指针差不多。能读取，不能修改。</p><p>如果vector、string对象是一个常量，只能使用const_iterator，如果vector、string不是常量，既能使用iterator，也能使用const_iterator</p><p>begin和end运算符： begin和end返回的具体类型由对象是否常量觉得，如果对象是常量，begin和end返回const_iterator，如果不是，返回iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v2;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v1.begin(); <span class="comment">//iter1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = v2.begin(); <span class="comment">//iter2 的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>cbegin()、cend() 返回const_iterator类型迭代器。</p><p>箭头-&gt;运算符将解引用和成员访问两个操作结合在一起。也就是it-&gt;mem和(*it).mem表达式的意思相同。</p><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><table><thead><tr><th>迭代器运算</th><th>说明</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上整数值，扔是一个迭代器类型。迭代器指示的新位置与原来的位置相比，向前移动了n个元素。结果迭代器或者指向容器的下一个元素，或者指向容器尾元素的下一个位置</td></tr><tr><td>iter - n</td><td></td></tr><tr><td>iter += n</td><td></td></tr><tr><td>iter1= n</td><td></td></tr><tr><td>iter 1 - iter2</td><td></td></tr><tr><td>&lt;, &lt;=, &gt;,&gt;=</td></tr></tbody></table><p>两个迭代器的间距的类型是diffrence 类型。带符号的。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义、初始化内置数组"><a href="#定义、初始化内置数组" class="headerlink" title="定义、初始化内置数组"></a>定义、初始化内置数组</h3><p>数组中元素的个数也属于数组类型的一部分，编译的时候纬度应该已知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>]  ; <span class="comment">//含有10个整形指针的数组。</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>定义数组的时候必须指定数组的类型。不允许使用auto关键字由初始值的列表来推断类型。</p><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的纬度。如果声明时没有指定纬度，编译器会根据初始值的数量计算并推断出来，如果指定了维度，那么初始值的总数量不应该超过指定的大小。</p><p>字符数组的特殊性： 一定要注意，字符串字面值的结尾还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">a</span>[] = <span class="string">"C++"</span> ;<span class="comment"> // 容量4</span></span><br></pre></td></tr></table></figure><p>不能讲数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">int a2[] = a; <span class="comment">//错误不能用一个数组初始化另一个数组</span></span><br><span class="line">a2 =a; <span class="comment">//错误不能把一个数组赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>理解复杂数组声明</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">ptrs</span><span class="selector-attr">[10]</span>; <span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">&amp;</span><span class="selector-tag">refs</span><span class="selector-attr">[10]</span>; <span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (*parray)<span class="selector-attr">[10]</span>; <span class="comment">//parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (&amp;arrRef)<span class="selector-attr">[10]</span>;<span class="comment">//parray引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><p>对数组而言，由内向外阅读比较合适。parray是一个指针，指向一个含有10个元素的数组，数组的元素类型是整形。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组的特性：在很多用到数组名字的地方，编译器都会自动的将其替换为一个指向数组首元素的指针。<br>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。</p><p>decltype不会执行数组到指针的转化。</p><p>指针也是迭代器</p><p>标注库函数begin、end。由于数组不是类类型，因此这两个函数不是成员函数。begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一个位置的指针。</p><p>尾后迭代器不能执行解引用和递增操作。</p><p>两个指针递减的结果类型是一种名为ptrdiff_t的标准库类型。定义在cstddef头文件中。</p><p>很多情况下，使用数组的名字，其实用的是一个指向数组首元素的指针。</p><p>内置下标运算符所用的索引值不是无符号类型，这一点和vector和string不一样。</p><h3 id="C分格字符串"><a href="#C分格字符串" class="headerlink" title="C分格字符串"></a>C分格字符串</h3><table><thead><tr><th>c分格字符串的函数</th><th>说明</th></tr></thead><tbody><tr><td>strlen()</td><td>返回p的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1,p2)</td><td>比较p1、p2的相等性，如果p1==p2 返回0，如果p1&gt;p2，返回一个正值，如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1,p2)</td><td>将p2附加到p1之后，返回p1</td></tr><tr><td>strcpy(p1,p2)</td><td>将p2拷贝给P1，返回p1</td></tr></tbody></table><p>当使用数组的时候其实真正用的是指向数组首元素的指针。所以比较字符串实际上比较的是指针。</p><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><ol><li>允许使用 以空字符结束的字符数组来初始哈动态string对象或者为string对象赋值</li><li>在string对象的加法运算中，允许使用空字符结束的字符数组作为其中一个运算对象。</li></ol><p>string对象的c_str函数返回一个C风格的字符串。</p><p>可以使用数组初始化vector对象。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言没有多维数组，通常所说的多维数组其实是数组的数组。</p><p>要使用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。<br>类型别名简化多维数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_ary = <span class="keyword">int</span>[<span class="number">4</span>];  <span class="comment">//int_ary 是含有4个整型元素的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_ary[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令空间的using声明&lt;/li&gt;
&lt;li&gt;标准库类型string&lt;/li&gt;
&lt;li&gt;标准库类型vector&lt;/li&gt;
&lt;li&gt;迭代器介绍&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第三章 字符串、向量、数组" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>特殊工具和技术</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/</id>
    <published>2018-08-02T01:07:12.000Z</published>
    <updated>2018-08-02T11:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制内存"><a href="#控制内存" class="headerlink" title="控制内存"></a>控制内存</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用new表达式时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> * sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a string"</span>);</span><br><span class="line"><span class="built_in">string</span> * arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际执行了三步：</p><ol><li>new 表达式调用 operator new 或operator new [] 标准库，分配一块足够大、原始的、未命名的内存空间。</li><li>编译器运行相应的构造函数，并传入初始值。</li><li>返回一个指向该对象的指针。</li></ol><p>当我们使用delete表达式时</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure><ol><li>调用析构函数</li><li>调用名为operator delete 或者operator delete [] 释放空间。</li></ol><p>发现new、delete表达式，如果对象是类类型，首先在类类型中查找，然后是全局作用域。也可以使用::new直接使用全局作用域的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>类作用域的new、delete是静态的。因为operator new 用在对象构造之前，operator delete 用在对象销毁后。而且不能操作类的任何成员。</p><p>new表达式和 operator new 函数：不能改变new表达式、delete表达式的含义。</p><p>malloc函数接受一个表示带分配字节数的size_t，返回指向分配空间的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">void</span>* mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* mem)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address)<span class="built_in"> type </span>(initializers)</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size]</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size] &#123;braced initializer list&#125;</span><br></pre></td></tr></table></figure><p>定位new 使用 operation new (size_t ,void *)函数<br>定位new 可以构造对象，单不分配内存</p><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>allcator</td></tr><tr><td>allocate</td><td>construct</td></tr><tr><td>destroy</td><td>deallocate</td></tr></tbody></table><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>new的形式</td></tr><tr><td>operator new</td><td>构造函数（定位new可以只构造对象，不申请空间）</td></tr><tr><td>free</td><td>析构函数（可以直接调用）</td></tr></tbody></table><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><ol><li>typeid 运算符，返回表达式的类型</li><li>dynamic_cast运算符 用于将基类指针或引用安全的转化为派生类的指针或者引用</li></ol><p>当操作被定义为虚函数时，编译器将根据对象的动态类型自动的选择正确的版本 。</p><ol><li>dynamic_cast<type*> (e)</type*></li><li>dynamci_cast<type&> (e)</type&></li><li>dynamic_cast<type&&> (e)</type&&></li></ol><p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p><p>type_info 类的name成员函数返回一个C风格的字符串，表示对象的类型名字。type_info 只能通过typeid运算符创建。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型使我们可以将一组整形常量组织在一起。 </p><ol><li>限定作用域</li><li>不限定作用域</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> 枚举名 &#123; 逗号分隔的枚举列表&#125;;</span></span><br></pre></td></tr></table></figure><p>枚举值可以不唯一，枚举成员是常量表达式。</p><p>和类一样，枚举也定义新的类型，也能定义变量。enum对象赋值必须使用该类型的一个枚举成员，或该类型的另一个对象。</p><p>指定enum的大小</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValue</span> : <span class="title">unsigned</span> <span class="title">long</span> <span class="title">long</span> </span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>枚举类型的前置声明</p><h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针，是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员。</p><p>成员指针的类型囊括了类的类型、成员的类型。当初始化一个这样的指针时，我们另其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p><h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><p>声明成员指针时，必须包含成员所属的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> className:: * pdata;</span><br><span class="line">pdata = &amp;Screen::contents <span class="comment">//指向某个非特定Screen对象的contents成员</span></span><br></pre></td></tr></table></figure><p>当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员，而非该成员所属的对象。只有当解引用成员指针时，我们才提供对象的信息。 也就是解引用时候绑定到特定的对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*  data()</span><br><span class="line">&#123;</span><br><span class="line">retrun &amp;Screen::contents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data 指向Screen类const string 成员指针。</span></span><br></pre></td></tr></table></figure><h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p><code>char (Screen::*pmf2)(int,int ) const;</code></p><h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>成员函数指针不是可调用对象，调用前必须使用.<em>或者-&gt;</em>绑定到特定对象上。所以不能直接将成员函数指针传递给算法。</p><font color="red"><br>以下内容无法理解：<br><br>1. 可以使用function生成一个可调用对象。<br>2. 可以使用mem_fn生成一个可调用对象。<br>3. 使用bind 生成一个可调用对象。<br><br></font><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class） ，后者称为嵌套类型（nested type）。</p><p>嵌套类是一个独立的类，与外层基本没有什么关系，特别是，外层类对象和嵌套类对象是相互独立的，嵌套类的对象不能包括任何外层类定义的成员；类似的，在外层类的对象也不能报考任何嵌套类定义的成员。嵌套类的名字在外层作用域内是可见的。之外不可见。 嵌套类对外层类的成员也没有特殊的访问权限。</p><h2 id="union-一种节省空间的类"><a href="#union-一种节省空间的类" class="headerlink" title="union 一种节省空间的类"></a>union 一种节省空间的类</h2><p>union可以定义多个数据成员，但在任何时刻，只有一个数据成员可以有值。union可以定义包括构造函数和析构函数在内的成员函数。但union不能继承自其它类，也不能作为基类使用。 不能有虚函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;控制内存&quot;&gt;&lt;a href=&quot;#控制内存&quot; class=&quot;headerlink&quot; title=&quot;控制内存&quot;&gt;&lt;/a&gt;控制内存&lt;/h2&gt;&lt;h3 id=&quot;重载new和delete&quot;&gt;&lt;a href=&quot;#重载new和delete&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十九章特殊工具和技术" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="特殊工具和技术" scheme="http://yoursite.com/tags/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>模板和泛型编程</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-09-25T07:36:16.526Z</updated>
    
    <content type="html"><![CDATA[<ol><li>名义模板</li><li>模板实参推断</li><li>重载与模板</li><li>可变参数模板</li><li>模板的特例化</li></ol><p>面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。<br><a id="more"></a></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;名义模板&lt;/li&gt;
&lt;li&gt;模板实参推断&lt;/li&gt;
&lt;li&gt;重载与模板&lt;/li&gt;
&lt;li&gt;可变参数模板&lt;/li&gt;
&lt;li&gt;模板的特例化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十六章 模板和泛型编程" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="模板和泛型编程" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>变量和基本类型</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-08-13T05:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。</p><p>主要内容 ：</p><ol><li>基本内置类型</li><li>变量</li><li>复合类型</li><li>const限定符</li><li>处理类型</li><li>自定义数据类型</li></ol><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++ 定义了一套包括算术类型和空类型的基本数据类型。</p><p>算术类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32</td></tr><tr><td>short</td><td>短整形</td><td>16</td></tr><tr><td>int</td><td>整形</td><td>16</td></tr><tr><td>long</td><td>长整形</td><td>32</td></tr><tr><td>long long</td><td>长整形</td><td>64</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10 位有效数字</td></tr></tbody></table><ol><li>寻址的最小内存块为 <strong>字节(byte)</strong> 大多数的字节由8个bit构成。</li><li>存储的基本单元称为 <strong>字(word) </strong>一般32或64bit。</li></ol><p>通常，float一个字，double两个字，long double4个字，类型float和double 分别有<strong>7</strong>个和<strong>16</strong>个有效位。</p><p>与其他类型不同，字符型被分为三种：char、signed char 、 unsigned char。char 和signed char 并不是一种，尽管类型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种的一种，具体由编译器决定。</p><p>如何选择类型：</p><ol><li>在算术表达式中不要使用char 、bool 只有在存放字符或者bool值时候才使用它们，因为类型char在一些机器上有符号，而在另外一些机器上又是无符号的，所以，如果使用char 进行运算特别容易出问题。如果使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。</li><li>执行浮点运算选用double，这是因为float通常进度不够。对于某些机器，双精度运算甚至比单精度还快。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当给某种类型的对象强制赋予了另一种类型的值时，到底发生了什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span><span class="keyword">b </span>= <span class="number">42</span><span class="comment">;</span></span><br><span class="line">int i = <span class="keyword">b </span><span class="comment">; ///i的值时1</span></span><br></pre></td></tr></table></figure><ol><li>当把一个非布尔类型的算术值赋给布尔类型时，初始值0是false，否则为true。</li><li>当把一个布尔值赋值给非布尔类型时，初始值false 是0，true是1.</li><li>浮点数赋值给整数类型时，进行近视处理，保留小数部分之前的。</li><li>将超出范围的值赋值给无符号类型：结果是初始值对无符号类型表示的总数取模后的余数。</li><li>将超出范围的值赋给带符号类型，结果未定义。</li></ol><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p><font color="red"></font></p><ol><li>无符号数递减不能是负值，如果为负值，会是取模的余数。</li><li>切勿混用带符号和无符号类型。如果表达式里面既有带符号的，又有无符号的，带符号的数会转化为无符号的数。<br><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3></li></ol><table><thead><tr><th>字面常量</th><th>进制</th></tr></thead><tbody><tr><td>20</td><td>十进制</td></tr><tr><td>024</td><td>八进制</td></tr><tr><td>0x14</td><td>十六进制</td></tr></tbody></table><ol><li>字面值常量的类型是能容纳该数值的尺寸最小的那个（int long， long long），默认是带符号的。类型short没有对应的字面值。浮点型字面值类型是double。</li><li><strong>字符串字面值的类型实际上是由常量字符构成的数组，末尾添加‘\0’。</strong></li><li><strong>如果两个字符串字面值位置紧邻且仅由空格，缩进、换行符分隔，则他们实际上是一个整体</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really"</span> </span><br><span class="line">              <span class="string">"that spans"</span>;</span><br></pre></td></tr></table></figure><p>有两种类型字符不能直接使用，需要转义：</p><ol><li>不可打印</li><li>特殊含义字符：单引号、双引号、问号、反斜杠</li></ol><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>指定字符和字符串字面值：指定的方法如下表：</p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode 16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode 32 字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8(仅用于字符串字面常量)</td><td>char</td></tr></tbody></table><p>指定整数字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>u U</td><td>unsigned</td></tr><tr><td>l L</td><td>long</td></tr><tr><td>ll LL</td><td>long long</td></tr></tbody></table><p>指定浮点字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>f F</td><td>float</td></tr><tr><td>l L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供具名的、可供程序操作的存储空间。C++每个变量都有数据类型，数据类型决定着变量所占内存空间的大小、布局方式、该空间能存储的值的范围、以及变量能参与的运算。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>基本形式：类型说明符（type specifier） + 变量名</p><p>string表示可变长字符序列  的数据类型</p><p>对象是指能存储数据并具有某种类型的存储空间。</p><p>当一次定义了两个或多个变量时，对象的名字随着定义也马上可以使用了。因此在同一条语句中，可以用先定义的变量去初始化后定义的其他变量。</p><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p><p>初始化的四种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>花括号的初始化形式称为<strong>初始化列表</strong>。</p><p>初始化列表用于内置类型的变量时：<strong>如果初始值存在丢失信息的风险，编译器报错。</strong></p><p>如果定义变量时没有指定值，则变量被默认初始化（default initialized），此时变量被赋予了默认值。</p><p>函数体之外的内置变量被初始化为0；函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示初始化，则其值由类确定。</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明：规定了变量的类型和名字，这一点上和定义相同。<br>定义：除了规定变量的类型和名字，还申请存储空间、为变量赋一个初始值。</p><p>声明代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">//声明i，而非定义i，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; 任何包含了显示初始化的声明既变为定义。</span><br></pre></td></tr></table></figure><p>变量能且只能别定义一次，但是可以被多次声明。</p><p>这相当于为分离式编程提供了支持</p><p>C++是一种静态类型语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查。 编译器知道每一个实体对象的类型是通过类型声明。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>用户定义的标识符不能连续出现两个下划线、不能以下划线紧连大写字母开头、定义在函数体外的标识符不能以下划线开头。</p><p>变量命名规范：</p><ol><li>标识符要能体现实际含义</li><li>变量一般用小写字母</li><li>用户定义的类名一般以大写字母开头</li><li>标识符由多个单词组成，则单词间应该有明显区分</li></ol><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>名字的有效区域始于名字的声明语句，以声明语句所在的作用域未端为结束。</p><p>第一次使用变量时再定义变量，这样好处：</p><ol><li>更容易找到变量的定义</li><li>容易赋值合理的初始值</li></ol><ol><li>全局作用域</li><li>块作用域</li><li>嵌套作用域</li></ol><ol><li>内层作用域可以访问外层作用域中的名字</li><li>内层作用域中可以重新定义外层作用域中的名字</li><li>使用作用域运算符可以直接访问外层作用域中的名字</li></ol><h2 id="符合类型（引用、指针）"><a href="#符合类型（引用、指针）" class="headerlink" title="符合类型（引用、指针）"></a>符合类型（引用、指针）</h2><p>符合类型是基于其他类型定义的类型（compound type）</p><p>基本数据类型  + 声明符</p><p><strong>声明符</strong>命令了一个变量，并指定该变量的相关类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference） 为对象起了另一个名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中，然而，定义引用时，程序把引用和它的初始值绑定在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此，引用必须初始化。</p><p>定义一个引用后，对其进行的所有操作都是在与之绑定的对象进行的。</p><ol><li>获取引用的值：实际上是获取了与引用绑定的对象的值。</li><li>以引用为初始值： 实际上是以与引用绑定的对象作为初始值。</li></ol><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p><p>用于在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。</p><p>引用的类型要和与之绑定的对象严格匹配。引用只能绑定在一个对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与引用类型，指针也实现了对其他对象的间接访问。</p><p>指针和引用的区别：</p><ol><li>指针本身也是对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。</li><li>指针无需在定义的时候赋值。</li></ol><p>指针存放某个对象的地址。要想获取该地址，使用取地址符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//p存放变量ival的地址。 或者说p是指向变量ival的指针。</span></span><br></pre></td></tr></table></figure><p>指针的类型都要和它所指向的对象严格匹配。</p><p>指针值：指针的值（即地址）应属于下列4中转态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>解引用来访问该对象，解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p>空指针使用nullptr，新标准使用NULL，NULL是预处理变量。</p><p>如果使用了未经初始化的指针，则该指针所占内存空间的当前内容被看做是一个地址值，访问该指针，相当于去访问一个本不存在的位置上的</p><p>指针和引用都能踢动对其他对象的间接访问，然而，在具体实现细节上，二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法领其在绑定到另外的对象。之后每次使用这个引用都是访问他最初绑定的那个对象。</p><p>给指针赋值，就是令其存放一个新地址。</p><p>如果两个指针存放的地址值相同，则他们相等。</p><p>void<em> 是一种特殊的指针类型，可用于存放任何对象的地址。一个`void</em><code>指针存放着一个地址。这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象不了解。 不能直接操作</code>void*` 指针所指的对象。因为我们不知道这个对象到底是什么类型。</p><h3 id="理解符合类型"><a href="#理解符合类型" class="headerlink" title="理解符合类型"></a>理解符合类型</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//p是<span class="built_in">int</span>型指针、r是一个<span class="built_in">int</span>型引用</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">int</span> *<span class="built_in">pi</span> = &amp;ival;</span><br><span class="line"><span class="built_in">int</span> **ppi = &amp;<span class="built_in">pi</span>; ///ppi指向一个<span class="built_in">int</span>型的指针</span><br></pre></td></tr></table></figure><p>ppi  -&gt; pi -&gt; ival (1024)</p><h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p ;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r 引用了一个指针，因此给r赋值，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><p>离变量名最近的符号对变量类型有最直接的影响。所以r是引用。</p><p>##const限定符</p><p>默认情况下，const对象仅仅在文件内有效。如果想在多个文件中共享const对象，就对const变量不管是声明还是定义都添加extern关键字。这样只需定义一次就可以了。</p><h3 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h3><p>可以把引用绑定到const 对象上，我们称为对常量的引用（refernce to const） 。一定要记住，</p><h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>引用的类型必须和其所引用对象的类型一致，但是有两个例外，第一种例外情况是初始化常量引用时允许用任何表达式作为初始值，只要改表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span> <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1* <span class="number">2</span>;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><p>必须认识到：常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>指向常量的指针（pointer to const） 不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">//pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr  = &amp;pi;  <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure><p>指针的类型必须与其所指对象的类型一致，但是有两个例外，其中一个是：允许一个指向常量的指针指向一个非常量对象。</p><p>试试这样想吧：所谓指向常量的指针和引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以自觉的不去改变所指对象的值。</p><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>指针是对象而引用不是，所以就像其他对象类型一样，允许指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量。即不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pip <span class="comment">//pip 是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><p>要想弄清楚这些声明的含义，最行之有效的方法是从右向左阅读</p><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题，用名词顶层const表示指针本身是一个常量，而用名词底层const 表示指针所指的对象是一个常量。</p><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。</p><p>当执行对象的拷贝操作时，常量的顶层const还是底层const区别名下，其中顶层const不受影响：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci <span class="comment">//允许改变p2的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;  <span class="comment">//正确，底层一样</span></span><br></pre></td></tr></table></figure><p>另一方面，底层const的限制不能忽视</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误，p指向的值可以通过p改变，但p指向的值是常量，所以错误</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式</p><p>constexpr变量：如果认定变量是一个常量表达式，那就把它声明为constexpr类型</p><h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>字面值类型： 比较简单，值也显而易见，容易得到，算术类型、引用类型、指针都属于字面值类型。  string 不属于，也就不能被定义成constexpr。</p><p>函数体内定义的变量，一般来说并非存放固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于多有函数体之外的对象，其地址固定不变，能用来初始哈constexpr指针。</p><h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>  <span class="comment">//p是一个指向整型常量的 指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">//q是一个指向整形的向量指针。</span></span><br></pre></td></tr></table></figure><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>为了简化复杂类型的定义</p><h3 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wage base,*p ;<span class="comment">// base 是double的同义词，p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//SI 是sales_item的同义词</span></span><br></pre></td></tr></table></figure><p>using 把等号左侧的名字规定成等号右侧类型的别名。</p><h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr 是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>pstring 的基本数据类型是指针 。 不能展开，如果展开就错了</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> * <span class="built_in">cstr</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>展开就成了底层常量了</p><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器通过初始值来推断变量的类型，显然，auto的定义必须有初始值。</p><ol><li>引用： 编译器以引用对象的类型作为auto的类型，希望推断引用，需要 auto &amp;</li><li>顶层const常量： 忽略，希望推断顶层const常量，需要用const auto</li><li>底层const常量： 保留</li></ol><h3 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h3><p>场景：希望从表达式的类型推断出要定义的变量类型，但是不想用改表达式的值初始化变量。decltype不实际计算表达式的值。</p><p>decltype处理顶层const和引用的方式与auto有些不同，如果decltyoe使用的表达式时一个表里，则decltype返回改变量的类型，包括顶层const和引用在内。</p><p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外。</p><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此，decltype（*p）的结果类型就是int&amp;，而非int。</p><p>decltype的表达式如果是加上括号的变量，结果是引用。</p><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名，以表示该类型对象的定义，所以分号必不可少。</p><p>可以为数据成员提供一个<strong>类内初始值</strong>，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p>头文件通常包含哪些只能被定义一次的实体。例如类、const、constexpr变量等。</p><p>确保头文件多次包含仍能安全工作的技术是<strong>预处理器</strong>，预处理器是在编译之前执行的一段程序。#include就是预处理，当预处理器看到#include标记时，就会用指定的头文件内容替换#include</p><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义、未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义。#ifdef、#ifndef、#endif。</p><p>预处理变量无视C++语言中关于作用域的规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。&lt;/p&gt;
&lt;p&gt;主要内容 ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内置类型&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;复合类型&lt;/li&gt;
&lt;li&gt;const限定符&lt;/li&gt;
&lt;li&gt;处理类型&lt;/li&gt;
&lt;li&gt;自定义数据类型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第二章变量和基本类型" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="变量和基本类型" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>组件化-库</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BA%93/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/IOS/库/组件化-库/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20170427/19136.html" rel="external nofollow noopener noreferrer" target="_blank">组件化-动态库实战</a>    </p><p><a href="https://blog.csdn.net/u013604612/article/details/43197465" rel="external nofollow noopener noreferrer" target="_blank">iOS开发——创建你自己的Framework</a>  </p><p><a href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" rel="external nofollow noopener noreferrer" target="_blank">iOS - Umbrella Header在framework中的应用</a></p><p><a href="https://www.jianshu.com/p/48aff237e8ff" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发中的『库』(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170427/19136.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件化-动态库实战&lt;/a&gt;    
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/IOS/%E5%BA%93/"/>
    
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>export命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/export%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/export命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-10-31T05:59:56.254Z</updated>
    
    <content type="html"><![CDATA[<p>export命令设置或显示环境变量。</p><a id="more"></a><h2 id="Linux-export-命令"><a href="#Linux-export-命令" class="headerlink" title="Linux export 命令"></a>Linux export 命令</h2><p>功能说明：设置或显示环境变量。（比如我们要用一个命令，但这个命令的执行文件不在当前目录，这样我们每次用的时候必须指定执行文件的目录，麻烦，在代码中先执行export，这个相当于告诉程序，执行某某东西时，需要的文件或什么东东在这些目录里）</p><p>语　　法：export [-fnp][变量名称]=[变量设置值]</p><p>补充说明：在shell中执行程序时，shell会提供一组环境变量。 export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。</p><p>参　　数：</p><p>-f 　代表[变量名称]中为函数名称。</p><p>　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>　<br>　-p 　列出所有的shell赋予程序的环境变量。<br>　<br>　一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。     —-《UNIX教程》<br>　<br>　<br>　<br>　在 linux 里设置环境变量的方法 （ export PATH ）<br>　<br>　一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。例如我的mips-linux-gcc编译器在“/opt/au1200_rm /build_tools/bin”目录下，build_tools就是我的编译工具，则有如下三种方法来设置环境变量：<br>　<br>　1、直接用export命令：<br>　#export PATH=$PATH:/opt/au1200_rm/build_tools/bin<br>　查看是否已经设好，可用命令export查看：<br>　<br>　<br>　<br>　[root@localhost bin]#export<br>　declare -x BASH_ENV=”/root/.bashrc”<br>　declare -x G_BROKEN_FILENAMES=”1”<br>　declare -x HISTSIZE=”1000”<br>　declare -x HOME=”/root”<br>　declare -x HOSTNAME=”localhost.localdomain”<br>　declare -x INPUTRC=”/etc/inputrc”<br>　declare -x LANG=”zh_CN.GB18030”<br>　declare -x LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN”<br>　declare -x LESSOPEN=”|/usr/bin/lesspipe.sh %s”<br>　declare -x LOGNAME=”root”<br>　declare -x LS_COLORS=”no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:<em>.cmd=01;32:</em>.exe=01;32:<em>.com=01;32:</em>.btm=01;32:<em>.bat=01;32:</em>.sh=01;32:<em>.csh=01;32:</em>.tar=01;31:<em>.tgz=01;31:</em>.arj=01;31:<em>.taz=01;31:</em>.lzh=01;31:<em>.zip=01;31:</em>.z=01;31:<em>.Z=01;31:</em>.gz=01;31:<em>.bz2=01;31:</em>.bz=01;31:<em>.tz=01;31:</em>.rpm=01;31:<em>.cpio=01;31:</em>.jpg=01;35:<em>.gif=01;35:</em>.bmp=01;35:<em>.xbm=01;35:</em>.xpm=01;35:<em>.png=01;35:</em>.tif=01;35:”<br>　declare -x MAIL=”/var/spool/mail/root”<br>　declare -x OLDPWD=”/opt/au1200_rm/build_tools”<br>　declare -x PATH=”/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin:/opt/au1200_rm/build_tools/bin”<br>　declare -x PWD=”/opt/au1200_rm/build_tools/bin”<br>　declare -x SHELL=”/bin/bash”<br>　declare -x SHLVL=”1”<br>　declare -x SSH_ASKPASS=”/usr/libexec/openssh/gnome-ssh-askpass”<br>　declare -x SSH_AUTH_SOCK=”/tmp/ssh-XX3LKWhz/agent.4242”<br>　declare -x SSH_CLIENT=”10.3.37.152 2236 22”<br>　declare -x SSH_CONNECTION=”10.3.37.152 2236 10.3.37.186 22”<br>　declare -x SSH_TTY=”/dev/pts/2”<br>　declare -x TERM=”linux”<br>　declare -x USER=”root”<br>　declare -x USERNAME=”root”<br>　<br>　可以看到灰色部分有设置的路径，说明环境变量已经设好，PATH里面已经有了我要加的编译器的路径。<br>　<br>　2、修改profile文件：<br>　#vi /etc/profile<br>　在里面加入:<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　3. 修改.bashrc文件：<br>　# vi /root/.bashrc<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下：<br>　# echo $PATH<br>　看看输出里面是不是已经有了 /my_new_path这个路径了。<br>　<br>　另有：4. 修改/etc/re.local文件：<br>　# vi /etc/re.local<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　<br>　———————————————————————————————————————–<br>　<br>　“/bin”、“/sbin”、“ /usr/bin”、“/usr/sbin”、“/usr/local/bin”等路径已经在系统环境变量中了，如果可执行文件在这几个标准位置，在终端命令行输入该软件可执行文件的文件名和参数(如果需要参数)，回车即可。<br>　<br>　　　如果不在标准位置，文件名前面需要加上完整的路径。不过每次都这样跑就太麻烦了，一个“一劳永逸”的办法是把这个路径加入环境变量。命令 export $PATH=”路径”(或“PATH=$PATH:路径”) ($PATH为环境变量名，如DVSDK；调用时用$DVSDK)可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下的“.bash_profile”只对这个用户有效。<br>　　　<br>　　　　　export $PATH=”$PATH:路径1:路径2:…:路径n” （或“PATH=$PATH:路径1:路径2:…:路径n”　），意思是可执行文件的路径包括原先设定的路径，也包括从“路径1”到“路径n”的所有路径。当用户输入一个一串字符并按回车后，shell会依次在这些路径里找对应的可执行文件并交给系统核心执行。那个“$PATH”表示原先设定的路径仍然有效，注意不要漏掉。某些软件可能还有“PATH”以外类型的环境变量需要添加，但方法与此相同，并且也需要注意“$”。<br>　　　　　<br>　　　　　　　注意，与DOS/Window不同，UNIX类系统环境变量中路径名用冒号分隔，不是分号。另外，软件越装越多，环境变量越添越多，为了避免造成混乱，建议所有语句都添加在文件结尾，按软件的安装顺序添加。<br>　　　　　　　<br>　　　　　　　　　格式如下()：<br>　　　　　　　　　<br>　　　　　　　　　　　# 软件名-版本号<br>　　　　　　　　　　　<br>　　　　　　　　　　　　　PATH=$PATH:路径1:路径 2:…:路径n<br>　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　其他环境变量=$其他环境变量:…<br>　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　在“profile”和“.bash_profile”中，“#”是注释符号，写在这里除了视觉分隔外没有任何效果。<br>　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　设置完毕，注销并重新登录，设置就生效了。如果不注销，直接在shell里执行这些语句，也能生效，但是作用范围只限于执行了这些语句的shell。<br>　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　相关的环境变量生效后，就不必老跑到软件的可执行文件目录里去操作了。<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　———————————————————————————————————————–<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　 执行一个脚本时，会先开启一个子shell环境（不知道执行其它程序是不是这样），然后将父shell中的所有系统环境变量复制过来，这个脚本中的语句就在子shell中执行。（也就是说父shell的环境变量在子shell中可以调用，但反过来就不行，如果在子shell中定义了环境变量，则只对该shell或者它的子shell有效，当该子shell结束时，也可以理解为脚本执行完时，变量消失。）为了证明这一点，请看脚本内容：<br>　　　　　　　　　　　　　　　　　　　　　　 　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　这样的脚本执行完后，test实际上是不存在的。接着看下面的：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　bash<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　这里在脚本最后一行再开一个子shell，该shell应该是脚本文件所在shell的子shell，这个脚本执行完后，是可以看到test这个变量的，因为现在是处于它的子shell中，当用exit退出子shell后，test变量消失。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　如果用source对脚本进行执行时，如果不加export，就不会在子shell中看到这个变量，因为它还不是一个系统环境变量呀，如脚本内容是：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　用source执行后，在shell下是能看到这个变量，但再执行bash开一个子shell时，test是不会被复制到子shell中的，因为执行脚本文件其实也是在一个子shell中运行，所以我再建另一个脚本文件执行时，是不会输入任何东西的，内容如：echo $test。所以这点特别注意了，明明在提示符下可以用echo $test输出变量值，为什么把它放进脚本文件就不行了呢？<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　所以得出的结论是：1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；2、一个shell中的系统环境变量才会被复制到子shell中（用export定义的变量）；3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。3、不用export定义的变量只对该shell有效，对子shell也是无效的。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　　　后来根据版主的提示，整理了一下贴子：为什么一个脚本直接执行和用source执行不一行呢？这也是我自己碰到的一个问题。manual原文是这样的：Read and execute commands from filename in the current shell environment and return the exit status of the last command executed from filename.明白了为什么不一样了吧？直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;export命令设置或显示环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="export" scheme="http://yoursite.com/tags/export/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/%E7%89%B9%E6%AE%8A%E5%8F%82%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/linux命令/特殊参数/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T11:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下linux shell下的特殊用法及参数的说明.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">变量说明:</span><br><span class="line"></span><br><span class="line">$$ </span><br><span class="line">Shell本身的PID（ProcessID） </span><br><span class="line">$! </span><br><span class="line">Shell最后运行的后台Process的PID </span><br><span class="line">$? </span><br><span class="line">最后运行的命令的结束代码（返回值） </span><br><span class="line">$- </span><br><span class="line">使用Set命令设定的Flag一览 </span><br><span class="line">$* </span><br><span class="line">所有参数列表。如<span class="string">"$*"</span>用「<span class="string">"」括起来的情况、以"</span><span class="variable">$1</span> <span class="variable">$2</span> … <span class="variable">$n</span><span class="string">"的形式输出所有参数。 </span></span><br><span class="line"><span class="string"><span class="variable">$@</span> </span></span><br><span class="line"><span class="string">所有参数列表。如"</span><span class="variable">$@</span><span class="string">"用「"</span>」括起来的情况、以<span class="string">"<span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$2</span>"</span> … <span class="string">"<span class="variable">$n</span>"</span> 的形式输出所有参数。 </span><br><span class="line"><span class="variable">$#</span> </span><br><span class="line">添加到Shell的参数个数 </span><br><span class="line"><span class="variable">$0</span> </span><br><span class="line">Shell本身的文件名 </span><br><span class="line"><span class="variable">$1</span>～<span class="variable">$n</span> </span><br><span class="line">添加到Shell的各参数值。<span class="variable">$1</span>是第1参数、<span class="variable">$2</span>是第2参数…。</span><br><span class="line"></span><br><span class="line">我们先写一个简单的脚本，执行以后再解释各个变量的意义 </span><br><span class="line"><span class="comment"># touch variable </span></span><br><span class="line"><span class="comment"># vi variable </span></span><br><span class="line">脚本内容如下： </span><br><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"number:<span class="variable">$#</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scname:<span class="variable">$0</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"first :<span class="variable">$1</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"second:<span class="variable">$2</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"argume:<span class="variable">$@</span>"</span> </span><br><span class="line">保存退出 </span><br><span class="line">赋予脚本执行权限 </span><br><span class="line"><span class="comment"># chmod +x variable </span></span><br><span class="line">执行脚本 </span><br><span class="line"><span class="comment"># ./variable aa bb </span></span><br><span class="line">number:2 </span><br><span class="line">scname:./variable </span><br><span class="line">first: aa </span><br><span class="line">second:bb </span><br><span class="line">argume:aa bb </span><br><span class="line">通过显示结果可以看到： </span><br><span class="line"><span class="variable">$#</span> 是传给脚本的参数个数 </span><br><span class="line"><span class="variable">$0</span> 是脚本本身的名字 </span><br><span class="line"><span class="variable">$1</span>是传递给该shell脚本的第一个参数 </span><br><span class="line"><span class="variable">$2</span>是传递给该shell脚本的第二个参数 </span><br><span class="line"><span class="variable">$@</span> 是传给脚本的所有参数的列表</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下linux shell下的特殊用法及参数的说明.&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/set%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/set命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> 1</span><br><span class="line"><span class="built_in">command</span> 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>Every script you write should include set -e at the top. This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit.</p><p>你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。</p><p>Using -e gives you error checking for free. If you forget to check something, bash will do it for you. Unfortunately it means you can’t check $? as bash will never get to the checking code if it isn’t zero. There are other constructs you could use:</p><p>使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span>-ne <span class="number">0</span>]; then </span><br><span class="line">echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi </span><br><span class="line">could be replaced with</span><br></pre></td></tr></table></figure><p>能够被代替为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command || &#123; echo <span class="string">"command failed"</span>; <span class="keyword">exit</span> <span class="number">1</span>; &#125; </span><br><span class="line">or</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> ! command; then</span><br><span class="line"> echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>What if you have a command that returns non-zero or you are not interested in its return value? You can use command || true, or if you have a longer section of code, you can turn off the error checking, but I recommend you use this sparingly.</p><p>如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>static关键字作用总结(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/static/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字理解/static/</id>
    <published>2018-07-17T10:07:12.000Z</published>
    <updated>2018-07-17T10:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。</p><a id="more"></a><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%c "</span>, a);</span><br><span class="line">     (<span class="keyword">void</span>)msg();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span> Hello</span><br></pre></td></tr></table></figure><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h2 id="内容持久化（static变量中的记忆功能和全局生存期）"><a href="#内容持久化（static变量中的记忆功能和全局生存期）" class="headerlink" title="内容持久化（static变量中的记忆功能和全局生存期）"></a>内容持久化（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><p>程序举例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fun()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>--; <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     printf(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">     <span class="keyword">for</span>(; <span class="keyword">count</span> &lt;= <span class="number">10</span>; ++<span class="keyword">count</span>)</span><br><span class="line">               printf(<span class="string">"%d\t\t%d\n"</span>, <span class="keyword">count</span>, fun());</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">global  local static</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h2 id="默认初始化为0"><a href="#默认初始化为0" class="headerlink" title="默认初始化为0"></a>默认初始化为0</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"integer: %d; string: (begin)%s(end)"</span>, a, str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">integer</span>: <span class="number">0</span>; <span class="keyword">string</span>: (<span class="keyword">begin</span>) (<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h2 id="C-中的类成员声明static"><a href="#C-中的类成员声明static" class="headerlink" title="C++中的类成员声明static"></a>C++中的类成员声明static</h2><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </li><li>不能将静态成员函数定义为虚函数。      </li><li>由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</li><li>由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）</li><li>static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。</li><li>静态数据成员在&lt;定义或说明&gt;时前面加关键字static。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）</li><li><p>静态成员初始化与一般数据成员初始化不同:</p><p> 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；</p><pre><code>所以我们得出静态数据成员初始化的格式：</code></pre><p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p></li><li><p>为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p></li></ol><h2 id="转载地址"><a href="#转载地址" class="headerlink" title="转载地址"></a>转载地址</h2><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" rel="external nofollow noopener noreferrer" target="_blank">C++中static关键字作用总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字理解" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
</feed>
