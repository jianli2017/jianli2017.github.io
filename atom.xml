<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-16T01:27:41.925Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KMP字符串查找</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/34_KMP/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/34_KMP/</id>
    <published>2019-07-12T10:07:12.000Z</published>
    <updated>2019-07-16T01:27:41.925Z</updated>
    
    <content type="html"><![CDATA[<p>记录KMP算法的主要思想</p><a id="more"></a><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>模式串和主串匹配的过程，当遇到不匹配的字符的时候，我们希望找到一种规律，可以往后多滑动几位。</p><p>模式串和主串匹配的过程中，存在相等和不相等的可能。</p><p>不相等的处理：拿好前缀本身，在它的后缀子串中，查找最长的那个可以和好前缀的前缀子串匹配。</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_多滑动几位.png" alt="匹配过程中，不相等处理"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func kmp(<span class="string">a:</span> String, <span class="string">n:</span> Int, <span class="string">b:</span> String, <span class="string">m:</span>Int) -&gt; Int &#123;</span><br><span class="line">    let next = getNexts(<span class="string">b:</span> b, <span class="string">m:</span> m)</span><br><span class="line">    var j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;n &#123;</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; a[a.index(a.startIndex, <span class="string">offsetBy:</span> i)] != b[b.index(b.startIndex, <span class="string">offsetBy:</span> j)] &#123; <span class="comment">//处理不等于的情况，i不动，j尽量移动多位</span></span><br><span class="line">            j = next[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相等，继续往后比较</span></span><br><span class="line">        <span class="keyword">if</span> a[a.index(a.startIndex, <span class="string">offsetBy:</span> i)] == b[b.index(b.startIndex, <span class="string">offsetBy:</span> j)] &#123;</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查找到了结果</span></span><br><span class="line">        <span class="keyword">if</span> j == m &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h2><p>next说明：</p><ol><li>下标：每个前缀结尾的下标</li><li>值： 这个前缀的最长可以匹配的前缀子串的结尾下标</li></ol><p>next[i-1] = k-1,则next[i] = k</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_Next求解中，相等处理.png" alt="KMP_Next求解中，相等处理"></p><p>查找b[0,i-1]的次长可匹配后缀子串，这个问题变成， 查找b[0,y]的最长匹配后缀子串的问题</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_next求解中，不相等.png" alt="KMP_Next求解中，相等处理"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*失效函数：  b 表示模式串，m表示模式串的长度*/</span></span><br><span class="line">func getNexts(<span class="selector-tag">b</span>: String, m: Int) -&gt; [Int] &#123;</span><br><span class="line">    <span class="selector-tag">var</span> next:[Int] = Array(repeating: -<span class="number">1</span>, count: m)  <span class="comment">//定义失效函数</span></span><br><span class="line">    <span class="selector-tag">var</span> k = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">        while k != -<span class="number">1</span> &amp;&amp; <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: k+<span class="number">1</span>)] != <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: i)] &#123;</span><br><span class="line">            k = next[k]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: k+<span class="number">1</span>)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: i)] &#123;</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[k] = k</span><br><span class="line">    &#125;</span><br><span class="line">    return next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录KMP算法的主要思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>理解OAuth</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/OAuth%202.0/OAuth/"/>
    <id>http://yoursite.com/wiki/编程理论/OAuth 2.0/OAuth/</id>
    <published>2019-07-11T04:11:35.000Z</published>
    <updated>2019-07-16T01:23:34.166Z</updated>
    
    <content type="html"><![CDATA[<p>理解OAuth</p><a id="more"></a><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><img src="/wiki/编程理论/OAuth 2.0/OAuth/auth.png" alt="OAuth"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" rel="external nofollow noopener noreferrer" target="_blank">理解OAuth 2.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解OAuth&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
      <category term="OAuth 2.0" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/OAuth-2-0/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift新特性</title>
    <link href="http://yoursite.com/wiki/IOS/swiftUI/swiftUI/"/>
    <id>http://yoursite.com/wiki/IOS/swiftUI/swiftUI/</id>
    <published>2019-07-02T04:07:12.000Z</published>
    <updated>2019-07-04T11:00:51.440Z</updated>
    
    <content type="html"><![CDATA[<p>本文按照自己的思路理解swift的新特性</p><a id="more"></a><h2 id="function-Builder-新特性"><a href="#function-Builder-新特性" class="headerlink" title="function Builder  新特性"></a>function Builder  新特性</h2><h2 id="单表达式隐式返回"><a href="#单表达式隐式返回" class="headerlink" title="单表达式隐式返回"></a>单表达式隐式返回</h2><p>计算属性、函数语句、闭包表达式，如果只有一个表达式，可以省略return关键字</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">width</span> = <span class="number">0.0</span>, <span class="built_in">height</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="built_in">var</span> area1: Double &#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;</span><br><span class="line">    </span><br><span class="line">    func area2() -&gt; Double &#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据结构体默认成员合成默认初始化器"><a href="#根据结构体默认成员合成默认初始化器" class="headerlink" title="根据结构体默认成员合成默认初始化器"></a>根据结构体默认成员合成默认初始化器</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Dog &#123;</span><br><span class="line">    var <span class="attr">name</span> = <span class="string">"Generic dog name"</span></span><br><span class="line">    var <span class="attr">age</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">boltNewborn</span> = Dog()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">daisyNewborn</span> = Dog(name: <span class="string">"Daisy"</span>, age: <span class="number">0</span>)</span><br><span class="line">// before swift <span class="number">5.0</span> ❎</span><br><span class="line"><span class="keyword">let</span> <span class="attr">benjiNewborn</span> = Dog(name: <span class="string">"Benji"</span>)</span><br><span class="line">// after switft <span class="number">5.1</span> ✅</span><br><span class="line"><span class="keyword">let</span> <span class="attr">benjiNewborn</span> = Dog(name: <span class="string">"Benji"</span>)</span><br></pre></td></tr></table></figure><h2 id="属性包装器"><a href="#属性包装器" class="headerlink" title="属性包装器"></a>属性包装器</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/propertyWarpper.png" alt="属性包装器"></p><h2 id="不透明返回类型"><a href="#不透明返回类型" class="headerlink" title="不透明返回类型"></a>不透明返回类型</h2><p>协议中有关联类型，不是一个完全类型，编译时，无法推断类型，使用some 修饰协议返回值，就是不透明返回类型，使用者不知道类型， 编译器知道具体的类型。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after switft 5.1 ✅</span></span><br><span class="line">struct ContentView: View &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">body</span>: some View &#123;</span><br><span class="line">        Text(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift-Style-DSL-Function-Builder"><a href="#Swift-Style-DSL-Function-Builder" class="headerlink" title="Swift Style DSL / Function Builder"></a>Swift Style DSL / Function Builder</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/viewBuildrer.png" alt="function Builder  新特性"></p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>优先使用值类型，在栈上分配，COW </p><h2 id="协议还是泛型"><a href="#协议还是泛型" class="headerlink" title="协议还是泛型"></a>协议还是泛型</h2><p>使用协议时，尽量优先抽取功能，使用组合协议</p><h2 id="抽象数据访问"><a href="#抽象数据访问" class="headerlink" title="抽象数据访问"></a>抽象数据访问</h2><p>@Binding @State @EnviromentObject @Enviroment。</p><h2 id="View链式调用的理解"><a href="#View链式调用的理解" class="headerlink" title="View链式调用的理解"></a>View链式调用的理解</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/VIewModifier.png" alt="View链式调用的理解"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook/" rel="external nofollow noopener noreferrer" target="_blank">SwiftUI 的一些初步探索 (一)</a></li><li><a href="https://mp.weixin.qq.com/s/ciiauLB__o-cXXfKn7lL1Q" rel="external nofollow noopener noreferrer" target="_blank">系列文章深度解读|SwiftUI 背后那些事儿</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文按照自己的思路理解swift的新特性&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swiftUI" scheme="http://yoursite.com/categories/IOS/swiftUI/"/>
    
    
      <category term="SwiftUI" scheme="http://yoursite.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 分享内容</title>
    <link href="http://yoursite.com/wiki/IOS/swiftUI/swiftUI_Share/"/>
    <id>http://yoursite.com/wiki/IOS/swiftUI/swiftUI_Share/</id>
    <published>2019-07-02T04:07:12.000Z</published>
    <updated>2019-07-10T11:58:19.510Z</updated>
    
    <content type="html"><![CDATA[<p>介绍SwiftUI</p><a id="more"></a><h2 id="跨平台技术演变史"><a href="#跨平台技术演变史" class="headerlink" title="跨平台技术演变史"></a>跨平台技术演变史</h2><ol><li>H5+原生（Cordova）</li><li>JavaScript开发+原生渲染 （React Native、Weex）</li><li>自绘UI+原生功能(Flutter、SwiftUI)</li></ol><h3 id="H5-原生"><a href="#H5-原生" class="headerlink" title="H5+原生"></a>H5+原生</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_H5.png" alt="混合APP的原理"></p><p>缺点：</p><ol><li>webview渲染存在性能瓶颈、复杂任务无法胜任</li><li>调用原生功能需要封装插件，麻烦</li></ol><h3 id="JavaScript开发-原生渲染"><a href="#JavaScript开发-原生渲染" class="headerlink" title="JavaScript开发+原生渲染"></a>JavaScript开发+原生渲染</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Weex.png" alt="JavaScript开发+原生渲染"></p><p>分析： </p><ol><li>解决了Webview渲染性能问题，相比较于原生，多了从Vue到原始的翻译过程。</li><li>调用原生功能需要封装插件，也比较麻烦</li></ol><h3 id="自绘UI-原生功能"><a href="#自绘UI-原生功能" class="headerlink" title="自绘UI+原生功能"></a>自绘UI+原生功能</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_flutter.png" alt="flutter"></p><p>flutter Dart语言开发, Skia渲染。Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API</p><p>分析： </p><ol><li>解决了JS到Native的翻译过程，自渲染。</li><li>调用原生功能需要封装插件，也比较麻烦</li></ol><h2 id="SwiftUI简介"><a href="#SwiftUI简介" class="headerlink" title="SwiftUI简介"></a>SwiftUI简介</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_SwiftUI.png" alt="SwiftUI"></p><ol><li>声明式语法（SwiftUI），内部黑盒完成渲染</li><li>响应式编程，数据变化，监控、通知SwiftUI刷新数据</li><li>无缝调用原始功能</li></ol><h2 id="一个例子—体验SwiftUI现代编程语言的魅力"><a href="#一个例子—体验SwiftUI现代编程语言的魅力" class="headerlink" title="一个例子—体验SwiftUI现代编程语言的魅力"></a>一个例子—体验SwiftUI现代编程语言的魅力</h2><p>代码</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span>  <span class="selector-tag">LandmarkList</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="variable">@EnvironmentObject</span> var <span class="attribute">userData</span>: UserData</span><br><span class="line">    </span><br><span class="line">    var <span class="attribute">body</span>: some View &#123;</span><br><span class="line">        <span class="selector-tag">NavigationView</span> &#123;</span><br><span class="line">            <span class="selector-tag">List</span> &#123;</span><br><span class="line">                <span class="selector-tag">Toggle</span>(<span class="attribute">isOn</span>: $userData.showFavoritesOnly) &#123;</span><br><span class="line">                    <span class="selector-tag">Text</span>(<span class="string">"Show Favorites Only"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="selector-tag">ForEach</span>(userData.landmarks) &#123; <span class="selector-tag">landmark</span> <span class="selector-tag">in</span></span><br><span class="line">                    <span class="selector-tag">if</span> !<span class="selector-tag">self</span><span class="selector-class">.userData</span><span class="selector-class">.showFavoritesOnly</span> || <span class="selector-tag">landmark</span><span class="selector-class">.isFavorite</span> &#123;</span><br><span class="line">                        <span class="selector-tag">NavigationButton</span>(</span><br><span class="line">                            <span class="attribute">destination</span>: LandmarkDetail(<span class="attribute">landmark</span>: landmark)</span><br><span class="line">                                .environmentObject(self.userData)</span><br><span class="line">                        ) &#123;</span><br><span class="line">                            <span class="selector-tag">LandmarkRow</span>(<span class="attribute">landmark</span>: landmark)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.navigationBarTitle</span>(Text(<span class="string">"Landmarks"</span>), <span class="attribute">displayMode</span>: .large)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">LandmarkRow</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">landmark</span>: <span class="selector-tag">Landmark</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">body</span>: <span class="selector-tag">some</span> <span class="selector-tag">View</span> &#123;</span><br><span class="line">        <span class="selector-tag">HStack</span> &#123;</span><br><span class="line">            <span class="selector-tag">landmark</span><span class="selector-class">.image</span>(<span class="attribute">forSize</span>: <span class="number">50</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">Text</span>(<span class="attribute">verbatim</span>: landmark.name)</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">Spacer</span>()</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">if</span> <span class="selector-tag">landmark</span><span class="selector-class">.isFavorite</span> &#123;</span><br><span class="line">                <span class="selector-tag">VStack</span> &#123;</span><br><span class="line">                    <span class="selector-tag">Image</span>(<span class="attribute">systemName</span>: <span class="string">"star.fill"</span>)</span><br><span class="line">                        <span class="selector-class">.imageScale</span>(.medium)</span><br><span class="line">                        <span class="selector-class">.foregroundColor</span>(.yellow)</span><br><span class="line">                    <span class="selector-tag">Text</span>(<span class="string">"sdfsdf"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Sample.png" alt="例子"></p><h2 id="SwiftUI原理浅析"><a href="#SwiftUI原理浅析" class="headerlink" title="SwiftUI原理浅析"></a>SwiftUI原理浅析</h2><h3 id="View的运作原理"><a href="#View的运作原理" class="headerlink" title="View的运作原理"></a>View的运作原理</h3><p>体会了SwiftUI的简洁用法，强大的功能后，分析下背后的原理：</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_modifer.png" alt="声明式原理"></p><p>定义了View的协议，所有的控件都准守View协议，View协议只定义了一个属性body，由于有了body属性，所以可以对body做对应的操作，这些操作封装在View的扩展中。这些扩展称为modifier。modifer作用于一个元素后，返回一个modified对象，这个对象也准守View协议，可以链式调用。</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_VIew_protocal.png" alt="view协议定义"></p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_chain.png" alt="链式调用的分析"></p><ol><li>声明了控件的样式（内存看是链式结构）， 传入渲染引擎渲染。开发者只声明，不用管复杂的渲染机制，大大简化了开发难度</li><li>按需添加modifer，避免子类内存暴涨（性能）</li><li>基于协议式，底层可以任意修改，底层预留可非常大的扩展空间</li></ol><h3 id="HStack-ZStack"><a href="#HStack-ZStack" class="headerlink" title="HStack/ZStack"></a>HStack/ZStack</h3><p>HStack 和 ZStack 的非常类似安卓的 LinerLayout，算法也同 Flex 布局比较相似。 对于如下的布局, 苹果都会在控件之间添加上符合苹果人机交互指南的间距，保证 UI 的优雅和一致性。</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Stack.png" alt="Stack"></p><p>对于如上的 Stack 是怎么计算的？设 Stack 主轴方向长度为 W1。</p><ol><li>根据人机交互指南的预留出边距 S, 边距根据元素的排列可能有多个</li><li>得到剩余的主轴宽度 W2= W1 - N * S</li><li>平均分配一个预估宽度</li><li>计算一些具备明确宽高的元素 如 Image 设置了 Frame的元素的等。</li><li>沿主轴方向从前到后计算，，如果计算出来的宽度小于预估宽度则正常显示，不够则截断。</li><li>最后的元素为剩余宽度，如果不够显示则阶段</li><li>默认的交叉轴对齐方式为 Center，Stack 占据包括最大元素的边界。</li></ol><p>默认的计算是顺序计算布局，如果某些元素比较重要，可以使用 LayoutPriority Modifier 提高布局优先级避免出现视图截断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>基于声明式，底层做了大量工作，上层开发者开发更简单</li><li>响应式也简化了内部状态的维护</li><li>苹果生态系统的无缝衔接，无缝调用原生功能</li><li>内部人性化精细的设计，苹果的大力推广，不久的几年后，苹果开发的主要方式？</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook/" rel="external nofollow noopener noreferrer" target="_blank">SwiftUI 的一些初步探索 (一)</a></li><li><a href="https://mp.weixin.qq.com/s/ciiauLB__o-cXXfKn7lL1Q" rel="external nofollow noopener noreferrer" target="_blank">系列文章深度解读|SwiftUI 背后那些事儿</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍SwiftUI&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swiftUI" scheme="http://yoursite.com/categories/IOS/swiftUI/"/>
    
    
      <category term="SwiftUI" scheme="http://yoursite.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 数据流理解</title>
    <link href="http://yoursite.com/wiki/IOS/swiftUI/swiftUI_DataFlow/"/>
    <id>http://yoursite.com/wiki/IOS/swiftUI/swiftUI_DataFlow/</id>
    <published>2019-07-02T04:07:12.000Z</published>
    <updated>2019-07-09T08:43:08.092Z</updated>
    
    <content type="html"><![CDATA[<ol><li>对于不变的常量直接传递给 SwiftUI 即可。</li><li>对于控件上需要管理的状态使用 @State 管理。</li><li>对于外部的事件变化使用 BindableObject 发送通知。</li><li>对于需要共享的视图可变数据使用 @ObjectBinding 管理。</li><li>不要出现多个状态同步管理，使用 @Binding 共享一个 Source of truth。</li><li>对于系统环境使用 @Enviroment 管理。</li><li>对于需要共享的不可变数据使用 @EnviromemntObject 管理。</li><li>@Binding 具有引用语义，可以很好的和 @Binding @objectBinding @State 协作，避免出现多个数据不同步。</li></ol><a id="more"></a><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/State.png" alt="State"></p><h2 id="Binding-引用语义"><a href="#Binding-引用语义" class="headerlink" title="Binding(引用语义)"></a>Binding(引用语义)</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/Binding.png" alt="Binding"></p><h2 id="BindingConvertible（state转化为引用语义的Binding）"><a href="#BindingConvertible（state转化为引用语义的Binding）" class="headerlink" title="BindingConvertible（state转化为引用语义的Binding）"></a>BindingConvertible（state转化为引用语义的Binding）</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/BindingConvertible.png" alt="BindingConvertible"></p><h2 id="BindableObject（接受外部通知）"><a href="#BindableObject（接受外部通知）" class="headerlink" title="BindableObject（接受外部通知）"></a>BindableObject（接受外部通知）</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/BindableObject.png" alt="BindableObject"></p><h2 id="ObjectBinding-多个界面共用一个数据，内部包装多个界面"><a href="#ObjectBinding-多个界面共用一个数据，内部包装多个界面" class="headerlink" title="ObjectBinding(多个界面共用一个数据，内部包装多个界面)"></a>ObjectBinding(多个界面共用一个数据，内部包装多个界面)</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/ObjectBinding.png" alt="ObjectBinding"></p><h2 id="EnvionmentObject-环境对象"><a href="#EnvionmentObject-环境对象" class="headerlink" title="EnvionmentObject(环境对象)"></a>EnvionmentObject(环境对象)</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_DataFlow/EnvionmentObject.png" alt="ObjectBinding"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook/" rel="external nofollow noopener noreferrer" target="_blank">SwiftUI 的一些初步探索 (一)</a></li><li><a href="https://mp.weixin.qq.com/s/ciiauLB__o-cXXfKn7lL1Q" rel="external nofollow noopener noreferrer" target="_blank">系列文章深度解读|SwiftUI 背后那些事儿</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;对于不变的常量直接传递给 SwiftUI 即可。&lt;/li&gt;
&lt;li&gt;对于控件上需要管理的状态使用 @State 管理。&lt;/li&gt;
&lt;li&gt;对于外部的事件变化使用 BindableObject 发送通知。&lt;/li&gt;
&lt;li&gt;对于需要共享的视图可变数据使用 @ObjectBinding 管理。&lt;/li&gt;
&lt;li&gt;不要出现多个状态同步管理，使用 @Binding 共享一个 Source of truth。&lt;/li&gt;
&lt;li&gt;对于系统环境使用 @Enviroment 管理。&lt;/li&gt;
&lt;li&gt;对于需要共享的不可变数据使用 @EnviromemntObject 管理。&lt;/li&gt;
&lt;li&gt;@Binding 具有引用语义，可以很好的和 @Binding @objectBinding @State 协作，避免出现多个数据不同步。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swiftUI" scheme="http://yoursite.com/categories/IOS/swiftUI/"/>
    
    
      <category term="SwiftUI" scheme="http://yoursite.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>AFNetworking 源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/AFNetworking/AFNetworking/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/AFNetworking/AFNetworking/</id>
    <published>2019-06-05T10:07:12.000Z</published>
    <updated>2019-06-05T11:49:12.850Z</updated>
    
    <content type="html"><![CDATA[<p>本文学习了AFNetworking，画了几个图，当做学习的成绩，留作以后复习使用。</p><a id="more"></a><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p><img src="/wiki/IOS/opensource/AFNetworking/AFNetworking/AFNetworking1.png" alt="AFNetworking"></p><h2 id="接收到响应"><a href="#接收到响应" class="headerlink" title="接收到响应"></a>接收到响应</h2><p><img src="/wiki/IOS/opensource/AFNetworking/AFNetworking/AFNetworking2.png" alt="AFNetworking"></p><h2 id="进度条模块"><a href="#进度条模块" class="headerlink" title="进度条模块"></a>进度条模块</h2><p><img src="/wiki/IOS/opensource/AFNetworking/AFNetworking/AFNetworking3.png" alt="AFNetworking"></p><h2 id="认证模块"><a href="#认证模块" class="headerlink" title="认证模块"></a>认证模块</h2><p><img src="/wiki/IOS/opensource/AFNetworking/AFNetworking/AFNetworking4.png" alt="AFNetworking"></p><p><img src="/wiki/IOS/opensource/AFNetworking/AFNetworking/AFNetworking5.png" alt="AFNetworking"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://github.com/draveness/analyze/blob/master/contents/AFNetworking/验证%20HTTPS%20请求的证书（五）.md" rel="external nofollow noopener noreferrer" target="_blank">验证 HTTPS 请求的证书（五）</a></li><li><a href="https://www.jianshu.com/p/488c1f46cedd" rel="external nofollow noopener noreferrer" target="_blank">11.第三方源码-AFNetworking解析</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文学习了AFNetworking，画了几个图，当做学习的成绩，留作以后复习使用。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="AFNetworking" scheme="http://yoursite.com/categories/IOS/opensource/AFNetworking/"/>
    
    
      <category term="AFNetworking" scheme="http://yoursite.com/tags/AFNetworking/"/>
    
  </entry>
  
  <entry>
    <title>iOS App 签名的原理([抄袭的，有问题请联系](http://wereadteam.github.io/2017/03/13/Signature/))</title>
    <link href="http://yoursite.com/wiki/IOS/%E6%9A%82%E6%97%A0%E5%88%86%E7%B1%BB/ios_sign/"/>
    <id>http://yoursite.com/wiki/IOS/暂无分类/ios_sign/</id>
    <published>2019-06-03T04:07:12.000Z</published>
    <updated>2019-06-03T09:29:49.395Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。</p><a id="more"></a><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>先来看看苹果的签名机制是为了做什么。在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>通常我们说的签名就是数字签名，它是基于非对称加密算法实现的。对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。</p><p>简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的：</p><ol><li>选两个质数 p 和 q，相乘得出一个大整数n，例如 p=61，q=53，n=pq=3233</li><li>选 1-n 间的随便一个质数 e，例如 e = 17</li><li>经过一系列数学公式，算出一个数字 d，满足：<br>a. 通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。<br>b. 如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。</li></ol><p>上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用公钥加密，私钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥（只知道 n 和 e）的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而n数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。</p><p>若对数字 d 是怎样计算出来的感兴趣，可以详读这两篇文章：<a href="http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html" rel="external nofollow noopener noreferrer" target="_blank">RSA 算法原理（一）（二）</a></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>现在知道了有非对称加密这东西，那数字签名是怎么回事呢？</p><p>数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。</p><p>有了上述非对称加密算法，就可以实现这个需求：</p><p><img src="/wiki/IOS/暂无分类/ios_sign/sign0.png" alt=""></p><ol><li>首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。</li><li>生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。</li><li>对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。</li><li>用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。</li></ol><p>之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位/ 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。</p><p>好了，有了非对称加密的基础，知道了数字签名是什么，怎样可以保证一份数据是经过某个地方认证的，来看看怎样通过数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果认证允许的。</p><h2 id="最简单的签名"><a href="#最简单的签名" class="headerlink" title="最简单的签名"></a>最简单的签名</h2><p>要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。</p><p><img src="/wiki/IOS/暂无分类/ios_sign/sign1.png" alt="最简单的签名"></p><p>如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。</p><p>但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：</p><ol><li>开发 App 时可以直接把开发中的应用安装进手机进行调试。</li><li>In-House 企业内部分发，可以直接安装企业证书签名后的 APP。</li><li>AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。</li></ol><p>苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。</p><h2 id="新的需求"><a href="#新的需求" class="headerlink" title="新的需求"></a>新的需求</h2><p>我们先来看第一个，开发时安装APP，它有两个个需求：</p><ol><li>安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。</li><li>苹果必须对这里的安装有控制权，包括</li></ol><ul><li>a.经过苹果允许才可以这样安装。</li><li>b.不能被滥用导致非开发app也能被安装。</li></ul><p>为了实现这些需求，iOS 签名的复杂度也就开始增加了。</p><p>苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：</p><p><img src="/wiki/IOS/暂无分类/ios_sign/sign2.png" alt="新的需求"></p><ol><li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li><li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li><li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li><li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。</li><li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。</li><li>验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）</li></ol><h2 id="加点东西"><a href="#加点东西" class="headerlink" title="加点东西"></a>加点东西</h2><p>上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。</p><p>怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。</p><p><img src="/wiki/IOS/暂无分类/ios_sign/sign3.png" alt="加点东西"></p><p>可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。</p><h2 id="最终流程"><a href="#最终流程" class="headerlink" title="最终流程"></a>最终流程</h2><p>到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。</p><p>实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。</p><p>所以整个流程稍微变一下，就变成这样了：</p><p><img src="/wiki/IOS/暂无分类/ios_sign/sign4.png" alt="最终流程"></p><p>因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：</p><ol><li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li><li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li><li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li><li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li><li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。</li><li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。</li><li>确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。<br>开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。</li></ol><h2 id="概念和操作"><a href="#概念和操作" class="headerlink" title="概念和操作"></a>概念和操作</h2><p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p><ol><li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li><li>第 2 步苹果处理，不用管。</li><li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li><li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li><li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。</li><li>第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li></ol><p>这里再总结一下这些概念：</p><p>证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。</p><ol><li>Entitlements：包含了 App 权限开关列表。</li><li>CertificateSigningRequest：本地公钥。</li><li>p12：本地私钥，可以导入到其他电脑。</li><li>Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li></ol><h2 id="其他发布方式"><a href="#其他发布方式" class="headerlink" title="其他发布方式"></a>其他发布方式</h2><p>前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。</p><p>而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。</p><p>据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。</p><p>那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。</p><p>所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。</p><p>到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。</p><h2 id="AppStore-加密"><a href="#AppStore-加密" class="headerlink" title="AppStore 加密"></a>AppStore 加密</h2><p>另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。</p><h2 id="本地私钥"><a href="#本地私钥" class="headerlink" title="本地私钥"></a>本地私钥</h2><p>我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest 和 p12 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？</p><p>能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。</p><h2 id="mobileprovision-格式调研-这点是自己的"><a href="#mobileprovision-格式调研-这点是自己的" class="headerlink" title="mobileprovision 格式调研(这点是自己的)"></a>mobileprovision 格式调研(这点是自己的)</h2><p><img src="/wiki/IOS/暂无分类/ios_sign/sign5.png" alt="mobileprovision"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="暂无分类" scheme="http://yoursite.com/categories/IOS/%E6%9A%82%E6%97%A0%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="iOS App 签名的原理" scheme="http://yoursite.com/tags/iOS-App-%E7%AD%BE%E5%90%8D%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>字符串排序</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/5_1_sort/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/5_1_sort/</id>
    <published>2019-05-30T02:07:12.000Z</published>
    <updated>2019-05-30T02:19:46.129Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></p><h2 id="键索引排序"><a href="#键索引排序" class="headerlink" title="键索引排序"></a>键索引排序</h2><p>说明： <code>a[]</code> 中存储待排序的数据，字符串名字，组号（我们作为键），组号在<code>0~R-1</code>，取出组号的方式：<code>a[i].key()</code></p><ol><li>计算各组的频率<code>count[r+1]++</code>;</li><li>频率转索引  <code>count[r] = count[r-1] + count[r]</code></li><li>数据分类</li><li>回写</li></ol><h2 id="低位优先的字符串排序"><a href="#低位优先的字符串排序" class="headerlink" title="低位优先的字符串排序"></a>低位优先的字符串排序</h2><p>如果字符串的长度均为W，那就从右向左以每个字符作为键，用键索引计数法将字符串排序W遍。</p><p>理解的方法是向前看：如果有两个键，他们中还没有被检查过的字符都完全相同，不同之处取决于已经检查过的字符，因为两个键已经排序，有序。另外，如果还没有被检查过的部分不同，那么已经被检查过的字符对于两者的最终顺序没有意义。之后的某轮会保证有序。</p><h2 id="高位优先的字符串排序"><a href="#高位优先的字符串排序" class="headerlink" title="高位优先的字符串排序"></a>高位优先的字符串排序</h2><p>首先用键索引计数法将所有字符串按照首字母排序，然后递归的再将每个首字母所对于的子数组排序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/code/javadoc/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;算法4 官网地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
    
      <category term="字符串排序" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>子字符串查找</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/5_3_findSubString/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/5_3_findSubString/</id>
    <published>2019-05-30T02:07:12.000Z</published>
    <updated>2019-05-30T11:10:44.308Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></p><h2 id="暴力子字符串查找算法"><a href="#暴力子字符串查找算法" class="headerlink" title="暴力子字符串查找算法"></a>暴力子字符串查找算法</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> search(<span class="keyword">String</span> pat,<span class="keyword">String</span> txt)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> M = pat.length();</span><br><span class="line"><span class="keyword">int</span> N = txt.length();</span><br><span class="line"><span class="built_in">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=N-M;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt; M ;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">if</span>(txt.charAt(i+j) != pat.charAt(j))</span><br><span class="line"><span class="built_in">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">if</span>(j==M) <span class="built_in">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最坏情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式需要NM次比较。</p><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p>主要思想：提前判断如何重新开始查找。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/code/javadoc/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;算法4 官网地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
    
      <category term="子字符串查找" scheme="http://yoursite.com/tags/%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>单词查找数</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/5_2_search/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/5_2_search/</id>
    <published>2019-05-30T02:07:12.000Z</published>
    <updated>2019-05-30T10:16:11.353Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></p><h2 id="单词查找树"><a href="#单词查找树" class="headerlink" title="单词查找树"></a>单词查找树</h2><p>每个节点都有R条连接，其中R为字母表的大小</p><p>每个键所关联的值保存在该键的最后一个字母所对应的节点中。值为空的节点在符号表中没有对应的键，他们的存在是为了简化单词查找树中的查找操作。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>以被查找的键中的字符为导向，单词查找树中的每个节点都包含了下一个可能出现的所有字符的链接。</p><p>查找结果：</p><ol><li>尾字符对应的节点中的值非空，查找一次命中，键所对应的值就是尾字符所对应的节点中保存的值。</li><li>键的尾字符所对应的节点中值为空，未命中，符号表中不存在被查找的键</li><li>查找结束于一条空链接，这也是一次未命中的查找</li></ol><p>查找过程就是在单词查找树中从根节点开始检查某条路径上所有节点。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ol><li>在到达键尾部前就遇到了一个空链接，需要为键中还未被检查的每个字符创建一个对应的节点，并将键对应的值保存在最后一个节点中。</li><li>在遇到空链接前就到达了健的尾部，将该节点中值设为键对应的值。</li></ol><h3 id="节点的表示"><a href="#节点的表示" class="headerlink" title="节点的表示"></a>节点的表示</h3><p>每个节点都含有一个值和26个链接</p><p>在单词查找树中，键是由从根节点到含有非空值的节点的路径隐式表示的。数据节点并不会保存字符串或字符，它保存了链接数组和值。基于含有R个字符的字母表的单词查找数称为<strong>R向单词查找树</strong>。</p><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>size的延时实现：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">size</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>(Node x)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x.val) ++cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i&lt;R, ++i)</span><br><span class="line">&#123;</span><br><span class="line">cnt += <span class="keyword">size</span>(<span class="keyword">next</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="built_in">get</span>(Node x,<span class="keyword">String</span> <span class="built_in">key</span>, <span class="built_in">int</span> d)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(d== <span class="built_in">key</span>.length()) <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始递归</span></span><br><span class="line"><span class="built_in">char</span> c = <span class="built_in">key</span>.charAt(d++);</span><br><span class="line">Node next = x.next[c];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">get</span>(next, <span class="built_in">key</span>,d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Value <span class="built_in">get</span>(<span class="keyword">String</span> <span class="built_in">key</span>)</span><br><span class="line">&#123;</span><br><span class="line">Node node = <span class="built_in">get</span>(root,<span class="built_in">key</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> node.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node put(Node x, <span class="keyword">String</span> <span class="built_in">key</span>, Value val, <span class="built_in">int</span> d) &#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) x= <span class="keyword">new</span> Node();</span><br><span class="line"><span class="keyword">if</span>(d == <span class="built_in">key</span>.length()) &#123;x.val = val, <span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="built_in">char</span> c = <span class="built_in">key</span>.charAt(d);</span><br><span class="line">x.next[c] = put(x.next[c],<span class="built_in">key</span>,val,d+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> put(<span class="keyword">String</span> <span class="built_in">key</span>, Value val) &#123;</span><br><span class="line">root = put(root,<span class="built_in">key</span>,val,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找所有键"><a href="#查找所有键" class="headerlink" title="查找所有键"></a>查找所有键</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> collect(Node x, <span class="keyword">String</span> pre, Queue&lt;<span class="keyword">String</span>&gt;) &#123;</span><br><span class="line"><span class="keyword">if</span>(x== <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x.val != <span class="keyword">null</span>) q.enqueue(pre);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">char</span> c=<span class="number">0</span>; c&lt;R; c++) &#123;</span><br><span class="line">collect(x.next[c],pre+c,q);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Iterable&lt;<span class="keyword">String</span>&gt; keysWithPrefix(<span class="keyword">String</span> pre) &#123;</span><br><span class="line">Queue&lt;<span class="keyword">String</span>&gt;  q = <span class="keyword">new</span> Queue&lt;Sting&gt;();</span><br><span class="line">collect(<span class="built_in">get</span>(root,pre,<span class="number">0</span>),pre,q);</span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/code/javadoc/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;算法4 官网地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
    
      <category term="单词查找数" scheme="http://yoursite.com/tags/%E5%8D%95%E8%AF%8D%E6%9F%A5%E6%89%BE%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>JLRoute学习</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/JLRoute/JLRoute/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/JLRoute/JLRoute/</id>
    <published>2019-05-13T04:07:12.000Z</published>
    <updated>2019-05-13T11:04:49.434Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注册流程"><a href="#注册流程" class="headerlink" title="注册流程"></a>注册流程</h2><p><img src="/wiki/IOS/opensource/JLRoute/JLRoute/register.png" alt="注册流程"></p><h2 id="route流程"><a href="#route流程" class="headerlink" title="route流程"></a>route流程</h2><p><img src="/wiki/IOS/opensource/JLRoute/JLRoute/routerurl.png" alt="route流程"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;注册流程&quot;&gt;&lt;a href=&quot;#注册流程&quot; class=&quot;headerlink&quot; title=&quot;注册流程&quot;&gt;&lt;/a&gt;注册流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/IOS/opensource/JLRoute/JLRoute/register.png&quot; a
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="JLRoute" scheme="http://yoursite.com/categories/IOS/opensource/JLRoute/"/>
    
    
      <category term="JLRoute" scheme="http://yoursite.com/tags/JLRoute/"/>
    
  </entry>
  
  <entry>
    <title>NSScanner</title>
    <link href="http://yoursite.com/wiki/IOS/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/NSScaner/"/>
    <id>http://yoursite.com/wiki/IOS/foundation使用记录/NSScaner/</id>
    <published>2019-05-13T01:35:49.000Z</published>
    <updated>2019-05-13T10:21:48.262Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>A string parser that scans for substrings or characters in a character set, and for numeric values from decimal, hexadecimal, and floating-point representations.</p><p>NSScanner是一个string的解析器。</p><p>An NSScanner object interprets and converts the characters of an NSString object into number and string values. </p><p>NSScanner对象将 NSString对象的字符 解析转化为 数字或string。</p><p>NSScanner是个类族。</p><p>初始化方法：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">+ </span>scannerWithString:</span><br></pre></td></tr></table></figure><p>扫描字符或string</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="string">scanCharactersFromSet:</span><span class="string">intoString:</span></span><br></pre></td></tr></table></figure><p>扫描一个数字</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">- </span>scanDecimal:</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;A string parser that scans for substrings or characters in a character set, and for numeric values from decimal, hexade
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="foundation使用记录" scheme="http://yoursite.com/categories/IOS/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="NSScanner" scheme="http://yoursite.com/tags/NSScanner/"/>
    
  </entry>
  
  <entry>
    <title>NSURL记录</title>
    <link href="http://yoursite.com/wiki/IOS/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/NSURL%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/wiki/IOS/foundation使用记录/NSURL记录/</id>
    <published>2019-05-10T07:35:49.000Z</published>
    <updated>2019-05-10T11:00:15.844Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="url是什么？"><a href="#url是什么？" class="headerlink" title="url是什么？"></a>url是什么？</h2><p>url是（ Uniform Resource Locator ）统一资源定位符的缩写。</p><h2 id="完整格式-amp-语法"><a href="#完整格式-amp-语法" class="headerlink" title="完整格式&amp;语法"></a>完整格式&amp;语法</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme:[<span class="string">//[user[:password</span>]@]host[<span class="string">:port</span>]][<span class="string">/path</span>][<span class="symbol">?query</span>][<span class="string">#fragment</span>]</span><br></pre></td></tr></table></figure><ol><li>scheme: 传送协议。</li><li>层级URL标记符号(为[//],固定不变)</li><li>user、password：访问资源需要的凭证信息（可省略）</li><li>host：服务器。（通常为域名，有时为IP地址）</li><li>port：端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略）</li><li>path：路径。（以“/”字符区别路径中的每一个目录名称）</li><li>query：查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题）</li><li>fragment：片段。以“#”字符为起点</li></ol><hr><h2 id="NSURLComponents"><a href="#NSURLComponents" class="headerlink" title="NSURLComponents"></a>NSURLComponents</h2><ul><li><p>Accessing Components in Native Format</p><p> 包括：fragment、host、path、query、queryItems、scheme等</p></li><li><p>Accessing Components in URL-Encoded Format</p><p> 包括：percentEncodedFragment、percentEncodedHost等</p></li><li><p>Locating Components in the URL String Representation</p><p>包括：rangeOfFragment、rangeOfHost等</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;url是什么？&quot;&gt;&lt;a href=&quot;#url是什么？&quot; class=&quot;headerlink&quot; title=&quot;url是什么？&quot;&gt;&lt;/a&gt;url是什么？&lt;/h2&gt;&lt;p&gt;url是（ Uniform Resource Locator ）
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="foundation使用记录" scheme="http://yoursite.com/categories/IOS/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="NSURL" scheme="http://yoursite.com/tags/NSURL/"/>
    
  </entry>
  
  <entry>
    <title>appledoc生成文档实践</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/use_appledoc/"/>
    <id>http://yoursite.com/wiki/工具/use_appledoc/</id>
    <published>2019-05-05T02:18:26.000Z</published>
    <updated>2019-05-05T03:57:03.555Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>第一步，下载appledoc，安装：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone gi<span class="variable">t:</span>//github.<span class="keyword">com</span>/tomaz/appledoc.git</span><br><span class="line"><span class="keyword">cd</span> ./appledoc</span><br><span class="line">sudo <span class="keyword">sh</span> install-appledoc.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>第二步，验证appledoc是否安装成功：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appledoc <span class="comment">--help</span></span><br></pre></td></tr></table></figure><p>第三步， touch命令创建脚本，复制下面代码到脚本，然后添加执行权限，执行脚本：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">appledoc \</span><br><span class="line">-<span class="ruby">-output ./apiDoc \</span></span><br><span class="line"><span class="ruby">-i *.m \</span></span><br><span class="line"><span class="ruby">--project-name <span class="string">"GSecretKey"</span> \</span></span><br><span class="line"><span class="ruby">--project-company <span class="string">"com.Gome"</span> \</span></span><br><span class="line"><span class="ruby">--no-create-docset \</span></span><br><span class="line"><span class="ruby">--keep-undocumented-objects \</span></span><br><span class="line"><span class="ruby">--keep-undocumented-members \</span></span><br><span class="line"><span class="ruby">--no-warn-undocumented-object \</span></span><br><span class="line"><span class="ruby">--no-warn-undocumented-member  \</span></span><br><span class="line"><span class="ruby">./</span></span><br></pre></td></tr></table></figure><p>这样就可以将<code>./</code>目录下所有头文件中的注释自动生成出对应的文档到<code>./apiDoc</code>目录下。实际使用中，可以根据需要修改源文件路径、生成文件的路径、project-name、project-company。</p><p>上面的脚本是可以运行的，但是少了注释，难以理解。不添加注释的原因是：上面的命令太长，使用多行显示，使用 <code>\</code>实现多行功能，如果在 <code>\</code> 后直接添加注释，脚本会运行报错，没有地方添加注释。所以，可执行的脚本没有注释，下面将有注释的脚本单独列出来，方便理解:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">appledoc <span class="string">\</span></span><br><span class="line"><span class="comment">#文档输出目录</span></span><br><span class="line">--output ./apiDoc <span class="string">\</span>                                       </span><br><span class="line"><span class="comment">#忽略.m文件，因.m中均为私有api和属性，开源的接口文档中理应忽略掉</span></span><br><span class="line">-i *.m <span class="string">\</span>                                                         </span><br><span class="line"><span class="comment">#工程的名字</span></span><br><span class="line">--project-name <span class="string">"GSecretKey"</span> <span class="string">\</span></span><br><span class="line"><span class="comment">#公司的名字</span></span><br><span class="line">--project-company <span class="string">"com.Gome"</span> <span class="string">\</span></span><br><span class="line"><span class="comment">#不生成docset，直接输出html</span></span><br><span class="line">--<span class="literal">no</span>-create-docset <span class="string">\</span></span><br><span class="line"><span class="comment">#没有注释的文件也输出html  --&gt;目的是看到所有的文件</span></span><br><span class="line">--keep-undocumented-objects <span class="string">\</span></span><br><span class="line"><span class="comment">#没有注释的属性和方法也输出到html  --&gt;目的是看到所有的属性和方法</span></span><br><span class="line">--keep-undocumented-members <span class="string">\</span></span><br><span class="line"><span class="comment">#没有注释的文件不提示警告</span></span><br><span class="line">--<span class="literal">no</span>-warn-undocumented-object <span class="string">\</span></span><br><span class="line"><span class="comment">#没有注释的属性和方法不提示警告</span></span><br><span class="line">--<span class="literal">no</span>-warn-undocumented-member <span class="string">\</span></span><br><span class="line"><span class="comment">#需要输出的文件路径  --&gt;这里推荐最好直接为当前工程路径平级输出，便于维护和使用</span></span><br><span class="line">./</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>实际使用上问题挺多，尤其Xcode9之后，普遍的方法会出现此错误：ERROR | !&gt; xcrun: error: unable to find utility “docsetutil”, not a developer tool or in PATH</p></blockquote><p>解决办法：终端-&gt;编写脚本-&gt;运行脚本-&gt;更新脚本从而规避docsetutil找不到等错误，经过验证，将命令放在脚本中，确实解决了这个问题。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><div id="refer">参考</div></h2><ol><li><a href="https://www.jianshu.com/p/f5cb3c728a5b" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发_编写接口文档（appledoc实用篇）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;第一步，下载appledoc，安装：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ABTest IOS SDK设计</title>
    <link href="http://yoursite.com/wiki/IOS/ABTest/ABTest/ABTest/"/>
    <id>http://yoursite.com/wiki/IOS/ABTest/ABTest/ABTest/</id>
    <published>2019-03-22T06:18:26.000Z</published>
    <updated>2019-05-13T11:14:26.611Z</updated>
    
    <content type="html"><![CDATA[<p>阅读目录：</p><ol><li><a href="#design">ABTest使用场景分析</a></li><li><a href="#sdk">SDK设计图</a></li><li><a href="#jd">附录：XX App AB效果</a></li></ol><h2 id="ABTest使用场景分析"><a href="#ABTest使用场景分析" class="headerlink" title="ABTest使用场景分析"></a><div id="design">ABTest使用场景分析</div></h2><p>下图说明ABTest使用场景的分析。</p><p><img src="/wiki/IOS/ABTest/ABTest/ABTest/ABL1.png" alt="流程解析"></p><p>依据上图的分析，设计出下面的SDK流程。</p><h2 id="SDK设计图"><a href="#SDK设计图" class="headerlink" title="SDK设计图"></a><div id="sdk">SDK设计图</div></h2><p>下图说明SDK的设计图。</p><p><img src="/wiki/IOS/ABTest/ABTest/ABTest/ABL2.png" alt="SDK设计图"></p><h2 id="附录：XX-App-AB效果"><a href="#附录：XX-App-AB效果" class="headerlink" title="附录：XX App AB效果"></a><div id="jd">附录：XX App AB效果</div></h2><p>经过反编译XX APP，分析XX客户端的AB实现原理，然后修改XX的代码，对比底部Bar的AB效果。</p><p><img src="/wiki/IOS/ABTest/ABTest/ABTest/JDA.PNG" alt="A"><br><img src="/wiki/IOS/ABTest/ABTest/ABTest/JDB.jpeg" alt="B"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;阅读目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#design&quot;&gt;ABTest使用场景分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sdk&quot;&gt;SDK设计图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#jd&quot;&gt;附录：XX App AB效果&lt;/a&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="ABTest" scheme="http://yoursite.com/categories/IOS/ABTest/"/>
    
      <category term="ABTest" scheme="http://yoursite.com/categories/IOS/ABTest/ABTest/"/>
    
    
      <category term="ABTest" scheme="http://yoursite.com/tags/ABTest/"/>
    
  </entry>
  
  <entry>
    <title>24. 自动引用计数器</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/24__%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift学习摘要/24__自动引用计数器/</id>
    <published>2019-01-30T03:07:12.000Z</published>
    <updated>2019-07-02T01:56:24.589Z</updated>
    
    <content type="html"><![CDATA[<p>官方目录：</p><ol><li>How ARC Works</li><li>ARC in Action</li><li>Strong Reference Cycles Between Class Instances</li><li>Resolving Strong Reference Cycles Between Class Instances</li><li>Strong Reference Cycles for Closures</li><li>Resolving Strong Reference Cycles for Closures</li></ol><a id="more"></a><blockquote><p>引用计数只适用于实例对象。结构体和枚举是值类型，不是引用类型，并且不通过引用存储和传递的。</p></blockquote><h2 id="ARC-⼯作机制"><a href="#ARC-⼯作机制" class="headerlink" title="ARC ⼯作机制"></a>ARC ⼯作机制</h2><h2 id="解决实例之间的强引用循环"><a href="#解决实例之间的强引用循环" class="headerlink" title="解决实例之间的强引用循环"></a>解决实例之间的强引用循环</h2><p>Swift 提供了两种方法解决你在使用类的属性而产生的强引用循环:<strong>弱引用</strong>( weak )和 <strong>无主引用</strong>( unowned )。</p><p>当一个实例的生命周期比较引用它的实例短，也就是这个实例可能会先于引用它的实例释放的时候，需要使用弱引用( weak )。对与一栋公寓来说在它的生命周期中是完全可以没有住户的，所以在这种情况下，上例中 Apartment 类使用弱引用来打断强引用循环是合 适的。相反，当一个实例拥有和引用它的实例相同的生命周期或是比引用它的实例更长的生命周期的时候，需要使用无主引用(unowned)。</p><p><strong>由于弱引用需要能在运行过程中设置为 nil ,所以必需要声明为可选类型的变量而不是常量。</strong></p><blockquote><p>注意当 ARC 设置弱引用为 nil 的时候，属性观察不会被调用。</p></blockquote><p>无主引用总是有值的。因而，ARC也不会将无主引用的值设置为 nil ，这也意味着无主引用要被定义为非可选类型。</p><p>总结来说：三种情况，</p><font color="red"><ol><li>都可以为nil，weak</li><li>一个可为nil，unowned</li><li>都不能为nil, unowned和隐式解包可选值</li></ol><p></p></font><p></p><hr><p>其中第三种比较经典，下面列出代码： </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> capitalCity: <span class="type">City</span>!</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, capitalName: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.capitalCity = <span class="type">City</span>(name: capitalName, country: <span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> country: <span class="type">Country</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, country: <span class="type">Country</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.country = country</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决闭包引起的强引⽤循环"><a href="#解决闭包引起的强引⽤循环" class="headerlink" title="解决闭包引起的强引⽤循环"></a>解决闭包引起的强引⽤循环</h2><p><strong>捕获列表</strong>：在闭包内部捕获一个或多个引用类型的规则</p><p>捕获列表中的每一项都是由 weak 或 unowned 关键字和实例的引用(如 self ) 或是由其他值初始化的变量(如 delegate = self.delegate! )成组构成的。它们每 一组都写在方括号中，组之间用逗号隔开。</p><p>捕获列表放在闭包的<strong>参数和返回值</strong>(如果有返回值的话<strong>)前面</strong>:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazy var someClosure: (Int, <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> = &#123;</span><br><span class="line">    [unowned <span class="keyword">self</span>, weak delegate = <span class="keyword">self</span>.delegate!] (index: Int, stringToProcess: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// closure body goes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;How ARC Works&lt;/li&gt;
&lt;li&gt;ARC in Action&lt;/li&gt;
&lt;li&gt;Strong Reference Cycles Between Class Instances&lt;/li&gt;
&lt;li&gt;Resolving Strong Reference Cycles Between Class Instances&lt;/li&gt;
&lt;li&gt;Strong Reference Cycles for Closures&lt;/li&gt;
&lt;li&gt;Resolving Strong Reference Cycles for Closures&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="自动引用计数器" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>23. 泛型</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/23__%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift学习摘要/23__泛型/</id>
    <published>2019-01-29T03:07:12.000Z</published>
    <updated>2019-01-30T07:29:45.819Z</updated>
    
    <content type="html"><![CDATA[<p>官方目录：</p><ol><li>The Problem That Generics Solve</li><li>Generic Functions</li><li>Type Parameters</li><li>Naming Type Parameters</li><li>Generic Types</li><li>Extending a Generic Type</li><li>Type Constraints</li><li>Associated Types</li><li>Generic Where Clauses</li><li>Extensions with a Generic Where Clause</li><li>Associated Types with a Generic Where Clause</li><li>Generic Subscripts</li></ol><a id="more"></a><h2 id="泛型解决的问题"><a href="#泛型解决的问题" class="headerlink" title="泛型解决的问题"></a>泛型解决的问题</h2><p>泛型解决某些功能，例如交换两个数，由于参数类型不同，需要重复编写代码的问题。</p><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(_ <span class="selector-tag">a</span>: inout T, _ <span class="selector-tag">b</span>: inout T) &#123;</span><br><span class="line">let temporaryA = <span class="selector-tag">a</span> </span><br><span class="line">a=b</span><br><span class="line"><span class="selector-tag">b</span> = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型版本的函数使用占位符类型名，而不是一个真正的类型名称。调用泛型函数的时候，从实参中推断类型T。</p><h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p><strong>类型参数</strong>指定并命名一个占位类型，<strong>并紧挨着函数名称后面</strong>，使用一对尖括号括起来(例如 <t> )。类型参数在调用时被一个真实的类型所替换。你可以通过在尖括号内写多个类型参数名来提供多个类型参数，用逗号隔开。</t></p><blockquote><p>类型参数：将类型作为参数</p></blockquote><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>除了泛型函数外，Swift可以定义你自己的泛型类型 。这些自定义的类、结构体、枚举可以和任何类型一起使用，方式类似于数组、字典 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Element)</span></span> &#123;</span><br><span class="line">items.append(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line"><span class="keyword">return</span> items.removeLast()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h2><p>扩展泛型类型时，你不需要提供<strong>类型参数列表</strong>作为扩展定义的一部分。 相反，原始<strong>类型定义</strong>中的类型参数列表在扩展的主体内依旧可用，并且原始类型参数名称会被用于引用原始定义中的类型参数。</p><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>有时候，对泛型函数和泛型类型进行类型约束是很有用的。类型约束指定参数类型必须继承自特定的类、遵循特定的协议、特定的协议组。</p><p>###类型约束语法</p><p>类型约束的写法:在类型参数名后跟上一个类或协议来进行约束，使用冒号进行分割，作为类型参数列表的一部分。泛型函数的类型约束语法如下(泛型类型的语法与此相同)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line"><span class="comment">// 这⾥里里写函数体的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个类型参数<code>T</code>，类型约束要求<code>T</code>的类型必须是<code>SomeClass</code>的子类。第二个类型参数<code>U</code>，类型约束要求<code>U</code>必须遵循<code>SomeProtocol</code>协议</p><h3 id="为啥需要类型约束？"><a href="#为啥需要类型约束？" class="headerlink" title="为啥需要类型约束？"></a>为啥需要类型约束？</h3><p>想想字典的key，必须可哈希，不是所有的类型都能作为字典的key，所以需要约束。</p><h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>当定义一个协议时，有时候定义一个或多个关联类型作为协议的一部分是很有用的。<strong>关联类型</strong>作为协议的一部分，并为一种类型提供占位符名称。在实现该协议之前不会指定关联类型的实际类型。关联类型使用 associatedtype 关键字来指定。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">associatedtype <span class="type">Item</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Item)</span></span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>item 可以通过类型推断得到。或者显式的指定：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Item = <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><h3 id="将约束添加到关联类型"><a href="#将约束添加到关联类型" class="headerlink" title="将约束添加到关联类型"></a>将约束添加到关联类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">associatedtype <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Item)</span></span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了遵循这个版本的 Container ，容器的 Item 类型必须符合 <code>Equatable</code> 协议。</p><h2 id="泛型-Where-⼦句"><a href="#泛型-Where-⼦句" class="headerlink" title="泛型 Where ⼦句"></a>泛型 Where ⼦句</h2><p>对关联类型定义一些规定通常也很有用。你可以通过<strong>定义泛型where子句</strong> 来完成此操作。泛型 where 子句使你能够要求关联类型必须符合某个协议，或者某些类型参数和相关类型必须相同。泛型 where子句以where 关键字开头，后跟关联类型的约束条件或类型和关联类型之间的相等关系。</p><p>where的位置：你需要在一个类型或函数体的起始大括号之前写一个泛型where子句。</p><h3 id="在扩展中使⽤泛型Where⼦句"><a href="#在扩展中使⽤泛型Where⼦句" class="headerlink" title="在扩展中使⽤泛型Where⼦句"></a>在扩展中使⽤泛型Where⼦句</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">associatedtype</span> <span class="keyword">Iterator: </span><span class="keyword">IteratorProtocol </span>where <span class="keyword">Iterator.Element </span>== <span class="keyword">Item</span></span><br></pre></td></tr></table></figure><h2 id="泛型下标"><a href="#泛型下标" class="headerlink" title="泛型下标"></a>泛型下标</h2><p>标也可以用泛型表示，同时也可以包含泛型 where 子句。 可以在下标括号之后的尖括号内写一个类型占位符，在下标主体的起始大括号之前写一个泛型 where子句。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;官方目录：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The Problem That Generics Solve&lt;/li&gt;
&lt;li&gt;Generic Functions&lt;/li&gt;
&lt;li&gt;Type Parameters&lt;/li&gt;
&lt;li&gt;Naming Type Parameters&lt;/li&gt;
&lt;li&gt;Generic Types&lt;/li&gt;
&lt;li&gt;Extending a Generic Type&lt;/li&gt;
&lt;li&gt;Type Constraints&lt;/li&gt;
&lt;li&gt;Associated Types&lt;/li&gt;
&lt;li&gt;Generic Where Clauses&lt;/li&gt;
&lt;li&gt;Extensions with a Generic Where Clause&lt;/li&gt;
&lt;li&gt;Associated Types with a Generic Where Clause&lt;/li&gt;
&lt;li&gt;Generic Subscripts&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>21. 扩展</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/21__%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift学习摘要/21__扩展/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T07:07:06.729Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Extension Syntax</li><li>Computed Properties</li><li>Initializers</li><li>Methods</li><li>Subscripts</li><li>Nested Types</li></ol><a id="more"></a><p> Extensions :为已存在的类、结构体、枚举或者协议类型增添了一个新的功能。这项功 能包括在对你无法访问源码的情况下进行类的扩展的能力(例如“追溯模型”)。Swift 中的Extensions 与 Objective-C 中的 Categories 类似。(但与 Objective-C 中 Categories 有所不同的是，Swift 中的 Extensions 并没有一个具体的命名)<br>在 Swift 中 Extensions 可以做到:</p><ol><li>添加计算实例属性和计算类型属性</li><li>定义实例方法和类方法</li><li>提供新的初始化方法</li><li>定义下标脚本</li><li>定义和使用新的嵌套类型</li><li>使现有类型符合协议</li></ol><blockquote><p>注意: Extensions 可以为类增添一个新的功能，但却不能重写之前已经存在的功能。</p></blockquote><h2 id="Extension-语法"><a href="#Extension-语法" class="headerlink" title="Extension 语法"></a>Extension 语法</h2><p>使用关键字 Extension 来声明一个扩展:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line"><span class="comment">//编写 SomeType 的新功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你想为一个已经存在的类型的进行扩展并添加一个新的功能，那么这个功能将会被 该类所有的实例使用，即使在这个 Extension 被定义之前。</p></blockquote><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>Extensions 可以将计算实例属性与计算类型属性添加到现有类中去。</p><blockquote><p>注意：Extensions 可以添加一个新的属性，但是他们不能存储这些属性，也不能为现有类 型添加属性观察者。</p></blockquote><h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><p>Extensions 可以给类添加一个便利初始化器，但它们不能够提供指定初始化器、反初始化器。指定初始化器和反初始化器都必须由原始类去提供。</p><blockquote><p>注意： 如果你声明了一个带有扩展的新的初始化器，那么你仍然有责任去确认在这个初始化器完成之后，每一个实例都已经被初始化完成。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>扩展可以向已经存在的类型添加实例方法或类方法。</p><h3 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h3><p> 我们可以通过在扩展中添加实例方法来实现修改变量。</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p> Extensions 能够对已经存在的类型添加下标。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>我们可以通过扩展 Extensions 来向任何已经存在的类、结构体或枚举添加新的嵌套类 型。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Extension Syntax&lt;/li&gt;
&lt;li&gt;Computed Properties&lt;/li&gt;
&lt;li&gt;Initializers&lt;/li&gt;
&lt;li&gt;Methods&lt;/li&gt;
&lt;li&gt;Subscripts&lt;/li&gt;
&lt;li&gt;Nested Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="扩展" scheme="http://yoursite.com/tags/%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>22. 协议</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/22__%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift学习摘要/22__协议/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T10:59:08.348Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Protocol Syntax</li><li>Property Requirements</li><li>Method Requirements</li><li>Mutating Method Requirements</li><li>Initializer Requirements</li><li>Protocols as Types</li><li>Delegation</li><li>Adding Protocol Conformance with an Extension</li><li>Collections of Protocol Types</li><li>Protocol Inheritance</li><li>Class-Only Protocols</li><li>Protocol Composition</li><li>Checking for Protocol Conformance</li><li>Optional Protocol Requirements</li><li>Protocol Extensions</li></ol><a id="more"></a><p><strong>协议</strong>可以作为方法、属性或者其他的一些特定的任务和功能块的设计蓝图。协议可以适用于类、结构体、枚举,并为它们提供具体的实现或满足特定的需求。任意类型只要满足一个协议的要求，那么我们便称这个类型<strong>遵循</strong>这个协议。</p><p>除了要求遵循协议的类型必须提供对应的实现以外，还可以通过<strong>协议扩展</strong>来为协议的遵循者提供默认的或者对其有利的实现。</p><h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 协议的定义写在这⾥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: FirstProtocol, AnotherProtocol </span>&#123; </span><br><span class="line"><span class="comment">// 结构体的定义写在这⾥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在为子类适配协议时，父类的名称需要写在协议名之前，分隔符不变。</p><h2 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h2><p>协议可以要求遵循者提供特定名称的实例属性、类型属性。协议只指定属性的名称和类型，而不指定属性是储存属性还是计算属性。此外，协议中也可以指定属性是可读的还是可读可写的。</p><p><strong>协议可以指定属性的名称、类型、读写性</strong></p><p>协议属性通常会以var关键字来声明变量属性。在类型声明后加上<code>{ get set }</code>来表示属性是可读可写的，用<code>{ get }</code>来表示可读属性。</p><p>在协议中定义<strong>类型属性</strong>时，始终使用static关键字作为前缀。即使该<strong>类型属性</strong>在类实现时以以 class 或 static 关键字作为前缀，这个规则也适用。</p><h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><p>我们无法为协议中定义的方法的参数指定默认值。</p><p>与<strong>类型属性</strong>一样，当在协议中定义<strong>类型方法</strong>时，始终使用static 关键字作为前缀。即使该类型方法要求在由类实现时以 class 或 static 关键字为前缀，也是如此。</p><h2 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h2><blockquote><p>注意：如果将协议实例方法要求标记为mutating，则在为类编写该方法的实现时，不需要写<code>mutating</code>关键字。 mutating关键字仅由结构体和枚举使用。</p></blockquote><h2 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h2><p>协议可能要求通过遵循类型来实现<strong>指定构造器</strong>。和普通构造器写法一样，你可以将构造器定义写在协议中，只是不用写大括号和构造器实现。</p><h3 id="类实现协议构造器的要求"><a href="#类实现协议构造器的要求" class="headerlink" title="类实现协议构造器的要求"></a>类实现协议构造器的要求</h3><p>你可以通过实现指定构造器、便利构造器来使遵循协议的类满足协议的构造器要求。在这两种情况下，你必须使用 required 修饰符标记构造器实现。</p><h3 id="可失败的构造器的要求"><a href="#可失败的构造器的要求" class="headerlink" title="可失败的构造器的要求"></a>可失败的构造器的要求</h3><p>遵循类型可以用可失败或非可失败的构造器来满足可失败的构造器要求。非可失败的构造器要求必须用非可失败的构造器或隐式展开的可失败的构造器来满足。</p><h2 id="将协议作为类型"><a href="#将协议作为类型" class="headerlink" title="将协议作为类型"></a>将协议作为类型</h2><p>协议本身并不实现任何功能。不过，你创建的任何协议都可以变为一个功能完备的类型在代码中使用。因为它是一种类型，所以你可以在允许其他类型的许多地方使用协议，包括:</p><ol><li>作为函数、方法或构造器的参数类型或返回类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器的元素类型</li></ol><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托是一种设计模式，它使类或结构体能够将其某些职责交给(或委托)到另一种类型的实例。通过定义封装委托职责的协议来实现此设计模式，从而保证遵循协议的类型(称为委托)提供被委托的功能。</p><h2 id="扩展添加遵循某协议"><a href="#扩展添加遵循某协议" class="headerlink" title="扩展添加遵循某协议"></a>扩展添加遵循某协议</h2><pre><code>extension Dice: TextRepresentable {    var textualDescription: String {        return &quot;A \(sides)-sided dice&quot;    }}</code></pre><h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>泛型类型可能只能在特定条件下满足协议的要求，例如类的泛型参数遵循一个协议。你可以通过在扩展类型时列出条件约束，让泛型类型有条件的遵循一个协议。通过编写一个泛型where分句，在遵循的协议名称后面写上约束条件。</p><h3 id="通过扩展申明类采纳了协议"><a href="#通过扩展申明类采纳了协议" class="headerlink" title="通过扩展申明类采纳了协议"></a>通过扩展申明类采纳了协议</h3><p>如果一个类型已经满足遵循一个协议的所有要求，但它没有申明遵循了这个协议，你可以通过一个空的扩展遵循该协议。</p><blockquote><p>注意：类型不会自动遵循一个协议，即便已经满足这个协议的要求。它们必须显示的申明它们遵循了这个协议。</p></blockquote><h2 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h2><p>协议可以用作诸如数组或字典之类的集合类型的元素类型。</p><h2 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h2><p>协议可以继承一个或多个协议，并且可以在其继承的协议的基础上添加更多的要求。协议继承的语法类似于类继承的语法，但是协议继承支持同时继承多个协议，并用逗号隔开。</p><h2 id="类的专属协议"><a href="#类的专属协议" class="headerlink" title="类的专属协议"></a>类的专属协议</h2><p>你可以通过将<code>AnyObject</code>协议添加到协议的继承列表中，来将协议限定为仅类类型(而不是结构体或枚举)可用。</p><blockquote><p>注意： 当协议的要求遵循者必须符合引用语义而不是值语义时，请使用<strong>类专属协议</strong>。</p></blockquote><h2 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h2><p>某些场合下，要求类型可以同时遵循多个协议是很有用的。您可以使用<strong>协议组合</strong>将多个协议组合到单个需求中。协议组合的行为就像你定义了一个临时本地协议，该协议具有组合中所有协议的要求。协议组合不定义任何新的协议类型。</p><p>协议组合使用<code>SomeProtocol &amp; AnotherProtocol</code>的形式。你可以根据需要，列出尽可能多的协议，用&amp;符号分隔它们。除了协议列表之外，协议组合还可以包含一个类类型，你可以使用它来指定继承的父类。</p><h2 id="检查协议的遵循情况"><a href="#检查协议的遵循情况" class="headerlink" title="检查协议的遵循情况"></a>检查协议的遵循情况</h2><p>你可以使用<strong>类型转换</strong>中描述的 is 和 as 运算符来检查协议遵循、转换成特定协议。检查和转换协议与检查和转换类型的语法相同:</p><ol><li>如果实例遵循协议，则is运算符返回true ，如果不遵循则返回false 。</li><li>向下转换运算符as?返回协议类型的可选值，如果实例不遵循该协议，则该值为nil 。</li><li>向下转换运算符的as!强制向下转换为协议类型，如果向下转换不成功则触发运行时错误。</li></ol><h2 id="可选协议要求"><a href="#可选协议要求" class="headerlink" title="可选协议要求"></a>可选协议要求</h2><p>你可以为协议定义可选要求，这些要求不强制遵循者必须实现。可选要求以 optional修饰符为前缀，作为协议定义的一部分。</p><p>可选要求允许你的代码与Objective-C交互。协议和可选要求都必须用@objc 属性标记。请注意：@objc协议只能由继承自Objective-C类或其他@objc类的类遵循。结构体或枚举不能遵循它们。</p><p>在可选要求中使用方法或属性时，其类型将自动变为可选。例如，类型 (Int) -&gt;String 的方法变为 ((Int) -&gt; String)? 。请注意：整个函数类型变成了可选项， 而不是方法的返回值。</p><p>考虑到遵循协议的类型可能未实现要求，你应该使用可选链来调用可选协议。你通过在调用方法名称后面写一个问号来检查可选方法是否实现，例如 <code>someOptionalMethod? (someArgument)</code> 。</p><h2 id="协议扩展–协议上创建扩展"><a href="#协议扩展–协议上创建扩展" class="headerlink" title="协议扩展–协议上创建扩展"></a>协议扩展–协议上创建扩展</h2><p><font color="blue">通过在协议上创建扩展</font>，所有遵循者都将自动获得此方法的实现，而无需任何其他修改。</p><p>协议扩展可以为符合协议的类型添加实现，但无法扩展协议本身或是继承其他协议。 协议继承始终在协议自身的声明中指定。</p><h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>你可以使用<strong>协议扩展</strong>来为任何方法或计算属性提供默认实现。如果一个遵循者本身就实现了协议中要求的方法或属性，那么这个实现会代替协议扩展中的默认实现。</p><p>注意：由协议扩展提供默认实现和可选协议不同。尽管符合的类型不需要提供任何一种协议的实现，但默认的实现在被调用时不需要可选链。</p><h3 id="为协议扩展添加条件约束"><a href="#为协议扩展添加条件约束" class="headerlink" title="为协议扩展添加条件约束"></a>为协议扩展添加条件约束</h3><p>当我们定义一个协议扩展时，我们可以通过where关键字在被扩展的协议名称后指定一个约束条件。</p><blockquote><p>注意：如果一个类型遵循了多个具有同名方法或属性的扩展协议，那么 Swift会优先调用约束条件较多一方的属性或方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Protocol Syntax&lt;/li&gt;
&lt;li&gt;Property Requirements&lt;/li&gt;
&lt;li&gt;Method Requirements&lt;/li&gt;
&lt;li&gt;Mutating Method Requirements&lt;/li&gt;
&lt;li&gt;Initializer Requirements&lt;/li&gt;
&lt;li&gt;Protocols as Types&lt;/li&gt;
&lt;li&gt;Delegation&lt;/li&gt;
&lt;li&gt;Adding Protocol Conformance with an Extension&lt;/li&gt;
&lt;li&gt;Collections of Protocol Types&lt;/li&gt;
&lt;li&gt;Protocol Inheritance&lt;/li&gt;
&lt;li&gt;Class-Only Protocols&lt;/li&gt;
&lt;li&gt;Protocol Composition&lt;/li&gt;
&lt;li&gt;Checking for Protocol Conformance&lt;/li&gt;
&lt;li&gt;Optional Protocol Requirements&lt;/li&gt;
&lt;li&gt;Protocol Extensions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>20. 嵌套类型</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/20__%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift学习摘要/20__嵌套类型/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T03:58:49.024Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Nested Types in Action</li><li>Referring to Nested Types</li></ol><a id="more"></a><p> 通常我们会创建枚举来支持特定的类或结构体的功能。类似地，为了可以方便地定义在更复杂类型上下文中使用的实用 工具类和结构，Swift 允许你定义 嵌套类型 ，从而实现在枚举、类和结构体中的定义嵌套类型。</p><p>如果要将一个类型嵌套在另一个类型中，只需在支持类型的大括号内定义嵌套类型即可。类型支持多层嵌套。</p><h2 id="嵌套类型的使用"><a href="#嵌套类型的使用" class="headerlink" title="嵌套类型的使用"></a>嵌套类型的使用</h2><h2 id="引⽤嵌套类型"><a href="#引⽤嵌套类型" class="headerlink" title="引⽤嵌套类型"></a>引⽤嵌套类型</h2><p>要在其定义上下文之外使用嵌套类型，需要在其名称前面加上嵌套在其中的类型的名称。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Nested Types in Action&lt;/li&gt;
&lt;li&gt;Referring to Nested Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="嵌套类型" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
</feed>
