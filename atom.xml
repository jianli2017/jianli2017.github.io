<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-29T10:23:44.998Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>23. 泛型</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/23__%E6%B3%9B%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/23__泛型/</id>
    <published>2019-01-29T03:07:12.000Z</published>
    <updated>2019-01-29T10:23:44.998Z</updated>
    
    <content type="html"><![CDATA[<ol><li>The Problem That Generics Solve</li><li>Generic Functions</li><li>Type Parameters</li><li>Naming Type Parameters</li><li>Generic Types</li><li>Extending a Generic Type</li><li>Type Constraints</li><li>Associated Types</li><li>Generic Where Clauses</li><li>Extensions with a Generic Where Clause</li><li>Associated Types with a Generic Where Clause</li><li>Generic Subscripts</li></ol><a id="more"></a><h2 id="泛型解决的问题"><a href="#泛型解决的问题" class="headerlink" title="泛型解决的问题"></a>泛型解决的问题</h2><p>泛型解决某些功能，但由于不同参数，需要重复编写代码的问题。例如实现交换功能的函数。</p><h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(_ <span class="selector-tag">a</span>: inout T, _ <span class="selector-tag">b</span>: inout T) &#123;</span><br><span class="line">let temporaryA = <span class="selector-tag">a</span> </span><br><span class="line">a=b</span><br><span class="line"><span class="selector-tag">b</span> = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型版本的函数使用占位符类型名，而不是一个真正的类型名称。调用泛型函数的时候，从实参中推断类型T。</p><h2 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a>类型参数</h2><p>类型参数指定并命名一个占位类型，并紧挨着函数名称后面，使用一对尖括号括起来(例如 <t> )。类型参数在调用时被一个真实的类型 所替换。你可以通过在尖括号内写多个类型参数名来提供多个类型参数，用逗号隔开。</t></p><h2 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h2><p>除了泛型函数外，Swift可以定义你自己的泛型类型 。这些自定义的类、结构体、枚举可以和任何类型一起使用，方式类似于数组 和 字典 。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">var</span> items = [<span class="type">Element</span>]()</span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> item: Element)</span></span> &#123;</span><br><span class="line">items.append(item)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element</span> &#123;</span><br><span class="line"><span class="keyword">return</span> items.removeLast()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展泛型类型"><a href="#扩展泛型类型" class="headerlink" title="扩展泛型类型"></a>扩展泛型类型</h2><p>扩展泛型类型时，你不需要提供类型参数列表作为扩展定义的一部分。 相反，原始 类型定义 中的类型参数列表在扩展的主体内依旧可用，并且原始类型参数名称会被用于引用原始定义 中的类型参数。</p><h2 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h2><p>有时候 对泛型函数和泛型类型进行类型约束是很有用的。 类型约束指定参数类型必须继承自特定的类、遵循特定的协议、特定的协议组。</p><p>###类型约束语法</p><p> 类型约束的写法:在类型参数名后跟上一个类或协议来进行约束，使用冒号进行分割，作为类型参数列表的一部分。泛型函数的类型约束语法如下(泛型类型的语法与此相同)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span>&lt;T: SomeClass, U: SomeProtocol&gt;<span class="params">(someT: T, someU: U)</span></span> &#123;</span><br><span class="line"><span class="comment">// 这⾥里里写函数体的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个类型参数 T ，类型约束要求 T 的类型必须是 SomeClass 的子类。第二个类型参数 U ，类型约束要求 U 必须遵循 SomeProtocol 协议</p><h3 id="类型约束行为"><a href="#类型约束行为" class="headerlink" title="类型约束行为"></a>类型约束行为</h3><h2 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h2><p>当定义一个协议时，有时候定义一个或多个关联类型作为协议的一部分是很有用的。关联类型作为协议的一部分并为一种类型提供占位符名称。在实现该协议之前不会指定该关联类型的实际类型。关联类型使用 associatedtype 关键字来指定。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">associatedtype <span class="type">Item</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Item)</span></span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>item 可以通过类型推断得到。或者</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> Item = <span class="built_in">Int</span></span><br></pre></td></tr></table></figure><h3 id="扩展现有类型，以指定关联类型"><a href="#扩展现有类型，以指定关联类型" class="headerlink" title="扩展现有类型，以指定关联类型"></a>扩展现有类型，以指定关联类型</h3><h3 id="将约束添加到关联类型"><a href="#将约束添加到关联类型" class="headerlink" title="将约束添加到关联类型"></a>将约束添加到关联类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">associatedtype <span class="type">Item</span>: <span class="type">Equatable</span></span><br><span class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> item: Item)</span></span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">subscript</span>(i: <span class="type">Int</span>) -&gt; <span class="type">Item</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了遵循这个版本的 Container ，容器的 Item 类型必须符合 Equatable 协 议。</p><h3 id="在其关联类型的约束中使用协议"><a href="#在其关联类型的约束中使用协议" class="headerlink" title="在其关联类型的约束中使用协议"></a>在其关联类型的约束中使用协议</h3><h2 id="泛型-Where-⼦句"><a href="#泛型-Where-⼦句" class="headerlink" title="泛型 Where ⼦句"></a>泛型 Where ⼦句</h2><p>对关联类型定义一些规定通常也很有用。你可以通过定义 泛型 where 子句 来完成此操作。 泛型 where 子句使你能够要求关联类型必须符合某个协议，或者某些类型参数和相关类 型必须相同。泛型 where 子句以 where 关键字开头，后跟关联类型的约束条件或类 型和关联类型之间的相等关系。你需要在一个类型或函数体的起始大括号之前写一个泛型where 子句。</p><h3 id="在扩展中使⽤泛型Where⼦句"><a href="#在扩展中使⽤泛型Where⼦句" class="headerlink" title="在扩展中使⽤泛型Where⼦句"></a>在扩展中使⽤泛型Where⼦句</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">associatedtype</span> <span class="keyword">Iterator: </span><span class="keyword">IteratorProtocol </span>where <span class="keyword">Iterator.Element </span>== <span class="keyword">Item</span></span><br></pre></td></tr></table></figure><h2 id="带有泛型Where⼦句的关联类型"><a href="#带有泛型Where⼦句的关联类型" class="headerlink" title="带有泛型Where⼦句的关联类型"></a>带有泛型Where⼦句的关联类型</h2><h2 id="泛型下标"><a href="#泛型下标" class="headerlink" title="泛型下标"></a>泛型下标</h2><p>标也可以用泛型表示，同时也可以包含泛型 where 子句。 可以在下标括号之后的尖括号内写一个类型占位符，在下标主体的起始大括号之前写一个泛型 where子句。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;The Problem That Generics Solve&lt;/li&gt;
&lt;li&gt;Generic Functions&lt;/li&gt;
&lt;li&gt;Type Parameters&lt;/li&gt;
&lt;li&gt;Naming Type Parameters&lt;/li&gt;
&lt;li&gt;Generic Types&lt;/li&gt;
&lt;li&gt;Extending a Generic Type&lt;/li&gt;
&lt;li&gt;Type Constraints&lt;/li&gt;
&lt;li&gt;Associated Types&lt;/li&gt;
&lt;li&gt;Generic Where Clauses&lt;/li&gt;
&lt;li&gt;Extensions with a Generic Where Clause&lt;/li&gt;
&lt;li&gt;Associated Types with a Generic Where Clause&lt;/li&gt;
&lt;li&gt;Generic Subscripts&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>19. 类型转换</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/19__%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/19__类型转换/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T03:55:37.511Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Defining a Class Hierarchy for Type Casting</li><li>Checking Type</li><li>Downcasting</li><li>Type Casting for Any and AnyObject</li></ol><a id="more"></a><p>Swift 中的类型转换是通过 is 和 as 运算符实现的。 这两个运算符提供了一种简单 而直观的方法来检查值的类型，或将值转换为其他类型。</p><h2 id="定义一个类结构作为类型转换示例"><a href="#定义一个类结构作为类型转换示例" class="headerlink" title="定义一个类结构作为类型转换示例"></a>定义一个类结构作为类型转换示例</h2><p>你可以使用类型转换连同类和子类的层次结构来检查特定类的实例类型，并将该实例强制转 换为同一层次结构中的另一个类。</p><h2 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h2><p>使用 类型检查运算符( is )来检查实例是否属于某个特定子类型。 如果实例属于该子类型，则类型检查运算符将返回 true ，否则，将返回 false 。</p><h2 id="强制转型"><a href="#强制转型" class="headerlink" title="强制转型"></a>强制转型</h2><p>实际上某个类型的常量或变量可能本来就是某个子类的实例。当确认是这种情况情况时，你 可以尝试使用 类型强制转换运算符 ( as? 或 as! )将该常量或变量 强制转换 成子 类型。</p><p>由于强制转换可能会失败，因该类型转换运算符有两种不同的形式。条件形式 as? 会返 回你尝试强制转换的类型的可选值。强制形式 as! 则会尝试强制转换，并同时将结果强 制解包。</p><p>当你不确定强制转换是否成功时，请使用类型转换运算符的条件形式( as? )。这种形 式的运算符将始终返回一个可选值，如果无法进行强制转换，该值将为 nil 。这使得你 可以检查强制转换是否成功。<br>仅当你确定强制转换会始终成功时，才使用类型转换运算符的强制形式( as! )。如果 你尝试强制转换为不正确的类型，此形式的运算符将触发运行时错误。</p><blockquote><p>转换实际上不会变更实例或修改其值。原本的实例保持不变;我们仅仅把它看作是它类型的实例，对其进行简单地处理和访问。</p></blockquote><h2 id="对Any和AnyObject做类型转换"><a href="#对Any和AnyObject做类型转换" class="headerlink" title="对Any和AnyObject做类型转换"></a>对Any和AnyObject做类型转换</h2><p>Swift 提供了两种特殊的类型来处理非特定类型:</p><ol><li>Any 可以表示任何类型的实例，包括函数类型。 </li><li>AnyObject 可以表示任何类类型的实例。</li></ol><p>只有在明确需要 Any 或 AnyObject 所提供的行为和功能时才使用他们。 最好在你 的代码中明确需要使用的类型。</p><blockquote><p>注意<br>Any 类型表示任何类型的值，包括可选类型。 如果程序需要一个类型为 Any 的 值，而你却使用了可选类型，Swift 会向你发出警告。 如果你确实需要将可选值作为Any 使用，可以使用 as 操作符将可选类型显式地转换为 Any 类型，如下所 示。</p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let optionalNumber: <span class="keyword">Int</span>? = <span class="number">3</span> things.<span class="keyword">append</span>(optionalNumber) <span class="comment">// 警告 </span></span><br><span class="line">things.<span class="keyword">append</span>(optionalNumber as <span class="keyword">Any</span>) <span class="comment">// 没有警告</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Defining a Class Hierarchy for Type Casting&lt;/li&gt;
&lt;li&gt;Checking Type&lt;/li&gt;
&lt;li&gt;Downcasting&lt;/li&gt;
&lt;li&gt;Type Casting for Any and AnyObject&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="类型转换" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>22. 协议</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/22__%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/22__协议/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T08:31:35.540Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Protocol Syntax</li><li>Property Requirements</li><li>Method Requirements</li><li>Mutating Method Requirements</li><li>Initializer Requirements</li><li>Protocols as Types</li><li>Delegation</li><li>Adding Protocol Conformance with an Extension</li><li>Collections of Protocol Types</li><li>Protocol Inheritance</li><li>Class-Only Protocols</li><li>Protocol Composition</li><li>Checking for Protocol Conformance</li><li>Optional Protocol Requirements</li><li>Protocol Extensions</li></ol><a id="more"></a><p>协议 可以作为方法、属性或者其他的一些特定的任务和功能块的设计蓝图。协议 可以适用 于 类 、 结构体 、以及 枚举 并为它们提供具体的实现或满足特定的需求。任意类型 只要满足一个协议的要求，那么我们便称这个类型 遵循 这个协议。</p><p>除了要求遵循协议的类型必须提供对应的实现以外，还可以通过 协议扩展 来为协议的遵循者 提供默认的或者对其有利的实现。</p><h2 id="协议语法"><a href="#协议语法" class="headerlink" title="协议语法"></a>协议语法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SomeProtocol</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 协议的定义写在这⾥里里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SomeStructure</span>: FirstProtocol, AnotherProtocol </span>&#123; </span><br><span class="line"><span class="comment">// 结构体的定义写在这⾥</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，在为子类适配协议时，父类名称需要写在协议名之前，分隔符不变。</p><h2 id="属性要求"><a href="#属性要求" class="headerlink" title="属性要求"></a>属性要求</h2><p>协议可以要求遵循协议的类型提供特定名称和实例属性或类型属性。协议只指定属性的名称和类型，而不指定属性为储存属性或计算属性。此外，协议中也可以指定属性是可读的还是可读可写的。</p><p>协议属性通常会以 var 关键字来声明变量属性。在类型声明后加上 { get set } 来表示属性是可读可写的，用{ get } 来表示可读属性。</p><p>在协议中定义类型属性要求时，始终使用 static 关键字作为前缀。即使该类型属性由 类实现，需要以 class 或 static 关键字作为前缀时，这个规则也适用</p><h2 id="方法要求"><a href="#方法要求" class="headerlink" title="方法要求"></a>方法要求</h2><p>我们无法为协议中定义的方法的参数指定默认值。与类型属性要求一样，当在协议中定义类型方法时，始终使用 static 关键字作为前缀。即使该类型方法要求在由类实现时以 class 或 static 关键字为前缀，也是如此。</p><h2 id="异变方法要求"><a href="#异变方法要求" class="headerlink" title="异变方法要求"></a>异变方法要求</h2><blockquote><p>注意：如果将协议实例方法要求标记为 mutating ，则在为类编写该方法的实现时，不需要 写 mutating 关键字。 mutating 关键字仅由结构体和枚举使用。</p></blockquote><h2 id="构造器要求"><a href="#构造器要求" class="headerlink" title="构造器要求"></a>构造器要求</h2><p>协议可能要求通过遵循类型来实现特定的构造器。和普通构造器写法一样，你可以将构造器定义写在协议中，只是不用写大括号和构造器实现</p><h3 id="协议构造器要求的类实现"><a href="#协议构造器要求的类实现" class="headerlink" title="协议构造器要求的类实现"></a>协议构造器要求的类实现</h3><p>你可以通过实现指定构造器、便利构造器来使遵循协议的类满足协议的构造器要求。在这两种情况下，你必须使用 required 修饰符标记构造器实现。</p><h3 id="可失败的构造器要求"><a href="#可失败的构造器要求" class="headerlink" title="可失败的构造器要求"></a>可失败的构造器要求</h3><p>遵循类型可以用可失败或非可失败的构造器来满足可失败的构造器要求。非可失败的构造器要求必须用非可失败的构造器或隐式展开的可失败的构造器来满足。</p><h2 id="将协议作为类型"><a href="#将协议作为类型" class="headerlink" title="将协议作为类型"></a>将协议作为类型</h2><p>协议本身并不实现任何功能。不过，你创建的任何协议都可以变为一个功能完备的类型在代码中使用。因为它是一种类型，所以你可以在允许其他类型的许多地方使用协议，包括:</p><ol><li>作为函数、方法或构造器的参数类型或返回类型</li><li>作为常量、变量或属性的类型</li><li>作为数组、字典或其他容器的元素类型</li></ol><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>委托 是一种设计模式，它使类或结构体能够将其某些职责交给(或 委托)到另一种类型的实 例。通过定义封装委托职责的协议来实现此设计模式，从而保证遵循协议类型(称为委托) 提供被委托的功能。</p><h2 id="让扩展添加协议遵循"><a href="#让扩展添加协议遵循" class="headerlink" title="让扩展添加协议遵循"></a>让扩展添加协议遵循</h2><h3 id="有条件地遵循协议"><a href="#有条件地遵循协议" class="headerlink" title="有条件地遵循协议"></a>有条件地遵循协议</h3><p>泛型类型可能只能在特定条件下满足协议的要求，例如类的泛型参数遵循一个协议。你可以通过在扩展类型时列出条件约束，让泛型类型有条件的遵循一个协议。通过编写一个泛型where 分句，在遵循的协议名称后面写上约束条件。</p><h3 id="通过扩展申明采纳协议"><a href="#通过扩展申明采纳协议" class="headerlink" title="通过扩展申明采纳协议"></a>通过扩展申明采纳协议</h3><p>如果一个类型已经满足遵循一个协议的所有要求，但它没有申明遵循了这个协议，你可以通 过一个空的扩展遵循该协议。</p><blockquote><p>注意：类型不会自动遵循一个协议，即便已经满足这个协议的要求。它们必须显示的申明它们遵循了这个协议。</p></blockquote><h2 id="协议类型的集合"><a href="#协议类型的集合" class="headerlink" title="协议类型的集合"></a>协议类型的集合</h2><p>协议可以用作诸如数组或字典之类的集合类型的元素类型，如 将协议作为类型 中所述。这个 例子创建了一个 TextRepresentable 数组</p><h2 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h2><p>协议可以 继承 一个或多个协议，并且可以在其继承的协议的基础上添加更多的要求。协议继 承的语法类似于类继承的语法，但是协议继承支持同时继承多个协议，并用逗号隔开</p><h2 id="类专属协议"><a href="#类专属协议" class="headerlink" title="类专属协议"></a>类专属协议</h2><p>你可以通过将 AnyObject 协议添加到协议的继承列表，来将协议限定为仅类类型(而不是结构体或枚举)可用。</p><blockquote><p>注意： 当协议的要求为，遵循该协议的类型必须符合引用语义而不是值语义时，请使用类专属 协议。</p></blockquote><h2 id="协议组合"><a href="#协议组合" class="headerlink" title="协议组合"></a>协议组合</h2><p>要求类型可以同时遵循多个协议是很有用的。您可以使用 协议组合 将多个协议组合到单个需 求中。协议组合的行为就像你定义了一个临时本地协议，该协议具有组合中所有协议的要求。协议组合不定义任何新的协议类型。</p><p>协议组合使用 SomeProtocol &amp; AnotherProtocol 的形式。你可以根据需要列出尽可 能多的协议，用&amp;符号( &amp; )分隔它们。除了协议列表之外，协议组合还可以包含一个类 类型，你可以使用它来指定继承的父类。</p><h2 id="协议遵循的检查"><a href="#协议遵循的检查" class="headerlink" title="协议遵循的检查"></a>协议遵循的检查</h2><p>你可以使用 类型转换 中描述的 is 和 as 运算符来检查协议遵循，和转换成特定协 议。检查和转换协议与检查和转换类型的语法相同:</p><ol><li>如果实例遵循协议，则 is 运算符返回 true ，如果不遵循则返回 false 。</li><li>向下转换运算符的 as? 返回协议类型的可选值，如果实例不遵循该协议，则该值 为 nil 。</li><li>向下转换运算符的 as! 强制向下转换为协议类型，如果向下转换不成功则触发运 行时错误。</li></ol><h2 id="可选协议要求"><a href="#可选协议要求" class="headerlink" title="可选协议要求"></a>可选协议要求</h2><p>你可以为协议定义 可选要求，这些要求不强制遵循者实现。可选要求以 optional 修饰符为前缀，作为协议定义的一部分。</p><p>可选要求允许你的代码与 Objective-C 交互。协议和可选要求都必须用 @objc 属性标记。请注意， @objc 协议只能由继承自 Objective-C 类或其他 @objc 类的类遵循。结构体或枚举不能遵循它们。</p><p>在可选要求中使用方法或属性时，其类型将自动变为可选。例如，类型 (Int) -&gt;String 的方法变为 ((Int) -&gt; String)? 。请注意，整个函数类型变成了可选项， 而不是方法的返回值。</p><p>考虑到遵循协议的类型可能未实现要求，你应该使用可选链来调用可选协议要求。你通过在 调用方法名称后面写一个问号来检查可选方法的实现，例如 someOptionalMethod? (someArgument) 。</p><h2 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h2><p>通过在协议上创建扩展，所有遵循协议的类型都将自动获得此方法实现，而无需任何其他修改。</p><p>协议扩展可以为符合的类型添加实现，但无法扩展协议本身或是继承其他协议。 协议继承始终在协议自身的声明中指定。</p><h3 id="提供默认实现"><a href="#提供默认实现" class="headerlink" title="提供默认实现"></a>提供默认实现</h3><p>你可以使用协议扩展来为任何方法或计算属性提供默认实现。如果一个符合的类型本身就实现了协议中要求的方法或属性，那么这个实现会代替协议扩展中的实现。</p><p>注意：由协议扩展提供默认实现的协议要求和可选协议要求不同。尽管符合的类型不需要提供任何一种协议的实现，有默认实现的要求在被调用时不需要可选链。</p><h3 id="为协议扩展添加条件约束"><a href="#为协议扩展添加条件约束" class="headerlink" title="为协议扩展添加条件约束"></a>为协议扩展添加条件约束</h3><p>当我们定义一个协议扩展时，我们可以通过 where 关键字在被扩展的协议名称后指定一个 任意类型在遵循协议前必须满足的约束条件。</p><blockquote><p>注意：如果一个类型遵循了多个具有同名方法或属性的扩展协议，那么 Swift 会优先调用条件 约束较多一方的属性或方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Protocol Syntax&lt;/li&gt;
&lt;li&gt;Property Requirements&lt;/li&gt;
&lt;li&gt;Method Requirements&lt;/li&gt;
&lt;li&gt;Mutating Method Requirements&lt;/li&gt;
&lt;li&gt;Initializer Requirements&lt;/li&gt;
&lt;li&gt;Protocols as Types&lt;/li&gt;
&lt;li&gt;Delegation&lt;/li&gt;
&lt;li&gt;Adding Protocol Conformance with an Extension&lt;/li&gt;
&lt;li&gt;Collections of Protocol Types&lt;/li&gt;
&lt;li&gt;Protocol Inheritance&lt;/li&gt;
&lt;li&gt;Class-Only Protocols&lt;/li&gt;
&lt;li&gt;Protocol Composition&lt;/li&gt;
&lt;li&gt;Checking for Protocol Conformance&lt;/li&gt;
&lt;li&gt;Optional Protocol Requirements&lt;/li&gt;
&lt;li&gt;Protocol Extensions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="协议" scheme="http://yoursite.com/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>20. 嵌套类型</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/20__%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/20__嵌套类型/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T03:58:49.024Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Nested Types in Action</li><li>Referring to Nested Types</li></ol><a id="more"></a><p> 通常我们会创建枚举来支持特定的类或结构体的功能。类似地，为了可以方便地定义在更复杂类型上下文中使用的实用 工具类和结构，Swift 允许你定义 嵌套类型 ，从而实现在枚举、类和结构体中的定义嵌套类型。</p><p>如果要将一个类型嵌套在另一个类型中，只需在支持类型的大括号内定义嵌套类型即可。类型支持多层嵌套。</p><h2 id="嵌套类型的使用"><a href="#嵌套类型的使用" class="headerlink" title="嵌套类型的使用"></a>嵌套类型的使用</h2><h2 id="引⽤嵌套类型"><a href="#引⽤嵌套类型" class="headerlink" title="引⽤嵌套类型"></a>引⽤嵌套类型</h2><p>要在其定义上下文之外使用嵌套类型，需要在其名称前面加上嵌套在其中的类型的名称。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Nested Types in Action&lt;/li&gt;
&lt;li&gt;Referring to Nested Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="嵌套类型" scheme="http://yoursite.com/tags/%E5%B5%8C%E5%A5%97%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>21. 扩展</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/21__%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/21__扩展/</id>
    <published>2019-01-29T02:07:12.000Z</published>
    <updated>2019-01-29T07:07:06.729Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Extension Syntax</li><li>Computed Properties</li><li>Initializers</li><li>Methods</li><li>Subscripts</li><li>Nested Types</li></ol><a id="more"></a><p> Extensions :为已存在的类、结构体、枚举或者协议类型增添了一个新的功能。这项功 能包括在对你无法访问源码的情况下进行类的扩展的能力(例如“追溯模型”)。Swift 中的Extensions 与 Objective-C 中的 Categories 类似。(但与 Objective-C 中 Categories 有所不同的是，Swift 中的 Extensions 并没有一个具体的命名)<br>在 Swift 中 Extensions 可以做到:</p><ol><li>添加计算实例属性和计算类型属性</li><li>定义实例方法和类方法</li><li>提供新的初始化方法</li><li>定义下标脚本</li><li>定义和使用新的嵌套类型</li><li>使现有类型符合协议</li></ol><blockquote><p>注意: Extensions 可以为类增添一个新的功能，但却不能重写之前已经存在的功能。</p></blockquote><h2 id="Extension-语法"><a href="#Extension-语法" class="headerlink" title="Extension 语法"></a>Extension 语法</h2><p>使用关键字 Extension 来声明一个扩展:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SomeType</span> </span>&#123;</span><br><span class="line"><span class="comment">//编写 SomeType 的新功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你想为一个已经存在的类型的进行扩展并添加一个新的功能，那么这个功能将会被 该类所有的实例使用，即使在这个 Extension 被定义之前。</p></blockquote><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>Extensions 可以将计算实例属性与计算类型属性添加到现有类中去。</p><blockquote><p>注意：Extensions 可以添加一个新的属性，但是他们不能存储这些属性，也不能为现有类 型添加属性观察者。</p></blockquote><h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><p>Extensions 可以给类添加一个便利初始化器，但它们不能够提供指定初始化器、反初始化器。指定初始化器和反初始化器都必须由原始类去提供。</p><blockquote><p>注意： 如果你声明了一个带有扩展的新的初始化器，那么你仍然有责任去确认在这个初始化器完成之后，每一个实例都已经被初始化完成。</p></blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>扩展可以向已经存在的类型添加实例方法或类方法。</p><h3 id="可变实例方法"><a href="#可变实例方法" class="headerlink" title="可变实例方法"></a>可变实例方法</h3><p> 我们可以通过在扩展中添加实例方法来实现修改变量。</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p> Extensions 能够对已经存在的类型添加下标。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>我们可以通过扩展 Extensions 来向任何已经存在的类、结构体或枚举添加新的嵌套类 型。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Extension Syntax&lt;/li&gt;
&lt;li&gt;Computed Properties&lt;/li&gt;
&lt;li&gt;Initializers&lt;/li&gt;
&lt;li&gt;Methods&lt;/li&gt;
&lt;li&gt;Subscripts&lt;/li&gt;
&lt;li&gt;Nested Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="扩展" scheme="http://yoursite.com/tags/%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>16. 析构过程</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/16__%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/16__析构过程/</id>
    <published>2019-01-28T02:07:12.000Z</published>
    <updated>2019-01-28T08:50:32.765Z</updated>
    
    <content type="html"><![CDATA[<ol><li>ow Deinitialization Works</li><li>Deinitializers in Action</li></ol><a id="more"></a><p>析构器 会在类的实例销毁之前被立即调用。使用deinit关键字来表示析构器，类似于使用init关键字标示构造器，析构器仅适用于class类型。</p><h2 id="析构器是如何运作的"><a href="#析构器是如何运作的" class="headerlink" title="析构器是如何运作的"></a>析构器是如何运作的</h2><p>在类的定义中, 类最多只能有一个析构器。 析构器不接受任何参数，并且没有括号。</p><p>在实例销毁之前，会自动调用析构器。你不能自己调用析构器。父类的析构器由其子类继承，父类析构器会在子类析构器实现的末尾自动调用。即使子类不提供自己的析构器，父类析构器也会被调用。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;ow Deinitialization Works&lt;/li&gt;
&lt;li&gt;Deinitializers in Action&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>15. 构造过程</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/15__%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/15__构造过程/</id>
    <published>2019-01-28T02:07:12.000Z</published>
    <updated>2019-01-28T08:39:18.573Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Setting Initial Values for Stored Properties</li><li>Customizing Initialization</li><li>Default Initializers</li><li>Initializer Delegation for Value Types</li><li>Class Inheritance and Initialization</li><li>Failable Initializers</li><li>Required Initializers</li><li>Setting a Default Property Value with a Closure or Function</li></ol><a id="more"></a><p>Swift 的构造器不用返回值。它们主要的作用就是确保在第一次使用前某类型 的实例都能正确的初始化。</p><h2 id="设置存储属性的初始值"><a href="#设置存储属性的初始值" class="headerlink" title="设置存储属性的初始值"></a>设置存储属性的初始值</h2><p>类和结构体在其创建实例时 必须 为它们所有的存储属性设置适当的初始值。存储属性不能处 于未知状态。<br>你可以在构造器中为存储属性设置初始值，或是作为定义属性时的一部分设置其默认值。</p><blockquote><p>注意：当你为存储属性设置默认值时，或是在构造器中设置其初始值，属性值是直接设置的，并不会调用任何属性观察器。</p></blockquote><h2 id="构造器器"><a href="#构造器器" class="headerlink" title="构造器器"></a>构造器器</h2><p>构造器在创建某类实例时调用。其最简单的形式用 init 数的实例方法</p><h2 id="默认属性值"><a href="#默认属性值" class="headerlink" title="默认属性值"></a>默认属性值</h2><p>你可以在构造器中设置一个存储属性的初始值。或指定一个 <code>默认属性值</code> 作为声明 属性的一部分。指定默认属性值你可以通过在属性定义时为其赋一个初始值。</p><blockquote><p>注意：如果一个属性总是相同的初始值，与其在构造器中设置一个值不如提供一个默认值。其效果是相同的，但是默认值与属性构造器的联系更紧密一些。它使构造器更简短，更清晰，并且可以通过默认值推断属性类型。默认值也使你更易使用默认构造器和构造器继承，</p></blockquote><h2 id="自定义构造过程"><a href="#自定义构造过程" class="headerlink" title="自定义构造过程"></a>自定义构造过程</h2><p>参数名：如果你在构造 器中没有为 每一个 参数提供外部参数名，Swift 就会自动为其提供外部参数名。</p><blockquote><p>注意如果不使用外部参数名是无法调用这些构造器的。如果在构造器中定义了外部参数名就必须使用，忽略它将会触发编译错误。</p></blockquote><h2 id="可选属性类型"><a href="#可选属性类型" class="headerlink" title="可选属性类型"></a>可选属性类型</h2><p>可选类型的属性会自动被初始化为 nil ，表示属性在构造过程期间故意设置为『没有 值』。</p><h2 id="在构造过程期间给常量赋值"><a href="#在构造过程期间给常量赋值" class="headerlink" title="在构造过程期间给常量赋值"></a>在构造过程期间给常量赋值</h2><p>构造过程期间你可以在任何时间点给常量属性赋值，只要构造完成时设置了确定值即可。一旦常量属性被赋值，就不能再次修改。</p><blockquote><p>注意：对于类的实例来说，常量属性只能在定义常量属性类的构造器中修改。不能在派生类中修改。</p></blockquote><h2 id="默认构造器"><a href="#默认构造器" class="headerlink" title="默认构造器"></a>默认构造器</h2><p>Swift 为属性均有默认值和没有构造器的结构体或类提供了一个 默认构造器 。默认构造器创 建了一个所有属性都有默认值的新实例。</p><h2 id="结构体类型的成员构造器器"><a href="#结构体类型的成员构造器器" class="headerlink" title="结构体类型的成员构造器器"></a>结构体类型的成员构造器器</h2><p>如果结构体没有任何自定义构造器，那么结构体类型会自动接收一个 成员构造器。不同于默 认构造器，即使结构体的存储属性没有默认值，它也会接收成员构造器。</p><h2 id="值类型的构造器器代理"><a href="#值类型的构造器器代理" class="headerlink" title="值类型的构造器器代理"></a>值类型的构造器器代理</h2><p>构造器可以调用其他构造器来执行实例的部分构造过程。这个过程称之为 构造器代理 ，以避免多个构造器之间的<strong>重复代码</strong>。</p><p>对于值类型，在自定义构造器中使用 self.init 来引用同一类型中的其他构造器。<strong>你只能在构造器中调用 self.init </strong>。</p><p>如果你为值类型定义了一个自定义构造器，你将无法再访问该类型的默认构造器( 如果是结 构体就是成员构造器 )</p><blockquote><p>注意：如果你想让你的自定义类型可以使用默认构造器，成员构造器，自定义构造器来进行初始化，就把自定义构造器写在扩展中，而不是作为值类型原始实现的一部分。</p></blockquote><h2 id="类的继承和构造过程"><a href="#类的继承和构造过程" class="headerlink" title="类的继承和构造过程"></a>类的继承和构造过程</h2><p>类的所有存储属性 — 包括任何从父类继承而来的属性 — 必须 在构造过程期间赋值。<br>Swift 给类类型定义了两种构造器以确保所有存储属性都能接收到初始值。它们分别是指定构造器和便利构造器。</p><h2 id="指定构造器和便利构造器"><a href="#指定构造器和便利构造器" class="headerlink" title="指定构造器和便利构造器"></a>指定构造器和便利构造器</h2><p>指定构造器是类的主要构造器。一个指定构造器初始化该类引入的所有属性，并调用合适的父类构造器以继续父类链上的构造过程。</p><p>便利构造器有着相同风格的写法，但是在 init 关键字之前需要放置 convenience 修饰符，并使用空格来分隔。</p><h2 id="类的构造代理"><a href="#类的构造代理" class="headerlink" title="类的构造代理"></a>类的构造代理</h2><p>为了简化指定构造器和便利构造器之间的关系。Swift 对构造器之间的代理采用了如下三条规则：</p><ol><li>指定构造器必须调用其直系父类的指定构造器。</li><li>便利构造器必须调用 同一 类中的其他构造器。</li><li>便利构造器最后必须调用指定构造器。</li></ol><p>简单的记忆方法:</p><ol><li>指定构造器必须 <strong>向上</strong> 代理。 </li><li>便利构造器必须 <strong>横向</strong> 代理。</li></ol><h2 id="两段式构造器过程"><a href="#两段式构造器过程" class="headerlink" title="两段式构造器过程"></a>两段式构造器过程</h2><p>Swift 中类的构造过程是两段式处理。第一阶段，为类引入的每个存储属性赋一个初始值。一旦确定了所有存储属性的初始状态，第二阶段开始，在新的实例被认为可以使用前，每个类都有机会进一步定制其存储属性。</p><p>Swift 的编译器执行了四个有帮助的安全检查以确保两段式构造过程无误完成: </p><ol><li>安全检查 1：指定构造器必须确保其类引入的所有属性在向上代理父类构造器之前完成初始化。如上所述，一个对象的内存只在其所有存储属性初始状态已知时才被认为完全初始化。为了符合此规则，指定构造器必须确保其所属类拥有的属性在向上代理前完成初始化。</li><li>安全检查 2：指定构造器必须在继承属性赋值前向上代理父类构造器，否则，便利构造器赋予的新值将被父类构造过程的一部分重写。</li><li>安全检查 3：便利构造器必须在 任何 属性(包括同一类中定义的属性)赋值前代理另一个构造器。否则便利构造器赋予的新值将被其所属类的指定构造器重写。</li><li>安全检查 4 构造器在第一阶段构造过程完成前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。</li></ol><p>以下是基于以上四个安全检查的两段式构造过程的流程:</p><p>阶段 1：</p><ol><li>在类中调用指定或便利构造器。</li><li>对一个新实例分配内存，但内存没还没有初始化。 指定构造器确认其所属类的所有存储属性都有值。现在那些存储属性的内存初始化完成。</li><li>指定构造器移交给父类构造器以为其存储属性执行相同的任务。 </li><li>这个过程沿着类的继承链持续向上，直到到达继承链的顶端。</li><li>一旦到达链的顶端，并且链中最后的类确保其所有存储属性都有值，则认为实例的内 存已经完全初始化，至此阶段 1 完成。</li></ol><p>阶段 2：</p><ol><li>从链顶端往下，链中每个指定构造器都可以选择进一步定制实例，构造器现在可以访 问 self 并修改它的属性，调用实例方法，等等。</li><li>最终，在链中的任何便利构造器也都可以选择定制实例以及使用 self 。</li></ol><h2 id="构造器的继承和重写"><a href="#构造器的继承和重写" class="headerlink" title="构造器的继承和重写"></a>构造器的继承和重写</h2><p>与 Objective-C 的派生类不同，Swift 的派生类默认不继承其父类构造器。Swift 这种机制防止了更定制化的派生类继承父类的简单构造器，也防止将简单构造器用于创建不完全初始化或是错误初始化的派生类实例。</p><p>当你在写一个与父类 指定 构造器相匹配的派生类构造器时，你是在有效的重写指定构造器。 因此，你必须在派生类构造器的定义前写上修饰符 override 。即使你重写的是一个自动提供的默认构造器，也要写上 override 。</p><p>相反的，如果你写一个与父类 便利 构造器相匹配的派生类构造器，根据 类的构造器代理 规 则，派生类是不能直接调用父类便利构造器的。因此，你的派生类(严格来说)没有重写父 类构造器。所以，在提供与父类便利构造器相匹配的实现时，无需编写 修饰<br>符 override </p><p>默认构造器(在可用时)总是类中的指定构造器。</p><p>派生类可在构造过程期间可修改变量继承属性，但不能修改常量继承属性。</p><h2 id="自动构造器的继承"><a href="#自动构造器的继承" class="headerlink" title="自动构造器的继承"></a>自动构造器的继承</h2><p>如上所述，派生类默认不继承其父类构造器。然而，如果满足某些特定条件，父类构造器 是 可以被自动继承的。实际上，这意味着很多常见场景中你不需要重写构造器，并且可以安全的以最小代价继承父类构造器。<br>假设你为派生类引入的所有属性提供了默认值，请应用以下两条规则以达到自动继承的目的:</p><ol><li>规则 1:如果你的派生类没有定义任何指定构造器，它会自动继承其父类的所有指定构造器。</li><li>规则 2:如果你的派生类为其父类的 所有 指定构造器都提供了实现 — 无论是按照规则 1 继承而来， 或是定义时提供了自定义实现 — 它都会自动继承父类的所有便利构造器。甚至在派生类进一步添加便利构造器时，这些规则仍然适用。</li></ol><h2 id="可失败构造器"><a href="#可失败构造器" class="headerlink" title="可失败构造器"></a>可失败构造器</h2><p>为了应对可能失败的构造过程，你可以为类，结构体，或是枚举定义一个或是多个可失败构 造器。编写可失败构造器的语法就是在 init 关键字后面添加问号( init? )。</p><blockquote><p>注意:你不能使用相同的参数类型或参数名定义一个可失败构造器后又定义一个非失败构造器。</p></blockquote><p>可失败构造器会创建一个关联值类型是自身构造类型的 可选 类型。在可失败构造器中编 写 return nil 以表示可以在任何情况下触发失败。</p><p>注意:严格来说，构造器没有返回值。它们的作用是确保构造过程结束时 self 可以完全并正确的初始化。虽然你写 return nil 是用于触发构造器失败，但表示构造成功是不会使用 return 关键字的。</p><h2 id="枚举的可失败构造器"><a href="#枚举的可失败构造器" class="headerlink" title="枚举的可失败构造器"></a>枚举的可失败构造器</h2><h2 id="带有原始值枚举的可失败构造器"><a href="#带有原始值枚举的可失败构造器" class="headerlink" title="带有原始值枚举的可失败构造器"></a>带有原始值枚举的可失败构造器</h2><h2 id="构造失败的传递"><a href="#构造失败的传递" class="headerlink" title="构造失败的传递"></a>构造失败的传递</h2><p>类、结构体或枚举的可失败构造器可以横向代理同一类型中的其他可失败构造器。类似的，派生类的可失败构造器可以向上代理其父类的可失败构造器。</p><blockquote><p>注意：一个可失败构造可以代理一个非失败构造器。如果你需要添加一个可能失败的状态到现有构造过程，请使用这个办法，否则将会构造失败。</p></blockquote><h2 id="重写可失败构造器"><a href="#重写可失败构造器" class="headerlink" title="重写可失败构造器"></a>重写可失败构造器</h2><p>你可以在派生来中重写父类的可失败构造器，就像其他构造器那样。或是你可以用派生类的 非失败 构造器重写父类的可失败构造器。这允许你定义一个不会构造失败的派生类，即使父 类的构造过程允许失败。</p><p>注意如果你使用非失败的派生类构造器重写了可失败的父类构造器，向上代理父类构造器的 唯一的方法就是强制解包(force-unwrap)可失败父类构造器的结果。</p><p>你可以使用非失败构造器重写可失败构造器，但是反过来不行。</p><h2 id="init-可失败构造器"><a href="#init-可失败构造器" class="headerlink" title="init! 可失败构造器"></a>init! 可失败构造器</h2><p>通常使用在关键字 init 后面放置问号( init? )的方式来定义一个可失败构造器， 用于创建一个适当的可选类型实例。你也可以定义一个可失败构造器，将其用于创建一个适 当的隐式解包可选类型的实例。为了定义这个可失败构造器，在关键字 init 后面用叹号 来替代问号( init! )。</p><h2 id="必要构造器"><a href="#必要构造器" class="headerlink" title="必要构造器"></a>必要构造器</h2><p>在类构造器的定义前写修饰符 required 以指明该类的每个派生类必须实现此构造器。</p><p>在每个派生类实现必要构造器时也必须在构造器前面写修饰符 required ，以指明构造 器要求应用于继承链中所有派生类。重写一个必要指定构造器时无需写修饰符 override 。</p><h2 id="使用闭包或函数设置默认属性值"><a href="#使用闭包或函数设置默认属性值" class="headerlink" title="使用闭包或函数设置默认属性值"></a>使用闭包或函数设置默认属性值</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</span><br><span class="line"><span class="keyword">let</span> someProperty: SomeType = &#123;</span><br><span class="line"><span class="comment">// 在闭包中创建⼀一个带有默认值的 someProperty // someValue 的类型必须是 SomeType</span></span><br><span class="line"><span class="keyword">return</span> someValue</span><br><span class="line">&#125;() </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意那个闭包的结束是在大括号后面尾随一对空括号。这告诉 Swift 立即执行闭包。如果你 忽略了这对括号，则为试图将闭包本身赋值给属性，而不是闭包的返回值。</p><p>注意：如果你使用闭包初始化属性，记住在闭包执行时其他实例还未初始化。这意味着无法在闭包中访问其他属性值，即使那些属性有默认值。你也不能隐式使用 self 属性，或 是调用实例方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Setting Initial Values for Stored Properties&lt;/li&gt;
&lt;li&gt;Customizing Initialization&lt;/li&gt;
&lt;li&gt;Default Initializers&lt;/li&gt;
&lt;li&gt;Initializer Delegation for Value Types&lt;/li&gt;
&lt;li&gt;Class Inheritance and Initialization&lt;/li&gt;
&lt;li&gt;Failable Initializers&lt;/li&gt;
&lt;li&gt;Required Initializers&lt;/li&gt;
&lt;li&gt;Setting a Default Property Value with a Closure or Function&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="构造过程" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E8%BF%87%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>17. 可选链</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/17__%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/17__可选链/</id>
    <published>2019-01-28T02:07:12.000Z</published>
    <updated>2019-01-28T10:09:02.556Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Optional Chaining as an Alternative to Forced Unwrapping</li><li>Defining Model Classes for Optional Chaining</li><li>Accessing Properties Through Optional Chaining</li><li>Calling Methods Through Optional Chaining</li><li>Accessing Subscripts Through Optional Chaining</li><li>Linking Multiple Levels of Chaining</li><li>Chaining on Methods with Optional Return Values</li></ol><a id="more"></a><p>可选链 是在当前可能为 nil的可选值上查询和调用属性、方法、下标的过程。如果可选值有值，则属性、方法或下标调用成功;如果可选值为 nil ，则属性、方法或下标调用 返回 nil 。多个查询可以链接在一起，如果链中的任何一个节点为 nil ，整个链会 返回失败。</p><h2 id="可选链作为强制展开的代替品"><a href="#可选链作为强制展开的代替品" class="headerlink" title="可选链作为强制展开的代替品"></a>可选链作为强制展开的代替品</h2><p>为了反映可选链可以对 nil 值进行调用这一事实，可选链调用的结果总是一个可选值， 即使正在查询的属性、方法或下标返回一个不可选值。</p><h2 id="为可选链定义模型类"><a href="#为可选链定义模型类" class="headerlink" title="为可选链定义模型类"></a>为可选链定义模型类</h2><p>你可以使用可选链来调用超过一级深度的属性、方法和下标。 这使你可以深入查看相互关联 类型的复杂模型中的子属性，并检查是否可以访问这些子属性上的属性、方法和下标。</p><h2 id="通过可选链访问属性"><a href="#通过可选链访问属性" class="headerlink" title="通过可选链访问属性"></a>通过可选链访问属性</h2><p>赋值是可选链的一部分，也就意味着 = 操作符的右操作数不会被计算。</p><p>任何通过可选链给属性赋值的尝试都会返回一个 Void? 类型的值。这样你可以和 nil 比较来检查赋值是否成功:</p><h2 id="通过可选链调⽤方法"><a href="#通过可选链调⽤方法" class="headerlink" title="通过可选链调⽤方法"></a>通过可选链调⽤方法</h2><p>你可以使用可选链来调用一个可选值的方法，以及检查调用是否成功。即使那个方法没有返回值你依然可以这样做。</p><h2 id="通过可选链访问下标"><a href="#通过可选链访问下标" class="headerlink" title="通过可选链访问下标"></a>通过可选链访问下标</h2><h2 id="访问可选类型的下标"><a href="#访问可选类型的下标" class="headerlink" title="访问可选类型的下标"></a>访问可选类型的下标</h2><p>如果下标返回一个可选类型的值，例如 Swift 中 Dictionary 的键下标，在下标的右括 号 后面 放置一个问号来链接其可选的返回值</p><h2 id="多级链表关联"><a href="#多级链表关联" class="headerlink" title="多级链表关联"></a>多级链表关联</h2><ol><li>如果要检索的类型不是可选的，通过可选链，它将成为可选的。</li><li>如果您要检索的类型已经是可选的，那么它将保持原状。</li></ol><h2 id="在方法的可选返回值上进行可选链式调用"><a href="#在方法的可选返回值上进行可选链式调用" class="headerlink" title="在方法的可选返回值上进行可选链式调用"></a>在方法的可选返回值上进行可选链式调用</h2><p>如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Optional Chaining as an Alternative to Forced Unwrapping&lt;/li&gt;
&lt;li&gt;Defining Model Classes for Optional Chaining&lt;/li&gt;
&lt;li&gt;Accessing Properties Through Optional Chaining&lt;/li&gt;
&lt;li&gt;Calling Methods Through Optional Chaining&lt;/li&gt;
&lt;li&gt;Accessing Subscripts Through Optional Chaining&lt;/li&gt;
&lt;li&gt;Linking Multiple Levels of Chaining&lt;/li&gt;
&lt;li&gt;Chaining on Methods with Optional Return Values&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="可选链" scheme="http://yoursite.com/tags/%E5%8F%AF%E9%80%89%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>18. 错误处理</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/18__%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/18__错误处理/</id>
    <published>2019-01-28T02:07:12.000Z</published>
    <updated>2019-01-29T03:19:27.919Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Representing and Throwing Errors</li><li>Handling Errors</li><li>Specifying Cleanup Actions</li></ol><a id="more"></a><h2 id="表示和抛出错误"><a href="#表示和抛出错误" class="headerlink" title="表示和抛出错误"></a>表示和抛出错误</h2><p>在 Swift 中，错误是遵循 Error 协议的值。Error 是一个空协议，表明遵循该协议的类型 可以用于错误处理。</p><h2 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h2><p>在 Swift 中有四种处理错误的方式：</p><ol><li>您可以将错误从函数传递给调用该函数的代码</li><li>可以使 用 do - catch 语句处理错误，</li><li>可以通过可选值处理错误</li><li>通过断言保证错误不会 发生</li></ol><h3 id="使⽤抛出函数传递错误"><a href="#使⽤抛出函数传递错误" class="headerlink" title="使⽤抛出函数传递错误"></a>使⽤抛出函数传递错误</h3><p>为了让函数、方法或者初始化程序可以抛出错误，您需要在函数声明的参数后面添写 throws 关键字。标有 throws 的函数称为抛出函数。如果函数指定了返回类型，则在返回箭头 ( -&gt; ) 之前添写 throws 关键字。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canThrowErrors</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:只有抛出函数才能传递错误。任何在非抛出函数中抛出错误都必须在函数内部进行处理。</p></blockquote><h3 id="使⽤-Do-Catch-处理错误"><a href="#使⽤-Do-Catch-处理错误" class="headerlink" title="使⽤ Do-Catch 处理错误"></a>使⽤ Do-Catch 处理错误</h3><p>在可抛出函数中，封闭的do - catch 子句或调用者必须处理错误。 如果错误传播到顶级作用域而未被处理， 则会出现运行时错误。</p><h3 id="将错误转换为可选值"><a href="#将错误转换为可选值" class="headerlink" title="将错误转换为可选值"></a>将错误转换为可选值</h3><p>你可以使用 try? 将错误转换为可选值来处理错误。 如果在执行 try? 表达式时抛出 错误，表达式的值将为 nil 。</p><h3 id="禁⽤错误传播"><a href="#禁⽤错误传播" class="headerlink" title="禁⽤错误传播"></a>禁⽤错误传播</h3><p>有时你知道可抛出函数或方法实际上不会在运行时抛出错误。 在这种情况下，你可以在表达 式之前添加 try! 来禁用错误传播，并把调用过程包装在运行时断言中，从而禁止其抛出 错误。 而如果实际运行时抛出了错误，你将收到运行时错误。</p><h2 id="指定清理操作"><a href="#指定清理操作" class="headerlink" title="指定清理操作"></a>指定清理操作</h2><p>当代码执行到即将离开当前代码块之前，可以使用 defer 语句来执行一组语句。无论是 因为错误而离开 — 抑或是因为诸如 return 或 break 等语句而离开， defer 语句都可以让你执行一些必要的清理。例如，你可以使用 defer 语句来关闭文件描述符 或释放手动分配的内存。</p><p>defer 语句会推迟执行，直到退出当前作用域。该语句由 defer 关键字和稍后要执 行的语句组成。延迟语句可能不包含任何将控制转移出语句的代码，例如 break 或 return 语句，或抛出错误。延迟操作的执行顺序与它们在源代码中编写的顺序相反。也 就是说，第一个 defer 语句中的代码最后一个执行，第二个 defer 语句中的代码倒 数第二个执行，依此类推。源代码中的最后一个 defer 语句最先执行。</p><blockquote><p>注意： 即使没有涉及错误处理代码，也可以使用 defer 语句。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Representing and Throwing Errors&lt;/li&gt;
&lt;li&gt;Handling Errors&lt;/li&gt;
&lt;li&gt;Specifying Cleanup Actions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="错误处理" scheme="http://yoursite.com/tags/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>14. 继承</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/14__%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/14__继承/</id>
    <published>2019-01-28T01:07:12.000Z</published>
    <updated>2019-01-28T02:47:13.962Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Subscript Syntax</li><li>Subscript Usage</li><li>Subscript Options</li></ol><a id="more"></a><p>一个类可以 继承 另一个类的方法，属性以及其他特性。当一个类继承另一个类时，继承类称 为 子类，被继承类称为 父类。在 Swift 中，继承是类类型区别于其他类型的基本特性。</p><p>Swift 中的子类可以调用和访问父类的方法，属性和下标，还可以重写这些方法，属性和下标 来优化或修改它们的行为。Swift 会通过检查重写的定义和父类的定义是否匹配来帮助确保重 写是正确的。</p><p>子类还可以给继承的属性添加属性观察器，以便在属性值发生变化时得到通知。属性观察器<br>可以被添加到任何属性，不管它原始定义是储存属性还是计算属性。</p><h2 id="定义一个基类"><a href="#定义一个基类" class="headerlink" title="定义一个基类"></a>定义一个基类</h2><p>Swift 中的类并不继承自一个统一的类。定义类时如果不指定父类那么该类自动成为基类。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>子类化 是在已有类的基础上创建新类的行为。</p><h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>一个子类可以对实例方法、类方法、实例属性、类属性和下标进行自定义实现，如果没有自定义，则会从超类继承，这就是所谓的重写。</p><p>重写从父类继承的特性，你需要在定义重写时添加 override 前缀。这表明你打算重写 一个特性并且没有使用错误的匹配定义。意外的重写会导致不可预料的行为，且任何没有使 用 override 关键词修饰的重写声明在编译代码时会被标记为错误。<br>override 关键词也提醒 Swift 编译器去检查你重写的这个类的超类(或它的某个父类) 是否有匹配重写版本的声明。这个检查确保你的重写定义是正确无误的。</p><h2 id="访问⽗父类的⽅方法、属性和下标"><a href="#访问⽗父类的⽅方法、属性和下标" class="headerlink" title="访问⽗父类的⽅方法、属性和下标"></a>访问⽗父类的⽅方法、属性和下标</h2><p>当你在子类中重写方法、属性或下标时，有时把父类的实现作为重写的一部分是很有用的。<br>例如，你可以优化现有的实现，或将修改后的值存储在现有的继承变量中。<br>在适当的情况下，应该用 super 前缀访问父类的方法、属性或下标:</p><ol><li>一个名为 someMethod() 的重写方法可以在实现中通过 super.someMethod() 来调用父类的 someMethod() 方法。</li><li>一个名为 someProperty 的属性可以在重写 getter 或 setter 的实现中通过 super.someProperty 访问父类的 someProperty 属性。</li><li>一个 someIndex 的重写下标可以在重写下标的实现中通过 super[someIndex] 访问父类的相同下标。</li></ol><h2 id="重写属性的-Getters-和-Setters"><a href="#重写属性的-Getters-和-Setters" class="headerlink" title="重写属性的 Getters 和 Setters"></a>重写属性的 Getters 和 Setters</h2><p>无论继承的属性原来是存储属性还是计算属性，都可以提供自定义的 getter(如果 setter 适 用，也包括 setter)来重写任何继承属性。子类不知道继承的属性是存储属性还是计算属 性，子类只知道继承的属性具有特定的名称和类型。你必须始终声明要重写的属性的名称和 类型，以使编译器能够检查你重写的属性是否与具有相同名称和类型的父类属性匹配。<br>通过在子类属性中重写 getter 和 setter，可以将继承的只读属性重写为读写属性，但是，你不能将继承的读写属性重写为只读属性。</p><blockquote><p>注意如果你重写属性的 setter 就必须同时重写属性的 getter。如果你不想在重写 getter 中修 改继承属性的值，你可以简单地在 getter 中返回 super.someProperty ，其中someProperty 是你想要重写的属性名称。</p></blockquote><h2 id="重写属性观察者"><a href="#重写属性观察者" class="headerlink" title="重写属性观察者"></a>重写属性观察者</h2><p>你可以用“属性重写特性”给一个继承属性增加属性观察者。 无论这个属性的初始值是多少，当它的值改变时你将会收到通知。更多有关属性观察者的信息，参阅 属性观察者.</p><blockquote><p>注意：你不能给常量存储属性或只读属性增加属性观察者。 因为这些属性值不能被修改，所以它是不能提供 willSet 或 didSet 的重写实现。<br>当然，你不能为同一个属性同时提供 setter 重写和 didSet 观察者。 如果你想观察这个属性值的改变，并且你已经为这个属性提供了一个重写的 setter 方法，那么你能在这个自定义 setter 方法里观察到它任何值的改变。</p></blockquote><h2 id="防⽌止重写"><a href="#防⽌止重写" class="headerlink" title="防⽌止重写"></a>防⽌止重写</h2><p>你可以通过标记方法、属性或下标为 final 来防止它被重写。通过在方法、属性或下标前添加 关键字 final (比如 final var 、 final func 、 final class func 和final subscript )来完成此操作</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Subscript Syntax&lt;/li&gt;
&lt;li&gt;Subscript Usage&lt;/li&gt;
&lt;li&gt;Subscript Options&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="继承" scheme="http://yoursite.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>10. 类和结构体</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/10__%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/10__类和结构体/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-28T01:46:39.491Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Comparing Structures and Classes</li><li>Structures and Enumerations Are Value Types</li><li>Classes Are Reference Types</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/10__类和结构体/1.png" alt="1"></p><p><img src="/wiki/swift学习摘要/10__类和结构体/2.png" alt="2"></p><p><img src="/wiki/swift学习摘要/10__类和结构体/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Comparing Structures and Classes&lt;/li&gt;
&lt;li&gt;Structures and Enumerations Are Value Types&lt;/li&gt;
&lt;li&gt;Classes Are Reference Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="类和结构体" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>2. 基础</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/2__%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/2__基础/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-28T01:47:30.358Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Constants and Variables</li><li>Comments</li><li>Semicolons</li><li>Integers</li><li>Floating-Point Numbers</li><li>Type Safety and Type Inference</li><li>Numeric Literals</li><li>Numeric Type Conversion</li><li>Type Aliases</li><li>Booleans</li><li>Tuples</li><li>Optionals</li><li>Error Handling</li><li>Assertions and Preconditions</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/2__基础/1.png" alt="1"></p><p><img src="/wiki/swift学习摘要/2__基础/2.png" alt="2"></p><p><img src="/wiki/swift学习摘要/2__基础/3.png" alt="3"></p><p><img src="/wiki/swift学习摘要/2__基础/4.png" alt="4"></p><p><img src="/wiki/swift学习摘要/2__基础/5.png" alt="5"></p><p><img src="/wiki/swift学习摘要/2__基础/6.png" alt="6"></p><p><img src="/wiki/swift学习摘要/2__基础/7.png" alt="7"></p><p><img src="/wiki/swift学习摘要/2__基础/8.png" alt="8"></p><p><img src="/wiki/swift学习摘要/2__基础/9.png" alt="9"></p><p><img src="/wiki/swift学习摘要/2__基础/10.png" alt="10"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Constants and Variables&lt;/li&gt;
&lt;li&gt;Comments&lt;/li&gt;
&lt;li&gt;Semicolons&lt;/li&gt;
&lt;li&gt;Integers&lt;/li&gt;
&lt;li&gt;Floating-Point Numbers&lt;/li&gt;
&lt;li&gt;Type Safety and Type Inference&lt;/li&gt;
&lt;li&gt;Numeric Literals&lt;/li&gt;
&lt;li&gt;Numeric Type Conversion&lt;/li&gt;
&lt;li&gt;Type Aliases&lt;/li&gt;
&lt;li&gt;Booleans&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;Optionals&lt;/li&gt;
&lt;li&gt;Error Handling&lt;/li&gt;
&lt;li&gt;Assertions and Preconditions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>7. 函数</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/8__%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/8__闭包/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:51:29.972Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Closure Expressions</li><li>Trailing Closures</li><li>Capturing Values</li><li>Closures Are Reference Types</li><li>Escaping Closures</li><li>Autoclosures</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/8__闭包/1.jpeg" alt="1"></p><p><img src="/wiki/swift学习摘要/8__闭包/2.jpeg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Closure Expressions&lt;/li&gt;
&lt;li&gt;Trailing Closures&lt;/li&gt;
&lt;li&gt;Capturing Values&lt;/li&gt;
&lt;li&gt;Closures Are Reference Types&lt;/li&gt;
&lt;li&gt;Escaping Closures&lt;/li&gt;
&lt;li&gt;Autoclosures&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>7. 函数</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/7__%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/7__函数/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:50:58.540Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Defining and Calling Functions</li><li>Function Parameters and Return Values</li><li>Function Argument Labels and Parameter Names</li><li>Function Types</li><li>Nested Functions</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/7__函数/1.jpeg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Defining and Calling Functions&lt;/li&gt;
&lt;li&gt;Function Parameters and Return Values&lt;/li&gt;
&lt;li&gt;Function Argument Labels and Parameter Names&lt;/li&gt;
&lt;li&gt;Function Types&lt;/li&gt;
&lt;li&gt;Nested Functions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>1. 枚举</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/9__%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/9__枚举/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:52:37.023Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Enumeration Syntax</li><li>Matching Enumeration Values with a Switch Statement</li><li>Iterating over Enumeration Cases</li><li>Associated Values</li><li>Raw Values</li><li>Recursive Enumerations</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/9__枚举/1.jpeg" alt="1"></p><p><img src="/wiki/swift学习摘要/9__枚举/2.jpeg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Enumeration Syntax&lt;/li&gt;
&lt;li&gt;Matching Enumeration Values with a Switch Statement&lt;/li&gt;
&lt;li&gt;Iterating over Enumeration Cases&lt;/li&gt;
&lt;li&gt;Associated Values&lt;/li&gt;
&lt;li&gt;Raw Values&lt;/li&gt;
&lt;li&gt;Recursive Enumerations&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>13. 下标</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/13__%E4%B8%8B%E6%A0%87/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/13__下标/</id>
    <published>2019-01-18T04:07:12.000Z</published>
    <updated>2019-01-25T10:27:11.338Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Subscript Syntax</li><li>Subscript Usage</li><li>Subscript Options</li></ol><a id="more"></a><p>你可以为单个类型定义多个下标，并根据传递给下标的索引值的类型，选择要使用的相应下 标进行重载。 下标不限于单个维度，你可以定义具有多个输入参数的下标以满足你自定义类 型的需求。</p><h2 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h2><p>使用下标, 让你可以通过在实例名称后面的方括号中写入一个或多个值来查询类的实例。它们 的语法类似于实例方法和计算属性语法。使用 subscript 关键字定义下标，并且和实例 方法类似，可以指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或 只读。和计算属性类似, 读写是由 getter 和 setter 方法实现的</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: <span class="type">Int</span>) -&gt; <span class="keyword">Int</span> &#123;</span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line"><span class="comment">// 在这⾥里里返回⼀一个对应下标的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>(<span class="keyword">new</span><span class="type">Value</span>) &#123;</span><br><span class="line"><span class="comment">// 在这⾥里里执⾏行行对应的赋值操作</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与只读计算属性一样，你可以通过删除 get 关键字以及大括号来简化只读下标的声明</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">subscript</span><span class="params">(index: Int)</span></span> -&gt; Int &#123; </span><br><span class="line"><span class="comment">// 在这⾥里里返回⼀一个对应下标的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标用法"><a href="#下标用法" class="headerlink" title="下标用法"></a>下标用法</h2><p>下标通常被用来作为访问集合、列表或序列中的元素的快捷方式.</p><p>Swift 的 Dictionary 类型将其键值作为下标实现并返回一个可选类型</p><h2 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h2><p>下标可以设置任意数量的输入参数，这些输入参数也可以是任意类型。 同时，下标也可以返 回任何类型。 下标可以使用可变参数，但它们不能使用输入输出参数或是提供默认参数值。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Subscript Syntax&lt;/li&gt;
&lt;li&gt;Subscript Usage&lt;/li&gt;
&lt;li&gt;Subscript Options&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="下标" scheme="http://yoursite.com/tags/%E4%B8%8B%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>12. 方法</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/12__%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/12__方法/</id>
    <published>2019-01-18T04:07:12.000Z</published>
    <updated>2019-01-25T10:17:39.385Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Instance Methods 实例方法</li><li>Type Methods 类型方法</li></ol><a id="more"></a><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>self 属性： 类型的每个实例都有一个名为 self 的隐式属性，它与实例本身完全等效。你可以使用self 属性来调用自己的实例方法。</p><p>在实例例⽅方法中修改值类型： 结构体和枚举是值类型 。默认情况下，无法在其实例方法中修改值类型的属性。你可以通过在方法的 func 关键字前放置 mutating 关键字。</p><p>你不能在常量结构体类型上调用异变方法，因为它的属性不能更改，即使它们是变量属性。</p><p>在可变方法中给self赋值：可变方法能给隐性的self属性赋以一个全新的实例</p><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>为了明确一个方法是类型方法，你可以在这个方法 的 func 关键词前加上 static 关键词。在类中，也可以使用 class 关键词来声明一个类型方法。与 static 关键词不同的是，用 class 关键词声明的类型方法允许它的子类重写其父类对类型方法的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Instance Methods 实例方法&lt;/li&gt;
&lt;li&gt;Type Methods 类型方法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="方法" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>11. 属性</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/11__%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/11__属性/</id>
    <published>2019-01-18T03:07:12.000Z</published>
    <updated>2019-01-25T10:13:56.514Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Stored Properties 存储属性</li><li>Computed Properties 计算属性</li><li>Property Observers 属性观察器</li><li>Global and Local Variables</li><li>Type Properties 类型属性</li></ol><a id="more"></a><p>存储属性将常量和变量值存储为实例 的一部分，而计算属性则是通过计算得到一个值(而不是存储值)。计算属性适用于类、结 构体和枚举类型，而存储属性只适用于类和结构体类型。</p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>常量结构体实例的存储属性：当值类型的实例声明为常量时，其所有属性也都被标记为常量。如果将引用类型的实例声明为常量时，你仍可以修改该实例的变量属性。</p><p>延迟存储属性：第一次使用时才进行计算。lazy标识，你必须始终将延迟属性声明为变量(使用 var 关键字)，因为延迟属性的初始值可能在实例初始化完成之后，仍然没有被赋值。而常量属性必须在实例初始化完成 之前 就 获得一个值，因此不能声明为延迟。<font color="blue">lazy和let是天敌啊</font></p><p>存储属性和实例变量： swift属性没有相应的实例变量，并且属性的底层存储不能直接访问。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性之外，类、结构体和枚举还可以定义 计算属性。它们会提供了一个 getter 方法和一个可选的 setter 方法来间接读取和设置其他属性和 值。</p><p>只读计算属性：只有 getter 方法但没有 setter 方法的计算属性称为 只读计算属性 。</p><p>你必须使用 var 关键字来声明计算属性(包括只读计算属性)，这是因为它们的值 是不固定。 let 关键字仅用于常量属性，这种属性一旦被初始化以后，就不能再更 改它们的值。</p><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器会观察并对属性值的变化做出反应。每次设置属性值时都会调用属性观察器，即使新值与属性的当前值相同。</p><p>你可以将属性观察器添加到你定义的任何存储属性上，但延迟存储属性除外。你还可以通过在子类中重写属性来为任何继承的属性(无论是存储还是计算)添加属性观察器。你并不需 要为非重写的计算属性定义属性观察器，因为你可以在计算属性的 setter 方法中观察并响应其值的更改。</p><p>你可以选择在属性上定义一个或两个观察器:</p><ol><li>在存储值之前调用 willSet 。</li><li>存储新值后立即调用 didSet 。</li></ol><p>在调用父类初始化方法之后，在子类中给父类属性赋值时，将会调用父类属性的 willSet 和 didSet 观察器。如果在调用父类初始化方法之前，在子类中给父类属性赋值，则不会调用父类的观察器。</p><p>didSet 观察器不会为旧值提供自定义参数名称，而是使用默认名称 oldValue 。</p><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><p>上面描述的用于计算和观察属性的功能也可用于 全局变量 和 局部变量 。全局变量是指在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是指在函数、方法或闭包上下文中定义的变量。</p><p>全局常量和变量总是被延迟计算，与 延迟存储属性 类似。与延迟存储属性不同的是，全局常量和变量不需要使用 lazy 修饰符进行标记。 局部常量和变量永远不会被延迟计算。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>实例属性是属于特定类型的实例的属性。每次创建该类型的新实例时，它都有自己的一组属性值，与任何其他实例不同。</p><p>类型属性用于定义一个对某个类型的 所有 实例都可见的值</p><p>存储类型属性可以是变量或常量。计算类型属性始终是变量属性，与声明计算实例属性的方式相同。</p><p>与存储实例属性不同，你必须始终为存储类型属性提供默认值。这是因为类型本身没有初始化方法来给存储类型属性赋值。<br>存储类型属性在首次访问时被初始化。它们会被保证只初始化一次，即使同时由多个线程访问。请注意你并不需要用 lazy 修饰符标记它们。</p><p>类型属性的语法: 你可以使用static关键字定义类型属性，对于类类型的计算属性，可以使用class关键字来允许子类覆盖超类的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Stored Properties 存储属性&lt;/li&gt;
&lt;li&gt;Computed Properties 计算属性&lt;/li&gt;
&lt;li&gt;Property Observers 属性观察器&lt;/li&gt;
&lt;li&gt;Global and Local Variables&lt;/li&gt;
&lt;li&gt;Type Properties 类型属性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="属性" scheme="http://yoursite.com/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>logan 源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/logan/logan/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/logan/logan/</id>
    <published>2018-12-19T04:07:12.000Z</published>
    <updated>2018-12-20T07:49:35.638Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在通过logan源码，分析logan的整体结构、存储结构、内部的数据结构、主要的C接口、优点、存在的问题。</p><a id="more"></a><blockquote><p>mmap 其实主要作用就是多个进程共享内存，所以本文有时候将mmap叫做共享内存</p></blockquote><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///初始化</span></span><br><span class="line"><span class="built_in">NSData</span> *keydata = [<span class="string">@"0123456789012345"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *ivdata = [<span class="string">@"0123456789012345"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">uint64_t file_max = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">loganInit(keydata, ivdata, file_max);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 写入日志</span></span><br><span class="line"><span class="built_in">NSString</span> *strLog = <span class="string">@"日志"</span>;</span><br><span class="line">logan(LoganTypeAction, strLog);</span><br></pre></td></tr></table></figure><p>使用方法非常简单 loganInit 初始化logan系统，logan 写入日志。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>我相信，对应任何一个三方库，你如果想了解它，第一个想知道的问题是：这个库的整体结构是什么结构？</p><p>下面来解密logan整体结构：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_struct.png" alt="logan整体结构"></p><p>就画了一个非常简单的图，但是我觉得能将logan整个日志存储的机制表达出来了。</p><ol><li>当程序有日志(命名为data) 需要写入的时候，我们将data做系列处理：格式化(附加上线程、时间等有用的信息)、 压缩、DES加密、 最后追加到mmap中。</li><li>mmap 据说能提高写日志的效率，防止丢失，  mmap中，如果日志达到了5K，就构成一个压缩单元，如果有后续的日志，就新开始一个压缩单元。</li><li>当mmap中的日志超过容量(初始指定10M)的1/3就写入日志文件中。</li><li>当日志文件满了，不知道怎么处理了，上传，还是上传？  logan没实现！！！！</li></ol><p>下面贴出了logan本地文件的结构</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_file.png" alt="本地文件结构"></p><ol><li>2018-12-19 是日志文件。</li><li>logan.mmap2是共享内存的映射文件。</li></ol><h2 id="logan本质–存储结构"><a href="#logan本质–存储结构" class="headerlink" title="logan本质–存储结构"></a>logan本质–存储结构</h2><p>如果你通过上节，了解了logan的整体结构，有没有它的感觉设计也很平凡？那么你现在有没有好奇logan到底哪里出色？值得美团去开源它？</p><p>我觉得核心的就是大量日志的组织结构，也就是如何高效的将大量日志组织在本地存储，你也可以想想。如果自己做，怎么组织？</p><p>logan用简单的方式实现了海量日志的本地存储，本质是自己设计了一套日志存储格式，它就是logan的本质，理解了本质，就理解了logan。</p><p>通过查阅源码，整理的日志格式如下 ：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logFile_format.png" alt="日志文件格式"></p><blockquote><p>图的阅读方式：下面部分是对上面部分的展开。分为两部分，日志头、日志体（图中左右两部分）。</p></blockquote><h3 id="日志头"><a href="#日志头" class="headerlink" title="日志头"></a>日志头</h3><p>日志头以0x0D标志位表示header开始，紧接着用两个字节表示头内容的长度、接着是头内容、最后用0x0E标志位表示header结束。</p><p>头内容数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"logan_version"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"file"</span>:<span class="string">"2018-12-19"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logan_version 表示logan的版本，file字段存储日志文件的文件名。 也就是你如果拿到了共享内存，就能通过读取头信息，将共享内存中的数据写入到file表示的日志文件中。</p><h3 id="日志体"><a href="#日志体" class="headerlink" title="日志体"></a>日志体</h3><p>日志体由长度(total_len，占用三字节、小端模式存储)、协议组成。</p><p>协议由协议起始标志位(1字节、值为0x01)、内容、协议结束标志位(1字节、值为0x00)。我自己理解，所谓协议就是一个压缩单元，超过5K开始下一个压缩单元。</p><p>内容由内容长度(4字节，大端模式存储)、各个log组成。</p><h3 id="先睹为快、窥探日志数据"><a href="#先睹为快、窥探日志数据" class="headerlink" title="先睹为快、窥探日志数据"></a>先睹为快、窥探日志数据</h3><p>如果看懂了上节内容，你有没有想窥探下logan内存结构的欲望？</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_memory.png" alt="日志数据"></p><ol><li>0x0D  头起始标志  </li><li>0x0028  = 40  头长度</li><li>0x7B ~0x7D00  头内容</li><li>0x0E  头结束标志</li><li>—这里是分割线， 表示头结束，下面是日志体—</li><li>0x000055  tatal_len 日志体总长度</li><li>0x01 协议起始标志位</li><li>0x00000050 内容长度</li><li>0x14D7~0x465C  多个压缩加密后的日志    </li><li>0x00  协议结束标志位</li></ol><p>看了logan日志存储格式，我自己总结了下，其实就是一个三级结构：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_three_struct.png" alt="logan三级结构"></p><p>你可以回头想想，所有的字段都服务于这个三级结构，如果你按照三级结构的思路理解，这里就没有多余的信息。 </p><blockquote><p>我首次看，就觉得怎么这么多len信息，是否是多余的呢。</p></blockquote><h2 id="日志追加机制"><a href="#日志追加机制" class="headerlink" title="日志追加机制"></a>日志追加机制</h2><h3 id="追加机制"><a href="#追加机制" class="headerlink" title="追加机制"></a>追加机制</h3><p>下面我们就可以进一步深入logan日志增加的机制了，其实，追加日志主要靠四个指针就完成了。</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_pointer.png" alt="4个关键指针的展示"></p><p>说明下这四个指针的作用：</p><ol><li>buffer_point 标记mmap的起始地址，基本固定不变。</li><li>total_point日志体的起始位置指针 ，这个指针目的是当有新日志添加的时候，更新total_point后面的total_len属性。位置也不变化。</li><li>content_lent_point内容起始位置指针，一个压缩单元完事后，前进一次。它的主要作用是，当增加log后，更新后面的content_len的内容。其实就是指向上面三级结构中的第二级结构</li><li>last_point 添加日志起始指针 ,每次新的日志都追加到last_point处，追加完后，更新last_point为下一个追加位置。 </li></ol><p>上面多次提到了压缩单元，我们用下面的图说明下压缩单元递增的思路：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_zip_unit.png" alt="5K压缩单元递增示意图"></p><p>上面是一个压缩单元完成后，开始新压缩单元的示意图。我们可以观察content_lent_point、last_point两个指针移动的情况。(箭头从 蓝色-&gt; 蓝色-&gt; 绿色 的变化过程)</p><h3 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h3><p>通过上面我们了解了三个基本的关键节点：</p><ol><li><p>5k  一个压缩单元的大小</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGAN_MAX_GZIP_UTIL <span class="number">5</span> * <span class="number">1024</span> <span class="comment">//压缩单元的大小</span></span><br></pre></td></tr></table></figure></li><li><p>容量(初始指定10M)的1/3  写文件的节点</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGAN_WRITEPROTOCOL_DEVIDE_VALUE <span class="number">3</span> <span class="comment">//多少分之一写入</span></span><br><span class="line">buffer_length / LOGAN_WRITEPROTOCOL_DEVIDE_VALUE</span><br></pre></td></tr></table></figure></li><li><p>10M 日志文件总大小</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t file_max = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>感觉也不是很复杂，就是用四个指针标记修改的位置，有新的日志来了，就追加到last_point处。</p><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>logan的结构、存储本质、追加日志机制都讲完了，接着看看代码是怎么实现的。logan用一个全局的数据结构管理所有的数据，这个数据结构定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">logan_model_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> total_len; <span class="comment">//数据长度</span></span><br><span class="line">    <span class="keyword">char</span> *file_path; <span class="comment">//文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_malloc_zlib;</span><br><span class="line">    z_stream *strm;</span><br><span class="line">    <span class="keyword">int</span> zlib_type; <span class="comment">//压缩类型</span></span><br><span class="line">    <span class="keyword">char</span> remain_data[<span class="number">16</span>]; <span class="comment">//剩余空间</span></span><br><span class="line">    <span class="keyword">int</span> remain_data_len; <span class="comment">//剩余空间长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_ready_gzip; <span class="comment">//是否可以gzip</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_stream_type; <span class="comment">//文件流类型</span></span><br><span class="line">    FILE *file; <span class="comment">//文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> file_len; <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer_point; <span class="comment">//缓存的指针 (不变)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *last_point; <span class="comment">//最后写入位置的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *total_point; <span class="comment">//总数的指针 (可能变) , 给c看,低字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *content_lent_point;<span class="comment">//协议内容长度指针 , 给java看,高字节</span></span><br><span class="line">    <span class="keyword">int</span> content_len; <span class="comment">//内容的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> aes_iv[<span class="number">16</span>]; <span class="comment">//aes_iv</span></span><br><span class="line">    <span class="keyword">int</span> is_ok;</span><br><span class="line"></span><br><span class="line">&#125; cLogan_model;</span><br></pre></td></tr></table></figure><p>感觉定义的很乱，我整理了下 ：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_model.png" alt="数据结构"></p><ol><li><p>日志文件相关的：有日志文件的路径file_path、文件流状态file_stream_type、文件流file、文件内容的大小file_len。其中文件流状态file_stream_type可选的取值：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_NONE 0</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_OPEN 1</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_CLOSE 2</span></span><br></pre></td></tr></table></figure></li><li><p>压缩相关的： is_malloc_zlib 表示strm是否申请空间 ,zlib_type 压缩状态，is_ready_gzip压缩是否准备好。 zlib_type可以的取值如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_INIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_ING  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_END  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_FAIL 4</span></span><br></pre></td></tr></table></figure></li><li><p>mmap操作相关的，记录日志的长度信息、四个指针的信息。</p></li><li>下面是加密相关的，DES加密是16字节为一个单元，如果日志压缩后，长度取余，不足16字节的内容就不参与加密了，等着下次日志，一起加密。所以remain_data、remain_data_len表示剩下的未加密的压缩过的日志数据。aes_iv 表示DES加密的初始向量。</li><li>is_ok 表示整个logan是否是正常状态。</li></ol><p>我将上面的数据分类主要的5类，到了哪一步，关注哪一步就ok了。分类后，就很好理解了。</p><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>下面我列举了logan C语言层的4个核心接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cache_dirs, <span class="keyword">const</span> <span class="keyword">char</span> *path_dirs, <span class="keyword">int</span> max_file, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_key16, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_iv16)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_write</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">char</span> *<span class="built_in">log</span>, <span class="keyword">long</span> <span class="keyword">long</span> local_time, <span class="keyword">char</span> *thread_name, <span class="keyword">long</span> <span class="keyword">long</span> thread_id,<span class="keyword">int</span> is_main)</span></span></span><br><span class="line"><span class="function">             </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_flush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>下面一一讲解下，所有的代码都是缩减代码。方便理解函数完成的主体工作。</p><h3 id="clogan-init"><a href="#clogan-init" class="headerlink" title="clogan_init"></a>clogan_init</h3><p>clogan_init 主要功能是：</p><ol><li>打开映射内存</li><li>如果存在上次程序结束后没有写入文件的日志，将上次日志写入到文件中。使本次以一个干净的环境开始。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">clogan_init(<span class="keyword">const</span> <span class="keyword">char</span> *cache_dirs, <span class="keyword">const</span> <span class="keyword">char</span> *path_dirs, <span class="keyword">int</span> max_file, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_key16,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_iv16) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///保存秘钥、初始向量</span></span><br><span class="line">    aes_init_key_iv(encrypt_key16, encrypt_iv16);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 构建内存映射文件路径</span></span><br><span class="line">    <span class="keyword">char</span> *cache_path = <span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != cache_path) &#123;</span><br><span class="line">        _mmap_file_path = cache_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 构建日志目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != dirs) &#123;</span><br><span class="line">        _dir_path = dirs; <span class="comment">//日志写入的文件目录</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 打开内存映射</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == _logan_buffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == _cache_buffer_buffer) &#123;</span><br><span class="line">            flag = open_mmap_file_clogan(cache_path, &amp;_logan_buffer, &amp;_cache_buffer_buffer);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">///读取内存映射中的日志，写入到文件中，准备开始一个干净的日志环境。</span></span><br><span class="line">    <span class="keyword">if</span> (is_init_ok) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == LOGAN_MMAP_MMAP) <span class="comment">//MMAP的缓存模式,从缓存的MMAP中读取数据</span></span><br><span class="line">            read_mmap_data_clogan(_dir_path);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clogan-open"><a href="#clogan-open" class="headerlink" title="clogan_open"></a>clogan_open</h3><p>clogan_open 主要工作是：</p><ol><li>初始化zlib</li><li>初始化加密模块</li><li>初始化全局数据logan_model</li></ol><p>代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int clogan_open(const char *pathname) &#123;</span><br><span class="line"></span><br><span class="line">    is_open_ok = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///全局的logan_model 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (NULL != logan_model) &#123; <span class="comment">//回写到日志中</span></span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        logan_model = malloc(sizeof(cLogan_model));</span><br><span class="line">        <span class="keyword">if</span> (NULL != logan_model) &#123;</span><br><span class="line">            memset(logan_model, <span class="number">0</span>, sizeof(cLogan_model));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>file_path = temp_file;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>buffer_point = _logan_buffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// zlib 的初始化</span></span><br><span class="line">    init_zlib_clogan(logan_model)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">///添加头信息</span></span><br><span class="line">   add_mmap_header_clogan(back_data, logan_model);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span><span class="function"><span class="title">last_point</span> = logan_model-&gt;</span>total_point + LOGAN_MMAP_TOTALLEN;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>total_point = _logan_buffer;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span><span class="function"><span class="title">last_point</span> = logan_model-&gt;</span>total_point + LOGAN_MMAP_TOTALLEN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///设置关键指针信息，长度信息</span></span><br><span class="line">    restore_last_position_clogan(logan_model);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 加密信息初始化</span></span><br><span class="line">    init_encrypt_key_clogan(logan_model);</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>is_ok = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (is_open_ok) &#123;</span><br><span class="line">        back = CLOGAN_OPEN_SUCCESS;</span><br><span class="line">    &#125; </span><br><span class="line">    return back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clogan_open 主要完成：初始化全局的logan_model、init_zlib_clogan、init_encrypt_key_clogan 三个工作。</p><h3 id="clogan-write"><a href="#clogan-write" class="headerlink" title="clogan_write"></a>clogan_write</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>clogan_write 顾名思义，就是写入日志，这里用简单的树形结构描述它的过程。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── clogan_write</span><br><span class="line">│   └── clogan_write_section分片写入</span><br><span class="line">│       └── clogan_write2</span><br><span class="line">│           ├── <span class="number">1.</span> clogan_zlib_compress</span><br><span class="line">│           │   └── clogan_zlib</span><br><span class="line">│           │       ├── aes_encrypt_clogan</span><br><span class="line">│           │       └── deflate</span><br><span class="line">│           ├── <span class="number">2.</span> update_length_clogan(logan_model);<span class="comment">///写完日志，更新长度信息</span></span><br><span class="line">│           ├── <span class="number">3.</span> 如果一个压缩单元完事，结束这个压缩单元</span><br><span class="line">│           │   ├── clogan_zlib_end_compress(logan_model)</span><br><span class="line">│           │   ├── aes_encrypt_clogan 加密剩余部分</span><br><span class="line">│           │   └── update_length_clogan(logan_model)</span><br><span class="line">│           ├── <span class="number">4.</span> 如果mmap的大小大于总容量的<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">│           │   └── write_flush_clogan();写入文件</span><br><span class="line">│           └── <span class="number">5.</span> 如果一个单元完事，还要做下面工作，开始下一个压缩单元</span><br><span class="line">│               ├── init_encrypt_key_clogan(logan_model)</span><br><span class="line">│               ├── init_zlib_clogan(logan_model)</span><br><span class="line">│               ├── logan_model-&gt;content_len = <span class="number">0</span></span><br><span class="line">│               ├── logan_model-&gt;remain_data_len = <span class="number">0</span></span><br><span class="line">│               └── restore_last_position_clogan(logan_model)</span><br></pre></td></tr></table></figure><h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h4><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_protocal.png" alt="协议"></p><h3 id="clogan-flush"><a href="#clogan-flush" class="headerlink" title="clogan_flush"></a>clogan_flush</h3><p>clogan_flush 将mmap中的日志强制写入到文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_flush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    write_flush_clogan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clogan_flush 调用了write_flush_clogan。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> write_flush_clogan() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span> (logan_model-&gt;total_len &gt; LOGAN_WRITEPROTOCOL_HEAER_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">point</span> = logan_model-&gt;total_point;</span><br><span class="line">        <span class="built_in">point</span> += LOGAN_MMAP_TOTALLEN;</span><br><span class="line">        write_dest_clogan(<span class="built_in">point</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), logan_model-&gt;total_len, logan_model);</span><br><span class="line">        clear_clogan(logan_model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write_flush_clogan调用write_dest_clogan将mmap中的数据写入到文件中，同时调用clear_clogan清空全局数据logan_model的状态。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入磁盘、更新文件大小</span></span><br><span class="line">void write_dest_clogan(void *point, size_t size, size_t length, cLogan_model *loganModel) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">fwrite</span>(point, sizeof(char), logan_model-&gt;</span><span class="function"><span class="title">total_len</span>, logan_model-&gt;</span>file);<span class="comment">//写入到文件中</span></span><br><span class="line">    <span class="function"><span class="title">fflush</span>(logan_model-&gt;</span>file);</span><br><span class="line">    <span class="function"><span class="title">loganModel</span>-&gt;</span><span class="function"><span class="title">file_len</span> += loganModel-&gt;</span>total_len; <span class="comment">//修改文件大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>美团的<a href="https://mp.weixin.qq.com/s/ojUZjT4YhUWZ3jh37UtJmg" rel="external nofollow noopener noreferrer" target="_blank">Logan：美团点评移动端基础日志库揭秘</a>说，有下面的缺点：</p><ol><li>卡顿，影响性能</li><li>日志丢失</li><li>安全性</li><li>日志分散</li></ol><p>我看了logan的源码，logan确实解决了上面的问题，反过来，logan有下面的优点：</p><ol><li>不卡顿，性能好</li><li>日志不丢失</li><li>安全</li><li>日志集中</li></ol><h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>logan主要实现了日志的本地存储功能，考虑的很多边界情况，我觉得应该可以使用，但是还存在下面的问题 ：</p><ol><li>没有日志回捞功能(没有开源，这个工作主要在服务端，客户端也没发现对应的接口)</li><li>没有主动上报功能(主动上报有简单的实现，这个应该也归结为使用者的功能吧)</li><li>日志大于10M的情况没有处理，需要自己完善。</li></ol><p>没有写的证据在这里：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_file_exist_clogan(logan_model-&gt;file_path)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (logan_model-&gt;file_len &gt; max_file_len) &#123;</span><br><span class="line">        printf_clogan(<span class="string">"clogan_write &gt; beyond max file , cant write log\n"</span>);</span><br><span class="line">        back = CLOAGN_WRITE_FAIL_MAXFILE;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文件的大小超过了10M，直接返回了 ，不在写入日志。</p><h2 id="胡思乱想"><a href="#胡思乱想" class="headerlink" title="胡思乱想"></a>胡思乱想</h2><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_future.png" alt="胡思乱想">  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/ojUZjT4YhUWZ3jh37UtJmg" rel="external nofollow noopener noreferrer" target="_blank">Logan：美团点评移动端基础日志库揭秘</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文旨在通过logan源码，分析logan的整体结构、存储结构、内部的数据结构、主要的C接口、优点、存在的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="logan" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/logan/"/>
    
    
      <category term="logan" scheme="http://yoursite.com/tags/logan/"/>
    
  </entry>
  
  <entry>
    <title>mmap原理之详解(转载)</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/mmap/union%E5%AE%9A%E4%B9%89%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>http://yoursite.com/wiki/编程基础/mmap/union定义的副本/</id>
    <published>2018-12-19T01:07:12.000Z</published>
    <updated>2018-12-19T03:15:58.822Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>mmap基础概念</li><li>mmap内存映射原理</li><li>mmap和常规文件操作的区别</li><li>mmap优点总结</li><li>mmap相关函数</li><li>mmap使用细节</li><li>在上面的知识前提下我们下面看看如果大小不是页的整倍数的具体情况</li></ol><p>文章出处：<a href="https://blog.csdn.net/qq_36675830/article/details/79283113" rel="external nofollow noopener noreferrer" target="_blank">mmap原理之详解</a></p><a id="more"></a><h2 id="mmap基础概念"><a href="#mmap基础概念" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mmap基础概念&lt;/li&gt;
&lt;li&gt;mmap内存映射原理&lt;/li&gt;
&lt;li&gt;mmap和常规文件操作的区别&lt;/li&gt;
&lt;li&gt;mmap优点总结&lt;/li&gt;
&lt;li&gt;mmap相关函数&lt;/li&gt;
&lt;li&gt;mmap使用细节&lt;/li&gt;
&lt;li&gt;在上面的知识前提下我们下面看看如果大小不是页的整倍数的具体情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/qq_36675830/article/details/79283113&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;mmap原理之详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
      <category term="mmap" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/mmap/"/>
    
    
      <category term="mmap" scheme="http://yoursite.com/tags/mmap/"/>
    
  </entry>
  
</feed>
