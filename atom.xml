<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-25T10:50:58.540Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>7. 函数</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/7__%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/7__函数/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:50:58.540Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Defining and Calling Functions</li><li>Function Parameters and Return Values</li><li>Function Argument Labels and Parameter Names</li><li>Function Types</li><li>Nested Functions</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/7__函数/1.jpeg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Defining and Calling Functions&lt;/li&gt;
&lt;li&gt;Function Parameters and Return Values&lt;/li&gt;
&lt;li&gt;Function Argument Labels and Parameter Names&lt;/li&gt;
&lt;li&gt;Function Types&lt;/li&gt;
&lt;li&gt;Nested Functions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>2. 基础</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/2__%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/2__基础/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-28T01:47:30.358Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Constants and Variables</li><li>Comments</li><li>Semicolons</li><li>Integers</li><li>Floating-Point Numbers</li><li>Type Safety and Type Inference</li><li>Numeric Literals</li><li>Numeric Type Conversion</li><li>Type Aliases</li><li>Booleans</li><li>Tuples</li><li>Optionals</li><li>Error Handling</li><li>Assertions and Preconditions</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/2__基础/1.png" alt="1"></p><p><img src="/wiki/swift学习摘要/2__基础/2.png" alt="2"></p><p><img src="/wiki/swift学习摘要/2__基础/3.png" alt="3"></p><p><img src="/wiki/swift学习摘要/2__基础/4.png" alt="4"></p><p><img src="/wiki/swift学习摘要/2__基础/5.png" alt="5"></p><p><img src="/wiki/swift学习摘要/2__基础/6.png" alt="6"></p><p><img src="/wiki/swift学习摘要/2__基础/7.png" alt="7"></p><p><img src="/wiki/swift学习摘要/2__基础/8.png" alt="8"></p><p><img src="/wiki/swift学习摘要/2__基础/9.png" alt="9"></p><p><img src="/wiki/swift学习摘要/2__基础/10.png" alt="10"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Constants and Variables&lt;/li&gt;
&lt;li&gt;Comments&lt;/li&gt;
&lt;li&gt;Semicolons&lt;/li&gt;
&lt;li&gt;Integers&lt;/li&gt;
&lt;li&gt;Floating-Point Numbers&lt;/li&gt;
&lt;li&gt;Type Safety and Type Inference&lt;/li&gt;
&lt;li&gt;Numeric Literals&lt;/li&gt;
&lt;li&gt;Numeric Type Conversion&lt;/li&gt;
&lt;li&gt;Type Aliases&lt;/li&gt;
&lt;li&gt;Booleans&lt;/li&gt;
&lt;li&gt;Tuples&lt;/li&gt;
&lt;li&gt;Optionals&lt;/li&gt;
&lt;li&gt;Error Handling&lt;/li&gt;
&lt;li&gt;Assertions and Preconditions&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>7. 函数</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/8__%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/8__闭包/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:51:29.972Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Closure Expressions</li><li>Trailing Closures</li><li>Capturing Values</li><li>Closures Are Reference Types</li><li>Escaping Closures</li><li>Autoclosures</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/8__闭包/1.jpeg" alt="1"></p><p><img src="/wiki/swift学习摘要/8__闭包/2.jpeg" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Closure Expressions&lt;/li&gt;
&lt;li&gt;Trailing Closures&lt;/li&gt;
&lt;li&gt;Capturing Values&lt;/li&gt;
&lt;li&gt;Closures Are Reference Types&lt;/li&gt;
&lt;li&gt;Escaping Closures&lt;/li&gt;
&lt;li&gt;Autoclosures&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>10. 类和结构体</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/10__%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/10__类和结构体/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-28T01:46:39.491Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Comparing Structures and Classes</li><li>Structures and Enumerations Are Value Types</li><li>Classes Are Reference Types</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/10__类和结构体/1.png" alt="1"></p><p><img src="/wiki/swift学习摘要/10__类和结构体/2.png" alt="2"></p><p><img src="/wiki/swift学习摘要/10__类和结构体/3.png" alt="3"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Comparing Structures and Classes&lt;/li&gt;
&lt;li&gt;Structures and Enumerations Are Value Types&lt;/li&gt;
&lt;li&gt;Classes Are Reference Types&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="类和结构体" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>1. 枚举</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/9__%E6%9E%9A%E4%B8%BE/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/9__枚举/</id>
    <published>2019-01-24T04:07:12.000Z</published>
    <updated>2019-01-25T10:52:37.023Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Enumeration Syntax</li><li>Matching Enumeration Values with a Switch Statement</li><li>Iterating over Enumeration Cases</li><li>Associated Values</li><li>Raw Values</li><li>Recursive Enumerations</li></ol><a id="more"></a><p><img src="/wiki/swift学习摘要/9__枚举/1.jpeg" alt="1"></p><p><img src="/wiki/swift学习摘要/9__枚举/2.jpeg" alt="1"></p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Enumeration Syntax&lt;/li&gt;
&lt;li&gt;Matching Enumeration Values with a Switch Statement&lt;/li&gt;
&lt;li&gt;Iterating over Enumeration Cases&lt;/li&gt;
&lt;li&gt;Associated Values&lt;/li&gt;
&lt;li&gt;Raw Values&lt;/li&gt;
&lt;li&gt;Recursive Enumerations&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="枚举" scheme="http://yoursite.com/tags/%E6%9E%9A%E4%B8%BE/"/>
    
  </entry>
  
  <entry>
    <title>12. 方法</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/12__%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/12__方法/</id>
    <published>2019-01-18T04:07:12.000Z</published>
    <updated>2019-01-25T10:17:39.385Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Instance Methods 实例方法</li><li>Type Methods 类型方法</li></ol><a id="more"></a><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><p>self 属性： 类型的每个实例都有一个名为 self 的隐式属性，它与实例本身完全等效。你可以使用self 属性来调用自己的实例方法。</p><p>在实例例⽅方法中修改值类型： 结构体和枚举是值类型 。默认情况下，无法在其实例方法中修改值类型的属性。你可以通过在方法的 func 关键字前放置 mutating 关键字。</p><p>你不能在常量结构体类型上调用异变方法，因为它的属性不能更改，即使它们是变量属性。</p><p>在可变方法中给self赋值：可变方法能给隐性的self属性赋以一个全新的实例</p><h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>为了明确一个方法是类型方法，你可以在这个方法 的 func 关键词前加上 static 关键词。在类中，也可以使用 class 关键词来声明一个类型方法。与 static 关键词不同的是，用 class 关键词声明的类型方法允许它的子类重写其父类对类型方法的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Instance Methods 实例方法&lt;/li&gt;
&lt;li&gt;Type Methods 类型方法&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="方法" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>13. 下标</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/13__%E4%B8%8B%E6%A0%87/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/13__下标/</id>
    <published>2019-01-18T04:07:12.000Z</published>
    <updated>2019-01-25T10:27:11.338Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Subscript Syntax</li><li>Subscript Usage</li><li>Subscript Options</li></ol><a id="more"></a><p>你可以为单个类型定义多个下标，并根据传递给下标的索引值的类型，选择要使用的相应下 标进行重载。 下标不限于单个维度，你可以定义具有多个输入参数的下标以满足你自定义类 型的需求。</p><h2 id="下标语法"><a href="#下标语法" class="headerlink" title="下标语法"></a>下标语法</h2><p>使用下标, 让你可以通过在实例名称后面的方括号中写入一个或多个值来查询类的实例。它们 的语法类似于实例方法和计算属性语法。使用 subscript 关键字定义下标，并且和实例 方法类似，可以指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或 只读。和计算属性类似, 读写是由 getter 和 setter 方法实现的</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscript(index: <span class="type">Int</span>) -&gt; <span class="keyword">Int</span> &#123;</span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line"><span class="comment">// 在这⾥里里返回⼀一个对应下标的值 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span>(<span class="keyword">new</span><span class="type">Value</span>) &#123;</span><br><span class="line"><span class="comment">// 在这⾥里里执⾏行行对应的赋值操作</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与只读计算属性一样，你可以通过删除 get 关键字以及大括号来简化只读下标的声明</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">subscript</span><span class="params">(index: Int)</span></span> -&gt; Int &#123; </span><br><span class="line"><span class="comment">// 在这⾥里里返回⼀一个对应下标的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标用法"><a href="#下标用法" class="headerlink" title="下标用法"></a>下标用法</h2><p>下标通常被用来作为访问集合、列表或序列中的元素的快捷方式.</p><p>Swift 的 Dictionary 类型将其键值作为下标实现并返回一个可选类型</p><h2 id="下标选项"><a href="#下标选项" class="headerlink" title="下标选项"></a>下标选项</h2><p>下标可以设置任意数量的输入参数，这些输入参数也可以是任意类型。 同时，下标也可以返 回任何类型。 下标可以使用可变参数，但它们不能使用输入输出参数或是提供默认参数值。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Subscript Syntax&lt;/li&gt;
&lt;li&gt;Subscript Usage&lt;/li&gt;
&lt;li&gt;Subscript Options&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="下标" scheme="http://yoursite.com/tags/%E4%B8%8B%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>11. 属性</title>
    <link href="http://yoursite.com/wiki/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/11__%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/wiki/swift学习摘要/11__属性/</id>
    <published>2019-01-18T03:07:12.000Z</published>
    <updated>2019-01-25T10:13:56.514Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Stored Properties 存储属性</li><li>Computed Properties 计算属性</li><li>Property Observers 属性观察器</li><li>Global and Local Variables</li><li>Type Properties 类型属性</li></ol><a id="more"></a><p>存储属性将常量和变量值存储为实例 的一部分，而计算属性则是通过计算得到一个值(而不是存储值)。计算属性适用于类、结 构体和枚举类型，而存储属性只适用于类和结构体类型。</p><h2 id="存储属性"><a href="#存储属性" class="headerlink" title="存储属性"></a>存储属性</h2><p>常量结构体实例的存储属性：当值类型的实例声明为常量时，其所有属性也都被标记为常量。如果将引用类型的实例声明为常量时，你仍可以修改该实例的变量属性。</p><p>延迟存储属性：第一次使用时才进行计算。lazy标识，你必须始终将延迟属性声明为变量(使用 var 关键字)，因为延迟属性的初始值可能在实例初始化完成之后，仍然没有被赋值。而常量属性必须在实例初始化完成 之前 就 获得一个值，因此不能声明为延迟。<font color="blue">lazy和let是天敌啊</font></p><p>存储属性和实例变量： swift属性没有相应的实例变量，并且属性的底层存储不能直接访问。</p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>除了存储属性之外，类、结构体和枚举还可以定义 计算属性。它们会提供了一个 getter 方法和一个可选的 setter 方法来间接读取和设置其他属性和 值。</p><p>只读计算属性：只有 getter 方法但没有 setter 方法的计算属性称为 只读计算属性 。</p><p>你必须使用 var 关键字来声明计算属性(包括只读计算属性)，这是因为它们的值 是不固定。 let 关键字仅用于常量属性，这种属性一旦被初始化以后，就不能再更 改它们的值。</p><h2 id="属性观察器"><a href="#属性观察器" class="headerlink" title="属性观察器"></a>属性观察器</h2><p>属性观察器会观察并对属性值的变化做出反应。每次设置属性值时都会调用属性观察器，即使新值与属性的当前值相同。</p><p>你可以将属性观察器添加到你定义的任何存储属性上，但延迟存储属性除外。你还可以通过在子类中重写属性来为任何继承的属性(无论是存储还是计算)添加属性观察器。你并不需 要为非重写的计算属性定义属性观察器，因为你可以在计算属性的 setter 方法中观察并响应其值的更改。</p><p>你可以选择在属性上定义一个或两个观察器:</p><ol><li>在存储值之前调用 willSet 。</li><li>存储新值后立即调用 didSet 。</li></ol><p>在调用父类初始化方法之后，在子类中给父类属性赋值时，将会调用父类属性的 willSet 和 didSet 观察器。如果在调用父类初始化方法之前，在子类中给父类属性赋值，则不会调用父类的观察器。</p><p>didSet 观察器不会为旧值提供自定义参数名称，而是使用默认名称 oldValue 。</p><h2 id="全局和局部变量"><a href="#全局和局部变量" class="headerlink" title="全局和局部变量"></a>全局和局部变量</h2><p>上面描述的用于计算和观察属性的功能也可用于 全局变量 和 局部变量 。全局变量是指在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是指在函数、方法或闭包上下文中定义的变量。</p><p>全局常量和变量总是被延迟计算，与 延迟存储属性 类似。与延迟存储属性不同的是，全局常量和变量不需要使用 lazy 修饰符进行标记。 局部常量和变量永远不会被延迟计算。</p><h2 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h2><p>实例属性是属于特定类型的实例的属性。每次创建该类型的新实例时，它都有自己的一组属性值，与任何其他实例不同。</p><p>类型属性用于定义一个对某个类型的 所有 实例都可见的值</p><p>存储类型属性可以是变量或常量。计算类型属性始终是变量属性，与声明计算实例属性的方式相同。</p><p>与存储实例属性不同，你必须始终为存储类型属性提供默认值。这是因为类型本身没有初始化方法来给存储类型属性赋值。<br>存储类型属性在首次访问时被初始化。它们会被保证只初始化一次，即使同时由多个线程访问。请注意你并不需要用 lazy 修饰符标记它们。</p><p>类型属性的语法: 你可以使用static关键字定义类型属性，对于类类型的计算属性，可以使用class关键字来允许子类覆盖超类的实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;Stored Properties 存储属性&lt;/li&gt;
&lt;li&gt;Computed Properties 计算属性&lt;/li&gt;
&lt;li&gt;Property Observers 属性观察器&lt;/li&gt;
&lt;li&gt;Global and Local Variables&lt;/li&gt;
&lt;li&gt;Type Properties 类型属性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="swift学习摘要" scheme="http://yoursite.com/categories/swift%E5%AD%A6%E4%B9%A0%E6%91%98%E8%A6%81/"/>
    
    
      <category term="属性" scheme="http://yoursite.com/tags/%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>logan 源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/logan/logan/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/logan/logan/</id>
    <published>2018-12-19T04:07:12.000Z</published>
    <updated>2018-12-20T07:49:35.638Z</updated>
    
    <content type="html"><![CDATA[<p>本文旨在通过logan源码，分析logan的整体结构、存储结构、内部的数据结构、主要的C接口、优点、存在的问题。</p><a id="more"></a><blockquote><p>mmap 其实主要作用就是多个进程共享内存，所以本文有时候将mmap叫做共享内存</p></blockquote><h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///初始化</span></span><br><span class="line"><span class="built_in">NSData</span> *keydata = [<span class="string">@"0123456789012345"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSData</span> *ivdata = [<span class="string">@"0123456789012345"</span> dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">uint64_t file_max = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">loganInit(keydata, ivdata, file_max);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 写入日志</span></span><br><span class="line"><span class="built_in">NSString</span> *strLog = <span class="string">@"日志"</span>;</span><br><span class="line">logan(LoganTypeAction, strLog);</span><br></pre></td></tr></table></figure><p>使用方法非常简单 loganInit 初始化logan系统，logan 写入日志。</p><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>我相信，对应任何一个三方库，你如果想了解它，第一个想知道的问题是：这个库的整体结构是什么结构？</p><p>下面来解密logan整体结构：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_struct.png" alt="logan整体结构"></p><p>就画了一个非常简单的图，但是我觉得能将logan整个日志存储的机制表达出来了。</p><ol><li>当程序有日志(命名为data) 需要写入的时候，我们将data做系列处理：格式化(附加上线程、时间等有用的信息)、 压缩、DES加密、 最后追加到mmap中。</li><li>mmap 据说能提高写日志的效率，防止丢失，  mmap中，如果日志达到了5K，就构成一个压缩单元，如果有后续的日志，就新开始一个压缩单元。</li><li>当mmap中的日志超过容量(初始指定10M)的1/3就写入日志文件中。</li><li>当日志文件满了，不知道怎么处理了，上传，还是上传？  logan没实现！！！！</li></ol><p>下面贴出了logan本地文件的结构</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_file.png" alt="本地文件结构"></p><ol><li>2018-12-19 是日志文件。</li><li>logan.mmap2是共享内存的映射文件。</li></ol><h2 id="logan本质–存储结构"><a href="#logan本质–存储结构" class="headerlink" title="logan本质–存储结构"></a>logan本质–存储结构</h2><p>如果你通过上节，了解了logan的整体结构，有没有它的感觉设计也很平凡？那么你现在有没有好奇logan到底哪里出色？值得美团去开源它？</p><p>我觉得核心的就是大量日志的组织结构，也就是如何高效的将大量日志组织在本地存储，你也可以想想。如果自己做，怎么组织？</p><p>logan用简单的方式实现了海量日志的本地存储，本质是自己设计了一套日志存储格式，它就是logan的本质，理解了本质，就理解了logan。</p><p>通过查阅源码，整理的日志格式如下 ：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logFile_format.png" alt="日志文件格式"></p><blockquote><p>图的阅读方式：下面部分是对上面部分的展开。分为两部分，日志头、日志体（图中左右两部分）。</p></blockquote><h3 id="日志头"><a href="#日志头" class="headerlink" title="日志头"></a>日志头</h3><p>日志头以0x0D标志位表示header开始，紧接着用两个字节表示头内容的长度、接着是头内容、最后用0x0E标志位表示header结束。</p><p>头内容数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"logan_version"</span>:<span class="number">3</span>,</span><br><span class="line">    <span class="attr">"file"</span>:<span class="string">"2018-12-19"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logan_version 表示logan的版本，file字段存储日志文件的文件名。 也就是你如果拿到了共享内存，就能通过读取头信息，将共享内存中的数据写入到file表示的日志文件中。</p><h3 id="日志体"><a href="#日志体" class="headerlink" title="日志体"></a>日志体</h3><p>日志体由长度(total_len，占用三字节、小端模式存储)、协议组成。</p><p>协议由协议起始标志位(1字节、值为0x01)、内容、协议结束标志位(1字节、值为0x00)。我自己理解，所谓协议就是一个压缩单元，超过5K开始下一个压缩单元。</p><p>内容由内容长度(4字节，大端模式存储)、各个log组成。</p><h3 id="先睹为快、窥探日志数据"><a href="#先睹为快、窥探日志数据" class="headerlink" title="先睹为快、窥探日志数据"></a>先睹为快、窥探日志数据</h3><p>如果看懂了上节内容，你有没有想窥探下logan内存结构的欲望？</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_memory.png" alt="日志数据"></p><ol><li>0x0D  头起始标志  </li><li>0x0028  = 40  头长度</li><li>0x7B ~0x7D00  头内容</li><li>0x0E  头结束标志</li><li>—这里是分割线， 表示头结束，下面是日志体—</li><li>0x000055  tatal_len 日志体总长度</li><li>0x01 协议起始标志位</li><li>0x00000050 内容长度</li><li>0x14D7~0x465C  多个压缩加密后的日志    </li><li>0x00  协议结束标志位</li></ol><p>看了logan日志存储格式，我自己总结了下，其实就是一个三级结构：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_three_struct.png" alt="logan三级结构"></p><p>你可以回头想想，所有的字段都服务于这个三级结构，如果你按照三级结构的思路理解，这里就没有多余的信息。 </p><blockquote><p>我首次看，就觉得怎么这么多len信息，是否是多余的呢。</p></blockquote><h2 id="日志追加机制"><a href="#日志追加机制" class="headerlink" title="日志追加机制"></a>日志追加机制</h2><h3 id="追加机制"><a href="#追加机制" class="headerlink" title="追加机制"></a>追加机制</h3><p>下面我们就可以进一步深入logan日志增加的机制了，其实，追加日志主要靠四个指针就完成了。</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_pointer.png" alt="4个关键指针的展示"></p><p>说明下这四个指针的作用：</p><ol><li>buffer_point 标记mmap的起始地址，基本固定不变。</li><li>total_point日志体的起始位置指针 ，这个指针目的是当有新日志添加的时候，更新total_point后面的total_len属性。位置也不变化。</li><li>content_lent_point内容起始位置指针，一个压缩单元完事后，前进一次。它的主要作用是，当增加log后，更新后面的content_len的内容。其实就是指向上面三级结构中的第二级结构</li><li>last_point 添加日志起始指针 ,每次新的日志都追加到last_point处，追加完后，更新last_point为下一个追加位置。 </li></ol><p>上面多次提到了压缩单元，我们用下面的图说明下压缩单元递增的思路：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_zip_unit.png" alt="5K压缩单元递增示意图"></p><p>上面是一个压缩单元完成后，开始新压缩单元的示意图。我们可以观察content_lent_point、last_point两个指针移动的情况。(箭头从 蓝色-&gt; 蓝色-&gt; 绿色 的变化过程)</p><h3 id="关键节点"><a href="#关键节点" class="headerlink" title="关键节点"></a>关键节点</h3><p>通过上面我们了解了三个基本的关键节点：</p><ol><li><p>5k  一个压缩单元的大小</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOGAN_MAX_GZIP_UTIL <span class="number">5</span> * <span class="number">1024</span> <span class="comment">//压缩单元的大小</span></span><br></pre></td></tr></table></figure></li><li><p>容量(初始指定10M)的1/3  写文件的节点</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGAN_WRITEPROTOCOL_DEVIDE_VALUE <span class="number">3</span> <span class="comment">//多少分之一写入</span></span><br><span class="line">buffer_length / LOGAN_WRITEPROTOCOL_DEVIDE_VALUE</span><br></pre></td></tr></table></figure></li><li><p>10M 日志文件总大小</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint64_t file_max = <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>感觉也不是很复杂，就是用四个指针标记修改的位置，有新的日志来了，就追加到last_point处。</p><h2 id="核心数据结构"><a href="#核心数据结构" class="headerlink" title="核心数据结构"></a>核心数据结构</h2><p>logan的结构、存储本质、追加日志机制都讲完了，接着看看代码是怎么实现的。logan用一个全局的数据结构管理所有的数据，这个数据结构定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">logan_model_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> total_len; <span class="comment">//数据长度</span></span><br><span class="line">    <span class="keyword">char</span> *file_path; <span class="comment">//文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_malloc_zlib;</span><br><span class="line">    z_stream *strm;</span><br><span class="line">    <span class="keyword">int</span> zlib_type; <span class="comment">//压缩类型</span></span><br><span class="line">    <span class="keyword">char</span> remain_data[<span class="number">16</span>]; <span class="comment">//剩余空间</span></span><br><span class="line">    <span class="keyword">int</span> remain_data_len; <span class="comment">//剩余空间长度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_ready_gzip; <span class="comment">//是否可以gzip</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> file_stream_type; <span class="comment">//文件流类型</span></span><br><span class="line">    FILE *file; <span class="comment">//文件流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> file_len; <span class="comment">//文件大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *buffer_point; <span class="comment">//缓存的指针 (不变)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *last_point; <span class="comment">//最后写入位置的指针</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *total_point; <span class="comment">//总数的指针 (可能变) , 给c看,低字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *content_lent_point;<span class="comment">//协议内容长度指针 , 给java看,高字节</span></span><br><span class="line">    <span class="keyword">int</span> content_len; <span class="comment">//内容的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> aes_iv[<span class="number">16</span>]; <span class="comment">//aes_iv</span></span><br><span class="line">    <span class="keyword">int</span> is_ok;</span><br><span class="line"></span><br><span class="line">&#125; cLogan_model;</span><br></pre></td></tr></table></figure><p>感觉定义的很乱，我整理了下 ：</p><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_model.png" alt="数据结构"></p><ol><li><p>日志文件相关的：有日志文件的路径file_path、文件流状态file_stream_type、文件流file、文件内容的大小file_len。其中文件流状态file_stream_type可选的取值：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_NONE 0</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_OPEN 1</span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">define</span> LOGAN_FILE_CLOSE 2</span></span><br></pre></td></tr></table></figure></li><li><p>压缩相关的： is_malloc_zlib 表示strm是否申请空间 ,zlib_type 压缩状态，is_ready_gzip压缩是否准备好。 zlib_type可以的取值如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_INIT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_ING  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_END  3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGAN_ZLIB_FAIL 4</span></span><br></pre></td></tr></table></figure></li><li><p>mmap操作相关的，记录日志的长度信息、四个指针的信息。</p></li><li>下面是加密相关的，DES加密是16字节为一个单元，如果日志压缩后，长度取余，不足16字节的内容就不参与加密了，等着下次日志，一起加密。所以remain_data、remain_data_len表示剩下的未加密的压缩过的日志数据。aes_iv 表示DES加密的初始向量。</li><li>is_ok 表示整个logan是否是正常状态。</li></ol><p>我将上面的数据分类主要的5类，到了哪一步，关注哪一步就ok了。分类后，就很好理解了。</p><h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>下面我列举了logan C语言层的4个核心接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cache_dirs, <span class="keyword">const</span> <span class="keyword">char</span> *path_dirs, <span class="keyword">int</span> max_file, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_key16, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_iv16)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_write</span><span class="params">(<span class="keyword">int</span> flag, <span class="keyword">char</span> *<span class="built_in">log</span>, <span class="keyword">long</span> <span class="keyword">long</span> local_time, <span class="keyword">char</span> *thread_name, <span class="keyword">long</span> <span class="keyword">long</span> thread_id,<span class="keyword">int</span> is_main)</span></span></span><br><span class="line"><span class="function">             </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_flush</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><p>下面一一讲解下，所有的代码都是缩减代码。方便理解函数完成的主体工作。</p><h3 id="clogan-init"><a href="#clogan-init" class="headerlink" title="clogan_init"></a>clogan_init</h3><p>clogan_init 主要功能是：</p><ol><li>打开映射内存</li><li>如果存在上次程序结束后没有写入文件的日志，将上次日志写入到文件中。使本次以一个干净的环境开始。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">clogan_init(<span class="keyword">const</span> <span class="keyword">char</span> *cache_dirs, <span class="keyword">const</span> <span class="keyword">char</span> *path_dirs, <span class="keyword">int</span> max_file, <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_key16,</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *encrypt_iv16) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///保存秘钥、初始向量</span></span><br><span class="line">    aes_init_key_iv(encrypt_key16, encrypt_iv16);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 构建内存映射文件路径</span></span><br><span class="line">    <span class="keyword">char</span> *cache_path = <span class="built_in">malloc</span>(total);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != cache_path) &#123;</span><br><span class="line">        _mmap_file_path = cache_path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 构建日志目录</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != dirs) &#123;</span><br><span class="line">        _dir_path = dirs; <span class="comment">//日志写入的文件目录</span></span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 打开内存映射</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == _logan_buffer) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == _cache_buffer_buffer) &#123;</span><br><span class="line">            flag = open_mmap_file_clogan(cache_path, &amp;_logan_buffer, &amp;_cache_buffer_buffer);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="comment">///读取内存映射中的日志，写入到文件中，准备开始一个干净的日志环境。</span></span><br><span class="line">    <span class="keyword">if</span> (is_init_ok) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == LOGAN_MMAP_MMAP) <span class="comment">//MMAP的缓存模式,从缓存的MMAP中读取数据</span></span><br><span class="line">            read_mmap_data_clogan(_dir_path);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clogan-open"><a href="#clogan-open" class="headerlink" title="clogan_open"></a>clogan_open</h3><p>clogan_open 主要工作是：</p><ol><li>初始化zlib</li><li>初始化加密模块</li><li>初始化全局数据logan_model</li></ol><p>代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int clogan_open(const char *pathname) &#123;</span><br><span class="line"></span><br><span class="line">    is_open_ok = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///全局的logan_model 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (NULL != logan_model) &#123; <span class="comment">//回写到日志中</span></span><br><span class="line">     </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        logan_model = malloc(sizeof(cLogan_model));</span><br><span class="line">        <span class="keyword">if</span> (NULL != logan_model) &#123;</span><br><span class="line">            memset(logan_model, <span class="number">0</span>, sizeof(cLogan_model));</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>file_path = temp_file;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>buffer_point = _logan_buffer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// zlib 的初始化</span></span><br><span class="line">    init_zlib_clogan(logan_model)</span><br><span class="line">    </span><br><span class="line">   <span class="comment">///添加头信息</span></span><br><span class="line">   add_mmap_header_clogan(back_data, logan_model);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span><span class="function"><span class="title">last_point</span> = logan_model-&gt;</span>total_point + LOGAN_MMAP_TOTALLEN;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>total_point = _logan_buffer;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>total_len = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span><span class="function"><span class="title">last_point</span> = logan_model-&gt;</span>total_point + LOGAN_MMAP_TOTALLEN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///设置关键指针信息，长度信息</span></span><br><span class="line">    restore_last_position_clogan(logan_model);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 加密信息初始化</span></span><br><span class="line">    init_encrypt_key_clogan(logan_model);</span><br><span class="line">    <span class="function"><span class="title">logan_model</span>-&gt;</span>is_ok = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (is_open_ok) &#123;</span><br><span class="line">        back = CLOGAN_OPEN_SUCCESS;</span><br><span class="line">    &#125; </span><br><span class="line">    return back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clogan_open 主要完成：初始化全局的logan_model、init_zlib_clogan、init_encrypt_key_clogan 三个工作。</p><h3 id="clogan-write"><a href="#clogan-write" class="headerlink" title="clogan_write"></a>clogan_write</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>clogan_write 顾名思义，就是写入日志，这里用简单的树形结构描述它的过程。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">├── clogan_write</span><br><span class="line">│   └── clogan_write_section分片写入</span><br><span class="line">│       └── clogan_write2</span><br><span class="line">│           ├── <span class="number">1.</span> clogan_zlib_compress</span><br><span class="line">│           │   └── clogan_zlib</span><br><span class="line">│           │       ├── aes_encrypt_clogan</span><br><span class="line">│           │       └── deflate</span><br><span class="line">│           ├── <span class="number">2.</span> update_length_clogan(logan_model);<span class="comment">///写完日志，更新长度信息</span></span><br><span class="line">│           ├── <span class="number">3.</span> 如果一个压缩单元完事，结束这个压缩单元</span><br><span class="line">│           │   ├── clogan_zlib_end_compress(logan_model)</span><br><span class="line">│           │   ├── aes_encrypt_clogan 加密剩余部分</span><br><span class="line">│           │   └── update_length_clogan(logan_model)</span><br><span class="line">│           ├── <span class="number">4.</span> 如果mmap的大小大于总容量的<span class="number">1</span>/<span class="number">3</span></span><br><span class="line">│           │   └── write_flush_clogan();写入文件</span><br><span class="line">│           └── <span class="number">5.</span> 如果一个单元完事，还要做下面工作，开始下一个压缩单元</span><br><span class="line">│               ├── init_encrypt_key_clogan(logan_model)</span><br><span class="line">│               ├── init_zlib_clogan(logan_model)</span><br><span class="line">│               ├── logan_model-&gt;content_len = <span class="number">0</span></span><br><span class="line">│               ├── logan_model-&gt;remain_data_len = <span class="number">0</span></span><br><span class="line">│               └── restore_last_position_clogan(logan_model)</span><br></pre></td></tr></table></figure><h4 id="协议分析"><a href="#协议分析" class="headerlink" title="协议分析"></a>协议分析</h4><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_protocal.png" alt="协议"></p><h3 id="clogan-flush"><a href="#clogan-flush" class="headerlink" title="clogan_flush"></a>clogan_flush</h3><p>clogan_flush 将mmap中的日志强制写入到文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clogan_flush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    write_flush_clogan();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>clogan_flush 调用了write_flush_clogan。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> write_flush_clogan() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span> (logan_model-&gt;total_len &gt; LOGAN_WRITEPROTOCOL_HEAER_LENGTH) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">point</span> = logan_model-&gt;total_point;</span><br><span class="line">        <span class="built_in">point</span> += LOGAN_MMAP_TOTALLEN;</span><br><span class="line">        write_dest_clogan(<span class="built_in">point</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), logan_model-&gt;total_len, logan_model);</span><br><span class="line">        clear_clogan(logan_model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>write_flush_clogan调用write_dest_clogan将mmap中的数据写入到文件中，同时调用clear_clogan清空全局数据logan_model的状态。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件写入磁盘、更新文件大小</span></span><br><span class="line">void write_dest_clogan(void *point, size_t size, size_t length, cLogan_model *loganModel) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">fwrite</span>(point, sizeof(char), logan_model-&gt;</span><span class="function"><span class="title">total_len</span>, logan_model-&gt;</span>file);<span class="comment">//写入到文件中</span></span><br><span class="line">    <span class="function"><span class="title">fflush</span>(logan_model-&gt;</span>file);</span><br><span class="line">    <span class="function"><span class="title">loganModel</span>-&gt;</span><span class="function"><span class="title">file_len</span> += loganModel-&gt;</span>total_len; <span class="comment">//修改文件大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>美团的<a href="https://mp.weixin.qq.com/s/ojUZjT4YhUWZ3jh37UtJmg" rel="external nofollow noopener noreferrer" target="_blank">Logan：美团点评移动端基础日志库揭秘</a>说，有下面的缺点：</p><ol><li>卡顿，影响性能</li><li>日志丢失</li><li>安全性</li><li>日志分散</li></ol><p>我看了logan的源码，logan确实解决了上面的问题，反过来，logan有下面的优点：</p><ol><li>不卡顿，性能好</li><li>日志不丢失</li><li>安全</li><li>日志集中</li></ol><h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><p>logan主要实现了日志的本地存储功能，考虑的很多边界情况，我觉得应该可以使用，但是还存在下面的问题 ：</p><ol><li>没有日志回捞功能(没有开源，这个工作主要在服务端，客户端也没发现对应的接口)</li><li>没有主动上报功能(主动上报有简单的实现，这个应该也归结为使用者的功能吧)</li><li>日志大于10M的情况没有处理，需要自己完善。</li></ol><p>没有写的证据在这里：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_file_exist_clogan(logan_model-&gt;file_path)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (logan_model-&gt;file_len &gt; max_file_len) &#123;</span><br><span class="line">        printf_clogan(<span class="string">"clogan_write &gt; beyond max file , cant write log\n"</span>);</span><br><span class="line">        back = CLOAGN_WRITE_FAIL_MAXFILE;</span><br><span class="line">        <span class="keyword">return</span> back;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果文件的大小超过了10M，直接返回了 ，不在写入日志。</p><h2 id="胡思乱想"><a href="#胡思乱想" class="headerlink" title="胡思乱想"></a>胡思乱想</h2><p><img src="/wiki/IOS/开源库学习/logan/logan/logan_future.png" alt="胡思乱想">  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://mp.weixin.qq.com/s/ojUZjT4YhUWZ3jh37UtJmg" rel="external nofollow noopener noreferrer" target="_blank">Logan：美团点评移动端基础日志库揭秘</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文旨在通过logan源码，分析logan的整体结构、存储结构、内部的数据结构、主要的C接口、优点、存在的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="logan" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/logan/"/>
    
    
      <category term="logan" scheme="http://yoursite.com/tags/logan/"/>
    
  </entry>
  
  <entry>
    <title>mmap原理之详解(转载)</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/mmap/union%E5%AE%9A%E4%B9%89%E7%9A%84%E5%89%AF%E6%9C%AC/"/>
    <id>http://yoursite.com/wiki/编程基础/mmap/union定义的副本/</id>
    <published>2018-12-19T01:07:12.000Z</published>
    <updated>2018-12-19T03:15:58.822Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>mmap基础概念</li><li>mmap内存映射原理</li><li>mmap和常规文件操作的区别</li><li>mmap优点总结</li><li>mmap相关函数</li><li>mmap使用细节</li><li>在上面的知识前提下我们下面看看如果大小不是页的整倍数的具体情况</li></ol><p>文章出处：<a href="https://blog.csdn.net/qq_36675830/article/details/79283113" rel="external nofollow noopener noreferrer" target="_blank">mmap原理之详解</a></p><a id="more"></a><h2 id="mmap基础概念"><a href="#mmap基础概念" class="headerlink" title="mmap基础概念"></a>mmap基础概念</h2><p>mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;mmap基础概念&lt;/li&gt;
&lt;li&gt;mmap内存映射原理&lt;/li&gt;
&lt;li&gt;mmap和常规文件操作的区别&lt;/li&gt;
&lt;li&gt;mmap优点总结&lt;/li&gt;
&lt;li&gt;mmap相关函数&lt;/li&gt;
&lt;li&gt;mmap使用细节&lt;/li&gt;
&lt;li&gt;在上面的知识前提下我们下面看看如果大小不是页的整倍数的具体情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;文章出处：&lt;a href=&quot;https://blog.csdn.net/qq_36675830/article/details/79283113&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;mmap原理之详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程基础" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    
      <category term="mmap" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/mmap/"/>
    
    
      <category term="mmap" scheme="http://yoursite.com/tags/mmap/"/>
    
  </entry>
  
  <entry>
    <title>7. Scribble&amp; NSZombieEnabled</title>
    <link href="http://yoursite.com/wiki/IOS/crash/7_increase_Wild_Pointer/"/>
    <id>http://yoursite.com/wiki/IOS/crash/7_increase_Wild_Pointer/</id>
    <published>2018-12-13T04:18:26.000Z</published>
    <updated>2018-12-17T08:57:29.885Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><p>定位野指针的方法。</p><a id="more"></a><h2 id="野指针分析方法-Enable-Malloc-Scribble"><a href="#野指针分析方法-Enable-Malloc-Scribble" class="headerlink" title="野指针分析方法(Enable Malloc Scribble)"></a>野指针分析方法(Enable Malloc Scribble)</h2><p>因为野指针的原因发生崩溃是常常出现的事，而且比较随机。所以我们要提高野指针的崩溃率,从而帮我们快速找到有问题的代码。</p><p>对象释放后，只有出现被随机填入的数据是不可访问的时候才会必现Crash。</p><p>这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。</p><p><img src="/wiki/IOS/crash/7_increase_Wild_Pointer/10.png" alt="Enable Scribble"></p><h2 id="僵尸模式-NSZombieEnabled"><a href="#僵尸模式-NSZombieEnabled" class="headerlink" title="僵尸模式(NSZombieEnabled)"></a>僵尸模式(NSZombieEnabled)</h2><p>启用了NSZombieEnabled的话，它会用一个僵尸来替换默认的dealloc实现，也就是在引用计数降到0时，该僵尸实现会将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。</p><p>所以当启用NSZombieEnabled时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接受到得信息，然后跳入调试器，这样你就可以查看到底是哪里出了问题。</p><p>所以这时一般崩溃的原因是：调用了已经释放的内存空间，或者说重复释放了某个地址空间。</p><p>如何找出问题</p><h3 id="NSZombieEnabled"><a href="#NSZombieEnabled" class="headerlink" title="NSZombieEnabled"></a>NSZombieEnabled</h3><p>打开NSZombieEnabled之后，如果遇到对应的崩溃类型既调用了已经释放的内存空间，或者说重复释放了某个地址空间。那么就能在GDB中看到对应的输出信息。</p><p>比如会出现如下这样的问题：<code>[__NSArrayM addObject:]: message sent to deallocated instance 0x7179910</code></p><h3 id="MallocStackLoggingNoCompact"><a href="#MallocStackLoggingNoCompact" class="headerlink" title="MallocStackLoggingNoCompact"></a>MallocStackLoggingNoCompact</h3><p>如果崩溃是发生在当前调用栈，通过上面的做法，系统就会把崩溃原因定位到具体代码中。但是，如果崩溃不在当前调用栈，系统就仅仅只能把崩溃地址告诉我们，而没办法定位到具体代码，这样我们也没法去修改错误。这时就可以修改scheme，让xcode记录每个地址alloc的历史，这样我们就可以用命令把这个地址还原出来。如图：(跟设置<code>NSZombieEnabled</code>一样，添加<code>MallocStackLoggingNoCompact</code>，并且设置为YES)</p><p><img src="/wiki/IOS/crash/7_increase_Wild_Pointer/11.png" alt="Enable Scribble"></p><p>这样，当出现崩溃原因是message sent to deallocated instance 0x7179910，我们可以使用以下命令，把内存地址还原：</p><p><code>(gdb) nfo malloc-history 0x7179910</code></p><p>也可以使用下面的命令<code>(gdb) shell malloc_history {pid/partial-process-name} {address}</code></p><h2 id="Enable-Address-Sanitizer（地址消毒剂）"><a href="#Enable-Address-Sanitizer（地址消毒剂）" class="headerlink" title="Enable Address Sanitizer（地址消毒剂）"></a>Enable Address Sanitizer（地址消毒剂）</h2><p>设置这个参数后就能看到一些更详细的错误信息提示，甚至会有内存使用情况的展示。</p><p>C语言是一门危险的语言，内存安全是一个主要的问题。C语言中根本没有内存安全可言。像下面的代码，会被正常的编译，而且可能正常运行：<code>char *ptr = malloc(5);ptr[12] = 0;</code>对于内存安全的验证已经有一些解决方案了。如Clang的静态代码分析，可以从代码中查找特定类型的内存安全问题。如Valgrind之类的程序可以在运行时检测到不安全的内存访问。</p><p>Address Sanitizer是另外一种解决方案。它使用了一种新的方法，有利有弊。但仍不失为一个查找代码问题的有力工具。</p><p>这类工具的理论依据是：访问内存时，通过比较访问的内存和程序实际分配的内存，验证内存访问的有效性，从而在bug发生时就检测到它们，而不会等到副作用产生时才有所察觉。</p><p>malloc函数总是最少分配16个字节。为了储存针对标准malloc的内存的保护，需要分配内存到16字节的范围内，因此，若分配的内存大小不是16字节的整数倍，余出的几个字节将不受保护。</p><p>Address Sanitizer会追踪受限内存，使用了一种简单但是很巧妙的方法：它在进程的内存空间上保存了一个固定的区域，叫做“影子内存区”。用内存消毒剂的术语来说，一个被标记为受限的内存被称作“中毒”内存。“影子内存区”会记录哪些内存字节是中毒的。通过一个简单的公式，可以将进程中的内存空间映射到“影子内存区”中，即：每8字节的正常内存块映射到一个字节的影子内存上。在影子内存上，会跟踪这8字节的“中毒状态”。</p><h2 id="Static-Analyzer（静态分析）"><a href="#Static-Analyzer（静态分析）" class="headerlink" title="Static Analyzer（静态分析）"></a>Static Analyzer（静态分析）</h2><p>Static Analyzer是一个非常好的工具去发现编译器警告不会提示的问题和一些个人的内错泄露和死存储（不会用到的赋了值的变量）错误。这个方法可能大大的提高内存使用和性能，以及提升应用的整体稳定性和代码质量。</p><p>打开方式：Xcode-&gt;Product-Analyze然后我们就能看到如下蓝色箭头所示的一些有问题的代码。</p><p><img src="/wiki/IOS/crash/7_increase_Wild_Pointer/14.png" alt="静态分析的问题"></p><h2 id="unrecognized-selector-send-to-instancd-快速定位"><a href="#unrecognized-selector-send-to-instancd-快速定位" class="headerlink" title="unrecognized selector send to instancd 快速定位"></a>unrecognized selector send to instancd 快速定位</h2><p>在debug navigator的断点栏里添加Create Symbolic Breakpoint。</p><p>在Symbolic中填写如下方法签名：-[NSObject(NSObject) doesNotRecognizeSelector:] </p><p>设置完成后再遇到类似的错误就会定位到具体的代码。</p><p><img src="/wiki/IOS/crash/7_increase_Wild_Pointer/13.png" alt="符号断点"></p><h2 id="参考的源码"><a href="#参考的源码" class="headerlink" title="参考的源码"></a>参考的源码</h2><p><a href="https://github.com/fangjinfeng/MySampleCode/tree/master/FJFZombieSnifferDemo" rel="external nofollow noopener noreferrer" target="_blank">FJFZombieSnifferDemo</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/1b804426d212?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" rel="external nofollow noopener noreferrer" target="_blank">iOS崩溃crash大解析</a><br><a href="https://www.jianshu.com/p/9fd4dc046046?utm_source=oschina-app" rel="external nofollow noopener noreferrer" target="_blank">iOS 野指针定位:野指针嗅探器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;p&gt;定位野指针的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="crash" scheme="http://yoursite.com/categories/IOS/crash/"/>
    
    
      <category term="Crash" scheme="http://yoursite.com/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>6. 如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/crash/6_increase_Wild_Pointer/"/>
    <id>http://yoursite.com/wiki/IOS/crash/6_increase_Wild_Pointer/</id>
    <published>2018-12-13T04:18:26.000Z</published>
    <updated>2018-12-17T08:49:50.981Z</updated>
    
    <content type="html"><![CDATA[<p>本文终于可以利用OC Runtime的特性，让OC野指针对象主动抛出自己的信息，某些情况下秒杀某些全系统栈Crash</p><a id="more"></a><h2 id="为什么错误地址是0x55555561？"><a href="#为什么错误地址是0x55555561？" class="headerlink" title="为什么错误地址是0x55555561？"></a>为什么错误地址是0x55555561？</h2><p>前文介绍了在内存释放后填充0x55使野指针出现后数据不能访问，从而使野指针变成了必现的方法，那这里会有一个比较奇怪的问题：我们在释放的内存上填上了0x55，但为什么大部分时候野指针Crash了，出错的地址却是0x55555561？</p><p>为了解答这个问题，我们可以先看看Crash栈，就会发现这些Crash都是在objc_msgSend上。我们知道Obj-C的对象方法调用是通过objc_msgSend进行的，我们通过野指针访问一个对象的方法也一样，其实是通过objc_msgSend给已经释放的对象发了一条消息。</p><p>而objc_msgSend的函数签名是这样：</p><p>id objc_msgSend(id self, SEL op, …)<br>我们再来看看objc_msgSend的代码:</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">libobjc.A.dylib</span>`objc_msgSend:</span><br><span class="line"> <span class="number">0x2f879f40</span> &lt;+<span class="number">0</span>&gt;: <span class="keyword">cbz </span><span class="built_in">r0</span>, <span class="number">0x2f879f7e</span> <span class="comment">; &lt;+62&gt;</span></span><br><span class="line"> <span class="number">0x2f879f42</span> &lt;+<span class="number">2</span>&gt;: <span class="keyword">ldr.w </span><span class="built_in">r9</span>, [<span class="built_in">r0</span>]</span><br><span class="line"> <span class="number">0x2f879f46</span> &lt;+<span class="number">6</span>&gt;: <span class="keyword">ldrh.w </span><span class="built_in">r12</span>, [<span class="built_in">r9</span>, <span class="number">#0xc</span>]</span><br><span class="line"> <span class="number">0x2f879f4a</span> &lt;+<span class="number">10</span>&gt;: <span class="keyword">ldr.w </span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="number">#0x8</span>]</span><br><span class="line"> <span class="number">0x2f879f4e</span> &lt;+<span class="number">14</span>&gt;: <span class="keyword">and.w </span><span class="built_in">r12</span>, <span class="built_in">r12</span>, <span class="built_in">r1</span></span><br><span class="line"> <span class="number">0x2f879f52</span> &lt;+<span class="number">18</span>&gt;: <span class="keyword">add.w </span><span class="built_in">r9</span>, <span class="built_in">r9</span>, <span class="built_in">r12</span>, <span class="keyword">lsl </span><span class="number">#3</span></span><br><span class="line"> <span class="number">0x2f879f56</span> &lt;+<span class="number">22</span>&gt;: <span class="keyword">ldr.w </span><span class="built_in">r12</span>, [<span class="built_in">r9</span>]</span><br><span class="line"> <span class="number">0x2f879f5a</span> &lt;+<span class="number">26</span>&gt;: <span class="keyword">teq.w </span><span class="built_in">r12</span>, <span class="built_in">r1</span></span><br><span class="line"> <span class="number">0x2f879f5e</span> &lt;+<span class="number">30</span>&gt;: <span class="keyword">bne </span><span class="number">0x2f879f66</span> <span class="comment">; &lt;+38&gt;</span></span><br><span class="line"> <span class="number">0x2f879f60</span> &lt;+<span class="number">32</span>&gt;: <span class="keyword">ldr.w </span><span class="built_in">r12</span>, [<span class="built_in">r9</span>, <span class="number">#0x4</span>]</span><br><span class="line"> <span class="number">0x2f879f64</span> &lt;+<span class="number">36</span>&gt;: <span class="keyword">bx </span><span class="built_in">r12</span></span><br><span class="line"> <span class="number">0x2f879f66</span> &lt;+<span class="number">38</span>&gt;: <span class="keyword">cmp.w </span><span class="built_in">r12</span>, <span class="number">#0x1</span></span><br><span class="line"> <span class="number">0x2f879f6a</span> &lt;+<span class="number">42</span>&gt;: <span class="keyword">blo </span><span class="number">0x2f879f78</span> <span class="comment">; &lt;+56&gt;</span></span><br><span class="line"> <span class="number">0x2f879f6c</span> &lt;+<span class="number">44</span>&gt;: <span class="keyword">it </span>eq</span><br><span class="line"> <span class="number">0x2f879f6e</span> &lt;+<span class="number">46</span>&gt;: <span class="keyword">ldreq.w </span><span class="built_in">r9</span>, [<span class="built_in">r9</span>, <span class="number">#0x4</span>]</span><br><span class="line"> <span class="number">0x2f879f72</span> &lt;+<span class="number">50</span>&gt;: <span class="keyword">ldr </span><span class="built_in">r12</span>, [<span class="built_in">r9</span>, <span class="number">#8</span>]!</span><br><span class="line"> <span class="number">0x2f879f76</span> &lt;+<span class="number">54</span>&gt;: <span class="keyword">b </span><span class="number">0x2f879f5a</span> <span class="comment">; &lt;+26&gt;</span></span><br><span class="line"> <span class="number">0x2f879f78</span> &lt;+<span class="number">56</span>&gt;: <span class="keyword">ldr.w </span><span class="built_in">r9</span>, [<span class="built_in">r0</span>]</span><br><span class="line"> <span class="number">0x2f879f7c</span> &lt;+<span class="number">60</span>&gt;: <span class="keyword">b </span><span class="number">0x2f87a1c0</span> <span class="comment">; _objc_msgSend_uncached</span></span><br><span class="line"> <span class="number">0x2f879f7e</span> &lt;+<span class="number">62</span>&gt;: <span class="keyword">mov.w </span><span class="built_in">r1</span>, <span class="number">#0x0</span></span><br><span class="line"> <span class="number">0x2f879f82</span> &lt;+<span class="number">66</span>&gt;: <span class="keyword">bx </span><span class="built_in">lr</span></span><br></pre></td></tr></table></figure><p>我们可以结合Obj-C类的内存布局再来解读一下上面的汇编代码（节选于Obj-C类的源代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line"> <span class="comment">// Class ISA;</span></span><br><span class="line"> Class superclass;</span><br><span class="line"> <span class="keyword">cache_t</span> cache;</span><br><span class="line"> <span class="keyword">uintptr_t</span> data_NEVER_USE; <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class_rw_t</span> *data() &#123;</span><br><span class="line"> <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(data_NEVER_USE &amp; ~CLASS_FAST_FLAG_MASK);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">uintptr_t</span> flags = (<span class="keyword">uintptr_t</span>)data_NEVER_USE &amp; CLASS_FAST_FLAG_MASK;</span><br><span class="line"> data_NEVER_USE = (<span class="keyword">uintptr_t</span>)newData | flags;</span><br><span class="line"> &#125;</span><br><span class="line">……..</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *<span class="title">buckets</span>;</span></span><br><span class="line"> <span class="keyword">mask_t</span> shiftmask;</span><br><span class="line"> <span class="keyword">mask_t</span> occupied;</span><br><span class="line">……..</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"> <span class="keyword">cache_key_t</span> key;</span><br><span class="line"> IMP imp;</span><br><span class="line">…...</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br></pre></td></tr></table></figure><p>根据苹果的函数调用约定，objc_msgSend被调用的时候，寄存器对应关系：r0是对象本身self，r1是sel，r2和r3是参数。根据objc_class的声明，我们可以知道：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x2f879f40</span> &lt;+<span class="number">0</span>&gt;: cbz <span class="built_in">r0</span>, <span class="number">0x2f879f7e</span> //如果self为<span class="number">0</span>就跳转到<span class="number">0x2f879f7e</span>。给nil发消息的话就什么都不做</span><br><span class="line"><span class="number">0x2f879f42</span> &lt;+<span class="number">2</span>&gt;: ldr.w <span class="built_in">r9</span>, [<span class="built_in">r0</span>] //取对象的类到<span class="built_in">r9</span></span><br><span class="line"><span class="number">0x2f879f46</span> &lt;+<span class="number">6</span>&gt;: ldrh.w <span class="built_in">r12</span>, [<span class="built_in">r9</span>, #<span class="number">0xc</span>] //取类的偏移#<span class="number">0xc</span>的数据到<span class="built_in">r12</span>，也就是shiftmask的值</span><br><span class="line"><span class="number">0x2f879f4a</span> &lt;+<span class="number">10</span>&gt;: ldr.w <span class="built_in">r9</span>, [<span class="built_in">r9</span>, #<span class="number">0x8</span>] //取类的偏移#<span class="number">0x8</span>的成员到<span class="built_in">r9</span>，也即是cache</span><br><span class="line"><span class="number">0x2f879f4e</span> &lt;+<span class="number">14</span>&gt;: <span class="keyword">and</span>.w <span class="built_in">r12</span>, <span class="built_in">r12</span>, <span class="built_in">r1</span> //<span class="built_in">r1</span>和shiftmask与，放到<span class="built_in">r12</span>,<span class="built_in">r1</span>是参数一，也就是sel，用来计算sel的index</span><br><span class="line"><span class="number">0x2f879f52</span> &lt;+<span class="number">18</span>&gt;: <span class="keyword">add</span>.w <span class="built_in">r9</span>, <span class="built_in">r9</span>, <span class="built_in">r12</span>, <span class="keyword">lsl</span> #<span class="number">3</span> //左移<span class="number">3</span>位就是乘<span class="number">8</span>，<span class="number">8</span>是索引项 bucket_t的宽度，<span class="built_in">r12</span>是cache索引，<span class="built_in">r9</span>就cache的位置，<span class="built_in">r9</span>+<span class="built_in">r12</span>*<span class="number">8</span>，就是当前sel对应的bucket_t缓存</span><br><span class="line"><span class="number">0x2f879f56</span> &lt;+<span class="number">22</span>&gt;: ldr.w <span class="built_in">r12</span>, [<span class="built_in">r9</span>] //取缓存bucket_t</span><br><span class="line"><span class="number">0x2f879f5a</span> &lt;+<span class="number">26</span>&gt;: teq.w <span class="built_in">r12</span>, <span class="built_in">r1</span> //判断缓存项是不是要找的sel key==sel？</span><br><span class="line"><span class="number">0x2f879f5e</span> &lt;+<span class="number">30</span>&gt;: bne <span class="number">0x2f879f66</span> //不是的话就要查找sel</span><br><span class="line"><span class="number">0x2f879f60</span> &lt;+<span class="number">32</span>&gt;: ldr.w <span class="built_in">r12</span>, [<span class="built_in">r9</span>, #<span class="number">0x4</span>] //是的话就取出imp</span><br><span class="line"><span class="number">0x2f879f64</span> &lt;+<span class="number">36</span>&gt;: <span class="built_in">bx</span> <span class="built_in">r12</span> //调sel的实现，跳到imp里面去执行</span><br></pre></td></tr></table></figure><p>其实上面的代码就是从缓存中找sel的实现的过程，而错误地址之所以是0x55555561是因为ldrh.w r12, [r9, #0xc]这行指令。我们用0x55555555覆盖了对象的isa指针，当发生OC调用查找缓存0x55555555+0xc取shiftmask的时候，发现这个地址不可读，于是CPU抛出了异常。</p><h2 id="怎么获取野指针的更多异常数据？"><a href="#怎么获取野指针的更多异常数据？" class="headerlink" title="怎么获取野指针的更多异常数据？"></a>怎么获取野指针的更多异常数据？</h2><p>弄清楚上述问题后，又有一个问题：既然0x55555555是被当成了类的指针使用，那假如我们用指定的类覆盖这个指针，是不是就可以执行我们指定类的方法呢？</p><p>进一步说就是在发生野指针调用的时候，我们是不是可以控制CPU的行为？说起来有点像溢出攻击，利用shellcode覆盖函数返回值，一旦我们在出错的时候控制了CPU就可以获取更多异常信息，比如是哪个类，调了什么方法，对象的地址之类。</p><p>先解决几个关键问题：</p><ol><li><p>覆盖成什么？<br>我们需要自己写一个类，用它的isa来替换已经释放的对象的isa。如果不出我们所料，我们用自己的类覆盖之后，之前调用的sel就换成了调用我们自己的类的某个sel。这样，只要我们指定的类也实现这个方法，就可以执行我们需要执行的代码，然后在里面获取我们需要的信息。当然，我们无法预料野指针对象会在调用哪个函数时发生Crash，好在我们可以利用runtime的重定向特性了转到我们自己的代码里面去。</p></li><li><p>怎么覆盖isa？<br>object_setClass可以替换一个类的isa，但是试了一下，发生死锁！根据Obj-C对象的内存布局，对象的第一个数据就是isa，这里我们可以直接用自己的类指针替换它，反正是已经释放的内存，随便我们怎么玩。<br>总之，还是很简单，这个类就是下面这样:</p></li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DPCatcher </span>: NSObject</span><br><span class="line"><span class="variable">@property</span> (readwrite,assign,nonatomic) Class origClass;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> DPCatcher</span><br><span class="line">- (id)<span class="attribute">forwardingTargetForSelector</span>:(SEL)aSelector&#123;</span><br><span class="line"> <span class="selector-tag">NSLog</span>(@<span class="string">"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(self.origClass),self,NSStringFromSelector(aSelector));</span><br><span class="line"> <span class="selector-tag">abort</span>();</span><br><span class="line"> <span class="selector-tag">return</span> <span class="selector-tag">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">-</span>(void)<span class="selector-tag">dealloc</span>&#123;</span><br><span class="line"> <span class="selector-tag">NSLog</span>(@<span class="string">"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(self.origClass),self,@<span class="string">"dealloc"</span>);</span><br><span class="line"> <span class="selector-tag">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(oneway void)<span class="selector-tag">release</span>&#123;</span><br><span class="line"> <span class="selector-tag">NSLog</span>(@<span class="string">"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(self.origClass),self,@<span class="string">"release"</span>);</span><br><span class="line"> <span class="selector-tag">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">-</span> (instancetype)<span class="selector-tag">autorelease</span>&#123;</span><br><span class="line"> <span class="selector-tag">NSLog</span>(@<span class="string">"发现objc野指针:%s::%p=&gt;%@"</span>,class_getName(self.origClass),self,@<span class="string">"autorelease"</span>);</span><br><span class="line"> <span class="selector-tag">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>注意：对象的release、dealloc等函数要特殊处理一下，因为任何对象都有这些方法，不会执行重定向。</p><p>然后，我们的free函数改成下面这样（去掉了一些多余代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DPFree</span><span class="params">(<span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">size_t</span> memSiziee=malloc_size(p);</span><br><span class="line"> <span class="keyword">if</span> (memSiziee&gt;sDPCatchSize) &#123;<span class="comment">//有足够的空间才覆盖</span></span><br><span class="line"> id obj=(id)p;</span><br><span class="line"> Class origClass=object_getClass(obj); <span class="comment">//判断是不是objc对象 ，registeredClasses里面有所有的类，如果可以查到，说明是objc类</span></span><br><span class="line"> <span class="keyword">if</span> (origClass &amp;&amp; CFSetContainsValue(registeredClasses, origClass)) &#123;</span><br><span class="line"> <span class="built_in">memset</span>(obj, <span class="number">0x55</span>, memSiziee);</span><br><span class="line"> <span class="built_in">memcpy</span>(obj, &amp;sDPCatchIsa, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));<span class="comment">//把我们自己的类的isa复制过去</span></span><br><span class="line"> </span><br><span class="line"> DPCatcher* bug=(DPCatcher*)p;</span><br><span class="line"> bug.origClass=origClass;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(p, <span class="number">0x55</span>, memSiziee);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="built_in">memset</span>(p, <span class="number">0x55</span>, memSiziee);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化的时候获取所有类信息，获取填充类的的大小:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">registeredClasses = <span class="built_in">CFSetCreateMutable</span>(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"> Class *classes = objc_copyClassList(&amp;count);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line"> <span class="built_in">CFSetAddValue</span>(registeredClasses, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(classes[i]));</span><br><span class="line"> &#125;</span><br><span class="line"> free(classes);</span><br><span class="line"> classes=<span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"> sDPCatchIsa=objc_getClass(<span class="string">"DPCatcher"</span>);</span><br><span class="line"> </span><br><span class="line"> sDPCatchSize=class_getInstanceSize(sDPCatchIsa);</span><br></pre></td></tr></table></figure><p>用下面简单的代码试一下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView* testObj=<span class="comment">[<span class="comment">[UIView alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[testObj release]</span>;</span><br><span class="line"><span class="comment">[testObj setNeedsLayout]</span>;</span><br></pre></td></tr></table></figure><p>发生野指针的类、对象地址和访问的方法就这样可以被打印出来！</p><p><img src="/wiki/IOS/crash/6_increase_Wild_Pointer/forward_crash.png" alt="野指针自报信息"></p><p>上面这两个Crash如果不能重现几乎是无解！但是，加上我们的野指针定位神器之后再看看，类名和地址都可以打出来了，解决起来就不是什么问题了。</p><p>说明：</p><ol><li><p>我们打印出了野指针对象的名字和地址，当这个类的对象比较少时，对查找问题有很大的用处（如果是自定义的类出现野指针，一般还是比较容易找到问题），但是如果是一些经常出现的类，比如nsarray，定位起来还是比较麻烦。这个时候建议试一下xcode的malloc history工具，或者可以自己实现一个类似记录内存使用记录的工具，因为有内存申请和释放的记录，只要重现一次就可以精确定位野指针。</p></li><li><p>如果出现dealloc的使用错误，例如先[super dealloc]，然后release成员变量，那么就会出现崩溃的现象，且此时对象的地址为0x55555555。这是因为[super dealloc]只会释放对应的内存，但其成员的内存不会被release而变成了0x555555。 这种问题场景比较简单，一旦发生绝对是必现的，修复也比较容易。</p></li></ol><p>后记</p><p>写到这里，关于iOS野指针随机问题定位的三篇文章就写完了，特别说一下，文中提到的方法虽然可以提高野指针的曝光率和定位精度，但并不是万能，比如下面这几种情况，可能并不一定适用：</p><ol><li>未触发出现野指针的逻辑：比如说一个有问题的代码，只有在特殊的逻辑下才会有野指针问题，如果我们没有触发这个逻辑，肯定也是无法暴露出这个问题的。这种情况建议还是提高测试的场景覆盖。</li><li>产生野指针和使用野指针的时间间隔太长：时间太长的话，很可能我们保留的指针已经被释放了。</li><li>APP内存消耗大，会降低曝光率。因为内存消耗大的时候，我们保留的指针数量必然减少，而且保留的时间也会更短。</li></ol><ol><li><p>free之前先填上 0x55 ，这个0x55有什么具体含义吗？<br>答：实际上填写数据的关键在于填写数据后其地址指向不可读的内存。而填写0x55，和前面提到的出现异常情况的对象地址0x555555连接起来被当成指针使用的话，就会被识别为0x55555555，而CPU访问这个地址就会抛出异常。<br>另外一点，就是方便区分野指针，例如在Xcode启用Enable Scribble时，指定alloc之后填写的地址为0xaa，防止内存初始化就使用，也是为了方便和free之后的内存做区分。</p></li><li><p>这个方法对于arc和非arc是否都可以用？<br>答：都可以，不过都是arc的话应该比较少出现野指针吧。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文终于可以利用OC Runtime的特性，让OC野指针对象主动抛出自己的信息，某些情况下秒杀某些全系统栈Crash&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="crash" scheme="http://yoursite.com/categories/IOS/crash/"/>
    
    
      <category term="Crash" scheme="http://yoursite.com/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>5. 如何定位Obj-C野指针随机Crash(二):让非必现Crash变成必现(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/crash/5_increase_Wild_Pointer/"/>
    <id>http://yoursite.com/wiki/IOS/crash/5_increase_Wild_Pointer/</id>
    <published>2018-12-13T02:18:26.000Z</published>
    <updated>2018-12-17T08:48:26.830Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容如下：</p><p>注：本文主要介绍一种延迟内在释放的技术，继续上一篇提到的如何提高野指针Crash的概率（可以文章底部点击“阅读原文”，查看上一篇文章）。另外，本文探讨的环境是在非arc情况下。</p><a id="more"></a><h2 id="只有小概率Crash肿么办？"><a href="#只有小概率Crash肿么办？" class="headerlink" title="只有小概率Crash肿么办？"></a>只有小概率Crash肿么办？</h2><p>之前介绍了一种在内存释放后填充0x55使野指针后数据不能访问，从而使某些野指针从不必现Crash变成了必现。然而，我们早就看穿了一切，这个事情不会那么顺利的。</p><p>加上上次的代码之后，再试试下面的代码：</p><p>其实这就是上一篇文中留下了几个问题之一，如果我们填充0x55后内存又被别的内存覆盖了，最终还是会出现随机Crash。而在真实环境中，这种情况是非常常见的。</p><p>我们再梳理一下这个过程：</p><ol><li>我们在即将要释放的填了0x55，之后调用了free真正释放，内存被系统回收。</li><li>这个时候系统随时可能把这片内存给别的代码使用，也就是说我们的0x55被再次写上随机的数据（在这里再强调一下，访问野指针是不会Crash的，只有野指针指向的地址被写上了有问题的数据才会引发Crash）。</li><li>假如释放的内存上又填上了另一个对象的指针，而那个对象也有同样的一个方法，那很可能只是逻辑上有问题，并不会直接Crash，甚至悄无声息地像什么事情都没发生一样。（这个地方可能会发生多种情况，可以参考之上一篇文章中的图）</li></ol><p>没有发生Crash可不是好事，因为这种情况如果后续再Crash，问题就非常难查，因为你看到的Crash栈很可能和出错的代码完全没有关联。既然这个问题这么棘手，最好还是和之前一样，让这个Crash提前暴露。</p><h2 id="继续提高Crash率"><a href="#继续提高Crash率" class="headerlink" title="继续提高Crash率"></a>继续提高Crash率</h2><p>沿着上次的思路，首先，我们要解决的问题就是怎么让系统不再往这片释放的内存上乱放东西。</p><p>要控制底层内存管理机制让它不使用这些内存可能很困难。但是，我们变通一下，简单粗暴地，我们干脆就不释放这片内存了。也就是当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据（偷笑)。</p><p>为了防止系统内存过快耗尽，还需要额外多做几件事：</p><ol><li>自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。</li><li>系统内存警告的时候，也要释放一部分内存。</li></ol><p>主要代码还是很简单的：</p><ol><li>在safe_free以及它调用的函数里面尽量不要再用带锁的函数，不然很容易导致死锁。</li><li>加上这个代码之后APP的内存占用会增大不少，拿过来测试可以，但万万不能放在正式的发布版本中。</li><li>关于性能问题，我的机器是iPhone5，跑在App里面运行，还算流畅（不同App性能可能会有些不同）。</li><li>可能由于锁的存在，会使cpu线程切换变得频繁，这样多线程的问题Crash率也可能会提升（最近遇到一个多线程引起的Crash很难重现，但我加了这个代码后就变成了必现Crash）</li></ol><p>做完这些之后拿到项目中实际验证一下，验证的版本可以是经过测试，且遗留Crash问题已经很少，但还没有对外灰度或发布的版本。</p><p>但以上代码只是雏形，其实还有很多地方可以优化，大家在试用时可以参考着优化：</p><ol><li>最好是根据机器的情况来决定偷偷保留内存的数量。</li><li>由于内存申请太过频繁，其实我们保留的内存很快就会耗尽，对于大片的内存，可以适当放过，这样可以提高保存指针的数量，防止消耗的内存过多。</li><li>有的APP自己写的都是Obj-C代码，想忽略c、c++对象的话可以过滤掉（会有办法判断的）。</li><li>如果觉得某些Obj-C类有问题，可以只保留指定的类对象，如果数量不是特别大，甚至可以干脆不释放。</li><li>……</li></ol><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>理论上，机器的内存越大，我们就可以瞒着系统不释放更多内存，野指针Crash的概率也就越大。</p><p>提前暴露问题并解决，避免事后再补，是一个很好的习惯，希望大家都能试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要内容如下：&lt;/p&gt;
&lt;p&gt;注：本文主要介绍一种延迟内在释放的技术，继续上一篇提到的如何提高野指针Crash的概率（可以文章底部点击“阅读原文”，查看上一篇文章）。另外，本文探讨的环境是在非arc情况下。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="crash" scheme="http://yoursite.com/categories/IOS/crash/"/>
    
    
      <category term="Crash" scheme="http://yoursite.com/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>4.如何定位Obj-C野指针随机Crash(一):先提高野指针Crash率(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/crash/4_increase_Wild_Pointer/"/>
    <id>http://yoursite.com/wiki/IOS/crash/4_increase_Wild_Pointer/</id>
    <published>2018-12-13T01:18:26.000Z</published>
    <updated>2018-12-17T09:00:47.359Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容如下：</p><p>欲让其灭亡先让其疯狂，我们当然不是人为制造Crash，准确地说，是使隐藏的随机性Crash暴露出来，提高测试时的Crash率，从而降低版本发布后的Crash率。</p><p>写C、C++代码的同学应该都清楚，Crash最多的原因通常有两种，一种是多线程，一种是野指针。这两种Crash都带随机性，而且这两种Crash有相当一部分都很难区分，甚至大量的Crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。</p><p>本文主要讨论的方向是Obj-C的野指针。Obj-C的野指针最常见的一种栈是objc_msgSend，从Bugly上报的Crash数据来看，objc_msgSend的量占了五分之一，这其中大多数是Obj-C野指针。当然也有相当多的Obj-C野指针不是这种表现，所以野指针的Crash体量非常惊人。</p><a id="more"></a><h2 id="为什么Obj-C野指针的Crash那么多？"><a href="#为什么Obj-C野指针的Crash那么多？" class="headerlink" title="为什么Obj-C野指针的Crash那么多？"></a>为什么Obj-C野指针的Crash那么多？</h2><p>我们有这么多自动化和人工测试流程，而且还有几轮的灰度过程，其实很多Crash场景都应该已经覆盖到了，但随机性意味着，测试的时候它没有问题，等用户用了才有问题，这种情况该怎么办？！</p><p>我觉得关键在于它的随机性，随机性问题我初略地分为两类：</p><p>第一类是跑不进出错的逻辑，执行不到出错的代码，这种可以提高测试场景覆盖度来解决。</p><p>第二类是跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致Crash，这好像要看人品了？</p><p>一说到人品就头疼啊有木有，由于上辈子做了太多善事，人品太好每次自测的时候根本不Crash有木有！</p><h2 id="野指针的随机性"><a href="#野指针的随机性" class="headerlink" title="野指针的随机性"></a>野指针的随机性</h2><p>野指针是指指向一个已删除的对象或未申请访问受限内存区域的指针。本文说的Obj-C野指针，说的是Obj-C对象释放之后指针未置空，导致的野指针（Obj-C里面一般不会出现为初始化对象的常识性错误）。</p><p>既然是访问已经释放的对象为什么不是必现Crash呢？</p><p>因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。</p><p>现实大概是下面几种可能的情况：</p><ol><li>对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。</li><li>对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。</li><li>对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。</li><li>对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。</li><li>对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！</li><li>对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。</li></ol><p>参考下面的这张图：</p><p><img src="/wiki/IOS/crash/4_increase_Wild_Pointer/wildPointer_random.png" alt="野指针随机性"></p><p>看看下面的代码，明显有问题，但是大部分时候是不会Crash的。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView* testObj=<span class="comment">[<span class="comment">[UIView alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[testObj release]</span>;</span><br><span class="line"><span class="comment">[testObj setNeedsLayout]</span>;</span><br></pre></td></tr></table></figure><p>但是这个放在用户那边或者不是UIView这个类就不好说了，Crash率可能飕飕就上去了！</p><h2 id="让随机变成不随机"><a href="#让随机变成不随机" class="headerlink" title="让随机变成不随机"></a>让随机变成不随机</h2><p>从上面列的情况来看，出现随机Crash的情况有很多种！这是得多蛋疼呢！或许最好的办法让他们全都立马Crash，然后把野指针都找出来！</p><p>仔细看看上面的关键路径只有出现被随机填入的数据是不可访问的时候才会必现Crash。</p><p>这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。</p><p><img src="/wiki/IOS/crash/4_increase_Wild_Pointer/ennable_scrible.png" alt="Enable Scribble 作用"></p><p>下面我们就拿刚刚的代码试一下。</p><figure class="highlight clojure-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">scheme=&gt;</span><span class="clojure">diagnostics=&gt;Enable Scribble</span></span><br></pre></td></tr></table></figure><p>果然，必现了，0x5555561！！</p><p><img src="/wiki/IOS/crash/4_increase_Wild_Pointer/wildPointerCrash.png" alt="野指针Crash"></p><p>但是有个问题：这货不能放在测试同学那边用！因为总不能让测试同学装了xcode来测试吧？</p><p>于是我们自己动手实现一个，这个过程中我们要解决几个问题：</p><ol><li>怎么在内存释放后填上不可访问的数据？内存释放很可能不在我们的代码中。为此我们需要hook对象释放的接口，内存时候之后马上执行我们的破坏工作。</li><li>我们要重写对象释放的接口，重写哪个呢？NSObject的dealloc、runtime的 object_dispose，C的free应该都是可以，但是各有优点，我选择的是覆盖面最广的free，free是C的函数，重写了它之后还可以顺带解决一部分C的野指针问题。</li><li><p>怎么重写？重写C的接口场景的有两种：</p><ol><li>替换系统动态库</li><li><p>hook</p><p>替换动态库太麻烦，还不知道行不行得通；hook我们就找现成的fishhook，github里面找的，但现成的代码需要防止代码冲突。</p></li></ol></li><li>填充的不可访问的数据的长度怎么确定？获取内存长度的接口不在标准库中，好在在Mac和iOS中可以用malloc_size就可以。</li><li>填什么？和xcode一样，填0x55。</li></ol><p>上hook后的free代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_free</span><span class="params">(<span class="keyword">void</span>* p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    size_tmemSiziee=malloc_size(p);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p,<span class="number">0x55</span>, memSiziee);</span><br><span class="line"></span><br><span class="line">    orig_free(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下，出现了和Enable Scribble一样的Crash！</p><p>重复造了这个xcode的轮子之后，以后编包给测试，终于在某些情况下不需要那么拼人品了。但是这仅仅覆盖了众多野指针中的一部分，还有大量的疑问等着继续解答。比如：</p><ol><li>由于内存已经被释放了，很可能我们的0x55又被别的数据覆盖，这种情况还是无能为力。</li><li>为什么我们的0x55555555变成了0x55555561。</li><li>如果释放后访问野指针的是系统代码，虽然提前发现了Crash，但是离解决问题还是很远。</li><li>如果野指针指向的数据没有被当成指针使用，还是可能不立即Crash。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/tencent_bugly/article/details/46277055" rel="external nofollow noopener noreferrer" target="_blank">如何定位Obj-C野指针随机Crash(一):先提高野指针Crash率</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要内容如下：&lt;/p&gt;
&lt;p&gt;欲让其灭亡先让其疯狂，我们当然不是人为制造Crash，准确地说，是使隐藏的随机性Crash暴露出来，提高测试时的Crash率，从而降低版本发布后的Crash率。&lt;/p&gt;
&lt;p&gt;写C、C++代码的同学应该都清楚，Crash最多的原因通常有两种，一种是多线程，一种是野指针。这两种Crash都带随机性，而且这两种Crash有相当一部分都很难区分，甚至大量的Crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。&lt;/p&gt;
&lt;p&gt;本文主要讨论的方向是Obj-C的野指针。Obj-C的野指针最常见的一种栈是objc_msgSend，从Bugly上报的Crash数据来看，objc_msgSend的量占了五分之一，这其中大多数是Obj-C野指针。当然也有相当多的Obj-C野指针不是这种表现，所以野指针的Crash体量非常惊人。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="crash" scheme="http://yoursite.com/categories/IOS/crash/"/>
    
    
      <category term="Crash" scheme="http://yoursite.com/tags/Crash/"/>
    
  </entry>
  
  <entry>
    <title>NSInvocation的基本使</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91/ios_jalebroke/"/>
    <id>http://yoursite.com/wiki/IOS/小码哥视频/ios_jalebroke/</id>
    <published>2018-12-11T07:35:49.000Z</published>
    <updated>2018-12-12T11:09:06.832Z</updated>
    
    <content type="html"><![CDATA[<p>小码哥视频学习记录</p><a id="more"></a><h2 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h2><h3 id="ssh-链接iphone手机"><a href="#ssh-链接iphone手机" class="headerlink" title="ssh 链接iphone手机"></a>ssh 链接iphone手机</h3><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh root@ <span class="number">10.144</span><span class="number">.32</span><span class="number">.27</span></span><br><span class="line">alpine</span><br></pre></td></tr></table></figure><p>ifunbox</p><h2 id="第二天"><a href="#第二天" class="headerlink" title="第二天"></a>第二天</h2><p>ssh 版本：SSH-2</p><p>查看SSH版本：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /etc/ssh</span><br><span class="line"><span class="keyword">ls</span></span><br><span class="line"><span class="keyword">cat</span> ssh_config  <span class="built_in">or</span> <span class="keyword">cat</span> sshd_config</span><br></pre></td></tr></table></figure><p>SSH 通信过程：</p><ol><li>建立安全链接</li><li>客户端认证(基于密码类型的、基于秘钥的认证（免密码，优先选择 ）)</li><li>数据传输</li></ol><p>服务器公钥：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/etc/</span>ssh<span class="regexp">/ssh_host_rs_key.pub</span></span><br></pre></td></tr></table></figure><p>重新生成秘钥</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh-keygen</span> <span class="selector-tag">-R</span> 10<span class="selector-class">.144</span><span class="selector-class">.36</span><span class="selector-class">.206</span></span><br></pre></td></tr></table></figure><p>自动拷贝公钥到服务器</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen </span><br><span class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>手动拷贝公钥到服务器</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp ~<span class="regexp">/.ssh/id</span>_rsa.pub root@10.<span class="number">144.36</span>.<span class="number">206</span><span class="symbol">:~/</span>.ssh</span><br><span class="line">cat id_rsa.pub <span class="meta">&gt;&gt; </span>authorized_keys</span><br></pre></td></tr></table></figure><p>22 端口</p><p>通过usb进行ssh链接</p><p>usbmuxd   端口映射<br>python ~/Documents/ios/usbmuxd/tcprelay.py -t 22:10010<br>ssh root@localhost -p 10010 </p><p>sh bash 子进程中执行<br>source 当前进程中执行</p><p>cycript 是C++、JavaScript、java 混合物， 调试某个APP  </p><p>cycript 命令进入cycript环境<br>cycript -p 进程名称<br>adv-cmds  执行ps命令  </p><p>UIApp= [UIApplication sharedApplication]</p><p>定义变量 :var app = UIApp.keyWindow</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">地址 可以访问对象</span></span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>对象  访问对象的成员变量</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归打印视图： <span class="selector-tag">view</span><span class="selector-class">.recursiveDescription</span>()<span class="selector-class">.toString</span>()</span><br></pre></td></tr></table></figure><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">筛选某种类型的视图： <span class="built_in">choose</span>(UITableViewCell)</span><br></pre></td></tr></table></figure><h2 id="第四天"><a href="#第四天" class="headerlink" title="第四天"></a>第四天</h2><p>拆分胖二进制文件</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lipo test -thin -armv7 -o test_armv7</span><br><span class="line">lipo -crate test_armv7 test_arm64 -o test</span><br></pre></td></tr></table></figure><p>file命令查看文件格式</p><p>XNU源码中有loader.h文件，定义了文件的格式</p><p>otool命令</p><p>dyld 只能加载MH_EXECUTE、MH_DYLIB|MH_BUNFLE类型的Mach-O文件</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小码哥视频学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="小码哥视频" scheme="http://yoursite.com/categories/IOS/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="小码哥视频" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>18. @synchronized</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/18_syncsize/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/18_syncsize/</id>
    <published>2018-12-06T02:38:11.000Z</published>
    <updated>2018-12-06T10:16:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>@synchronized  内幕揭秘</p><a id="more"></a><h2 id="synchronized揭秘"><a href="#synchronized揭秘" class="headerlink" title="@synchronized揭秘"></a>@synchronized揭秘</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        AXPerson * p = [AXPerson <span class="keyword">new</span>];</span><br><span class="line">        <span class="meta">@synchronized</span> (p) &#123;</span><br><span class="line">            NSLog(@<span class="string">"p is @synchronized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写为C++：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        AXPerson * p = ((AXPerson *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"AXPerson"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">id</span> _sync_obj = (<span class="keyword">id</span>)p;</span><br><span class="line">            objc_sync_enter(_sync_obj);  </span><br><span class="line">            <span class="keyword">struct</span> _SYNC_EXIT &#123;</span><br><span class="line">                _SYNC_EXIT(<span class="keyword">id</span> arg) : sync_exit(arg) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">                ~_SYNC_EXIT() &#123; <span class="comment">// 析构函数，析构的时候会自动释放锁</span></span><br><span class="line">                    objc_sync_exit(sync_exit); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">id</span> sync_exit; <span class="comment">// 成员变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            _sync_exit(_sync_obj);  </span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_cp_sc2q63f937j88dcxp23f471w0000gn_T_main_3c34e3_mi_0);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一步步分析代码 </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id _sync_obj = (<span class="name">id</span>)p<span class="comment">;</span></span><br><span class="line">objc_sync_enter(<span class="name">_sync_obj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>将上锁的对象p赋值给_sync_obj ， 调用objc_sync_enter函数，实参传递_sync_obj, objc_sync_enter函数就相当于上锁。后面详细分析</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">_SYNC_EXIT</span> &#123;</span><br><span class="line">    <span class="selector-tag">_SYNC_EXIT</span>(id arg) : <span class="selector-tag">sync_exit</span>(arg) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="selector-tag">_SYNC_EXIT</span>() &#123; <span class="comment">// 析构函数，析构的时候会自动释放锁</span></span><br><span class="line">        <span class="selector-tag">objc_sync_exit</span>(sync_exit); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">id</span> <span class="selector-tag">sync_exit</span>; <span class="comment">// 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">_sync_exit</span>(_sync_obj);</span><br></pre></td></tr></table></figure><p>这不是一个单独的语句，注意看结构体的右大括号后面并没有分号，所以 _sync_exit(_sync_obj) 是跟在 _SYNC_EXIT 结构体后面的，即它声明了一个名为 _sync_exit 的结构体对象。</p><p>_sync_exit对象的的析构函数里面调用了objc_sync_exit函数。这个函数相当于解锁。 析构函数在_sync_exit释放的时候调用。也就是作用域结束的时候调用。</p><p>所以， <code>@synchronized (p)</code> 相当于  新建了一个作用域，在作用域开始的时候，调用objc_sync_enter函数，实参是p，作用域结束的时候，自动调用析构函数objc_sync_exit，解锁。</p><h2 id="synchronized数据结构"><a href="#synchronized数据结构" class="headerlink" title="@synchronized数据结构"></a>@synchronized数据结构</h2><p>@synchronized 相关的数据结构，安装存储的位置划分，有两种：</p><ol><li>线程内部存储的数据。</li><li>全局数据，用来线程间共享。</li></ol><p>后面会分析这两种数据的相互关系。</p><p>线程内部：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span> &#123;</span> <span class="comment">// 同步数据结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span> <span class="comment">// 指向下一个 SyncData，看来是链表</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">// 锁住的对象</span></span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// 使用这个block(???)的线程数  number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex; <span class="comment">// 递归锁</span></span><br><span class="line">&#125; SyncData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lockCount;  <span class="comment">// number of times THIS THREAD locked this block</span></span><br><span class="line">&#125; SyncCacheItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line">    SyncCacheItem <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">&#125; SyncCache;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/threadInData.png" alt="线程内STL数据"></p><p>全局数据定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> <span class="type">SyncList</span> &#123;</span><br><span class="line">    <span class="type">SyncData</span> *<span class="class"><span class="keyword">data</span>;</span></span><br><span class="line">    spinlock_t lock; // 自旋锁</span><br><span class="line"></span><br><span class="line">    <span class="type">SyncList</span>() : <span class="class"><span class="keyword">data</span>(<span class="title">nil</span>) &#123; &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/thread_out_data.png" alt="全局锁数据"></p><h2 id="synchronized源码分析"><a href="#synchronized源码分析" class="headerlink" title="@synchronized源码分析"></a>@synchronized源码分析</h2><p>@synchronized 相关的API有两个：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int objc_sync_enter(<span class="name">id</span> obj)</span><br><span class="line">int objc_sync_exit(<span class="name">id</span> obj)</span><br></pre></td></tr></table></figure><h3 id="objc-sync-enter"><a href="#objc-sync-enter" class="headerlink" title="objc_sync_enter"></a>objc_sync_enter</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS; <span class="comment">// 用来记录结果，默认成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123; <span class="comment">// obj 必须非空，</span></span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE); <span class="comment">// 为 obj 对象绑定一个递归锁</span></span><br><span class="line">        <span class="keyword">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.lock(); <span class="comment">// 递归锁加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则 @synchronized 啥也不干</span></span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了id2data函数，取出所对象，上锁。</p><h3 id="objc-sync-exit"><a href="#objc-sync-exit" class="headerlink" title="objc_sync_exit"></a>objc_sync_exit</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); <span class="comment">// 为 obj 解绑递归锁</span></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; <span class="comment">// 压根儿没有 objc_sync_enter 过</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock(); <span class="comment">// 尝试解锁</span></span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; <span class="comment">// 解锁失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过id2data取出锁对象，解锁。</p><p>所以关键锁对象建模都在id2data函数中。这个函数顾名思义，就是将id类型的对象转化为锁数据。</p><h3 id="id2data"><a href="#id2data" class="headerlink" title="id2data"></a>id2data</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">static SyncData* id2data(id object, enum usage why)</span><br><span class="line">&#123;</span><br><span class="line">    spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class="line">    SyncData* result = NULL;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    SyncCache *cache = fetch_cache(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        unsigned int i;</span><br><span class="line">        <span class="function"><span class="title">for</span> (i = 0; i &lt; cache-&gt;</span>used; i++) &#123;</span><br><span class="line">            S<span class="function"><span class="title">yncCacheItem</span> *item = &amp;cache-&gt;</span>list[i];</span><br><span class="line">            <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">data</span>-&gt;</span>object != object) continue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="function"><span class="title">result</span> = item-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (result-&gt;</span><span class="function"><span class="title">threadCount</span> &lt;= 0  ||  item-&gt;</span>lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            switch(why) &#123;</span><br><span class="line">            case ACQUIRE:</span><br><span class="line">                <span class="function"><span class="title">item</span>-&gt;</span>lockCount++;</span><br><span class="line">                break;</span><br><span class="line">            case RELEASE:</span><br><span class="line">                <span class="function"><span class="title">item</span>-&gt;</span>lockCount--;</span><br><span class="line">                <span class="function"><span class="title">if</span> (item-&gt;</span>lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[i] = cache-&gt;</span><span class="function"><span class="title">list</span>[--cache-&gt;</span>used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSA<span class="function"><span class="title">tomicDecrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">lockp</span>-&gt;</span>lock();</span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = NULL;</span><br><span class="line">        <span class="function"><span class="title">for</span> (p = *listp; p != NULL; p = p-&gt;</span>nextData) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> ( p-&gt;</span>object == object ) &#123;</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                OSA<span class="function"><span class="title">tomicIncrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> ( (firstUnused == NULL) &amp;&amp; (p-&gt;</span>threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            goto done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != NULL ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="function"><span class="title">result</span>-&gt;</span>object = (objc_object *)object;</span><br><span class="line">            <span class="function"><span class="title">result</span>-&gt;</span>threadCount = <span class="number">1</span>;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    result = (SyncData*)calloc(sizeof(SyncData), <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>object = (objc_object *)object;</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">new</span> (&amp;result-&gt;</span>mutex) recursive_mutex_t();</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">    <span class="function"><span class="title">lockp</span>-&gt;</span>unlock();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            return <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="function"><span class="title">if</span> (result-&gt;</span>object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[cache-&gt;</span>used].<span class="keyword">data</span> = result;</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[cache-&gt;</span>used].lockCount = <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span>used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">LOCK_FOR_OBJ</span>(<span class="selector-tag">obj</span>) <span class="selector-tag">sDataLists</span><span class="selector-attr">[obj]</span><span class="selector-class">.lock</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">LIST_FOR_OBJ</span>(<span class="selector-tag">obj</span>) <span class="selector-tag">sDataLists</span><span class="selector-attr">[obj]</span><span class="selector-class">.data</span></span><br><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">StripedMap</span>&lt;<span class="selector-tag">SyncList</span>&gt; <span class="selector-tag">sDataLists</span>;</span><br></pre></td></tr></table></figure><p>整个代码可以分为2种情况：</p><ol><li>当前线程的TLS已经有对象object的数据 ：直接对锁的次数lockCount累加.</li><li>当前的线程里面没有，说明object在这个线程第一次上锁，那么也分两种情况，一种情况是：这个对象在所有线程中第一次上锁，那么，新建锁对象数据SyncData，然后将线程数threadCount赋值为1.  数据另一种情况是，这个对象在其他的线程中上过锁，那么从全局数据sDataLists中取出锁数据listp，将线程数累加。  因为这两种情况都是第一次进入这个线程，所以，执行完上面的操作，需要将锁数据result添加到线程TLS中。</li></ol><p>下面放置了一张图，方便理解 。图的上面是全局数据结构，是个链表，因为全局的数据比较多。所以使用高效的链表作为基本数据结构。中间是线程内部的数据结构，对于某个线程，锁没有全局的多，所以使用简单的数据结构数组。下面部分是这段代码的基本逻辑。</p><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/sync流程.png" alt="加锁流程"></p><p>拆分理解三种情况：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> SyncCache *cache = fetch_cache(NO);</span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; cache-&gt;</span>used; i++) &#123;</span><br><span class="line">        S<span class="function"><span class="title">yncCacheItem</span> *item = &amp;cache-&gt;</span>list[i];</span><br><span class="line">        <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">data</span>-&gt;</span>object != object) continue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Found a match.</span></span><br><span class="line">        <span class="function"><span class="title">result</span> = item-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">if</span> (result-&gt;</span><span class="function"><span class="title">threadCount</span> &lt;= 0  ||  item-&gt;</span>lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        switch(why) &#123;</span><br><span class="line">        case ACQUIRE:</span><br><span class="line">            <span class="function"><span class="title">item</span>-&gt;</span>lockCount++;</span><br><span class="line">            break;</span><br><span class="line">        case RELEASE:</span><br><span class="line">            <span class="function"><span class="title">item</span>-&gt;</span>lockCount--;</span><br><span class="line">            <span class="function"><span class="title">if</span> (item-&gt;</span>lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[i] = cache-&gt;</span><span class="function"><span class="title">list</span>[--cache-&gt;</span>used];</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                OSA<span class="function"><span class="title">tomicDecrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case CHECK:</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是第一种情况，上锁情况累加lockCount，解锁情况递减lockCount。如果lockCount为0 ，清楚数据。如果符合这种情况，就直接返回了。 下面的代码都属于第二种情况。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SyncData* p;</span><br><span class="line">SyncData* firstUnused = <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (p = *listp; p != <span class="keyword">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">        result = p;</span><br><span class="line">        <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">        OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (firstUnused == <span class="keyword">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">        firstUnused = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码是对象的锁数据在全局数据中找到了。直接递增threadCount。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// an unused one was found, use it</span></span><br><span class="line"><span class="keyword">if</span> ( firstUnused != <span class="keyword">NULL</span> ) &#123;</span><br><span class="line">    result = firstUnused;</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，但是在全局数据中找到了空的result，直接赋值threadCount为1。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = (<span class="name">SyncData*</span>)calloc(<span class="name">sizeof</span>(<span class="name">SyncData</span>), <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">result-&gt;object = (<span class="name">objc_object</span> *)object;</span><br><span class="line">result-&gt;threadCount = 1;</span><br><span class="line">new (&amp;result-&gt;mutex) recursive_mutex_t();</span><br><span class="line">result-&gt;nextData = *listp<span class="comment">;</span></span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure><p>这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，并且在全局数据中没有找到空的SyncData。直接创建，添加到链表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!<span class="keyword">cache</span>) <span class="keyword">cache</span> = fetch_cache(YES);</span><br><span class="line"><span class="keyword">cache</span>-&gt;<span class="keyword">list</span>[<span class="keyword">cache</span>-&gt;used].data = <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">cache</span>-&gt;<span class="keyword">list</span>[<span class="keyword">cache</span>-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">cache</span>-&gt;used++;</span><br></pre></td></tr></table></figure><p>这段代码是第二种情况的最后一步，以为第二种情况都是第一次进入改线程，所以需要将创建或者以后的锁数据result添加到线程数据TLS中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>@synchronized 就是在作用开始的时候，调用objc_sync_enter 函数，用对象创建出了锁数据SyncData，并上锁 。 当作用域结束的时候，调用objc_sync_exit 解锁，使用的锁是递归锁，在同一个线程中可以重入。所以，对同一个对象嵌套使用@synchronized，不会死锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@synchronized  内幕揭秘&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>16. retain 和 release（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/16_retain_release/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/16_retain_release/</id>
    <published>2018-12-04T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:10.984Z</updated>
    
    <content type="html"><![CDATA[<p>在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 <code>retain</code> 和减少引用计数的 <code>release</code> 方法。</p><p>这篇文章会在源代码层面介绍 Objective-C 中 <code>retain</code> 和 <code>release</code> 的实现，它们是如何达到平衡的。</p><a id="more"></a><h2 id="从-retain-开始"><a href="#从-retain-开始" class="headerlink" title="从 retain 开始"></a>从 retain 开始</h2><p>如今我们已经进入了全面使用 ARC 的时代，几年前还经常使用的 <code>retain</code> 和 <code>release</code> 方法已经很难出现于我们的视野中了，绝大多数内存管理的实现细节都由编译器代劳。</p><p>在这里，我们还要从 <code>retain</code> 方法开始，对内存管理的实现细节一探究竟。</p><p>下面是 <code>retain</code> 方法的调用栈：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject retain]</span><br><span class="line">└── id objc_object::rootRetain()</span><br><span class="line">    └── id objc_object::rootRetain(<span class="keyword">bool </span>tryRetain, <span class="keyword">bool </span>handleOverflow)</span><br><span class="line">        ├── uintptr_t LoadExclusive(uintptr_t *src)</span><br><span class="line">        ├── uintptr_t <span class="keyword">addc(uintptr_t </span><span class="keyword">lhs, </span>uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br><span class="line">        ├── uintptr_t <span class="keyword">bits</span></span><br><span class="line"><span class="keyword"> </span>       │   └── uintptr_t has_sidetable_rc  </span><br><span class="line">        ├── <span class="keyword">bool </span>StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)</span><br><span class="line">        └── <span class="keyword">bool </span>objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)                </span><br><span class="line">            └── uintptr_t <span class="keyword">addc(uintptr_t </span><span class="keyword">lhs, </span>uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br></pre></td></tr></table></figure><p>调用栈中的前两个方法的实现直接调用了下一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_object::rootRetain() &#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>id objc_object::rootRetain(bool tryRetain, bool handleOverflow)</code> 方法是调用栈中最重要的方法，其原理就是将 <code>isa</code> 结构体中的 <code>extra_rc</code> 的值加一。</p><p><code>extra_rc</code> 就是用于保存自动引用计数的标志位，下面就是 <code>isa</code> 结构体中的结构：</p><p><img src="/wiki/IOS/Runtime/objc/16_retain_release/objc-rr-isa-struct.png" alt="objc-rr-isa-struct"></p><p>接下来我们会分三种情况对 <code>rootRetain</code> 进行分析。</p><h3 id="正常的-rootRetain"><a href="#正常的-rootRetain" class="headerlink" title="正常的 rootRetain"></a>正常的 rootRetain</h3><p>这是简化后的 <code>rootRetain</code> 方法的实现，其中只有处理一般情况的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id objc_object:<span class="type"></span>:rootRetain(bool tryRetain, bool handleOverflow) &#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line"></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = addc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们假设的条件是 <code>isa</code> 中的 <code>extra_rc</code> 的位数足以存储 <code>retainCount</code>。</p></blockquote><ol><li>使用 <code>LoadExclusive</code> 加载 <code>isa</code> 的值</li><li>调用 <code>addc(newisa.bits, RC_ONE, 0, &amp;carry)</code> 方法将 <code>isa</code> 的值加一</li><li>调用 <code>StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</code> 更新 <code>isa</code> 的值</li><li>返回当前对象</li></ol><h3 id="有进位版本的-rootRetain"><a href="#有进位版本的-rootRetain" class="headerlink" title="有进位版本的 rootRetain"></a>有进位版本的 rootRetain</h3><p>在这里调用 <code>addc</code> 方法为 <code>extra_rc</code> 加一时，8 位的 <code>extra_rc</code> 可能不足以保存引用计数。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id objc_object::rootRetain(<span class="keyword">bool </span>tryRetain, <span class="keyword">bool </span>handleOverflow) &#123;</span><br><span class="line">    transcribeToSideTable = false<span class="comment">;</span></span><br><span class="line">    isa_t oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>   isa_t newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    uintptr_t carry<span class="comment">;</span></span><br><span class="line">    newisa.<span class="keyword">bits </span>= <span class="keyword">addc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (carry &amp;&amp; !handleOverflow)</span><br><span class="line">        return rootRetain_overflow(tryRetain)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>extra_rc</code> 不足以保存引用计数，并且 <code>handleOverflow = false</code>。</p></blockquote><p>当方法传入的 <code>handleOverflow = false</code> 时（这也是通常情况），我们会调用 <code>rootRetain_overflow</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_object::rootRetain_overflow(<span class="keyword">bool</span> tryRetain) &#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(tryRetain, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实就是重新执行 <code>rootRetain</code> 方法，并传入 <code>handleOverflow = true</code>。</p><h3 id="有进位版本的-rootRetain（处理溢出）"><a href="#有进位版本的-rootRetain（处理溢出）" class="headerlink" title="有进位版本的 rootRetain（处理溢出）"></a>有进位版本的 rootRetain（处理溢出）</h3><p>当传入的 <code>handleOverflow = true</code> 时，我们就会在 <code>rootRetain</code> 方法中处理引用计数的溢出。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id objc_object:<span class="type"></span>:rootRetain(bool tryRetain, bool handleOverflow) &#123;</span><br><span class="line">    bool sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = addc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            <span class="keyword">new</span><span class="type">isa</span>.extra_rc = RC_HALF;</span><br><span class="line">            <span class="keyword">new</span><span class="type">isa</span>.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用这个方法，并且 <code>handleOverflow = true</code> 时，我们就可以确定 <code>carry</code> 一定是存在的了，</p><p>因为 <code>extra_rc</code> 已经溢出了，所以要更新它的值为 <code>RC_HALF</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF (1ULL&lt;&lt;7)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>extra_rc</code> 总共为 8 位，<code>RC_HALF = 0b10000000</code>。</p></blockquote><p>然后设置 <code>has_sidetable_rc</code> 为真，存储新的 <code>isa</code> 的值之后，调用 <code>sidetable_addExtraRC_nolock</code> 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> objc_object::sidetable_addExtraRC_nolock(<span class="keyword">size_t</span> delta_rc) &#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">size_t</span> oldRefcnt = refcntStorage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">    <span class="keyword">size_t</span> newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将溢出的一位 <code>RC_HALF</code> 添加到 <code>oldRefcnt</code> 中，其中的各种 <code>SIDE_TABLE</code> 宏定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span></span><br></pre></td></tr></table></figure><p>因为 <code>refcnts</code> 中的 64 为的最低两位是有意义的标志位，所以在使用 <code>addc</code> 时要将 <code>delta_rc</code> 左移两位，获得一个新的引用计数 <code>newRefcnt</code>。</p><p>如果这时出现了溢出，那么就会撤销这次的行为。否则，会将新的引用计数存储到 <code>refcntStorage</code> 指针中。</p><hr><p>也就是说，在 iOS 的内存管理中，我们使用了 <code>isa</code> 结构体中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储某个对象的自动引用计数。</p><p>更重要的是，<strong>如果自动引用计数为 1，<code>extra_rc</code> 实际上为 0</strong>，因为它保存的是额外的引用计数，我们通过这个行为能够减少很多不必要的函数调用。</p><p>到目前为止，我们已经从头梳理了 <code>retain</code> 方法的调用栈及其实现。下面要介绍的是在内存管理中，我们是如何使用 <code>release</code> 方法平衡这个方法的。</p><h2 id="以-release-结束"><a href="#以-release-结束" class="headerlink" title="以 release 结束"></a>以 release 结束</h2><p>与 release 方法相似，我们看一下这个方法简化后的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> release]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootRelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootRetain(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br></pre></td></tr></table></figure><p>前面的两个方法的实现和 <code>retain</code> 中的相差无几，这里就直接跳过了。</p><p>同样，在分析 <code>release</code> 方法时，我们也根据上下文的不同，将 <code>release</code> 方法的实现拆分为三部分，说明它到底是如何调用的。</p><h3 id="正常的-release"><a href="#正常的-release" class="headerlink" title="正常的 release"></a>正常的 release</h3><p>这一个版本的方法调用可以说是最简版本的方法调用了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>objc_object::rootRelease(<span class="keyword">bool </span>performDealloc, <span class="keyword">bool </span>handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa<span class="comment">;</span></span><br><span class="line">    isa_t newisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>       newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        uintptr_t carry<span class="comment">;</span></span><br><span class="line">        newisa.<span class="keyword">bits </span>= <span class="keyword">subc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line">    &#125; while (!StoreReleaseExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   return false<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>LoadExclusive</code> 获取 <code>isa</code> 内容</li><li>将 <code>isa</code> 中的引用计数减一</li><li>调用 <code>StoreReleaseExclusive</code> 方法保存新的 <code>isa</code></li></ol><h3 id="从-SideTable-借位"><a href="#从-SideTable-借位" class="headerlink" title="从 SideTable 借位"></a>从 SideTable 借位</h3><p>接下来，我们就要看两种相对比较复杂的情况了，首先是从 <code>SideTable</code> 借位的版本：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>objc_object::rootRelease(<span class="keyword">bool </span>performDealloc, <span class="keyword">bool </span>handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa<span class="comment">;</span></span><br><span class="line">    isa_t newisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>       newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        uintptr_t carry<span class="comment">;</span></span><br><span class="line">        newisa.<span class="keyword">bits </span>= <span class="keyword">subc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line">        if (carry) goto underflow<span class="comment">;</span></span><br><span class="line">    &#125; while (!StoreReleaseExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits));</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="symbol"> underflow:</span></span><br><span class="line">    newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (newisa.has_sidetable_rc) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            return rootRelease_underflow(performDealloc)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t <span class="keyword">borrowed </span>= sidetable_subExtraRC_nolock(RC_HALF)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        if (<span class="keyword">borrowed </span>&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            newisa.<span class="keyword">extra_rc </span>= <span class="keyword">borrowed </span>- <span class="number">1</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">bool </span>stored = StoreExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           return false<span class="comment">;</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里省去了使用锁来<strong>防止竞争条件</strong>以及<strong>调用 <code>StoreExclusive</code> 失败后恢复现场</strong>的代码。<br>我们会默认这里存在 <code>SideTable</code>，也就是 <code>has_sidetable_rc = true</code>。</p></blockquote><p>你可以看到，这里也有一个 <code>handleUnderflow</code>，与 retain 中的相同，如果发生了 <code>underflow</code>，会重新调用该 <code>rootRelease</code> 方法，并传入 <code>handleUnderflow = true</code>。</p><p>在调用 <code>sidetable_subExtraRC_nolock</code> 成功借位之后，我们会重新设置 <code>newisa</code> 的值 <code>newisa.extra_rc = borrowed - 1</code> 并更新 <code>isa</code>。</p><h3 id="release-中调用-dealloc"><a href="#release-中调用-dealloc" class="headerlink" title="release 中调用 dealloc"></a>release 中调用 dealloc</h3><p>如果在 <code>SideTable</code> 中也没有获取到借位的话，就说明没有任何的变量引用了当前对象（即 <code>retainCount = 0</code>），就需要向它发送 <code>dealloc</code> 消息了。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool objc_object:<span class="type"></span>:rootRelease(bool performDealloc, bool handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line"><span class="type">    do </span>&#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line"></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = subc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">        <span class="keyword">if</span> (carry) goto underflow;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> underflow:<span class="type"></span></span><br><span class="line"><span class="type">    newisa </span>= oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">isa</span>.deallocating) &#123;</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span>.deallocating = <span class="literal">true</span>;</span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(<span class="built_in">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会直接调用 <code>objc_msgSend</code> 向当前对象发送 <code>dealloc</code> 消息。</p><p>不过为了确保消息只会发送一次，我们使用 <code>deallocating</code> 标记位。</p><h2 id="获取自动引用计数"><a href="#获取自动引用计数" class="headerlink" title="获取自动引用计数"></a>获取自动引用计数</h2><p>在文章的最结尾，笔者想要介绍一下 <code>retainCount</code> 的值是怎么计算的，我们直接来看 <code>retainCount</code> 方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> objc_object::rootRetainCount() &#123;</span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">    <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">        rc += sidetable_getExtraRC_nolock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据方法的实现，retainCount 有三部分组成：</p><ul><li>1</li><li><code>extra_rc</code> 中存储的值</li><li><code>sidetable_getExtraRC_nolock</code> 返回的值</li></ul><p>这也就证明了我们之前得到的结论。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们在这篇文章中已经介绍了 <code>retain</code> 和 <code>release</code> 这一对用于内存管理的方法是如何实现的，这里总结一下文章一下比较重要的问题。</p><ul><li><code>extra_rc</code> 只会保存额外的自动引用计数，对象实际的引用计数会在这个基础上 +1</li><li>Objective-C 使用 <code>isa</code> 中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储对象的引用计数</li><li>在对象的引用计数归零时，会调用 <code>dealloc</code> 方法回收对象</li></ul><p>有关于自动释放池实现的介绍，可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/自动释放池的前世今生.md" rel="external nofollow noopener noreferrer" target="_blank">自动释放池的前世今生</a>。</p><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 &lt;code&gt;retain&lt;/code&gt; 和减少引用计数的 &lt;code&gt;release&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;这篇文章会在源代码层面介绍 Objective-C 中 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 的实现，它们是如何达到平衡的。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="retain 和 release" scheme="http://yoursite.com/tags/retain-%E5%92%8C-release/"/>
    
  </entry>
  
  <entry>
    <title>17. weak 相关源码分析</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/17_weak/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/17_weak/</id>
    <published>2018-12-04T02:38:11.000Z</published>
    <updated>2018-12-05T11:45:08.564Z</updated>
    
    <content type="html"><![CDATA[<p>weak相关源码分析</p><a id="more"></a><h2 id="weak探究"><a href="#weak探究" class="headerlink" title="__weak探究"></a>__weak探究</h2><p>程序中添加了一个<code>__weak</code>变量，查看调用堆栈，看到下一个调用的是<code>objc_initWeak</code>函数。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak入口.jpg" alt="__weak调用的函数"></p><p>所以我们就objc_initWeak函数作为入口，探究weak。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先了解以下的变量，这些变量在这章的数据结构、函数形参中使用：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak id weakPtr = o</span><br><span class="line"><span class="keyword">location</span>            <span class="title">newObj</span></span><br><span class="line">refferer            reffenent</span><br><span class="line">引用着               被引用者</span><br></pre></td></tr></table></figure><h3 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h3><p>下面从SideTables() 函数为入口，了解weak相关的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回StripedMap<sidetable> 结构，StripedMap<sidetable> 是一个模板类，函数体内将SideTableBuf强制转换为<code>StripedMap&lt;SideTable&gt;*</code>：</sidetable></sidetable></p><p>StripedMap 定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(<span class="number">64</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT <span class="built_in">array</span>[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是StripedMap的简化定义，StripedMap是个模板类，根据模板参数T生成实例类，我们给模板参数传递的实参是SideTable，StripedMap内部只定义了一个数据成员PaddedT array[64]，PaddedT就是64位对齐后的SideTable。</p><p>进一步简化：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SideTable array[<span class="number">64</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>所以StripedMap就是SideTable型的数组，数组有64个成员。</p><p>SideTable的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_sideTable.png" alt="SideTable 类结构"></p><p>可以看出SideTable的大小是62，64位对齐后是64。其中weak_talbe存储着weak相关的内容。其他的两个成员refcnts、slock不在本文的研究范围内。</p><p>所以数组<code>SideTable array[64]</code> 中元素的大小就是64。整个array 共占用64*64=4096字节。回到没有简化前的版本，<code>StripedMap&lt;SideTable&gt;</code>本质是一个数组，数组的元素是模板参数类型 —SideTable。大小为64。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/stripmap_memory_struct.png" alt="`StripedMap&lt;SideTable&gt;` 内存结构"></p><p>函数SideTables()是将SideTableBuf转化为<code>StripedMap&lt;SideTable&gt;</code>的。所以下面了解SideTableBuf的定义。</p><h3 id="SideTableBuf"><a href="#SideTableBuf" class="headerlink" title="SideTableBuf"></a>SideTableBuf</h3><p>SideTableBuf的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span></span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br></pre></td></tr></table></figure><p>前面的alignas(StripedMap<sidetable>)是对齐的。<code>sizeof(StripedMap&lt;SideTable&gt;)</code>根据上面分析是4096，所以上面的代码简化为：</sidetable></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> SideTableBuf[<span class="number">4096</span>];</span><br></pre></td></tr></table></figure><p>所以SideTableBuf 就是一个包含 4096个uint8_t的数组 。</p><p>所以,函数SideTables() 就相当将uint8_t SideTableBuf[4096] 重新解释为<code>SideTable array[64]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/17_weak/stripedMap.png" alt="SideTableBuf转化为StripedMap 内存示意图"></p><h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的弱引用表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries; </span><br><span class="line">    <span class="keyword">size_t</span>    num_entries; <span class="comment">// 实体的数量</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>weak_entries一个数组，数组每个元素是 weak_entry_t 结构体，一个weak_entry_t结构存储了一个reffenent，以及指向reffenent的弱引用者们。</li><li>num_entries 是实体（weak_entry_t）的数量</li><li>mask是容量减1.</li></ol><h3 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent; </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers; </span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line : <span class="number">1</span>; <span class="comment">// 变量名是 out_of_line ，占 1 个 bit</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_1; <span class="comment">// 数组中有几个元素，即 referent 有几个弱引用</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line=0 is LSB of one of these (don't care which)</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构看着比较复杂：</p><ol><li>referent存储被弱引用的对象。</li><li>第二个成员是一个union，存储若引用者（refferer）。如果referent的弱引用者小于四个，也就是out_of_line为0时，弱引用者就存储在inline_referrers数组中。 否则，就存储在referrers中，这是out_of_line 为1，referrers是个二级指针，里面存的是指向referent 的对象们的地址。num_refs 是弱引用着的个数。mask是容量减1。</li></ol><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_entry_t.png" alt="SideTableBuf转化为StripedMap"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面分析了weak相关的结构，现在花一张总图：</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_data_overal.png" alt="SideTableBuf转化为StripedMap"></p><p>上面是详细的数据结构，比较复杂，下面列出我认为核心的结构，核心结构就是三级hash表。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_table三级表.png" alt="SideTableBuf转化为StripedMap"></p><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_storeWeakOrNil(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj);</span><br><span class="line"><span class="keyword">id</span> objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj);</span><br><span class="line"><span class="keyword">void</span> objc_destroyWeak(<span class="keyword">id</span> *location);</span><br></pre></td></tr></table></figure><p>下面章节的代码只是简化的代码，为了方便理解，可能缺失部分细节。</p><h3 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_initWeak内部只调用了storeWeak函数。</p><h3 id="objc-storeWeak"><a href="#objc-storeWeak" class="headerlink" title="objc_storeWeak"></a>objc_storeWeak</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_storeWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>,</span><br><span class="line">                    <span class="literal">true</span><span class="comment">/*new*/</span>,</span><br><span class="line">                    <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, (objc_object *)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="objc-destroyWeak"><a href="#objc-destroyWeak" class="headerlink" title="objc_destroyWeak"></a>objc_destroyWeak</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_destroyWeak(id *<span class="keyword">location</span>)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>, <span class="literal">false</span><span class="comment">/*new*/</span>, <span class="literal">false</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (<span class="keyword">location</span>, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出objc_initWeak 、 objc_storeWeak 、objc_destroyWeak 的关键内容都是调用storeWeak函数，只是模板参数传递的不一样。</p><h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><p>下面讲解storeWeak函数，下面只关注添加的过程。删除的过程没有关注。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> id </span><br><span class="line">storeWeak(id *location, objc_object *<span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(<span class="keyword">new</span><span class="type">Obj</span> == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *<span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = &amp;SideTables()[<span class="keyword">new</span><span class="type">Obj</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Obj</span> = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;<span class="keyword">new</span><span class="type">Table</span>-&gt;weak_table, (id)<span class="keyword">new</span><span class="type">Obj</span>, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = &amp;SideTables()[<span class="keyword">new</span><span class="type">Obj</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = nil;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是根据newObj 找到存储newObj的地址对应的SideTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">       <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>StripedMap重载了[] 操作符，内部调用了indexForPointer ，indexForPointer就是将对象的地址做某些操作，相当于hash。然后将hash的结果和64取余，得到0~63的值，这个值就可以当做数组的索引使用。</p><p>storeWeak函数接着调用了 weak_register_no_lock函数：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">weak<span class="number">_</span>register<span class="number">_n</span>o<span class="number">_</span>lock(weak<span class="number">_</span>table<span class="number">_</span>t *weak<span class="number">_</span>table, id referent<span class="number">_</span>id, </span><br><span class="line">                      id *referrer<span class="number">_</span>id, bool crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> *referent = (objc<span class="number">_</span><span class="keyword">object</span> *)referent<span class="number">_</span>id;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> **referrer = (objc<span class="number">_</span><span class="keyword">object</span> **)referrer<span class="number">_</span>id;</span><br><span class="line"> weak<span class="number">_</span>entry<span class="number">_</span>t *entry;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak<span class="number">_</span>entry<span class="number">_</span>t *entry;</span><br><span class="line">    <span class="comment">// 找到 referent 所在的 entry</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak<span class="number">_</span>entry<span class="number">_f</span>or<span class="number">_</span>referent(weak<span class="number">_</span>table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 将 referrer 添加进这个 entry 中，这样 referrer 就成为 referent 的弱引用之一了</span></span><br><span class="line">        append<span class="number">_</span>referrer(entry, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到对应的 entry ，那么说明 referent 还没有弱引用，就为其新建一个 entry</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>t <span class="keyword">new</span><span class="number">_</span>entry;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.referent = referent;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.<span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>line = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[<span class="number">0</span>] = referrer;</span><br><span class="line">        <span class="comment">// 数组中 4 个referrer全部初始化为 nil</span></span><br><span class="line">        <span class="keyword">for</span> (size<span class="number">_</span>t i = <span class="number">1</span>; i &lt; WEAK<span class="number">_</span>INLINE<span class="number">_</span>COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查一下需不需要扩容</span></span><br><span class="line">        weak<span class="number">_</span>grow<span class="number">_m</span>aybe(weak<span class="number">_</span>table);</span><br><span class="line">        <span class="comment">// 将新建的 entry 插入 weak table 中</span></span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>insert(weak<span class="number">_</span>table, &amp;<span class="keyword">new</span><span class="number">_</span>entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> referent<span class="number">_</span>id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能就是讲referrer_id 插入到正确的位置，分为两种情况：</p><ol><li>如果根据referent_id可以找到一个weak_entry_t类型的实体entry ，就调用将append_referrer 将referrer_id插入到entry（相当于三级hash表）中。</li><li>如果没有，就需要新建一个weak_entry_t类型的实体new_entry。然后调用weak_entry_insert将new_entry插入到二级hash表中。</li></ol><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能是 nil</span></span><br><span class="line">    assert(referent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak_table 中存的实体数组</span></span><br><span class="line">    <span class="function"><span class="title">weak_entry_t</span> *weak_entries = weak_table-&gt;</span>weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) &#123;</span><br><span class="line">        return <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 Hash 的方法找到 referent 所在的索引，不过实在看不懂</span></span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = hash_pointer(referent) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span> (weak_table-&gt;</span>weak_entries[index].referent != referent) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="function"><span class="title">if</span> (hash_displacement &gt; weak_table-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">            return <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回找到的 weak_entry_t，这里可以证明 weak_entries 确实是一个数组</span></span><br><span class="line">    <span class="function"><span class="title">return</span> &amp;weak_table-&gt;</span>weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_entry_for_referent 根据给的的referent 在weak_table-&gt;weak_entries中遍历，是否有相同的，如果相同就返回对应的weak_entry_t类型的实体，如果没有nil。</p><p>hash_pointer 就是对对象referent的地址做个hash，然后和<code>weak_table-&gt;mask</code> 做与操作，返回的结果小于weak_table-&gt;mask，当做数组的索引。</p><p>hash_displacement记录的就是最佳位置和实际存储位置的便宜距离。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">weak_entry_t</span> *weak_entries = weak_table-&gt;</span>weak_entries;</span><br><span class="line">    assert(weak_entries != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 hash 决定 索引</span></span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = hash_pointer(new_entry-&gt;</span><span class="function"><span class="title">referent</span>) &amp; (weak_table-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该索引中已经有 entry，那么这个索引就不能用了，就找下一个索引</span></span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 new_entry 放入指定的索引中</span></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    <span class="function"><span class="title">weak_table</span>-&gt;</span>num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; weak_table-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">weak_table</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_entry_insert 就是在二级hash表中插入一个新的实体new_entry。通过hash_pointer找到一个最佳位置index，如果最佳位置已经有内容了，就接着查找下一个位置，直到找到空位置。记录下index。在index处插入new_entry。同时将num_entries累加1。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// out_of_line == 0 的情况</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (! entry-&gt;</span>out_of_line) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// inline_referrers 还放得下，就放在 inline_referrers 里</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>out_of_line = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">assert</span>(entry-&gt;</span>out_of_line);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到可以存放 new_referrer 的索引位置</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 index 处的对象替换成 new_referrer</span></span><br><span class="line">    <span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    <span class="comment">// 总数加一</span></span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append_referrer 是在三级hash表entry中出入一个新的弱引用着new_referrer。</p><p>分为三种情况：</p><ol><li>如果inline_referrers没有存储满，直接存储到inline_referrers中</li><li>如果inline_referrers个数是4个了，在插入，就需要将inline_referrers拷贝到referrers，然后进入第三步。</li><li>如果inline_referrers存储满了，判断是否需要扩容，然后将数据存储到referrers中。</li></ol><p>存储到inline_referrers的代码是：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储完成后，直接返回了，所以后面的代码就是存储在referrers的情况。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">    calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中</span></span><br><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">    <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>out_of_line = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码的功能是inline_referrers正好4个，如果再次添加，肯定放不下了，所以将inline_referrers中的数据移到referrers中。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">entry</span>-&gt;num_refs &gt;= TABLE_SIZE(<span class="keyword">entry</span>) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> grow_refs_and_insert(<span class="keyword">entry</span>, new_referrer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用超过 3/4，就先扩容，然后再插入。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 找到可以存放 new_referrer 的索引位置</span></span><br><span class="line"><span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != NULL) &#123;</span><br><span class="line">    <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">    hash_displacement++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 index 处的对象替换成 new_referrer</span></span><br><span class="line"><span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">ref = new_referrer;</span><br><span class="line"><span class="comment">// 总数加一</span></span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br></pre></td></tr></table></figure><p>上面的代码是通过弱引用着new_referrer找到index。然后从index开始，寻址空位置，将new_referrer插入到entry-&gt;referrers[index]位置处。同时将entry-&gt;num_refs累加</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>weak即使一个三级hash表。</p><ol><li>第一级用来提高效率的，可以想象，很多多选，放到一个hash表中，降低了效率。所有将多有的对象散列到64个表中。</li><li>二级缓存存储被弱引用的对象。</li><li>三级缓存存储某个对象的所有的弱引用着。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;weak相关源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="retain 和 release" scheme="http://yoursite.com/tags/retain-%E5%92%8C-release/"/>
    
  </entry>
  
  <entry>
    <title>15. 自动释放池的前世今生（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/15_autoreleasepool/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/15_autoreleasepool/</id>
    <published>2018-12-03T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:17.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 <code>autorelease</code> 方法，另一部分分析 <code>retain</code>、<code>release</code> 方法的实现以及自动引用计数。</p></blockquote><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章会在源代码层面介绍 Objective-C 中自动释放池，以及方法的 <code>autorelease</code> 的具体实现。</p><h2 id="从-main-函数开始"><a href="#从-main-函数开始" class="headerlink" title="从 main 函数开始"></a>从 main 函数开始</h2><p><code>main</code> 函数可以说是在整个 iOS 开发中非常不起眼的一个函数，它很好地隐藏在 <code>Supporting Files</code> 文件夹中，却是整个 iOS 应用的入口。<br><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main.png" alt="objc-autorelease-main"></p><p><code>main.m</code> 文件中的内容是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 <code>@autoreleasepool</code> block 中只包含了一行代码，这行代码将所有的事件、消息全部交给了 <code>UIApplication</code> 来处理，但是这不是本文关注的重点。</p><p>需要注意的是：<strong>整个 iOS 的应用都是包含在一个自动释放池 block 中的</strong>。</p><h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h2><p><code>@autoreleasepool</code> 到底是什么？我们在命令行中使用 <code>clang -rewrite-objc main.m</code> 让编译器重新改写这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -rewrite-objc main.m</span></span><br></pre></td></tr></table></figure><p>在生成了一大堆警告之后，当前目录下多了一个 <code>main.cpp</code> 文件</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main-cpp.png" alt="objc-autorelease-main-cpp"></p><blockquote><p>这里删除了 <code>main</code> 函数中其他无用的代码。</p></blockquote><p>在这个文件中，有一个非常奇怪的 <code>__AtAutoreleasePool</code> 的结构体，前面的注释写到 <code>/* @autoreleasepool */</code>。也就是说 <code>@autoreleasepool {}</code> 被转换为一个 <code>__AtAutoreleasePool</code> 结构体：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要弄清楚这行代码的意义，我们要在 <code>main.cpp</code> 中查找名为 <code>__AtAutoreleasePool</code> 的结构体：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main-cpp-struct.png" alt="objc-autorelease-main-cpp-struct"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，会在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p><p>这表明，我们的 <code>main</code> 函数在实际工作时其实是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line">        </span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@autoreleasepool</code> 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。</p><h2 id="AutoreleasePool-是什么"><a href="#AutoreleasePool-是什么" class="headerlink" title="AutoreleasePool 是什么"></a>AutoreleasePool 是什么</h2><p>这一节开始分析方法 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法看上去是对 <code>AutoreleasePoolPage</code> 对应<strong>静态方法</strong> <code>push</code> 和 <code>pop</code> 的封装。</p><p>这一小节会按照下面的顺序逐步解析代码中的内容：</p><ul><li><a href="#AutoreleasePoolPage">AutoreleasePoolPage 的结构</a></li><li><a href="#objc_autoreleasePoolPush">objc_autoreleasePoolPush 方法</a></li><li><a href="#objc_autoreleasePoolPop">objc_autoreleasePoolPop 方法</a></li></ul><h3 id="AutoreleasePoolPage-的结构"><a href="#AutoreleasePoolPage-的结构" class="headerlink" title="AutoreleasePoolPage 的结构"></a>AutoreleasePoolPage 的结构</h3><p><code>AutoreleasePoolPage</code> 是一个 C++ 中的类：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-AutoreleasePoolPage.png" alt="objc-autorelease-AutoreleasePoolPage"></p><p>它在 <code>NSObject.mm</code> 中的定义是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    <span class="keyword">id</span> *next;</span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>magic</code> 用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</li><li><code>thread</code> 保存了当前页所在的线程</li></ul><p><strong>每一个自动释放池都是由一系列的 <code>AutoreleasePoolPage</code> 组成的，并且每一个 <code>AutoreleasePoolPage</code> 的大小都是 <code>4096</code> 字节（16 进制 0x1000）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE I386_PGBYTES</span></span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>自动释放池中的 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-AutoreleasePoolPage-linked-list.png" alt="objc-autorelease-AutoreleasePoolPage-linked-list"></p><blockquote><p><code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</p></blockquote><h4 id="自动释放池中的栈"><a href="#自动释放池中的栈" class="headerlink" title="自动释放池中的栈"></a>自动释放池中的栈</h4><p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code> 中，它在内存中的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-page-in-memory.png" alt="objc-autorelease-page-in-memory"></p><p>其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的 <code>0x100816038 ~ 0x100817000</code> 都是用来存储<strong>加入到自动释放池中的对象</strong>。</p><blockquote><p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法帮助我们快速获取 <code>0x100816038 ~ 0x100817000</code> 这一范围的边界地址。</p></blockquote><p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-after-insert-to-page.png" alt="objc-autorelease-after-insert-to-page"></p><blockquote><p>关于 <code>hiwat</code> 和 <code>depth</code> 在文章中并不会进行介绍，因为它们并不影响整个自动释放池的实现，也不在关键方法的调用栈中。</p></blockquote><h4 id="POOL-SENTINEL（哨兵对象）"><a href="#POOL-SENTINEL（哨兵对象）" class="headerlink" title="POOL_SENTINEL（哨兵对象）"></a>POOL_SENTINEL（哨兵对象）</h4><p>到了这里，你可能想要知道 <code>POOL_SENTINEL</code> 到底是什么，还有它为什么在栈中。</p><p>首先回答第一个问题： <code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define POOL_SENTINEL nil</span></span><br></pre></td></tr></table></figure><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line">        </span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的 <code>atautoreleasepoolobj</code> 就是一个 <code>POOL_SENTINEL</code>。</p></blockquote><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-stack.png" alt="objc-autorelease-pop-stack"></p><h3 id="objc-autoreleasePoolPush-方法"><a href="#objc-autoreleasePoolPush-方法" class="headerlink" title="objc_autoreleasePoolPush 方法"></a><a id="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush 方法</h3><p>了解了 <code>POOL_SENTINEL</code>，我们来重新回顾一下 <code>objc_autoreleasePoolPush</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用 <code>AutoreleasePoolPage</code> 的类方法 <code>push</code>，也非常简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() &#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="autoreleaseFast"></a>在这里会进入一个比较关键的方法 <code>autoreleaseFast</code>，并传入哨兵对象 <code>POOL_SENTINEL</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法分三种情况选择不同的代码执行：</p><ul><li>有 <code>hotPage</code> 并且当前 <code>page</code> 不满<ul><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li><li>有 <code>hotPage</code> 并且当前 <code>page</code> 已满<ul><li>调用 <code>autoreleaseFullPage</code> 初始化一个新的页</li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li><li>无 <code>hotPage</code><ul><li>调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code></li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li></ul><p>最后的都会调用 <code>page-&gt;add(obj)</code> 将对象添加到自动释放池中。</p><blockquote><p><code>hotPage</code> 可以理解为当前正在使用的 <code>AutoreleasePoolPage</code>。</p></blockquote><h4 id="page-gt-add-添加对象"><a href="#page-gt-add-添加对象" class="headerlink" title="page-&gt;add 添加对象"></a>page-&gt;add 添加对象</h4><p><code>id *add(id obj)</code> 将对象添加到自动释放池页中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="keyword">id</span> *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>笔者对这个方法进行了处理，更方便理解。</p></blockquote><p>这个方法其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p><h4 id="autoreleaseFullPage（当前-hotPage-已满）"><a href="#autoreleaseFullPage（当前-hotPage-已满）" class="headerlink" title="autoreleaseFullPage（当前 hotPage 已满）"></a>autoreleaseFullPage（当前 hotPage 已满）</h4><p><code>autoreleaseFullPage</code> 会在当前的 <code>hotPage</code> 已满的时候调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会从传入的 <code>page</code> 开始遍历整个双向链表，直到：</p><ol><li>查找到一个未满的 <code>AutoreleasePoolPage</code></li><li>使用构造器传入 <code>parent</code> 创建一个新的 <code>AutoreleasePoolPage</code></li></ol><p>在查找到一个可以使用的 <code>AutoreleasePoolPage</code> 之后，会将该页面标记成 <code>hotPage</code>，然后调动上面分析过的 <code>page-&gt;add</code> 方法添加对象。</p><h4 id="autoreleaseNoPage（没有-hotPage"><a href="#autoreleaseNoPage（没有-hotPage" class="headerlink" title="autoreleaseNoPage（没有 hotPage)"></a>autoreleaseNoPage（没有 hotPage)</h4><p>如果当前内存中不存在 <code>hotPage</code>，就会调用 <code>autoreleaseNoPage</code> 方法初始化一个 <code>AutoreleasePoolPage</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然当前内存中不存在 <code>AutoreleasePoolPage</code>，就要<strong>从头开始构建这个自动释放池的双向链表</strong>，也就是说，新的 <code>AutoreleasePoolPage</code> 是没有 <code>parent</code> 指针的。</p><p>初始化之后，将当前页标记为 <code>hotPage</code>，然后会先向这个 <code>page</code> 中添加一个 <code>POOL_SENTINEL</code> 对象，来确保在 <code>pop</code> 调用的时候，不会出现异常。</p><p>最后，将 <code>obj</code> 添加到自动释放池中。</p><h3 id="objc-autoreleasePoolPop-方法"><a href="#objc-autoreleasePoolPop-方法" class="headerlink" title="objc_autoreleasePoolPop 方法"></a><a id="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop 方法</h3><p>同样，回顾一下上面提到的 <code>objc_autoreleasePoolPop</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中<strong>传入其它的指针也是可行的</strong>，会将自动释放池释放到相应的位置。</p></blockquote><p>我们一般都会在这个方法中传入一个哨兵对象 <code>POOL_SENTINEL</code>，如下图一样释放对象：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-stack.png" alt="objc-autorelease-pop-stack"></p><h4 id="对-objc-autoreleasePoolPop-行为的测试"><a href="#对-objc-autoreleasePoolPop-行为的测试" class="headerlink" title="对 objc_autoreleasePoolPop 行为的测试"></a>对 objc_autoreleasePoolPop 行为的测试</h4><p>在继续分析这个方法之前做一个小测试，在 <code>objc_autoreleasePoolPop</code> 传入非哨兵对象，测试一下这个方法的行为。</p><p>下面是 <code>main.m</code> 文件中的源代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *s = <span class="string">@"Draveness"</span>;</span><br><span class="line">        [s stringByAppendingString:<span class="string">@"-Suffix"</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的这一行打一个断点，因为这里会调用 <code>autorelease</code> 方法，将字符串加入自动释放池：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-breakpoint-main.png" alt="objc-autorelease-breakpoint-main"></p><p>当代码运行到这里时，通过 lldb 打印出当前 <code>hotPage</code> 中的栈内容：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-print-pool-content.png" alt="objc-autorelease-print-pool-content"></p><ol><li>通过 <code>static</code> 方法获取当前 <code>hotPage</code></li><li>打印 <code>AutoreleasePoolPage</code> 中的内容</li><li>打印当前 <code>next</code> 指针指向的内容，以及之前的内容，<code>-2</code>时已经到了 <code>begin()</code> 位置</li><li>使用 <code>print()</code>和 <code>printAll()</code>打印自动释放池中内容</li></ol><p>然后将字符串 <code>@&quot;Draveness-Suffix&quot;</code> 的指针传入 <code>pop</code> 方法，测试 <code>pop</code> 方法能否传入非哨兵参数。</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-string.png" alt="objc-autorelease-pop-string"></p><p>再次打印当前 <code>AutoreleasePoolPage</code> 的内容时，字符串已经不存在了，这说明<strong>向 <code>pop</code> 方法传入非哨兵参数是可行的</strong>，只是我们一般不会传入非哨兵对象。</p><hr><p>让我们重新回到对 <code>objc_autoreleasePoolPop</code> 方法的分析，也就是 <code>AutoreleasePoolPage::pop</code> 方法的调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = pageForPointer(token);</span><br><span class="line">    <span class="keyword">id</span> *stop = (<span class="keyword">id</span> *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个方法中删除了大量无关的代码，以及对格式进行了调整。</p></blockquote><p>该静态方法总共做了三件事情：</p><ol><li>使用 <code>pageForPointer</code> 获取当前 <code>token</code> 所在的 <code>AutoreleasePoolPage</code></li><li>调用 <code>releaseUntil</code> 方法释放<strong>栈中的</strong>对象，直到 <code>stop</code></li><li>调用 <code>child</code> 的 <code>kill</code> 方法</li></ol><blockquote><p>我到现在也不是很清楚为什么要根据当前页的不同状态 <code>kill</code> 掉不同 <code>child</code> 的页面。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">    page-&gt;child-&gt;kill();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">    page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pageForPointer-获取-AutoreleasePoolPage"><a href="#pageForPointer-获取-AutoreleasePoolPage" class="headerlink" title="pageForPointer 获取 AutoreleasePoolPage"></a>pageForPointer 获取 AutoreleasePoolPage</h4><p><code>pageForPointer</code> 方法主要是通过内存地址的操作，获取当前指针所在页的首地址：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="keyword">return</span> pageForPointer((uintptr_t)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    uintptr_t offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt;= <span class="keyword">sizeof</span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;fastcheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指针与页面的大小，也就是 4096 取模，得到当前指针的偏移量，因为所有的 <code>AutoreleasePoolPage</code> 在内存中都是对齐的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = 0x100816048</span><br><span class="line">p % SIZE = 0x48</span><br><span class="line">result = 0x100816000</span><br></pre></td></tr></table></figure><p>而最后调用的方法 <code>fastCheck()</code> 用来检查当前的 <code>result</code> 是不是一个 <code>AutoreleasePoolPage</code>。</p><blockquote><p>通过检查 <code>magic_t</code> 结构体中的某个成员是否为 <code>0xA1A1A1A1</code>。</p></blockquote><h4 id="releaseUntil-释放对象"><a href="#releaseUntil-释放对象" class="headerlink" title="releaseUntil 释放对象"></a>releaseUntil 释放对象</h4><p><code>releaseUntil</code> 方法的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> releaseUntil(<span class="keyword">id</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        <span class="keyword">id</span> obj = *--page-&gt;next;</span><br><span class="line">        memset((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现还是很容易的，用一个 <code>while</code> 循环持续释放 <code>AutoreleasePoolPage</code> 中的内容，直到 <code>next</code> 指向了 <code>stop</code> 。</p><p>使用 <code>memset</code> 将内存的内容设置成 <code>SCRIBBLE</code>，然后使用 <code>objc_release</code> 释放对象。</p><h4 id="kill-方法"><a href="#kill-方法" class="headerlink" title="kill() 方法"></a>kill() 方法</h4><p>到这里，没有分析的方法就只剩下 <code>kill</code> 了，而它会将当前页面以及子页面全部删除：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> kill() &#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = <span class="literal">nil</span>;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorelease-方法"><a href="#autorelease-方法" class="headerlink" title="autorelease 方法"></a>autorelease 方法</h3><p>我们已经对自动释放池生命周期有一个比较好的了解，最后需要了解的话题就是 <code>autorelease</code> 方法的实现，先来看一下方法的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> autorelease]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootAutorelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootAutorelease2()</span><br><span class="line">        └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">            └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                └── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>在 <code>autorelease</code> 方法的调用栈中，最终都会调用上面提到的 <a href="#autoreleaseFast">autoreleaseFast</a> 方法，将当前对象加到 <code>AutoreleasePoolPage</code> 中。</p><p>这一小节中这些方法的实现都非常容易，只是进行了一些参数上的检查，最终还要调用 <a href="#autoreleaseFast">autoreleaseFast</a> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> objc_object::rootAutorelease() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,used)) <span class="keyword">id</span> objc_object::rootAutorelease2() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">   <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在上面已经分析过 <code>autoreleaseFast</code> 方法的实现，这里就不会多说了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个自动释放池 <code>AutoreleasePool</code> 的实现以及 <code>autorelease</code> 方法都已经分析完了，我们再来回顾一下文章中的一些内容：</p><ul><li>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</li><li>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</li><li>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What is autoreleasepool? - Objective-C</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" rel="external nofollow noopener noreferrer" target="_blank">Using Autorelease Pool Blocks</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/occ/cl/NSAutoreleasePool" rel="external nofollow noopener noreferrer" target="_blank">NSAutoreleasePool</a></li><li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" rel="external nofollow noopener noreferrer" target="_blank">黑幕背后的 Autorelease</a></li></ul><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 &lt;code&gt;autorelease&lt;/code&gt; 方法，另一部分分析 &lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt; 方法的实现以及自动引用计数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="autorelease" scheme="http://yoursite.com/tags/autorelease/"/>
    
  </entry>
  
  <entry>
    <title>14. 关联对象 AssociatedObject 完全解析（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/14_AssociatedObject%20/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/14_AssociatedObject /</id>
    <published>2018-12-02T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:23.213Z</updated>
    
    <content type="html"><![CDATA[<p>我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 <code>@property</code> 并不能在分类中<strong>正确</strong>创建实例变量和存取方法。</p><p>不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。</p><p>这篇文章包含了两方面的内容：</p><ul><li><a href="#关联对象的应用">使用关联对象为已经存在的类中添加属性</a></li><li><a href="#关联对象的实现">关联对象在底层 Objective-C 中的实现</a></li></ul><blockquote><p>注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。</p><p>如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从<a href="#关联对象的实现">这里</a>开始深入了解其底层实现。</p></blockquote><a id="more"></a> <h2 id="关联对象的应用"><a href="#关联对象的应用" class="headerlink" title="关联对象的应用"></a>关联对象的应用</h2><p>关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。</p><h3 id="分类中的-property"><a href="#分类中的-property" class="headerlink" title="分类中的 @property"></a>分类中的 @property</h3><p><code>@property</code> 可以说是一个 Objective-C 编程中的“宏”，它有<a href="https://zh.wikipedia.org/zh/元编程" rel="external nofollow noopener noreferrer" target="_blank">元编程</a>的思想。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DKObject </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSString *property;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>在使用上述代码时会做三件事：</p><ul><li>生成实例变量 <code>_property</code></li><li>生成 <code>getter</code> 方法 <code>- property</code></li><li>生成 <code>setter</code> 方法 <code>- setProperty:</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation DKObject &#123;</span><br><span class="line">    NSString *_property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)<span class="keyword">property</span><span class="title"> </span>&#123;</span><br><span class="line">    return _property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setProperty:(NSString *)<span class="keyword">property</span><span class="title"> </span>&#123;</span><br><span class="line">    _property = <span class="keyword">property</span><span class="title"></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 <code>@property</code> 生成一个属性，那么为什么在分类中不可以呢？</p><p>我们来做一个小实验：创建一个 <code>DKObject</code> 的分类 <code>Category</code>，并添加一个属性 <code>categoryProperty</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> DKObject (Category)</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告：</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-warning-category-property.png" alt="objc-ao-warning-category-property"></p><p>在这里的警告告诉我们 <code>categoryProperty</code> 属性的存取方法需要自己手动去实现，或者使用 <code>@dynamic</code> 在运行时实现这些方法。</p><p>换句话说，分类中的 <code>@property</code> 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</p><h3 id="使用关联对象"><a href="#使用关联对象" class="headerlink" title="使用关联对象"></a>使用关联对象</h3><p>Q：我们为什么要使用关联对象？</p><p>A：因为在分类中 <code>@property</code> 并不会自动生成实例变量以及存取方法，所以<strong>一般使用关联对象为已经存在的类添加『属性』</strong>。</p><p>上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个<strong>伪属性</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"DKObject+Category.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DKObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)categoryProperty &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCategoryProperty:(<span class="built_in">NSString</span> *)categoryProperty &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>_cmd</code> 代指当前方法的选择子，也就是 <code>@selector(categoryProperty)</code>。</p></blockquote><p>我们使用了两个方法 <code>objc_getAssociatedObject</code> 以及 <code>objc_setAssociatedObject</code> 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。</p><p>在这里有必要解释两个问题：</p><ol><li>为什么向方法中传入 <code>@selector(categoryProperty)</code>？</li><li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 是干什么的？</li></ol><p>关于第一个问题，我们需要看一下这两个方法的原型：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>@selector(categoryProperty)</code> 也就是参数中的 <code>key</code>，其实可以使用静态指针 <code>static void *</code> 类型的参数来代替，不过在这里，笔者强烈推荐使用 <code>@selector(categoryProperty)</code> 作为 <code>key</code> 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 <code>key</code> 的唯一性。</p><p><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 又是什么呢？如果我们使用 <code>Command</code> 加左键查看它的定义：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里的注释我们能看到很多东西，也就是说不同的 <code>objc_AssociationPolicy</code> 对应了不通的属性修饰符：</p><table><thead><tr><th style="text-align:left">objc_AssociationPolicy</th><th style="text-align:center">modifier</th></tr></thead><tbody><tr><td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:center">assign</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:center">nonatomic, strong</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:center">nonatomic, copy</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td><td style="text-align:center">atomic, strong</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY</td><td style="text-align:center">atomic, copy</td></tr></tbody></table><p>而我们在代码中实现的属性 <code>categoryProperty</code> 就相当于使用了 <code>nonatomic</code> 和 <code>strong</code> 修饰符。</p><blockquote><p>关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，<a href="https://google.com" rel="external nofollow noopener noreferrer" target="_blank">Google</a> 是一个很好的选择。</p></blockquote><p>到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。</p><p>@property` 其实有元编程的思想，它能够为我们自动生成<strong>实例变量以及存取方法</strong>，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.<span class="keyword">property</span> &lt;=&gt; [<span class="built_in">self</span> <span class="keyword">property</span>]</span><br><span class="line"><span class="built_in">self</span>.<span class="keyword">property</span> = value &lt;=&gt; [<span class="built_in">self</span> setProperty:value]</span><br></pre></td></tr></table></figure><p>在分类中，因为类的实例变量的布局已经固定，使用 <code>@property</code> 已经<strong>无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量）</strong>，所以我们需要<strong>使用关联对象以及两个方法来模拟构成属性的三个要素</strong>。</p><blockquote><p>如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。</p></blockquote><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><blockquote><p>探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。</p></blockquote><p>这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>三个方法的作用分别是：</p><ul><li>以键值对形式添加关联对象</li><li>根据 <code>key</code> 获取关联对象</li><li>移除所有关联对象</li></ul><p>而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。</p><h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>首先是 <code>objc_setAssociatedObject</code> 方法，这个方法的调用栈并不复杂：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>) </span></span><br><span class="line"><span class="function">└── <span class="keyword">void</span> <span class="title">objc_setAssociatedObject_non_gc</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span></span><br><span class="line"><span class="function">    └── <span class="keyword">void</span> _<span class="title">object_set_associative_reference</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr_t policy</span>)</span></span><br></pre></td></tr></table></figure><p>调用栈中的 <code>_object_set_associative_reference</code> 方法实际完成了设置关联对象的任务：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。</p></blockquote><p>我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用：</p><ul><li><code>AssociationsManager</code></li><li><code>AssociationsHashMap</code></li><li><code>ObjcAssociationMap</code></li><li><code>ObjcAssociation</code></li></ul><h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><p><code>AssociationsManager</code> 在源代码中的定义是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">spinlock_t</span> _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">spinlock_t</span> AssociationsManager::_lock;</span><br><span class="line">AssociationsHashMap *AssociationsManager::_map = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>它维护了 <code>spinlock_t</code> 和 <code>AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code>lock.lock()</code> 方法，在析构时会调用 <code>lock.unlock()</code>，而 <code>associations</code> 方法用于取得一个全局的 <code>AssociationsHashMap</code> 单例。</p><p>也就是说 <code>AssociationsManager</code> 通过持有一个<a href="https://en.wikipedia.org/wiki/Spinlock" rel="external nofollow noopener noreferrer" target="_blank">自旋锁</a> <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即<strong>每次只会有一个线程对 AssociationsHashMap 进行操作</strong>。</p><h4 id="如何存储-ObjcAssociation"><a href="#如何存储-ObjcAssociation" class="headerlink" title="如何存储 ObjcAssociation"></a>如何存储 ObjcAssociation</h4><p><code>ObjcAssociation</code> 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p><p>首先，<code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code> 到 <code>ObjectAssociationMap</code> 的映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>ObjectAssociationMap</code> 则保存了从 <code>key</code> 到关联对象 <code>ObjcAssociation</code> 的映射，<strong>这个数据结构保存了当前对象对应的所有关联对象</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最关键的 <code>ObjcAssociation</code> 包含了 <code>policy</code> 以及 <code>value</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">    id _value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ObjcAssociation(<span class="keyword">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(<span class="number">0</span>), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> policy() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="function">id <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        NSObject *obj = [NSObject <span class="keyword">new</span>];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="meta">@selector</span>(hello), @<span class="string">"Hello"</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关联对象 <code>ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @&quot;Hello&quot;)</code> 在内存中是这么存储的：</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-associateobjcect.png" alt="objc-ao-associateobjcect"></p><hr><p>接下来我们可以重新回到对 <code>objc_setAssociatedObject</code> 方法的分析了。</p><p>在这里会将方法的执行分为两种情况：</p><ul><li><code>new_value != nil</code> 设置/更新关联对象的值</li><li><code>new_value == nil</code> 删除一个关联对象</li></ul><h4 id="new-value-nil"><a href="#new-value-nil" class="headerlink" title="new_value != nil"></a>new_value != nil</h4><p>先来分析在 <code>new_value != nil</code> 的情况下，该方法的执行是什么样的：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br><span class="line"></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">            associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>old_association(0, nil)</code> 创建一个临时的 <code>ObjcAssociation</code> 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</li><li><p>调用 <code>acquireValue</code> 对 <code>new_value</code> 进行 <code>retain</code> 或者 <code>copy</code></p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> acquireValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化一个 <code>AssociationsManager</code>，并获取唯一的保存关联对象的哈希表 <code>AssociationsHashMap</code></p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager<span class="comment">;</span></span><br><span class="line">AssociationsHashMap &amp;associations(<span class="name">manager</span>.associations())<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>先使用 <code>DISGUISE(object)</code> 作为 key 寻找对应的 <code>ObjectAssociationMap</code></p></li><li><p>如果没有找到，初始化一个 <code>ObjectAssociationMap</code>，再实例化 <code>ObjcAssociation</code> 对象添加到 Map 中，并调用 <code>setHasAssociatedObjects</code> 方法，表明当前对象含有关联对象</p> <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line"><span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br></pre></td></tr></table></figure></li><li><p>如果找到了对应的 <code>ObjectAssociationMap</code>，就要看 <code>key</code> 是否存在了，由此来决定是更新原有的关联对象，还是增加一个</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O<span class="function"><span class="title">bjectAssociationMap</span> *refs = i-&gt;</span>second;</span><br><span class="line">O<span class="function"><span class="title">bjectAssociationMap</span>::iterator j = refs-&gt;</span>find(key);</span><br><span class="line"><span class="function"><span class="title">if</span> (j != refs-&gt;</span>end()) &#123;</span><br><span class="line">    <span class="function"><span class="title">old_association</span> = j-&gt;</span>second;</span><br><span class="line">    <span class="function"><span class="title">j</span>-&gt;</span>second = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后的最后，如果原来的关联对象有值的话，会调用 <code>ReleaseValue()</code> 释放关联对象的值</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ReleaseValue &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span>(<span class="params"></span>) (<span class="params">ObjcAssociation &amp;association</span>) </span>&#123;</span><br><span class="line">        releaseValue(association.<span class="keyword">value</span>(), association.policy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseValue</span>(<span class="params">id <span class="keyword">value</span>, uintptr_t policy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(<span class="keyword">value</span>, SEL_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到这里，该条件下的方法实现就结束了。</p><h4 id="new-value-nil-1"><a href="#new-value-nil-1" class="headerlink" title="new_value == nil"></a>new_value == nil</h4><p>如果 <code>new_value == nil</code>，就说明我们要删除对应 <code>key</code> 的关联对象，实现如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(<span class="name">id</span> object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i !=  associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                old_association = j-&gt;second<span class="comment">;</span></span><br><span class="line">                refs-&gt;erase(<span class="name">j</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">old_association</span>.hasValue()) ReleaseValue()(<span class="name">old_association</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下方法的实现与前面的唯一区别就是，我们会调用 <code>erase</code> 方法，擦除 <code>ObjectAssociationMap</code> 中 <code>key</code> 对应的节点。</p><h4 id="setHasAssociatedObjects"><a href="#setHasAssociatedObjects" class="headerlink" title="setHasAssociatedObjects()"></a>setHasAssociatedObjects()</h4><p>其实上面的两种情况已经将 <code>objc_setAssociatedObject</code> 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，<code>setHasAssociatedObjects()</code> 方法的作用是什么？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> void objc_object:<span class="type"></span>:setHasAssociatedObjects() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line"><span class="type">    isa_t oldisa </span>= LoadExclusive(&amp;isa.bits);</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">isa</span>.indexed) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">isa</span>.has_assoc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span>.has_assoc = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits)) goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会将 <code>isa</code> 结构体中的标记位 <code>has_assoc</code> 标记为 <code>true</code>，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 <code>isa</code> 中的各个标记位都是干什么的。</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-isa-struct.png" alt="objc-ao-isa-struct"></p><blockquote><p>如果想要了解关于 isa 的知识，可以阅读<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解 isa</a></p></blockquote><h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>我们既然已经对 <code>objc_setAssociatedObject</code> 的实现已经比较熟悉了，相信对于 <code>objc_getAssociatedObject</code> 的理解也会更加容易。</p><p>方法的调用栈和 <code>objc_setAssociatedObject</code> 非常相似：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">└── <span class="keyword">id</span> objc_getAssociatedObject_non_gc(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    └── <span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure><p>而 <code>_object_get_associative_reference</code> 相比于前面方法的实现更加简单。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">                value = entry.value()<span class="comment">;</span></span><br><span class="line">                policy = entry.policy()<span class="comment">;</span></span><br><span class="line">                if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_retain)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_autorelease)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中寻找关联对象的逻辑和 <code>objc_setAssociatedObject</code> 差不多：</p><ol><li>获取静态变量 <code>AssociationsHashMap</code></li><li>以 <code>DISGUISE(object)</code> 为 key 查找 <code>AssociationsHashMap</code></li><li>以 <code>void *key</code> 为 key 查找 <code>ObjcAssociation</code></li><li><p>根据 <code>policy</code> 调用相应的方法</p> <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id<span class="comment">(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span></span><br><span class="line"><span class="comment">    ((id(*)</span>(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回关联对象 <code>ObjcAssociation</code> 的值</p></li></ol><h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><p>关于最后的 <code>objc_removeAssociatedObjects</code> 方法，其实现也相对简单，这是方法的调用栈：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc<span class="number">_</span>removeAssociatedObjects(id <span class="keyword">object</span>)</span><br><span class="line">└── <span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(id <span class="keyword">object</span>)</span><br></pre></td></tr></table></figure><p>这是简化版本的 <code>objc_removeAssociatedObjects</code> 方法实现：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc<span class="number">_</span>removeAssociatedObjects(id <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">object</span> &amp;&amp; <span class="keyword">object</span>-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(<span class="keyword">object</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加速移除对象的关联对象的速度，我们会通过标记位 <code>has_assoc</code> 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 <code>_object_remove_assocations</code> 方法移除对象上所有的关联对象：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements<span class="comment">;</span></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager<span class="comment">;</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations())<span class="comment">;</span></span><br><span class="line">        if (associations.size() == <span class="number">0</span>) return<span class="comment">;</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t </span><span class="keyword">disguised_object </span>= <span class="keyword">DISGUISE(object);</span></span><br><span class="line"><span class="keyword"> </span>       AssociationsHashMap::iterator i = associations.find(<span class="keyword">disguised_object);</span></span><br><span class="line"><span class="keyword"> </span>       if (i != associations<span class="meta">.end</span>()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            for (ObjectAssociationMap::iterator <span class="keyword">j </span>= refs-&gt;<span class="keyword">begin(), </span>end = refs-&gt;end()<span class="comment">; j != end; ++j) &#123;</span></span><br><span class="line">                elements.push_back(<span class="keyword">j-&gt;second);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            delete refs<span class="comment">;</span></span><br><span class="line">            associations.erase(i)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(elements.<span class="keyword">begin(), </span>elements<span class="meta">.end</span>(), ReleaseValue())<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="关于应用"><a href="#关于应用" class="headerlink" title="关于应用"></a>关于应用</h3><p>本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。</p><ul><li>如果你把属性理解为<strong>通过方法访问的实例变量</strong>，我相信这个问题的答案是不能，<strong>因为分类不能为类增加额外的实例变量</strong>。</li><li>不过如果属性只是一个<strong>存取方法以及存储值的容器的集合</strong>，那么分类是可以实现属性的。</li></ul><blockquote><p><strong>分类中对属性的实现其实只是实现了一个看起来像属性的接口而已</strong>。</p></blockquote><h3 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h3><p>关联对象又是如何实现并且管理的呢：</p><ul><li>关联对象其实就是 <code>ObjcAssociation</code> 对象</li><li>关联对象由 <code>AssociationsManager</code> 管理并在  <code>AssociationsHashMap</code> 存储</li><li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li><li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li><li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li></ul><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 &lt;code&gt;@property&lt;/code&gt; 并不能在分类中&lt;strong&gt;正确&lt;/strong&gt;创建实例变量和存取方法。&lt;/p&gt;
&lt;p&gt;不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。&lt;/p&gt;
&lt;p&gt;这篇文章包含了两方面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#关联对象的应用&quot;&gt;使用关联对象为已经存在的类中添加属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#关联对象的实现&quot;&gt;关联对象在底层 Objective-C 中的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。&lt;/p&gt;
&lt;p&gt;如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从&lt;a href=&quot;#关联对象的实现&quot;&gt;这里&lt;/a&gt;开始深入了解其底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="AssociatedObject" scheme="http://yoursite.com/tags/AssociatedObject/"/>
    
  </entry>
  
</feed>
