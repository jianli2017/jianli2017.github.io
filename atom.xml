<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-21T06:45:38.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fishhook学习记录</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/"/>
    <id>http://yoursite.com/wiki/IOS /开源库学习/fishhook/</id>
    <published>2018-06-20T04:07:12.000Z</published>
    <updated>2018-06-21T06:45:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个源码是OOMDetector中替换malloc函数的源码。使用这个源码的目的是可以方便的看出fishhook提供的api的调用方式。</p><p>首先，fishhook定义了一个结构体，存储替换的数据。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">//替换的函数名字</span></span><br><span class="line">  <span class="keyword">void</span> *replacement; <span class="comment">//替换后的函数指针</span></span><br><span class="line">  <span class="keyword">void</span> **replaced;   <span class="comment">//原始的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的替换malloc等函数的入口函数，该函数调用了fishhook的<code>rebind_symbols_for_imagename</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookMalloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        beSureAllRebindingFuncBeenCalled();</span><br><span class="line">        </span><br><span class="line">        orig_malloc = <span class="built_in">malloc</span>;</span><br><span class="line">        orig_calloc = <span class="built_in">calloc</span>;</span><br><span class="line">        orig_valloc = valloc;</span><br><span class="line">        orig_realloc = <span class="built_in">realloc</span>;</span><br><span class="line">        orig_block_copy = _Block_copy;</span><br><span class="line">        </span><br><span class="line">        rebind_symbols_for_imagename(</span><br><span class="line">                                     (struct rebinding[<span class="number">5</span>])&#123;</span><br><span class="line">                                         &#123;<span class="string">"realloc"</span>,(<span class="keyword">void</span>*)new_realloc,(<span class="keyword">void</span>**)&amp;orig_realloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"malloc"</span>, (<span class="keyword">void</span>*)new_malloc, (<span class="keyword">void</span> **)&amp;orig_malloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"valloc"</span>,(<span class="keyword">void</span>*)new_valloc,(<span class="keyword">void</span>**)&amp;orig_valloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"calloc"</span>,(<span class="keyword">void</span>*)new_calloc,(<span class="keyword">void</span>**)&amp;orig_calloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"_Block_copy"</span>,(<span class="keyword">void</span>*)new_block_copy,(<span class="keyword">void</span>**)&amp;orig_block_copy&#125;&#125;,</span><br><span class="line">                                     <span class="number">5</span>,</span><br><span class="line">                                     getImagename());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        isPaused = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hookMalloc</code>替换了<code>realloc</code>、<code>malloc</code>、<code>valloc</code>、<code>calloc</code>、<code>_Block_copy</code>这几个函数。</p><p>下面是新的<code>new_malloc</code>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">new_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = orig_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        global_leakChecker-&gt;recordMallocStack((<span class="keyword">vm_address_t</span>)ptr, (<span class="keyword">uint32_t</span>)size,<span class="string">"malloc"</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __enable_malloc_logger__</span></span><br><span class="line">    malloc_printf(<span class="string">"malloc ptr:%p size:%lu thread:%lu\n"</span>,ptr, size,mach_thread_self());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new_malloc</code>函数首先会调用原来的<code>malloc</code>函数，接着会记录申请的内存的堆栈。</p><p>下面是rebind_symbols_for_imagename第三个入参————镜像名称的获取方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getImagename</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">        name = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<mach-o dyld.h=""> 头文件中的<code>_dyld_get_image_name</code>函数。 <code>_dyld_get_image_name</code> 根据镜像的索引，获取镜像的名称。<code>strrchr</code>函数是反向查找第一个给定字符。返回查找到的结果。</mach-o></p><p>下面代码进入fishhook的入口函数<code>rebind_symbols_for_imagename</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebind_symbols_for_imagename</span><span class="params">(struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> rebindings_nel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span> *imagename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">mach_header_t</span>* header = (<span class="keyword">const</span> <span class="keyword">mach_header_t</span>*)_dyld_get_image_header(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">long</span> slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">            name = tmp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,imagename) == <span class="number">0</span>)&#123;</span><br><span class="line">            rebind_symbols_image((<span class="keyword">void</span> *)header,</span><br><span class="line">                                 slide,</span><br><span class="line">                                 rebindings,</span><br><span class="line">                                 rebindings_nel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebindings</code>替换的函数信息结构体，<code>rebindings_nel</code>替换的函数指针的个数，<code>imagename</code>要替换函数指针镜像名称，也就是只替换名称为<code>imagename</code>文件中的函数指针，其他库不做替换。</p><p><code>_dyld_get_image_header</code> 获取镜像的header头，<code>_dyld_get_image_vmaddr_slide</code>获取镜像的随机启动地址。<code>rebind_symbols_for_imagename</code>函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考<a href="https://stackoverflow.com/questions/13574933/ios-crash-reports-atos-not-working-as-expected/13576028#13576028" rel="external nofollow noopener noreferrer" target="_blank">iOS crash reports: atos not working as expected</a>、<font color="red"> <a href="https://www.cnblogs.com/feng9exe/p/7988360.html" rel="external nofollow noopener noreferrer" target="_blank">iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol</a></font> 。</p><p>下面为了理解ALSR中的slide，贴出一段测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">understandALSR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///枚举所有镜像</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *image_name = (<span class="keyword">char</span> *)_dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> *<span class="title">mh</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">i</span>);</span></span><br><span class="line">        <span class="keyword">intptr_t</span> vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\n"</span>,</span><br><span class="line">               image_name, (<span class="keyword">mach_vm_address_t</span>)mh, vmaddr_slide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image name <span class="regexp">/Users/</span>lijian<span class="regexp">/Library/</span>Developer<span class="regexp">/CoreSimulator/</span>Devices<span class="regexp">/21045765-7E1F-499B-A985-1BCCFC70B079/</span>data<span class="regexp">/Containers/</span>Bundle<span class="regexp">/Application/</span><span class="number">0975</span>D79D-<span class="number">5079</span>-<span class="number">4258</span>-<span class="number">8</span>A0F-<span class="number">48175818</span>A28A<span class="regexp">/LearnMachO.app/</span>LearnMachO ,image header <span class="number">0</span>x10dff0000 , ASLR slide <span class="number">0</span>xdff0000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libBacktraceRecording.dylib ,image header <span class="number">0</span>x10e07c000 , ASLR slide <span class="number">0</span>x10e07c000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libMainThreadChecker.dylib ,image header <span class="number">0</span>x10e08b000 , ASLR slide <span class="number">0</span>x10e08b000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/</span>Developer<span class="regexp">/Library/</span>PrivateFrameworks<span class="regexp">/DTDDISupport.framework/</span>libViewDebuggerSupport.dylib ,image header <span class="number">0</span>x10e27d000 , ASLR slide <span class="number">0</span>x10e27d000.</span><br></pre></td></tr></table></figure><p>代码对应的二进制文件中的加载地址（链接时load address）示意图：<br><img src="learnMachO.jpg" alt="learnMachO"><br><img src="libbacktraceRecording.jpg" alt="learnMachO"><br>结合上面的示例代码和二进制内容图片，可以诠释下面的公式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slide = (运行时)load<span class="built_in"> address </span>- (链接时)load address;</span><br><span class="line">symble<span class="built_in"> address </span>＝ stack<span class="built_in"> address </span>－slide；</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>stack address ： 程序运行时线程栈中 所有 函数调用的地址</li><li>symble address ： dsym文件中函数符号对应的地址，用此地址在dsym 文件中可以查出对应的符号信息。 </li></ol><p>可以看出，没有ASLR时：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symble<span class="built_in"> address </span>=  stack address</span><br></pre></td></tr></table></figure><p>好了，接着看<code>rebind_symbols_image</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                         struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">rebindings_head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_image</code> 主要工作是通过<code>prepend_rebindings</code>构造绑定的结构体struct rebindings_entry，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int prepend_rebindings(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> **rebindings_head,</span><br><span class="line">                              <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span> rebindings[],</span><br><span class="line">                              size_t nel) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///申请new_entry地址                  </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *new_entry = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span>));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///给new_entry-&gt;rebindings分配内存</span></span><br><span class="line">  new_entry-&gt;rebindings = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///拷贝重新绑定信息到new_entry-&gt;rebindings</span></span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者</span></span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepend_rebindings 只是将绑定的struct rebinding类型参数转化为struct rebindings_entry结构，这种结构类似链表，可以方便的管理多个struct rebinding结构。下面看rebind_symbols_for_image：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void rebind_symbols_for_image(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span> *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="comment">///find the image containing a given address</span></span><br><span class="line">  <span class="comment">///验证库是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">///SEG_LINKEDIT commond指针</span></span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  <span class="comment">///LC_SYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>* symtab_cmd = NULL;</span><br><span class="line">  <span class="comment">///LC_DYSYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>* dysymtab_cmd = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">///定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针</span></span><br><span class="line">  uintptr_t cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      symtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      dysymtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses 查找符号表和string表</span></span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="built_in">char</span> *strtab = (<span class="built_in">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) </span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + <span class="keyword">sizeof</span>(segment_command_t)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_for_image</code> 函数主要定位到三表、类型为<code>S_LAZY_SYMBOL_POINTERS</code>、<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section。然后调用<code>perform_rebinding_with_section</code> 函数。其中部分宏定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SEG_LINKEDIT<span class="meta-string">"__LINKEDIT"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_NON_LAZY_SYMBOL_POINTERS 0x6  <span class="comment">/* section with only non-lazy symbol pointers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_LAZY_SYMBOL_POINTERS 0x7     <span class="comment">/* section with only lazy symbol</span></span></span><br></pre></td></tr></table></figure><p>上面的宏定义于<mach-o loader.h="">文件中，位于458行。<font color="red"> 在S_NON_LAZY_SYMBOL_POINTERS宏的上面有一段注释。这段注释非常的关键。说明了S_NON_LAZY_SYMBOL_POINTERS类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。</font></mach-o></p><p>For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries. </p><p>对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。 </p><p>For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure. </p><p>间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。</p><p>Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries  in the section is 4 bytes (看结构是8bytes，可能是64位的缘故)</p><p>由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节<br></p><p>下面是<code>perform_rebinding_with_section</code>函数源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,  <span class="comment">//section</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,     <span class="comment">//基址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,  <span class="comment">//符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,  <span class="comment">//sting 表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab <span class="comment">//动态符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///section加载到内存的虚拟地址（是要替换这里面的东西）</span></span><br><span class="line">    <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///section中替换函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。</span></span><br><span class="line">        <span class="comment">///下面目的是获取section中存储的函数指针的符号  动态符号表-&gt; 符号表-&gt; string表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引</span></span><br><span class="line">        <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">        <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">            symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。</span></span><br><span class="line">        <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">        <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">        <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///如果符号名称和替换的名称一样，进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                      indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">///保存原始的指针地址，只保存一次</span></span><br><span class="line">                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。   </span></span><br><span class="line">                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">                    <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        symbol_loop:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perform_rebinding_with_section函数完成替换的关键函数。 将section中的</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/78444203?locationNum=3&amp;fps=1" rel="external nofollow noopener noreferrer" target="_blank">Fishhook替换C函数的原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个源码是OOMDetector中替换malloc函数的源码。使用这个源码的目的是可以方便的看出fishhook提供的api的调用方式。&lt;/p&gt;
&lt;p&gt;首先，fishhook定义了一个结构体，存储替换的数据。定义如下：&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="fishhook" scheme="http://yoursite.com/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>Xcode编译环境变量</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/wiki/工具/Xcode编译常量/xcode编译环境变量/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T08:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看图吧</p><p><img src="http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="xcode 环境变量"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Xcode编译常量" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>合并真机模拟器静态库(转载)</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E5%8A%A8%E6%80%81%E5%BA%93/static_lib_aggregate_script/"/>
    <id>http://yoursite.com/wiki/IOS /动态库/static_lib_aggregate_script/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T09:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章解释合并真机模拟器静态库的脚本</p><a id="more"></a><h2 id="合成脚本"><a href="#合成脚本" class="headerlink" title="合成脚本"></a>合成脚本</h2><p>合并的脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/build</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"build_DIR=<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/include/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_INCLUDE=<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_A=<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphonesimulator/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"SIMULATOR_DIR_A=<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line">open <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="铺路"><a href="#铺路" class="headerlink" title="铺路"></a>铺路</h2><p>本代码中用到的核心命令：</p><h3 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h3><p>苹果给的一个命令。主要用来编译Xcode的工程。<br>可以在终端中输入xcodebuild -h来查看命令的详情，介绍一下本脚本中用到的几个参数</p><ul><li>clean:clean一下工程</li><li>-configuration Release<br>使用Release方式编译，还可以使用Debug</li><li>-sdk iphoneos<br>真机编译，还可以使用-sdk iphonesimulator模拟器编译</li></ul><h3 id="cp-“源文件路径”-“目标文件路径”"><a href="#cp-“源文件路径”-“目标文件路径”" class="headerlink" title="cp “源文件路径” “目标文件路径”"></a>cp “源文件路径” “目标文件路径”</h3><p>复制”源文件路径”的文件到 “目标文件路径”</p><h3 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h3><p>lipo -create “模拟器.a文件路径” “真机.a文件路径” -output “目标.a文件路径”</p><p>将模拟器和真机的.a包合成。</p><h3 id="用到的一些shell脚本基础命令"><a href="#用到的一些shell脚本基础命令" class="headerlink" title="用到的一些shell脚本基础命令"></a>用到的一些shell脚本基础命令</h3><h4 id="echo-“你要写的东西”"><a href="#echo-“你要写的东西”" class="headerlink" title="echo “你要写的东西”"></a>echo “你要写的东西”</h4><p>打印的log,将”你要写的东西”打印出来，相当于OC中的NSLog<br>Xcode的话，运行脚本后，可以在这里找到log</p><h4 id="赋值命令。-变量名-变量值"><a href="#赋值命令。-变量名-变量值" class="headerlink" title="赋值命令。 变量名=变量值"></a>赋值命令。 变量名=变量值</h4><p>比如将”CrazyStone”赋值给MyName变量</p><p>MyName=CrazyStone</p><h4 id="变量名"><a href="#变量名" class="headerlink" title="${变量名}"></a>${变量名}</h4><p>取出变量名的内容。<br>比如：取出变量MyName中的内容<br>${MyName}</p><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>if [ 条件语句 ]then<br>…<br>fi<br>条件语句为真就执行then后面的语句，不成立就结束判断语句</p><h4 id="本脚本中用到的判断语句："><a href="#本脚本中用到的判断语句：" class="headerlink" title="本脚本中用到的判断语句："></a>本脚本中用到的判断语句：</h4><p>[ -d “文件夹路径” ] ：判断是否为文件夹</p><h2 id="脚本结构解释"><a href="#脚本结构解释" class="headerlink" title="脚本结构解释"></a>脚本结构解释</h2><p>看完上面，我想你再看一下代码应该就能理解脚本，然后可以做一些简单的改动了。下面再介绍一下脚本的结构。</p><h3 id="执行条件–-编译"><a href="#执行条件–-编译" class="headerlink" title="执行条件– 编译"></a>执行条件– 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#我们的大部分脚本代码</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本的时候做个判断，在Xcode里面build这个工程的时候就执行then后面的脚本</p><h3 id="工程名称定义"><a href="#工程名称定义" class="headerlink" title="工程名称定义"></a>工程名称定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>变量target_Name是我们要编译的target的名字，在这里指的是工程的名字${PROJECT_NAME}，也就是MySDK。</p><p>顺便说一下，ACTION和PROJECT_NAME都是Xcode里面定义的，这是在Xcode里面写脚本的一个好处。</p><h3 id="build-路径"><a href="#build-路径" class="headerlink" title="build 路径"></a>build 路径</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=$&#123;SRCROOT&#125;/build</span><br><span class="line">    echo <span class="string">"build_DIR=$&#123;build_DIR&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=$&#123;build_DIR&#125;/Release-iphoneos/<span class="keyword">include</span>/$&#123;PROJECT_NAME&#125;</span><br><span class="line">    echo <span class="string">"DEVICE_DIR_INCLUDE=$&#123;DEVICE_DIR_INCLUDE&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=$&#123;build_DIR&#125;/Release-iphoneos/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"DEVICE_DIR_A=$&#123;DEVICE_DIR_A&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=$&#123;build_DIR&#125;/Release-iphonesimulator/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"SIMULATOR_DIR_A=$&#123;SIMULATOR_DIR_A&#125;"</span></span><br></pre></td></tr></table></figure><p>这里是定义的build之后各个文件的路径。我们执行了xcodebuild命令之后，会在工程目录生成一个build文件夹，里面有build之后生成的文件。打开Finder看看就知道各个文件的路径了。</p><h3 id="build目录的位置"><a href="#build目录的位置" class="headerlink" title="build目录的位置"></a>build目录的位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是定义目标变量的路径了。你想把文件放在哪里？在这里定义咯。${SRCROOT}表示工程的根目录。用了这么久的Xcode，这个有用过吧(全局头文件配置过吧？)？</p><h3 id="文件状态判断"><a href="#文件状态判断" class="headerlink" title="文件状态判断"></a>文件状态判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是文件的操作了。如果有这两个文件夹，就删除掉。为什么？为了保证我们工程的纯净啊。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br></pre></td></tr></table></figure><p>这里就跟平常操作一样了。先clean一下工程，然后模拟器编译一次，真机编译一次。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line"><span class="attribute">cp</span> -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>关键代码。拷贝头文件到我们的目标位置去。合成.a包。大功告成。</p><h3 id="打开目标文件夹"><a href="#打开目标文件夹" class="headerlink" title="打开目标文件夹"></a>打开目标文件夹</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line"><span class="keyword">open</span> <span class="string">"<span class="subst">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>最后，打开文件夹。检查一下文件是否真正生成了。</p><h2 id="shell脚本基础知识"><a href="#shell脚本基础知识" class="headerlink" title="shell脚本基础知识"></a>shell脚本基础知识</h2><p>如果你想了解更多关于shell脚本的知识，可以看看这篇文章：Linux shell脚本基础学习详细介绍</p><h2 id="xcworkspace-工程对应的脚本"><a href="#xcworkspace-工程对应的脚本" class="headerlink" title="xcworkspace 工程对应的脚本"></a>xcworkspace 工程对应的脚本</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphoneos</span><br></pre></td></tr></table></figure><p>对于xcworkspace工程，需要将编译的脚本替换 ，其中–workspace、-scheme是必须的 ，scheme 可以通过xcodebuild -list 查看。</p><h2 id="iOS设备架构"><a href="#iOS设备架构" class="headerlink" title="iOS设备架构"></a>iOS设备架构</h2><p>模拟器：<br>iPhone4s-iPnone5：i386<br>iPhone5s-iPhone7 Plus：x86_64</p><p>真机:<br>iPhone3gs-iPhone4s：     armv7<br>iPhone5-iPhone5c：        armv7s<br>iPhone5s-iPhone7 Plus： arm64</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9cf90b9537fd" rel="external nofollow noopener noreferrer" target="_blank">【iOS开发】静态库.a文件合成脚本解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章解释合并真机模拟器静态库的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="动态库" scheme="http://yoursite.com/categories/IOS/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>查看虚拟内存</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B2/"/>
    <id>http://yoursite.com/wiki/IOS /虚拟内存/虚拟内存之2/</id>
    <published>2018-06-02T04:07:12.000Z</published>
    <updated>2018-06-02T04:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.<br>如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。</p><p>The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">Instruments User Guide</a> and the other articles in this document. For information on how to use the top tool,<br>以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">仪器用户指南</a>和本文中的其他文章。有关如何使用顶部工具的信息，请参见<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">2</a>。see <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">Performance Overview</a>.</p><a id="more"></a><h2 id="Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）"><a href="#Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）" class="headerlink" title="Viewing Virtual Memory Statistics（查看虚拟内存统计信息）"></a>Viewing Virtual Memory Statistics（查看虚拟内存统计信息）</h2><p>The vm_stat tool displays high-level statistics about the current virtual memory usage of the system. By default, vm_stat displays these statistics once, but you can specify an interval value (in seconds) to update these statistics continuously. For information on the usage of this tool, see the vm_stat man page.<br>vm_stat工具显示关于系统当前虚拟内存使用情况的高级统计信息。默认情况下，vm_stat只显示这些统计信息一次，但是您可以指定一个间隔值(以秒为单位)来持续更新这些统计信息。有关此工具使用的信息，请参见vm_stat手册页。</p><p>Listing 1 shows an example of the output from vm_stat. </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mach Virtual Memory Statistics: (page size <span class="keyword">of</span> <span class="number">4096</span> bytes)</span><br><span class="line">Pages free:                     <span class="number">3194</span>.</span><br><span class="line">Pages active:                  <span class="number">34594</span>.</span><br><span class="line">Pages inactive:                <span class="number">17870</span>.</span><br><span class="line">Pages wired down:               <span class="number">9878</span>.</span><br><span class="line"><span class="string">"Translation faults"</span>:        <span class="number">6333197</span>.</span><br><span class="line">Pages copy-on-write:           <span class="number">81385</span>.</span><br><span class="line">Pages zero filled:           <span class="number">3180051</span>.</span><br><span class="line">Pages reactivated:            <span class="number">343961</span>.</span><br><span class="line">Pageins:                       <span class="number">33043</span>.</span><br><span class="line">Pageouts:                      <span class="number">78496</span>.</span><br><span class="line">Object cache: <span class="number">66227</span> hits <span class="keyword">of</span> <span class="number">96952</span> lookups (<span class="number">68</span><span class="comment">% hit rate)</span></span><br></pre></td></tr></table></figure><h2 id="Viewing-Mach-O-Code-Pages"><a href="#Viewing-Mach-O-Code-Pages" class="headerlink" title="Viewing Mach-O Code Pages"></a>Viewing Mach-O Code Pages</h2><p>The pagestufftool displays information about the specified logical pages of a file conforming to the Mach-O executable format. For each specified page of code, symbols (function and static data structure names) are displayed. All pages in the <strong>TEXT, </strong>text section are displayed if no page numbers are given.<br>pagestufftool显示符合Mach-O可执行格式的文件的指定逻辑页的信息。对于每个指定的代码页，将显示符号(函数和静态数据结构名称)。如果没有给出页码，则显示__TEXT节中的所有页面。</p><p>Listing 2 shows part of the output from pagestuff for the TextEdit application. This output is the result of running the tool with the -a option, which prints information about all of the executable’s code pages. It includes the virtual address locations of each page and the type of information on that page.<br>清单2显示了TextEdit应用程序的页面内容的部分输出。此输出是使用-a选项运行工具的结果，该选项打印关于可执行文件的所有代码页的信息。它包括每个页面的虚拟地址位置和页面上的信息类型。</p><p>Listing 2  Partial output of pagestuff tool</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">File<span class="built_in"> Page </span>0 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>1 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>2 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>2 virtual<span class="built_in"> address </span>0x3a08 <span class="keyword">to</span> 0x4000</span><br><span class="line">File<span class="built_in"> Page </span>3 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>3 virtual<span class="built_in"> address </span>0x4000 <span class="keyword">to</span> 0x5000</span><br><span class="line">File<span class="built_in"> Page </span>4 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>4 virtual<span class="built_in"> address </span>0x5000 <span class="keyword">to</span> 0x6000</span><br><span class="line"> </span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__cstring)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal4)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal8)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__const)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>22 virtual<span class="built_in"> address </span>0x17000 <span class="keyword">to</span> 0x17ffc</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__data)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__la_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__nl_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__dyld)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__cfstring)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__bss)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__common)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>23 virtual<span class="built_in"> address </span>0x18000 <span class="keyword">to</span> 0x18d48</span><br><span class="line"> 0x00018000 _NXArgc</span><br><span class="line"> 0x00018004 _NXArgv</span><br><span class="line"> 0x00018008 _environ</span><br><span class="line"> 0x0001800c ___progname</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>In the preceding listing, if a page exports any symbols, those symbols are also displayed by the -a option. If you want to view the symbols for a single page, pass in the desired page number instead of the -a option. For more information about the pagestuff tool and its supported options, see the pagestuff man page.</p><p>在前面的列表中，如果一个页面导出任何符号，那么这些符号也会被a选项显示。如果要查看单个页面的符号，请输入所需的页码，而不是-a选项。有关pagestuff工具及其支持选项的更多信息，请参见pagestuff man页面。</p><h2 id="Viewing-Virtual-Memory-Regions"><a href="#Viewing-Virtual-Memory-Regions" class="headerlink" title="Viewing Virtual Memory Regions"></a>Viewing Virtual Memory Regions</h2><p>The vmmap and vmmap64 tools display the virtual memory regions allocated for a specified process. These tools provide access to the virtual memory of 32-bit and 64-bit applications, respectively. You can use them to understand the purpose of memory at a given address and how that memory is being used. For each virtual-memory region, these tools display the type of page, the starting address, region size (in kilobytes), read/write permissions, sharing mode, and the purpose of the pages in that region.<br>vmmap和vmmap64工具显示为指定进程分配的虚拟内存区域。这些工具分别提供对32位和64位应用程序的虚拟内存的访问。您可以使用它们来理解给定地址的内存用途以及内存的使用方式。对于每个虚拟内存区域，这些工具显示页面的类型、起始地址、区域大小(单位为千字节)、读/写权限、共享模式和该区域的页面用途。</p><p>The following sections show you how to interpret the output from the vmmap tool. For more information about the vmmap and vmmap64 tools, see the vmmap or vmmap64 man pages.<br>以下部分将向您展示如何解释vmmap工具的输出。有关vmmap和vmmap64工具的更多信息，请参见vmmap或vmmap64手册页面。</p><p>Sample Output From vmmap<br>Listing 3 shows some sample output from the vmmap tool. This example is not a full listing of the tool’s output but is an abbreviated version showing the primary sections.</p><p>Listing 3  Typical output of vmmap</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">==== Non-writable regions <span class="keyword">for</span> process 313</span><br><span class="line">__PAGEZERO              0 [   4K] ---/--- <span class="attribute">SM</span>=NUL <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__TEXT               1000 [  40K] r-x/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__LINKEDIT           e000 [   4K] r--/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/w/Clock</span><br><span class="line">                    90000 [   4K] r--/r-- <span class="attribute">SM</span>=SHM</span><br><span class="line">                   340000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">                   789000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">Submap           90000000-9fffffff r--/r-- machine-wide submap</span><br><span class="line">__TEXT           90000000  [ 932K] r-x/r-x <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__LINKEDIT       900e9000   [ 260K] r--/r-- <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__TEXT           90130000 [ 740K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__LINKEDIT       901e9000 [ 188K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__TEXT           90220000 [2144K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">__LINKEDIT       90438000 [ 296K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">==== Writable regions <span class="keyword">for</span> process 606</span><br><span class="line">__DATA             18000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV /Contents/MacOS/TextEdit</span><br><span class="line">__OBJC             19000 [   8K] rw-/rwx <span class="attribute">SM</span>=COW /Contents/MacOS/TextEdit</span><br><span class="line">MALLOC_OTHER       1d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(DefaultMallocZone_0x5d2c0)     5d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                   9d000 [ 372K] rw-/rwx <span class="attribute">SM</span>=COW 33320000 00000020 00000000 00001b84<span class="built_in">..</span>.</span><br><span class="line">VALLOC_USED(DefaultMallocZone_0x5d2c0)     ff000 [  36K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsDefaultZone_0x10  108000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsRegionZone_0x148  148000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">Submap           a000b000-a012ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0130000 [  28K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">Submap           a0137000-a021ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0220000 [  20K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">Submap           a0225000-a048ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0490000 [  12K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./IOKit.framework/Versions/A/IOKit</span><br><span class="line">Submap           a0493000-a050ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0510000 [  36K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/OSServices</span><br><span class="line">                 b959e000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b95a0000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b9630000 [ 164K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b965a000 [ 896K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 bff80000 [ 504K] rw-/rwx <span class="attribute">SM</span>=ZER</span><br><span class="line">STACK[0]         bfffe000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 bffff000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">__DATA           c000c000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV <span class="built_in">..</span>./Versions/A/ApplicationEnhancer</span><br><span class="line">STACK[1]         f0001000 [ 512K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 ff002000 [12272K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 </span><br><span class="line">                 ==== Legend</span><br><span class="line"><span class="attribute">SM</span>=sharing mode:</span><br><span class="line">    <span class="attribute">COW</span>=copy_on_write <span class="attribute">PRV</span>=private <span class="attribute">NUL</span>=empty <span class="attribute">ALI</span>=aliased</span><br><span class="line">    <span class="attribute">SHM</span>=shared <span class="attribute">ZER</span>=zero_filled S/<span class="attribute">A</span>=shared_alias</span><br><span class="line"> </span><br><span class="line">==== Summary <span class="keyword">for</span> process 313</span><br><span class="line">ReadOnly portion of Libraries: <span class="attribute">Total</span>=27420KB <span class="attribute">resident</span>=12416KB(45%) <span class="attribute">swapped_out_or_unallocated</span>=15004KB(55%)</span><br><span class="line">Writable regions: <span class="attribute">Total</span>=21632KB <span class="attribute">written</span>=536KB(2%) <span class="attribute">resident</span>=1916KB(9%) <span class="attribute">swapped_out</span>=0KB(0%) <span class="attribute">unallocated</span>=19716KB(91%)</span><br></pre></td></tr></table></figure><p>If you specify the -d parameter (plus an interval in seconds), vmmap takes two snapshots of virtual-memory usage—one at the beginning of a specified interval and the other at the end—and displays the differences. It shows three sets of differences:</p><ul><li>individual differences</li><li>regions in the first snapshot that are not in the second</li><li>regions in the second snapshot that are not in the first</li></ul><p>如果您指定-d参数(加上以秒为单位的间隔)，vmmap将获取两个虚拟内存使用快照(一个在指定的间隔开始，另一个在结束)，并显示差异。它显示了三组差异:</p><ul><li>个体差异</li><li>第一个快照中的区域而不是第二个快照中的区域</li><li>第二个快照中不属于第一个快照的区域</li></ul><p>Interpreting vmmap’s Output<br>The columns of vmmap output have no headings. Instead you can interpret the type of data in each column by its format. Table 1 describes these columns.</p><p>Table 1  Column descriptions for vmmap</p><p><strong>Table 1</strong>  Column descriptions for vmmap</p><table><thead><tr><th>Column Number</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td><code>__TEXT</code>, <code>__LINKEDIT</code>, <code>MALLOC_USED</code>, <code>STACK</code>, and so on</td><td>The purpose of the memory. This column can contain the name of a Mach-O segment or the memory allocation technique.</td></tr><tr><td>2</td><td><code>(DefaultMallocZone_0x5d2c0)</code></td><td>If present, the zone used for allocation.</td></tr><tr><td>3</td><td><code>4eee000</code></td><td>The virtual memory address of the region.</td></tr><tr><td>4</td><td><code>[ 124K]</code></td><td>The size of the region, measured in kilobytes</td></tr><tr><td>5</td><td><code>rw-/rwx</code></td><td>Read, write and execution permissions for the region. The first set of flags specifies the current protection for the region. The second set of values specifies the maximum protection for the region. If an entry contains a dash (<code>-</code>), the process does not have the target permission.</td></tr><tr><td>6</td><td><code>SM=PRV</code></td><td>Sharing mode for the region, either <code>COW</code> (copy-on-write), <code>PRV</code> (private), <code>NUL</code> (empty), <code>ALI</code> (aliased), or <code>SHM</code> (shared).</td></tr><tr><td>7</td><td><code>...ts/MacOS/Clock</code></td><td>The end of the pathname identifying the executable mapped into this region of virtual memory. If the region is stack or heap memory, nothing is displayed in this column.</td></tr></tbody></table><p>Column 1 identifies the purpose of the memory. A <strong>TEXT segment contains read-only code and data. A </strong>DATA segment contains data that may be both readable and writable. For allocated data, this column shows how the memory was allocated, such as on the stack, using malloc, and so on. For regions loaded from a library, the far right column shows the name of the library loaded into memory.<br>第1列标识内存的用途。<strong>TEXT段包含只读代码和数据。</strong>DATA段包含可读和可写的数据。对于已分配的数据，这一列显示如何分配内存，例如使用malloc在堆栈上，等等。对于从库中加载的区域，最右边的列显示加载到内存中的库的名称。</p><p>The size of the virtual memory region (column 4) represents the total size reserved for that region. This number may not reflect the actual number of memory pages allocated for the region. For example, calling vm_allocate reserves a set of memory pages but does not allocate any physical memory until the pages are actually touched. Similarly, a memory-mapped file may reserve a set of pages, but the system does not load pages until a read or write event occurs on the file.<br>虚拟内存区域的大小(第4列)表示该区域保留的总大小。这个数字可能不能反映为该区域分配的内存页的实际数量。例如，调用vm_allocation会保留一组内存页，但在实际操作这些页之前不会分配任何物理内存。类似地，内存映射文件可以保留一组页面，但是系统在文件上发生读或写事件之前不会加载页面。</p><p>The protection mode (column 5) describes the access restrictions for the memory region. A memory region contains separate flags for read, write, and execution permissions. Each virtual memory region has a current permission, and a maximum permission. In the output from vmmap, the current permission appears first followed by the maximum permission. Thus, if the permissions are “r–/rwx“ the page is currently read-only but allows read, write, and execution access as its maximum allowed permissions. Typically, the current permissions do not permit writing to a region. However, these permissions may change under certain circumstances. For example, a debugger may request write access to a page in order to set a breakpoint.<br>保护模式(第5列)描述了内存区域的访问限制。内存区域包含用于读取、写入和执行权限的单独标志。每个虚拟内存区域都有一个当前权限和最大权限。在vmmap的输出中，当前权限首先显示为最大权限。因此，如果权限是“r- /rwx”，页面当前是只读的，但允许读、写和执行访问作为其最大允许的权限。通常，当前权限不允许写入区域。但是，这些权限在某些情况下可能会改变。例如，调试器可以请求对页面的写访问，以便设置断点。</p><p>The sharing mode (SM= field) tells you whether pages are shared between processes and what happens when pages are modified. Private pages (PRV) are visible only to the process and are allocated as they are used. Private pages can also be paged out to disk. Copy-on-write (COW) pages are shared by multiple processes (or shared by a single process in multiple locations). When the page is modified, the writing process then receives its own copy of the page. Empty (NUL) sharing implies that the page does not really exist in physical memory. Aliased (ALI) and shared (SHM) memory are shared between processes.<br>共享模式(SM= field)告诉您进程之间是否共享页面，以及修改页面时会发生什么。私有页面(PRV)只对进程可见，并在使用它们时进行分配。还可以将私有页面分页到磁盘。写时复制(COW)页面由多个进程共享(或由多个位置的单个进程共享)。当页面被修改时，编写过程将收到它自己的页面副本。空(NUL)共享意味着页面并不真正存在于物理内存中。别名(ALI)和共享(SHM)内存在进程之间共享。</p><p>The sharing mode typically describes the general mode controlling the region. For example, as copy-on-write pages are modified, they become private to the application. However, the region containing those private pages is still copy-on-write until all pages become private. Once all pages are private, the sharing mode changes to private.<br>共享模式通常描述控制该区域的通用模式。例如，当对写后复制的页面进行修改时，它们将成为应用程序的私有页面。但是，包含这些私有页面的区域仍然是“写时复制”，直到所有页面变为私有。一旦所有页面都是私有的，共享模式就会变为私有。</p><p>Some lines in the output of vmmap describe submaps. A submap is a shared set of virtual memory page descriptions that the operating system can reuse between multiple processes. For example, the memory between 0x90000000 and 0xAFFFFFFF is a submap containing the most common dynamic libraries. Submaps minimize the operating system’s memory usage by representing the virtual memory regions only once. Submaps can either be shared by all processes (machine-wide) or be local to the process (process-only). If the contents of a machine-wide submap are changed—for example, the debugger makes a section of memory for a dynamic library writable so it can insert debugging traps—then the submap becomes local, and the kernel allocates memory to store the extra copy.<br>vmmap输出中的一些行描述子映射。子映射是操作系统可以在多个进程之间重用的一组共享的虚拟内存页面描述。例如，0x90000000和0xAFFFFFFF之间的内存是包含最常见动态库的子映射。子映射只表示一次虚拟内存区域，从而最小化操作系统的内存使用。子映射可以由所有进程(机器范围内)共享，也可以是进程(仅处理)的本地映射。如果修改了机器范围的子映射的内容(例如，调试器为动态库编写一个内存段，以便它可以插入调试trap)，那么子映射就变成本地的，内核分配内存来存储额外的副本。</p><p>[a]:</p><p>[a]:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.&lt;br&gt;如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。&lt;/p&gt;
&lt;p&gt;The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Instruments User Guide&lt;/a&gt; and the other articles in this document. For information on how to use the top tool,&lt;br&gt;以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅&lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;仪器用户指南&lt;/a&gt;和本文中的其他文章。有关如何使用顶部工具的信息，请参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;。see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Performance Overview&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存之一----关于</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/IOS /虚拟内存/虚拟内存/</id>
    <published>2018-06-01T04:07:12.000Z</published>
    <updated>2018-06-02T04:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译下<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" rel="external nofollow noopener noreferrer" target="_blank">Memory Usage Performance Guidelines</a></p><a id="more"></a><h2 id="About-Virtual-Memory"><a href="#About-Virtual-Memory" class="headerlink" title="About Virtual Memory"></a>About Virtual Memory</h2><p>Virtual memory allows an operating system to escape the limitations of physical RAM. The virtual memory manager creates a logical address space (or “virtual” address space) for each process and divides it up into uniformly-sized chunks of memory called pages. The processor and its memory management unit (MMU) maintain a page table to map pages in the program’s logical address space to hardware addresses in the computer’s RAM. When a program’s code accesses an address in memory, the MMU uses the page table to translate the specified logical address into the actual hardware memory address. This translation occurs automatically and is transparent to the running application. </p><p><font color="red">虚拟内存允许操作系统摆脱物理RAM的限制。虚拟内存管理器为每个进程创建一个逻辑地址空间(或“虚拟”地址空间)，</font>并将其划分为大小相同的称为页面的内存块。处理器及其内存管理单元(MMU)维护一个页表，将程序逻辑地址空间中的页映射到计算机RAM中的硬件地址。当程序的代码访问内存中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动进行的，对正在运行的应用程序是透明的。</p><p>As far as a program is concerned, addresses in its logical address space are always available. 就程序而言，其逻辑地址空间中的地址总是可用的。<br>However, if an application accesses an address on a memory page that is not currently in physical RAM, a page fault occurs.但是，如果应用程序访问当前不在物理RAM中的内存页上的地址，则会发生页面错误。 When that happens, the virtual memory system invokes a special page-fault handler to respond to the fault immediately.当发生这种情况时，虚拟内存系统调用一个特殊的页面错误处理程序来立即响应错误。 The page-fault handler stops the currently executing code, locates a free page of physical memory, loads the page containing the needed data from disk, updates the page table, and then returns control to the program’s code, which can then access the memory address normally. This process is known as paging. 页面错误处理程序停止当前执行的代码，定位物理内存的空闲页面，从磁盘装载包含所需数据的页面，更新页面表，然后返回对程序代码的控制，然后程序代码就可以正常地访问内存地址。这个过程称为分页。</p><p>If there are no free pages available in physical memory, the handler must first release an existing page to make room for the new page.如果在物理内存中没有可用的空闲页面，处理程序必须首先释放一个现有页面，以便为新页面腾出空间。 How the system release pages depends on the platform. 系统释放页面的方式取决于平台。In OS X, the virtual memory system often writes pages to the backing store.在OS X中，虚拟内存系统经常将页面写入后备存储器。 The backing store is a disk-based repository containing a copy of the memory pages used by a given process.后备存储是一个基于磁盘的存储库，其中包含给定进程使用的内存页的副本。 Moving data from physical memory to the backing store is called paging out (or “swapping out”);将数据从物理内存移动到后台存储被称为分页(或“交换出”); moving data from the backing store back in to physical memory is called paging in (or “swapping in”). 将数据从后台存储恢复到物理内存称为分页in(或“交换in”)。In iOS, there is no backing store and so pages are are never paged out to disk, but read-only pages are still be paged in from disk as needed.在iOS中，没有备份存储，所以不会将页面调出到磁盘，但是只读页面仍然根据需要从磁盘调入。</p><p>In OS X and in earlier versions of iOS, the size of a page is 4 kilobytes.在OS X和iOS的早期版本中，页面的大小是4千字节。 In later versions of iOS, A7- and A8-based systems expose 16-kilobyte pages to the 64-bit userspace backed by 4-kilobyte physical pages,在iOS的后续版本中，基于A7和基于a8的系统将16千字节的页暴露给由4千字节物理页支持的64位用户空间， while A9 systems expose 16-kilobyte pages backed by 16-kilobyte physical pages. 而A9系统将16千字节的页暴露给由16千字节物理页支持的64位用户空间。These sizes determine how many kilobytes the system reads from disk when a page fault occurs. 这些大小决定了当发生页面错误时系统从磁盘读取多少千字节。Disk thrashing can occur when the system spends a disproportionate amount of time handling page faults and reading and writing pages, rather than executing code for a program. 当系统花费过多的时间处理页面错误、读写页面，而不是为程序执行代码时，就会发生磁盘抖动。</p><p>Paging of any kind, and disk thrashing in particular, affects performance negatively because it forces the system to spend a lot of time reading and writing to disk. Reading a page in from the backing store takes a significant amount of time and is much slower than reading directly from RAM. If the system has to write a page to disk before it can read another page from disk, the performance impact is even worse.<br>任何类型的分页，特别是磁盘抖动，都会对性能产生负面影响，因为这会迫使系统花费大量时间对磁盘进行读写。从后台存储读取页面需要大量的时间，而且比直接从RAM读取要慢得多。如果系统必须在从磁盘读取另一个页面之前将一个页面写到磁盘，那么性能的影响甚至更糟。</p><h2 id="Details-of-the-Virtual-Memory-System"><a href="#Details-of-the-Virtual-Memory-System" class="headerlink" title="Details of the Virtual Memory System"></a>Details of the Virtual Memory System</h2><p>The logical address space of a process consists of mapped regions of memory. Each mapped memory region contains a known number of virtual memory pages. Each region has specific attributes controlling such things as inheritance (portions of the region may be mapped from “parent” regions), write-protection, and whether it is wired (that is, it cannot be paged out). Because regions contain a known number of pages, they are page-aligned, meaning the starting address of the region is also the starting address of a page and the ending address also defines the end of a page.<br>进程的逻辑地址空间由内存的映射区域组成。每个映射内存区域包含已知数量的虚拟内存页。每个区域都有特定的属性来控制诸如继承(该区域的一部分可以从“父”区域映射)、写保护以及它是否连接(也就是说，它不能被分页)。因为区域包含已知的页数，所以它们是页面对齐的，这意味着该区域的起始地址也是页面的起始地址，而结尾地址也定义了页面的结束地址。</p><p>The kernel associates a VM object with each region of the logical address space.<font color="red">内核将VM对象与逻辑地址空间的每个区域关联起来。</font> The kernel uses VM objects to track and manage the resident and nonresident pages of the associated regions.内核使用VM对象跟踪和管理关联区域的驻留页和非驻留页。 A region can map to part of the backing store or to a memory-mapped file in the file system.区域可以映射到备份存储的一部分，或者映射到文件系统中的内存映射文件。 Each VM object contains a map that associates regions with either the default pager or the vnode pager. 每个VM对象都包含一个映射，该映射将区域与默认分页器或vnode分页器关联起来。The default pager is a system manager that manages the nonresident virtual memory pages in the backing store and fetches those pages when requested. 默认分页器是一个系统管理器，它管理后台存储中的非驻留虚拟内存页，并在请求时获取这些页。The vnode pager implements memory-mapped file access. vnode分页器实现内存映射文件访问。The vnode pager uses the paging mechanism to provide a window directly into a file. vnode分页器使用分页机制直接向文件提供一个窗口。This mechanism lets you read and write portions of the file as if they were located in memory.该机制允许您读取和写入文件的部分，就像它们位于内存中一样。</p><p>In addition to mapping regions to either the default or vnode pager, a VM object may also map regions to another VM object. The kernel uses this self referencing technique to implement copy-on-write regions. Copy-on-write regions allow different processes (or multiple blocks of code within a process) to share a page as long as none of them write to that page. When a process attempts to write to the page, a copy of the page is created in the logical address space of the process doing the writing. From that point forward, the writing process maintains its own separate copy of the page, which it can write to at any time. Copy-on-write regions let the system share large quantities of data efficiently in memory while still letting processes manipulate those pages directly (and safely) if needed. These types of regions are most commonly used for the data pages loaded from system frameworks.<br>除了将区域映射到默认或vnode页导航之外，VM对象还可以将区域映射到另一个VM对象。内核使用这种自引用技术来实现写时复制区域。写后复制区域允许不同的进程(或一个进程中的多个代码块)共享一个页面，只要它们中没有一个写入该页。当进程试图写入页面时，将在执行写入操作的进程的逻辑地址空间中创建页面的副本。从那时起，编写过程就维护了它自己的页面的独立拷贝，它可以在任何时候对其进行写入。写后复制区域允许系统在内存中有效地共享大量数据，同时还允许进程在需要时直接(和安全地)操作这些页面。这些类型的区域通常用于从系统框架加载的数据页。<br>每个VM对象包含几个字段，如表1所示。</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Resident pages</td><td>A list of the pages of this region that are currently resident in physical memory.</td></tr><tr><td>Size</td><td>The size of the region, in bytes.</td></tr><tr><td>Pager</td><td>The pager responsible for tracking and handling the pages of this region in backing store.</td></tr><tr><td>Shadow</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Copy</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Attributes</td><td>Flags indicating the state of various implementation detai<em>**</em>ls.</td></tr></tbody></table><p>If the VM object is involved in a copy-on-write (<code>vm_copy</code>) operation, the shadow and copy fields may point to other VM objects. Otherwise both fields are usually <code>NULL</code>.</p><h2 id="Wired-Memory"><a href="#Wired-Memory" class="headerlink" title="Wired Memory"></a>Wired Memory</h2><p>Wired memory (also called resident memory) stores kernel code and data structures that must never be paged out to disk. Applications, frameworks, and other user-level software cannot allocate wired memory. However, they can affect how much wired memory exists at any time. For example, an application that creates threads and ports implicitly allocates wired memory for the required kernel resources that are associated with them.<br>Wired memory(也称为常驻内存)存储内核代码和数据结构，这些代码和数据结构永远不能被分页到磁盘上。应用程序、框架和其他用户级软件不能分配Wired memory。然而，它们可以影响在任何时候存在多少Wired memory。例如，创建线程和端口的应用程序隐式申请了Wired memory，这些内存是内核资源需要的。</p><p>Table 2 lists some of the wired-memory costs for application-generated entities.</p><table><thead><tr><th>Resource</th><th>Wired Memory Used by Kernel</th></tr></thead><tbody><tr><td>Process</td><td>16 kilobytes</td></tr><tr><td>Thread</td><td>blocked in a continuation—5 kilobytes; blocked—21 kilobyte</td></tr><tr><td>Mach port</td><td>116 bytes</td></tr><tr><td>Mapping</td><td>32 byte</td></tr><tr><td>Library</td><td>2 kilobytes plus 200 bytes for each task that uses it</td></tr><tr><td>Memory region</td><td>160 bytes</td></tr></tbody></table><p>As you can see, every thread, process, and library contributes to the resident footprint of the system. In addition to your application using wired memory, however, the kernel itself requires wired memory for the following entities:<br>如您所见，每个线程、进程和库都会影响系统的驻留内存。但是，除了使用Wired memory的应用程序之外，内核本身的以下实体会使用有线内存:</p><ol><li>VM objects</li><li>the virtual memory buffer cache</li><li>I/O buffer caches</li><li>drivers</li></ol><p>Wired data structures are also associated with the physical page and map tables used to store virtual-memory mapping information, Both of these entities scale with the amount of available physical memory. Consequently, when you add memory to a system, the amount of wired memory increases even if nothing else changes. When a computer is first booted into the Finder, with no other applications running, wired memory can consume approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system.<br>Wired data structures还与物理页面、用于存储虚拟内存映射信息的映射表相关联，这两个实体都与可用物理内存的大小相关联。因此，当您向系统添加内存时，即使没有其他变化，wired-memory的数量也会增加。当一台计算机第一次启动Finder时，没有其他应用程序运行时，在64兆系统中wired-memory可以消耗大约14兆字节 在128兆系统中消耗17兆字节。</p><p>Wired memory pages are not immediately moved back to the free list when they become invalid. Instead they are “garbage collected” when the free-page count falls below the threshold that triggers page out events.<br>Wired memory页在无效时不会立即移回空闲列表。相反，当空闲页面数低于触发page out事件的阈值时，它们会被“垃圾收集”。</p><h2 id="Page-Lists-in-the-Kernel"><a href="#Page-Lists-in-the-Kernel" class="headerlink" title="Page Lists in the Kernel"></a>Page Lists in the Kernel</h2><p>The kernel maintains and queries three system-wide lists of physical memory pages:<br>内核维护和查询三个系统范围的物理内存页列表:。</p><ul><li>The active list contains pages that are currently mapped into memory and have been recently accessed.</li><li>The inactive list contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be removed from memory at any time.</li><li>The free list contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them.</li></ul><ul><li>活动列表包含当前映射到内存和最近访问的页面。</li><li>非活动列表包含当前驻留在物理内存中但最近未被访问的页面。这些页面包含有效的数据，但是可以随时从内存中删除。</li><li>空闲列表包含 没有和任何VM对象关联的物理内存页。任何需要这些页面的进程都可以立即使用这些页面。</li></ul><p>When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list. If a page has been accessed recently, it is reactivated and placed on the end of the active list. In OS X, if an inactive page contains data that has not been written to the backing store recently, its contents must be paged out to disk before it can be placed on the free list. (In iOS, modified but inactive pages must remain in memory and be cleaned up by the application that owns them.) If an inactive page has not been modified and is not permanently resident (wired), it is stolen (any current virtual mappings to it are destroyed) and added to the free list. Once the free list size exceeds the target threshold, the pager rests.<br>当空闲列表中的页面数低于阈值(由物理内存大小决定)时，pager将尝试平衡队列。它通过从非活动列表中提取页面来实现这一点。如果最近访问了某个页面，则重新激活该页面并将其放置在活动列表的末尾。在OS X中，如果一个不活动的页面包含了最近没有写到后台存储的数据，那么在它被放到空闲列表之前，它的内容必须被分页到磁盘上。(在iOS中，修改但不活跃的页面必须保留在内存中，并由拥有它们的应用程序进行清理。) 如果一个不活动的页面没有被修改，并且不是永久驻留(wired)，那么它将被窃取(它的任何当前虚拟映射都将被销毁)并添加到空闲列表中。一旦空闲列表大小超过目标阈值，pager就会停止。</p><p>The kernel moves pages from the active list to the inactive list if they are not accessed; it moves pages from the inactive list to the active list on a soft fault (see Paging In Process). When virtual pages are swapped out, the associated physical pages are placed in the free list. Also, when processes explicitly free memory, the kernel moves the affected pages to the free list.<br>内核将未访问的页面从活动列表移动到非活动列表;通过soft fault将页面从非活动列表移动到活动列表 (请参阅分页In Process)。当虚拟页面交换出去时，相关的物理页面被放在空闲列表中。此外，当进程显式地释放内存时，内核将受影响的页面移动到空闲列表。</p><h2 id="Paging-Out-Process"><a href="#Paging-Out-Process" class="headerlink" title="Paging Out Process"></a>Paging Out Process</h2><p>In OS X, when the number of pages in the free list dips below a computed threshold, the kernel reclaims physical pages for the free list by swapping inactive pages out of memory. To do this, the kernel iterates all resident pages in the active and inactive lists, performing the following steps:</p><ol><li>If a page in the active list is not recently touched, it is moved to the inactive list.</li><li>If a page in the inactive list is not recently touched, the kernel finds the page’s VM object.</li><li>If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object.</li><li>The VM object’s default pager attempts to write the page out to the backing store.</li><li>If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list.</li></ol><p>在OS X中，当空闲列表中的页面数量低于计算的阈值时，内核通过将不活动的页面从内存中交换出来，从而回收空闲列表的物理页面。为此，内核遍历活动和非活动列表中的所有驻留页面，执行以下步骤:</p><ol><li>如果活动列表中的某个页面最近未被触摸，它将被移到非活动列表。</li><li>如果非活动列表中的一个页面最近没有被使用，内核将找到页面的VM对象。</li><li>如果VM对象以前从未被分页，那么内核将调用一个初始化例程，该例程创建并分配一个默认的分页器对象。</li><li>VM对象的默认分页器尝试将页面写到后台存储。</li><li>如果pager成功，内核释放页面占用的物理内存，并将页面从非活动列表移动到空闲列表。</li></ol><h2 id="Paging-In-Process"><a href="#Paging-In-Process" class="headerlink" title="Paging In Process"></a>Paging In Process</h2><p>The final phase of virtual memory management moves pages into physical memory, either from the backing store or from the file containing the page data. A memory access fault initiates the page-in process. A memory access fault occurs when code tries to access data at a virtual address that is not mapped to physical memory. There are two kinds of faults:<br>虚拟内存管理的最后一个阶段是将页面移动到物理内存中，或者从后台存储区，或者从包含页面数据的文件中。内存访问错误启动page-in进程。当代码试图访问没有映射到物理内存的虚拟地址中的数据时，会发生内存访问错误。有两种错误:</p><ol><li>A soft fault occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process.</li><li><p>A hard fault occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault.</p></li><li><p>soft fault：当引用地址的页驻留在物理内存中，但当前没有映射到此进程的地址空间时，就会发生此错误。</p></li><li>hard fault：当引用地址的页面不在物理内存中，而是被交换到后备存储器(或从映射文件中可用)时，就会出现。这就是通常所说的页面错误。</li></ol><p>When any type of fault occurs, the kernel locates the map entry and VM object for the accessed region. The kernel then goes through the VM object’s list of resident pages. If the desired page is in the list of resident pages, the kernel generates a soft fault. If the page is not in the list of resident pages, it generates a hard fault.<br>当发生任何类型的错误时，内核为被访问区域定位映射条目和VM对象。内核然后遍历VM对象的常驻页面列表。如果希望的页面位于驻留页面的列表中，内核会生成一个软错误。如果页面不在常驻页面列表中，则会产生硬错误。</p><p>For soft faults, the kernel maps the physical memory containing the pages to the virtual address space of the process. The kernel then marks the specific page as active. If the fault involved a write operation, the page is also marked as modified so that it will be written to backing store if it needs to be freed later.<br>对于软故障，内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将特定页面标记为活动页面。如果该错误涉及到写操作，那么该页面也会被标记为修改，以便在以后需要释放时写入到后备存储器中。</p><p>For hard faults, the VM object’s pager finds the page in the backing store or from the file on disk, depending on the type of pager. After making the appropriate adjustments to the map information, the pager moves the page into physical memory and places the page on the active list. As with a soft fault, if the fault involved a write operation, the page is marked as modified.<br>对于硬故障，VM对象的寻呼机根据寻呼机的类型在备份存储中或从磁盘上的文件中查找页面。在对映射信息进行适当的调整之后，寻呼机将页面移动到物理内存中，并将页面放在活动列表中。与软错误一样，如果错误涉及写操作，则将页面标记为已修改。</p><h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><p>Mac的内存使用：Wired, Active, Inactive和Free</p><ul><li>Wired(联动): 系统核心占用的，永远不会从系统物【[内存】中去除。</li><li>Active(活跃): 表示这些内存数据正在使用种，或者刚被使用过。</li><li>Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。</li><li>Free(可用空间): 表示这些内存中的数据是无效的，即内存剩余量！</li></ul><p>当Free的【内存】低于某个key值时，这个key值是由你的物理内存大小决定的，系统则会按照以下顺序使用Inactive的资源。</p><ul><li>首先，如果Inactive的数据最近被调用了，系统会把它们的状态改变成Active,并且在原有Active内存逻辑地址的后面；</li><li>其次，如果Inactive的内存数据最近没有被使用过，但是曾经被更改过，而还没有在硬盘的相应虚拟[内存]中做修改，系统会对相应硬盘的虚拟内存做修改，并把这部分物理内存释放为free供程序使用。</li><li>再次，如果inactive[内存]中得数据被在映射到硬盘后再没有被更改过，则直接释放成free。</li><li>最后如果active的内存一段时间没有被使用，会被暂时改变状态为inactive。</li></ul><p>　　所以，如果你的系统里有少量的free memeory和大量的inactive的memeory，说明你的内存是够用的，系统运行在最佳状态，只要需要,系统就会使用它们，不用担心。</p><pre><code>如果系统的free memory和inactive memory都很少，而active memory很多，说明你的[内存]不够了。当然一开机，大部分[内存]都是free,这时系统反而不在最佳状态，因为很多数据都需要从硬盘调用，速度反而慢了。</code></pre><h4 id="Free-memory"><a href="#Free-memory" class="headerlink" title="Free memory"></a>Free memory</h4><p>This is RAM that’s not being used.</p><h4 id="Wired-memory"><a href="#Wired-memory" class="headerlink" title="Wired memory"></a>Wired memory</h4><p>Information in this memory can’t be moved to the hard disk, so it must stay in RAM. The amount of Wired memory depends on the applications you are using.</p><h4 id="Active-memory"><a href="#Active-memory" class="headerlink" title="Active memory"></a>Active memory</h4><p>This information is currently in memory, and has been recently used.</p><h4 id="Inactive-memory"><a href="#Inactive-memory" class="headerlink" title="Inactive memory"></a>Inactive memory</h4><p>This information in memory is not actively being used, but was recently used.</p><p>For example, if you’ve been using Mail and then quit it, the RAM that Mail was using is marked as Inactive memory. This Inactive memory is available for use by another application, just like Free memory.  However, if you open Mail before its Inactive memory is used by a different application, Mail will open quicker because its Inactive memory is converted to Active memory, instead of loading Mail from the slower hard disk.</p><h4 id="Used"><a href="#Used" class="headerlink" title="Used"></a>Used</h4><p>This is the total amount of memory used.</p><h4 id="VM-size"><a href="#VM-size" class="headerlink" title="VM size"></a>VM size</h4><p>This is the total amount of Virtual Memory for all processes on your Mac. </p><h4 id="Page-ins-Page-outs"><a href="#Page-ins-Page-outs" class="headerlink" title="Page ins / Page outs"></a>Page ins / Page outs</h4><p>This refers to the amount of information moved between RAM and the hard disk. This number is a cumulative amount of data that Mac OS X has moved between RAM and disk space.</p><p>Tip: Page outs occur when your Mac has to write information from RAM to the hard drive (because RAM is full).  Adding more RAM may reduce page outs.</p><h4 id="Swap-used"><a href="#Swap-used" class="headerlink" title="Swap used"></a>Swap used</h4><p>This is the amount of information copied to the swap file on your hard drive.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译下&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Memory Usage Performance Guidelines&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存1" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/"/>
    
  </entry>
  
  <entry>
    <title>Mach-o文件结构理解</title>
    <link href="http://yoursite.com/wiki/IOS%20/Mach_O/Mach_O_File_Struct/"/>
    <id>http://yoursite.com/wiki/IOS /Mach_O/Mach_O_File_Struct/</id>
    <published>2018-05-16T04:07:12.000Z</published>
    <updated>2018-06-21T04:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：</p><ol><li>有助于理解崩溃日志解析的原理。理解KSCrash源码；</li><li>有助于理解开源代码fishhook的原理；</li><li>有助于理解腾讯OOMDetector开源库源码；</li><li>好处应该不止这些。</li></ol><a id="more"></a><h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>它的组成结构如下图所示，包括了Header、Load commands、Data（包含Segement的具体数据）。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/mach-o-overall_small.jpg" alt="mach-o 文件结构"></p><p>这张图片说明了几点：</p><ol><li>mach-o由三部分构成，header、Load Commands、Data区域。</li><li>commond指定了各种数据在Data区域的位置。 可以将header比喻为文章的摘要，Load Commands为文章的目录、Data是文章的正文。 目录的特点是可以定位内容在文章的位置。Load Commands其实就是这个作用。</li><li>每个segment下面可以有一个或多个section。 可以理解为一级目录下的子二级目录~~。</li></ol><p>也可以从另外角度认识Mach-O结构，如图所示。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_O_new_overall_small.png" alt="mach-o 内部详细结构"></p><p>这张图表达了更多的细节信息：</p><ol><li>segment 的类型有__TEXT(程序的代码区域，只读) 、__DATA(程序的数据区域，可读写)</li><li>__DATA segment 后面跟随着多个section，包括__nl__symbol_ptr （not layz符号）__la__symbol_ptr</li></ol><p>下面来聊聊Header部分</p><h2 id="mach-header"><a href="#mach-header" class="headerlink" title="mach-header"></a>mach-header</h2><p>mach-header 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mach_header_64</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>magic;<span class="comment">/* mach magic number identifier */</span></span><br><span class="line"><span class="keyword">cpu_type_t</span>cputype;<span class="comment">/* cpu specifier */</span></span><br><span class="line"><span class="keyword">cpu_subtype_t</span>cpusubtype;<span class="comment">/* machine specifier */</span></span><br><span class="line"><span class="keyword">uint32_t</span>filetype;<span class="comment">/* type of file */</span></span><br><span class="line"><span class="keyword">uint32_t</span>ncmds;<span class="comment">/* number of load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>sizeofcmds;<span class="comment">/* the size of all the load commands */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>magic：魔数，用于快速确认该文件的种类（用于64位还是32位）。可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_MAGIC_64 0xfeedfacf <span class="comment">/* the 64-bit mach magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CIGAM_64 0xcffaedfe <span class="comment">/* NXSwapInt(MH_MAGIC_64) */</span></span></span><br></pre></td></tr></table></figure><ul><li>cputype：CPU类型，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_I386CPU_TYPE_X86  <span class="comment">/* compatibility */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>CPU_TYPE_X86_64(CPU_TYPE_X86 | CPU_ARCH_ABI64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM((cpu_type_t) 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_TYPE_ARM64          (CPU_TYPE_ARM | CPU_ARCH_ABI64)</span></span><br></pre></td></tr></table></figure><ul><li>cpusubtype：对应的具体类型，比如arm64、armv7，可取值（部分）如下：</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define CPU_SUBTYPE_X86_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_X86_64_ALL((<span class="name">cpu_subtype_t</span>)<span class="number">3</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7((<span class="name">cpu_subtype_t</span>) <span class="number">9</span>)</span><br><span class="line">#define CPU_SUBTYPE_ARM_V7S((<span class="name">cpu_subtype_t</span>) <span class="number">11</span>) /* Swift */</span><br></pre></td></tr></table></figure><ul><li>filetype：文件类型，比如可执行文件、库文件、Dsym文件，例如：MH_EXECUTE值是2，代表可执行文件，可取值如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * Constants <span class="keyword">for</span> the filetype field of the mach_header</span><br><span class="line"> */</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_OBJECT   0x1     <span class="comment">/* relocatable object file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_EXECUTE  0x2     <span class="comment">/* demand paged executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_FVMLIB   0x3     <span class="comment">/* fixed VM shared library file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CORE     0x4     <span class="comment">/* core file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PRELOAD  0x5     <span class="comment">/* preloaded executable file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB    0x6     <span class="comment">/* dynamically bound shared library */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLINKER 0x7     <span class="comment">/* dynamic link editor */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BUNDLE   0x8     <span class="comment">/* dynamically bound bundle file */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLIB_STUB   0x9     <span class="comment">/* shared library stub for static */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DSYM     0xa     <span class="comment">/* companion file with only debug */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_KEXT_BUNDLE  0xb     <span class="comment">/* x86_64 kexts */</span></span></span><br></pre></td></tr></table></figure><ul><li>ncmds ：加载命令条数</li><li>sizeofcmds：所有加载命令的大小</li><li>reserved：保留字段</li><li>flags：标志位，可取值（部分）如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_DYLDLINK0x4<span class="comment">/* the object file is input for the</span></span></span><br><span class="line"><span class="meta"><span class="comment">   dynamic linker and can't be staticly</span></span></span><br><span class="line"><span class="meta"><span class="comment">   link edited again */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_PREBOUND0x10<span class="comment">/* the file has its dynamic undefined</span></span></span><br><span class="line"><span class="meta"><span class="comment">   references prebound. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_SPLIT_SEGS0x20<span class="comment">/* the file has its read-only and</span></span></span><br><span class="line"><span class="meta"><span class="comment">   read-write segments split */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_TWOLEVEL0x80<span class="comment">/* the image is using two-level name</span></span></span><br><span class="line"><span class="meta"><span class="comment">   space bindings */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_NOMULTIDEFS0x200<span class="comment">/* this umbrella guarantees no multiple</span></span></span><br><span class="line"><span class="meta"><span class="comment">   defintions of symbols in its</span></span></span><br><span class="line"><span class="meta"><span class="comment">   sub-images so the two-level namespace</span></span></span><br><span class="line"><span class="meta"><span class="comment">   hints can always be used. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_CANONICAL    0x4000<span class="comment">/* the binary has been canonicalized</span></span></span><br><span class="line"><span class="meta"><span class="comment">   via the unprebind operation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_WEAK_DEFINES0x8000<span class="comment">/* the final linked image contains</span></span></span><br><span class="line"><span class="meta"><span class="comment">   external weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MH_BINDS_TO_WEAK 0x10000<span class="comment">/* the final linked image uses</span></span></span><br><span class="line"><span class="meta"><span class="comment">   weak symbols */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>MH_PIE 0x200000<span class="comment">/* When this bit is set, the OS will</span></span></span><br><span class="line"><span class="meta"><span class="comment">   load the main executable at a</span></span></span><br><span class="line"><span class="meta"><span class="comment">   random address.  Only used in</span></span></span><br><span class="line"><span class="meta"><span class="comment">   MH_EXECUTE filetypes. */</span></span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>下图是借用machoview查看header的结构：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/machview-header.png" alt="header 结构"></p><p>可以看出：</p><ol><li>该文件是可执行文件</li><li>文件的构架是x86_64</li><li>number of Load commands表示有74个load commond</li><li>MH_TWOLEVEL二级名字空间</li><li>MH_PIE 随机地址空间</li></ol><p>接下来介绍head后的load command部分。</p><h2 id="load-command"><a href="#load-command" class="headerlink" title="load command"></a>load command</h2><p>Load commands紧跟在头部之后，这些加载指令清晰地告诉加载器如何处理二进制数据，有些命令是由内核处理的，有些是由动态链接器处理的。在源码中有明显的注释来说明这些是动态连接器处理的。</p><p>这里列举几个看上去比较熟悉的….</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;mach-o/loader.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT0x1<span class="comment">/* segment of this file to be mapped  被映射到内存的段*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SYMTAB0x2<span class="comment">/* link-edit stab symbol table info  符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_DYSYMTAB0xb<span class="comment">/* dynamic link-edit symbol table info 动态符号表*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_DYLIB0xc<span class="comment">/* load a dynamically linked shared library 动态链接库*/</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * load a dynamically linked shared library that is allowed to be missing</span></span><br><span class="line"><span class="comment"> * (all symbols are weak imported).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>LC_SEGMENT_640x19<span class="comment">/* 64-bit segment of this file to be</span></span></span><br><span class="line"><span class="meta"><span class="comment">   mapped */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_UUID0x1b<span class="comment">/* the uuid */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_RPATH       (0x1c | LC_REQ_DYLD)    <span class="comment">/* runpath additions */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_CODE_SIGNATURE 0x1d<span class="comment">/* local of code signature */</span></span></span><br></pre></td></tr></table></figure><p>load command的基本定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">load_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;       <span class="comment">/* type of load command */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> cmdsize;   <span class="comment">/* total size of command in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体只表示了所有的command都需要包含的属性—-命令类型和命令的大小。具体对于不同的命令都会有不同的定义。但是必须包含上面两个字段。</p><p>下面就来看具体的命令—LC_SEGMENT_64类型命令的定义。</p><h3 id="LC-SEGMENT"><a href="#LC-SEGMENT" class="headerlink" title="LC_SEGMENT"></a>LC_SEGMENT</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * The segment load command indicates <span class="keyword">that</span> a part <span class="keyword">of</span> this <span class="built_in">file</span> <span class="keyword">is</span> <span class="keyword">to</span> be</span><br><span class="line"> * mapped <span class="keyword">into</span> <span class="keyword">the</span> task's address <span class="literal">space</span>.  The size <span class="keyword">of</span> this segment <span class="keyword">in</span> memory,</span><br><span class="line"> * vmsize, maybe <span class="keyword">equal</span> <span class="keyword">to</span> <span class="keyword">or</span> larger than <span class="keyword">the</span> amount <span class="keyword">to</span> map <span class="keyword">from</span> this <span class="built_in">file</span>,</span><br><span class="line"> * filesize.  The <span class="built_in">file</span> <span class="keyword">is</span> mapped starting <span class="keyword">at</span> fileoff <span class="keyword">to</span> <span class="keyword">the</span> <span class="keyword">beginning</span> <span class="keyword">of</span></span><br><span class="line"> * <span class="keyword">the</span> segment <span class="keyword">in</span> memory, vmaddr.  The <span class="built_in">rest</span> <span class="keyword">of</span> <span class="keyword">the</span> memory <span class="keyword">of</span> <span class="keyword">the</span> segment,</span><br><span class="line"> * <span class="keyword">if</span> any, <span class="keyword">is</span> allocated zero fill <span class="keyword">on</span> demand.  The segment's maximum virtual</span><br><span class="line"> * memory protection <span class="keyword">and</span> initial virtual memory protection are specified</span><br><span class="line"> * <span class="keyword">by</span> <span class="keyword">the</span> maxprot <span class="keyword">and</span> initprot fields.  If <span class="keyword">the</span> segment has sections <span class="keyword">then</span> <span class="keyword">the</span></span><br><span class="line"> * section structures directly follow <span class="keyword">the</span> segment command <span class="keyword">and</span> their size <span class="keyword">is</span></span><br><span class="line"> * reflected <span class="keyword">in</span> cmdsize.</span><br><span class="line">段加载命令指定了：文件需要映射到程序地址空间的某个部分。 </span><br><span class="line">段在内存中的大小用vmsize指定。内存中段的大小可能等于或大于文件大小（filesize），文件大小使用filesize指定。</span><br><span class="line">映射的源起始文件地址是fileoff，目的起始地址是vmaddr。内存中剩余的段内存用<span class="number">0</span>填充。</span><br><span class="line">段的最大内存权限和初始内存权限用maxprot、initprot字段指定。</span><br><span class="line">如果段有section，那么section的结构紧跟着段。section的大小包括在cmdsize字段中。</span><br><span class="line"> */</span><br><span class="line">struct segment_command &#123; /* <span class="keyword">for</span> <span class="number">32</span>-bit architectures */</span><br><span class="line">uint32_tcmd;/* LC_SEGMENT */</span><br><span class="line">uint32_tcmdsize;/* includes sizeof section structs */</span><br><span class="line">charsegname[<span class="number">16</span>];/* segment <span class="built_in">name</span> */</span><br><span class="line">uint32_tvmaddr;/* memory address <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tvmsize;/* memory size <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfileoff;/* <span class="built_in">file</span> <span class="built_in">offset</span> <span class="keyword">of</span> this segment */</span><br><span class="line">uint32_tfilesize;/* amount <span class="keyword">to</span> map <span class="keyword">from</span> <span class="keyword">the</span> <span class="built_in">file</span> */</span><br><span class="line">vm_prot_tmaxprot;/* maximum VM protection */</span><br><span class="line">vm_prot_tinitprot;/* initial VM protection */</span><br><span class="line">uint32_tnsects;/* <span class="built_in">number</span> <span class="keyword">of</span> sections <span class="keyword">in</span> segment */</span><br><span class="line">uint32_tflags;/* flags */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出segment_command包含了命令必须的属性cmd、cmdsize。剩下的属性是segment_command特有的属性。</p><p>下面是名称为_DATA的segment commond的截图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/DATA_Segment.png" alt="segement"></p><p>可以看出：</p><ol><li>命令类型是LC_SEGMENT_64</li><li>命令的大小1832</li><li>segment 命令的名称是__DATA</li><li>映射的内存地址是4360744960（十进制）</li><li>内存的大小12488704</li><li>文件的偏移量是65777664</li><li>需要映射的文件的大小10424320</li><li>最大内存保护权限：读写执行</li><li>初始内存权限：读写</li><li>这个端附属了22个 section，也就是说1832大小的segment_command包括了22个section命令的大小。</li><li>看的方法：offset代表文件的便宜量、Data表示内存地址中存储的值、description表示这段内存地址的名称的描述、value表示存储的值的可视描述。</li></ol><p>下面看看22个section的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/sections.png" alt="22sections"></p><p>下面讲解section的结构,section 的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">section_64</span> &#123;</span> <span class="comment">/* for 64-bit architectures */</span></span><br><span class="line"><span class="keyword">char</span>sectname[<span class="number">16</span>];<span class="comment">/* name of this section */</span></span><br><span class="line"><span class="keyword">char</span>segname[<span class="number">16</span>];<span class="comment">/* segment this section goes in */</span></span><br><span class="line"><span class="keyword">uint64_t</span>addr;<span class="comment">/* memory address of this section */</span></span><br><span class="line"><span class="keyword">uint64_t</span>size;<span class="comment">/* size in bytes of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>offset;<span class="comment">/* file offset of this section */</span></span><br><span class="line"><span class="keyword">uint32_t</span>align;<span class="comment">/* section alignment (power of 2) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reloff;<span class="comment">/* file offset of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nreloc;<span class="comment">/* number of relocation entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>flags;<span class="comment">/* flags (section type and attributes)*/</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved1;<span class="comment">/* reserved (for offset or index) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved2;<span class="comment">/* reserved (for count or sizeof) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>reserved3;<span class="comment">/* reserved */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下图是__nl_symbol_ptr section 的示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/nl_symbol_ptr_section.png" alt="nl_symbol_ptr_section"></p><p>可以看出：</p><ol><li>section的名称是__nl_symbol_ptr</li><li>该section所属的端的名称 _DATA 。段名称大写，section名称小写</li><li>内存地址4360744960</li><li>该section在内存中的大小是16</li><li>该section在物理文件的偏移量</li><li>内存对齐大小 8</li><li>间接符号索引是1198 （这里不太懂什么意思）</li></ol><p>segment 有四种，如图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/segment_types.png" alt="segment_types"></p><p>可以看出有<strong>PAGEZERO、</strong>TEXT、<strong>DATA、</strong>LINKEDIT。</p><h3 id="LC-SYMTAB"><a href="#LC-SYMTAB" class="headerlink" title="LC_SYMTAB"></a>LC_SYMTAB</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD</span></span><br><span class="line"><span class="comment"> * "stab" style symbol table information as described in the header files</span></span><br><span class="line"><span class="comment"> * &lt;nlist.h&gt; and &lt;stab.h&gt;.</span></span><br><span class="line"><span class="comment"> * symtab_command 包含了符号表、字符串索引表 的偏移量和大小 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span> &#123;</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_SYMTAB */</span></span><br><span class="line"><span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct symtab_command) */</span></span><br><span class="line"><span class="keyword">uint32_t</span>symoff;<span class="comment">/* symbol table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>nsyms;<span class="comment">/* number of symbol table entries */</span></span><br><span class="line"><span class="keyword">uint32_t</span>stroff;<span class="comment">/* string table offset */</span></span><br><span class="line"><span class="keyword">uint32_t</span>strsize;<span class="comment">/* string table size in bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是LC_SYMTAB command示意图：</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/systab.png" alt="symbol table"></p><p>由表中可以看出</p><ol><li>命令的大小是24 （十进制）</li><li>符号表在物理文件的偏移量是 77360448</li><li>符号表的大小 1069179</li><li>String表的物理文件偏移量是94479244</li><li>string表的大小是22093264</li></ol><p>这个commond同时指定了两个表的位置信息。</p><h3 id="LC-UUID"><a href="#LC-UUID" class="headerlink" title="LC_UUID"></a>LC_UUID</h3><p>LC_UUID 用来标识唯一APP，命令的定义如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">uuid_command</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmd;<span class="comment">/* LC_UUID */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>cmdsize;<span class="comment">/* sizeof(struct uuid_command) */</span></span><br><span class="line">    <span class="keyword">uint8_t</span>uuid[<span class="number">16</span>];<span class="comment">/* the 128-bit uuid */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/uuid.png" alt="uuid"></p><p>每个可执行程序都有一个uuid，这样根据不同的uuid能确定包。比如崩溃日志中就会包含uuid字段。表示是哪个包崩溃了。</p><h3 id="LC-DYSYMTAB（动态符号表）"><a href="#LC-DYSYMTAB（动态符号表）" class="headerlink" title="LC_DYSYMTAB（动态符号表）"></a>LC_DYSYMTAB（动态符号表）</h3><p>下面的描述摘至<mach-o loader.h="">。<br>This is the second set of the symbolic information which is used to support  the data structures for the dynamically link editor.</mach-o></p><p>LC_DYSYMTAB 是第二种符号信集，这个符号集被动态连接器的数据结构使用。</p><ul><li>The original set of symbolic information in the symtab_command which contains</li><li>the symbol and string tables must also be present when this load command is</li><li><p>present.<br>当这个command（动态符号command）出现的时候，symtab_command必须出现，symtab_command包含符号表和String表。</p><p>When this load command is present the symbol table is organized into three groups of symbols:</p></li></ul><p>当这个加载命令出现的时候，符号表被组织为三部分：</p><ol><li>local symbols (static and debugging symbols) - grouped by module</li><li>defined external symbols - grouped by module (sorted by name if not lib)</li><li>undefined external symbols (sorted by name if MH_BINDATLOAD is not set, and in order the were seen by the static linker if MH_BINDATLOAD is set)</li></ol><p>In this load command there are offsets and counts to each of the three groups of symbols.</p><p>这个命令指定了每个部分的偏移量和符号个数：</p><p>This load command contains a the offsets and sizes of the following new symbolic information tables:</p><p>这个命令包含下面新的符号：</p><ol><li>table of contents</li><li>module table</li><li>reference symbol table</li><li>indirect symbol table</li></ol><p>The first three tables above (the table of contents, module table and reference symbol table) are only present if the file is a dynamically linked shared library. </p><p>前三个只有文件是动态库的时候才出现。 </p><p>For executable and object modules, which are files containing only one module, the information that would be in these three tables is determined as follows:</p><ol><li>table of contents - the defined external symbols are sorted by name</li><li>module table - the file contains only one module so everything in the file is part of the module.</li><li>reference symbol table - is the defined and undefined external symbols</li></ol><p>For dynamically linked shared library files this load command also contains offsets and sizes to the pool of relocation entries for all sections separated into two groups:</p><ol><li>external relocation entries</li><li>local relocation entries</li></ol><p>For executable and object modules the relocation entries continue to hang off the section structures.</p><table><thead><tr><th>名称</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>cmd</td><td>uint32_t</td><td>LC_DYSYMTAB</td></tr><tr><td>cmdsize</td><td>uint32_t</td><td>sizeof(struct dysymtab_command)</td></tr><tr><td></td><td></td><td></td></tr><tr><td>ilocalsym</td><td>uint32_t</td><td>index to local symbols</td></tr><tr><td>nlocalsym</td><td>uint32_t</td><td>number of local symbols</td></tr><tr><td>iextdefsym</td><td>uint32_t</td><td>index to externally defined symbols</td></tr><tr><td>nextdefsym</td><td>uint32_t</td><td>number of externally defined symbols</td></tr><tr><td>iundefsym</td><td>uint32_t</td><td>index to undefined symbols</td></tr><tr><td>nundefsym</td><td>uint32_t</td><td>number of undefined symbols</td></tr><tr><td></td><td></td><td></td></tr><tr><td>tocoff</td><td>uint32_t</td><td>file offset to table of contents</td></tr><tr><td>ntoc</td><td>uint32_t</td><td>number of entries in table of contents</td></tr><tr><td>modtaboff</td><td>uint32_t</td><td>file offset to module table</td></tr><tr><td>nmodtab</td><td>uint32_t</td><td>number of module table entries</td></tr><tr><td>extrefsymoff</td><td>uint32_t</td><td>offset to referenced symbol table</td></tr><tr><td>nextrefsyms</td><td>uint32_t</td><td>number of referenced symbol table entries</td></tr><tr><td>indirectsymoff</td><td>uint32_t</td><td>file offset to the indirect symbol table</td></tr><tr><td>nindirectsyms</td><td>uint32_t</td><td>number of indirect symbol table entries</td></tr><tr><td>–</td><td>–</td><td>–</td></tr><tr><td>extreloff</td><td>uint32_t</td><td>offset to external relocation entries</td></tr><tr><td>nextrel</td><td>uint32_t</td><td>number of external relocation entries</td></tr><tr><td>locreloff</td><td>uint32_t</td><td>offset to local relocation entries</td></tr><tr><td>nlocrel</td><td>uint32_t</td><td>number of local relocation entries</td></tr></tbody></table><p>总结就是定义了各种符号的偏移量和各种符号的个数</p><h2 id="DATA部分"><a href="#DATA部分" class="headerlink" title="DATA部分"></a>DATA部分</h2><p>DATA部分是Mach-O文件的主体，存储着各种类型的实际数据，例如LC_SEGMENT（<strong>TEXT）指定的代码段, LC_SEGMENT（</strong>DATA）指定的数据段。 LC_SYMTAB（__LINKEDIT）段指定的符号表和String表、以及动态符号表，等等。<br>这里只介绍符号表、String表、动态符号表三种结构</p><h3 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h3><p>符号表的数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nlist_64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span>  n_strx; <span class="comment">/* index into the string table */</span></span><br><span class="line">    &#125; n_un;</span><br><span class="line">    <span class="keyword">uint8_t</span> n_type;        <span class="comment">/* type flag, see below */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> n_sect;        <span class="comment">/* section number or NO_SECT */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> n_desc;       <span class="comment">/* see &lt;mach-o/stab.h&gt; */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> n_value;      <span class="comment">/* value of this symbol (or stab offset) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Symbols with a index into the string table of zero (n_un.n_strx == 0) are</span></span><br><span class="line"><span class="comment"> * defined to have a null, "", name.  Therefore all string indexes to non null</span></span><br><span class="line"><span class="comment"> * names must not have a zero string index.  This is bit historical information</span></span><br><span class="line"><span class="comment"> * that has never been well documented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The n_type field really contains four fields:</span></span><br><span class="line"><span class="comment"> *unsigned char N_STAB:3,</span></span><br><span class="line"><span class="comment"> *      N_PEXT:1,</span></span><br><span class="line"><span class="comment"> *      N_TYPE:3,</span></span><br><span class="line"><span class="comment"> *      N_EXT:1;</span></span><br><span class="line"><span class="comment"> * which are used via the following masks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_STAB0xe0  <span class="comment">/* if any of these bits set, a symbolic debugging entry */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_PEXT0x10  <span class="comment">/* private external symbol bit */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_TYPE0x0e  <span class="comment">/* mask for the type bits */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>N_EXT0x01  <span class="comment">/* external symbol bit, set for external symbols */</span></span></span><br></pre></td></tr></table></figure><p>示意图如下：<br><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/system_detail.png" alt="symbol"></p><p>可以看出：</p><ol><li>String表的偏移量是0xbbff8, 翻译后是[GMRYouHaoHuoReq getRequestURL]</li><li>地址是0x100003300，</li></ol><h3 id="string表"><a href="#string表" class="headerlink" title="string表"></a>string表</h3><p>String表顺序列出了二进制mach-O文件的中的所有可见字符串。串之间通过0x00分隔。可以通过相对String表起始位置的偏移量随机访问String表中的字符串。符号表结构中的n_strx指定的就是String表中的偏移量。通过这个偏移量可以访问到符号对应的具体字符串。</p><p>例如： String表的0xbbf8处是不是[GMRYouHaoHuoReq getRequestURL]，string表的地址是0x049C6D40 加上偏移量0x000BBFB1 ，等于0x54d633d。</p><p><img src="http://of685p9vy.bkt.clouddn.com/mach_o/1/stringtable.png" alt="string table"></p><p>可以看出string表的0x54d633d地址出就是：[GMRYouHaoHuoReq getRequestURL]。  </p><h3 id="动态符号表。"><a href="#动态符号表。" class="headerlink" title="动态符号表。"></a>动态符号表。</h3><p>动态符号表中存储着动态连接器使用的相关符号。 每个符号一般占用32bit的存储空间。存储的内容是符号表中的索引。</p><h2 id="注意啦"><a href="#注意啦" class="headerlink" title="注意啦"></a>注意啦</h2><p>网上直接下载的MachOView经常崩溃，是由于有段代码没有做非空判断，所以为了有效使用MachOView，请从<a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">官网</a>下载代码，然后在崩溃的地方添加非空判断。就OK拉。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://opensource.apple.com/source/xnu/xnu-1456.1.26/EXTERNAL_HEADERS/mach-o/loader.h" rel="external nofollow noopener noreferrer" target="_blank">mach-o/loader.h</a></li><li><a href="https://www.jianshu.com/p/54d842db3f69" rel="external nofollow noopener noreferrer" target="_blank">趣探 Mach-O：文件格式分析</a></li><li><a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">MachOView 源码地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有助于理解崩溃日志解析的原理。理解KSCrash源码；&lt;/li&gt;
&lt;li&gt;有助于理解开源代码fishhook的原理；&lt;/li&gt;
&lt;li&gt;有助于理解腾讯OOMDetector开源库源码；&lt;/li&gt;
&lt;li&gt;好处应该不止这些。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="Mach-O" scheme="http://yoursite.com/tags/Mach-O/"/>
    
  </entry>
  
  <entry>
    <title>iOS事件处理看我就够了(转载)</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/iOS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/wiki/IOS /事件处理/iOS事件处理/</id>
    <published>2018-04-27T04:07:12.000Z</published>
    <updated>2018-04-28T07:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自<a href="https://www.jianshu.com/p/b0884faae603" rel="external nofollow noopener noreferrer" target="_blank">iOS事件处理，看我就够了~</a></p><a id="more"></a><h2 id="UIResponder"><a href="#UIResponder" class="headerlink" title="UIResponder"></a>UIResponder</h2><p>UIResponder是iOS中用于处理用户事件的API，可以处理触摸事件、按压事件(3D touch)、远程控制事件、硬件运动事件。可以通过touchesBegan、pressesBegan、motionBegan、remoteControlReceivedWithEvent等方法，获取到对应的回调消息。UIResponder不只用来接收事件，还可以处理和传递对应的事件，如果当前响应者不能处理，则转发给其他合适的响应者处理。</p><p>应用程序通过响应者来接收和处理事件，响应者可以是继承自UIResponder的任何子类，例如UIView、UIViewController、UIApplication等。<font color="red">当事件来到时，系统会将事件传递给合适的响应者，并且将其成为第一响应者</font>。</p><p>第一响应者未处理的事件，将会在响应者链中进行传递，传递规则由UIResponder的nextResponder决定，可以通过重写该属性来决定传递规则。当一个事件到来时，第一响应者没有接收消息，则顺着响应者链向后传递。</p><h2 id="查找第一响应者"><a href="#查找第一响应者" class="headerlink" title="查找第一响应者"></a>查找第一响应者</h2><h4 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h4><p>查找第一响应者时，有两个非常关键的API，查找第一响应者就是通过不断调用子视图的这两个API完成的。</p><p>调用下面方法，获取到被点击的视图，也就是第一响应者。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(UIView *)</span>hitTest:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p>查找点击的视图。 内部会调用pointInside:withEvent方法。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(BOOL)</span>pointInside:<span class="params">(CGPoint)</span>point withEvent:<span class="params">(UIEvent *)</span>event;</span><br></pre></td></tr></table></figure><p>来判断点击区域是否在视图上，是则返回YES，不是则返回NO。</p><h4 id="查找第一响应者-1"><a href="#查找第一响应者-1" class="headerlink" title="查找第一响应者"></a>查找第一响应者</h4><p>应用程序接收到事件后，将事件交给keyWindow并转发给根视图，根视图按照视图层级逐级遍历子视图，并且遍历的过程中不断判断视图范围，并最终找到第一响应者。</p><p>从keyWindow开始，向前逐级遍历子视图，不断调用UIView的hitTest:withEvent:方法，通过该方法查找在点击区域中的视图后，并继续调用返回视图的子视图的hitTest:withEvent:方法，以此类推。如果子视图不在点击区域或没有子视图，则当前视图就是第一响应者。</p><p>在hitTest:withEvent:方法中，会从上到下遍历子视图，并调用subViews的pointInside:withEvent:方法，来找到点击区域内且最上面的子视图。如果找到子视图则调用其hitTest:withEvent:方法，并继续执行这个流程，以此类推。如果子视图不在点击区域内，则忽略这个视图及其子视图，继续遍历其他视图。</p><font color="blue">可以通过重写对应的方法，控制这个遍历过程。通过重写pointInside:withEvent:方法，来做自己的判断并返回YES或NO，返回点击区域是否在视图上。通过重写hitTest:withEvent:方法，返回被点击的视图</font>。<br><br>此方法在遍历视图时，忽略以下三种情况的视图，如果视图具有以下特征则忽略。但是视图的背景颜色是clearColor，并不在忽略范围内。<br><font color="red"><br><br>1.  视图的hidden等于YES。<br><br>2.  视图的alpha小于等于0.01。<br><br>3.  视图的userInteractionEnabled为NO。<br><br></font><br>如果点击事件是发生在视图外，但在其子视图内部，子视图也不能接收事件并成为第一响应者。这是因为在其父视图进行hitTest:withEvent:的过程中，就会将其忽略掉。<br><br>## 事件传递<br><br>#### 传递过程<br><br><u><br>1.  UIApplication接收到事件，将事件传递给keyWindow。<br><br>2.  keyWindow遍历subViews的hitTest:withEvent:方法，找到点击区域内合适的视图来处理事件。<br><br>3.  UIView的子视图也会遍历其subViews的hitTest:withEvent:方法，以此类推。<br><br>4.  直到找到点击区域内，且处于最上方的视图，将视图逐步返回给UIApplication。<br><br>5.  在查找第一响应者的过程中，已经形成了一个响应者链。<br><br>6.  应用程序会先调用第一响应者处理事件。<br><br>7.  如果第一响应者不能处理事件，则调用其nextResponder方法，一直找响应者链中能处理该事件的对象。<br><br>8.  最后到UIApplication后仍然没有能处理该事件的对象，则该事件被废弃。<br></u><br><br>模拟代码<br><br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span> || <span class="keyword">self</span>.userInteractionEnabled == <span class="literal">NO</span> || <span class="keyword">self</span>.hidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> inside = [<span class="keyword">self</span> pointInside:point withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (inside) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *subViews = <span class="keyword">self</span>.subviews;</span><br><span class="line">        <span class="comment">// 对子视图从上向下找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = subViews.count - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">UIView</span> *subView = subViews[i];</span><br><span class="line">            <span class="built_in">CGPoint</span> insidePoint = [<span class="keyword">self</span> convertPoint:point toView:subView];</span><br><span class="line">            <span class="built_in">UIView</span> *hitView = [subView hitTest:insidePoint withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitView) &#123;</span><br><span class="line">                <span class="keyword">return</span> hitView;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 示例<br><br><img src="http://of685p9vy.bkt.clouddn.com/enentChain/eventChain.png" alt="事件传递"><br><br>事件传递示例<br><br>如上图所示，响应者链如下：<br><br>1.  如果点击UITextField后其会成为第一响应者。<br><br>2.  如果textField未处理事件，则会将事件传递给下一级响应者链，也就是其父视图。<br><br>3.  父视图未处理事件则继续向下传递，也就是UIViewController的View。<br><br>4.  如果控制器的View未处理事件，则会交给控制器处理。<br><br>5.  控制器未处理则会交给UIWindow。<br><br>6.  然后会交给UIApplication。<br><br>7.  最后交给UIApplicationDelegate，如果其未处理则丢弃事件。<br><br><u>事件通过UITouch进行传递，在事件到来时，第一响应者会分配对应的UITouch，UITouch会一直跟随着第一响应者，并且根据当前事件的变化UITouch也会变化，当事件结束后则UITouch被释放。</u><br><br><font color="red">UIViewController没有hitTest:withEvent:方法，所以控制器不参与查找响应视图的过程。但是控制器在响应者链中，如果控制器的View不处理事件，会交给控制器来处理。控制器不处理的话，再交给View的下一级响应者处理。</font><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li><p>在执行hitTest:withEvent:方法时，如果该视图是hidden等于NO的那三种被忽略的情况，则改视图返回nil。</p></li><li><p>如果当前视图在响应者链中，但其没有处理事件，则不考虑其兄弟视图，即使其兄弟视图和其都在点击范围内。</p></li><li><p>UIImageView的userInteractionEnabled默认为NO，如果想要UIImageView响应交互事件，将属性设置为YES即可响应事件。</p></li></ol><h2 id="事件控制"><a href="#事件控制" class="headerlink" title="事件控制"></a>事件控制</h2><h4 id="事件拦截"><a href="#事件拦截" class="headerlink" title="事件拦截"></a>事件拦截</h4><p>有时候想让指定视图来响应事件，不再向其子视图继续传递事件，可以通过重写hitTest:withEvent:方法。在执行到方法后，直接将该视图返回，而不再继续遍历子视图，这样响应者链的终端就是当前视图。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件转发"><a href="#事件转发" class="headerlink" title="事件转发"></a>事件转发</h4><p>在开发过程中，经常会遇到子视图显示范围超出父视图的情况，这时候可以重写该视图的pointInside:withEvent:方法，将点击区域扩大到能够覆盖所有子视图。</p><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/expend.png" alt="扩大响应区域"></p><p>扩大响应区域</p><p>假设有上面的视图结构，SuperView的Subview超出了其视图范围，如果点击Subview在父视图外面的部分，则不能响应事件。所以通过重写pointInside:withEvent:方法，将响应区域扩大为虚线区域，包含SuperView的所有子视图，即可让子视图响应事件。</p><h4 id="事件逐级传递"><a href="#事件逐级传递" class="headerlink" title="事件逐级传递"></a>事件逐级传递</h4><p>如果想让响应者链中，每一级UIResponder都可以响应事件，可以在每级UIResponder中都实现touches并调用super方法，即可实现响应者链事件逐级传递。</p><p><font color="red">只不过这并不包含UIControl子类以及UIGestureRecognizer的子类，这两类会直接打断响应者链</font>。</p><h2 id="Gesture-Recognizer"><a href="#Gesture-Recognizer" class="headerlink" title="Gesture Recognizer"></a>Gesture Recognizer</h2><p><strong>如果有事件到来时，视图有附加的手势识别器，则手势识别器优先处理事件。如果手势识别器没有处理事件，则将事件交给视图处理，视图如果未处理则顺着响应者链继续向后传递。</strong></p><p><img src="http://of685p9vy.bkt.clouddn.com/gesture.png" alt="手势识别"></p><p>手势识别</p><p>当响应者链和手势同时出现时，也就是既实现了touches方法又添加了手势，会发现touches方法有时会失效，这是因为手势的执行优先级是高于响应者链的。</p><p>事件到来后先会执行hitTest和pointInside操作，通过这两个方法找到第一响应者，这个在上面已经详细讲过了。当找到第一响应者并将其返回给UIApplication后，UIApplication会向第一响应者派发事件，并且遍历整个响应者链。如果响应者链中能够处理当前事件的手势，则将事件交给手势处理，并调用touches的cancelled方法将响应者链取消。</p><p><font color="red">在UIApplication向第一响应者派发事件，并且遍历响应者链查找手势时，会开始执行响应者链中的touches系列方法。</font>会先执行touchesBegan和touchesMoved方法，如果响应者链能够继续响应事件，则执行touchesEnded方法表示事件完成，如果将事件交给手势处理则调用touchesCancelled方法将响应者链打断。</p><p>根据苹果的官方文档，<u>手势不参与响应者链传递事件，但是也通过hitTest的方式查找响应的视图，手势和响应者链一样都需要通过hitTest方法来确定响应者链的。在UIApplication向响应者链派发消息时，只要响应者链中存在能够处理事件的手势，则手势响应事件，如果手势不在响应者链中则不能处理事件。</u></p><p><a href="https://developer.apple.com/documentation/uikit/uigesturerecognizer" rel="external nofollow noopener noreferrer" target="_blank">Apple UIGestureRecognizer Documentation</a></p><h2 id="UIControl"><a href="#UIControl" class="headerlink" title="UIControl"></a>UIControl</h2><p>根据上面的手势和响应者链的处理规则，我们会发现UIButton或者UISlider等控件，并不符合这个处理规则。UIButton可以在其父视图已经添加tapGestureRecognizer的情况下，依然正常响应事件，并且tap手势不响应。</p><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/btnStack.jpg" alt=""></p><p>UIControl</p><p>以UIButton为例，UIButton也是通过hitTest的方式查找第一响应者的。区别在于，<font color="red">如果UIButton是第一响应者，则直接由UIApplication派发事件，不通过Responder Chain派发。</font>如果其不能处理事件，则交给手势处理或响应者链传递。</p><p>不只UIButton是直接由UIApplication派发事件的，所有继承自UIControl的类，都是由UIApplication直接派发事件的。</p><p>[Apple UIControl Documentation][2]</p><h2 id="事件传递优先级"><a href="#事件传递优先级" class="headerlink" title="事件传递优先级"></a>事件传递优先级</h2><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>为了有依据的推断响应事件的实现和传递机制，我们做以下测试。</p><h6 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h6><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/example1.png" alt=""></p><p>示例1</p><p>假设RootView、SuperView、Button都实现touches方法，并且Button添加buttonAction:的action，点击button后的调用如下。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line"></span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> touchesBegan:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> touchesEnded:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> buttonAction:</span><br></pre></td></tr></table></figure><h6 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h6><p>还是上面的视图结构，我们给RootView加上UITapGestureRecognizer手势，并且通过tapAction:方法接收回调，点击上面的SuperView后，方法调用如下。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">B<span class="function"><span class="title">utton</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> hitTest:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> pointInside:withEvent:</span><br><span class="line"></span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizer:shouldReceivePress:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> touchesBegan:withEvent:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> gestureRecognizerShouldBegin:</span><br><span class="line">R<span class="function"><span class="title">ootView</span> -&gt;</span> tapAction:</span><br><span class="line">S<span class="function"><span class="title">uperView</span> -&gt;</span> touchesCancelled:</span><br></pre></td></tr></table></figure><h6 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h6><p><img src="http://of685p9vy.bkt.clouddn.com/enentChain/example2.png" alt=""></p><p>示例3</p><p>上面的视图中Subview1、Subview2、Subview3是同级视图，都是SuperView的子视图。我们给Subview1加上UITapGestureRecognizer手势，并且通过subView1Action:方法接收回调，点击上面的Subview3后，方法调用如下。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SuperView -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">hitTest:</span><span class="string">withEvent:</span></span><br><span class="line">SuperView -&gt; <span class="string">pointInside:</span><span class="string">withEvent:</span></span><br><span class="line"></span><br><span class="line">Subview3 -&gt; <span class="string">touchesBegan:</span><span class="string">withEvent:</span></span><br><span class="line">Subview3 -&gt; <span class="string">touchesEnded:</span><span class="string">withEvent:</span></span><br></pre></td></tr></table></figure><p>通过上面的例子来看，虽然Subview1在Subview3的下面，并且添加了手势，点击区域是在Subview1和Subview3两个视图上的。但是由于经过hitTest和pointInside之后，响应者链中并没有Subview1，所以Subview1的手势并没有被响应。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>根据我们上面的测试，推断iOS响应事件的优先级，以及整体的响应逻辑。</p><p>当事件到来时，会通过hitTest和pointInside两个方法，从Window开始向上面的视图查找，找到第一响应者的视图。找到第一响应者后，系统会判断其是继承自UIControl还是UIResponder，如果是继承自UIControl，则直接通过UIApplication直接向其派发消息，并且不再向响应者链派发消息。</p><p>如果是继承自UIResponder的类，则调用第一响应者的touchesBegin，并且不会立即执行touchesEnded，而是调用之后顺着响应者链向后查找。如果在查找过程中，发现响应者链中有的视图添加了手势，则进入手势的代理方法中，如果代理方法返回可以响应这个事件，则将第一响应者的事件取消，并调用其touchesCanceled方法，然后由手势来响应事件。</p><p>如果手势不能处理事件，则交给第一响应者来处理。如果第一响应者也不能响应事件，则顺着响应者链继续向后查找，直到找到能够处理事件的UIResponder对象。如果找到UIApplication还没有对象响应事件的话，则将这次事件丢弃。</p><h3 id="接收事件深度剖析"><a href="#接收事件深度剖析" class="headerlink" title="接收事件深度剖析"></a>接收事件深度剖析</h3><p>在UIApplication接收到响应事件之前，还有更复杂的系统级的处理，处理流程大致如下。</p><ol><li><p>系统通过IOKit.framework来处理硬件操作，其中屏幕处理也通过IOKit完成(IOKit可能是注册监听了屏幕输出的端口) 当用户操作屏幕，IOKit收到屏幕操作，会将这次操作封装为IOHIDEvent对象。通过mach port(IPC进程间通信)将事件转发给SpringBoard来处理。</p></li><li><p>SpringBoard是iOS系统的桌面程序。SpringBoard收到mach port发过来的事件，唤醒main runloop来处理。 main runloop将事件交给source1处理，source1会调用__IOHIDEventSystemClientQueueCallback()函数。</p></li><li><p>函数内部会判断，是否有程序在前台显示，如果有则通过mach port将IOHIDEvent事件转发给这个程序。 如果前台没有程序在显示，则表明SpringBoard的桌面程序在前台显示，也就是用户在桌面进行了操作。 <strong>IOHIDEventSystemClientQueueCallback()函数会将事件交给source0处理，source0会调用</strong>UIApplicationHandleEventQueue()函数，函数内部会做具体的处理操作。</p></li><li><p>例如用户点击了某个应用程序的icon，会将这个程序启动。 应用程序接收到SpringBoard传来的消息，会唤醒main runloop并将这个消息交给source1处理，source1调用<strong>IOHIDEventSystemClientQueueCallback()函数，在函数内部会将事件交给source0处理，并调用source0的</strong>UIApplicationHandleEventQueue()函数。 在__UIApplicationHandleEventQueue()函数中，会将传递过来的IOHIDEvent转换为UIEvent对象。</p></li><li><p>在函数内部，调用UIApplication的sendEvent:方法，将UIEvent传递给第一响应者或UIControl对象处理，在UIEvent内部包含若干个UITouch对象。</p></li></ol><h6 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h6><p>source1是runloop用来处理mach port传来的系统事件的，source0是用来处理用户事件的。 source1收到系统事件后，都会调用source0的函数，所以最终这些事件都是由source0处理的。</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>在开发中，有时会有找到当前View对应的控制器的需求，这时候就可以利用我们上面所学，根据响应者链来找到最近的控制器。</p><p>在UIResponder中提供了nextResponder方法，通过这个方法可以找到当前响应环节的上一级响应对象。可以从当前UIView开始不断调用nextResponder，查找上一级响应者链的对象，就可以找到离自己最近的UIViewController。</p><p>示例代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIViewController</span> *)parentController &#123;</span><br><span class="line">   <span class="built_in">UIResponder</span> *responder = [<span class="keyword">self</span> nextResponder];</span><br><span class="line">   <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">       <span class="keyword">if</span> ([responder isKindOfClass:[<span class="built_in">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">           <span class="keyword">return</span> (<span class="built_in">UIViewController</span> *)responder;</span><br><span class="line">       &#125;</span><br><span class="line">       responder = [responder nextResponder];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者：刘小壮</p><p>链接：<a href="https://www.jianshu.com/p/b0884faae603" rel="external nofollow noopener noreferrer" target="_blank">https://www.jianshu.com/p/b0884faae603</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自&lt;a href=&quot;https://www.jianshu.com/p/b0884faae603&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;iOS事件处理，看我就够了~&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="事件处理" scheme="http://yoursite.com/categories/IOS/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
    
      <category term="事件处理" scheme="http://yoursite.com/tags/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>homebrew-gem使用.</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/ruby/homebrew-gem%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/wiki/工具/ruby/homebrew-gem使用/</id>
    <published>2018-04-23T04:07:12.000Z</published>
    <updated>2018-05-16T12:09:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用cocoapod更新repo会报下面错误：</p><p>Updating spec repo <code>master</code><br>[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down</p><p>经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。<a href="https://blog.github.com/2018-02-23-weak-cryptographic-standards-removed/" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。</p><p>解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。</p><a id="more"></a><h2 id="Homebrew介绍"><a href="#Homebrew介绍" class="headerlink" title="Homebrew介绍"></a>Homebrew介绍</h2><p>Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。<br>援引官方的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew – OS X 不可或缺的套件管理器。</p><p>使用ruby安装Homebrew</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)”</span></span><br></pre></td></tr></table></figure><p>卸载</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/uninstall)"</span></span><br></pre></td></tr></table></figure><p>homebrew使用 </p><p>安装包 brew install <packagename></packagename></p><p>卸载包 brew uninstall <packagename></packagename></p><p>查询可用包 brew search <packagename></packagename></p><p>查看已经安装列表 brew list</p><p>查看任意包信息brew info <packagename></packagename></p><h2 id="ruby更新"><a href="#ruby更新" class="headerlink" title="ruby更新"></a>ruby更新</h2><p>使用brew安装ruby很方便，但缺点也是很明显的，不能实时进行版本的切换，所以还是用 brew + rvm 或brew + rbenv比较好，但是后面的这种方法我没有走通。所以我使用Homebrew更新ruby。</p><p>我们不去删除系统自带的ruby，gem，而是自己重新安装一套新的ruby，gem，通过更改PATH环境变量的方式来更新系统，</p><p>这样做好处比较安全的，不会破坏原有的苹果系统，又不耽误我使用最新的ruby。</p><h4 id="更新Home-brew"><a href="#更新Home-brew" class="headerlink" title="更新Home brew"></a>更新Home brew</h4><p>好了，开始吧</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span>update</span><br><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>ruby</span><br></pre></td></tr></table></figure><h4 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h4><p>系统原始版本的/usr/bin/ruby 我们并不删除，只是更改PATH环境变量，且将/usr/local/bin 添加到PATH的前面，这样系统就会首先用</p><p>/usr/local/bin下面找到我们用brew安装的ruby ruby 2.5.1p57(2018-03-29 revision 63029) [x86_64-darwin16]版本的了。</p><p>到自己目录下的.profile 或者 .bashrc 或者  .bash_profile    </p><p>用vim打开 （更改前请备份好这个文件，避免误操作）</p><p>在文件的末尾加入:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for brew install</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><p>然后重启终端，就可以用到了新的ruby了</p><p>检验一下</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ruby --version</span><br><span class="line">ruby <span class="number">2.5</span><span class="number">.1</span>p57 (<span class="number">2018</span><span class="number">-03</span><span class="number">-29</span> revision <span class="number">63029</span>) [x86_64-darwin16]</span><br><span class="line">$ which ruby</span><br><span class="line">/usr/local/bin/ruby               注意：系统的是 /usr/bin/ruby</span><br></pre></td></tr></table></figure><h4 id="gem的自我更新"><a href="#gem的自我更新" class="headerlink" title="gem的自我更新"></a>gem的自我更新</h4><p>gem是随着ruby的安装而安装的，所以路径和刚刚安装ruby的路径是相同过的，</p><p>此gem是自己安装路径中的gem (/usr/local/bin/gem)，不是系统的gem(/usr/bin/gem)，我们这里也不动系统的gem</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> gem</span></span><br><span class="line">/usr/local/bin/gem</span><br></pre></td></tr></table></figure><h2 id="gem-介绍"><a href="#gem-介绍" class="headerlink" title="gem 介绍"></a>gem 介绍</h2><p>Gem是一个管理Ruby库和程序的标准包，它通过<a href="http://rubygems.org/" rel="external nofollow noopener noreferrer" target="_blank">Ruby Gem</a>源来查找、安装、升级和卸载软件包，非常的便捷。</p><p>Ruby 1.9.2版本默认已安装Ruby Gem，如果你使用其它发行版本，请参考“如何安装Ruby Gem”。</p><p>Ruby gem包的安装方式：</p><p>所有的gem包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了Cache、doc、gems、specifications 4个目录，cache下放置下载的原生gem包，gems下则放置的是解压过的gem包。<br>当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的gem包，然后重新运行 gem install [gemname] 命令即可。</p><p>Ruby Gem命令详解：</p><p>//更新Gem自身<br>//注意：在某些linux发行版中为了系统稳定性此命令禁止执行<br>$ gem update –system</p><p>// 从Gem源安装gem包<br>$ gem install [gemname]</p><p>// 从本机安装gem包<br>$ gem install -l [gemname].gem</p><p>// 安装指定版本的gem包<br>$ gem install [gemname] –version=[ver]</p><p>// 更新所有已安装的gem包<br>$ gem update</p><p>// 更新指定的gem包<br>// 注意：gem update [gemname]不会升级旧版本的包，此时你可以使用 gem install [gemname] –version=[ver]代替<br>$ gem update [gemname]</p><p>// 删除指定的gem包，注意此命令将删除所有已安装的版本<br>$ gem uninstall [gemname]</p><p>// 删除某指定版本gem<br>$ gem uninstall [gemname] –version=[ver]</p><p>// 查看本机已安装的所有gem包<br>$ gem list [–local]</p><h2 id="解决无法连接到GitHub问题"><a href="#解决无法连接到GitHub问题" class="headerlink" title="解决无法连接到GitHub问题"></a>解决无法连接到GitHub问题</h2><p>通过下面的命令可以解决链接到Github失败的问题 ：</p><h4 id="升级openssl"><a href="#升级openssl" class="headerlink" title="升级openssl"></a>升级openssl</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/opt/openssl/bin/openssl</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.0.2o  27 Mar 2018</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">如果openssl版本低，请使用Homebrew更新</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew update</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew install openssl</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> brew upgrade openssl</span></span><br><span class="line"></span><br><span class="line">`` If you need to have this software first in your PATH run: echo 'export PATH="/usr/local/opt/openssl/bin:$PATH"' &gt;&gt; ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/opt/openssl/bin:$PATH"'</span> &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">which</span> openssl</span></span><br><span class="line">/usr/local/opt/openssl/bin/openssl</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> openssl version</span></span><br><span class="line">OpenSSL 1.0.2n  7 Dec 2017</span><br></pre></td></tr></table></figure><h4 id="升级ruby"><a href="#升级ruby" class="headerlink" title="升级ruby"></a>升级ruby</h4><p>$ ruby –version<br>ruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-darwin16]</p><p>如果版本比较低，请参考ruby升级</p><h4 id="升级cocoapod"><a href="#升级cocoapod" class="headerlink" title="升级cocoapod"></a>升级cocoapod</h4><p>$ gem install cocoapods -n /usr/local/bin</p><p>$ which pod<br>/usr/local/bin/pod</p><p>$ pod –version<br>1.5.0</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blog.csdn.net/wks_lovewei/article/details/73369333" rel="external nofollow noopener noreferrer" target="_blank">mac系统用HomeBrew直接安装ruby</a></li><li><a href="https://stackoverflow.com/questions/38993527/cocoapods-failed-to-connect-to-github-to-update-the-cocoapods-specs-specs-repo" rel="external nofollow noopener noreferrer" target="_blank">Cocoapods: Failed to connect to GitHub to update the CocoaPods/Specs specs repo</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用cocoapod更新repo会报下面错误：&lt;/p&gt;
&lt;p&gt;Updating spec repo &lt;code&gt;master&lt;/code&gt;&lt;br&gt;[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down&lt;/p&gt;
&lt;p&gt;经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。&lt;a href=&quot;https://blog.github.com/2018-02-23-weak-cryptographic-standards-removed/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="ruby" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/ruby/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>堆区（heap）和栈区（stack）的区别(转载)</title>
    <link href="http://yoursite.com/wiki/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/%E5%A0%86%E5%8C%BA%EF%BC%88heap%EF%BC%89%E5%92%8C%E6%A0%88%E5%8C%BA%EF%BC%88stack%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/</id>
    <published>2018-04-03T04:07:12.000Z</published>
    <updated>2018-05-16T12:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>（1）申请方式</p><p>栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；</p><p>堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收；</p><p>（2）操作方式</p><p>栈区：操作方式类似于数据结构中的栈；</p><p>堆区：不同于数据结构中的堆，分配方式类似于链表。</p><p>（3）申请后系统的响应 </p><p>栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出；</p><p>堆区：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 </p><p>（4）申请大小的限制</p><p>栈区：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p>堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>（5）申请效率的比较</p><p>栈区：系统自动分配，速度较快。但程序员是无法控制的。</p><p>堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. </p><p>注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。</p><p>（6）堆和栈中的存储内容</p><p>栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。</p><p>堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。</p><p>参考资料</p><p><a href="https://blog.csdn.net/shanshanhi/article/details/50904706" rel="external nofollow noopener noreferrer" target="_blank">堆区（heap）和栈区（stack）的区别</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;（1）申请方式&lt;/p&gt;
&lt;p&gt;栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等；&lt;/p&gt;
&lt;p&gt;堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收；&lt;/p&gt;

      
    
    </summary>
    
      <category term="C语言语法" scheme="http://yoursite.com/categories/C%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="C 语言语法" scheme="http://yoursite.com/tags/C-%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>NSDateFormatter 时间格式</title>
    <link href="http://yoursite.com/wiki/IOS%20/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/NSDateFormatter%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS /foundation使用记录/NSDateFormatter时间格式/</id>
    <published>2018-03-22T07:35:49.000Z</published>
    <updated>2018-03-22T06:03:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="时间匹配格式"><a href="#时间匹配格式" class="headerlink" title="时间匹配格式"></a>时间匹配格式</h2><caption><a>Date Field Symbol Table</a></caption><table><thead><tr><th>Field</th><th>Sym.</th><th>No.</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>era</td><td>G</td><td>1..3</td><td>AD</td><td>Era - Replaced with the Era string for the current date. One to three letters for the abbreviated form, four letters for the long form, five for the narrow form.</td></tr><tr><td></td><td></td><td>4</td><td>Anno Domini</td></tr><tr><td></td><td></td><td>5</td><td>A</td></tr><tr><td>year</td><td>y</td><td>1..n</td><td>1996</td><td>Year. Normally the length specifies the padding, but for two letters it also specifies the maximum length. Example:</td></tr><tr><td></td><td>Y</td><td>1..n</td><td>1997</td><td>Year (in “Week of Year” based calendars). This year designation is used in ISO year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems where week date processing is desired. May not always be the same value as calendar year.</td></tr><tr><td></td><td>u</td><td>1..n</td><td>4601</td><td>Extended year. This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0.</td></tr><tr><td>quarter</td><td>Q</td><td>1..2</td><td>02</td><td>Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name.</td></tr><tr><td></td><td></td><td>3</td><td>Q2</td></tr><tr><td></td><td></td><td>4</td><td>2nd quarter</td></tr><tr><td></td><td>q</td><td>1..2</td><td>02</td><td><strong>Stand-Alone</strong> Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name.</td></tr><tr><td></td><td></td><td>3</td><td>Q2</td></tr><tr><td></td><td></td><td>4</td><td>2nd quarter</td></tr><tr><td>month</td><td>M</td><td>1..2</td><td>09</td><td>Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Sept</td></tr><tr><td></td><td></td><td>4</td><td>September</td></tr><tr><td></td><td></td><td>5</td><td>S</td></tr><tr><td></td><td>L</td><td>1..2</td><td>09</td><td><strong>Stand-Alone</strong> Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or 5 for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Sept</td></tr><tr><td></td><td></td><td>4</td><td>September</td></tr><tr><td></td><td></td><td>5</td><td>S</td></tr><tr><td></td><td>l</td><td>1</td><td>*</td><td>Special symbol for Chinese leap month, used in combination with M. Only used with the Chinese calendar.</td></tr><tr><td>week</td><td>w</td><td>1..2</td><td>27</td><td>Week of Year.</td></tr><tr><td></td><td>W</td><td>1</td><td>3</td><td>Week of Month</td></tr><tr><td>day</td><td>d</td><td>1..2</td><td>1</td><td>Date - Day of the month</td></tr><tr><td></td><td>D</td><td>1..3</td><td>345</td><td>Day of year</td></tr><tr><td></td><td>F</td><td>1</td><td>2</td><td>Day of Week in Month. The example is for the 2nd Wed in July</td></tr><tr><td></td><td>g</td><td>1..n</td><td>2451334</td><td>Modified Julian day. This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields.</td></tr><tr><td>week day</td><td>E</td><td>1..3</td><td>Tues</td><td>Day of week - Use one through three letters for the short day, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td></td><td>e</td><td>1..2</td><td>2</td><td>Local day of week. Same as E except adds a numeric value that will depend on the local starting day of the week, using one or two letters. For this example, Monday is the first day of the week.</td></tr><tr><td></td><td></td><td>3</td><td>Tues</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td></td><td>c</td><td>1</td><td>2</td><td><strong>Stand-Alone</strong> local day of week - Use one letter for the local numeric value (same as ‘e’), three for the short day, or four for the full name, or five for the narrow name.</td></tr><tr><td></td><td></td><td>3</td><td>Tues</td></tr><tr><td></td><td></td><td>4</td><td>Tuesday</td></tr><tr><td></td><td></td><td>5</td><td>T</td></tr><tr><td>period</td><td>a</td><td>1</td><td>AM</td><td>AM or PM</td></tr><tr><td>hour</td><td>h</td><td>1..2</td><td>11</td><td>Hour [1-12].</td></tr><tr><td></td><td>H</td><td>1..2</td><td>13</td><td>Hour [0-23].</td></tr><tr><td></td><td>K</td><td>1..2</td><td>0</td><td>Hour [0-11].</td></tr><tr><td></td><td>k</td><td>1..2</td><td>24</td><td>Hour [1-24].</td></tr><tr><td></td><td>j</td><td>1..2</td><td>n/a</td><td>This is a special-purpose symbol. It must not occur in patterns, but is reserved for use in APIs doing flexible date pattern generation, and requests the preferred format (12 vs 24 hour) for the language in question.</td></tr><tr><td>minute</td><td>m</td><td>1..2</td><td>59</td><td>Minute. Use one or two for zero padding.</td></tr><tr><td>second</td><td>s</td><td>1..2</td><td>12</td><td>Second. Use one or two for zero padding.</td></tr><tr><td></td><td>S</td><td>1..n</td><td>3457</td><td>Fractional Second - rounds to the count of letters. (example is for 12.34567)</td></tr><tr><td></td><td>A</td><td>1..n</td><td>69540000</td><td>Milliseconds in day. This field behaves  <em>exactly</em>  like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value.</td></tr><tr><td>zone</td><td>z</td><td>1..3</td><td>PDT _fallbacks: _HPG-8:00 GMT-08:00</td><td>Timezone - with the s <em>pecific non-location format</em> . Where that is unavailable, falls back to  <em>localized GMT format</em> . Use one to three letters for the short format or four for the full format. In the short format, metazone names are not used unless the commonlyUsed flag is on in the locale.</td></tr><tr><td></td><td></td><td>4</td><td>Pacific Daylight Time <em>fallbacks:</em>  HPG-8:00 GMT-08:00</td></tr><tr><td></td><td>Z</td><td>1..3</td><td>-0800</td><td>Timezone - Use one to three letters for RFC 822 format, four letters for the localized GMT format.</td></tr><tr><td></td><td></td><td>4</td><td>HPG+8:00 <em>fallbacks:</em> GMT-08:00</td></tr><tr><td></td><td>v</td><td>1</td><td>PT</td><td>Timezone - with the  <em>generic</em>   <em>non-location format</em> . Where that is unavailable, uses special fallback rules given in  <em>[Appendix J][6]</em> . Use one letter for short format, four for long format.</td></tr><tr><td></td><td></td><td>4</td><td>Pacific Time <em>fallbacks:</em> Pacific Time (Canada) Pacific Time (Yellowknife) United States (Los Angeles) Time HPG-8:35 GMT-08:35</td></tr><tr><td></td><td>V</td><td>1</td><td>PST HPG-8:00 GMT-08:00</td><td>Timezone - with the same format as z, except that metazone timezone abbreviations are to be displayed if available, regardless of the value of commonlyUsed.</td></tr><tr><td></td><td></td><td>4</td><td>United States (Los Angeles) Time <em>fallbacks:</em>  HPG-8:35 MT-08:35</td><td>Timezone - with the  <em>generic</em>   <em>location format</em> . Where that is unavailable, falls back to the localized GMT format. (Fallback is only necessary with a GMT-style Timezone ID, like Etc/GMT-830.) This is especially useful when presenting possible timezone choices for user selection, since the naming is more uniform than the v format.</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://unicode.org/reports/tr35/tr35-10.html#Date_Format_Patternss" rel="external nofollow noopener noreferrer" target="_blank">UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;时间匹配格式&quot;&gt;&lt;a href=&quot;#时间匹配格式&quot; class=&quot;headerlink&quot; title=&quot;时间匹配格式&quot;&gt;&lt;/a&gt;时间匹配格式&lt;/h2&gt;&lt;caption&gt;&lt;a&gt;Date Field Symbol Table&lt;/a&gt;&lt;/caption&gt;

&lt;table
      
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="foundation使用记录" scheme="http://yoursite.com/categories/IOS/foundation%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="NSDateFormatter" scheme="http://yoursite.com/tags/NSDateFormatter/"/>
    
  </entry>
  
  <entry>
    <title>正确使用NS_DESIGNATED_INITIALIZER</title>
    <link href="http://yoursite.com/wiki/IOS%20/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/IOS /虚拟内存/指定初始化函数/</id>
    <published>2018-03-21T04:07:12.000Z</published>
    <updated>2018-04-28T06:17:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文结束了下指定初始化函数，本文完全转载自 <a href="https://blog.csdn.net/zcube/article/details/51657417" rel="external nofollow noopener noreferrer" target="_blank">正确使用NS_DESIGNATED_INITIALIZER</a> 。</p><h2 id="为什么会提到NS-DESIGNATED-INITIALIZER"><a href="#为什么会提到NS-DESIGNATED-INITIALIZER" class="headerlink" title="为什么会提到NS_DESIGNATED_INITIALIZER"></a>为什么会提到NS_DESIGNATED_INITIALIZER</h2><p>============================================================</p><p>最近在清理项目警告，遇到了“Method override for the designated initializer”的警告，全称为：</p><ul><li><p>Method override for the designated initializer of the superclass ‘-init’ not found 或者</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found。</p></li></ul><p>经排查是因为头文件中出现NS_DESIGNATED_INITIALIZER 声明的初始化方法，如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)initWithPurchaseService:(<span class="type">HTLPrepayPurchaseService</span> *)service <span class="type">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p>如果用了NS_DESIGNATED_INITIALIZER，那么警告中出现init、initWithNibName或是其它，取决于你的继承的父类类型：</p><p>UIViewController</p><ul><li><p>Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found</p></li></ul><p>UIView</p><ul><li><p>Method override for the designated initializer of the superclass ‘-initWithFrame:’ not found</p></li><li><p>Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found</p></li></ul><p>NSObject</p><ul><li>Method override for the designated initializer of the superclass ‘-init’ not found</li></ul><h2 id="正确使用NS-DESIGNATED-INITIALIZER"><a href="#正确使用NS-DESIGNATED-INITIALIZER" class="headerlink" title="正确使用NS_DESIGNATED_INITIALIZER"></a>正确使用NS_DESIGNATED_INITIALIZER</h2><h3 id="为什么要用NS-DESIGNATED-INITIALIZER"><a href="#为什么要用NS-DESIGNATED-INITIALIZER" class="headerlink" title="为什么要用NS_DESIGNATED_INITIALIZER"></a>为什么要用NS_DESIGNATED_INITIALIZER</h3><p>Objective-C 中主要通过NS_DESIGNATED_INITIALIZER宏来实现指定构造器的。这里之所以要用这个宏，往往是想<font color="red">告诉调用者要用这个方法去初始化（构造）类对象</font>。</p><h3 id="怎样避免使用NS-DESIGNATED-INITIALIZER产生的警告"><a href="#怎样避免使用NS-DESIGNATED-INITIALIZER产生的警告" class="headerlink" title="怎样避免使用NS_DESIGNATED_INITIALIZER产生的警告"></a>怎样避免使用NS_DESIGNATED_INITIALIZER产生的警告</h3><p>如果子类指定了新的初始化器，那么在这个初始化器内部必须调用父类的Designated Initializer。并且需要重写父类的Designated Initializer，将其指向子类新的初始化器。</p><p>如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> initWithName:<span class="string">@""</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h3><p>如果定义NS_DESIGNATED_INITIALIZER，大多是不想让调用者调用父类的初始化函数，只希望通过该类指定的初始化进行初始化，这时候就可以用NS_UNAVAILABLE宏。</p><p>如下：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (instance<span class="keyword">type</span>)init <span class="type">NS_UNAVAILABLE</span>;</span><br><span class="line">- (instance<span class="keyword">type</span>)initWithName:(<span class="type">NSString</span> *)name <span class="type">NS_DESIGNATED_INITIALIZER</span>;</span><br></pre></td></tr></table></figure><p>如果调用者使用init 初始化，编译器就会给出一个编译错误。使用NS_UNAVAILABLE后，就不需要在.m中重写父类初始化函数了。如果要允许调用者使用init就需要在.m中重写父类的初始化函数，如上提到的，否则就会报警告。</p><h2 id="避免使用new"><a href="#避免使用new" class="headerlink" title="避免使用new"></a>避免使用new</h2><p>如果使用new来创建对象的话，即使init被声明为NS_UNAVAILABLE，也不会收到编译器的警告和错误提示了。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ol><li><a href="[http://stackoverflow.com/questions/26185239/ios-designated-initializers-using-ns-designated-initializer]">iOS Designated Initializers : Using NS_DESIGNATED_INITIALIZER</a>  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文结束了下指定初始化函数，本文完全转载自 &lt;a href=&quot;https://blog.csdn.net/zcube/article/details/51657417&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;
      
    
    </summary>
    
      <category term="IOS " scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="指定初始化函数" scheme="http://yoursite.com/tags/%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>工具下载地址</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    <id>http://yoursite.com/wiki/工具/工具下载地址/工具下载地址/</id>
    <published>2018-03-13T10:01:31.000Z</published>
    <updated>2018-03-22T06:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录常用工具下载地址</p><a id="more"></a><p><a href="http://xclient.info/s/cornerstone.html?_=74d8fe1bd364c1684fb6797602864a6a" rel="external nofollow noopener noreferrer" target="_blank">xclient</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录常用工具下载地址&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="工具下载地址" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>创建私有仓库</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-private-repo/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-private-repo/</id>
    <published>2018-03-01T06:50:54.000Z</published>
    <updated>2018-03-05T10:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 ‘官方仓库’、’私有仓库’。</p><ol><li><a href="https://github.com/CocoaPods/Specs.git" rel="external nofollow noopener noreferrer" target="_blank">官方仓库</a>的作用代表CocoaPods的官方podspec存放地址。 具体可以参考:<a href="https://github.com/CocoaPods/Specs" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods官方源</a>、<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" rel="external nofollow noopener noreferrer" target="_blank">Specs</a>; </li><li><a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">私有仓库</a>的是私有podspec存放地址。在git中仓库名称是LJRepo，clone到本地的别名是MyPrivateRepo。后文中私有仓库–LJRepo指的git地址，MyPrivateRepo指的是clone到本地的名称。</li></ol><a id="more"></a><h2 id="创建私有仓库"><a href="#创建私有仓库" class="headerlink" title="创建私有仓库"></a>创建私有仓库</h2><p>仓库（Spec Repo） 是所有的Pods的一个索引，是所有公开\私有Pods的podspec文件仓库，其实就是一个部署在服务器的Git仓库，当你使用CocoaPods 后它会被Clone到本地的 ~/.cocoapods/repos 目录下。</p><p>首先在git上创建一个私有远端仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，步骤如下：</p><ol><li><p>在GitHub上创建私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，空的就可以。</p></li><li><p>将私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>添加到cocoapod中，远端私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a> 在本地中的别名是MyPrivateRepo，这样以后操作MyPrivateRepo就相当于操作<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>， 命令如下：</p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo <span class="keyword">add</span><span class="bash"> <span class="string">'MyPrivateRepo'</span> <span class="string">'git@github.com:jianli2017/LJRepo.git'</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：这个Git 仓库地址要换成你自己的创建的 Specs git 地址！！！ 成功后会在~/.cocoapods/repos目录下就能看到MyPrivateRepo了，至此，第一步就完成了创建私有仓库。</p></blockquote><p>创建完成后，查看~/.cocoapods/repos 目录的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> 到~/.cocoapods/repos 目录</span></span><br><span class="line">cd ~/.cocoapods/repos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看目录结构</span></span><br><span class="line">tree -L 3</span><br></pre></td></tr></table></figure><p>大概的文件目录如下:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── MyPrivateRepo</span><br><span class="line">│   └── LJMenu</span><br><span class="line">│       └── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">└── master</span><br><span class="line">    ├── CocoaPods-version.yml</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── Specs</span><br><span class="line">        ├── <span class="number">0</span></span><br><span class="line">        ├── <span class="number">1</span></span><br><span class="line">        ├── <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中master就是官方的Sepc Repo,跟master同目录级别的MyPrivateRepo目录就是我自己创建的私有Sepc Repo。私有仓库中LJMenu是以前创建的，如果以前没有创建，MyPrivateRepo下面是空的。</p><p>也可以使用’pod repo list ‘ 命令查看仓库信息，结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  <span class="string">https:</span><span class="comment">//github.com/CocoaPods/Specs.git</span></span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/master</span><br><span class="line"></span><br><span class="line">MyPrivateRepo</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  git<span class="meta">@github</span>.<span class="string">com:</span>jianli2017/LJRepo.git</span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/MyPrivateRepo</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> repos</span><br></pre></td></tr></table></figure><p>小结</p><p>上面讲解了私有仓库的创建方法。创建完成后，从两个方面描述私有仓库，进一步认识私有创库：文件目录、pod命令</p><h2 id="创建LJMenu库"><a href="#创建LJMenu库" class="headerlink" title="创建LJMenu库"></a>创建<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a></h2><p>1.创建LJMenu库： 首先，在Git上创建一个<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu仓库</a>,当然你也是可以在公司内网创建的。 创建方法使用Cocoapods提供的一个<a href="http://guides.cocoapods.org/making/using-pod-lib-create" rel="external nofollow noopener noreferrer" target="_blank">Using Pod Lib Create</a> 工具。</p><p>在Terminal中执行cd命令，进入要创建项目的目录，执行以下命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod lib create [项目名]</span></span><br><span class="line">pod <span class="class"><span class="keyword">lib</span> <span class="title">create</span> <span class="title">LJMenu</span></span></span><br></pre></td></tr></table></figure><p>‘pod lib create’命令会在当前目录创建LJMenu项目，接着在Terminal控制台会输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cloning `<span class="keyword">https</span>://github.com/CocoaPods/pod-template.git` <span class="keyword">into</span> `LJMenu`.</span><br><span class="line">Configuring LJMenu template.</span><br><span class="line">Ignoring ffi<span class="number">-1.9</span><span class="number">.14</span> because its extensions are <span class="keyword">not</span> built.  Try: gem pristine ffi <span class="comment">--version 1.9.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"></span><br><span class="line">To <span class="built_in">get</span> you started we need <span class="built_in">to</span> ask <span class="keyword">a</span> few questions, this should only take <span class="keyword">a</span> minute.</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-02</span> <span class="number">13</span>:<span class="number">55</span>:<span class="number">04.386</span> defaults[<span class="number">30912</span>:<span class="number">784564</span>] </span><br><span class="line">The domain/default pair <span class="keyword">of</span> (org.cocoapods.pod-template, HasRunbefore) does <span class="keyword">not</span> exist</span><br><span class="line">If this is your <span class="keyword">first</span> <span class="built_in">time</span> we recommend running through <span class="keyword">with</span> <span class="keyword">the</span> guide: </span><br><span class="line"> - <span class="keyword">http</span>://guides.cocoapods.org/making/<span class="keyword">using</span>-pod-lib-<span class="built_in">create</span>.html</span><br><span class="line"> ( hold cmd <span class="keyword">and</span> double click links <span class="built_in">to</span> <span class="built_in">open</span> <span class="keyword">in</span> <span class="keyword">a</span> browser. )</span><br><span class="line"></span><br><span class="line"> Press <span class="literal">return</span> <span class="built_in">to</span> continue.</span><br></pre></td></tr></table></figure><p>选择回车按钮，接着会出现一系列的问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">What platform <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ iOS / macOS ]</span><br><span class="line"> &gt; ios</span><br><span class="line"></span><br><span class="line">What <span class="keyword">language</span> <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ Swift / ObjC ]</span><br><span class="line"> &gt; objc</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">include</span> a demo application <span class="keyword">with</span> your <span class="keyword">library</span>? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you <span class="keyword">use</span>? [ Specta / Kiwi / <span class="keyword">None</span> ]</span><br><span class="line"> &gt; specta</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">view</span> based testing? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">What <span class="keyword">is</span> your <span class="keyword">class</span> prefix?</span><br><span class="line"> &gt; LJ</span><br></pre></td></tr></table></figure><p>回答完问题后，会创建出LJMenu项目。结构如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">Example</span></span><br><span class="line">│   ├── LJMenu</span><br><span class="line">│   ├── LJMenu.xcodeproj</span><br><span class="line">│   ├── LJMenu.xcworkspace</span><br><span class="line">│   ├── Podfile</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LJMenu     **这个是创建的LJMenu项目**</span><br><span class="line">│   ├── Assets</span><br><span class="line">│   └── <span class="keyword">Classes</span></span><br><span class="line">├── LJMenu.podspec  </span><br><span class="line">├── README.md</span><br><span class="line">└── _Pods.xcodeproj -&gt; <span class="keyword">Example</span>/Pods/Pods.xcodeproj</span><br></pre></td></tr></table></figure><p>2、添加实现代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LJMenu</span><br><span class="line">├── Assets</span><br><span class="line">└── Classes</span><br><span class="line">    ├── LJMenu</span><br><span class="line">    │   ├── IFMMenu.h</span><br><span class="line">    │   ├── IFMMenu.m</span><br><span class="line">    │   ├── IFMMenuContainerView.h</span><br><span class="line">    │   ├── IFMMenuContainerView.m</span><br><span class="line">    │   ├── IFMMenuItem.h</span><br><span class="line">    │   ├── IFMMenuItem.m</span><br><span class="line">    │   ├── IFMMenuView.h</span><br><span class="line">    │   └── IFMMenuView.m</span><br><span class="line">    └── ReplaceMe.m</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">9</span> files</span><br></pre></td></tr></table></figure><p>在本教程中我在上面的Classes文件目录添加了 IFMMenu*.[h、m]八个文件。<br>3.开发模式下测试pod库的代码 打开Example工程目录Podfile文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">#pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../MyLib.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行 pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了 不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/MyLib中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。测试库文件没有问题,接着我们需要执行第4步。</p><p>4.提交<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a>到git上。 在Terminal中执行以下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'1.0.2'</span></span></span><br><span class="line"><span class="bash">git remote add origin git@github.com:jianli2017/LJMenu.git</span></span><br><span class="line"><span class="bash">git push origin master     <span class="comment">#提交到远端仓库</span></span></span><br><span class="line"><span class="bash">git tag -m <span class="string">"v1.0.2"</span> <span class="string">"v1.0.2"</span> <span class="comment">#打上标签，这个很重要</span></span></span><br><span class="line"><span class="bash">git push --tags     <span class="comment">#推送tag到远端仓库</span></span></span><br></pre></td></tr></table></figure><p>到这里，成功提交到远程仓库—<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu库</a>，以后就可以使用git上的LJMenu库了。</p><h2 id="创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo"><a href="#创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo" class="headerlink" title="创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo"></a>创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo</h2><p>1.配置LJMenu库的podspec 文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint LJMenu.podspec' to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name             = <span class="string">'LJMenu'</span></span><br><span class="line">  s.version          = <span class="string">'1.0.2'</span></span><br><span class="line">  s.summary          = <span class="string">'A short description of LJMenu.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don't worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">TODO: Add long description of the pod here.</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage         = <span class="string">'https://github.com/jianli2017/LJMenu'</span></span><br><span class="line">  <span class="comment"># s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'</span></span><br><span class="line">  s.license          = &#123; <span class="symbol">:type</span> =&gt; <span class="string">'MIT'</span>, <span class="symbol">:file</span> =&gt; <span class="string">'LICENSE'</span> &#125;</span><br><span class="line">  s.author           = &#123; <span class="string">'jianli2017'</span> =&gt; <span class="string">'lijian-ds1@gomeplus.com'</span> &#125;</span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/jianli2017/LJMenu.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">'v1.0.2'</span>&#125;</span><br><span class="line">  <span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class="line"></span><br><span class="line">  s.ios.deployment_target = <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">'LJMenu/Classes/**/*'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   'LJMenu' =&gt; ['LJMenu/Assets/*.png']</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class="line">  <span class="comment"># s.frameworks = 'UIKit', 'MapKit'</span></span><br><span class="line">  <span class="comment"># s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>podspec更多配置请参考:<a href="http://guides.cocoapods.org/syntax/podspec.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></p><p>2.验证LJMenu.podspec</p><p>编辑完LJMenu.podspec文件后，需要验证一下这个LJMenu.podspec文件是否可用 ,在Terminal中执行cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint  <span class="comment">--allow-warnings</span></span><br></pre></td></tr></table></figure><p>当你看到 Terminal 中输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Analyzed <span class="number">1</span> podspec.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">LJMenu.podspec passed validation.</span></span><br></pre></td></tr></table></figure><p>表示这个LJMenu.podspec 验证通过，是一个符合CocoaPods规则的配置文件。</p><p>3.本地测试LJMenu.podspec文件 </p><p>打开Example工程目录Podfile文件修改下pod 的引用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pod <span class="string">'LJMenu'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">pod <span class="string">'LJMenu'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../LJMenu.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行pod install命令安装依赖，打开项目工程，现在可以看到库文件都被加载到Pods子项目中了</p><p>4.向Spec Repo提交podspec </p><p>测试库文件没有问题我们就把MyLib.podspec提交到远程Spec Repo仓库中，就是本文开头说的[官方仓库][13] 在Terminal中执行 cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pod repo push [Repo名] [podspec 文件名字]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pod repo push MyPrivateRepo ./LJMenu.podspec --allow-warnings</span></span><br></pre></td></tr></table></figure><p>如果提交成功，在Terminal会输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Validating spec</span><br><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Updating the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Already up-to-date.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Adding the spec to the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"> - [Update] LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Pushing the <span class="string">`MyPrivateRepo' repo</span></span></span><br></pre></td></tr></table></figure><p>表示提交成功了！这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/MySpecs目录下查看</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~<span class="regexp">/.cocoapods/repos</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">tree -L 3 MyPrivateRepo/</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPrivateRepo/</span><br><span class="line">└── LJMenu</span><br><span class="line">    ├── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">    │   └── LJMenu.podspec</span><br><span class="line">    └── <span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">        └── LJMenu.podspec</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>再去看我们的Spec Repo远端仓库 也就是[官方仓库][14]，也有了一次提交，这个podspec也已经被Push上去了。</p><p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了. 在Terminal中执行 pod search MyLib</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; LJMenu (<span class="number">1.0</span><span class="number">.2</span>)</span><br><span class="line">   A <span class="keyword">short</span> description of LJMenu.</span><br><span class="line">   pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu.git</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span><span class="number">.2</span>, <span class="number">1.0</span><span class="number">.1</span> [MyPrivateRepo repo]</span><br></pre></td></tr></table></figure><h2 id="使用制作好的Pod"><a href="#使用制作好的Pod" class="headerlink" title="使用制作好的Pod"></a>使用制作好的Pod</h2><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可, 在正式项目的Podfile 里添加私有Spec Repo</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#私有Spec Repo</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">source</span> <span class="string">'git<span class="variable">@github</span>.com:jianli2017/LJRepo.git'</span> </span><br><span class="line">source <span class="string">'git<span class="variable">@github</span>.com:CocoaPods/Specs.git'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br></pre></td></tr></table></figure><p>然后执行pod install，安装依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p><h2 id="将LJMenu发布到官方仓库中"><a href="#将LJMenu发布到官方仓库中" class="headerlink" title="将LJMenu发布到官方仓库中"></a>将LJMenu发布到官方仓库中</h2><h3 id="注册CocoaPods"><a href="#注册CocoaPods" class="headerlink" title="注册CocoaPods"></a>注册CocoaPods</h3><p>首先使用pod trunk me查看自己是否注册过：如果没有下面类似的内容输出,则表示没有注册过</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> <span class="symbol">Name:</span>     jianli2017</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Email:</span>    jianli2017@163.com</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Since:</span>    February <span class="number">28</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">01</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">Pods:</span>     None</span></span><br><span class="line"><span class="ruby">- <span class="symbol">Sessions:</span></span></span><br><span class="line"><span class="ruby">- February <span class="number">28</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">01</span> - July <span class="number">6</span>th, <span class="number">04</span><span class="symbol">:</span><span class="number">04</span>. <span class="symbol">IP:</span> <span class="number">101.254</span>.<span class="number">248.194</span></span></span><br></pre></td></tr></table></figure><p>使用pod trunk register命令注册。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">pod</span> <span class="selector-tag">trunk</span> <span class="selector-tag">register</span> <span class="selector-tag">jianli2017</span>@<span class="keyword">163</span>.<span class="keyword">com</span> <span class="string">'jianli2017'</span> --verbose</span><br></pre></td></tr></table></figure><p>注册完成后，使用下面的命令，将LJMenu库的spec推送到官方仓库中。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod trunk <span class="built_in">push</span>  --allow-<span class="built_in">warnings</span></span><br></pre></td></tr></table></figure><p>推送完成后，可以使用pod search 查看。</p><h2 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h2><h4 id="pod命令使用方法"><a href="#pod命令使用方法" class="headerlink" title="pod命令使用方法"></a>pod命令使用方法</h4><p>pod的命令如果不知道怎么用，可以使用pod –help命令查看使用方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod COMMAND</span><br><span class="line"></span><br><span class="line">CocoaPods, the Cocoa library package manager.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"></span><br><span class="line">+ <span class="keyword">cache</span>         Manipulate the CocoaPods <span class="keyword">cache</span></span><br><span class="line">+ deintegrate   Deintegrate CocoaPods <span class="keyword">from</span> your <span class="keyword">project</span></span><br><span class="line">+ env           Display pod environment</span><br><span class="line">+ init          Generate a Podfile <span class="keyword">for</span> the <span class="keyword">current</span> <span class="keyword">directory</span></span><br><span class="line">+ <span class="keyword">install</span>       <span class="keyword">Install</span> <span class="keyword">project</span> dependencies according <span class="keyword">to</span> <span class="keyword">versions</span> <span class="keyword">from</span> a</span><br><span class="line">Podfile.lock</span><br><span class="line">+ ipc           Inter-process communication</span><br><span class="line">+ lib           Develop pods</span><br><span class="line">+ <span class="keyword">list</span>          <span class="keyword">List</span> pods</span><br><span class="line">+ outdated      <span class="keyword">Show</span> outdated <span class="keyword">project</span> dependencies</span><br><span class="line">+ plugins       <span class="keyword">Show</span> available CocoaPods plugins</span><br><span class="line">+ repo          Manage spec-repositories</span><br><span class="line">+ <span class="keyword">search</span>        <span class="keyword">Search</span> <span class="keyword">for</span> pods</span><br><span class="line">+ setup         Setup the CocoaPods environment</span><br><span class="line">+ spec          Manage pod specs</span><br><span class="line">+ trunk         Interact <span class="keyword">with</span> the CocoaPods API (e.g. publishing <span class="keyword">new</span> specs)</span><br><span class="line">+ try           Try a Pod!</span><br><span class="line">+ <span class="keyword">update</span>        <span class="keyword">Update</span> outdated <span class="keyword">project</span> dependencies <span class="keyword">and</span> <span class="keyword">create</span> <span class="keyword">new</span> Podfile.lock</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"><span class="comment">--silent        Show nothing</span></span><br><span class="line"><span class="comment">--version       Show the version of the tool</span></span><br><span class="line"><span class="comment">--verbose       Show more debugging information</span></span><br><span class="line"><span class="comment">--no-ansi       Show output without ANSI codes</span></span><br><span class="line"><span class="comment">--help          Show help banner of specified command</span></span><br></pre></td></tr></table></figure><p>通过上面可以看到pod 的所有命令。常用的有pod init、pod install、 pod update、pod lib、pod repo等等，如果对pod repo不了解，可以使用pod repo –help进一步查看使用方法。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod repo [COMMAND]</span><br><span class="line"></span><br><span class="line">Manage spec-repositories</span><br><span class="line"></span><br><span class="line">Command<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">+ <span class="built_in">add</span>       Add <span class="keyword">a</span> spec repo</span><br><span class="line">+ lint      Validates <span class="keyword">all</span> specs in <span class="keyword">a</span> repo</span><br><span class="line">&gt; <span class="keyword">list</span>      List repos</span><br><span class="line">+ push      Push <span class="keyword">new</span> specifications <span class="keyword">to</span> <span class="keyword">a</span> spec-repo</span><br><span class="line">+ <span class="built_in">remove</span>    Remove <span class="keyword">a</span> spec repo</span><br><span class="line">+ <span class="keyword">update</span>    Update <span class="keyword">a</span> spec repo</span><br><span class="line"></span><br><span class="line">Option<span class="variable">s:</span></span><br><span class="line"></span><br><span class="line">--<span class="keyword">silent</span>    Show nothing</span><br><span class="line">--<span class="keyword">verbose</span>   Show more debugging information</span><br><span class="line">--<span class="keyword">no</span>-ansi   Show output without ANSI codes</span><br><span class="line">--<span class="keyword">help</span>      Show <span class="keyword">help</span> banner of specified <span class="keyword">command</span></span><br></pre></td></tr></table></figure><p>可以看出，pod repo add 、pod repo list 等命令，如果对pod repo list命令不知道如何使用，可以使用pod repo list –help命令进一步查看使用方法</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">$ pod repo list</span><br><span class="line"></span><br><span class="line">List <span class="keyword">the</span> repos <span class="built_in">from</span> <span class="keyword">the</span> <span class="built_in">local</span> spec-repos <span class="built_in">directory</span> <span class="keyword">at</span> `~/.cocoapods/repos/.`</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"></span><br><span class="line"><span class="comment">--count-only   Show the total number of repos</span></span><br><span class="line"><span class="comment">--silent       Show nothing</span></span><br><span class="line"><span class="comment">--verbose      Show more debugging information</span></span><br><span class="line"><span class="comment">--no-ansi      Show output without ANSI codes</span></span><br><span class="line"><span class="comment">--help         Show help banner of specified command</span></span><br></pre></td></tr></table></figure><p>上面的方法对任何的pod命令都使用，通过上面的方法我们可以学习会pod命令的使用方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p> <a href="https://www.jianshu.com/p/107cc74847ab" rel="external nofollow noopener noreferrer" target="_blank">利用CocoaPods创建私有库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 ‘官方仓库’、’私有仓库’。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods/Specs.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;官方仓库&lt;/a&gt;的作用代表CocoaPods的官方podspec存放地址。 具体可以参考:&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods官方源&lt;/a&gt;、&lt;a href=&quot;http://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Specs&lt;/a&gt;; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jianli2017/LJRepo.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;私有仓库&lt;/a&gt;的是私有podspec存放地址。在git中仓库名称是LJRepo，clone到本地的别名是MyPrivateRepo。后文中私有仓库–LJRepo指的git地址，MyPrivateRepo指的是clone到本地的名称。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>图解SSH原理</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/SSH/ssh-theory/"/>
    <id>http://yoursite.com/wiki/工具/SSH/ssh-theory/</id>
    <published>2018-02-27T10:11:35.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于<a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></p><a id="more"></a><h2 id="初见SSH"><a href="#初见SSH" class="headerlink" title="初见SSH"></a>初见SSH</h2><blockquote><p>SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。</p></blockquote><h2 id="SSH工作原理"><a href="#SSH工作原理" class="headerlink" title="SSH工作原理"></a>SSH工作原理</h2><p>在讨论SSH的原理和使用前，我们需要分析一个问题：为什么需要SSH？</p><p>从第一节SSH的定义中可以看出，SSH和telnet、ftp等协议主要的区别在于安全性。这就引出下一个问题：如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种：</p><ol><li><p>对称加密（也称为秘钥加密）</p></li><li><p>非对称加密（也称公钥加密）</p></li></ol><p>所谓对称加密，指加密解密使用同一套秘钥。如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareEncrypt.png" alt="对称加密-Client端"></p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareDecrypt.png" alt="对称加密-Server端"></p><p>对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：如何安全的传输密钥、保存秘钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。</p><blockquote><p>两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。</p></blockquote><p>下面看下使用非对称加密方案的登录流程：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicEncrypt.png" alt="非对称加密登录流程"></p><ol><li><p>远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。</p></li><li><p>Client使用这个公钥，将密码进行加密。</p></li><li><p>Client将加密的密码发送给Server端。</p></li><li><p>远程Server用自己的私钥，解密登录密码，然后验证其合法性。</p></li><li><p>若验证结果，给Client相应的响应。</p></li></ol><blockquote><p>私钥是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。</p></blockquote><h4 id="这样就一定安全了吗？"><a href="#这样就一定安全了吗？" class="headerlink" title="这样就一定安全了吗？"></a>这样就一定安全了吗？</h4><p>上述流程会有一个问题：Client端如何保证接受到的公钥就是目标Server端的？，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？这就是所谓的[中间人攻击][2]</p><p><img src="//upload-images.jianshu.io/upload_images/2599999-da9359eb5fe05c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623" alt=""></p><p>图1-4：中间人攻击</p><h4 id="SSH中是如何解决这个问题的？"><a href="#SSH中是如何解决这个问题的？" class="headerlink" title="SSH中是如何解决这个问题的？"></a>SSH中是如何解决这个问题的？</h4><h5 id="基于口令的认证"><a href="#基于口令的认证" class="headerlink" title="基于口令的认证"></a>基于口令的认证</h5><p>从上面的描述可以看出，问题就在于如何对Server的公钥进行认证？在https中可以通过CA来进行公证，可是SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'ssh-server.example.com (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><blockquote><p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p></blockquote><p>如果输入yes后，会出现下面信息：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'ssh-server.example.com,12.18.429.21'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts. </span><br><span class="line">Password: (enter password)</span><br></pre></td></tr></table></figure><p>该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码，之后的流程就按照图1-3进行。</p><h5 id="2-基于公钥认证"><a href="#2-基于公钥认证" class="headerlink" title="2.基于公钥认证"></a>2.基于公钥认证</h5><p>在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicKeyAuthentication.png" alt="公钥认证流程"></p><ol><li><p>Client端用户TopGun将自己的公钥存放在Server上，追加在文件authorized_keys中。</p></li><li><p>Server收到登录请求后，随机生成一个字符串str1，并发送给Client。</p></li><li><p>Client用自己的私钥对字符串str1进行加密。</p></li><li><p>将加密后字符串发送给Server。</p></li><li><p>Server用之前存储的公钥进行解密，比较解密后的str2和str1。</p></li><li><p>根据比较结果，返回客户端登陆结果。</p></li></ol><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/GitHub-SSHKeys.png" alt="GitHub中SSH keys设置"></p><h2 id="SSH实践"><a href="#SSH实践" class="headerlink" title="SSH实践"></a>SSH实践</h2><h4 id="生成密钥操作"><a href="#生成密钥操作" class="headerlink" title="生成密钥操作"></a>生成密钥操作</h4><p>经过上面的原理分析，下面三行命令的含义应该很容易理解了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span> -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line">$ cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line">$ chmod <span class="number">0600</span> ~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure><p>ssh-keygen是用于生产密钥的工具。</p><ul><li><p>-t：指定生成密钥类型（rsa、dsa、ecdsa等）</p></li><li><p>-P：指定passphrase，用于确保私钥的安全</p></li><li><p>-f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）</p></li></ul><p>首先看下面~/.ssh中的四个文件：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/SHH-config.png" alt="SSH-涉及文件"></p><ol><li><p>id_rsa：保存私钥</p></li><li><p>id_rsa.pub：保存公钥</p></li><li><p>authorized_keys：保存已授权的客户端公钥</p></li><li><p>known_hosts：保存已认证的远程主机公钥</p></li></ol><p>四个角色的关系如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/ssh-struct.png" alt="SSH 结构简图"></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h6 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以用户名user，登录远程主机host</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地用户和远程用户相同，则用户名可省去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SSH默认端口22，可以用参数p修改端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2017 user@host</span></span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本文以图文方式对SSH原理进行解析（主要指远程登录，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于&lt;a href=&quot;https://www.jianshu.com/p/33461b619d53&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;图解SSH原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="SSH" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/SSH/"/>
    
    
  </entry>
  
  <entry>
    <title>Cocoapods-new-spec</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/Cocoapods-new-spec/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/Cocoapods-new-spec/</id>
    <published>2018-02-27T07:06:13.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>cocoapod学习 安装和使用（1）</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-learn-install/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-learn-install/</id>
    <published>2018-02-27T02:29:06.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a> Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在<a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a>的基础上稍微修改而来。<br><a id="more"></a></p><h2 id="什么是CocoaPods？"><a href="#什么是CocoaPods？" class="headerlink" title="什么是CocoaPods？"></a>什么是CocoaPods？</h2><p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a>是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要我们做太多的配置。直观、集中和自动化地管理项目的第三方库。</p><p>我们都有这样的经历，当添加第三方库的时候，需要导入一堆相关依赖库。当需要更新某个第三方库的时候，又需要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。</p><p>使用CocoaPods管理第三方库后，只需要相当少的配置，就可将第三方库集成到工程中，其它的一切都交由CocoaPods来管理即可，我们使用起来就更省心了。</p><h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>1.首先更新gem到最新版本，在终端中输入：sudo gem update –system更新gem</p><blockquote><p>Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 <a href="http://rubygems.org/" rel="external nofollow noopener noreferrer" target="_blank">http://rubygems.org/</a> ）源来查找、安装、升级和卸载软件包，非常的便捷。</p></blockquote><p>2.删除自带的ruby镜像，终端输入：<code>gem sources --remove https://rubygems.org/</code>。 </p><p>3.添加淘宝的镜像，终端输入：<code>gem sources -a https://gems.ruby-china.org/</code>(原来的淘宝镜像 <a href="https://ruby.taobao.org/已经不能用了)。" rel="external nofollow noopener noreferrer" target="_blank">https://ruby.taobao.org/已经不能用了)。</a> </p><p>4.可以用<code>gem sources -l</code>来检查使用替换镜像位置成功，结果应该只有 <code>https://gems.ruby-china.org/</code> 才对。</p><p>5.安装CocoaPods，终端输入：sudo gem install cocoapods。 </p><blockquote><p>如果提示Operation not permitted，执行sudo gem install -n /usr/local/bin cocoapods命令安装，原因请参考<a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">系统集成保护</a>。</p></blockquote><p>6.然后配置下CocoaPods，终端输入：pod setup。</p><p>到这里CocoaPods就安装好了。</p><h2 id="查找第三方库"><a href="#查找第三方库" class="headerlink" title="查找第三方库"></a>查找第三方库</h2><p>比如查找MJExtension，终端输入：<code>pod search MJExtension</code>，第一次搜索他需要建索引，等待一会儿就可以了。</p><p>输出结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-&gt; MJExtension (<span class="number">3.0</span><span class="meta">.13</span>)</span><br><span class="line">   A fast <span class="keyword">and</span> convenient conversion between JSON <span class="keyword">and</span> model</span><br><span class="line">   pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line">   - Homepage: https://github.com/CoderMJLee/MJExtension</span><br><span class="line">   - Source:   https://github.com/CoderMJLee/MJExtension.git</span><br><span class="line">   - Versions: <span class="number">3.0</span><span class="meta">.13</span>, <span class="number">3.0</span><span class="meta">.12</span>, <span class="number">3.0</span><span class="meta">.11</span>, <span class="number">3.0</span><span class="meta">.10</span>, <span class="number">3.0</span><span class="meta">.9</span>, <span class="number">3.0</span><span class="meta">.8</span>, <span class="number">3.0</span><span class="meta">.7</span>, <span class="number">3.0</span><span class="meta">.6</span>,</span><br><span class="line">   <span class="number">3.0</span><span class="meta">.5</span>, <span class="number">3.0</span><span class="meta">.4</span>, <span class="number">3.0</span><span class="meta">.3</span>, <span class="number">3.0</span><span class="meta">.2</span>, <span class="number">3.0</span><span class="meta">.0</span>, <span class="number">2.5</span><span class="meta">.16</span>, <span class="number">2.5</span><span class="meta">.15</span>, <span class="number">2.5</span><span class="meta">.14</span>, <span class="number">2.5</span><span class="meta">.13</span>, <span class="number">2.5</span><span class="meta">.12</span>,</span><br><span class="line">   <span class="number">2.5</span><span class="meta">.10</span>, <span class="number">2.5</span><span class="meta">.9</span>, <span class="number">2.5</span><span class="meta">.8</span>, <span class="number">2.5</span><span class="meta">.7</span>, <span class="number">2.5</span><span class="meta">.6</span>, <span class="number">2.5</span><span class="meta">.5</span>, <span class="number">2.5</span><span class="meta">.3</span>, <span class="number">2.5</span><span class="meta">.2</span>, <span class="number">2.5</span><span class="meta">.1</span>, <span class="number">2.5</span><span class="meta">.0</span>, <span class="number">2.4</span><span class="meta">.4</span>,</span><br><span class="line">   <span class="number">2.4</span><span class="meta">.2</span>, <span class="number">2.4</span><span class="meta">.1</span>, <span class="number">2.4</span><span class="meta">.0</span>, <span class="number">2.3</span><span class="meta">.8</span>, <span class="number">2.3</span><span class="meta">.7</span>, <span class="number">2.3</span><span class="meta">.6</span>, <span class="number">2.3</span><span class="meta">.5</span>, <span class="number">2.3</span><span class="meta">.4</span>, <span class="number">2.3</span><span class="meta">.3</span>, <span class="number">2.3</span><span class="meta">.2</span>, <span class="number">2.3</span><span class="meta">.1</span>,</span><br><span class="line">   <span class="number">2.3</span><span class="meta">.0</span>, <span class="number">2.2</span><span class="meta">.0</span>, <span class="number">2.1</span><span class="meta">.1</span>, <span class="number">2.1</span><span class="meta">.0</span>, <span class="number">2.0</span><span class="meta">.4</span>, <span class="number">2.0</span><span class="meta">.3</span>, <span class="number">2.0</span><span class="meta">.2</span>, <span class="number">2.0</span><span class="meta">.1</span>, <span class="number">2.0</span><span class="meta">.0</span>, <span class="number">1.2</span><span class="meta">.1</span>, <span class="number">1.2</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">1.1</span><span class="meta">.0</span>, <span class="number">1.0</span><span class="meta">.1</span>, <span class="number">1.0</span><span class="meta">.0</span>, <span class="number">0.3</span><span class="meta">.2</span>, <span class="number">0.3</span><span class="meta">.1</span>, <span class="number">0.3</span><span class="meta">.0</span>, <span class="number">0.2</span><span class="meta">.0</span>, <span class="number">0.1</span><span class="meta">.3</span>, <span class="number">0.1</span><span class="meta">.2</span>, <span class="number">0.1</span><span class="meta">.1</span>, <span class="number">0.1</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">0.0</span><span class="meta">.3</span>, <span class="number">0.0</span><span class="meta">.2</span>, <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br><span class="line"></span><br><span class="line">-&gt; MJExtension_HPTest (<span class="number">0.0</span><span class="meta">.1</span>)</span><br><span class="line">   花圃测试项目</span><br><span class="line">   pod <span class="string">'MJExtension_HPTest'</span>, <span class="string">'~&gt; 0.0.1'</span></span><br><span class="line">   - Homepage: https://github.com/LetMeCrazy/testPods</span><br><span class="line">   - Source:   https://github.com/LetMeCrazy/testPods.git</span><br><span class="line">   - Versions: <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br></pre></td></tr></table></figure><h2 id="引入第三方库到项目中"><a href="#引入第三方库到项目中" class="headerlink" title="引入第三方库到项目中"></a>引入第三方库到项目中</h2><p>我先在桌面上新建一个cocoapodUse项目，然后演示把MJExtension导进去。</p><p>2.然后生成并编辑一个<code>Podfile</code>文件，命令为:</p><p><code>vim Podfile</code></p><p>要导入的第三方都要写在Podfile中。进去后需要先按</p><p><code>I</code> 键进入编辑状态，写完后按<code>esc</code>，然后按<code>shift+zz</code>(或者先按<code>shift+:</code>,再按<code>wq</code>)就可以保存退出了。</p><p>Podfile的格式如下，其中’cocoapodUse’为你的target的名字。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios,<span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'cocoapodUse'</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>3.安装，命令为：</p><p><code>pod install</code></p><p>安装成功之后，第三方库就被包含到项目中了。</p><p>之前我们一直是双击Test.xcodeproj打开项目，以后我们就要双击Test.xcworkspace打开了，可以看到MJExtension已经被引入了。</p><h2 id="项目引入MJExtension"><a href="#项目引入MJExtension" class="headerlink" title="项目引入MJExtension"></a>项目引入MJExtension</h2><p>你会发现当引入MJExtension的头文件时，可以 <code>#import &lt;MJExtension.h&gt;</code>或者<code>#import &lt;MJExtension/MJExtension.h&gt;</code>，但是却不能在输入<code>#import &quot;MJExtension.h&quot;</code>的时候出现提示。虽然强制输入也可以编译通过，但是感觉很不爽。 解决这个问题的办法是在工程的Build Settings搜索Search，然后在User header search paths中添加$(SRCROOT)并选择recursive。</p><p>现在就可以提示#import “MJExtension.h”啦。</p><h2 id="增加新的第三方"><a href="#增加新的第三方" class="headerlink" title="增加新的第三方"></a>增加新的第三方</h2><p>如果使用过程中我还想添加其他的第三方怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。</p><h2 id="更新CocoaPods中的第三方库"><a href="#更新CocoaPods中的第三方库" class="headerlink" title="更新CocoaPods中的第三方库"></a>更新CocoaPods中的第三方库</h2><p>第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。</p><p>如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： pod install –verbose –no-repo-update </p><h2 id="删除CocoaPods中的某些第三方库。"><a href="#删除CocoaPods中的某些第三方库。" class="headerlink" title="删除CocoaPods中的某些第三方库。"></a>删除CocoaPods中的某些第三方库。</h2><p>当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。</p><h2 id="升级CocoaPods"><a href="#升级CocoaPods" class="headerlink" title="升级CocoaPods"></a>升级CocoaPods</h2><p>升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令sudo gem install -n /usr/local/bin cocoapods –pre就可以了。</p><h2 id="卸载CocoaPods"><a href="#卸载CocoaPods" class="headerlink" title="卸载CocoaPods"></a>卸载CocoaPods</h2><p>卸载CocoaPods的命令是sudo gem uninstall cocoapods</p><p>执行完命令后，最下面打印Successfully uninstalled cocoapods字样就代表已经成功卸载了。</p><h2 id="CocoaPods-Mac-App的安装和使用"><a href="#CocoaPods-Mac-App的安装和使用" class="headerlink" title="CocoaPods Mac App的安装和使用"></a>CocoaPods Mac App的安装和使用</h2><p>CocoaPods桌面应用版下载地址：[<a href="https://cocoapods.org/app][1" rel="external nofollow noopener noreferrer" target="_blank">https://cocoapods.org/app][1</a>] 打开应用会提示你是否安装命令行工具，选择install就也可以在命令行使用Pod了。省去了上面的步骤们，方便快捷的使用CocoaPods。</p><p>现在假如要给一个Test项目加入第三方库 1.选择File-New Podfile from Xcode Project，去选择项目的Project文件。</p><p>2.填写自动生成的Podfile，并且安装。</p><p>然后就可以去打开工程了，是不是比命令行简单多了。 </p><blockquote><p>注意：Cocoapods.app 删掉并执行命令可能会报错：Unable to locate the CocoaPods.app application bundle. Please ensure the application is available and launch it at least once<br>这时候只要执行sudo gem install -n /usr/local/bin cocoapods命令就可以了。</p></blockquote><h2 id="CocoaPods官方使用指南"><a href="#CocoaPods官方使用指南" class="headerlink" title="CocoaPods官方使用指南"></a>CocoaPods官方使用指南</h2><p>链接：<a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods 官方使用指南</a>有什么不了解的或者遇到错误可以去这里查看一下。</p><h2 id="XCode的CocoaPods插件"><a href="#XCode的CocoaPods插件" class="headerlink" title="XCode的CocoaPods插件"></a>XCode的CocoaPods插件</h2><p>[CocoaPods-xcode-plugin]是一个XCode的插件，可以很方便的在Xcode通过pods安装各种第三方库。前提是终端已经安装好CocoaPods。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a></li><li><a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">升级 OS X 10.11 cocoapods 使用不正常的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://guides.cocoapods.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods&lt;/a&gt; Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在&lt;a href=&quot;https://www.jianshu.com/p/1711e131987d&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;看一遍就会的CocoaPods的安装和使用教程&lt;/a&gt;的基础上稍微修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>自己搭建博客的经历</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/hexo/%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/wiki/工具/hexo/自己搭建博客的经历/</id>
    <published>2018-02-13T07:33:17.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。</p><a id="more"></a><h2 id="初始化hexo环境"><a href="#初始化hexo环境" class="headerlink" title="初始化hexo环境"></a>初始化hexo环境</h2><ul><li>新建博客的文件夹</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="string">/Desktop/jiangli2017</span> </span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/Desktop/jianli2017</span></span><br></pre></td></tr></table></figure><ul><li>初始化hexo</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><h2 id="Wikitten主题配置"><a href="#Wikitten主题配置" class="headerlink" title="Wikitten主题配置"></a>Wikitten主题配置</h2><p>本博客根据自己的喜好，选择的<a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">Wikitten</a>主题，这个主题类似wiki，具有文章的目录结构。</p><ul><li>进入你的 hexo 站点文件夹，克隆 <code>Wikitten</code> 主题到 <code>themes/</code> 路径下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/jiangli2017 </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten</span><br></pre></td></tr></table></figure><ul><li>覆盖站点目录中一些默认页面模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf themes/Wikitten/_source/* <span class="built_in">source</span>/</span><br><span class="line">cp -rf themes/Wikitten/_scaffolds/* scaffolds/</span><br></pre></td></tr></table></figure><ul><li>重命名主题中的 <code>_config.yml.example</code> 到 <code>_config.yml</code>，然后可以使用配置文件配置主题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml</span><br><span class="line"><span class="comment"># 编辑配置文件，定制你的配置项</span></span><br><span class="line">vim themes/Wikitten/_config.yml</span><br></pre></td></tr></table></figure><p>大部分的配置项都和 <a href="https://github.com/ppoffice/hexo-theme-icarus" rel="external nofollow noopener noreferrer" target="_blank">icarus</a> 主题中的配置项一样，你可以首先去阅读一下 <a href="https://github.com/ppoffice/hexo-theme-icarus/wiki" rel="external nofollow noopener noreferrer" target="_blank">icraus 的文档</a>。</p><ul><li>需要安装的插件写在主题的 <a href="./package.json"><code>package.json</code></a> 文件中</li></ul><p>这里列出了这些插件的功能作用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-autonofollow    // 打开非本站链接时自动开启新标签页</span><br><span class="line">hexo-directory-category // 根据文章文件目录自动为文章添加分类</span><br><span class="line">hexo-generator-feed    // 生成 RSS 源</span><br><span class="line">hexo-generator-json-content// 生成全站文章 json 内容，用于全文搜索</span><br><span class="line">hexo-generator-sitemap// 生成全站站点地图 sitemap</span><br></pre></td></tr></table></figure><p>你可以将这些插件合并到<strong>站点</strong>的 <code>package.json</code> 文件中通过 <code>npm install</code> 一次安装，</p><p>或者在<strong>站点目录</strong>下，你可以通过以下命令安装他们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><p>下面是站点推荐配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yaml</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">wiki/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">Wikitten</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'_posts/**/embed_page/**'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Markdown</span></span><br><span class="line"><span class="comment">## https://github.com/hexojs/hexo-renderer-marked</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line"><span class="attr">  gfm:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### JsonContent</span></span><br><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  pages:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">404.</span><span class="string">html</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">### Creat sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Adds nofollow attribute to all external links in your hexo blog posts automatically.</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&lt;your</span> <span class="string">site</span> <span class="string">url</span> <span class="string">domain&gt;</span> <span class="comment"># eg: zthxxx.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment（发布git）</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 多级目录结构</span></span><br><span class="line"><span class="attr">auto_dir_categorize:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span>  <span class="comment"># options:true, false; default is true</span></span><br><span class="line"><span class="attr">  force:</span> <span class="literal">true</span> <span class="comment"># options:true, false; default is false</span></span><br></pre></td></tr></table></figure><p>多级目录结构可以需要安装插件：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span> hexo-<span class="built_in">directory</span>-category</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>不能发布到git上面</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line"><span class="keyword">ERROR </span>Deployer not found: git</span><br></pre></td></tr></table></figure><p>解决办法：hexo目录下安装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span>  <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><ul><li>hexo d 没有反应</li></ul><p>需要在站点目录下的_config.yml 中添加如下配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><ul><li>图床</li></ul><p>我的博客中用相对目录显示图片，无法显示，需要用图床，我选择的是<a href="https://portal.qiniu.com" rel="external nofollow noopener noreferrer" target="_blank">七牛云</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>Git分支管理(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git分支管理/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h2><p>在[版本回退][1]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。<strong>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-initial.png" alt="git-br-initial"></p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p><p><strong>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</strong></p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-create.png" alt="git-br-create"></p><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-fd.png" alt="git-br-dev-fd"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-ff-merge.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-remove.png" alt="git-br-rm"></p><p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p><p>下面开始实战。</p><p><strong>首先，我们创建dev分支，然后切换到dev分支：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> dev</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* dev</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"branch test"</span></span></span><br><span class="line">[dev fec145a] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-on-master.png" alt="git-br-on-master"></p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge dev</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was fec145a).</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch dev</p><p>切换分支：git checkout </p><p>创建+切换分支：git checkout -b </p><p>合并某分支到当前分支：git merge </p><p>删除分支：git branch -d </p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的feature1分支，继续我们的新分支开发：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> feature1</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">AND</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 75a857c] <span class="keyword">AND</span> simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">1</span> commit.</span><br></pre></td></tr></table></figure><p>在master分支上把readme.txt文件的最后一行改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 400b400] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-feature1.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> feature1</span><br><span class="line"><span class="keyword">Auto</span>-merging readme.txt</span><br><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> readme.txt</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unmerged paths:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> as appropriate to mark resolution)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       both modified:      readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">and</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"conflict fixed"</span></span></span><br><span class="line">[master 59bc1cb] conflict fixed</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-conflict-merged.png" alt="git-br-conflict-merged"></p><p>用带参数的git log也可以看到分支的合并情况：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 75a857c <span class="keyword">AND</span> simple</span><br><span class="line">* | 400b400 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* fec145a branch test</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d feature1</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>feature1 (was <span class="number">75</span>a857c).</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>用git log –graph命令可以看到分支合并图。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working <span class="built_in">directory</span> <span class="keyword">and</span> index state WIP <span class="keyword">on</span> <span class="title">dev</span>: <span class="title">6224937</span> <span class="title">add</span> <span class="title">merge</span></span><br><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">6224937</span> <span class="built_in">add</span> <span class="built_in">merge</span></span><br></pre></td></tr></table></figure><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">6</span> commits.</span><br><span class="line">$ git checkout -b issue<span class="number">-101</span></span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue<span class="number">-101</span> cc17032] fix bug <span class="number">101</span></span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">2</span> commits.</span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff -m "merged bug fix 101" issue-101</span></span><br><span class="line">Merge made <span class="keyword">by</span> <span class="keyword">the</span> <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> <span class="built_in">file</span> changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br><span class="line">$ git branch -d issue<span class="number">-101</span></span><br><span class="line">Deleted branch issue<span class="number">-101</span> (was cc17032).</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">list</span></span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP <span class="keyword">on</span> de<span class="variable">v:</span> <span class="number">6224937</span> <span class="built_in">add</span> merge</span><br></pre></td></tr></table></figure><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><h2 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h2><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用git remote：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> dev</span><br></pre></td></tr></table></figure><ul><li><p>master分支是主分支，因此要时刻与远程同步；</p></li><li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.<span class="string">com:</span>michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">46</span>, done.</span><br><span class="line"><span class="string">remote:</span> Compressing <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">26</span>/<span class="number">26</span>), done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">46</span> (delta <span class="number">16</span>), reused <span class="number">45</span> (delta <span class="number">15</span>)</span><br><span class="line">Receiving <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">46</span><span class="regexp">/46), 15.69 KiB | 6 KiB/</span>s, done.</span><br><span class="line">Resolving <span class="string">deltas:</span> <span class="number">100</span>% (<span class="number">16</span>/<span class="number">16</span>), done.</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add /usr/bin/env"</span></span><br><span class="line">[dev <span class="number">291</span>bea8] <span class="keyword">add</span> /usr/<span class="keyword">bin</span>/env</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">5</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">349</span> <span class="keyword">bytes</span>, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">   fc38031.<span class="number">.291</span>bea8  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.py </span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add coding: utf-8"</span></span><br><span class="line">[dev bd6ae48] <span class="keyword">add</span> coding: utf<span class="number">-8</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-<span class="keyword">fast</span>-forward)</span><br><span class="line"><span class="keyword">error</span>: <span class="keyword">failed</span> <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip <span class="keyword">of</span> your <span class="keyword">current</span> branch <span class="keyword">is</span> behind</span><br><span class="line">hint: its remote counterpart. <span class="keyword">Merge</span> the remote changes (e.g. <span class="string">'git pull'</span>)</span><br><span class="line">hint: <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line"><span class="keyword">From</span> github.com:michaelliao/learngit</span><br><span class="line">   fc38031<span class="built_in">..</span>291bea8  dev        -&gt; origin/dev</span><br><span class="line">There is <span class="literal">no</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">    git pull  </span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="builtin-name">set</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream dev origin/</span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br><span class="line">Branch <span class="built_in">dev</span> <span class="built_in">set</span> up to track remote branch <span class="built_in">dev</span> <span class="keyword">from</span> origin.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">CONFLICT (content): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> hello.py</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"merge &amp; fix hello.py"</span></span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">10</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100%</span> (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">Writing objects: <span class="number">100%</span> (<span class="number">6</span>/<span class="number">6</span>), <span class="number">747</span> bytes, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github<span class="selector-class">.com</span>:michaelliao/learngit.git</span><br><span class="line">   <span class="number">291</span>bea8.<span class="selector-class">.adca45d</span>  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p></li></ol><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  <span class="literal">master</span></span><br><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">6a5819e merged bug fix 101</span><br><span class="line">cc17032 fix bug 101</span><br><span class="line">7825a50 merge with no-ff</span><br><span class="line">6224937 <span class="builtin-name">add</span> merge</span><br><span class="line">59bc1cb conflict fixed</span><br><span class="line">400b400 &amp; simple</span><br><span class="line">75a857c <span class="keyword">AND</span> simple</span><br><span class="line">fec145a branch test</span><br><span class="line">d17efd8 <span class="builtin-name">remove</span> test.txt</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">9</span> <span class="number">6224937</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v0.<span class="number">9</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.9</span></span><br><span class="line"><span class="keyword">commit</span> <span class="number">622493706</span>ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">08</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">merge</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">1</span> -m <span class="string">"version 0.1 released"</span> <span class="number">3628164</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.<span class="number">1</span></span><br><span class="line"><span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">1</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">11</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">version</span> <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">3628164</span>fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Tue Aug <span class="number">20</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">49</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-s</span> v0.<span class="number">2</span> -m <span class="string">"signed version 0.2 released"</span> fec145a</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: signing failed: secret key not available</span><br><span class="line"><span class="keyword">error: </span>gpg failed to sign the data</span><br><span class="line"><span class="keyword">error: </span>unable to sign the tag</span><br></pre></td></tr></table></figure><p>用命令git show 可以看到PGP签名信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.2</span></span><br><span class="line">tag v0<span class="number">.2</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">33</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">signed <span class="keyword">version</span> <span class="number">0.2</span> released</span><br><span class="line"><span class="comment">-----BEGIN PGP SIGNATURE-----</span></span><br><span class="line"><span class="keyword">Version</span>: GnuPG v1<span class="number">.4</span><span class="number">.12</span> (Darwin)</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class="line"><span class="comment">-----END PGP SIGNATURE-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">10</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    branch <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p></li><li><p>git tag -a  -m “blablabla…”可以指定标签信息；</p></li><li><p>git tag -s  -m “blablabla…”可以用PGP签名标签；</p></li><li><p>命令git tag可以查看所有标签。</p></li></ul><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><ul><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git仓库/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。</p><a id="more"></a><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——[码云](<a href="https://gitee.com/）。" rel="external nofollow noopener noreferrer" target="_blank">https://gitee.com/）。</a></p><p>和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p>码云的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-add-ssh-key.jpg" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-key.jpg" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？</p><p>首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-new-repo.jpg" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令git remote add把它和码云的远程库关联：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><blockquote><p>小提示 ： origin 远程仓库也就是url对应的仓库 在本地的别名。</p></blockquote><p>如果在使用命令git remote add时报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，<font color="red">git给远程库起的默认名称是origin</font>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> github git@github.com:michaelliao/learngit.git</span></span><br></pre></td></tr></table></figure><p>接着，再关联码云的远程库：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>github master</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>gitee master</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorymulti-remote.jpg" alt="multi-remote"></p><p>码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。</p><blockquote><p>小贴士 ：git fetch 和git pull的区别</p><ul><li>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支</li><li>pull 若某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支</li></ul></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://git-scm.com/book/zh/v1/Git-基础-远程仓库的使用" rel="external nofollow noopener noreferrer" target="_blank">Git-基础-远程仓库的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>git时光穿梭(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%B7%A5%E4%BD%9C%E5%8C%BA/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git工作区/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><ul><li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li><li>第二步，使用命令git commit，完成。</li></ul><h2 id="工作区的状态"><a href="#工作区的状态" class="headerlink" title="工作区的状态"></a>工作区的状态</h2><ul><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向append GPL：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-head.jpg" alt="git-head"></p><p>改为指向add distributed：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-header-move.jpg" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><ol><li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li><li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li></ol><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-repo.jpg" alt="git-repo"></p><p>分支和HEAD的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br></pre></td></tr></table></figure><p>先用git status查看一下状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       LICENSE</span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   LICENSE</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage.jpg" alt="git-stage"></p><p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master <span class="number">27</span>c9860] understand how stage works</span><br><span class="line"> <span class="number">2</span> files <span class="section">changed</span>, <span class="number">675</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> LICENSE</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage-after-commit.jpg" alt="git-stage-after-commit"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</strong></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span>.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt </span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"git tracks changes"</span></span><br><span class="line">[<span class="keyword">master</span> d4f25b6] git tracks changes</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p><p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme<span class="selector-class">.txt</span> </span><br><span class="line">diff --git a/readme<span class="selector-class">.txt</span> b/readme.txt</span><br><span class="line">index <span class="number">76</span>d770f.<span class="selector-class">.a9c5755</span> <span class="number">100644</span></span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">4</span> @@</span><br><span class="line"> Git is <span class="selector-tag">a</span> distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has <span class="selector-tag">a</span> mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>现在，看看readme.txt的文件内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">add</span> readme.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> readme.txt</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure><p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退][1]一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退][2]一节，不过前提是没有推送到远程库。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add test.txt"</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">94</span>cdc44] <span class="keyword">add</span> test.txt</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm test.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       deleted:    test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line"><span class="keyword">rm</span> '<span class="keyword">test</span>.txt'</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">"remove test.txt"</span></span><br><span class="line">[master d17efd8] remove <span class="keyword">test</span>.txt</span><br><span class="line"> 1 <span class="keyword">file</span> changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
