<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-20T10:29:05.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/set%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/set命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> 1</span><br><span class="line"><span class="built_in">command</span> 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>Every script you write should include set -e at the top. This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit.</p><p>你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。</p><p>Using -e gives you error checking for free. If you forget to check something, bash will do it for you. Unfortunately it means you can’t check $? as bash will never get to the checking code if it isn’t zero. There are other constructs you could use:</p><p>使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span>-ne <span class="number">0</span>]; then </span><br><span class="line">echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi </span><br><span class="line">could be replaced with</span><br></pre></td></tr></table></figure><p>能够被代替为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command || &#123; echo <span class="string">"command failed"</span>; <span class="keyword">exit</span> <span class="number">1</span>; &#125; </span><br><span class="line">or</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> ! command; then</span><br><span class="line"> echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>What if you have a command that returns non-zero or you are not interested in its return value? You can use command || true, or if you have a longer section of code, you can turn off the error checking, but I recommend you use this sparingly.</p><p>如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>组件化-库</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BA%93/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/IOS/库/组件化-库/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20170427/19136.html" rel="external nofollow noopener noreferrer" target="_blank">组件化-动态库实战</a>    </p><p><a href="https://blog.csdn.net/u013604612/article/details/43197465" rel="external nofollow noopener noreferrer" target="_blank">iOS开发——创建你自己的Framework</a>  </p><p><a href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" rel="external nofollow noopener noreferrer" target="_blank">iOS - Umbrella Header在framework中的应用</a></p><p><a href="https://www.jianshu.com/p/48aff237e8ff" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发中的『库』(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170427/19136.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件化-动态库实战&lt;/a&gt;    
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/IOS/%E5%BA%93/"/>
    
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>static关键字作用总结(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97/static/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字/static/</id>
    <published>2018-07-17T10:07:12.000Z</published>
    <updated>2018-07-17T10:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。</p><a id="more"></a><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%c "</span>, a);</span><br><span class="line">     (<span class="keyword">void</span>)msg();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span> Hello</span><br></pre></td></tr></table></figure><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h2 id="内容持久化（static变量中的记忆功能和全局生存期）"><a href="#内容持久化（static变量中的记忆功能和全局生存期）" class="headerlink" title="内容持久化（static变量中的记忆功能和全局生存期）"></a>内容持久化（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><p>程序举例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fun()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>--; <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     printf(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">     <span class="keyword">for</span>(; <span class="keyword">count</span> &lt;= <span class="number">10</span>; ++<span class="keyword">count</span>)</span><br><span class="line">               printf(<span class="string">"%d\t\t%d\n"</span>, <span class="keyword">count</span>, fun());</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">global  local static</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h2 id="默认初始化为0"><a href="#默认初始化为0" class="headerlink" title="默认初始化为0"></a>默认初始化为0</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"integer: %d; string: (begin)%s(end)"</span>, a, str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">integer</span>: <span class="number">0</span>; <span class="keyword">string</span>: (<span class="keyword">begin</span>) (<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h2 id="C-中的类成员声明static"><a href="#C-中的类成员声明static" class="headerlink" title="C++中的类成员声明static"></a>C++中的类成员声明static</h2><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </li><li>不能将静态成员函数定义为虚函数。      </li><li>由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</li><li>由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）</li><li>static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。</li><li>静态数据成员在&lt;定义或说明&gt;时前面加关键字static。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）</li><li><p>静态成员初始化与一般数据成员初始化不同:</p><p> 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；</p><pre><code>所以我们得出静态数据成员初始化的格式：</code></pre><p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p></li><li><p>为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p></li></ol><h2 id="转载地址"><a href="#转载地址" class="headerlink" title="转载地址"></a>转载地址</h2><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" rel="external nofollow noopener noreferrer" target="_blank">C++中static关键字作用总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>explicit实例浅析(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97/explicit-learn/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字/explicit-learn/</id>
    <published>2018-07-16T01:07:12.000Z</published>
    <updated>2018-07-16T03:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。</p><a id="more"></a><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>按默认规定，只用传一个参数的构造函数也定义了一个隐式转换。举个例子：<br>（下面这个CExample没有什么实际的意义，主要是用来说明问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iFirst;</span><br><span class="line"><span class="keyword">int</span> m_iSecond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Example.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StdAfx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line">CExample::CExample(<span class="keyword">void</span>)</span><br><span class="line">: m_iFirst(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::~CExample(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond):m_iFirst(iFirst), m_iSecond(iSecond)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TestExplicitKey.cpp</span></span><br><span class="line">...<span class="comment">//其它头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CExample objOne; <span class="comment">//调用没有参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objTwo</span><span class="params">(<span class="number">12</span>, <span class="number">12</span>)</span></span>; <span class="comment">//调用有两个参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objThree</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">//同上，可以传一个参数是因为该构造函数的第二个参数有默认值</span></span><br><span class="line">CExample objFour = <span class="number">12</span>; <span class="comment">//执行了隐式转换,等价于CExample temp(12);objFour(temp);注意这个地方调用了</span></span><br><span class="line"><span class="comment">//编译器为我们提供的默认复制构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在构造函数声明中加入关键字explicit，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CExample</span><span class="params">(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么CExample objFour = 12; 这条语句将不能通过编译。在vs05下的编译错误提示如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error C2440: <span class="string">'initializing'</span> : cannot convert <span class="keyword">from</span> <span class="string">'int'</span> <span class="keyword">to</span> <span class="string">'CExample'</span></span><br><span class="line">    <span class="function"><span class="keyword">Constructor</span> <span class="title">for</span> <span class="title">class</span> '<span class="title">CExample</span>' <span class="title">is</span> <span class="title">declared</span> '<span class="title">explicit</span>'</span></span><br></pre></td></tr></table></figure><h2 id="explicit意义"><a href="#explicit意义" class="headerlink" title="explicit意义"></a>explicit意义</h2><p>对于某些类型，这一情况非常理想。<font color="blue">但在大部分情况中，隐式转换却容易导致错误（不是语法错误，编译器不会报错）。隐式转换总是在我们没有察觉的情况下悄悄发生，除非有心所为，隐式转换常常是我们所不希望发生的。通过将构造函数声明为explicit（显式）的方式可以抑制隐式转换。也就是说，explicit构造函数必须显式调用。</font><br>引用一下Bjarne Stroustrup的例子:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">String</span>&#123;</span><br><span class="line">   <span class="keyword">explicit</span> <span class="keyword">String</span>(<span class="keyword">int</span> n);</span><br><span class="line">   <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="string">'a'</span>; <span class="comment">//错误：不能做隐式char-&gt;String转换</span></span><br><span class="line"><span class="keyword">String</span> s2(<span class="number">10</span>);  <span class="comment">//可以：调用explicit String(int n);</span></span><br><span class="line"><span class="keyword">String</span> s3 = <span class="keyword">String</span>(<span class="number">10</span>);<span class="comment">//可以：调用explicit String(int n);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s4 = <span class="string">"Brian"</span>; <span class="comment">//可以：隐式转换调用String(const char *p);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s5(<span class="string">"Fawlty"</span>); <span class="comment">//可以：正常调用String(const char *p);</span></span><br><span class="line"><span class="keyword">void</span> f(<span class="keyword">String</span>);</span><br><span class="line"><span class="keyword">String</span> g()</span><br><span class="line">&#123;</span><br><span class="line">  f(<span class="number">10</span>); <span class="comment">//错误：不能做隐式int-&gt;String转换</span></span><br><span class="line">  f(<span class="string">"Arthur"</span>); <span class="comment">//可以：隐式转换，等价于f(String("Arthur"));</span></span><br><span class="line">  <span class="built_in">return</span> <span class="number">10</span>; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际代码中的东西可不像这种故意造出的例子。<br>发生隐式转换，除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。<br>原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。</p><p>原文链接：<a href="http://blog.csdn.net/chollima/article/details/3486230" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chollima/article/details/3486230</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
      <category term="explicit" scheme="http://yoursite.com/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十五章 面向对象程序设计/面向对象程序设计/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-19T10:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有虚函数、访问控制等内容</p><a id="more"></a><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>静态类型和动态类型</p><ol><li>通过使用数据抽象，可以将类的接口和实现分离</li><li>使用继承可以定义相似类型并对相似类型建模</li><li>使用动态绑定，可以忽略相似类型的区别，而用统一的方式使用对象</li></ol><p>当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。</p><ol><li>成员函数如果没用被声明为虚函数，解析过程发生在编译时候</li><li>成员函数声明为虚函数，根据调用指针在运行的时候确定调用的版本。</li></ol><p>派生类显示的著名他使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字。</p><p>回避虚函数使用：在函数名前加作用域运算符。</p><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ol><li>protected用来声明希望与派生类共享、但不被共有访问的成员。</li><li>派生类成员和友元只能通过派生类对象访问基类的受保护的成员。</li><li>protected成员对于派生类和友元来说可以访问。</li><li>protected对于类的用户来说不可访问。</li></ol><p>某个类对其继承而来的成员的访问权限收到两个因素的影响：</p><ol><li>基类中该成员的访问说明符</li><li>派生列表中派生访问说明符</li></ol><p>爸爸受保护的属性，儿子的小三（友元）想通过儿子窃取，不行（友元不能传递）</p><p>爸爸受保护的属性，爸爸的小三想通过儿子获取，可以（谁的小三就能获取到谁的保护属性，小三具有破坏性）</p><p>派生类的作用域位于基类的作用域内</p><ol><li>class的访问说明符、派生访问说明符默认都是private</li><li>struct的访问说明符、派生访问说明符默认都是public的</li></ol><p>两个角度理解访问控制：</p><ol><li>普通用户</li><li>实现者</li></ol><p>派生类的成员隐藏同名的基类成员。</p><p>使用作用域运算符来使用一个被隐藏的基类成员</p><p>除了覆盖继承而来的虚函数，派生类最好不用重新定义其他在基类中名字</p><p>函数调用解析过程</p><p>假如我们调用p-&gt;mem()，</p><ol><li>确定p的静态类型</li><li>在静态类型对应的类中找mem</li><li>找到后判断是否虚函数，是产生虚函数调用版本、不是编译器产生常规调用版本。</li></ol><p>名字查找先于类型检测</p><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>析构函数定义成虚函数，确保删除指针能执行正确的版本。</p><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有虚函数、访问控制等内容&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十五章 面向对象程序设计" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象程序设计" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>拷贝控制</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Premer/第十三章/拷贝控制/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-13T11:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们将学到：拷贝、赋值、移动、销毁做什么？</p><ol><li>拷贝构造函数  </li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li><li>析构函数</li></ol><p>函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。</p><p>如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。</p><a id="more"></a><h2 id="拷贝、赋值、销毁"><a href="#拷贝、赋值、销毁" class="headerlink" title="拷贝、赋值、销毁"></a>拷贝、赋值、销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   plublic:</span><br><span class="line">   Foo(canst Foo&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h4><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。</p><p>合成拷贝构造函数如何拷贝：</p><ol><li>类类型：使用其拷贝构造函数来拷贝</li><li>内置类型：直接拷贝</li><li>数组：逐个拷贝数组成员</li></ol><p>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig):</span><br><span class="line"><span class="function"><span class="title">bookNO</span><span class="params">(orig.bookNO)</span></span>,</span><br><span class="line"><span class="function"><span class="title">units_sold</span><span class="params">(orig.units_sold)</span></span>,</span><br><span class="line"><span class="function"><span class="title">revenue</span><span class="params">(orig.revenue)</span></span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><ol><li>直接初始化：我们实际上要求编译器用普通的函数匹配类选择与我们提供的参数最匹配的构造函数</li><li>拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。</li></ol><p>拷贝初始化发生的场景：</p><ol><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li><li>insert 、push（emplace 直接初始化）</li></ol><h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>当一个函数具有非引用类型的返回值类型时，返回值会被用来初始化调用方的结果</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。<br>如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;);</span><br></pre></td></tr></table></figure></p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">booNO = rhs.bookNO;</span><br><span class="line">units_sold = rhs.units_sold;</span><br><span class="line">revenue = rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>构造函数初始化对象的非static数据成员。</li><li>析构函数释放对象使用的资源，并销毁对象的非静态成员。</li></ol><p>析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">~Foo()</span>;</span><br></pre></td></tr></table></figure></p><ol><li>在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。</li><li>在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。</li></ol><p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。</p><p>什么时候会调用析构函数：</p><ol><li>变量在离开其作用域时</li><li>对象被销毁，其成员被销毁</li><li>容器被销毁，其成员被销毁</li><li>动态分配的对象，delete 运算符时会被销毁</li><li>对于临时对象，当创建他的完整表达式结束时被销毁</li></ol><p><font color="red">析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的</font></p><h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><p>需要析构函数的类也需要拷贝和赋值。<br>需要拷贝操作的类也需要赋值操作。</p><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。</p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。<br>删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。</p><p>=default 、=delete区别：</p><ol><li>=delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。</li><li>可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。</li></ol><p>析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。</p><p>对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。</p><p>合成的拷贝成员可能是删除的：如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。</p><p>对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，次运算符视图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。</p><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>管理类外资源的类必须定义拷贝控制函数。</p><ol><li>类值拷贝</li><li>类指针拷贝</li></ol><p>赋值运算符通常组合了析构函数和构造函数的操作。类型析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">//拷贝底层String</span></span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">//是否旧内存</span></span><br><span class="line">ps = newp;</span><br><span class="line">i=rhs.i;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它吱声，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</p><p>引用计数的工作方式：</p><ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li><li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。</li><li>析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将学到：拷贝、赋值、移动、销毁做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拷贝构造函数  &lt;/li&gt;
&lt;li&gt;拷贝赋值运算符&lt;/li&gt;
&lt;li&gt;移动构造函数&lt;/li&gt;
&lt;li&gt;移动赋值运算符&lt;/li&gt;
&lt;li&gt;析构函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么&lt;br&gt;运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。&lt;/p&gt;
&lt;p&gt;如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Premer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/"/>
    
      <category term="第十三章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Premer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    
    
      <category term="拷贝控制" scheme="http://yoursite.com/tags/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>为什么`forward_list`不支持`push_back`操作？</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/forward_list%E4%B8%8D%E6%94%AF%E6%8C%81push_back%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/forward_list不支持push_back操作/</id>
    <published>2018-06-27T02:07:12.000Z</published>
    <updated>2018-06-27T02:40:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么forward-list不支持push-back操作？"><a href="#为什么forward-list不支持push-back操作？" class="headerlink" title="为什么forward_list不支持push_back操作？"></a>为什么forward_list不支持push_back操作？</h2><p>由于forward_list是单向链表，所以我们如果想要访问尾元素，都要从首元素开始跌代，算法复杂度为O(n)。而对于list为双向链表，直接通过尾指针可以访问尾元素，实现在尾元素添加元素，函数复杂度为O(1)，而vector，string,deque,也可以通过尾指针来添加元素，函数复杂度为O(1)。</p><p>同样的原因也有forward_list不支持pop_back。<br>由于类似原因(算法的复杂度)，有vector，string，不支持push_front，pop_front，但是通过insert，和erase操作仍然可以完成添加/删除首元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么forward-list不支持push-back操作？&quot;&gt;&lt;a href=&quot;#为什么forward-list不支持push-back操作？&quot; class=&quot;headerlink&quot; title=&quot;为什么forward_list不支持push_back操作？&quot;&gt;
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="forward_list" scheme="http://yoursite.com/tags/forward-list/"/>
    
  </entry>
  
  <entry>
    <title>容器基本操作</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/%E5%AE%B9%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/容器基本操作/</id>
    <published>2018-06-26T08:07:12.000Z</published>
    <updated>2018-06-26T08:19:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文列举C++中容器的通用操作。来源于C++ primer</p><a id="more"></a><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td><font color="blue"><strong>类型别名</strong></font></td><td></td></tr><tr><td>iterator</td><td>容器的迭代器类型</td></tr><tr><td>const_iterator</td><td>可以读取元素，但不能修改元素的迭代器类型</td></tr><tr><td>size_type</td><td>无符号整数类型，足够保存此种容器类型最大可能大小</td></tr><tr><td>difference_type</td><td>带符号整数类型，足够保存两个迭代器之间的距离</td></tr><tr><td>value_type</td><td>元素类型</td></tr><tr><td>reference</td><td>元素的左值类型，与value_type&amp;含义相同</td></tr><tr><td>const_reference</td><td>元素的const左值类型(const value_type &amp;)</td></tr><tr><td><font color="blue"><strong>构造函数</strong></font></td><td></td></tr><tr><td>C c;</td><td>默认构造函数，构造空的容器</td></tr><tr><td>C c1(c2)</td><td>构造出c2的拷贝c1</td></tr><tr><td>C c(b,e)</td><td>构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持）</td></tr><tr><td>C c{a,b,c …}</td><td>列表初始化</td></tr><tr><td><font color="blue"><strong>赋值与swap</strong></font></td><td></td></tr><tr><td>c1= c2</td><td>将c1中的元素地换为c2中的元素</td></tr><tr><td>c1 = {a,b,c …}</td><td>将c1中的元素退换为列表中的元素（array不适用）</td></tr><tr><td>a.swap(b)</td><td>交换a和b的元素</td></tr><tr><td>swap(a,b)</td><td>与a.swap(b)等价</td></tr><tr><td><font color="blue"><strong>大小</strong></font></td><td></td></tr><tr><td>c.size()</td><td>c中元素的书面（forward_list不支持）</td></tr><tr><td>c.max_size()</td><td>c可保存的最大元素数目</td></tr><tr><td>c.empty()</td><td>c中存储了元素，返回false，否则返回true</td></tr><tr><td><font color="blue"><strong>添加删除元素（不使用array）</strong></font></td><td>在不同的容器中，这些操作的接口都不同</td></tr><tr><td>c.insert(args)</td><td>将args中的元素拷贝进c</td></tr><tr><td>c.emplace(inits)</td><td>使用inits构造c中的一个元素</td></tr><tr><td>c.erase(args)</td><td>删除args指定的元素</td></tr><tr><td>c.clear()</td><td>删除c中的所有元素，返回void</td></tr><tr><td><font color="blue"><strong>关系运算符</strong></font></td><td></td></tr><tr><td>==， !=</td><td>所有容器都支持相等（不等于）运算符</td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>无序关联容器不支持</td></tr><tr><td><font color="blue"><strong>获取迭代器</strong></font></td><td></td></tr><tr><td>c.begin(), c.end()</td><td>返回指向c的首元素和尾元素之后位置的迭代器</td></tr><tr><td>c.cbegin(),c.cend()</td><td>返回const_iterator</td></tr><tr><td><font color="blue"><strong>反向容器的额外成员（不支持forward_list）</strong></font></td><td></td></tr><tr><td>reverse_iterator</td><td>逆序寻址元素的迭代器</td></tr><tr><td><code>const_reverse_iterator</code></td><td>不修改元素的逆序迭代器</td></tr><tr><td>c.rbegin(),c.rend()</td><td>返回指向c的尾元素和首元素之前位置的迭代器</td></tr><tr><td>c.crbegin(),c.crend</td><td>返回<code>const_reverse_iterator</code></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文列举C++中容器的通用操作。来源于C++ primer&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="容器操作" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++标准库中的list的实现原理</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/list/C++%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E7%9A%84list%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/C++语言/container/list/C++标准库中的list的实现原理/</id>
    <published>2018-06-26T07:07:12.000Z</published>
    <updated>2018-06-26T07:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/loveyou11111111/article/details/49763197" rel="external nofollow noopener noreferrer" target="_blank">C++标准库中的list的实现原理</a></p><a id="more"></a><p>在C++中采用了大量的标志模板库（STL）实现程序的设计，这种设计方式使得不同类型的对象都能通用，而不再是C语言中的通常对于不同的类型需要重新设计或者或者比较采用间接的指针操作。C++中的这种方式简化了写代码的复杂度，但是增加了编译器的复杂度和难度。</p><p>在数据结构中链表是比较基本的类型，在C++中链表是基于模板的类，因此在实际的使用过程中需要涉及到实际的类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lint;</span><br></pre></td></tr></table></figure><p>在C++中关于list的接口比较丰富，主要是关于大小，数据的插入、删除等。但是在C++中引入了迭代器的概念，这个迭代器是关于关于容器中比较重要的一部分，因为这种迭代器使得算法等问题与容器独立开来，迭代器实质上还是指针，准确的将是一个封装了指针的类。</p><p>迭代器类的创建应该包含下面的操作，首先应该支持的操作符至少包括如下（operator*()，operator++()，operator++(int)，operator==()， operator!=()）,当然也会存在const_iterator这样的常迭代器，也就是只允许访问，不能修改对象的迭代器，当然存在迭代器的构造函数、复制控制函数，这些函数都是必须要存在的，因为设计到了指针的操作问题，构造函数应该存在参数是链表节点指针的定义，只有存在这个定义才能间接的访问节点对象。<br>当然在类中至少存在返回迭代器的begin()和end()函数，这两个函数返回的迭代器分别指向链表的开始和链表结束的下一个地址，这是迭代器中经常容易理解错误的地方。</p><p>在C++中通常创建const_iterator类，然后iterator直接继承const_iterator。</p><p>下面说说list类设计的基本思路：<br>首先、创建链表节点对象，实质上是完成对传递进来的类型的封装操作，同时构成一个双向链表的基本要素（prev、next指针）。节点肯定要存在构造函数，而且是直接初始化三个成员变量。<br>其次、创建迭代器类，实质上就是封装一个节点指针，通过节点指针实现操作，至少要实现的操作符已说明。这两个类都要设置List为友元类，因为这样才能用List直接操作迭代器的相关操作。<br>最后、依靠上面的迭代器类和节点类，创建一个List类，该类中主要完成一些基本操作。其中需要注意的就是迭代器的操作，比如删除元素和插入元素以后迭代器的变化问题等。</p><p>需要注意的是在List中采用了哨兵节点，这个哨兵节点并不算实际的操作对象，也就是为了保证肯定有目标所指向，存在一个head对象，这个对象的next就是实际的数据，而tail是迭代器所能到达的最后一个对象，但是这个对象并不是合理的区域，实际上end()实际上就是指向了tail节点，这两个节点head和tail就是哨兵节点。具体的参看代码。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>实现的基本形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __MYLIST_H_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MYLIST_H_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> myspace</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        templateObject&gt;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*封装对象，形成链表节点*/</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                        Object data;</span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span>;</span></span><br><span class="line">                        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*节点构造函数*/</span></span><br><span class="line">                        Node(<span class="keyword">const</span> Object &amp;d = Object(), Node *p = <span class="literal">NULL</span>, Node *n = <span class="literal">NULL</span>)</span><br><span class="line">                        :data(d), prev(p), next(n)&#123;&#125;</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                <span class="comment">/*创建一个常量迭代器类，这是容器设计的关键*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">const_iterator</span></span></span><br><span class="line"><span class="class">                &#123;</span></span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        const_iterator():current(<span class="literal">NULL</span>)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*重载迭代器的值*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object &amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载前向++操作符*/</span></span><br><span class="line">                        const_iterator &amp; <span class="keyword">operator</span>++ ()</span><br><span class="line">                        &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*重载后向++操作符，因为是一个局部对象不能返回引用*/</span></span><br><span class="line">                        const_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                const_iterator old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*判断迭代器是否相同，实质上就是判断指向的节点是否相同*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> const_iterator &amp;rhs) <span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> current == rhs.current;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*调用==操作符*/</span></span><br><span class="line">                        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> const_iterator &amp;rhs)<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> (!(*<span class="keyword">this</span> == rhs));</span><br><span class="line">                        &#125;</span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*迭代器实质就是一个节点指针*/</span></span><br><span class="line">                        Node *current;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*获得链表中的内容*/</span></span><br><span class="line">                        <span class="function">Object &amp; <span class="title">retrieve</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">                        </span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> current-&gt;data;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于指针参数的迭代器构造函数，保证只有List使用*/</span></span><br><span class="line">                        const_iterator(Node *p):current (p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*友元类，可以调用迭代器的私有成员*/</span></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*一般迭代器，直接继承const_iterator*/</span></span><br><span class="line">                <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> :</span> <span class="keyword">public</span> const_iterator</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">public</span>:</span><br><span class="line">                        iterator():const_iterator()</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*得到对象的值*/</span></span><br><span class="line">                        Object &amp;<span class="keyword">operator</span>*()</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> retrieve();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*基于const的重载*/</span></span><br><span class="line">                        <span class="keyword">const</span> Object&amp; <span class="keyword">operator</span>*()<span class="keyword">const</span></span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="keyword">return</span> const_iterator::<span class="keyword">operator</span>*();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*前向++操作符*/</span></span><br><span class="line">                        iterator &amp;<span class="keyword">operator</span>++()</span><br><span class="line">                       &#123;</span><br><span class="line">                                current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">/*后向++操作符*/</span></span><br><span class="line">                        iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                iterator *old = *<span class="keyword">this</span>;</span><br><span class="line">                                ++(*<span class="keyword">this</span>);</span><br><span class="line">                                <span class="keyword">return</span> old;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span>:</span><br><span class="line">                        <span class="comment">/*基于节点的迭代器构造函数*/</span></span><br><span class="line">                        iterator(Node *p):const_iterator(p)</span><br><span class="line">                        &#123;&#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Object&gt;;</span></span><br><span class="line">                &#125;;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">                List()</span><br><span class="line">                &#123;</span><br><span class="line">                        init();</span><br><span class="line">                &#125;</span><br><span class="line">                ~List()</span><br><span class="line">                &#123;</span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="keyword">delete</span> head;</span><br><span class="line">                        <span class="keyword">delete</span> tail;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                       <span class="comment">/*创建哨兵节点*/</span></span><br><span class="line">                        init();</span><br><span class="line">                        <span class="comment">/*复制数据*/</span></span><br><span class="line">                        *<span class="keyword">this</span> = rhs;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">const</span> List &amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> List &amp;rhs)</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;rhs)</span><br><span class="line">                                <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                        <span class="comment">/*清除原有的信息*/</span></span><br><span class="line">                        clear();</span><br><span class="line">                        <span class="comment">/*添加新的对象*/</span></span><br><span class="line">                        <span class="keyword">for</span>(const_iterator itr = rhs.begin(); itr != rhs.end(); ++ itr)</span><br><span class="line">                                push_back(*itr);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到迭代器，实质上就是得到节点指针*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*iterator()是构造函数*/</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(head-&gt;next);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">               </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">const_iterator <span class="title">end</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> const_iterator(tail);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> theSize;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span>( !empty())</span><br><span class="line">                                pop_front();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*得到第一个元素*/</span></span><br><span class="line">                <span class="function">Object &amp; <span class="title">front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*采用了迭代器begin()*/</span></span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">front</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *begin();</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function">Object &amp;<span class="title">back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*end()指向最后一个对象的下一个地址，因此需要--*/</span></span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">const</span> Object &amp;<span class="title">back</span><span class="params">()</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> *--end();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/***********************************************</span></span><br><span class="line"><span class="comment">                *从头插入新的节点，这时候的begin已经不再是begin</span></span><br><span class="line"><span class="comment">                *因此插入操作会导致迭代器出错</span></span><br><span class="line"><span class="comment">                ***********************************************/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(begin(), x);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*从后插入新的节点，这时候会将end后移*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        insert(end(), x);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*从头弹出一个对象*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        erase(begin());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                       erase(--end());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*插入对象，参数是迭代器和数据*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">insert</span><span class="params">(iterator itr, <span class="keyword">const</span> Object &amp;x)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        theSize ++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        *Node *np = Node(x,p-&gt;prev,p);</span></span><br><span class="line"><span class="comment">                        this means that np-&gt;prev = p-&gt;prev,</span></span><br><span class="line"><span class="comment">                        and np-&gt;next = p;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                        update the p-&gt;prev and p-&gt;prev-&gt;next;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev-&gt;next = np;</span></span><br><span class="line"><span class="comment">                        *p-&gt;prev = np;</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">                        <span class="keyword">return</span> iterator(p-&gt;prev=p-&gt;prev-&gt;next= <span class="keyword">new</span> Node(x,p-&gt;prev, p));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器处的对象,因此删除也会导致迭代器破坏*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator itr)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*得到当前迭代器的指针*/</span></span><br><span class="line">                        Node *p = itr.current;</span><br><span class="line">                        <span class="comment">/*得到新的迭代器，并初始化*/</span></span><br><span class="line">                        <span class="function">iterator <span class="title">retVal</span><span class="params">(p-&gt;next)</span></span>;</span><br><span class="line">                        <span class="comment">/*更新链表的链接关系*/</span></span><br><span class="line">                        p-&gt;prev-&gt;next = p-&gt;next;</span><br><span class="line">                        p-&gt;next-&gt;prev = p-&gt;prev;</span><br><span class="line">                        <span class="comment">/*删除对象*/</span></span><br><span class="line">                        <span class="keyword">delete</span> p;</span><br><span class="line">                        <span class="comment">/*使得对象数减少*/</span></span><br><span class="line">                        theSize --;</span><br><span class="line">                        <span class="comment">/*返回新的迭代器*/</span></span><br><span class="line">                        <span class="keyword">return</span> retVal;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*删除迭代器指向的对象*/</span></span><br><span class="line">                <span class="function">iterator <span class="title">erase</span><span class="params">(iterator start, iterator end)</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        <span class="comment">/*for中不使用++itr的原因是erase之后</span></span><br><span class="line"><span class="comment">                         *就是下一个迭代器，因此不需要++操作*/</span></span><br><span class="line">                        <span class="keyword">for</span>(iterator itr = start; itr != end; )</span><br><span class="line">                        &#123;</span><br><span class="line">                                <span class="comment">/*该操作会导致迭代器更新到下一个*/</span></span><br><span class="line">                                itr = erase(itr);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> itr;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span>:</span><br><span class="line">                <span class="comment">/*链表中的数据成员*/</span></span><br><span class="line">                <span class="keyword">int</span> theSize;</span><br><span class="line">                Node *head;</span><br><span class="line">                Node *tail;</span><br><span class="line">                <span class="comment">/*初始化函数*/</span></span><br><span class="line">                <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                        theSize = <span class="number">0</span>;</span><br><span class="line">                        <span class="comment">/*create two sentinel node*/</span></span><br><span class="line">                        <span class="comment">/*构建两个哨兵节点，也就是两个并不算在结构体中的对象*/</span></span><br><span class="line">                        head = <span class="keyword">new</span> Node;</span><br><span class="line">                        tail = <span class="keyword">new</span> Node;</span><br><span class="line">                        <span class="comment">/*绑定起来*/</span></span><br><span class="line">                        head-&gt;next = tail;</span><br><span class="line">                        tail-&gt;prev = head;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/loveyou11111111/article/details/49763197&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;C++标准库中的list的实现原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="list" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/list/"/>
    
    
      <category term="list" scheme="http://yoursite.com/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>deque的实现原理和使用方法详解</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/deque/deque%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/</id>
    <published>2018-06-26T02:07:12.000Z</published>
    <updated>2018-06-26T07:01:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文抄袭至<a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a>。只用于本人学习。</p><a id="more"></a><h2 id="Deque-简介"><a href="#Deque-简介" class="headerlink" title="Deque 简介"></a>Deque 简介</h2><ol><li>deque是“double—ended queue”的缩写，和vector一样都是STL的容器，deque 是双端数组，而 vector 是单端的。</li><li>deque 在接口上和 vector 非常相似，在许多操作的地方可以直接替换。</li><li>deque 可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法，这个等下会详讲）。</li><li>deque 头部和尾部添加或移除元素都非常快速。但是在中间插入元素或移除元素比较费时。</li><li>使用时需要包含头文件 #include<deque> 。</deque></li></ol><h2 id="Deque-实现原理"><a href="#Deque-实现原理" class="headerlink" title="Deque 实现原理"></a>Deque 实现原理</h2><h3 id="deque-的中控器"><a href="#deque-的中控器" class="headerlink" title="deque 的中控器"></a>deque 的中控器</h3><p>deque是连续空间（至少逻辑上看来如此），连续线性空间总令我们联想到array或vector。<strong>array无法成长，vector虽可成长</strong>，却只能向尾端成长，而且其所谓的成长原是个假象，事实上是<font color="blue"><strong>（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。</strong></font>如果不是vector每次配置新空间时都有留下一些余裕，其成长假象所带来的代价将是相当高昂。</p><font color="blue"><strong>deque系由一段一段的定量连续空间构成。</strong></font>一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。<br><br>受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。<br><br><font color="blue"><strong>deque采用一块所谓的map作为主控</strong>。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，<strong>指向另一段（较大的）连续线性空间，称为缓冲区</strong>。<strong>缓冲区才是deque的储存空间主体</strong>。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。</font><p>deque的整体架构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequeStruct.png" alt="deque的整体架构"></p><h3 id="deque-的迭代器"><a href="#deque-的迭代器" class="headerlink" title="deque 的迭代器"></a>deque 的迭代器</h3><p>让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针，分别为cur, first, last, node。</p><p>指针结构如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/C++/deque/dequePointer.png" alt="指针结构"></p><p>在上面介绍中我们大致了解了deque 的基本概念和实现原理，现在我就开始介绍如何使用 deque。</p><h2 id="deque-使用"><a href="#deque-使用" class="headerlink" title="deque 使用"></a>deque 使用</h2><h3 id="deque-对象的默认构造"><a href="#deque-对象的默认构造" class="headerlink" title="deque 对象的默认构造"></a>deque 对象的默认构造</h3><p>deque 采用模板类实现，deque 对象的默认构造形式：deque<t> dequeT；   </t></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deqInt;            <span class="comment">//一个存放int的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">float</span>&gt; deqFloat;       <span class="comment">//一个存放float的deque容器。  </span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; deqString;     <span class="comment">//一个存放string的deque容器。  </span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>尖括号内还可以设置指针类型或自定义类型。</p><h3 id="deque-元素添加移除操作"><a href="#deque-元素添加移除操作" class="headerlink" title="deque 元素添加移除操作"></a>deque 元素添加移除操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.push_back(elem);       <span class="comment">//在容器尾部添加一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.push_front(elem);     <span class="comment">//在容器头部插入一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_back();           <span class="comment">//删除容器最后一个数据  </span></span><br><span class="line"><span class="built_in">deque</span>.pop_front();          <span class="comment">//删除容器第一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-的数据存取"><a href="#deque-的数据存取" class="headerlink" title="deque 的数据存取"></a>deque 的数据存取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.at(idx);    <span class="comment">//返回索引idx所指的数据，如果idx越界，抛出out_of_range。  </span></span><br><span class="line"><span class="built_in">deque</span>[idx];      <span class="comment">//返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。  </span></span><br><span class="line"><span class="built_in">deque</span>.front();   <span class="comment">//返回第一个数据。  </span></span><br><span class="line"><span class="built_in">deque</span>.back();    <span class="comment">//返回最后一个数据</span></span><br></pre></td></tr></table></figure><h3 id="deque-与迭代器"><a href="#deque-与迭代器" class="headerlink" title="deque 与迭代器"></a>deque 与迭代器</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.begin();  <span class="comment">//返回容器中第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.end();  <span class="comment">//返回容器中最后一个元素之后的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rbegin();  <span class="comment">//返回容器中倒数第一个元素的迭代器。  </span></span><br><span class="line"><span class="built_in">deque</span>.rend();   <span class="comment">//返回容器中倒数最后一个元素之后的迭代器。</span></span><br></pre></td></tr></table></figure><h3 id="deque-对象的带参数构造"><a href="#deque-对象的带参数构造" class="headerlink" title="deque 对象的带参数构造"></a>deque 对象的带参数构造</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>(beg,end);    <span class="comment">//构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>(n,elem);   <span class="comment">//构造函数将n个elem拷贝给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq);  <span class="comment">//拷贝构造函数。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的赋值"><a href="#deque-的赋值" class="headerlink" title="deque 的赋值"></a>deque 的赋值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.assign(beg,end);   <span class="comment">//将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。  </span></span><br><span class="line"><span class="built_in">deque</span>.assign(n,elem);  <span class="comment">//将n个elem拷贝赋值给本身。  </span></span><br><span class="line"><span class="built_in">deque</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">deque</span> &amp;deq); <span class="comment">//重载等号操作符   </span></span><br><span class="line"><span class="built_in">deque</span>.swap(deq);  <span class="comment">// 将deq与本身的元素互换</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD;  </span><br><span class="line">deqIntA.push_back(<span class="number">1</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">3</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">5</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">7</span>);  </span><br><span class="line">deqIntA.push_back(<span class="number">9</span>);  </span><br><span class="line">  </span><br><span class="line">deqIntB.assign(deqIntA.begin(),deqIntA.end());  <span class="comment">// 1 3 5 7 9  </span></span><br><span class="line">      </span><br><span class="line">deqIntC.assign(<span class="number">5</span>,<span class="number">8</span>);        <span class="comment">//8 8 8 8 8  </span></span><br><span class="line">  </span><br><span class="line">deqIntD = deqIntA;      <span class="comment">//1 3 5 7 9  </span></span><br><span class="line">  </span><br><span class="line">deqIntC.swap(deqIntD);      <span class="comment">//互换</span></span><br></pre></td></tr></table></figure><h3 id="deque-的大小"><a href="#deque-的大小" class="headerlink" title="deque 的大小"></a>deque 的大小</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.size();      <span class="comment">//返回容器中元素的个数  </span></span><br><span class="line"><span class="built_in">deque</span>.empty();     <span class="comment">//判断容器是否为空  </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num);   <span class="comment">//重新指定容器的长度为num，若容器变长，则以默认值填充新位置。  </span></span><br><span class="line">                    <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。     </span></span><br><span class="line"><span class="built_in">deque</span>.resize(num, elem);  <span class="comment">//重新指定容器的长度为num，若容器变长，则以elem值填充新位置。  </span></span><br><span class="line">                        <span class="comment">//如果容器变短，则末尾超出容器长度的元素被删除。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的插入"><a href="#deque-的插入" class="headerlink" title="deque 的插入"></a>deque 的插入</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.insert(pos,elem);   <span class="comment">//在pos位置插入一个elem元素的拷贝，返回新数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,n,elem);   <span class="comment">//在pos位置插入n个elem数据，无返回值。  </span></span><br><span class="line"><span class="built_in">deque</span>.insert(pos,beg,end);   <span class="comment">//在pos位置插入[beg,end)区间的数据，无返回值。</span></span><br></pre></td></tr></table></figure><h3 id="deque-的删除"><a href="#deque-的删除" class="headerlink" title="deque 的删除"></a>deque 的删除</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>.clear();  <span class="comment">//移除容器的所有数据  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(beg,end);  <span class="comment">//删除[beg,end)区间的数据，返回下一个数据的位置。  </span></span><br><span class="line"><span class="built_in">deque</span>.erase(pos);    <span class="comment">//删除pos位置的数据，返回下一个数据的位置。</span></span><br></pre></td></tr></table></figure><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> 让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针。<br>在进行迭代器的移动时，需要考虑跨缓冲区的情况。</p><p>重载前加(减)，在实现后加(减)时，调用重载的前加(减)。<br>重载+=,实现+时，直接调用+=,实现-=时，调用+=负数，实现-时，调用-=.<br>//当需要实现新的功能时，最好使用已经重载好的操作，即方便有安全。。。。</p><p>另外，deque在效率上来说是不够vector好的，因此有时候在对deque进行sort的时候，需要先将元素移到vector再进行sort，然后移回来。</p><p>构造函数：根据缓冲区设置大小和元素个数，决定map的大小；给map分配空间，根据缓冲区的个数，分配缓冲区，默认指定一个缓冲区；<br> 设置start和finish迭代器，满足左闭右开的原则。<br> push_back:如果空间满足，直接插入；不满足，调用push_back_aux。<br> push_back_aux:先调用reverse_map_at_back,若符合某种条件，重换一个map；分配空间。<br> reserve_map_at_back:看看map有没有满，满的话，调用reallocate_map。<br> reallocate_map:如果前端或后端pop过多，就会导致大量的空闲空间，如果是这种情况，则不用新分配空间，调整一下start的位置即可；<br> 如果不够，则需要重新申请空间。<br> pop：析构元素，如果是最后一块还需要删除空间。<br> erase：需要判断，前面的元素少还是后面的元素少，移动较少的部分。<br> insert：判断位置，如果为前端或后端直接调用push操作，否则，移动较少的一端。</p><p>deque的构造与内存管理：</p><p>由于deque的设计思想就是由一块块的缓存区连接起来的，因此它的内存管理会比较复杂。插入的时候要考虑是否要跳转缓存区、是否要新建map节点（和vector一样，其实是重新分配一块空间给map，删除原来空间）、插入后元素是前面元素向前移动还是后面元素向后面移动（谁小移动谁）。而在删除元素的时候，考虑是将前面元素后移覆盖需要移除元素的地方还是后面元素前移覆盖（谁小移动谁）。移动完以后要析构冗余的元素，释放冗余的缓存区。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//   deque的特性:  </span></span><br><span class="line"><span class="regexp">//</span>   对于任何一个迭代器i  </span><br><span class="line"><span class="regexp">//     i.node是map array中的某元素的地址. i.node的内容是一个指向某个结点的头的指针  </span></span><br><span class="line"><span class="regexp">//</span>     i.first == *(i.node)  </span><br><span class="line"><span class="regexp">//     i.last  == i.first + node_size  </span></span><br><span class="line"><span class="regexp">//</span>     i.cur是一个指向[i.first, i.last)之间的指针  </span><br><span class="line"><span class="regexp">//       注意: 这意味着i.cur永远是一个可以解引用的指针,  </span></span><br><span class="line"><span class="regexp">//</span>            即使其是一个指向结尾后元素的迭代器  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   起点和终点总是非奇异(nonsingular)的迭代器.  </span><br><span class="line"><span class="regexp">//     注意: 这意味着空deque一定有一个node, 而一个具有N个元素的deque  </span></span><br><span class="line"><span class="regexp">//</span>          (N是Buffer Size)一定有有两个nodes  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   对于除了start.node和finish.node之外的每一个node, 每一个node中的元素  </span><br><span class="line"><span class="regexp">//   都是一个初始化过的对象. 如果start.node == finish.node,  </span></span><br><span class="line"><span class="regexp">//</span>   那么[start.cur, finish.cur)都是未初始化的空间.  </span><br><span class="line"><span class="regexp">//   否则, [start.cur, start.last)和[finish.first, finish.cur)都是初始化的对象,  </span></span><br><span class="line"><span class="regexp">//</span>   而[start.first, start.cur)和[finish.cur, finish.last)是未初始化的空间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>   [map, map + map_size)是一个合法的非空区间  </span><br><span class="line"><span class="regexp">//   [start.node, finish.node]是内含在[map, map + map_size)区间的合法区间  </span></span><br><span class="line"><span class="regexp">//</span>   一个在[map, map + map_size)区间内的指针指向一个分配过的node,  </span><br><span class="line"><span class="regexp">//   当且仅当此指针在[start.node, finish.node]区间内  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">inline size_t __deque_buf_size(size_t n, size_t sz)    </span></span><br><span class="line"><span class="regexp">&#123;    </span></span><br><span class="line"><span class="regexp">  return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1));    </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> __deque_iterator的数据结构  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Ref</span>, <span class="title">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;  </span></span><br><span class="line">struct __deque_iterator  </span><br><span class="line">&#123;  </span><br><span class="line">    typedef __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;  </span><br><span class="line">    typedef __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;  </span><br><span class="line">    static size_t buffer_size() &#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, sizeof(T)); &#125;  </span><br><span class="line">  </span><br><span class="line">    typedef random_access_iterator_tag iterator_category;  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef Ptr pointer;  </span><br><span class="line">    typedef Ref reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">    typedef T** map_pointer;  </span><br><span class="line">  </span><br><span class="line">    typedef __deque_iterator self;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 保持与容器的联结  </span></span><br><span class="line"><span class="regexp">    T* cur;       //</span> 此迭代器所指之缓冲区中的现行元素  </span><br><span class="line">    T* first;     <span class="regexp">// 此迭代器所指之缓冲区的头  </span></span><br><span class="line"><span class="regexp">    T* last;      //</span> 此迭代器所指之缓冲区的尾（含备用空间）  </span><br><span class="line">    map_pointer node;    <span class="regexp">// 指向管控中心  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 这个是deque内存管理的关键, 其模型如下  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------  </span><br><span class="line"><span class="regexp">// map--&gt;|   |   |   |   |   |   | ..... |   |   |   |&lt;------------------  </span></span><br><span class="line"><span class="regexp">//</span>       ---------------------------------------------                  |  </span><br><span class="line"><span class="regexp">//             |                                                        |  </span></span><br><span class="line"><span class="regexp">//</span>             |                                                        |  </span><br><span class="line"><span class="regexp">//             |   node                                                 |  </span></span><br><span class="line"><span class="regexp">//</span>             |   缓冲区buffer, 这里实际存储元素                          |  </span><br><span class="line"><span class="regexp">//             |   ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>             -<span class="function">--&gt;</span>|   |   |   |   |   |   | ..... |   |   | X |        |  </span><br><span class="line"><span class="regexp">//                 ---------------------------------------------        |  </span></span><br><span class="line"><span class="regexp">//</span>                   ↑       ↑                             ↑            |  </span><br><span class="line"><span class="regexp">//             ------        |                             |            |  </span></span><br><span class="line"><span class="regexp">//</span>             |             |                             |            |  </span><br><span class="line"><span class="regexp">//             |   -----------   ---------------------------            |  </span></span><br><span class="line"><span class="regexp">//</span>             ----|-----        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>                 |    |        |                                      |  </span><br><span class="line"><span class="regexp">//                 |    |        |                                      |  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------                             |  </span><br><span class="line"><span class="regexp">//              | cur | first | end | map |------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>              ---------------------------  </span><br><span class="line"><span class="regexp">//              迭代器, 其内部维护着一个缓冲区状态  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(T* x, map_pointer y)  </span></span><br><span class="line"><span class="regexp">        : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator() : cur(0), first(0), last(0), node(0) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">    __deque_iterator(const iterator&amp; x)  </span></span><br><span class="line"><span class="regexp">        : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference operator*() const &#123; return *cur; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 判断两个迭代器间的距离  </span><br><span class="line">    difference_type operator-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> difference_type(buffer_size()) * (node - x.node - <span class="number">1</span>) +  </span><br><span class="line">            (cur - first) + (x.last - x.cur);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 下面重载的这些运算符是让deque从外界看上去维护的是一段连续空间的关键!!!  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 前缀自增  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 如果当前迭代器指向元素是当前缓冲区的最后一个元素,  </span></span><br><span class="line"><span class="regexp">//</span> 则将迭代器状态调整为下一个缓冲区的第一个元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 不是当前缓冲区最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first          cur                     end  </span><br><span class="line"><span class="regexp">// ↓               ↓                       ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first              cur                 end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                   ↓                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 当前元素为当前缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 执行前缀自增前的状态  </span></span><br><span class="line"><span class="regexp">//</span> first                              cur end  </span><br><span class="line"><span class="regexp">// ↓                                   ↓   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 当前缓冲区  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 执行完成后的状态  </span><br><span class="line"><span class="regexp">// first                                  end  </span></span><br><span class="line"><span class="regexp">//</span> ↓                                       ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   | ..... |   |   | X | &lt;----- 下一缓冲区  </span><br><span class="line"><span class="regexp">// ---------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> ↑  </span><br><span class="line"><span class="regexp">// cur  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">    self&amp; operator++()  </span><br><span class="line">    &#123;  </span><br><span class="line">        ++cur;    <span class="regexp">// 切换至下一个元素  </span></span><br><span class="line"><span class="regexp">        if (cur == last)    //</span> 如果已达到缓冲区的尾端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node + <span class="number">1</span>);    <span class="regexp">// 就切换至下一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = first;           //</span> 的第一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 后缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增  </span><br><span class="line">    self operator++(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        ++*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 前缀自减, 处理方式类似于前缀自增  </span></span><br><span class="line"><span class="regexp">    //</span> 如果当前迭代器指向元素是当前缓冲区的第一个元素  </span><br><span class="line">    <span class="regexp">// 则将迭代器状态调整为前一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    self&amp; operator--()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (cur == first)    //</span> 如果已达到缓冲区的头端  </span><br><span class="line">        &#123;  </span><br><span class="line">            set_node(node - <span class="number">1</span>);    <span class="regexp">// 就切换至前一节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            cur = last;            //</span> 的最后一个元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        --cur;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator--(int)  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        --*<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 将迭代器向前移动n个元素, n可以为负  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                     operator+=(difference_type n)  </span><br><span class="line"><span class="regexp">//                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span>                      offset = n + (cur - first)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------- offset &gt; <span class="number">0</span> ? &amp;&amp;  </span><br><span class="line"><span class="regexp">//                                   |           移动后是否超出当前缓冲区?  </span></span><br><span class="line"><span class="regexp">//</span>               ----------------------------  </span><br><span class="line"><span class="regexp">//           No  |                          |  Yes  </span></span><br><span class="line"><span class="regexp">//</span>               |                          |  </span><br><span class="line"><span class="regexp">//               ↓                          |---------- offset &gt; 0?  </span></span><br><span class="line"><span class="regexp">//</span>           cur += n;                      |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                          Yes |                          | No  </span><br><span class="line"><span class="regexp">//                              |                          |  </span></span><br><span class="line"><span class="regexp">//</span>                              ↓                          |  </span><br><span class="line"><span class="regexp">//                   计算要向后移动多少个缓冲区                |  </span></span><br><span class="line"><span class="regexp">//</span>                   node_offset =                         |  </span><br><span class="line"><span class="regexp">//                   offset / difference_type              |  </span></span><br><span class="line"><span class="regexp">//</span>                   (buffer_size());                      ↓  </span><br><span class="line"><span class="regexp">//                              |           计算要向前移动多少个缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              |           node_offset = -difference_type  </span><br><span class="line"><span class="regexp">//                              |           ((-offset - 1) / buffer_size()) - 1;  </span></span><br><span class="line"><span class="regexp">//</span>                              |                          |  </span><br><span class="line"><span class="regexp">//                              ----------------------------  </span></span><br><span class="line"><span class="regexp">//</span>                                           |  </span><br><span class="line"><span class="regexp">//                                           |  </span></span><br><span class="line"><span class="regexp">//</span>                                           ↓  </span><br><span class="line"><span class="regexp">//                                       调整缓冲区  </span></span><br><span class="line"><span class="regexp">//</span>                              set_node(node + node_offset);  </span><br><span class="line"><span class="regexp">//                                    计算并调整cur指针  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">    //</span> 以下实现随机存取。迭代器可以直接跳跃n个距离  </span><br><span class="line">    self&amp; operator+=(difference_type n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type offset = n + (cur - first);  </span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; difference_type(buffer_size()))  </span><br><span class="line">            cur += n;        <span class="regexp">// 目标位置在同一缓冲区内  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">        &#123;           //</span> 目标位置不在同一缓冲区内  </span><br><span class="line">            difference_type node_offset =  </span><br><span class="line">                offset &gt; <span class="number">0</span> ? offset / difference_type(buffer_size())  </span><br><span class="line">                : -difference_type((-offset - <span class="number">1</span>) / buffer_size()) - <span class="number">1</span>;  </span><br><span class="line">            <span class="regexp">// 切换至正确的节点（亦即缓冲区）  </span></span><br><span class="line"><span class="regexp">            set_node(node + node_offset);  </span></span><br><span class="line"><span class="regexp">            //</span> 切换至正确的元素  </span><br><span class="line">            cur = first + (offset - node_offset * difference_type(buffer_size()));  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator+(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 这里调用了operator +=()可以自动调整指针状态  </span></span><br><span class="line"><span class="regexp">        return tmp += n;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 将n变为-n就可以使用operator +=()了,  </span><br><span class="line">    self&amp; operator-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;  </span><br><span class="line">  </span><br><span class="line">    self operator-(difference_type n) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        self tmp = *<span class="keyword">this</span>;  </span><br><span class="line">        <span class="keyword">return</span> tmp -= n;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    reference operator[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125;  </span><br><span class="line">  </span><br><span class="line">    bool operator==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;  </span><br><span class="line">    bool operator!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;  </span><br><span class="line">    bool operator&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> set_node(map_pointer new_node)  </span><br><span class="line">    &#123;  </span><br><span class="line">        node = new_node;  </span><br><span class="line">        first = *new_node;  </span><br><span class="line">        last = first + difference_type(buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// deque的数据结构  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt;  </span></span><br><span class="line"><span class="regexp">class deque  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Basic types  </span><br><span class="line">    typedef T value_type;  </span><br><span class="line">    typedef value_type* pointer;  </span><br><span class="line">    typedef value_type&amp; reference;  </span><br><span class="line">    typedef size_t size_type;  </span><br><span class="line">    typedef ptrdiff_t difference_type;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Iterators  </span></span><br><span class="line"><span class="regexp">    typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;       iterator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:                      //</span> Internal typedefs  </span><br><span class="line">  </span><br><span class="line">    typedef pointer* map_pointer;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 这个提供STL标准的allocator接口, 见&lt;stl_alloc.h&gt;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator;  </span></span><br><span class="line"><span class="regexp">    typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 获取缓冲区最大存储元素数量  </span><br><span class="line">    static size_type buffer_size()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> __deque_buf_size(BufSiz, sizeof(value_type));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    static size_type initial_map_size() &#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;  </span><br><span class="line">  </span><br><span class="line">protected:                      <span class="regexp">// Data members  </span></span><br><span class="line"><span class="regexp">    iterator start;               //</span> 起始缓冲区  </span><br><span class="line">    iterator finish;              <span class="regexp">// 最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 指向map, map是一个连续的空间, 其每个元素都是一个指针，指向一个节点（缓冲区）  </span><br><span class="line">    map_pointer map;  </span><br><span class="line">    size_type map_size;   <span class="regexp">// map容量  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:  </span></span><br><span class="line"><span class="regexp">    iterator begin() &#123; return start; &#125;  </span></span><br><span class="line"><span class="regexp">    iterator end() &#123; return finish; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 提供随机访问能力, 其调用的是迭代器重载的operator []  </span><br><span class="line">    <span class="regexp">// 其实际地址需要进行一些列的计算, 效率有损失  </span></span><br><span class="line"><span class="regexp">    reference operator[](size_type n) &#123; return start[difference_type(n)]; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    reference front() &#123; return *start; &#125;  </span></span><br><span class="line"><span class="regexp">    reference back()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        iterator tmp = finish;  </span></span><br><span class="line"><span class="regexp">        --tmp;  </span></span><br><span class="line"><span class="regexp">        return *tmp;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 当前容器拥有的元素个数, 调用迭代器重载的operator -  </span><br><span class="line">    size_type size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> finish - start;; &#125;  </span><br><span class="line">    size_type max_size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_type(-<span class="number">1</span>); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// deque为空的时, 只有一个缓冲区  </span></span><br><span class="line"><span class="regexp">    bool empty() const &#123; return finish == start; &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Constructor, destructor.  </span><br><span class="line">    deque() : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        create_map_and_nodes(<span class="number">0</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(size_type n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    deque(int n, <span class="keyword">const</span> value_type&amp; value)  </span><br><span class="line">        : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fill_initialize(n, value);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    ~deque()  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start, finish);     <span class="regexp">// &lt;stl_construct.h&gt;  </span></span><br><span class="line"><span class="regexp">        destroy_map_and_nodes();  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    deque&amp; operator= (const deque&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 其实我觉得把这个操作放在<span class="keyword">if</span>内效率更高  </span><br><span class="line">        <span class="keyword">const</span> size_type len = size();  </span><br><span class="line">        <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 当前容器比x容器拥有元素多, 析构多余元素  </span></span><br><span class="line"><span class="regexp">            if (len &gt;= x.size())  </span></span><br><span class="line"><span class="regexp">                erase(copy(x.begin(), x.end(), start), finish);  </span></span><br><span class="line"><span class="regexp">            //</span> 将x所有超出部分的元素使用insert()追加进去  </span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">                const_iterator mid = x.begin() + difference_type(len);  </span><br><span class="line">                copy(x.begin(), mid, start);  </span><br><span class="line">                insert(finish, mid, x.end());  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:  </span><br><span class="line">    <span class="literal">void</span> push_back(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 最后缓冲区尚有两个（含）以上的元素备用空间  </span></span><br><span class="line"><span class="regexp">        if (finish.cur != finish.last - 1)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(finish.cur, t);     //</span> 直接在备用空间上构造元素  </span><br><span class="line">            ++finish.cur;     <span class="regexp">// 调整最后缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 容量已满就要新申请内存了  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            push_back_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> push_front(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (start.cur != start.first)      <span class="regexp">// 第一缓冲区尚有备用空间  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            construct(start.cur - 1, t);   //</span> 直接在备用空间上构造元素  </span><br><span class="line">            --start.cur;     <span class="regexp">// 调整第一缓冲区的使用状态  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else    //</span> 第一缓冲区已无备用空间  </span><br><span class="line">            push_front_aux(t);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="literal">void</span> pop_back()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (finish.cur != finish.first)    <span class="regexp">// 最后缓冲区有一个（或更多）元素  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            --finish.cur;    //</span> 调整指针，相当于排除了最后元素  </span><br><span class="line">            destroy(finish.cur);    <span class="regexp">// 将最后元素析构  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        else  </span></span><br><span class="line"><span class="regexp">            //</span> 最后缓冲区没有任何元素  </span><br><span class="line">            pop_back_aux();    <span class="regexp">// 这里将进行缓冲区的释放工作  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void pop_front()  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        if (start.cur != start.last - 1)    //</span> 第一缓冲区有两个（或更多）元素  </span><br><span class="line">        &#123;  </span><br><span class="line">            destroy(start.cur);    <span class="regexp">// 将第一元素析构  </span></span><br><span class="line"><span class="regexp">            ++start.cur;           //</span>调整指针，相当于排除了第一元素  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">            <span class="regexp">// 第一缓冲区仅有一个元素  </span></span><br><span class="line"><span class="regexp">            pop_front_aux();    //</span> 这里将进行缓冲区的释放工作  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">public:                         <span class="regexp">// Insert  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//             insert(iterator position, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |---------------- 判断插入位置  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> deque.begin() |          deque.emd() |                      |  </span><br><span class="line"><span class="regexp">//               |                      |                      |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                      ↓                      |  </span><br><span class="line"><span class="regexp">//         push_front(x);         push_back(x);                |  </span></span><br><span class="line"><span class="regexp">//</span>                                                             ↓  </span><br><span class="line"><span class="regexp">//                                                 insert_aux(position, x);  </span></span><br><span class="line"><span class="regexp">//</span>                                                 具体剖析见后面实现  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="regexp">// 如果是在deque的最前端插入, 那么直接push_front()即可  </span></span><br><span class="line"><span class="regexp">        if (position.cur == start.cur)  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            push_front(x);  </span></span><br><span class="line"><span class="regexp">            return start;  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        //</span> 如果是在deque的末尾插入, 直接调用push_back()  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur)  </span><br><span class="line">        &#123;  </span><br><span class="line">            push_back(x);  </span><br><span class="line">            iterator tmp = finish;  </span><br><span class="line">            --tmp;  </span><br><span class="line">            <span class="keyword">return</span> tmp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> insert_aux(position, x);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    iterator insert(iterator position) &#123; <span class="keyword">return</span> insert(position, value_type()); &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 详解见实现部分  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, size_type n, const value_type&amp; x);  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, int n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    void insert(iterator pos, long n, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        insert(pos, (size_type) n, x);  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    void resize(size_type new_size) &#123; resize(new_size, value_type()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">public:                         //</span> Erase  </span><br><span class="line">  </span><br><span class="line">    iterator erase(iterator pos)  </span><br><span class="line">    &#123;  </span><br><span class="line">        iterator next = pos;  </span><br><span class="line">        ++next;  </span><br><span class="line">  </span><br><span class="line">        <span class="regexp">// 清除点之前的元素个数  </span></span><br><span class="line"><span class="regexp">        difference_type index = pos - start;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">        //</span> 如果清除点之前的元素个数比较少, 哪部分少就移动哪部分  </span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size() &gt;&gt; <span class="number">1</span>))  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="regexp">// 就移动清除点之前的元素  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, pos, next);  </span></span><br><span class="line"><span class="regexp">            pop_front();   //</span> 移动完毕，最前一个元素冗余，去除之  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   <span class="regexp">// 如果清除点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(next, finish, pos);  //</span> 就移动清除点之后的元素  </span><br><span class="line">            pop_back();   <span class="regexp">// 移动完毕，最后一个元素冗余，去除之  </span></span><br><span class="line"><span class="regexp">        &#125;  </span></span><br><span class="line"><span class="regexp">        return start + index;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    iterator erase(iterator first, iterator last);  </span></span><br><span class="line"><span class="regexp">    void clear();  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">protected:  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 详解见实现部分  </span><br><span class="line">    <span class="literal">void</span> push_back_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> push_front_aux(<span class="keyword">const</span> value_type&amp; t);  </span><br><span class="line">    <span class="literal">void</span> pop_back_aux();  </span><br><span class="line">    <span class="literal">void</span> pop_front_aux();  </span><br><span class="line">  </span><br><span class="line">    iterator insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">    <span class="literal">void</span> insert_aux(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x);  </span><br><span class="line">  </span><br><span class="line">    <span class="regexp">// 分配内存, 不进行构造  </span></span><br><span class="line"><span class="regexp">    pointer allocate_node() &#123; return data_allocator::allocate(buffer_size()); &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 释放内存, 不进行析构  </span><br><span class="line">    <span class="literal">void</span> deallocate_node(pointer n)  </span><br><span class="line">    &#123;  </span><br><span class="line">        data_allocator::deallocate(n, buffer_size());  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">// 清除[first, last)区间的所有元素  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span>                  erase(iterator first, iterator last)  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>                                   |---------------- 是否要删除整个区间?  </span><br><span class="line"><span class="regexp">//                                   |  </span></span><br><span class="line"><span class="regexp">//</span>               ------------------------------------------  </span><br><span class="line"><span class="regexp">//           Yes |                                        | No  </span></span><br><span class="line"><span class="regexp">//</span>               |                                        |  </span><br><span class="line"><span class="regexp">//               ↓                                        | --- 判断哪侧元素少  </span></span><br><span class="line"><span class="regexp">//</span>            clear();                                    ↓  </span><br><span class="line"><span class="regexp">//       -----------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> 左侧少 |                                                         右侧少 |  </span><br><span class="line"><span class="regexp">//       |                                                               |  </span></span><br><span class="line"><span class="regexp">//</span>       ↓                                                               ↓  </span><br><span class="line"><span class="regexp">//   copy_backward(start, first, last);            copy(last, finish, first);  </span></span><br><span class="line"><span class="regexp">//</span>   new_start = start + n;                        new_finish = finish - n;  </span><br><span class="line"><span class="regexp">//   析构多余的元素                                  析构多余的元素  </span></span><br><span class="line"><span class="regexp">//</span>   destroy(start, new_start);                    destroy(new_finish, finish);  </span><br><span class="line"><span class="regexp">//   释放多余内存空间                                释放多余内存空间  </span></span><br><span class="line"><span class="regexp">//</span>   <span class="keyword">for</span> (...)                                     <span class="keyword">for</span> (...)  </span><br><span class="line"><span class="regexp">//      ...                                             ...  </span></span><br><span class="line"><span class="regexp">//</span>   更新map状态                                    更新map状态  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">if</span> (first == start &amp;&amp; last == finish)   <span class="regexp">// 如果清除区间是整个deque  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        clear();              //</span> 直接调用clear()即可  </span><br><span class="line">        <span class="keyword">return</span> finish;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        difference_type n = last - first;   <span class="regexp">// 清除区间的长度  </span></span><br><span class="line"><span class="regexp">        difference_type elems_before = first - start;   //</span> 清除区间前方的元素个数  </span><br><span class="line">        <span class="keyword">if</span> (elems_before &lt; (size() - n) / <span class="number">2</span>)   <span class="regexp">// 如果前方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy_backward(start, first, last);  //</span> 向后移动前方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_start = start + n;     <span class="regexp">// 标记deque的新起点  </span></span><br><span class="line"><span class="regexp">            destroy(start, new_start);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            start = new_start;   //</span> 设定deque的新起点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>    <span class="regexp">// 如果清除区间后方的元素个数比较少  </span></span><br><span class="line"><span class="regexp">        &#123;  </span></span><br><span class="line"><span class="regexp">            copy(last, finish, first);  //</span> 向前移动后方元素（覆盖清除区间）  </span><br><span class="line">            iterator new_finish = finish - n;     <span class="regexp">// 标记deque的新尾点  </span></span><br><span class="line"><span class="regexp">            destroy(new_finish, finish);          //</span> 移动完毕，将冗余的元素析构  </span><br><span class="line">            <span class="regexp">// 以下将冗余的缓冲区释放  </span></span><br><span class="line"><span class="regexp">            for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur)  </span></span><br><span class="line"><span class="regexp">                data_allocator::deallocate(*cur, buffer_size());  </span></span><br><span class="line"><span class="regexp">            finish = new_finish;   //</span> 设定deque的新尾点  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> start + elems_before;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::clear()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="regexp">// 以下针对头尾以外的每一个缓冲区  </span></span><br><span class="line"><span class="regexp">    for (map_pointer node = start.node + 1; node &lt; finish.node; ++node)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        //</span> 将缓冲区内的所有元素析构  </span><br><span class="line">        destroy(*node, *node + buffer_size());  </span><br><span class="line">        <span class="regexp">// 释放缓冲区内存  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(*node, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    if (start.node != finish.node)   //</span> 至少有头尾两个缓冲区  </span><br><span class="line">    &#123;  </span><br><span class="line">        destroy(start.cur, start.last);  <span class="regexp">// 将头缓冲区的目前所有元素析构  </span></span><br><span class="line"><span class="regexp">        destroy(finish.first, finish.cur);  //</span> 将尾缓冲区的目前所有元素析构  </span><br><span class="line">        <span class="regexp">// 以下释放尾缓冲区。注意：头缓冲区保留  </span></span><br><span class="line"><span class="regexp">        data_allocator::deallocate(finish.first, buffer_size());  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    else   //</span> 只有一个缓冲区  </span><br><span class="line">        destroy(start.cur, finish.cur);   <span class="regexp">// 将此唯一缓冲区内的所有元素析构  </span></span><br><span class="line"><span class="regexp">        //</span> 注意：并不释放缓冲区空间，这唯一的缓冲区将保留  </span><br><span class="line">  </span><br><span class="line">    finish = start;   <span class="regexp">// 调整状态  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当finish.cur == finish.last - <span class="number">1</span> 时才会被调用  </span><br><span class="line"><span class="regexp">// 也就是说，只有当最后一个缓冲区只剩下一个备用元素空间时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t)  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    value_type t_copy = t;  </span></span><br><span class="line"><span class="regexp">    reserve_map_at_back();  </span></span><br><span class="line"><span class="regexp">    *(finish.node + 1) = allocate_node();    //</span> 配置一个新节点（缓冲区）  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        construct(finish.cur, t_copy);         <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">        finish.set_node(finish.node + 1);      //</span> 改变finish，令其指向新节点  </span><br><span class="line">        finish.cur = finish.first;             <span class="regexp">// 设定finish的状态  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    __STL_UNWIND(deallocate_node(*(finish.node + 1)));  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> Called only <span class="keyword">if</span> start.cur == start.first.  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;::push_front_aux(<span class="keyword">const</span> value_type&amp; t)  </span><br><span class="line">&#123;  </span><br><span class="line">    value_type t_copy = t;  </span><br><span class="line">    reserve_map_at_front();  </span><br><span class="line">    *(start.node - <span class="number">1</span>) = allocate_node();  </span><br><span class="line">    __STL_TRY  </span><br><span class="line">    &#123;  </span><br><span class="line">        start.set_node(start.node - <span class="number">1</span>);        <span class="regexp">// 改变start，令其指向新节点  </span></span><br><span class="line"><span class="regexp">        start.cur = start.last - 1;            //</span> 设定start的状态  </span><br><span class="line">        construct(start.cur, t_copy);          <span class="regexp">// 针对标的元素设值  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">    catch(...)  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        start.set_node(start.node + 1);  </span></span><br><span class="line"><span class="regexp">        start.cur = start.first;  </span></span><br><span class="line"><span class="regexp">        deallocate_node(*(start.node - 1));  </span></span><br><span class="line"><span class="regexp">        throw;  </span></span><br><span class="line"><span class="regexp">    &#125;  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span> 只有当 finish.cur == finish.first 时才会被调用  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line"><span class="literal">void</span> deque&lt;T, Alloc, BufSize&gt;:: pop_back_aux()  </span><br><span class="line">&#123;  </span><br><span class="line">    deallocate_node(finish.first);      <span class="regexp">// 释放最后一个缓冲区  </span></span><br><span class="line"><span class="regexp">    finish.set_node(finish.node - 1);   //</span> 调整finish状态，使指向  </span><br><span class="line">    finish.cur = finish.last - <span class="number">1</span>;       <span class="regexp">// 上一个缓冲区的最后一个元素  </span></span><br><span class="line"><span class="regexp">    destroy(finish.cur);                //</span> 将该元素析构  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="regexp">// 只有当 start.cur == start.last - 1 时才会被调用  </span></span><br><span class="line"><span class="regexp">template &lt;class T, class Alloc, size_t BufSize&gt;  </span></span><br><span class="line"><span class="regexp">void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux()  </span></span><br><span class="line"><span class="regexp">&#123;  </span></span><br><span class="line"><span class="regexp">    destroy(start.cur);    //</span> 将第一个缓冲区的第一个（也是最后一个、唯一一个）元素析构  </span><br><span class="line">    deallocate_node(start.first);    <span class="regexp">// 释放第一缓冲区  </span></span><br><span class="line"><span class="regexp">    start.set_node(start.node + 1);  //</span> 调整start状态，使指向  </span><br><span class="line">    start.cur = start.first;         <span class="regexp">// 下一个缓冲区的第一个元素  </span></span><br><span class="line"><span class="regexp">&#125;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 在指定位置前插入元素  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line"><span class="regexp">//              insert_aux(iterator pos, const value_type&amp; x)  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//                                   |----------- 判断pos前端元素少还是后端元素少  </span></span><br><span class="line"><span class="regexp">//</span>                                   |  </span><br><span class="line"><span class="regexp">//               -----------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         前端少 |                                       后端少 |  </span><br><span class="line"><span class="regexp">//               |                                             |  </span></span><br><span class="line"><span class="regexp">//</span>               ↓                                             |  </span><br><span class="line"><span class="regexp">//           进行相关操作                                   进行相关操作  </span></span><br><span class="line"><span class="regexp">//</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 下面以pos前面元素少的情形进行说明, 为了简化, 假设操作不会超过一个缓冲区区间  </span><br><span class="line"><span class="regexp">//  </span></span><br><span class="line"><span class="regexp">//</span> 插入前状态  </span><br><span class="line"><span class="regexp">//           start            pos                                 end  </span></span><br><span class="line"><span class="regexp">//</span>             ↓               ↓                                   ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">// 需要进行操作的区间  </span></span><br><span class="line"><span class="regexp">//</span>                需要拷贝的区间  </span><br><span class="line"><span class="regexp">//                 -------------  </span></span><br><span class="line"><span class="regexp">//</span>       start     |           |                                  end  </span><br><span class="line"><span class="regexp">//         ↓       ↓           ↓                                   ↓  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">// |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span></span><br><span class="line"><span class="regexp">//</span> ---------------------------------------------------------------------  </span><br><span class="line"><span class="regexp">//             ↑   ↑       ↑   ↑  </span></span><br><span class="line"><span class="regexp">//</span>        front1   |       |   |  </span><br><span class="line"><span class="regexp">//                 |       |   |  </span></span><br><span class="line"><span class="regexp">//</span>            front2       |   |  </span><br><span class="line"><span class="regexp">//                         |   |  </span></span><br><span class="line"><span class="regexp">//</span>                       pos   |  </span><br><span class="line"><span class="regexp">//                             |  </span></span><br><span class="line"><span class="regexp">//</span>                          pos1  </span><br><span class="line"><span class="regexp">// 拷贝操作完成后  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">//         这是[front2, pos1)  </span></span><br><span class="line"><span class="regexp">//</span>             ------------- --------- 这里是给待插入元素预留的空间  </span><br><span class="line"><span class="regexp">//       start |           | |                                    end  </span></span><br><span class="line"><span class="regexp">//</span>         ↓   ↓           ↓ ↓                                     ↓  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span> |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | X |  </span><br><span class="line"><span class="regexp">// ---------------------------------------------------------------------  </span></span><br><span class="line"><span class="regexp">//</span>         ↑  </span><br><span class="line"><span class="regexp">//   这里存储的是原来的front()  </span></span><br><span class="line"><span class="regexp">//</span>  </span><br><span class="line"><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span><span class="regexp">////</span>  </span><br><span class="line">  </span><br><span class="line">template &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;  </span></span><br><span class="line">typename deque&lt;T, Alloc, BufSize&gt;::iterator  </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, <span class="keyword">const</span> value_type&amp; x)  </span><br><span class="line">&#123;  </span><br><span class="line">    difference_type index = pos - start;   <span class="regexp">// 插入点之前的元素个数  </span></span><br><span class="line"><span class="regexp">    value_type x_copy = x;  </span></span><br><span class="line"><span class="regexp">  </span></span><br><span class="line"><span class="regexp">    //</span> 前面的时候用的移位操作, 这里怎么不用了呢^_^?  </span><br><span class="line">    <span class="keyword">if</span> (index &lt; size() / <span class="number">2</span>)    <span class="regexp">// 如果插入点之前的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_front(front());       //</span> 在最前端加入与第一元素同值的元素  </span><br><span class="line">        iterator front1 = start;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        ++front1;  </span></span><br><span class="line"><span class="regexp">        iterator front2 = front1;  </span></span><br><span class="line"><span class="regexp">        ++front2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        iterator pos1 = pos;  </span></span><br><span class="line"><span class="regexp">        ++pos1;  </span></span><br><span class="line"><span class="regexp">        copy(front2, pos1, front1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>    <span class="regexp">// 插入点之后的元素个数比较少  </span></span><br><span class="line"><span class="regexp">    &#123;  </span></span><br><span class="line"><span class="regexp">        push_back(back());         //</span> 在最尾端加入与最后元素同值的元素  </span><br><span class="line">        iterator back1 = finish;   <span class="regexp">// 以下标示记号，然后进行元素移动  </span></span><br><span class="line"><span class="regexp">        --back1;  </span></span><br><span class="line"><span class="regexp">        iterator back2 = back1;  </span></span><br><span class="line"><span class="regexp">        --back2;  </span></span><br><span class="line"><span class="regexp">        pos = start + index;  </span></span><br><span class="line"><span class="regexp">        copy_backward(pos, back2, back1);    //</span> 元素移动  </span><br><span class="line">    &#125;  </span><br><span class="line">    *pos = x_copy;    <span class="regexp">// 在插入点上设定新值  </span></span><br><span class="line"><span class="regexp">    return pos;  </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="源网址"><a href="#源网址" class="headerlink" title="源网址"></a>源网址</h2><ul><li><a href="https://blog.csdn.net/baidu_28312631/article/details/48000123" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析——deque的实现原理和使用方法详解</a></li><li><a href="https://blog.csdn.net/Hackbuteer1/article/details/7729451" rel="external nofollow noopener noreferrer" target="_blank">STL源码剖析—deque</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文抄袭至&lt;a href=&quot;https://blog.csdn.net/baidu_28312631/article/details/48000123&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;STL源码剖析——deque的实现原理和使用方法详解&lt;/a&gt;。只用于本人学习。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
      <category term="deque" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/deque/"/>
    
    
      <category term="deque" scheme="http://yoursite.com/tags/deque/"/>
    
  </entry>
  
  <entry>
    <title>Markdown公式编辑</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/markdowm/Markdown%E5%85%AC%E5%BC%8F%E7%BC%96%E8%BE%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/wiki/工具/markdowm/Markdown公式编辑学习笔记/</id>
    <published>2018-06-25T04:11:12.000Z</published>
    <updated>2018-06-26T03:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown中使用LaTEX 编写含有数学公式的博客。</p><a id="more"></a><h2 id="如何插入公式"><a href="#如何插入公式" class="headerlink" title="如何插入公式"></a>如何插入公式</h2><ol><li>行中公式（放在文中与其他文字编辑）：可以用如下方法表示：<code>$数学公式$</code></li><li>独立公式可以用下面的方法表示：<code>$$数学公式$$</code></li><li>自动编号的公式可以用如下的方法表示：<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">数学公式</span><br><span class="line"><span class="tag">\<span class="name">label</span><span class="string">&#123;eq:当前公式名&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">自动编号后的公式可在全文任意处使用 <span class="tag">\<span class="name">eqref</span><span class="string">&#123;eq:公式名&#125;</span></span> 语句引用。</span><br></pre></td></tr></table></figure></li></ol><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，not one line &#125; $</span></span><br></pre></td></tr></table></figure><p>显示$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，not one line } $</p><p>例子</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ J_<span class="tag">\<span class="name">alpha</span></span>(x) = <span class="tag">\<span class="name">sum</span></span>_&#123;m=0&#125;^<span class="tag">\<span class="name">infty</span></span> <span class="tag">\<span class="name">frac</span><span class="string">&#123;(-1)^m&#125;</span><span class="string">&#123;m! \gamma (m + \alpha + 1)&#125;</span></span> &#123;<span class="tag">\<span class="name">left</span></span>(&#123; <span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;2&#125;</span></span> &#125;<span class="tag">\<span class="name">right</span></span>)&#125;^&#123;2m + <span class="tag">\<span class="name">alpha</span></span>&#125; <span class="tag">\<span class="name">text</span></span> &#123;，独立公式示例&#125;$$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ J_\alpha(x) = \sum_{m=0}^\infty \frac{(-1)^m}{m! \gamma (m + \alpha + 1)} {\left({ \frac{x}{2} }\right)}^{2m + \alpha} \text {，独立公式示例} $$</p><h2 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h2><p><code>^</code> 表示上标， <code>_</code> 表示下标。如果上下标的内容多于一个字符，需要用<code>{}</code>将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。</p><p>例子</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> x^&#123;y^z&#125;=(<span class="number">1</span>+&#123;\rm e&#125;^x)^&#123;<span class="number">-2</span>xy^w&#125; <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ x^{y^z}=(1+{\rm e}^x)^{-2xy^w} $$</p><p>另外，如果要在左右两边都有上下标，可以用<code>\sideset</code> 命令</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span> \sideset&#123;^<span class="number">1</span>_2&#125;&#123;^<span class="number">3</span>_4&#125;\bigotimes <span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$ \sideset{^1_2}{^3_4}\bigotimes $$</p><h2 id="括号和分隔符"><a href="#括号和分隔符" class="headerlink" title="括号和分隔符"></a>括号和分隔符</h2><p><code>()</code>、<code>[]</code>和<code>|</code>表示符号本身，使用 <code>\{\}</code> 来表示 <code>{}</code>。当要显示大号的括号或分隔符时，要用 \left 和 \right 命令。<br>一些特殊的括号：</p><table><thead><tr><th>输入</th><th>显示</th></tr></thead><tbody><tr><td><code>$$\langle表达式\rangle$$</code></td><td>$$\langle表达式\rangle$$</td></tr><tr><td><code>$$\lceil表达式\rceil$$</code></td><td>$$\lceil表达式\rceil$$</td></tr><tr><td><code>$$\lfloor表达式\rfloor$$</code></td><td>$$\lfloor表达式\rfloor$$</td></tr><tr><td><code>$$\lbrace表达式\rbrace$$</code></td><td>$$\lbrace表达式\rbrace$$</td></tr></tbody></table><p>例子</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$ f(x,y,z) = <span class="number">3</span>y^<span class="number">2</span>z \left( <span class="number">3</span>+\frac&#123;<span class="number">7</span>x+<span class="number">5</span>&#125;&#123;<span class="number">1</span>+y^<span class="number">2</span>&#125; \right) $$</span><br></pre></td></tr></table></figure><p>显示<br>$$ f(x,y,z) = 3y^2z \left( 3+\frac{7x+5}{1+y^2} \right) $$</p><h2 id="分数"><a href="#分数" class="headerlink" title="分数"></a>分数</h2><p>通常使用 <code>\frac {分子} {分母}</code>命令产生一个分数<code>\frac {分子} {分母}</code>，分数可嵌套。<br>便捷情况可直接输入 \frac ab来快速生成一个\frac ab。<br>如果分式很复杂，亦可使用 分子 \over 分母 命令，此时分数仅有一层。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\<span class="built-in">frac</span>&#123;a<span class="number">-1</span>&#125;&#123;b<span class="number">-1</span>&#125; \quad <span class="keyword">and</span> \quad &#123;a+<span class="number">1</span>\over b+<span class="number">1</span>&#125;<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示</p><p>$$\frac{a-1}{b-1} \quad and \quad {a+1\over b+1}$$</p><h2 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h2><p>使用 <code>\sqrt [根指数，省略时为2] {被开方数}</code>命令输入开方。</p><p>例子：</p><p><code>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</code></p><p>显示</p><p>$$\sqrt{2} \quad and \quad \sqrt[n]{3}$$</p><h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p>数学公式中常见的省略号有两种，<code>\ldots</code> 表示与文本底线对齐的省略号，<code>\cdots</code> 表示与文本中线对齐的省略号。</p><p>例子：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">$f</span>(x_1,x_2,<span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\l</span>dots&#125;_&#123;<span class="symbol">\r</span>m ldots&#125; ,x_n) = x_1^2 + x_2^2 + <span class="symbol">\u</span>nderbrace&#123;<span class="symbol">\c</span>dots&#125;_&#123;<span class="symbol">\r</span>m cdots&#125; + x_n^2$$</span><br></pre></td></tr></table></figure><p>显示：</p><p>$$f(x_1,x_2,\underbrace{\ldots}_{\rm ldots} ,x_n) = x_1^2 + x_2^2 + \underbrace{\cdots}_{\rm cdots} + x_n^2$$</p><h2 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h2><p>使用 <code>\vec{矢量}</code>来自动产生一个矢量。也可以使用 <code>\overrightarrow</code>等命令自定义字母上方的符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span> <span class="tag">\<span class="name">cdot</span></span> <span class="tag">\<span class="name">vec</span><span class="string">&#123;b&#125;</span>=<span class="number">0</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$<span class="tag">\<span class="name">overleftarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overleftrightarrow</span><span class="string">&#123;xy&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">overrightarrow</span><span class="string">&#123;xy&#125;</span></span>$$</span></span><br></pre></td></tr></table></figure><p>显示：<br>$$\overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \quad \overrightarrow{xy}$$</p><h2 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h2><p>使用 \int_积分下限^积分上限 {被积表达式} 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><table><thead><tr><th>输入</th><th>说明</th><th>显示</th></tr></thead><tbody><tr><td><code>\rm</code></td><td>罗马体</td><td>$$\rm Sample$$</td></tr><tr><td><code>\it</code></td><td>意大利体</td><td>$$\it Sample $$</td></tr><tr><td><code>\bf</code></td><td>粗体</td><td>$$\bf Sample $$</td></tr><tr><td><code>\sf</code></td><td>等线体</td><td>$$\sf Sample $$</td></tr><tr><td><code>\tt</code></td><td>打字机体</td><td>$$\tt Sample $$</td></tr><tr><td><code>\frak</code></td><td>旧德式字体</td><td>$$\frak Sample $$</td></tr><tr><td><code>\cal</code></td><td>花体</td><td>$$\cal Sample $$</td></tr><tr><td><code>\Bbb</code></td><td>黑板粗体</td><td>$$\Bbb Sample $$</td></tr><tr><td><code>\mit</code></td><td>数学斜体</td><td>$$\mit Sample $$</td></tr><tr><td>\scr</td><td>手写体</td><td>$$\scr Sample$$</td></tr></tbody></table><h2 id="积分-1"><a href="#积分-1" class="headerlink" title="积分"></a>积分</h2><p>使用 <code>\int_积分下限^积分上限 {被积表达式}</code> 来输入一个积分。</p><p>例子：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span><span class="symbol">$</span>\int_0^<span class="number">1</span> &#123;x^<span class="number">2</span>&#125; \,&#123;\rm d&#125;x<span class="symbol">$</span><span class="symbol">$</span></span><br></pre></td></tr></table></figure><p>显示<br>$$\int_0^1 {x^2} \,{\rm d}x$$</p><h2 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h2><p>使用\lim_{变量 \to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \to 符号至任意符号。</p><p>例子：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="formula">$$ <span class="tag">\<span class="name">lim</span></span>_&#123;n <span class="tag">\<span class="name">to</span></span> +<span class="tag">\<span class="name">infty</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> <span class="tag">\<span class="name">quad</span></span> and <span class="tag">\<span class="name">quad</span></span> <span class="tag">\<span class="name">lim</span></span>_&#123;x<span class="tag">\<span class="name">leftarrow</span><span class="string">&#123;示例&#125;</span></span>&#125; <span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;n(n+1)&#125;</span></span> $$</span></span><br></pre></td></tr></table></figure><p>显示：</p><p>$$ \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad and \quad \lim_{x\leftarrow{示例}} \frac{1}{n(n+1)} $$</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.zybuluo.com/codeep/note/163962" rel="external nofollow noopener noreferrer" target="_blank">Cmd Markdown 公式指导手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown中使用LaTEX 编写含有数学公式的博客。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="markdowm" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/markdowm/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>数学知识一对数指数</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/wiki/数据知识/数学基础知识/</id>
    <published>2018-06-25T04:07:12.000Z</published>
    <updated>2018-06-26T03:41:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>解换底公式为：</p><p>$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \text{(c＞0，c≠1)} $$</p><p>loga（b）=logc（b）/logc（a）（c＞0，c≠1）<br>推导过程</p><p>令 $ \log_a{b} = t $</p><p>即 $ a^t = b$</p><p>即a^t=b</p><p>两边取以c（c＞0，c≠1）的对数</p><p>即 $ \log_c(a^t) =\log_cb $</p><p>即 $t\log_c{a}=log_cb</p><p>由a≠1，即 $ \log_c{a}≠0$</p><p>所以 $t=\frac{log_cb}{log_ca} $ </p><p>所以： $log_ab= \frac{log_cb}{log_ca}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对数&quot;&gt;&lt;a href=&quot;#对数&quot; class=&quot;headerlink&quot; title=&quot;对数&quot;&gt;&lt;/a&gt;对数&lt;/h2&gt;&lt;p&gt;解换底公式为：&lt;/p&gt;
&lt;p&gt;$$ \log_ab = \frac {\log_cb}{\log_ca}  \quad \quad \tex
      
    
    </summary>
    
      <category term="数据知识" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="数学知识" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>运算符优先级表</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E6%B3%95/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/运算法/运算符优先级表/</id>
    <published>2018-06-23T04:07:12.000Z</published>
    <updated>2018-07-05T11:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="C-运算符优先级"><a href="#C-运算符优先级" class="headerlink" title="C++ 运算符优先级"></a>C++ 运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;C-运算符优先级&quot;&gt;&lt;a href=&quot;#C-运算符优先级&quot; class=&quot;headerlink&quot; title=&quot;C++ 运算符优先级&quot;&gt;&lt;/a&gt;C++ 运算符优先级&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结合
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="运算法" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="运算符优先级" scheme="http://yoursite.com/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>mach-o Viewer 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/Mach_O/machoviewer/"/>
    <id>http://yoursite.com/wiki/IOS/Mach_O/machoviewer/</id>
    <published>2018-06-22T04:07:12.000Z</published>
    <updated>2018-06-22T05:52:55.000Z</updated>
    
    <content type="html"><![CDATA[<p> 本文是 <a href="https://github.com/gdbinit/MachOView" rel="external nofollow noopener noreferrer" target="_blank">mach-o Viewer </a>源码学习记录。</p><a id="more"></a><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/datastruct.png" alt="数据结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/overrall.png" alt="代码结构"></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/macho/viewver/domainTask.png" alt="domainTask"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 本文是 &lt;a href=&quot;https://github.com/gdbinit/MachOView&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;mach-o Viewer &lt;/a&gt;源码学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Mach_O" scheme="http://yoursite.com/categories/IOS/Mach-O/"/>
    
    
      <category term="macho" scheme="http://yoursite.com/tags/macho/"/>
    
  </entry>
  
  <entry>
    <title>图解fishhook</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/fishHookPicture/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/fishhook/fishHookPicture/</id>
    <published>2018-06-21T04:07:12.000Z</published>
    <updated>2018-06-22T10:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文尝试9图片解释fishhook原理<br><a id="more"></a></p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP1.jpg" alt="图1 __la_symbol_ptr section"></p><p>图1. load command中_DATA segement中<code>__la_symbol_ptr</code> section结构图,说明该section和动态符号表对应的起始索引是146</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP2.jpg" alt="图2 数据区域中__la_symbol_ptr的结构"></p><p>图2.数据区域中<code>__la_symbol_ptr</code>的结构,可以看出该section的起始地址是0x00240B0，图2和图3是为了找malloc函数指针的位置</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP3.jpg" alt="图3 __la_symbol_ptr 中malloc"></p><p>图3.数据区域中__la_symbol_ptr的结构,  偏移了一定的位置。文件0x000242B0地址出存储的是malloc函数指针。</p><p>计算偏移数量的方法：0x242B0  - 0x240B0 = 0x200<br>每个条目占用8个字节0x200/0x8 = 0x40  = 64<br>得出：在符号表中，malloc偏移64个条目</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP4.jpg" alt="图4 动态符号表起始地址"></p><p>图4 .转到数据区域中动态符号表的起始位置处，该图说明动态符号表的起始地址是0x3B0A4</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP5.jpg" alt="图5 动态符号表 __la_symbol_ptr对应处"></p><p>图5 。 计算<strong>la_symbol_ptr 对应的符号在动态符号表中的位置： 0x3B060 + 146*4 = 0x3B060 + 0x248 = 0x3B2A8，<br>地址0x0003B2A8处后面的符号和</strong>la_symbol_ptr中的条目对应。 </p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP6.jpg" alt="图6 动态符号表 __la_symbol_ptr 内部146偏移处"></p><p>图6 .  查找64个偏移后的动态符号表的地址：0x3B2A8 + 0x40*x4 = 0x3B3A8，地址0x3B3A8中存储的值是符号表中的索引，<br>为0xb32。由于machoviewer看不到符号表，所以用代码查看符号表中索引为0xB32 的符号信息。</p><p>查看代码：struct nlist_64 const * mallocNlist =[self getSymbol64ByIndex:0xB32];</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP7.jpg" alt="图7 符号表"></p><p>图7 .代码查看符号表示意图。符号表的索引为0xB32的符号的信息。可以看出n_strx的值是0x2B07，<br>这个值指的是string表中的偏移量 </p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP8.jpg" alt="图8 string表起始地址 "></p><p>图8 .string 表，string表的起始地址是0x3B498</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhookP9.jpg" alt="图9 String表偏移0x2B07"><br>图9 .string 表， 偏移0x2B07 后的结果—— 0x3B498 + 0x2B07 = 0x3DF9F， 这个地址存储的字符串就是图3中</p><p>地址为0x10001ef10的函数指针的名称，名称是malloc。这个名称和我么要替换的名称一致，所以替换图3中的<br>0x10001ef10，替换成新指定函数指针地址。实现替换。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文尝试9图片解释fishhook原理&lt;br&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="fishhook" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/"/>
    
    
      <category term="图解fishhook" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%A7%A3fishhook/"/>
    
  </entry>
  
  <entry>
    <title>fishhook学习记录</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/learn_fishhook/"/>
    <id>http://yoursite.com/wiki/IOS/开源库学习/fishhook/learn_fishhook/</id>
    <published>2018-06-20T04:07:12.000Z</published>
    <updated>2018-06-22T10:02:59.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/facebook/fishhook" rel="external nofollow noopener noreferrer" target="_blank">fishhook</a>是一个可以替换C函数的开源库，官网的readme讲解了重新绑定的原理。本文从源码的角度去学习fishhook。</p><a id="more"></a><h2 id="源码示意图"><a href="#源码示意图" class="headerlink" title="源码示意图"></a>源码示意图</h2><p>先给个简单的源码示意图。循序渐进理解啊。直接上源码有点懵，几个函数名称太相似了。不过呢，看图，好像就四个函数、247行代码而已。</p><p><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/fishhook_code_struct.png" alt="源码示意图"></p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><p>源码使用OOMDetector，OOMDetector使用fishhook替换malloc函数。使用OOMDetector的目的是顺便可以学习fishhook api的调用方式，同时也能学习fishhook源码。</p><p>首先，fishhook定义了一个结构体，存储绑定的数据。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">//替换的函数名字</span></span><br><span class="line">  <span class="keyword">void</span> *replacement; <span class="comment">//替换后的函数指针</span></span><br><span class="line">  <span class="keyword">void</span> **replaced;   <span class="comment">//原始的方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的替换malloc等函数的入口函数，该函数调用了fishhook的<code>rebind_symbols_for_imagename</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hookMalloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        beSureAllRebindingFuncBeenCalled();</span><br><span class="line">        </span><br><span class="line">        orig_malloc = <span class="built_in">malloc</span>;</span><br><span class="line">        orig_calloc = <span class="built_in">calloc</span>;</span><br><span class="line">        orig_valloc = valloc;</span><br><span class="line">        orig_realloc = <span class="built_in">realloc</span>;</span><br><span class="line">        orig_block_copy = _Block_copy;</span><br><span class="line">        </span><br><span class="line">        rebind_symbols_for_imagename(</span><br><span class="line">                                     (struct rebinding[<span class="number">5</span>])&#123;</span><br><span class="line">                                         &#123;<span class="string">"realloc"</span>,(<span class="keyword">void</span>*)new_realloc,(<span class="keyword">void</span>**)&amp;orig_realloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"malloc"</span>, (<span class="keyword">void</span>*)new_malloc, (<span class="keyword">void</span> **)&amp;orig_malloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"valloc"</span>,(<span class="keyword">void</span>*)new_valloc,(<span class="keyword">void</span>**)&amp;orig_valloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"calloc"</span>,(<span class="keyword">void</span>*)new_calloc,(<span class="keyword">void</span>**)&amp;orig_calloc&#125;,</span><br><span class="line">                                         &#123;<span class="string">"_Block_copy"</span>,(<span class="keyword">void</span>*)new_block_copy,(<span class="keyword">void</span>**)&amp;orig_block_copy&#125;&#125;,</span><br><span class="line">                                     <span class="number">5</span>,</span><br><span class="line">                                     getImagename());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        isPaused = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hookMalloc</code>替换了<code>realloc</code>、<code>malloc</code>、<code>valloc</code>、<code>calloc</code>、<code>_Block_copy</code>这几个函数。</p><p>下面是新的<code>new_malloc</code>函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">new_malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = orig_malloc(size);</span><br><span class="line">    <span class="keyword">if</span>(!isPaused)&#123;</span><br><span class="line">        global_leakChecker-&gt;recordMallocStack((<span class="keyword">vm_address_t</span>)ptr, (<span class="keyword">uint32_t</span>)size,<span class="string">"malloc"</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __enable_malloc_logger__</span></span><br><span class="line">    malloc_printf(<span class="string">"malloc ptr:%p size:%lu thread:%lu\n"</span>,ptr, size,mach_thread_self());</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>new_malloc</code>函数首先会调用原来的<code>malloc</code>函数，接着会记录申请的内存的堆栈。</p><p>下面是原始函数的定义：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void* (<span class="name">*orig_malloc</span>)(<span class="name">size_t</span>)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_calloc</span>)(<span class="name">size_t</span>, size_t)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_realloc</span>)(<span class="name">void</span> *, size_t);</span><br><span class="line">static void* (<span class="name">*orig_valloc</span>)(<span class="name">size_t</span>)<span class="comment">;</span></span><br><span class="line">static void* (<span class="name">*orig_block_copy</span>)(<span class="name">const</span> void *aBlock);</span><br></pre></td></tr></table></figure><p>下面是rebind_symbols_for_imagename第三个入参————镜像名称的获取方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getImagename</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">    <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">        name = tmp + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了<code>&lt;mach-o/dyld.h&gt;</code> 头文件中的<code>_dyld_get_image_name</code>函数。 <code>_dyld_get_image_name</code> 根据镜像的索引，获取镜像的名称。<code>strrchr</code>函数是反向查找第一个给定字符。返回第一次匹配到的地址指针。</p><p>下面代码进入fishhook的入口函数<code>rebind_symbols_for_imagename</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebind_symbols_for_imagename</span><span class="params">(struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">size_t</span> rebindings_nel,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">char</span> *imagename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> count = _dyld_image_count();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">mach_header_t</span>* header = (<span class="keyword">const</span> <span class="keyword">mach_header_t</span>*)_dyld_get_image_header(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* name = _dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* tmp = <span class="built_in">strrchr</span>(name, <span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">long</span> slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        <span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">            name = tmp + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,imagename) == <span class="number">0</span>)&#123;</span><br><span class="line">            rebind_symbols_image((<span class="keyword">void</span> *)header,</span><br><span class="line">                                 slide,</span><br><span class="line">                                 rebindings,</span><br><span class="line">                                 rebindings_nel);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebindings</code>承载重新绑定的所有信息，<code>rebindings_nel</code>是<code>rebindings</code>的个数，<code>imagename</code>要替换函数指针镜像名称，也就是只替换名称为<code>imagename</code>文件中的函数指针，其他库不做替换。</p><p><code>_dyld_get_image_header</code> 获取镜像的header头，<code>_dyld_get_image_vmaddr_slide</code>获取镜像的随机启动地址。<code>rebind_symbols_for_imagename</code>函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考<a href="https://stackoverflow.com/questions/13574933/ios-crash-reports-atos-not-working-as-expected/13576028#13576028" rel="external nofollow noopener noreferrer" target="_blank">iOS crash reports: atos not working as expected</a>、<font color="red"> <a href="https://www.cnblogs.com/feng9exe/p/7988360.html" rel="external nofollow noopener noreferrer" target="_blank">iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol</a></font> 。</p><p>下面为了理解ALSR中的slide，贴出一段测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">understandALSR</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///枚举所有镜像</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _dyld_image_count(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> *image_name = (<span class="keyword">char</span> *)_dyld_get_image_name(i);</span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span> *<span class="title">mh</span> = _<span class="title">dyld_get_image_header</span>(<span class="title">i</span>);</span></span><br><span class="line">        <span class="keyword">intptr_t</span> vmaddr_slide = _dyld_get_image_vmaddr_slide(i);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\n"</span>,</span><br><span class="line">               image_name, (<span class="keyword">mach_vm_address_t</span>)mh, vmaddr_slide);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Image name <span class="regexp">/Users/</span>lijian<span class="regexp">/Library/</span>Developer<span class="regexp">/CoreSimulator/</span>Devices<span class="regexp">/21045765-7E1F-499B-A985-1BCCFC70B079/</span>data<span class="regexp">/Containers/</span>Bundle<span class="regexp">/Application/</span><span class="number">0975</span>D79D-<span class="number">5079</span>-<span class="number">4258</span>-<span class="number">8</span>A0F-<span class="number">48175818</span>A28A<span class="regexp">/LearnMachO.app/</span>LearnMachO ,image header <span class="number">0</span>x10dff0000 , ASLR slide <span class="number">0</span>xdff0000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libBacktraceRecording.dylib ,image header <span class="number">0</span>x10e07c000 , ASLR slide <span class="number">0</span>x10e07c000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/u</span>sr<span class="regexp">/lib/</span>libMainThreadChecker.dylib ,image header <span class="number">0</span>x10e08b000 , ASLR slide <span class="number">0</span>x10e08b000.</span><br><span class="line">Image name <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>Library<span class="regexp">/CoreSimulator/</span>Profiles<span class="regexp">/Runtimes/i</span>OS.simruntime<span class="regexp">/Contents/</span>Resources<span class="regexp">/RuntimeRoot/</span>Developer<span class="regexp">/Library/</span>PrivateFrameworks<span class="regexp">/DTDDISupport.framework/</span>libViewDebuggerSupport.dylib ,image header <span class="number">0</span>x10e27d000 , ASLR slide <span class="number">0</span>x10e27d000.</span><br></pre></td></tr></table></figure><p>代码对应的二进制文件中的加载地址（链接时load address）示意图：<br><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/learnMachO.jpg" alt="learnMachO"><br><img src="http://of685p9vy.bkt.clouddn.com/iOS/%E5%BC%80%E6%BA%90%E5%BA%93/fishhook/libbacktraceRecording.jpg" alt="learnMachO"><br>结合上面的示例代码和二进制内容图片，可以诠释下面的公式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slide = (运行时)load<span class="built_in"> address </span>- (链接时)load address;</span><br><span class="line">symble<span class="built_in"> address </span>＝ stack<span class="built_in"> address </span>－slide；</span><br></pre></td></tr></table></figure><p>其中：</p><ol><li>stack address ： 程序运行时线程栈中 所有 函数调用的地址</li><li>symble address ： dsym文件中函数符号对应的地址，用此地址在dsym 文件中可以查出对应的符号信息。 </li></ol><p>可以看出，没有ASLR时：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symble<span class="built_in"> address </span>=  stack address</span><br></pre></td></tr></table></figure><p>好了，接着看<code>rebind_symbols_image</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rebind_symbols_image</span><span class="params">(<span class="keyword">void</span> *header,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">intptr_t</span> slide,</span></span></span><br><span class="line"><span class="function"><span class="params">                         struct rebinding rebindings[],</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">size_t</span> rebindings_nel)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">rebindings_head</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel);</span><br><span class="line">    rebind_symbols_for_image(rebindings_head, header, slide);</span><br><span class="line">    <span class="built_in">free</span>(rebindings_head);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_image</code> 主要工作是通过<code>prepend_rebindings</code>构造绑定的结构体<code>struct rebindings_entry</code>，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span> *<span class="title">rebindings</span>;</span></span><br><span class="line">  <span class="keyword">size_t</span> rebindings_nel;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int prepend_rebindings(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> **rebindings_head,</span><br><span class="line">                              <span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span> rebindings[],</span><br><span class="line">                              size_t nel) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">///申请new_entry地址                  </span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *new_entry = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span>));</span><br><span class="line">  <span class="keyword">if</span> (!new_entry) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///给new_entry-&gt;rebindings分配内存</span></span><br><span class="line">  new_entry-&gt;rebindings = malloc(<span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  <span class="keyword">if</span> (!new_entry-&gt;rebindings) &#123;</span><br><span class="line">    free(new_entry);</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///拷贝重新绑定信息到new_entry-&gt;rebindings</span></span><br><span class="line">  memcpy(new_entry-&gt;rebindings, rebindings, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">rebinding</span></span>) * nel);</span><br><span class="line">  new_entry-&gt;rebindings_nel = nel;</span><br><span class="line">  new_entry-&gt;next = *rebindings_head;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">///这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者</span></span><br><span class="line">  *rebindings_head = new_entry;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prepend_rebindings 只是将绑定的struct rebinding类型参数转化为struct rebindings_entry结构，这种结构类似链表，可以方便的管理多个struct rebinding结构。下面看rebind_symbols_for_image：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> void rebind_symbols_for_image(<span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span></span> *rebindings,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mach_header</span></span> *header,</span><br><span class="line">                                     intptr_t slide) &#123;</span><br><span class="line">  Dl_info info;</span><br><span class="line">  <span class="comment">///find the image containing a given address</span></span><br><span class="line">  <span class="comment">///验证库是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (dladdr(header, &amp;info) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  segment_command_t *cur_seg_cmd;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">///SEG_LINKEDIT commond指针</span></span><br><span class="line">  segment_command_t *linkedit_segment = NULL;</span><br><span class="line">  <span class="comment">///LC_SYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>* symtab_cmd = NULL;</span><br><span class="line">  <span class="comment">///LC_DYSYMTAB commond指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>* dysymtab_cmd = NULL;</span><br><span class="line"></span><br><span class="line"><span class="comment">///定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针</span></span><br><span class="line">  uintptr_t cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize)</span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        linkedit_segment = cur_seg_cmd;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      symtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">symtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB)</span><br><span class="line">    &#123;</span><br><span class="line">      dysymtab_cmd = (<span class="class"><span class="keyword">struct</span> <span class="title">dysymtab_command</span></span>*)cur_seg_cmd;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!symtab_cmd || !dysymtab_cmd || !linkedit_segment ||</span><br><span class="line">      !dysymtab_cmd-&gt;nindirectsyms) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find base symbol/string table addresses 查找符号表和string表</span></span><br><span class="line">  uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff;</span><br><span class="line">  nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff);</span><br><span class="line">  <span class="built_in">char</span> *strtab = (<span class="built_in">char</span> *)(linkedit_base + symtab_cmd-&gt;stroff);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get indirect symbol table (array of uint32_t indices into symbol table)</span></span><br><span class="line">  uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff);</span><br><span class="line"></span><br><span class="line">  cur = (uintptr_t)header + <span class="keyword">sizeof</span>(mach_header_t);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) </span><br><span class="line">  &#123;</span><br><span class="line">    cur_seg_cmd = (segment_command_t *)cur;</span><br><span class="line">    <span class="keyword">if</span> (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">          strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section</span></span><br><span class="line">      <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123;</span><br><span class="line">        section_t *sect =</span><br><span class="line">          (section_t *)(cur + <span class="keyword">sizeof</span>(segment_command_t)) + j;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123;</span><br><span class="line">          perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rebind_symbols_for_image</code> 函数主要定位到三表、类型为<code>S_LAZY_SYMBOL_POINTERS</code>、<code>S_NON_LAZY_SYMBOL_POINTERS</code>类型的section。然后调用<code>perform_rebinding_with_section</code> 函数。其中部分宏定义如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>SEG_LINKEDIT<span class="meta-string">"__LINKEDIT"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_NON_LAZY_SYMBOL_POINTERS 0x6  <span class="comment">/* section with only non-lazy symbol pointers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>S_LAZY_SYMBOL_POINTERS 0x7     <span class="comment">/* section with only lazy symbol</span></span></span><br></pre></td></tr></table></figure><p>上面的宏定义于<code>&lt;mach-o/loader.h&gt;</code>文件中，位于458行。<font color="red"> 在S_NON_LAZY_SYMBOL_POINTERS宏的上面有一段注释。这段注释非常的关键。说明了S_NON_LAZY_SYMBOL_POINTERS类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。</font></p><p>For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries. </p><p>对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。 </p><p>For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure. </p><p>间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。</p><p>Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries  in the section is 4 bytes (看结构是8bytes，可能是64位的缘故)</p><p>由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节</p><p>下面是<code>perform_rebinding_with_section</code>函数源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perform_rebinding_with_section</span><span class="params">(struct rebindings_entry *rebindings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">section_t</span> *section,  <span class="comment">//section</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">intptr_t</span> slide,     <span class="comment">//基址</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">nlist_t</span> *symtab,  <span class="comment">//符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">char</span> *strtab,  <span class="comment">//sting 表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> *indirect_symtab <span class="comment">//动态符号表</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                           )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">///动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///section加载到内存的虚拟地址（是要替换这里面的东西）</span></span><br><span class="line">    <span class="keyword">void</span> **indirect_symbol_bindings = (<span class="keyword">void</span> **)((<span class="keyword">uintptr_t</span>)slide + section-&gt;addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///section中替换函数指针</span></span><br><span class="line">    <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; section-&gt;size / <span class="keyword">sizeof</span>(<span class="keyword">void</span> *); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。</span></span><br><span class="line">        <span class="comment">///下面目的是获取section中存储的函数指针的符号  动态符号表-&gt; 符号表-&gt; string表</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引</span></span><br><span class="line">        <span class="keyword">uint32_t</span> symtab_index = indirect_symbol_indices[i];</span><br><span class="line">        <span class="keyword">if</span> (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL ||</span><br><span class="line">            symtab_index == (INDIRECT_SYMBOL_LOCAL   | INDIRECT_SYMBOL_ABS))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。</span></span><br><span class="line">        <span class="keyword">uint32_t</span> strtab_offset = symtab[symtab_index].n_un.n_strx;</span><br><span class="line">        <span class="keyword">char</span> *symbol_name = strtab + strtab_offset;</span><br><span class="line">        <span class="keyword">if</span> (strnlen(symbol_name, <span class="number">2</span>) &lt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rebindings_entry</span> *<span class="title">cur</span> = <span class="title">rebindings</span>;</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; cur-&gt;rebindings_nel; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">///如果符号名称和替换的名称一样，进行替换</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(&amp;symbol_name[<span class="number">1</span>], cur-&gt;rebindings[j].name) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cur-&gt;rebindings[j].replaced != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">                      indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">///保存原始的指针地址，只保存一次</span></span><br><span class="line">                        *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。   </span></span><br><span class="line">                    indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement;</span><br><span class="line">                    <span class="keyword">goto</span> symbol_loop;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        symbol_loop:;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>perform_rebinding_with_section函数完成替换的关键函数。 将section中的函数指针替换为新的函数指针。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Hello_Hwc/article/details/78444203?locationNum=3&amp;fps=1" rel="external nofollow noopener noreferrer" target="_blank">Fishhook替换C函数的原理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/facebook/fishhook&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;fishhook&lt;/a&gt;是一个可以替换C函数的开源库，官网的readme讲解了重新绑定的原理。本文从源码的角度去学习fishhook。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="开源库学习" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="fishhook" scheme="http://yoursite.com/categories/IOS/%E5%BC%80%E6%BA%90%E5%BA%93%E5%AD%A6%E4%B9%A0/fishhook/"/>
    
    
      <category term="fishhook" scheme="http://yoursite.com/tags/fishhook/"/>
    
  </entry>
  
  <entry>
    <title>合并真机模拟器静态库(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%8A%A8%E6%80%81%E5%BA%93/static_lib_aggregate_script/"/>
    <id>http://yoursite.com/wiki/IOS/动态库/static_lib_aggregate_script/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T09:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章解释合并真机模拟器静态库的脚本</p><a id="more"></a><h2 id="合成脚本"><a href="#合成脚本" class="headerlink" title="合成脚本"></a>合成脚本</h2><p>合并的脚本如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/build</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"build_DIR=<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/include/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_INCLUDE=<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphoneos/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"DEVICE_DIR_A=<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=<span class="variable">$&#123;build_DIR&#125;</span>/Release-iphonesimulator/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"SIMULATOR_DIR_A=<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line">cp -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line">open <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="铺路"><a href="#铺路" class="headerlink" title="铺路"></a>铺路</h2><p>本代码中用到的核心命令：</p><h3 id="xcodebuild"><a href="#xcodebuild" class="headerlink" title="xcodebuild"></a>xcodebuild</h3><p>苹果给的一个命令。主要用来编译Xcode的工程。<br>可以在终端中输入xcodebuild -h来查看命令的详情，介绍一下本脚本中用到的几个参数</p><ul><li>clean:clean一下工程</li><li>-configuration Release<br>使用Release方式编译，还可以使用Debug</li><li>-sdk iphoneos<br>真机编译，还可以使用-sdk iphonesimulator模拟器编译</li></ul><h3 id="cp-“源文件路径”-“目标文件路径”"><a href="#cp-“源文件路径”-“目标文件路径”" class="headerlink" title="cp “源文件路径” “目标文件路径”"></a>cp “源文件路径” “目标文件路径”</h3><p>复制”源文件路径”的文件到 “目标文件路径”</p><h3 id="lipo"><a href="#lipo" class="headerlink" title="lipo"></a>lipo</h3><p>lipo -create “模拟器.a文件路径” “真机.a文件路径” -output “目标.a文件路径”</p><p>将模拟器和真机的.a包合成。</p><h3 id="用到的一些shell脚本基础命令"><a href="#用到的一些shell脚本基础命令" class="headerlink" title="用到的一些shell脚本基础命令"></a>用到的一些shell脚本基础命令</h3><h4 id="echo-“你要写的东西”"><a href="#echo-“你要写的东西”" class="headerlink" title="echo “你要写的东西”"></a>echo “你要写的东西”</h4><p>打印的log,将”你要写的东西”打印出来，相当于OC中的NSLog<br>Xcode的话，运行脚本后，可以在这里找到log</p><h4 id="赋值命令。-变量名-变量值"><a href="#赋值命令。-变量名-变量值" class="headerlink" title="赋值命令。 变量名=变量值"></a>赋值命令。 变量名=变量值</h4><p>比如将”CrazyStone”赋值给MyName变量</p><p>MyName=CrazyStone</p><h4 id="变量名"><a href="#变量名" class="headerlink" title="${变量名}"></a>${变量名}</h4><p>取出变量名的内容。<br>比如：取出变量MyName中的内容<br>${MyName}</p><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>if [ 条件语句 ]then<br>…<br>fi<br>条件语句为真就执行then后面的语句，不成立就结束判断语句</p><h4 id="本脚本中用到的判断语句："><a href="#本脚本中用到的判断语句：" class="headerlink" title="本脚本中用到的判断语句："></a>本脚本中用到的判断语句：</h4><p>[ -d “文件夹路径” ] ：判断是否为文件夹</p><h2 id="脚本结构解释"><a href="#脚本结构解释" class="headerlink" title="脚本结构解释"></a>脚本结构解释</h2><p>看完上面，我想你再看一下代码应该就能理解脚本，然后可以做一些简单的改动了。下面再介绍一下脚本的结构。</p><h3 id="执行条件–-编译"><a href="#执行条件–-编译" class="headerlink" title="执行条件– 编译"></a>执行条件– 编译</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;ACTION&#125;</span>"</span> = <span class="string">"build"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="comment">#我们的大部分脚本代码</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>执行脚本的时候做个判断，在Xcode里面build这个工程的时候就执行then后面的脚本</p><h3 id="工程名称定义"><a href="#工程名称定义" class="headerlink" title="工程名称定义"></a>工程名称定义</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要build的target名</span></span><br><span class="line">target_Name=<span class="variable">$&#123;PROJECT_NAME&#125;</span> </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"target_Name=<span class="variable">$&#123;target_Name&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>变量target_Name是我们要编译的target的名字，在这里指的是工程的名字${PROJECT_NAME}，也就是MySDK。</p><p>顺便说一下，ACTION和PROJECT_NAME都是Xcode里面定义的，这是在Xcode里面写脚本的一个好处。</p><h3 id="build-路径"><a href="#build-路径" class="headerlink" title="build 路径"></a>build 路径</h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之后的文件夹路径</span></span><br><span class="line">build_DIR=$&#123;SRCROOT&#125;/build</span><br><span class="line">    echo <span class="string">"build_DIR=$&#123;build_DIR&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的头文件的文件夹路径</span></span><br><span class="line">DEVICE_DIR_INCLUDE=$&#123;build_DIR&#125;/Release-iphoneos/<span class="keyword">include</span>/$&#123;PROJECT_NAME&#125;</span><br><span class="line">    echo <span class="string">"DEVICE_DIR_INCLUDE=$&#123;DEVICE_DIR_INCLUDE&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build生成的.a文件路径</span></span><br><span class="line">DEVICE_DIR_A=$&#123;build_DIR&#125;/Release-iphoneos/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"DEVICE_DIR_A=$&#123;DEVICE_DIR_A&#125;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build生成的.a文件路径</span></span><br><span class="line">SIMULATOR_DIR_A=$&#123;build_DIR&#125;/Release-iphonesimulator/<span class="class"><span class="keyword">lib</span>$&#123;<span class="title">PROJECT_NAME</span>&#125;.<span class="title">a</span></span></span><br><span class="line">    echo <span class="string">"SIMULATOR_DIR_A=$&#123;SIMULATOR_DIR_A&#125;"</span></span><br></pre></td></tr></table></figure><p>这里是定义的build之后各个文件的路径。我们执行了xcodebuild命令之后，会在工程目录生成一个build文件夹，里面有build之后生成的文件。打开Finder看看就知道各个文件的路径了。</p><h3 id="build目录的位置"><a href="#build目录的位置" class="headerlink" title="build目录的位置"></a>build目录的位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#目标文件夹路径</span></span><br><span class="line">INSTALL_DIR=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR=<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标头文件文件夹路径</span></span><br><span class="line">INSTALL_DIR_Headers=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/Headers</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_Headers=<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#目标.a路径</span></span><br><span class="line">INSTALL_DIR_A=<span class="variable">$&#123;SRCROOT&#125;</span>/Products/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/lib<span class="variable">$&#123;PROJECT_NAME&#125;</span>.a</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"INSTALL_DIR_A=<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是定义目标变量的路径了。你想把文件放在哪里？在这里定义咯。${SRCROOT}表示工程的根目录。用了这么久的Xcode，这个有用过吧(全局头文件配置过吧？)？</p><h3 id="文件状态判断"><a href="#文件状态判断" class="headerlink" title="文件状态判断"></a>文件状态判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#判断build文件夹是否存在，存在则删除</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;build_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断目标文件夹是否存在，存在则删除该文件夹</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">rm -rf <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#创建目标文件夹</span></span><br><span class="line">mkdir -p <span class="string">"<span class="variable">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>这里就是文件的操作了。如果有这两个文件夹，就删除掉。为什么？为了保证我们工程的纯净啊。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build之前clean一下</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -target <span class="variable">$&#123;target_Name&#125;</span> clean</span><br><span class="line"></span><br><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -target <span class="variable">$&#123;target_Name&#125;</span> -configuration Release -sdk iphoneos</span><br></pre></td></tr></table></figure><p>这里就跟平常操作一样了。先clean一下工程，然后模拟器编译一次，真机编译一次。</p><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#复制头文件到目标文件夹</span></span><br><span class="line"><span class="attribute">cp</span> -R <span class="string">"<span class="variable">$&#123;DEVICE_DIR_INCLUDE&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;INSTALL_DIR_Headers&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合成模拟器和真机.a包</span></span><br><span class="line">lipo -create <span class="string">"<span class="variable">$&#123;DEVICE_DIR_A&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;SIMULATOR_DIR_A&#125;</span>"</span> -output <span class="string">"<span class="variable">$&#123;INSTALL_DIR_A&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>关键代码。拷贝头文件到我们的目标位置去。合成.a包。大功告成。</p><h3 id="打开目标文件夹"><a href="#打开目标文件夹" class="headerlink" title="打开目标文件夹"></a>打开目标文件夹</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打开目标文件夹</span></span><br><span class="line"><span class="keyword">open</span> <span class="string">"<span class="subst">$&#123;INSTALL_DIR&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>最后，打开文件夹。检查一下文件是否真正生成了。</p><h2 id="shell脚本基础知识"><a href="#shell脚本基础知识" class="headerlink" title="shell脚本基础知识"></a>shell脚本基础知识</h2><p>如果你想了解更多关于shell脚本的知识，可以看看这篇文章：Linux shell脚本基础学习详细介绍</p><h2 id="xcworkspace-工程对应的脚本"><a href="#xcworkspace-工程对应的脚本" class="headerlink" title="xcworkspace 工程对应的脚本"></a>xcworkspace 工程对应的脚本</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#模拟器build</span></span><br><span class="line"><span class="attribute">xcodebuild</span> -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphonesimulator</span><br><span class="line"></span><br><span class="line"><span class="comment">#真机build</span></span><br><span class="line">xcodebuild -workspace <span class="variable">$&#123;target_Name&#125;</span>.xcworkspace -scheme <span class="variable">$&#123;target_Name&#125;</span> -configuration <span class="variable">$&#123;build_model&#125;</span> -sdk iphoneos</span><br></pre></td></tr></table></figure><p>对于xcworkspace工程，需要将编译的脚本替换 ，其中–workspace、-scheme是必须的 ，scheme 可以通过xcodebuild -list 查看。</p><h2 id="iOS设备架构"><a href="#iOS设备架构" class="headerlink" title="iOS设备架构"></a>iOS设备架构</h2><p>模拟器：<br>iPhone4s-iPnone5：i386<br>iPhone5s-iPhone7 Plus：x86_64</p><p>真机:<br>iPhone3gs-iPhone4s：     armv7<br>iPhone5-iPhone5c：        armv7s<br>iPhone5s-iPhone7 Plus： arm64</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/9cf90b9537fd" rel="external nofollow noopener noreferrer" target="_blank">【iOS开发】静态库.a文件合成脚本解释</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章解释合并真机模拟器静态库的脚本&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="动态库" scheme="http://yoursite.com/categories/IOS/%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Xcode编译环境变量</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <id>http://yoursite.com/wiki/工具/Xcode编译常量/xcode编译环境变量/</id>
    <published>2018-06-06T04:07:12.000Z</published>
    <updated>2018-06-06T08:59:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>看图吧</p><p><img src="http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.png" alt="xcode 环境变量"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://of685p9vy.bkt.clouddn.com/%E5%B7%A5%E5%85%B7/xcode/Xcode%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Xcode编译常量" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Xcode%E7%BC%96%E8%AF%91%E5%B8%B8%E9%87%8F/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>查看虚拟内存</title>
    <link href="http://yoursite.com/wiki/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B9%8B2/"/>
    <id>http://yoursite.com/wiki/IOS/虚拟内存/虚拟内存之2/</id>
    <published>2018-06-02T04:07:12.000Z</published>
    <updated>2018-06-02T04:47:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.<br>如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。</p><p>The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">Instruments User Guide</a> and the other articles in this document. For information on how to use the top tool,<br>以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">仪器用户指南</a>和本文中的其他文章。有关如何使用顶部工具的信息，请参见<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">2</a>。see <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">Performance Overview</a>.</p><a id="more"></a><h2 id="Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）"><a href="#Viewing-Virtual-Memory-Statistics（查看虚拟内存统计信息）" class="headerlink" title="Viewing Virtual Memory Statistics（查看虚拟内存统计信息）"></a>Viewing Virtual Memory Statistics（查看虚拟内存统计信息）</h2><p>The vm_stat tool displays high-level statistics about the current virtual memory usage of the system. By default, vm_stat displays these statistics once, but you can specify an interval value (in seconds) to update these statistics continuously. For information on the usage of this tool, see the vm_stat man page.<br>vm_stat工具显示关于系统当前虚拟内存使用情况的高级统计信息。默认情况下，vm_stat只显示这些统计信息一次，但是您可以指定一个间隔值(以秒为单位)来持续更新这些统计信息。有关此工具使用的信息，请参见vm_stat手册页。</p><p>Listing 1 shows an example of the output from vm_stat. </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Mach Virtual Memory Statistics: (page size <span class="keyword">of</span> <span class="number">4096</span> bytes)</span><br><span class="line">Pages free:                     <span class="number">3194</span>.</span><br><span class="line">Pages active:                  <span class="number">34594</span>.</span><br><span class="line">Pages inactive:                <span class="number">17870</span>.</span><br><span class="line">Pages wired down:               <span class="number">9878</span>.</span><br><span class="line"><span class="string">"Translation faults"</span>:        <span class="number">6333197</span>.</span><br><span class="line">Pages copy-on-write:           <span class="number">81385</span>.</span><br><span class="line">Pages zero filled:           <span class="number">3180051</span>.</span><br><span class="line">Pages reactivated:            <span class="number">343961</span>.</span><br><span class="line">Pageins:                       <span class="number">33043</span>.</span><br><span class="line">Pageouts:                      <span class="number">78496</span>.</span><br><span class="line">Object cache: <span class="number">66227</span> hits <span class="keyword">of</span> <span class="number">96952</span> lookups (<span class="number">68</span><span class="comment">% hit rate)</span></span><br></pre></td></tr></table></figure><h2 id="Viewing-Mach-O-Code-Pages"><a href="#Viewing-Mach-O-Code-Pages" class="headerlink" title="Viewing Mach-O Code Pages"></a>Viewing Mach-O Code Pages</h2><p>The pagestufftool displays information about the specified logical pages of a file conforming to the Mach-O executable format. For each specified page of code, symbols (function and static data structure names) are displayed. All pages in the <strong>TEXT, </strong>text section are displayed if no page numbers are given.<br>pagestufftool显示符合Mach-O可执行格式的文件的指定逻辑页的信息。对于每个指定的代码页，将显示符号(函数和静态数据结构名称)。如果没有给出页码，则显示__TEXT节中的所有页面。</p><p>Listing 2 shows part of the output from pagestuff for the TextEdit application. This output is the result of running the tool with the -a option, which prints information about all of the executable’s code pages. It includes the virtual address locations of each page and the type of information on that page.<br>清单2显示了TextEdit应用程序的页面内容的部分输出。此输出是使用-a选项运行工具的结果，该选项打印关于可执行文件的所有代码页的信息。它包括每个页面的虚拟地址位置和页面上的信息类型。</p><p>Listing 2  Partial output of pagestuff tool</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">File<span class="built_in"> Page </span>0 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>1 contains Mach-O headers</span><br><span class="line">File<span class="built_in"> Page </span>2 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>2 virtual<span class="built_in"> address </span>0x3a08 <span class="keyword">to</span> 0x4000</span><br><span class="line">File<span class="built_in"> Page </span>3 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>3 virtual<span class="built_in"> address </span>0x4000 <span class="keyword">to</span> 0x5000</span><br><span class="line">File<span class="built_in"> Page </span>4 contains contents of section (__TEXT,__text)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>4 virtual<span class="built_in"> address </span>0x5000 <span class="keyword">to</span> 0x6000</span><br><span class="line"> </span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__cstring)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal4)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__literal8)</span><br><span class="line">File<span class="built_in"> Page </span>22 contains contents of section (__TEXT,__const)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>22 virtual<span class="built_in"> address </span>0x17000 <span class="keyword">to</span> 0x17ffc</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__data)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__la_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__nl_symbol_ptr)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__dyld)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__cfstring)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__bss)</span><br><span class="line">File<span class="built_in"> Page </span>23 contains contents of section (__DATA,__common)</span><br><span class="line">Symbols on file<span class="built_in"> page </span>23 virtual<span class="built_in"> address </span>0x18000 <span class="keyword">to</span> 0x18d48</span><br><span class="line"> 0x00018000 _NXArgc</span><br><span class="line"> 0x00018004 _NXArgv</span><br><span class="line"> 0x00018008 _environ</span><br><span class="line"> 0x0001800c ___progname</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><p>In the preceding listing, if a page exports any symbols, those symbols are also displayed by the -a option. If you want to view the symbols for a single page, pass in the desired page number instead of the -a option. For more information about the pagestuff tool and its supported options, see the pagestuff man page.</p><p>在前面的列表中，如果一个页面导出任何符号，那么这些符号也会被a选项显示。如果要查看单个页面的符号，请输入所需的页码，而不是-a选项。有关pagestuff工具及其支持选项的更多信息，请参见pagestuff man页面。</p><h2 id="Viewing-Virtual-Memory-Regions"><a href="#Viewing-Virtual-Memory-Regions" class="headerlink" title="Viewing Virtual Memory Regions"></a>Viewing Virtual Memory Regions</h2><p>The vmmap and vmmap64 tools display the virtual memory regions allocated for a specified process. These tools provide access to the virtual memory of 32-bit and 64-bit applications, respectively. You can use them to understand the purpose of memory at a given address and how that memory is being used. For each virtual-memory region, these tools display the type of page, the starting address, region size (in kilobytes), read/write permissions, sharing mode, and the purpose of the pages in that region.<br>vmmap和vmmap64工具显示为指定进程分配的虚拟内存区域。这些工具分别提供对32位和64位应用程序的虚拟内存的访问。您可以使用它们来理解给定地址的内存用途以及内存的使用方式。对于每个虚拟内存区域，这些工具显示页面的类型、起始地址、区域大小(单位为千字节)、读/写权限、共享模式和该区域的页面用途。</p><p>The following sections show you how to interpret the output from the vmmap tool. For more information about the vmmap and vmmap64 tools, see the vmmap or vmmap64 man pages.<br>以下部分将向您展示如何解释vmmap工具的输出。有关vmmap和vmmap64工具的更多信息，请参见vmmap或vmmap64手册页面。</p><p>Sample Output From vmmap<br>Listing 3 shows some sample output from the vmmap tool. This example is not a full listing of the tool’s output but is an abbreviated version showing the primary sections.</p><p>Listing 3  Typical output of vmmap</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">==== Non-writable regions <span class="keyword">for</span> process 313</span><br><span class="line">__PAGEZERO              0 [   4K] ---/--- <span class="attribute">SM</span>=NUL <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__TEXT               1000 [  40K] r-x/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/MacOS/Clock</span><br><span class="line">__LINKEDIT           e000 [   4K] r--/rwx <span class="attribute">SM</span>=COW <span class="built_in">..</span>.ts/w/Clock</span><br><span class="line">                    90000 [   4K] r--/r-- <span class="attribute">SM</span>=SHM</span><br><span class="line">                   340000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">                   789000 [3228K] r--/rwx <span class="attribute">SM</span>=COW 00000100 00320<span class="built_in">..</span>.</span><br><span class="line">Submap           90000000-9fffffff r--/r-- machine-wide submap</span><br><span class="line">__TEXT           90000000  [ 932K] r-x/r-x <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__LINKEDIT       900e9000   [ 260K] r--/r-- <span class="attribute">SM</span>=COW /usr/lib/libSystem.B.dylib</span><br><span class="line">__TEXT           90130000 [ 740K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__LINKEDIT       901e9000 [ 188K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">__TEXT           90220000 [2144K] r-x/r-x <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">__LINKEDIT       90438000 [ 296K] r--/r-- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">==== Writable regions <span class="keyword">for</span> process 606</span><br><span class="line">__DATA             18000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV /Contents/MacOS/TextEdit</span><br><span class="line">__OBJC             19000 [   8K] rw-/rwx <span class="attribute">SM</span>=COW /Contents/MacOS/TextEdit</span><br><span class="line">MALLOC_OTHER       1d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(DefaultMallocZone_0x5d2c0)     5d000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                   9d000 [ 372K] rw-/rwx <span class="attribute">SM</span>=COW 33320000 00000020 00000000 00001b84<span class="built_in">..</span>.</span><br><span class="line">VALLOC_USED(DefaultMallocZone_0x5d2c0)     ff000 [  36K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsDefaultZone_0x10  108000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">MALLOC_USED(CoreGraphicsRegionZone_0x148  148000 [ 256K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line"> </span><br><span class="line">[<span class="built_in">..</span>.data omitted<span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">Submap           a000b000-a012ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0130000 [  28K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CoreFoundation</span><br><span class="line">Submap           a0137000-a021ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0220000 [  20K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/CarbonCore</span><br><span class="line">Submap           a0225000-a048ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0490000 [  12K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./IOKit.framework/Versions/A/IOKit</span><br><span class="line">Submap           a0493000-a050ffff r--/r-- process-only submap</span><br><span class="line">__DATA           a0510000 [  36K] rw-/rw- <span class="attribute">SM</span>=COW <span class="built_in">..</span>./Versions/A/OSServices</span><br><span class="line">                 b959e000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b95a0000 [   4K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b9630000 [ 164K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 b965a000 [ 896K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 bff80000 [ 504K] rw-/rwx <span class="attribute">SM</span>=ZER</span><br><span class="line">STACK[0]         bfffe000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 bffff000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">__DATA           c000c000 [   4K] rw-/rwx <span class="attribute">SM</span>=PRV <span class="built_in">..</span>./Versions/A/ApplicationEnhancer</span><br><span class="line">STACK[1]         f0001000 [ 512K] rw-/rwx <span class="attribute">SM</span>=PRV</span><br><span class="line">                 ff002000 [12272K] rw-/rw- <span class="attribute">SM</span>=SHM</span><br><span class="line">                 </span><br><span class="line">                 ==== Legend</span><br><span class="line"><span class="attribute">SM</span>=sharing mode:</span><br><span class="line">    <span class="attribute">COW</span>=copy_on_write <span class="attribute">PRV</span>=private <span class="attribute">NUL</span>=empty <span class="attribute">ALI</span>=aliased</span><br><span class="line">    <span class="attribute">SHM</span>=shared <span class="attribute">ZER</span>=zero_filled S/<span class="attribute">A</span>=shared_alias</span><br><span class="line"> </span><br><span class="line">==== Summary <span class="keyword">for</span> process 313</span><br><span class="line">ReadOnly portion of Libraries: <span class="attribute">Total</span>=27420KB <span class="attribute">resident</span>=12416KB(45%) <span class="attribute">swapped_out_or_unallocated</span>=15004KB(55%)</span><br><span class="line">Writable regions: <span class="attribute">Total</span>=21632KB <span class="attribute">written</span>=536KB(2%) <span class="attribute">resident</span>=1916KB(9%) <span class="attribute">swapped_out</span>=0KB(0%) <span class="attribute">unallocated</span>=19716KB(91%)</span><br></pre></td></tr></table></figure><p>If you specify the -d parameter (plus an interval in seconds), vmmap takes two snapshots of virtual-memory usage—one at the beginning of a specified interval and the other at the end—and displays the differences. It shows three sets of differences:</p><ul><li>individual differences</li><li>regions in the first snapshot that are not in the second</li><li>regions in the second snapshot that are not in the first</li></ul><p>如果您指定-d参数(加上以秒为单位的间隔)，vmmap将获取两个虚拟内存使用快照(一个在指定的间隔开始，另一个在结束)，并显示差异。它显示了三组差异:</p><ul><li>个体差异</li><li>第一个快照中的区域而不是第二个快照中的区域</li><li>第二个快照中不属于第一个快照的区域</li></ul><p>Interpreting vmmap’s Output<br>The columns of vmmap output have no headings. Instead you can interpret the type of data in each column by its format. Table 1 describes these columns.</p><p>Table 1  Column descriptions for vmmap</p><p><strong>Table 1</strong>  Column descriptions for vmmap</p><table><thead><tr><th>Column Number</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>1</td><td><code>__TEXT</code>, <code>__LINKEDIT</code>, <code>MALLOC_USED</code>, <code>STACK</code>, and so on</td><td>The purpose of the memory. This column can contain the name of a Mach-O segment or the memory allocation technique.</td></tr><tr><td>2</td><td><code>(DefaultMallocZone_0x5d2c0)</code></td><td>If present, the zone used for allocation.</td></tr><tr><td>3</td><td><code>4eee000</code></td><td>The virtual memory address of the region.</td></tr><tr><td>4</td><td><code>[ 124K]</code></td><td>The size of the region, measured in kilobytes</td></tr><tr><td>5</td><td><code>rw-/rwx</code></td><td>Read, write and execution permissions for the region. The first set of flags specifies the current protection for the region. The second set of values specifies the maximum protection for the region. If an entry contains a dash (<code>-</code>), the process does not have the target permission.</td></tr><tr><td>6</td><td><code>SM=PRV</code></td><td>Sharing mode for the region, either <code>COW</code> (copy-on-write), <code>PRV</code> (private), <code>NUL</code> (empty), <code>ALI</code> (aliased), or <code>SHM</code> (shared).</td></tr><tr><td>7</td><td><code>...ts/MacOS/Clock</code></td><td>The end of the pathname identifying the executable mapped into this region of virtual memory. If the region is stack or heap memory, nothing is displayed in this column.</td></tr></tbody></table><p>Column 1 identifies the purpose of the memory. A <strong>TEXT segment contains read-only code and data. A </strong>DATA segment contains data that may be both readable and writable. For allocated data, this column shows how the memory was allocated, such as on the stack, using malloc, and so on. For regions loaded from a library, the far right column shows the name of the library loaded into memory.<br>第1列标识内存的用途。<strong>TEXT段包含只读代码和数据。</strong>DATA段包含可读和可写的数据。对于已分配的数据，这一列显示如何分配内存，例如使用malloc在堆栈上，等等。对于从库中加载的区域，最右边的列显示加载到内存中的库的名称。</p><p>The size of the virtual memory region (column 4) represents the total size reserved for that region. This number may not reflect the actual number of memory pages allocated for the region. For example, calling vm_allocate reserves a set of memory pages but does not allocate any physical memory until the pages are actually touched. Similarly, a memory-mapped file may reserve a set of pages, but the system does not load pages until a read or write event occurs on the file.<br>虚拟内存区域的大小(第4列)表示该区域保留的总大小。这个数字可能不能反映为该区域分配的内存页的实际数量。例如，调用vm_allocation会保留一组内存页，但在实际操作这些页之前不会分配任何物理内存。类似地，内存映射文件可以保留一组页面，但是系统在文件上发生读或写事件之前不会加载页面。</p><p>The protection mode (column 5) describes the access restrictions for the memory region. A memory region contains separate flags for read, write, and execution permissions. Each virtual memory region has a current permission, and a maximum permission. In the output from vmmap, the current permission appears first followed by the maximum permission. Thus, if the permissions are “r–/rwx“ the page is currently read-only but allows read, write, and execution access as its maximum allowed permissions. Typically, the current permissions do not permit writing to a region. However, these permissions may change under certain circumstances. For example, a debugger may request write access to a page in order to set a breakpoint.<br>保护模式(第5列)描述了内存区域的访问限制。内存区域包含用于读取、写入和执行权限的单独标志。每个虚拟内存区域都有一个当前权限和最大权限。在vmmap的输出中，当前权限首先显示为最大权限。因此，如果权限是“r- /rwx”，页面当前是只读的，但允许读、写和执行访问作为其最大允许的权限。通常，当前权限不允许写入区域。但是，这些权限在某些情况下可能会改变。例如，调试器可以请求对页面的写访问，以便设置断点。</p><p>The sharing mode (SM= field) tells you whether pages are shared between processes and what happens when pages are modified. Private pages (PRV) are visible only to the process and are allocated as they are used. Private pages can also be paged out to disk. Copy-on-write (COW) pages are shared by multiple processes (or shared by a single process in multiple locations). When the page is modified, the writing process then receives its own copy of the page. Empty (NUL) sharing implies that the page does not really exist in physical memory. Aliased (ALI) and shared (SHM) memory are shared between processes.<br>共享模式(SM= field)告诉您进程之间是否共享页面，以及修改页面时会发生什么。私有页面(PRV)只对进程可见，并在使用它们时进行分配。还可以将私有页面分页到磁盘。写时复制(COW)页面由多个进程共享(或由多个位置的单个进程共享)。当页面被修改时，编写过程将收到它自己的页面副本。空(NUL)共享意味着页面并不真正存在于物理内存中。别名(ALI)和共享(SHM)内存在进程之间共享。</p><p>The sharing mode typically describes the general mode controlling the region. For example, as copy-on-write pages are modified, they become private to the application. However, the region containing those private pages is still copy-on-write until all pages become private. Once all pages are private, the sharing mode changes to private.<br>共享模式通常描述控制该区域的通用模式。例如，当对写后复制的页面进行修改时，它们将成为应用程序的私有页面。但是，包含这些私有页面的区域仍然是“写时复制”，直到所有页面变为私有。一旦所有页面都是私有的，共享模式就会变为私有。</p><p>Some lines in the output of vmmap describe submaps. A submap is a shared set of virtual memory page descriptions that the operating system can reuse between multiple processes. For example, the memory between 0x90000000 and 0xAFFFFFFF is a submap containing the most common dynamic libraries. Submaps minimize the operating system’s memory usage by representing the virtual memory regions only once. Submaps can either be shared by all processes (machine-wide) or be local to the process (process-only). If the contents of a machine-wide submap are changed—for example, the debugger makes a section of memory for a dynamic library writable so it can insert debugging traps—then the submap becomes local, and the kernel allocates memory to store the extra copy.<br>vmmap输出中的一些行描述子映射。子映射是操作系统可以在多个进程之间重用的一组共享的虚拟内存页面描述。例如，0x90000000和0xAFFFFFFF之间的内存是包含最常见动态库的子映射。子映射只表示一次虚拟内存区域，从而最小化操作系统的内存使用。子映射可以由所有进程(机器范围内)共享，也可以是进程(仅处理)的本地映射。如果修改了机器范围的子映射的内容(例如，调试器为动态库编写一个内存段，以便它可以插入调试trap)，那么子映射就变成本地的，内核分配内存来存储额外的副本。</p><p>[a]:</p><p>[a]:</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.&lt;br&gt;如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。&lt;/p&gt;
&lt;p&gt;The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Instruments User Guide&lt;/a&gt; and the other articles in this document. For information on how to use the top tool,&lt;br&gt;以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅&lt;a href=&quot;https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;仪器用户指南&lt;/a&gt;和本文中的其他文章。有关如何使用顶部工具的信息，请参见&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2&lt;/a&gt;。see &lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Performance Overview&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存之一----关于</title>
    <link href="http://yoursite.com/wiki/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>http://yoursite.com/wiki/IOS/虚拟内存/虚拟内存/</id>
    <published>2018-06-01T04:07:12.000Z</published>
    <updated>2018-06-02T04:04:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章翻译下<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" rel="external nofollow noopener noreferrer" target="_blank">Memory Usage Performance Guidelines</a></p><a id="more"></a><h2 id="About-Virtual-Memory"><a href="#About-Virtual-Memory" class="headerlink" title="About Virtual Memory"></a>About Virtual Memory</h2><p>Virtual memory allows an operating system to escape the limitations of physical RAM. The virtual memory manager creates a logical address space (or “virtual” address space) for each process and divides it up into uniformly-sized chunks of memory called pages. The processor and its memory management unit (MMU) maintain a page table to map pages in the program’s logical address space to hardware addresses in the computer’s RAM. When a program’s code accesses an address in memory, the MMU uses the page table to translate the specified logical address into the actual hardware memory address. This translation occurs automatically and is transparent to the running application. </p><p><font color="red">虚拟内存允许操作系统摆脱物理RAM的限制。虚拟内存管理器为每个进程创建一个逻辑地址空间(或“虚拟”地址空间)，</font>并将其划分为大小相同的称为页面的内存块。处理器及其内存管理单元(MMU)维护一个页表，将程序逻辑地址空间中的页映射到计算机RAM中的硬件地址。当程序的代码访问内存中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动进行的，对正在运行的应用程序是透明的。</p><p>As far as a program is concerned, addresses in its logical address space are always available. 就程序而言，其逻辑地址空间中的地址总是可用的。<br>However, if an application accesses an address on a memory page that is not currently in physical RAM, a page fault occurs.但是，如果应用程序访问当前不在物理RAM中的内存页上的地址，则会发生页面错误。 When that happens, the virtual memory system invokes a special page-fault handler to respond to the fault immediately.当发生这种情况时，虚拟内存系统调用一个特殊的页面错误处理程序来立即响应错误。 The page-fault handler stops the currently executing code, locates a free page of physical memory, loads the page containing the needed data from disk, updates the page table, and then returns control to the program’s code, which can then access the memory address normally. This process is known as paging. 页面错误处理程序停止当前执行的代码，定位物理内存的空闲页面，从磁盘装载包含所需数据的页面，更新页面表，然后返回对程序代码的控制，然后程序代码就可以正常地访问内存地址。这个过程称为分页。</p><p>If there are no free pages available in physical memory, the handler must first release an existing page to make room for the new page.如果在物理内存中没有可用的空闲页面，处理程序必须首先释放一个现有页面，以便为新页面腾出空间。 How the system release pages depends on the platform. 系统释放页面的方式取决于平台。In OS X, the virtual memory system often writes pages to the backing store.在OS X中，虚拟内存系统经常将页面写入后备存储器。 The backing store is a disk-based repository containing a copy of the memory pages used by a given process.后备存储是一个基于磁盘的存储库，其中包含给定进程使用的内存页的副本。 Moving data from physical memory to the backing store is called paging out (or “swapping out”);将数据从物理内存移动到后台存储被称为分页(或“交换出”); moving data from the backing store back in to physical memory is called paging in (or “swapping in”). 将数据从后台存储恢复到物理内存称为分页in(或“交换in”)。In iOS, there is no backing store and so pages are are never paged out to disk, but read-only pages are still be paged in from disk as needed.在iOS中，没有备份存储，所以不会将页面调出到磁盘，但是只读页面仍然根据需要从磁盘调入。</p><p>In OS X and in earlier versions of iOS, the size of a page is 4 kilobytes.在OS X和iOS的早期版本中，页面的大小是4千字节。 In later versions of iOS, A7- and A8-based systems expose 16-kilobyte pages to the 64-bit userspace backed by 4-kilobyte physical pages,在iOS的后续版本中，基于A7和基于a8的系统将16千字节的页暴露给由4千字节物理页支持的64位用户空间， while A9 systems expose 16-kilobyte pages backed by 16-kilobyte physical pages. 而A9系统将16千字节的页暴露给由16千字节物理页支持的64位用户空间。These sizes determine how many kilobytes the system reads from disk when a page fault occurs. 这些大小决定了当发生页面错误时系统从磁盘读取多少千字节。Disk thrashing can occur when the system spends a disproportionate amount of time handling page faults and reading and writing pages, rather than executing code for a program. 当系统花费过多的时间处理页面错误、读写页面，而不是为程序执行代码时，就会发生磁盘抖动。</p><p>Paging of any kind, and disk thrashing in particular, affects performance negatively because it forces the system to spend a lot of time reading and writing to disk. Reading a page in from the backing store takes a significant amount of time and is much slower than reading directly from RAM. If the system has to write a page to disk before it can read another page from disk, the performance impact is even worse.<br>任何类型的分页，特别是磁盘抖动，都会对性能产生负面影响，因为这会迫使系统花费大量时间对磁盘进行读写。从后台存储读取页面需要大量的时间，而且比直接从RAM读取要慢得多。如果系统必须在从磁盘读取另一个页面之前将一个页面写到磁盘，那么性能的影响甚至更糟。</p><h2 id="Details-of-the-Virtual-Memory-System"><a href="#Details-of-the-Virtual-Memory-System" class="headerlink" title="Details of the Virtual Memory System"></a>Details of the Virtual Memory System</h2><p>The logical address space of a process consists of mapped regions of memory. Each mapped memory region contains a known number of virtual memory pages. Each region has specific attributes controlling such things as inheritance (portions of the region may be mapped from “parent” regions), write-protection, and whether it is wired (that is, it cannot be paged out). Because regions contain a known number of pages, they are page-aligned, meaning the starting address of the region is also the starting address of a page and the ending address also defines the end of a page.<br>进程的逻辑地址空间由内存的映射区域组成。每个映射内存区域包含已知数量的虚拟内存页。每个区域都有特定的属性来控制诸如继承(该区域的一部分可以从“父”区域映射)、写保护以及它是否连接(也就是说，它不能被分页)。因为区域包含已知的页数，所以它们是页面对齐的，这意味着该区域的起始地址也是页面的起始地址，而结尾地址也定义了页面的结束地址。</p><p>The kernel associates a VM object with each region of the logical address space.<font color="red">内核将VM对象与逻辑地址空间的每个区域关联起来。</font> The kernel uses VM objects to track and manage the resident and nonresident pages of the associated regions.内核使用VM对象跟踪和管理关联区域的驻留页和非驻留页。 A region can map to part of the backing store or to a memory-mapped file in the file system.区域可以映射到备份存储的一部分，或者映射到文件系统中的内存映射文件。 Each VM object contains a map that associates regions with either the default pager or the vnode pager. 每个VM对象都包含一个映射，该映射将区域与默认分页器或vnode分页器关联起来。The default pager is a system manager that manages the nonresident virtual memory pages in the backing store and fetches those pages when requested. 默认分页器是一个系统管理器，它管理后台存储中的非驻留虚拟内存页，并在请求时获取这些页。The vnode pager implements memory-mapped file access. vnode分页器实现内存映射文件访问。The vnode pager uses the paging mechanism to provide a window directly into a file. vnode分页器使用分页机制直接向文件提供一个窗口。This mechanism lets you read and write portions of the file as if they were located in memory.该机制允许您读取和写入文件的部分，就像它们位于内存中一样。</p><p>In addition to mapping regions to either the default or vnode pager, a VM object may also map regions to another VM object. The kernel uses this self referencing technique to implement copy-on-write regions. Copy-on-write regions allow different processes (or multiple blocks of code within a process) to share a page as long as none of them write to that page. When a process attempts to write to the page, a copy of the page is created in the logical address space of the process doing the writing. From that point forward, the writing process maintains its own separate copy of the page, which it can write to at any time. Copy-on-write regions let the system share large quantities of data efficiently in memory while still letting processes manipulate those pages directly (and safely) if needed. These types of regions are most commonly used for the data pages loaded from system frameworks.<br>除了将区域映射到默认或vnode页导航之外，VM对象还可以将区域映射到另一个VM对象。内核使用这种自引用技术来实现写时复制区域。写后复制区域允许不同的进程(或一个进程中的多个代码块)共享一个页面，只要它们中没有一个写入该页。当进程试图写入页面时，将在执行写入操作的进程的逻辑地址空间中创建页面的副本。从那时起，编写过程就维护了它自己的页面的独立拷贝，它可以在任何时候对其进行写入。写后复制区域允许系统在内存中有效地共享大量数据，同时还允许进程在需要时直接(和安全地)操作这些页面。这些类型的区域通常用于从系统框架加载的数据页。<br>每个VM对象包含几个字段，如表1所示。</p><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody><tr><td>Resident pages</td><td>A list of the pages of this region that are currently resident in physical memory.</td></tr><tr><td>Size</td><td>The size of the region, in bytes.</td></tr><tr><td>Pager</td><td>The pager responsible for tracking and handling the pages of this region in backing store.</td></tr><tr><td>Shadow</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Copy</td><td>Used for copy-on-write optimizations.</td></tr><tr><td>Attributes</td><td>Flags indicating the state of various implementation detai<em>**</em>ls.</td></tr></tbody></table><p>If the VM object is involved in a copy-on-write (<code>vm_copy</code>) operation, the shadow and copy fields may point to other VM objects. Otherwise both fields are usually <code>NULL</code>.</p><h2 id="Wired-Memory"><a href="#Wired-Memory" class="headerlink" title="Wired Memory"></a>Wired Memory</h2><p>Wired memory (also called resident memory) stores kernel code and data structures that must never be paged out to disk. Applications, frameworks, and other user-level software cannot allocate wired memory. However, they can affect how much wired memory exists at any time. For example, an application that creates threads and ports implicitly allocates wired memory for the required kernel resources that are associated with them.<br>Wired memory(也称为常驻内存)存储内核代码和数据结构，这些代码和数据结构永远不能被分页到磁盘上。应用程序、框架和其他用户级软件不能分配Wired memory。然而，它们可以影响在任何时候存在多少Wired memory。例如，创建线程和端口的应用程序隐式申请了Wired memory，这些内存是内核资源需要的。</p><p>Table 2 lists some of the wired-memory costs for application-generated entities.</p><table><thead><tr><th>Resource</th><th>Wired Memory Used by Kernel</th></tr></thead><tbody><tr><td>Process</td><td>16 kilobytes</td></tr><tr><td>Thread</td><td>blocked in a continuation—5 kilobytes; blocked—21 kilobyte</td></tr><tr><td>Mach port</td><td>116 bytes</td></tr><tr><td>Mapping</td><td>32 byte</td></tr><tr><td>Library</td><td>2 kilobytes plus 200 bytes for each task that uses it</td></tr><tr><td>Memory region</td><td>160 bytes</td></tr></tbody></table><p>As you can see, every thread, process, and library contributes to the resident footprint of the system. In addition to your application using wired memory, however, the kernel itself requires wired memory for the following entities:<br>如您所见，每个线程、进程和库都会影响系统的驻留内存。但是，除了使用Wired memory的应用程序之外，内核本身的以下实体会使用有线内存:</p><ol><li>VM objects</li><li>the virtual memory buffer cache</li><li>I/O buffer caches</li><li>drivers</li></ol><p>Wired data structures are also associated with the physical page and map tables used to store virtual-memory mapping information, Both of these entities scale with the amount of available physical memory. Consequently, when you add memory to a system, the amount of wired memory increases even if nothing else changes. When a computer is first booted into the Finder, with no other applications running, wired memory can consume approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system.<br>Wired data structures还与物理页面、用于存储虚拟内存映射信息的映射表相关联，这两个实体都与可用物理内存的大小相关联。因此，当您向系统添加内存时，即使没有其他变化，wired-memory的数量也会增加。当一台计算机第一次启动Finder时，没有其他应用程序运行时，在64兆系统中wired-memory可以消耗大约14兆字节 在128兆系统中消耗17兆字节。</p><p>Wired memory pages are not immediately moved back to the free list when they become invalid. Instead they are “garbage collected” when the free-page count falls below the threshold that triggers page out events.<br>Wired memory页在无效时不会立即移回空闲列表。相反，当空闲页面数低于触发page out事件的阈值时，它们会被“垃圾收集”。</p><h2 id="Page-Lists-in-the-Kernel"><a href="#Page-Lists-in-the-Kernel" class="headerlink" title="Page Lists in the Kernel"></a>Page Lists in the Kernel</h2><p>The kernel maintains and queries three system-wide lists of physical memory pages:<br>内核维护和查询三个系统范围的物理内存页列表:。</p><ul><li>The active list contains pages that are currently mapped into memory and have been recently accessed.</li><li>The inactive list contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be removed from memory at any time.</li><li>The free list contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them.</li></ul><ul><li>活动列表包含当前映射到内存和最近访问的页面。</li><li>非活动列表包含当前驻留在物理内存中但最近未被访问的页面。这些页面包含有效的数据，但是可以随时从内存中删除。</li><li>空闲列表包含 没有和任何VM对象关联的物理内存页。任何需要这些页面的进程都可以立即使用这些页面。</li></ul><p>When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list. If a page has been accessed recently, it is reactivated and placed on the end of the active list. In OS X, if an inactive page contains data that has not been written to the backing store recently, its contents must be paged out to disk before it can be placed on the free list. (In iOS, modified but inactive pages must remain in memory and be cleaned up by the application that owns them.) If an inactive page has not been modified and is not permanently resident (wired), it is stolen (any current virtual mappings to it are destroyed) and added to the free list. Once the free list size exceeds the target threshold, the pager rests.<br>当空闲列表中的页面数低于阈值(由物理内存大小决定)时，pager将尝试平衡队列。它通过从非活动列表中提取页面来实现这一点。如果最近访问了某个页面，则重新激活该页面并将其放置在活动列表的末尾。在OS X中，如果一个不活动的页面包含了最近没有写到后台存储的数据，那么在它被放到空闲列表之前，它的内容必须被分页到磁盘上。(在iOS中，修改但不活跃的页面必须保留在内存中，并由拥有它们的应用程序进行清理。) 如果一个不活动的页面没有被修改，并且不是永久驻留(wired)，那么它将被窃取(它的任何当前虚拟映射都将被销毁)并添加到空闲列表中。一旦空闲列表大小超过目标阈值，pager就会停止。</p><p>The kernel moves pages from the active list to the inactive list if they are not accessed; it moves pages from the inactive list to the active list on a soft fault (see Paging In Process). When virtual pages are swapped out, the associated physical pages are placed in the free list. Also, when processes explicitly free memory, the kernel moves the affected pages to the free list.<br>内核将未访问的页面从活动列表移动到非活动列表;通过soft fault将页面从非活动列表移动到活动列表 (请参阅分页In Process)。当虚拟页面交换出去时，相关的物理页面被放在空闲列表中。此外，当进程显式地释放内存时，内核将受影响的页面移动到空闲列表。</p><h2 id="Paging-Out-Process"><a href="#Paging-Out-Process" class="headerlink" title="Paging Out Process"></a>Paging Out Process</h2><p>In OS X, when the number of pages in the free list dips below a computed threshold, the kernel reclaims physical pages for the free list by swapping inactive pages out of memory. To do this, the kernel iterates all resident pages in the active and inactive lists, performing the following steps:</p><ol><li>If a page in the active list is not recently touched, it is moved to the inactive list.</li><li>If a page in the inactive list is not recently touched, the kernel finds the page’s VM object.</li><li>If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object.</li><li>The VM object’s default pager attempts to write the page out to the backing store.</li><li>If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list.</li></ol><p>在OS X中，当空闲列表中的页面数量低于计算的阈值时，内核通过将不活动的页面从内存中交换出来，从而回收空闲列表的物理页面。为此，内核遍历活动和非活动列表中的所有驻留页面，执行以下步骤:</p><ol><li>如果活动列表中的某个页面最近未被触摸，它将被移到非活动列表。</li><li>如果非活动列表中的一个页面最近没有被使用，内核将找到页面的VM对象。</li><li>如果VM对象以前从未被分页，那么内核将调用一个初始化例程，该例程创建并分配一个默认的分页器对象。</li><li>VM对象的默认分页器尝试将页面写到后台存储。</li><li>如果pager成功，内核释放页面占用的物理内存，并将页面从非活动列表移动到空闲列表。</li></ol><h2 id="Paging-In-Process"><a href="#Paging-In-Process" class="headerlink" title="Paging In Process"></a>Paging In Process</h2><p>The final phase of virtual memory management moves pages into physical memory, either from the backing store or from the file containing the page data. A memory access fault initiates the page-in process. A memory access fault occurs when code tries to access data at a virtual address that is not mapped to physical memory. There are two kinds of faults:<br>虚拟内存管理的最后一个阶段是将页面移动到物理内存中，或者从后台存储区，或者从包含页面数据的文件中。内存访问错误启动page-in进程。当代码试图访问没有映射到物理内存的虚拟地址中的数据时，会发生内存访问错误。有两种错误:</p><ol><li>A soft fault occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process.</li><li><p>A hard fault occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault.</p></li><li><p>soft fault：当引用地址的页驻留在物理内存中，但当前没有映射到此进程的地址空间时，就会发生此错误。</p></li><li>hard fault：当引用地址的页面不在物理内存中，而是被交换到后备存储器(或从映射文件中可用)时，就会出现。这就是通常所说的页面错误。</li></ol><p>When any type of fault occurs, the kernel locates the map entry and VM object for the accessed region. The kernel then goes through the VM object’s list of resident pages. If the desired page is in the list of resident pages, the kernel generates a soft fault. If the page is not in the list of resident pages, it generates a hard fault.<br>当发生任何类型的错误时，内核为被访问区域定位映射条目和VM对象。内核然后遍历VM对象的常驻页面列表。如果希望的页面位于驻留页面的列表中，内核会生成一个软错误。如果页面不在常驻页面列表中，则会产生硬错误。</p><p>For soft faults, the kernel maps the physical memory containing the pages to the virtual address space of the process. The kernel then marks the specific page as active. If the fault involved a write operation, the page is also marked as modified so that it will be written to backing store if it needs to be freed later.<br>对于软故障，内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将特定页面标记为活动页面。如果该错误涉及到写操作，那么该页面也会被标记为修改，以便在以后需要释放时写入到后备存储器中。</p><p>For hard faults, the VM object’s pager finds the page in the backing store or from the file on disk, depending on the type of pager. After making the appropriate adjustments to the map information, the pager moves the page into physical memory and places the page on the active list. As with a soft fault, if the fault involved a write operation, the page is marked as modified.<br>对于硬故障，VM对象的寻呼机根据寻呼机的类型在备份存储中或从磁盘上的文件中查找页面。在对映射信息进行适当的调整之后，寻呼机将页面移动到物理内存中，并将页面放在活动列表中。与软错误一样，如果错误涉及写操作，则将页面标记为已修改。</p><h2 id="名称解释"><a href="#名称解释" class="headerlink" title="名称解释"></a>名称解释</h2><p>Mac的内存使用：Wired, Active, Inactive和Free</p><ul><li>Wired(联动): 系统核心占用的，永远不会从系统物【[内存】中去除。</li><li>Active(活跃): 表示这些内存数据正在使用种，或者刚被使用过。</li><li>Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。</li><li>Free(可用空间): 表示这些内存中的数据是无效的，即内存剩余量！</li></ul><p>当Free的【内存】低于某个key值时，这个key值是由你的物理内存大小决定的，系统则会按照以下顺序使用Inactive的资源。</p><ul><li>首先，如果Inactive的数据最近被调用了，系统会把它们的状态改变成Active,并且在原有Active内存逻辑地址的后面；</li><li>其次，如果Inactive的内存数据最近没有被使用过，但是曾经被更改过，而还没有在硬盘的相应虚拟[内存]中做修改，系统会对相应硬盘的虚拟内存做修改，并把这部分物理内存释放为free供程序使用。</li><li>再次，如果inactive[内存]中得数据被在映射到硬盘后再没有被更改过，则直接释放成free。</li><li>最后如果active的内存一段时间没有被使用，会被暂时改变状态为inactive。</li></ul><p>　　所以，如果你的系统里有少量的free memeory和大量的inactive的memeory，说明你的内存是够用的，系统运行在最佳状态，只要需要,系统就会使用它们，不用担心。</p><pre><code>如果系统的free memory和inactive memory都很少，而active memory很多，说明你的[内存]不够了。当然一开机，大部分[内存]都是free,这时系统反而不在最佳状态，因为很多数据都需要从硬盘调用，速度反而慢了。</code></pre><h4 id="Free-memory"><a href="#Free-memory" class="headerlink" title="Free memory"></a>Free memory</h4><p>This is RAM that’s not being used.</p><h4 id="Wired-memory"><a href="#Wired-memory" class="headerlink" title="Wired memory"></a>Wired memory</h4><p>Information in this memory can’t be moved to the hard disk, so it must stay in RAM. The amount of Wired memory depends on the applications you are using.</p><h4 id="Active-memory"><a href="#Active-memory" class="headerlink" title="Active memory"></a>Active memory</h4><p>This information is currently in memory, and has been recently used.</p><h4 id="Inactive-memory"><a href="#Inactive-memory" class="headerlink" title="Inactive memory"></a>Inactive memory</h4><p>This information in memory is not actively being used, but was recently used.</p><p>For example, if you’ve been using Mail and then quit it, the RAM that Mail was using is marked as Inactive memory. This Inactive memory is available for use by another application, just like Free memory.  However, if you open Mail before its Inactive memory is used by a different application, Mail will open quicker because its Inactive memory is converted to Active memory, instead of loading Mail from the slower hard disk.</p><h4 id="Used"><a href="#Used" class="headerlink" title="Used"></a>Used</h4><p>This is the total amount of memory used.</p><h4 id="VM-size"><a href="#VM-size" class="headerlink" title="VM size"></a>VM size</h4><p>This is the total amount of Virtual Memory for all processes on your Mac. </p><h4 id="Page-ins-Page-outs"><a href="#Page-ins-Page-outs" class="headerlink" title="Page ins / Page outs"></a>Page ins / Page outs</h4><p>This refers to the amount of information moved between RAM and the hard disk. This number is a cumulative amount of data that Mac OS X has moved between RAM and disk space.</p><p>Tip: Page outs occur when your Mac has to write information from RAM to the hard drive (because RAM is full).  Adding more RAM may reduce page outs.</p><h4 id="Swap-used"><a href="#Swap-used" class="headerlink" title="Swap used"></a>Swap used</h4><p>This is the amount of information copied to the swap file on your hard drive.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译下&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Memory Usage Performance Guidelines&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="虚拟内存" scheme="http://yoursite.com/categories/IOS/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    
      <category term="虚拟内存1" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%981/"/>
    
  </entry>
  
</feed>
