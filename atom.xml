<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-06T10:16:38.060Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>18. @synchronized</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/18_syncsize/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/18_syncsize/</id>
    <published>2018-12-06T02:38:11.000Z</published>
    <updated>2018-12-06T10:16:38.060Z</updated>
    
    <content type="html"><![CDATA[<p>@synchronized  内幕揭秘</p><a id="more"></a><h2 id="synchronized揭秘"><a href="#synchronized揭秘" class="headerlink" title="@synchronized揭秘"></a>@synchronized揭秘</h2><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        AXPerson * p = [AXPerson <span class="keyword">new</span>];</span><br><span class="line">        <span class="meta">@synchronized</span> (p) &#123;</span><br><span class="line">            NSLog(@<span class="string">"p is @synchronized"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写为C++：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123; __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">        AXPerson * p = ((AXPerson *(*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *)objc_msgSend)((<span class="keyword">id</span>)objc_getClass(<span class="string">"AXPerson"</span>), sel_registerName(<span class="string">"new"</span>));</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">id</span> _sync_obj = (<span class="keyword">id</span>)p;</span><br><span class="line">            objc_sync_enter(_sync_obj);  </span><br><span class="line">            <span class="keyword">struct</span> _SYNC_EXIT &#123;</span><br><span class="line">                _SYNC_EXIT(<span class="keyword">id</span> arg) : sync_exit(arg) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">                ~_SYNC_EXIT() &#123; <span class="comment">// 析构函数，析构的时候会自动释放锁</span></span><br><span class="line">                    objc_sync_exit(sync_exit); </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">id</span> sync_exit; <span class="comment">// 成员变量</span></span><br><span class="line">            &#125;</span><br><span class="line">            _sync_exit(_sync_obj);  </span><br><span class="line">            <span class="built_in">NSLog</span>((<span class="built_in">NSString</span> *)&amp;__NSConstantStringImpl__var_folders_cp_sc2q63f937j88dcxp23f471w0000gn_T_main_3c34e3_mi_0);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一步步分析代码 </p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id _sync_obj = (<span class="name">id</span>)p<span class="comment">;</span></span><br><span class="line">objc_sync_enter(<span class="name">_sync_obj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>将上锁的对象p赋值给_sync_obj ， 调用objc_sync_enter函数，实参传递_sync_obj, objc_sync_enter函数就相当于上锁。后面详细分析</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">_SYNC_EXIT</span> &#123;</span><br><span class="line">    <span class="selector-tag">_SYNC_EXIT</span>(id arg) : <span class="selector-tag">sync_exit</span>(arg) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">    ~<span class="selector-tag">_SYNC_EXIT</span>() &#123; <span class="comment">// 析构函数，析构的时候会自动释放锁</span></span><br><span class="line">        <span class="selector-tag">objc_sync_exit</span>(sync_exit); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">id</span> <span class="selector-tag">sync_exit</span>; <span class="comment">// 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">_sync_exit</span>(_sync_obj);</span><br></pre></td></tr></table></figure><p>这不是一个单独的语句，注意看结构体的右大括号后面并没有分号，所以 _sync_exit(_sync_obj) 是跟在 _SYNC_EXIT 结构体后面的，即它声明了一个名为 _sync_exit 的结构体对象。</p><p>_sync_exit对象的的析构函数里面调用了objc_sync_exit函数。这个函数相当于解锁。 析构函数在_sync_exit释放的时候调用。也就是作用域结束的时候调用。</p><p>所以， <code>@synchronized (p)</code> 相当于  新建了一个作用域，在作用域开始的时候，调用objc_sync_enter函数，实参是p，作用域结束的时候，自动调用析构函数objc_sync_exit，解锁。</p><h2 id="synchronized数据结构"><a href="#synchronized数据结构" class="headerlink" title="@synchronized数据结构"></a>@synchronized数据结构</h2><p>@synchronized 相关的数据结构，安装存储的位置划分，有两种：</p><ol><li>线程内部存储的数据。</li><li>全局数据，用来线程间共享。</li></ol><p>后面会分析这两种数据的相互关系。</p><p>线程内部：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span> &#123;</span> <span class="comment">// 同步数据结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SyncData</span>* <span class="title">nextData</span>;</span> <span class="comment">// 指向下一个 SyncData，看来是链表</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; object; <span class="comment">// 锁住的对象</span></span><br><span class="line">    <span class="keyword">int32_t</span> threadCount;  <span class="comment">// 使用这个block(???)的线程数  number of THREADS using this block</span></span><br><span class="line">    <span class="keyword">recursive_mutex_t</span> mutex; <span class="comment">// 递归锁</span></span><br><span class="line">&#125; SyncData;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    SyncData *data;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lockCount;  <span class="comment">// number of times THIS THREAD locked this block</span></span><br><span class="line">&#125; SyncCacheItem;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SyncCache</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> allocated;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> used;</span><br><span class="line">    SyncCacheItem <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line">&#125; SyncCache;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/threadInData.png" alt="线程内STL数据"></p><p>全局数据定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">struct</span> <span class="type">SyncList</span> &#123;</span><br><span class="line">    <span class="type">SyncData</span> *<span class="class"><span class="keyword">data</span>;</span></span><br><span class="line">    spinlock_t lock; // 自旋锁</span><br><span class="line"></span><br><span class="line">    <span class="type">SyncList</span>() : <span class="class"><span class="keyword">data</span>(<span class="title">nil</span>) &#123; &#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/thread_out_data.png" alt="全局锁数据"></p><h2 id="synchronized源码分析"><a href="#synchronized源码分析" class="headerlink" title="@synchronized源码分析"></a>@synchronized源码分析</h2><p>@synchronized 相关的API有两个：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int objc_sync_enter(<span class="name">id</span> obj)</span><br><span class="line">int objc_sync_exit(<span class="name">id</span> obj)</span><br></pre></td></tr></table></figure><h3 id="objc-sync-enter"><a href="#objc-sync-enter" class="headerlink" title="objc_sync_enter"></a>objc_sync_enter</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> objc_sync_enter(id obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS; <span class="comment">// 用来记录结果，默认成功</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj) &#123; <span class="comment">// obj 必须非空，</span></span><br><span class="line">        SyncData* data = id2data(obj, ACQUIRE); <span class="comment">// 为 obj 对象绑定一个递归锁</span></span><br><span class="line">        <span class="keyword">assert</span>(data);</span><br><span class="line">        data-&gt;mutex.lock(); <span class="comment">// 递归锁加锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 否则 @synchronized 啥也不干</span></span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">        <span class="keyword">if</span> (DebugNilSync) &#123;</span><br><span class="line">            _objc_inform(<span class="string">"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        objc_sync_nil();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了id2data函数，取出所对象，上锁。</p><h3 id="objc-sync-exit"><a href="#objc-sync-exit" class="headerlink" title="objc_sync_exit"></a>objc_sync_exit</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = OBJC_SYNC_SUCCESS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">        SyncData* data = id2data(obj, RELEASE); <span class="comment">// 为 obj 解绑递归锁</span></span><br><span class="line">        <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; <span class="comment">// 压根儿没有 objc_sync_enter 过</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">bool</span> okay = data-&gt;mutex.tryUnlock(); <span class="comment">// 尝试解锁</span></span><br><span class="line">            <span class="keyword">if</span> (!okay) &#123;</span><br><span class="line">                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; <span class="comment">// 解锁失败</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// @synchronized(nil) does nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过id2data取出锁对象，解锁。</p><p>所以关键锁对象建模都在id2data函数中。这个函数顾名思义，就是将id类型的对象转化为锁数据。</p><h3 id="id2data"><a href="#id2data" class="headerlink" title="id2data"></a>id2data</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">static SyncData* id2data(id object, enum usage why)</span><br><span class="line">&#123;</span><br><span class="line">    spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">    SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br><span class="line">    SyncData* result = NULL;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Check per-thread cache of already-owned locks for matching object</span></span><br><span class="line">    SyncCache *cache = fetch_cache(NO);</span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        unsigned int i;</span><br><span class="line">        <span class="function"><span class="title">for</span> (i = 0; i &lt; cache-&gt;</span>used; i++) &#123;</span><br><span class="line">            S<span class="function"><span class="title">yncCacheItem</span> *item = &amp;cache-&gt;</span>list[i];</span><br><span class="line">            <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">data</span>-&gt;</span>object != object) continue;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Found a match.</span></span><br><span class="line">            <span class="function"><span class="title">result</span> = item-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">            <span class="function"><span class="title">if</span> (result-&gt;</span><span class="function"><span class="title">threadCount</span> &lt;= 0  ||  item-&gt;</span>lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            switch(why) &#123;</span><br><span class="line">            case ACQUIRE:</span><br><span class="line">                <span class="function"><span class="title">item</span>-&gt;</span>lockCount++;</span><br><span class="line">                break;</span><br><span class="line">            case RELEASE:</span><br><span class="line">                <span class="function"><span class="title">item</span>-&gt;</span>lockCount--;</span><br><span class="line">                <span class="function"><span class="title">if</span> (item-&gt;</span>lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                    <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[i] = cache-&gt;</span><span class="function"><span class="title">list</span>[--cache-&gt;</span>used];</span><br><span class="line">                    <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                    OSA<span class="function"><span class="title">tomicDecrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case CHECK:</span><br><span class="line">                <span class="comment">// do nothing</span></span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thread cache didn't find anything.</span></span><br><span class="line">    <span class="comment">// Walk in-use list looking for matching object</span></span><br><span class="line">    <span class="comment">// Spinlock prevents multiple threads from creating multiple </span></span><br><span class="line">    <span class="comment">// locks for the same new object.</span></span><br><span class="line">    <span class="comment">// We could keep the nodes in some hash table if we find that there are</span></span><br><span class="line">    <span class="comment">// more than 20 or so distinct locks active, but we don't do that now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">lockp</span>-&gt;</span>lock();</span><br><span class="line">    &#123;</span><br><span class="line">        SyncData* p;</span><br><span class="line">        SyncData* firstUnused = NULL;</span><br><span class="line">        <span class="function"><span class="title">for</span> (p = *listp; p != NULL; p = p-&gt;</span>nextData) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> ( p-&gt;</span>object == object ) &#123;</span><br><span class="line">                result = p;</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">                OSA<span class="function"><span class="title">tomicIncrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">                goto done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="title">if</span> ( (firstUnused == NULL) &amp;&amp; (p-&gt;</span>threadCount == <span class="number">0</span>) )</span><br><span class="line">                firstUnused = p;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// no SyncData currently associated with object</span></span><br><span class="line">        <span class="keyword">if</span> ( (why == RELEASE) || (why == CHECK) )</span><br><span class="line">            goto done;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// an unused one was found, use it</span></span><br><span class="line">        <span class="keyword">if</span> ( firstUnused != NULL ) &#123;</span><br><span class="line">            result = firstUnused;</span><br><span class="line">            <span class="function"><span class="title">result</span>-&gt;</span>object = (objc_object *)object;</span><br><span class="line">            <span class="function"><span class="title">result</span>-&gt;</span>threadCount = <span class="number">1</span>;</span><br><span class="line">            goto done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// malloc a new SyncData and add to list.</span></span><br><span class="line">    <span class="comment">// XXX calling malloc with a global lock held is bad practice,</span></span><br><span class="line">    <span class="comment">// might be worth releasing the lock, mallocing, and searching again.</span></span><br><span class="line">    <span class="comment">// But since we never free these guys we won't be stuck in malloc very often.</span></span><br><span class="line">    result = (SyncData*)calloc(sizeof(SyncData), <span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>object = (objc_object *)object;</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="title">new</span> (&amp;result-&gt;</span>mutex) recursive_mutex_t();</span><br><span class="line">    <span class="function"><span class="title">result</span>-&gt;</span>nextData = *listp;</span><br><span class="line">    *listp = result;</span><br><span class="line">    </span><br><span class="line"> done:</span><br><span class="line">    <span class="function"><span class="title">lockp</span>-&gt;</span>unlock();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="comment">// Only new ACQUIRE should get here.</span></span><br><span class="line">        <span class="comment">// All RELEASE and CHECK and recursive ACQUIRE are </span></span><br><span class="line">        <span class="comment">// handled by the per-thread caches above.</span></span><br><span class="line">        <span class="keyword">if</span> (why == RELEASE) &#123;</span><br><span class="line">            <span class="comment">// Probably some thread is incorrectly exiting </span></span><br><span class="line">            <span class="comment">// while the object is held by another thread.</span></span><br><span class="line">            return <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (why != ACQUIRE) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        <span class="function"><span class="title">if</span> (result-&gt;</span>object != object) _objc_fatal(<span class="string">"id2data is buggy"</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// Save in thread cache</span></span><br><span class="line">            <span class="keyword">if</span> (!cache) cache = fetch_cache(YES);</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[cache-&gt;</span>used].<span class="keyword">data</span> = result;</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[cache-&gt;</span>used].lockCount = <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="title">cache</span>-&gt;</span>used++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">LOCK_FOR_OBJ</span>(<span class="selector-tag">obj</span>) <span class="selector-tag">sDataLists</span><span class="selector-attr">[obj]</span><span class="selector-class">.lock</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">LIST_FOR_OBJ</span>(<span class="selector-tag">obj</span>) <span class="selector-tag">sDataLists</span><span class="selector-attr">[obj]</span><span class="selector-class">.data</span></span><br><span class="line"><span class="selector-tag">static</span> <span class="selector-tag">StripedMap</span>&lt;<span class="selector-tag">SyncList</span>&gt; <span class="selector-tag">sDataLists</span>;</span><br></pre></td></tr></table></figure><p>整个代码可以分为2种情况：</p><ol><li>当前线程的TLS已经有对象object的数据 ：直接对锁的次数lockCount累加.</li><li>当前的线程里面没有，说明object在这个线程第一次上锁，那么也分两种情况，一种情况是：这个对象在所有线程中第一次上锁，那么，新建锁对象数据SyncData，然后将线程数threadCount赋值为1.  数据另一种情况是，这个对象在其他的线程中上过锁，那么从全局数据sDataLists中取出锁数据listp，将线程数累加。  因为这两种情况都是第一次进入这个线程，所以，执行完上面的操作，需要将锁数据result添加到线程TLS中。</li></ol><p>下面放置了一张图，方便理解 。图的上面是全局数据结构，是个链表，因为全局的数据比较多。所以使用高效的链表作为基本数据结构。中间是线程内部的数据结构，对于某个线程，锁没有全局的多，所以使用简单的数据结构数组。下面部分是这段代码的基本逻辑。</p><p><img src="/wiki/IOS/Runtime/objc/18_syncsize/sync流程.png" alt="加锁流程"></p><p>拆分理解三种情况：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> SyncCache *cache = fetch_cache(NO);</span><br><span class="line"><span class="keyword">if</span> (cache) &#123;</span><br><span class="line">    unsigned int i;</span><br><span class="line">    <span class="function"><span class="title">for</span> (i = 0; i &lt; cache-&gt;</span>used; i++) &#123;</span><br><span class="line">        S<span class="function"><span class="title">yncCacheItem</span> *item = &amp;cache-&gt;</span>list[i];</span><br><span class="line">        <span class="function"><span class="title">if</span> (item-&gt;</span><span class="function"><span class="title">data</span>-&gt;</span>object != object) continue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Found a match.</span></span><br><span class="line">        <span class="function"><span class="title">result</span> = item-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">if</span> (result-&gt;</span><span class="function"><span class="title">threadCount</span> &lt;= 0  ||  item-&gt;</span>lockCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"id2data cache is buggy"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        switch(why) &#123;</span><br><span class="line">        case ACQUIRE:</span><br><span class="line">            <span class="function"><span class="title">item</span>-&gt;</span>lockCount++;</span><br><span class="line">            break;</span><br><span class="line">        case RELEASE:</span><br><span class="line">            <span class="function"><span class="title">item</span>-&gt;</span>lockCount--;</span><br><span class="line">            <span class="function"><span class="title">if</span> (item-&gt;</span>lockCount == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// remove from per-thread cache</span></span><br><span class="line">                <span class="function"><span class="title">cache</span>-&gt;</span><span class="function"><span class="title">list</span>[i] = cache-&gt;</span><span class="function"><span class="title">list</span>[--cache-&gt;</span>used];</span><br><span class="line">                <span class="comment">// atomic because may collide with concurrent ACQUIRE</span></span><br><span class="line">                OSA<span class="function"><span class="title">tomicDecrement32Barrier</span>(&amp;result-&gt;</span>threadCount);</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        case CHECK:</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是第一种情况，上锁情况累加lockCount，解锁情况递减lockCount。如果lockCount为0 ，清楚数据。如果符合这种情况，就直接返回了。 下面的代码都属于第二种情况。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SyncData* p;</span><br><span class="line">SyncData* firstUnused = <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (p = *listp; p != <span class="keyword">NULL</span>; p = p-&gt;nextData) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( p-&gt;object == object ) &#123;</span><br><span class="line">        result = p;</span><br><span class="line">        <span class="comment">// atomic because may collide with concurrent RELEASE</span></span><br><span class="line">        OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (firstUnused == <span class="keyword">NULL</span>) &amp;&amp; (p-&gt;threadCount == <span class="number">0</span>) )</span><br><span class="line">        firstUnused = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码是对象的锁数据在全局数据中找到了。直接递增threadCount。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// an unused one was found, use it</span></span><br><span class="line"><span class="keyword">if</span> ( firstUnused != <span class="keyword">NULL</span> ) &#123;</span><br><span class="line">    result = firstUnused;</span><br><span class="line">    result-&gt;object = (objc_object *)object;</span><br><span class="line">    result-&gt;threadCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，但是在全局数据中找到了空的result，直接赋值threadCount为1。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = (<span class="name">SyncData*</span>)calloc(<span class="name">sizeof</span>(<span class="name">SyncData</span>), <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">result-&gt;object = (<span class="name">objc_object</span> *)object;</span><br><span class="line">result-&gt;threadCount = 1;</span><br><span class="line">new (&amp;result-&gt;mutex) recursive_mutex_t();</span><br><span class="line">result-&gt;nextData = *listp<span class="comment">;</span></span><br><span class="line">*listp = result;</span><br></pre></td></tr></table></figure><p>这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，并且在全局数据中没有找到空的SyncData。直接创建，添加到链表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (!<span class="keyword">cache</span>) <span class="keyword">cache</span> = fetch_cache(YES);</span><br><span class="line"><span class="keyword">cache</span>-&gt;<span class="keyword">list</span>[<span class="keyword">cache</span>-&gt;used].data = <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">cache</span>-&gt;<span class="keyword">list</span>[<span class="keyword">cache</span>-&gt;used].lockCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">cache</span>-&gt;used++;</span><br></pre></td></tr></table></figure><p>这段代码是第二种情况的最后一步，以为第二种情况都是第一次进入改线程，所以需要将创建或者以后的锁数据result添加到线程数据TLS中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>@synchronized 就是在作用开始的时候，调用objc_sync_enter 函数，用对象创建出了锁数据SyncData，并上锁 。 当作用域结束的时候，调用objc_sync_exit 解锁，使用的锁是递归锁，在同一个线程中可以重入。所以，对同一个对象嵌套使用@synchronized，不会死锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;@synchronized  内幕揭秘&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
  </entry>
  
  <entry>
    <title>16. retain 和 release（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/16_retain_release/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/16_retain_release/</id>
    <published>2018-12-04T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:10.984Z</updated>
    
    <content type="html"><![CDATA[<p>在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 <code>retain</code> 和减少引用计数的 <code>release</code> 方法。</p><p>这篇文章会在源代码层面介绍 Objective-C 中 <code>retain</code> 和 <code>release</code> 的实现，它们是如何达到平衡的。</p><a id="more"></a><h2 id="从-retain-开始"><a href="#从-retain-开始" class="headerlink" title="从 retain 开始"></a>从 retain 开始</h2><p>如今我们已经进入了全面使用 ARC 的时代，几年前还经常使用的 <code>retain</code> 和 <code>release</code> 方法已经很难出现于我们的视野中了，绝大多数内存管理的实现细节都由编译器代劳。</p><p>在这里，我们还要从 <code>retain</code> 方法开始，对内存管理的实现细节一探究竟。</p><p>下面是 <code>retain</code> 方法的调用栈：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- [NSObject retain]</span><br><span class="line">└── id objc_object::rootRetain()</span><br><span class="line">    └── id objc_object::rootRetain(<span class="keyword">bool </span>tryRetain, <span class="keyword">bool </span>handleOverflow)</span><br><span class="line">        ├── uintptr_t LoadExclusive(uintptr_t *src)</span><br><span class="line">        ├── uintptr_t <span class="keyword">addc(uintptr_t </span><span class="keyword">lhs, </span>uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br><span class="line">        ├── uintptr_t <span class="keyword">bits</span></span><br><span class="line"><span class="keyword"> </span>       │   └── uintptr_t has_sidetable_rc  </span><br><span class="line">        ├── <span class="keyword">bool </span>StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value)</span><br><span class="line">        └── <span class="keyword">bool </span>objc_object::sidetable_addExtraRC_nolock(size_t delta_rc)                </span><br><span class="line">            └── uintptr_t <span class="keyword">addc(uintptr_t </span><span class="keyword">lhs, </span>uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout)</span><br></pre></td></tr></table></figure><p>调用栈中的前两个方法的实现直接调用了下一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> objc_object::rootRetain() &#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>id objc_object::rootRetain(bool tryRetain, bool handleOverflow)</code> 方法是调用栈中最重要的方法，其原理就是将 <code>isa</code> 结构体中的 <code>extra_rc</code> 的值加一。</p><p><code>extra_rc</code> 就是用于保存自动引用计数的标志位，下面就是 <code>isa</code> 结构体中的结构：</p><p><img src="/wiki/IOS/Runtime/objc/16_retain_release/objc-rr-isa-struct.png" alt="objc-rr-isa-struct"></p><p>接下来我们会分三种情况对 <code>rootRetain</code> 进行分析。</p><h3 id="正常的-rootRetain"><a href="#正常的-rootRetain" class="headerlink" title="正常的 rootRetain"></a>正常的 rootRetain</h3><p>这是简化后的 <code>rootRetain</code> 方法的实现，其中只有处理一般情况的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">id objc_object:<span class="type"></span>:rootRetain(bool tryRetain, bool handleOverflow) &#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line"></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = addc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里我们假设的条件是 <code>isa</code> 中的 <code>extra_rc</code> 的位数足以存储 <code>retainCount</code>。</p></blockquote><ol><li>使用 <code>LoadExclusive</code> 加载 <code>isa</code> 的值</li><li>调用 <code>addc(newisa.bits, RC_ONE, 0, &amp;carry)</code> 方法将 <code>isa</code> 的值加一</li><li>调用 <code>StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)</code> 更新 <code>isa</code> 的值</li><li>返回当前对象</li></ol><h3 id="有进位版本的-rootRetain"><a href="#有进位版本的-rootRetain" class="headerlink" title="有进位版本的 rootRetain"></a>有进位版本的 rootRetain</h3><p>在这里调用 <code>addc</code> 方法为 <code>extra_rc</code> 加一时，8 位的 <code>extra_rc</code> 可能不足以保存引用计数。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id objc_object::rootRetain(<span class="keyword">bool </span>tryRetain, <span class="keyword">bool </span>handleOverflow) &#123;</span><br><span class="line">    transcribeToSideTable = false<span class="comment">;</span></span><br><span class="line">    isa_t oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>   isa_t newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    uintptr_t carry<span class="comment">;</span></span><br><span class="line">    newisa.<span class="keyword">bits </span>= <span class="keyword">addc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (carry &amp;&amp; !handleOverflow)</span><br><span class="line">        return rootRetain_overflow(tryRetain)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>extra_rc</code> 不足以保存引用计数，并且 <code>handleOverflow = false</code>。</p></blockquote><p>当方法传入的 <code>handleOverflow = false</code> 时（这也是通常情况），我们会调用 <code>rootRetain_overflow</code> 方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id objc_object::rootRetain_overflow(<span class="keyword">bool</span> tryRetain) &#123;</span><br><span class="line">    <span class="keyword">return</span> rootRetain(tryRetain, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实就是重新执行 <code>rootRetain</code> 方法，并传入 <code>handleOverflow = true</code>。</p><h3 id="有进位版本的-rootRetain（处理溢出）"><a href="#有进位版本的-rootRetain（处理溢出）" class="headerlink" title="有进位版本的 rootRetain（处理溢出）"></a>有进位版本的 rootRetain（处理溢出）</h3><p>当传入的 <code>handleOverflow = true</code> 时，我们就会在 <code>rootRetain</code> 方法中处理引用计数的溢出。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">id objc_object:<span class="type"></span>:rootRetain(bool tryRetain, bool handleOverflow) &#123;</span><br><span class="line">    bool sideTableLocked = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = addc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">            <span class="keyword">new</span><span class="type">isa</span>.extra_rc = RC_HALF;</span><br><span class="line">            <span class="keyword">new</span><span class="type">isa</span>.has_sidetable_rc = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    sidetable_addExtraRC_nolock(RC_HALF);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用这个方法，并且 <code>handleOverflow = true</code> 时，我们就可以确定 <code>carry</code> 一定是存在的了，</p><p>因为 <code>extra_rc</code> 已经溢出了，所以要更新它的值为 <code>RC_HALF</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF (1ULL&lt;&lt;7)</span></span><br></pre></td></tr></table></figure><blockquote><p><code>extra_rc</code> 总共为 8 位，<code>RC_HALF = 0b10000000</code>。</p></blockquote><p>然后设置 <code>has_sidetable_rc</code> 为真，存储新的 <code>isa</code> 的值之后，调用 <code>sidetable_addExtraRC_nolock</code> 方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> objc_object::sidetable_addExtraRC_nolock(<span class="keyword">size_t</span> delta_rc) &#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>];</span><br><span class="line">    <span class="keyword">size_t</span> oldRefcnt = refcntStorage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> carry;</span><br><span class="line">    <span class="keyword">size_t</span> newRefcnt = </span><br><span class="line">        addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, <span class="number">0</span>, &amp;carry);</span><br><span class="line">    <span class="keyword">if</span> (carry) &#123;</span><br><span class="line">        refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        refcntStorage = newRefcnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将溢出的一位 <code>RC_HALF</code> 添加到 <code>oldRefcnt</code> 中，其中的各种 <code>SIDE_TABLE</code> 宏定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_DEALLOCATING      (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_ONE            (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_PINNED         (1UL&lt;&lt;(WORD_BITS-1))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_RC_SHIFT 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1)</span></span><br></pre></td></tr></table></figure><p>因为 <code>refcnts</code> 中的 64 为的最低两位是有意义的标志位，所以在使用 <code>addc</code> 时要将 <code>delta_rc</code> 左移两位，获得一个新的引用计数 <code>newRefcnt</code>。</p><p>如果这时出现了溢出，那么就会撤销这次的行为。否则，会将新的引用计数存储到 <code>refcntStorage</code> 指针中。</p><hr><p>也就是说，在 iOS 的内存管理中，我们使用了 <code>isa</code> 结构体中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储某个对象的自动引用计数。</p><p>更重要的是，<strong>如果自动引用计数为 1，<code>extra_rc</code> 实际上为 0</strong>，因为它保存的是额外的引用计数，我们通过这个行为能够减少很多不必要的函数调用。</p><p>到目前为止，我们已经从头梳理了 <code>retain</code> 方法的调用栈及其实现。下面要介绍的是在内存管理中，我们是如何使用 <code>release</code> 方法平衡这个方法的。</p><h2 id="以-release-结束"><a href="#以-release-结束" class="headerlink" title="以 release 结束"></a>以 release 结束</h2><p>与 release 方法相似，我们看一下这个方法简化后的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> release]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootRelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootRetain(<span class="keyword">bool</span> performDealloc, <span class="keyword">bool</span> handleUnderflow)</span><br></pre></td></tr></table></figure><p>前面的两个方法的实现和 <code>retain</code> 中的相差无几，这里就直接跳过了。</p><p>同样，在分析 <code>release</code> 方法时，我们也根据上下文的不同，将 <code>release</code> 方法的实现拆分为三部分，说明它到底是如何调用的。</p><h3 id="正常的-release"><a href="#正常的-release" class="headerlink" title="正常的 release"></a>正常的 release</h3><p>这一个版本的方法调用可以说是最简版本的方法调用了：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>objc_object::rootRelease(<span class="keyword">bool </span>performDealloc, <span class="keyword">bool </span>handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa<span class="comment">;</span></span><br><span class="line">    isa_t newisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>       newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        uintptr_t carry<span class="comment">;</span></span><br><span class="line">        newisa.<span class="keyword">bits </span>= <span class="keyword">subc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line">    &#125; while (!StoreReleaseExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits));</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>   return false<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>LoadExclusive</code> 获取 <code>isa</code> 内容</li><li>将 <code>isa</code> 中的引用计数减一</li><li>调用 <code>StoreReleaseExclusive</code> 方法保存新的 <code>isa</code></li></ol><h3 id="从-SideTable-借位"><a href="#从-SideTable-借位" class="headerlink" title="从 SideTable 借位"></a>从 SideTable 借位</h3><p>接下来，我们就要看两种相对比较复杂的情况了，首先是从 <code>SideTable</code> 借位的版本：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span>objc_object::rootRelease(<span class="keyword">bool </span>performDealloc, <span class="keyword">bool </span>handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa<span class="comment">;</span></span><br><span class="line">    isa_t newisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"> </span>       newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        uintptr_t carry<span class="comment">;</span></span><br><span class="line">        newisa.<span class="keyword">bits </span>= <span class="keyword">subc(newisa.bits, </span>RC_ONE, <span class="number">0</span>, &amp;carry)<span class="comment">;</span></span><br><span class="line">        if (carry) goto underflow<span class="comment">;</span></span><br><span class="line">    &#125; while (!StoreReleaseExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits));</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="symbol"> underflow:</span></span><br><span class="line">    newisa = oldisa<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (newisa.has_sidetable_rc) &#123;</span><br><span class="line">        if (!handleUnderflow) &#123;</span><br><span class="line">            return rootRelease_underflow(performDealloc)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t <span class="keyword">borrowed </span>= sidetable_subExtraRC_nolock(RC_HALF)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">        if (<span class="keyword">borrowed </span>&gt; <span class="number">0</span>) &#123;</span><br><span class="line">            newisa.<span class="keyword">extra_rc </span>= <span class="keyword">borrowed </span>- <span class="number">1</span><span class="comment">;</span></span><br><span class="line">            <span class="keyword">bool </span>stored = StoreExclusive(&amp;isa.<span class="keyword">bits, </span>oldisa.<span class="keyword">bits, </span>newisa.<span class="keyword">bits);</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"> </span>           return false<span class="comment">;</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里省去了使用锁来<strong>防止竞争条件</strong>以及<strong>调用 <code>StoreExclusive</code> 失败后恢复现场</strong>的代码。<br>我们会默认这里存在 <code>SideTable</code>，也就是 <code>has_sidetable_rc = true</code>。</p></blockquote><p>你可以看到，这里也有一个 <code>handleUnderflow</code>，与 retain 中的相同，如果发生了 <code>underflow</code>，会重新调用该 <code>rootRelease</code> 方法，并传入 <code>handleUnderflow = true</code>。</p><p>在调用 <code>sidetable_subExtraRC_nolock</code> 成功借位之后，我们会重新设置 <code>newisa</code> 的值 <code>newisa.extra_rc = borrowed - 1</code> 并更新 <code>isa</code>。</p><h3 id="release-中调用-dealloc"><a href="#release-中调用-dealloc" class="headerlink" title="release 中调用 dealloc"></a>release 中调用 dealloc</h3><p>如果在 <code>SideTable</code> 中也没有获取到借位的话，就说明没有任何的变量引用了当前对象（即 <code>retainCount = 0</code>），就需要向它发送 <code>dealloc</code> 消息了。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bool objc_object:<span class="type"></span>:rootRelease(bool performDealloc, bool handleUnderflow) &#123;</span><br><span class="line">    isa_t oldisa;</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line"><span class="type">    do </span>&#123;</span><br><span class="line">        oldisa = LoadExclusive(&amp;isa.bits);</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line"></span><br><span class="line">        uintptr_t carry;</span><br><span class="line">        <span class="keyword">new</span><span class="type">isa</span>.bits = subc(<span class="keyword">new</span><span class="type">isa</span>.bits, RC_ONE, <span class="number">0</span>, &amp;carry);</span><br><span class="line">        <span class="keyword">if</span> (carry) goto underflow;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"> underflow:<span class="type"></span></span><br><span class="line"><span class="type">    newisa </span>= oldisa;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">isa</span>.deallocating) &#123;</span><br><span class="line">        <span class="keyword">return</span> overrelease_error();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span>.deallocating = <span class="literal">true</span>;</span><br><span class="line">    StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(<span class="built_in">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会直接调用 <code>objc_msgSend</code> 向当前对象发送 <code>dealloc</code> 消息。</p><p>不过为了确保消息只会发送一次，我们使用 <code>deallocating</code> 标记位。</p><h2 id="获取自动引用计数"><a href="#获取自动引用计数" class="headerlink" title="获取自动引用计数"></a>获取自动引用计数</h2><p>在文章的最结尾，笔者想要介绍一下 <code>retainCount</code> 的值是怎么计算的，我们直接来看 <code>retainCount</code> 方法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (NSUInteger)retainCount &#123;</span><br><span class="line">    <span class="keyword">return</span> ((id)self)-&gt;rootRetainCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> objc_object::rootRetainCount() &#123;</span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">    <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">        rc += sidetable_getExtraRC_nolock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 根据方法的实现，retainCount 有三部分组成：</p><ul><li>1</li><li><code>extra_rc</code> 中存储的值</li><li><code>sidetable_getExtraRC_nolock</code> 返回的值</li></ul><p>这也就证明了我们之前得到的结论。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们在这篇文章中已经介绍了 <code>retain</code> 和 <code>release</code> 这一对用于内存管理的方法是如何实现的，这里总结一下文章一下比较重要的问题。</p><ul><li><code>extra_rc</code> 只会保存额外的自动引用计数，对象实际的引用计数会在这个基础上 +1</li><li>Objective-C 使用 <code>isa</code> 中的 <code>extra_rc</code> 和 <code>SideTable</code> 来存储对象的引用计数</li><li>在对象的引用计数归零时，会调用 <code>dealloc</code> 方法回收对象</li></ul><p>有关于自动释放池实现的介绍，可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/自动释放池的前世今生.md" rel="external nofollow noopener noreferrer" target="_blank">自动释放池的前世今生</a>。</p><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 &lt;code&gt;retain&lt;/code&gt; 和减少引用计数的 &lt;code&gt;release&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;这篇文章会在源代码层面介绍 Objective-C 中 &lt;code&gt;retain&lt;/code&gt; 和 &lt;code&gt;release&lt;/code&gt; 的实现，它们是如何达到平衡的。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="retain 和 release" scheme="http://yoursite.com/tags/retain-%E5%92%8C-release/"/>
    
  </entry>
  
  <entry>
    <title>17. weak 相关源码分析</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/17_weak/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/17_weak/</id>
    <published>2018-12-04T02:38:11.000Z</published>
    <updated>2018-12-05T11:45:08.564Z</updated>
    
    <content type="html"><![CDATA[<p>weak相关源码分析</p><a id="more"></a><h2 id="weak探究"><a href="#weak探究" class="headerlink" title="__weak探究"></a>__weak探究</h2><p>程序中添加了一个<code>__weak</code>变量，查看调用堆栈，看到下一个调用的是<code>objc_initWeak</code>函数。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak入口.jpg" alt="__weak调用的函数"></p><p>所以我们就objc_initWeak函数作为入口，探究weak。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>首先了解以下的变量，这些变量在这章的数据结构、函数形参中使用：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__weak id weakPtr = o</span><br><span class="line"><span class="keyword">location</span>            <span class="title">newObj</span></span><br><span class="line">refferer            reffenent</span><br><span class="line">引用着               被引用者</span><br></pre></td></tr></table></figure><h3 id="StripedMap"><a href="#StripedMap" class="headerlink" title="StripedMap"></a>StripedMap</h3><p>下面从SideTables() 函数为入口，了解weak相关的数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数返回StripedMap<sidetable> 结构，StripedMap<sidetable> 是一个模板类，函数体内将SideTableBuf强制转换为<code>StripedMap&lt;SideTable&gt;*</code>：</sidetable></sidetable></p><p>StripedMap 定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">        <span class="function">T value <span class="title">alignas</span><span class="params">(<span class="number">64</span>)</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    PaddedT <span class="built_in">array</span>[<span class="number">64</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是StripedMap的简化定义，StripedMap是个模板类，根据模板参数T生成实例类，我们给模板参数传递的实参是SideTable，StripedMap内部只定义了一个数据成员PaddedT array[64]，PaddedT就是64位对齐后的SideTable。</p><p>进一步简化：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SideTable array[<span class="number">64</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>所以StripedMap就是SideTable型的数组，数组有64个成员。</p><p>SideTable的结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_sideTable.png" alt="SideTable 类结构"></p><p>可以看出SideTable的大小是62，64位对齐后是64。其中weak_talbe存储着weak相关的内容。其他的两个成员refcnts、slock不在本文的研究范围内。</p><p>所以数组<code>SideTable array[64]</code> 中元素的大小就是64。整个array 共占用64*64=4096字节。回到没有简化前的版本，<code>StripedMap&lt;SideTable&gt;</code>本质是一个数组，数组的元素是模板参数类型 —SideTable。大小为64。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/stripmap_memory_struct.png" alt="`StripedMap&lt;SideTable&gt;` 内存结构"></p><p>函数SideTables()是将SideTableBuf转化为<code>StripedMap&lt;SideTable&gt;</code>的。所以下面了解SideTableBuf的定义。</p><h3 id="SideTableBuf"><a href="#SideTableBuf" class="headerlink" title="SideTableBuf"></a>SideTableBuf</h3><p>SideTableBuf的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alignas(StripedMap&lt;SideTable&gt;) <span class="keyword">static</span> <span class="keyword">uint8_t</span></span><br><span class="line">    SideTableBuf[<span class="keyword">sizeof</span>(StripedMap&lt;SideTable&gt;)];</span><br></pre></td></tr></table></figure><p>前面的alignas(StripedMap<sidetable>)是对齐的。<code>sizeof(StripedMap&lt;SideTable&gt;)</code>根据上面分析是4096，所以上面的代码简化为：</sidetable></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> SideTableBuf[<span class="number">4096</span>];</span><br></pre></td></tr></table></figure><p>所以SideTableBuf 就是一个包含 4096个uint8_t的数组 。</p><p>所以,函数SideTables() 就相当将uint8_t SideTableBuf[4096] 重新解释为<code>SideTable array[64]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/17_weak/stripedMap.png" alt="SideTableBuf转化为StripedMap 内存示意图"></p><h3 id="weak-table-t"><a href="#weak-table-t" class="headerlink" title="weak_table_t"></a>weak_table_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的弱引用表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries; </span><br><span class="line">    <span class="keyword">size_t</span>    num_entries; <span class="comment">// 实体的数量</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>weak_entries一个数组，数组每个元素是 weak_entry_t 结构体，一个weak_entry_t结构存储了一个reffenent，以及指向reffenent的弱引用者们。</li><li>num_entries 是实体（weak_entry_t）的数量</li><li>mask是容量减1.</li></ol><h3 id="weak-entry-t"><a href="#weak-entry-t" class="headerlink" title="weak_entry_t"></a>weak_entry_t</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    DisguisedPtr&lt;objc_object&gt; referent; </span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers; </span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line : <span class="number">1</span>; <span class="comment">// 变量名是 out_of_line ，占 1 个 bit</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_1; <span class="comment">// 数组中有几个元素，即 referent 有几个弱引用</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask;</span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line=0 is LSB of one of these (don't care which)</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构看着比较复杂：</p><ol><li>referent存储被弱引用的对象。</li><li>第二个成员是一个union，存储若引用者（refferer）。如果referent的弱引用者小于四个，也就是out_of_line为0时，弱引用者就存储在inline_referrers数组中。 否则，就存储在referrers中，这是out_of_line 为1，referrers是个二级指针，里面存的是指向referent 的对象们的地址。num_refs 是弱引用着的个数。mask是容量减1。</li></ol><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_entry_t.png" alt="SideTableBuf转化为StripedMap"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>上面分析了weak相关的结构，现在花一张总图：</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_data_overal.png" alt="SideTableBuf转化为StripedMap"></p><p>上面是详细的数据结构，比较复杂，下面列出我认为核心的结构，核心结构就是三级hash表。</p><p><img src="/wiki/IOS/Runtime/objc/17_weak/weak_table三级表.png" alt="SideTableBuf转化为StripedMap"></p><h2 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_storeWeakOrNil(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj);</span><br><span class="line"><span class="keyword">id</span> objc_initWeak(<span class="keyword">id</span> *location, <span class="keyword">id</span> newObj);</span><br><span class="line"><span class="keyword">void</span> objc_destroyWeak(<span class="keyword">id</span> *location);</span><br></pre></td></tr></table></figure><p>下面章节的代码只是简化的代码，为了方便理解，可能缺失部分细节。</p><h3 id="objc-initWeak"><a href="#objc-initWeak" class="headerlink" title="objc_initWeak"></a>objc_initWeak</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_initWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">Obj</span>) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">        (location, (objc_object*)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_initWeak内部只调用了storeWeak函数。</p><h3 id="objc-storeWeak"><a href="#objc-storeWeak" class="headerlink" title="objc_storeWeak"></a>objc_storeWeak</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id</span><br><span class="line">objc_storeWeak(id *location, id <span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>,</span><br><span class="line">                    <span class="literal">true</span><span class="comment">/*new*/</span>,</span><br><span class="line">                    <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, (objc_object *)<span class="keyword">new</span><span class="type">Obj</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="objc-destroyWeak"><a href="#objc-destroyWeak" class="headerlink" title="objc_destroyWeak"></a>objc_destroyWeak</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">objc_destroyWeak(id *<span class="keyword">location</span>)</span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>)storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>, <span class="literal">false</span><span class="comment">/*new*/</span>, <span class="literal">false</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (<span class="keyword">location</span>, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出objc_initWeak 、 objc_storeWeak 、objc_destroyWeak 的关键内容都是调用storeWeak函数，只是模板参数传递的不一样。</p><h3 id="storeWeak"><a href="#storeWeak" class="headerlink" title="storeWeak"></a>storeWeak</h3><p>下面讲解storeWeak函数，下面只关注添加的过程。删除的过程没有关注。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">template &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">          CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="keyword">static</span> id </span><br><span class="line">storeWeak(id *location, objc_object *<span class="keyword">new</span><span class="type">Obj</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(haveOld  ||  haveNew);</span><br><span class="line">    <span class="keyword">if</span> (!haveNew) assert(<span class="keyword">new</span><span class="type">Obj</span> == nil);</span><br><span class="line"></span><br><span class="line">    Class previouslyInitializedClass = nil;</span><br><span class="line">    id oldObj;</span><br><span class="line">    SideTable *oldTable;</span><br><span class="line">    SideTable *<span class="keyword">new</span><span class="type">Table</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = &amp;SideTables()[<span class="keyword">new</span><span class="type">Obj</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assign new value, if any.</span></span><br><span class="line">    <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Obj</span> = (objc_object *)</span><br><span class="line">            weak_register_no_lock(&amp;<span class="keyword">new</span><span class="type">Table</span>-&gt;weak_table, (id)<span class="keyword">new</span><span class="type">Obj</span>, location, </span><br><span class="line">                                  crashIfDeallocating);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = &amp;SideTables()[<span class="keyword">new</span><span class="type">Obj</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span><span class="type">Table</span> = nil;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是根据newObj 找到存储newObj的地址对应的SideTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">       <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   T&amp; <span class="keyword">operator</span>[] (<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123; </span><br><span class="line">       <span class="keyword">return</span> <span class="built_in">array</span>[indexForPointer(p)].value; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>StripedMap重载了[] 操作符，内部调用了indexForPointer ，indexForPointer就是将对象的地址做某些操作，相当于hash。然后将hash的结果和64取余，得到0~63的值，这个值就可以当做数组的索引使用。</p><p>storeWeak函数接着调用了 weak_register_no_lock函数：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">id </span><br><span class="line">weak<span class="number">_</span>register<span class="number">_n</span>o<span class="number">_</span>lock(weak<span class="number">_</span>table<span class="number">_</span>t *weak<span class="number">_</span>table, id referent<span class="number">_</span>id, </span><br><span class="line">                      id *referrer<span class="number">_</span>id, bool crashIfDeallocating)</span><br><span class="line">&#123;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> *referent = (objc<span class="number">_</span><span class="keyword">object</span> *)referent<span class="number">_</span>id;</span><br><span class="line">    objc<span class="number">_</span><span class="keyword">object</span> **referrer = (objc<span class="number">_</span><span class="keyword">object</span> **)referrer<span class="number">_</span>id;</span><br><span class="line"> weak<span class="number">_</span>entry<span class="number">_</span>t *entry;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// now remember it and where it is being stored</span></span><br><span class="line">    weak<span class="number">_</span>entry<span class="number">_</span>t *entry;</span><br><span class="line">    <span class="comment">// 找到 referent 所在的 entry</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = weak<span class="number">_</span>entry<span class="number">_f</span>or<span class="number">_</span>referent(weak<span class="number">_</span>table, referent))) &#123;</span><br><span class="line">        <span class="comment">// 将 referrer 添加进这个 entry 中，这样 referrer 就成为 referent 的弱引用之一了</span></span><br><span class="line">        append<span class="number">_</span>referrer(entry, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到对应的 entry ，那么说明 referent 还没有弱引用，就为其新建一个 entry</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>t <span class="keyword">new</span><span class="number">_</span>entry;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.referent = referent;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.<span class="keyword">out</span><span class="number">_</span><span class="keyword">of</span><span class="number">_</span>line = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[<span class="number">0</span>] = referrer;</span><br><span class="line">        <span class="comment">// 数组中 4 个referrer全部初始化为 nil</span></span><br><span class="line">        <span class="keyword">for</span> (size<span class="number">_</span>t i = <span class="number">1</span>; i &lt; WEAK<span class="number">_</span>INLINE<span class="number">_</span>COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span><span class="number">_</span>entry.inline<span class="number">_</span>referrers[i] = nil;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查一下需不需要扩容</span></span><br><span class="line">        weak<span class="number">_</span>grow<span class="number">_m</span>aybe(weak<span class="number">_</span>table);</span><br><span class="line">        <span class="comment">// 将新建的 entry 插入 weak table 中</span></span><br><span class="line">        weak<span class="number">_</span>entry<span class="number">_</span>insert(weak<span class="number">_</span>table, &amp;<span class="keyword">new</span><span class="number">_</span>entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> referent<span class="number">_</span>id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的功能就是讲referrer_id 插入到正确的位置，分为两种情况：</p><ol><li>如果根据referent_id可以找到一个weak_entry_t类型的实体entry ，就调用将append_referrer 将referrer_id插入到entry（相当于三级hash表）中。</li><li>如果没有，就需要新建一个weak_entry_t类型的实体new_entry。然后调用weak_entry_insert将new_entry插入到二级hash表中。</li></ol><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static weak_entry_t *</span><br><span class="line">weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 不能是 nil</span></span><br><span class="line">    assert(referent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak_table 中存的实体数组</span></span><br><span class="line">    <span class="function"><span class="title">weak_entry_t</span> *weak_entries = weak_table-&gt;</span>weak_entries;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!weak_entries) &#123;</span><br><span class="line">        return <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 Hash 的方法找到 referent 所在的索引，不过实在看不懂</span></span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = hash_pointer(referent) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">while</span> (weak_table-&gt;</span>weak_entries[index].referent != referent) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        <span class="function"><span class="title">if</span> (hash_displacement &gt; weak_table-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">            return <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回找到的 weak_entry_t，这里可以证明 weak_entries 确实是一个数组</span></span><br><span class="line">    <span class="function"><span class="title">return</span> &amp;weak_table-&gt;</span>weak_entries[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_entry_for_referent 根据给的的referent 在weak_table-&gt;weak_entries中遍历，是否有相同的，如果相同就返回对应的weak_entry_t类型的实体，如果没有nil。</p><p>hash_pointer 就是对对象referent的地址做个hash，然后和<code>weak_table-&gt;mask</code> 做与操作，返回的结果小于weak_table-&gt;mask，当做数组的索引。</p><p>hash_displacement记录的就是最佳位置和实际存储位置的便宜距离。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">weak_entry_t</span> *weak_entries = weak_table-&gt;</span>weak_entries;</span><br><span class="line">    assert(weak_entries != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 hash 决定 索引</span></span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = hash_pointer(new_entry-&gt;</span><span class="function"><span class="title">referent</span>) &amp; (weak_table-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果该索引中已经有 entry，那么这个索引就不能用了，就找下一个索引</span></span><br><span class="line">    <span class="keyword">while</span> (weak_entries[index].referent != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; weak_table-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 new_entry 放入指定的索引中</span></span><br><span class="line">    weak_entries[index] = *new_entry;</span><br><span class="line">    <span class="function"><span class="title">weak_table</span>-&gt;</span>num_entries++;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; weak_table-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">weak_table</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>weak_entry_insert 就是在二级hash表中插入一个新的实体new_entry。通过hash_pointer找到一个最佳位置index，如果最佳位置已经有内容了，就接着查找下一个位置，直到找到空位置。记录下index。在index处插入new_entry。同时将num_entries累加1。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// out_of_line == 0 的情况</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (! entry-&gt;</span>out_of_line) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// inline_referrers 还放得下，就放在 inline_referrers 里</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">            calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中</span></span><br><span class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>out_of_line = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">assert</span>(entry-&gt;</span>out_of_line);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        return grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">    size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找到可以存放 new_referrer 的索引位置</span></span><br><span class="line">    <span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != NULL) &#123;</span><br><span class="line">        <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 index 处的对象替换成 new_referrer</span></span><br><span class="line">    <span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    <span class="comment">// 总数加一</span></span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append_referrer 是在三级hash表entry中出入一个新的弱引用着new_referrer。</p><p>分为三种情况：</p><ol><li>如果inline_referrers没有存储满，直接存储到inline_referrers中</li><li>如果inline_referrers个数是4个了，在插入，就需要将inline_referrers拷贝到referrers，然后进入第三步。</li><li>如果inline_referrers存储满了，判断是否需要扩容，然后将数据存储到referrers中。</li></ol><p>存储到inline_referrers的代码是：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (entry-&gt;</span>inline_referrers[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">entry</span>-&gt;</span>inline_referrers[i] = new_referrer;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存储完成后，直接返回了，所以后面的代码就是存储在referrers的情况。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">weak_referrer_t *new_referrers = (weak_referrer_t *)</span><br><span class="line">    calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中</span></span><br><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">    <span class="function"><span class="title">new_referrers</span>[i] = entry-&gt;</span>inline_referrers[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>referrers = new_referrers;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>num_refs = WEAK_INLINE_COUNT;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>out_of_line = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>mask = WEAK_INLINE_COUNT-<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这段代码的功能是inline_referrers正好4个，如果再次添加，肯定放不下了，所以将inline_referrers中的数据移到referrers中。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">entry</span>-&gt;num_refs &gt;= TABLE_SIZE(<span class="keyword">entry</span>) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> grow_refs_and_insert(<span class="keyword">entry</span>, new_referrer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用超过 3/4，就先扩容，然后再插入。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">size_t</span> index = w_hash_pointer(new_referrer) &amp; (entry-&gt;</span>mask);</span><br><span class="line">size_t hash_displacement = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 找到可以存放 new_referrer 的索引位置</span></span><br><span class="line"><span class="function"><span class="title">while</span> (entry-&gt;</span>referrers[index] != NULL) &#123;</span><br><span class="line">    <span class="function"><span class="title">index</span> = (index+1) &amp; entry-&gt;</span>mask;</span><br><span class="line">    hash_displacement++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">if</span> (hash_displacement &gt; entry-&gt;</span>max_hash_displacement) &#123;</span><br><span class="line">    <span class="function"><span class="title">entry</span>-&gt;</span>max_hash_displacement = hash_displacement;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 index 处的对象替换成 new_referrer</span></span><br><span class="line"><span class="function"><span class="title">weak_referrer_t</span> &amp;ref = entry-&gt;</span>referrers[index];</span><br><span class="line">ref = new_referrer;</span><br><span class="line"><span class="comment">// 总数加一</span></span><br><span class="line"><span class="function"><span class="title">entry</span>-&gt;</span>num_refs++;</span><br></pre></td></tr></table></figure><p>上面的代码是通过弱引用着new_referrer找到index。然后从index开始，寻址空位置，将new_referrer插入到entry-&gt;referrers[index]位置处。同时将entry-&gt;num_refs累加</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>weak即使一个三级hash表。</p><ol><li>第一级用来提高效率的，可以想象，很多多选，放到一个hash表中，降低了效率。所有将多有的对象散列到64个表中。</li><li>二级缓存存储被弱引用的对象。</li><li>三级缓存存储某个对象的所有的弱引用着。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;weak相关源码分析&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="retain 和 release" scheme="http://yoursite.com/tags/retain-%E5%92%8C-release/"/>
    
  </entry>
  
  <entry>
    <title>15. 自动释放池的前世今生（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/15_autoreleasepool/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/15_autoreleasepool/</id>
    <published>2018-12-03T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:17.678Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 <code>autorelease</code> 方法，另一部分分析 <code>retain</code>、<code>release</code> 方法的实现以及自动引用计数。</p></blockquote><a id="more"></a><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇文章会在源代码层面介绍 Objective-C 中自动释放池，以及方法的 <code>autorelease</code> 的具体实现。</p><h2 id="从-main-函数开始"><a href="#从-main-函数开始" class="headerlink" title="从 main 函数开始"></a>从 main 函数开始</h2><p><code>main</code> 函数可以说是在整个 iOS 开发中非常不起眼的一个函数，它很好地隐藏在 <code>Supporting Files</code> 文件夹中，却是整个 iOS 应用的入口。<br><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main.png" alt="objc-autorelease-main"></p><p><code>main.m</code> 文件中的内容是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个 <code>@autoreleasepool</code> block 中只包含了一行代码，这行代码将所有的事件、消息全部交给了 <code>UIApplication</code> 来处理，但是这不是本文关注的重点。</p><p>需要注意的是：<strong>整个 iOS 的应用都是包含在一个自动释放池 block 中的</strong>。</p><h2 id="autoreleasepool"><a href="#autoreleasepool" class="headerlink" title="@autoreleasepool"></a>@autoreleasepool</h2><p><code>@autoreleasepool</code> 到底是什么？我们在命令行中使用 <code>clang -rewrite-objc main.m</code> 让编译器重新改写这个文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clang -rewrite-objc main.m</span></span><br></pre></td></tr></table></figure><p>在生成了一大堆警告之后，当前目录下多了一个 <code>main.cpp</code> 文件</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main-cpp.png" alt="objc-autorelease-main-cpp"></p><blockquote><p>这里删除了 <code>main</code> 函数中其他无用的代码。</p></blockquote><p>在这个文件中，有一个非常奇怪的 <code>__AtAutoreleasePool</code> 的结构体，前面的注释写到 <code>/* @autoreleasepool */</code>。也就是说 <code>@autoreleasepool {}</code> 被转换为一个 <code>__AtAutoreleasePool</code> 结构体：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    __AtAutoreleasePool __autoreleasepool;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要弄清楚这行代码的意义，我们要在 <code>main.cpp</code> 中查找名为 <code>__AtAutoreleasePool</code> 的结构体：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-main-cpp-struct.png" alt="objc-autorelease-main-cpp-struct"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> __AtAutoreleasePool &#123;</span><br><span class="line">  __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125;</span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体会在初始化时调用 <code>objc_autoreleasePoolPush()</code> 方法，会在析构时调用 <code>objc_autoreleasePoolPop</code> 方法。</p><p>这表明，我们的 <code>main</code> 函数在实际工作时其实是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line">        </span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@autoreleasepool</code> 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。</p><h2 id="AutoreleasePool-是什么"><a href="#AutoreleasePool-是什么" class="headerlink" title="AutoreleasePool 是什么"></a>AutoreleasePool 是什么</h2><p>这一节开始分析方法 <code>objc_autoreleasePoolPush</code> 和 <code>objc_autoreleasePoolPop</code> 的实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法看上去是对 <code>AutoreleasePoolPage</code> 对应<strong>静态方法</strong> <code>push</code> 和 <code>pop</code> 的封装。</p><p>这一小节会按照下面的顺序逐步解析代码中的内容：</p><ul><li><a href="#AutoreleasePoolPage">AutoreleasePoolPage 的结构</a></li><li><a href="#objc_autoreleasePoolPush">objc_autoreleasePoolPush 方法</a></li><li><a href="#objc_autoreleasePoolPop">objc_autoreleasePoolPop 方法</a></li></ul><h3 id="AutoreleasePoolPage-的结构"><a href="#AutoreleasePoolPage-的结构" class="headerlink" title="AutoreleasePoolPage 的结构"></a>AutoreleasePoolPage 的结构</h3><p><code>AutoreleasePoolPage</code> 是一个 C++ 中的类：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-AutoreleasePoolPage.png" alt="objc-autorelease-AutoreleasePoolPage"></p><p>它在 <code>NSObject.mm</code> 中的定义是这样的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> AutoreleasePoolPage &#123;</span><br><span class="line">    magic_t <span class="keyword">const</span> magic;</span><br><span class="line">    <span class="keyword">id</span> *next;</span><br><span class="line">    pthread_t <span class="keyword">const</span> thread;</span><br><span class="line">    AutoreleasePoolPage * <span class="keyword">const</span> parent;</span><br><span class="line">    AutoreleasePoolPage *child;</span><br><span class="line">    uint32_t <span class="keyword">const</span> depth;</span><br><span class="line">    uint32_t hiwat;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>magic</code> 用于对当前 <code>AutoreleasePoolPage</code> <strong>完整性</strong>的校验</li><li><code>thread</code> 保存了当前页所在的线程</li></ul><p><strong>每一个自动释放池都是由一系列的 <code>AutoreleasePoolPage</code> 组成的，并且每一个 <code>AutoreleasePoolPage</code> 的大小都是 <code>4096</code> 字节（16 进制 0x1000）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I386_PGBYTES 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGE_SIZE I386_PGBYTES</span></span><br></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p>自动释放池中的 <code>AutoreleasePoolPage</code> 是以<strong>双向链表</strong>的形式连接起来的：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-AutoreleasePoolPage-linked-list.png" alt="objc-autorelease-AutoreleasePoolPage-linked-list"></p><blockquote><p><code>parent</code> 和 <code>child</code> 就是用来构造双向链表的指针。</p></blockquote><h4 id="自动释放池中的栈"><a href="#自动释放池中的栈" class="headerlink" title="自动释放池中的栈"></a>自动释放池中的栈</h4><p>如果我们的一个 <code>AutoreleasePoolPage</code> 被初始化在内存的 <code>0x100816000 ~ 0x100817000</code> 中，它在内存中的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-page-in-memory.png" alt="objc-autorelease-page-in-memory"></p><p>其中有 56 bit 用于存储 <code>AutoreleasePoolPage</code> 的成员变量，剩下的 <code>0x100816038 ~ 0x100817000</code> 都是用来存储<strong>加入到自动释放池中的对象</strong>。</p><blockquote><p><code>begin()</code> 和 <code>end()</code> 这两个类的实例方法帮助我们快速获取 <code>0x100816038 ~ 0x100817000</code> 这一范围的边界地址。</p></blockquote><p><code>next</code> 指向了下一个为空的内存地址，如果 <code>next</code> 指向的地址加入一个 <code>object</code>，它就会如下图所示<strong>移动到下一个为空的内存地址中</strong>：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-after-insert-to-page.png" alt="objc-autorelease-after-insert-to-page"></p><blockquote><p>关于 <code>hiwat</code> 和 <code>depth</code> 在文章中并不会进行介绍，因为它们并不影响整个自动释放池的实现，也不在关键方法的调用栈中。</p></blockquote><h4 id="POOL-SENTINEL（哨兵对象）"><a href="#POOL-SENTINEL（哨兵对象）" class="headerlink" title="POOL_SENTINEL（哨兵对象）"></a>POOL_SENTINEL（哨兵对象）</h4><p>到了这里，你可能想要知道 <code>POOL_SENTINEL</code> 到底是什么，还有它为什么在栈中。</p><p>首先回答第一个问题： <code>POOL_SENTINEL</code> 只是 <code>nil</code> 的别名。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define POOL_SENTINEL nil</span></span><br></pre></td></tr></table></figure><p>在每个自动释放池初始化调用 <code>objc_autoreleasePoolPush</code> 的时候，都会把一个 <code>POOL_SENTINEL</code> push 到自动释放池的栈顶，并且返回这个 <code>POOL_SENTINEL</code> 哨兵对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// do whatever you want</span></span><br><span class="line">        </span><br><span class="line">        objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的 <code>atautoreleasepoolobj</code> 就是一个 <code>POOL_SENTINEL</code>。</p></blockquote><p>而当方法 <code>objc_autoreleasePoolPop</code> 调用时，就会向自动释放池中的对象发送 <code>release</code> 消息，直到第一个 <code>POOL_SENTINEL</code>：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-stack.png" alt="objc-autorelease-pop-stack"></p><h3 id="objc-autoreleasePoolPush-方法"><a href="#objc-autoreleasePoolPush-方法" class="headerlink" title="objc_autoreleasePoolPush 方法"></a><a id="objc_autoreleasePoolPush"></a>objc_autoreleasePoolPush 方法</h3><p>了解了 <code>POOL_SENTINEL</code>，我们来重新回顾一下 <code>objc_autoreleasePoolPush</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用 <code>AutoreleasePoolPage</code> 的类方法 <code>push</code>，也非常简单：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push() &#123;</span><br><span class="line">   <span class="keyword">return</span> autoreleaseFast(POOL_SENTINEL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a id="autoreleaseFast"></a>在这里会进入一个比较关键的方法 <code>autoreleaseFast</code>，并传入哨兵对象 <code>POOL_SENTINEL</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> *autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">   AutoreleasePoolPage *page = hotPage();</span><br><span class="line">   <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">       <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法分三种情况选择不同的代码执行：</p><ul><li>有 <code>hotPage</code> 并且当前 <code>page</code> 不满<ul><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li><li>有 <code>hotPage</code> 并且当前 <code>page</code> 已满<ul><li>调用 <code>autoreleaseFullPage</code> 初始化一个新的页</li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li><li>无 <code>hotPage</code><ul><li>调用 <code>autoreleaseNoPage</code> 创建一个 <code>hotPage</code></li><li>调用 <code>page-&gt;add(obj)</code> 方法将对象添加至 <code>AutoreleasePoolPage</code> 的栈中</li></ul></li></ul><p>最后的都会调用 <code>page-&gt;add(obj)</code> 将对象添加到自动释放池中。</p><blockquote><p><code>hotPage</code> 可以理解为当前正在使用的 <code>AutoreleasePoolPage</code>。</p></blockquote><h4 id="page-gt-add-添加对象"><a href="#page-gt-add-添加对象" class="headerlink" title="page-&gt;add 添加对象"></a>page-&gt;add 添加对象</h4><p><code>id *add(id obj)</code> 将对象添加到自动释放池页中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> *add(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">    <span class="keyword">id</span> *ret = next;</span><br><span class="line">    *next = obj;</span><br><span class="line">    next++;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>笔者对这个方法进行了处理，更方便理解。</p></blockquote><p>这个方法其实就是一个压栈的操作，将对象加入 <code>AutoreleasePoolPage</code> 然后移动栈顶的指针。</p><h4 id="autoreleaseFullPage（当前-hotPage-已满）"><a href="#autoreleaseFullPage（当前-hotPage-已满）" class="headerlink" title="autoreleaseFullPage（当前 hotPage 已满）"></a>autoreleaseFullPage（当前 hotPage 已满）</h4><p><code>autoreleaseFullPage</code> 会在当前的 <code>hotPage</code> 已满的时候调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page) &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line">        <span class="keyword">else</span> page = new AutoreleasePoolPage(page);</span><br><span class="line">    &#125; <span class="keyword">while</span> (page-&gt;full());</span><br><span class="line"></span><br><span class="line">    setHotPage(page);</span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会从传入的 <code>page</code> 开始遍历整个双向链表，直到：</p><ol><li>查找到一个未满的 <code>AutoreleasePoolPage</code></li><li>使用构造器传入 <code>parent</code> 创建一个新的 <code>AutoreleasePoolPage</code></li></ol><p>在查找到一个可以使用的 <code>AutoreleasePoolPage</code> 之后，会将该页面标记成 <code>hotPage</code>，然后调动上面分析过的 <code>page-&gt;add</code> 方法添加对象。</p><h4 id="autoreleaseNoPage（没有-hotPage"><a href="#autoreleaseNoPage（没有-hotPage" class="headerlink" title="autoreleaseNoPage（没有 hotPage)"></a>autoreleaseNoPage（没有 hotPage)</h4><p>如果当前内存中不存在 <code>hotPage</code>，就会调用 <code>autoreleaseNoPage</code> 方法初始化一个 <code>AutoreleasePoolPage</code>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = new AutoreleasePoolPage(<span class="literal">nil</span>);</span><br><span class="line">    setHotPage(page);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">        page-&gt;add(POOL_SENTINEL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然当前内存中不存在 <code>AutoreleasePoolPage</code>，就要<strong>从头开始构建这个自动释放池的双向链表</strong>，也就是说，新的 <code>AutoreleasePoolPage</code> 是没有 <code>parent</code> 指针的。</p><p>初始化之后，将当前页标记为 <code>hotPage</code>，然后会先向这个 <code>page</code> 中添加一个 <code>POOL_SENTINEL</code> 对象，来确保在 <code>pop</code> 调用的时候，不会出现异常。</p><p>最后，将 <code>obj</code> 添加到自动释放池中。</p><h3 id="objc-autoreleasePoolPop-方法"><a href="#objc-autoreleasePoolPop-方法" class="headerlink" title="objc_autoreleasePoolPop 方法"></a><a id="objc_autoreleasePoolPop"></a>objc_autoreleasePoolPop 方法</h3><p>同样，回顾一下上面提到的 <code>objc_autoreleasePoolPop</code> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中<strong>传入其它的指针也是可行的</strong>，会将自动释放池释放到相应的位置。</p></blockquote><p>我们一般都会在这个方法中传入一个哨兵对象 <code>POOL_SENTINEL</code>，如下图一样释放对象：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-stack.png" alt="objc-autorelease-pop-stack"></p><h4 id="对-objc-autoreleasePoolPop-行为的测试"><a href="#对-objc-autoreleasePoolPop-行为的测试" class="headerlink" title="对 objc_autoreleasePoolPop 行为的测试"></a>对 objc_autoreleasePoolPop 行为的测试</h4><p>在继续分析这个方法之前做一个小测试，在 <code>objc_autoreleasePoolPop</code> 传入非哨兵对象，测试一下这个方法的行为。</p><p>下面是 <code>main.m</code> 文件中的源代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *s = <span class="string">@"Draveness"</span>;</span><br><span class="line">        [s stringByAppendingString:<span class="string">@"-Suffix"</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的这一行打一个断点，因为这里会调用 <code>autorelease</code> 方法，将字符串加入自动释放池：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-breakpoint-main.png" alt="objc-autorelease-breakpoint-main"></p><p>当代码运行到这里时，通过 lldb 打印出当前 <code>hotPage</code> 中的栈内容：</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-print-pool-content.png" alt="objc-autorelease-print-pool-content"></p><ol><li>通过 <code>static</code> 方法获取当前 <code>hotPage</code></li><li>打印 <code>AutoreleasePoolPage</code> 中的内容</li><li>打印当前 <code>next</code> 指针指向的内容，以及之前的内容，<code>-2</code>时已经到了 <code>begin()</code> 位置</li><li>使用 <code>print()</code>和 <code>printAll()</code>打印自动释放池中内容</li></ol><p>然后将字符串 <code>@&quot;Draveness-Suffix&quot;</code> 的指针传入 <code>pop</code> 方法，测试 <code>pop</code> 方法能否传入非哨兵参数。</p><p><img src="/wiki/IOS/Runtime/objc/15_autoreleasepool/objc-autorelease-pop-string.png" alt="objc-autorelease-pop-string"></p><p>再次打印当前 <code>AutoreleasePoolPage</code> 的内容时，字符串已经不存在了，这说明<strong>向 <code>pop</code> 方法传入非哨兵参数是可行的</strong>，只是我们一般不会传入非哨兵对象。</p><hr><p>让我们重新回到对 <code>objc_autoreleasePoolPop</code> 方法的分析，也就是 <code>AutoreleasePoolPage::pop</code> 方法的调用：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token) &#123;</span><br><span class="line">    AutoreleasePoolPage *page = pageForPointer(token);</span><br><span class="line">    <span class="keyword">id</span> *stop = (<span class="keyword">id</span> *)token;</span><br><span class="line"></span><br><span class="line">    page-&gt;releaseUntil(stop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (page-&gt;child) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">            page-&gt;child-&gt;kill();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">            page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个方法中删除了大量无关的代码，以及对格式进行了调整。</p></blockquote><p>该静态方法总共做了三件事情：</p><ol><li>使用 <code>pageForPointer</code> 获取当前 <code>token</code> 所在的 <code>AutoreleasePoolPage</code></li><li>调用 <code>releaseUntil</code> 方法释放<strong>栈中的</strong>对象，直到 <code>stop</code></li><li>调用 <code>child</code> 的 <code>kill</code> 方法</li></ol><blockquote><p>我到现在也不是很清楚为什么要根据当前页的不同状态 <code>kill</code> 掉不同 <code>child</code> 的页面。</p></blockquote><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">    page-&gt;child-&gt;kill();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">    page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pageForPointer-获取-AutoreleasePoolPage"><a href="#pageForPointer-获取-AutoreleasePoolPage" class="headerlink" title="pageForPointer 获取 AutoreleasePoolPage"></a>pageForPointer 获取 AutoreleasePoolPage</h4><p><code>pageForPointer</code> 方法主要是通过内存地址的操作，获取当前指针所在页的首地址：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(<span class="keyword">const</span> <span class="keyword">void</span> *p) &#123;</span><br><span class="line">    <span class="keyword">return</span> pageForPointer((uintptr_t)p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123;</span><br><span class="line">    AutoreleasePoolPage *result;</span><br><span class="line">    uintptr_t offset = p % SIZE;</span><br><span class="line"></span><br><span class="line">    assert(offset &gt;= <span class="keyword">sizeof</span>(AutoreleasePoolPage));</span><br><span class="line"></span><br><span class="line">    result = (AutoreleasePoolPage *)(p - offset);</span><br><span class="line">    result-&gt;fastcheck();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将指针与页面的大小，也就是 4096 取模，得到当前指针的偏移量，因为所有的 <code>AutoreleasePoolPage</code> 在内存中都是对齐的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = 0x100816048</span><br><span class="line">p % SIZE = 0x48</span><br><span class="line">result = 0x100816000</span><br></pre></td></tr></table></figure><p>而最后调用的方法 <code>fastCheck()</code> 用来检查当前的 <code>result</code> 是不是一个 <code>AutoreleasePoolPage</code>。</p><blockquote><p>通过检查 <code>magic_t</code> 结构体中的某个成员是否为 <code>0xA1A1A1A1</code>。</p></blockquote><h4 id="releaseUntil-释放对象"><a href="#releaseUntil-释放对象" class="headerlink" title="releaseUntil 释放对象"></a>releaseUntil 释放对象</h4><p><code>releaseUntil</code> 方法的实现如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> releaseUntil(<span class="keyword">id</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>-&gt;next != stop) &#123;</span><br><span class="line">        AutoreleasePoolPage *page = hotPage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (page-&gt;empty()) &#123;</span><br><span class="line">            page = page-&gt;parent;</span><br><span class="line">            setHotPage(page);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        page-&gt;unprotect();</span><br><span class="line">        <span class="keyword">id</span> obj = *--page-&gt;next;</span><br><span class="line">        memset((<span class="keyword">void</span>*)page-&gt;next, SCRIBBLE, <span class="keyword">sizeof</span>(*page-&gt;next));</span><br><span class="line">        page-&gt;protect();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj != POOL_SENTINEL) &#123;</span><br><span class="line">            objc_release(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setHotPage(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现还是很容易的，用一个 <code>while</code> 循环持续释放 <code>AutoreleasePoolPage</code> 中的内容，直到 <code>next</code> 指向了 <code>stop</code> 。</p><p>使用 <code>memset</code> 将内存的内容设置成 <code>SCRIBBLE</code>，然后使用 <code>objc_release</code> 释放对象。</p><h4 id="kill-方法"><a href="#kill-方法" class="headerlink" title="kill() 方法"></a>kill() 方法</h4><p>到这里，没有分析的方法就只剩下 <code>kill</code> 了，而它会将当前页面以及子页面全部删除：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> kill() &#123;</span><br><span class="line">    AutoreleasePoolPage *page = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">while</span> (page-&gt;child) page = page-&gt;child;</span><br><span class="line"></span><br><span class="line">    AutoreleasePoolPage *deathptr;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        deathptr = page;</span><br><span class="line">        page = page-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (page) &#123;</span><br><span class="line">            page-&gt;unprotect();</span><br><span class="line">            page-&gt;child = <span class="literal">nil</span>;</span><br><span class="line">            page-&gt;protect();</span><br><span class="line">        &#125;</span><br><span class="line">        delete deathptr;</span><br><span class="line">    &#125; <span class="keyword">while</span> (deathptr != <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autorelease-方法"><a href="#autorelease-方法" class="headerlink" title="autorelease 方法"></a>autorelease 方法</h3><p>我们已经对自动释放池生命周期有一个比较好的了解，最后需要了解的话题就是 <code>autorelease</code> 方法的实现，先来看一下方法的调用栈：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- [<span class="built_in">NSObject</span> autorelease]</span><br><span class="line">└── <span class="keyword">id</span> objc_object::rootAutorelease()</span><br><span class="line">    └── <span class="keyword">id</span> objc_object::rootAutorelease2()</span><br><span class="line">        └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autorelease(<span class="keyword">id</span> obj)</span><br><span class="line">            └── <span class="keyword">static</span> <span class="keyword">id</span> AutoreleasePoolPage::autoreleaseFast(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                ├── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseFullPage(<span class="keyword">id</span> obj, AutoreleasePoolPage *page)</span><br><span class="line">                │   ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                │   └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br><span class="line">                └── <span class="keyword">static</span> <span class="keyword">id</span> *autoreleaseNoPage(<span class="keyword">id</span> obj)</span><br><span class="line">                    ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent)</span><br><span class="line">                    └── <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</span><br></pre></td></tr></table></figure><p>在 <code>autorelease</code> 方法的调用栈中，最终都会调用上面提到的 <a href="#autoreleaseFast">autoreleaseFast</a> 方法，将当前对象加到 <code>AutoreleasePoolPage</code> 中。</p><p>这一小节中这些方法的实现都非常容易，只是进行了一些参数上的检查，最终还要调用 <a href="#autoreleaseFast">autoreleaseFast</a> 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">id</span> objc_object::rootAutorelease() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (prepareOptimizedReturn(ReturnAtPlus1)) <span class="keyword">return</span> (<span class="keyword">id</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rootAutorelease2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((noinline,used)) <span class="keyword">id</span> objc_object::rootAutorelease2() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoreleasePoolPage::autorelease((<span class="keyword">id</span>)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">   <span class="keyword">id</span> *dest __unused = autoreleaseFast(obj);</span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在上面已经分析过 <code>autoreleaseFast</code> 方法的实现，这里就不会多说了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整个自动释放池 <code>AutoreleasePool</code> 的实现以及 <code>autorelease</code> 方法都已经分析完了，我们再来回顾一下文章中的一些内容：</p><ul><li>自动释放池是由 <code>AutoreleasePoolPage</code> 以双向链表的方式实现的</li><li>当对象调用 <code>autorelease</code> 方法时，会将对象加入 <code>AutoreleasePoolPage</code> 的栈中</li><li>调用 <code>AutoreleasePoolPage::pop</code> 方法会向栈中的对象发送 <code>release</code> 消息</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://stackoverflow.com/questions/14677049/what-is-autoreleasepool-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What is autoreleasepool? - Objective-C</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" rel="external nofollow noopener noreferrer" target="_blank">Using Autorelease Pool Blocks</a></li><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSAutoreleasePool_Class/index.html#//apple_ref/occ/cl/NSAutoreleasePool" rel="external nofollow noopener noreferrer" target="_blank">NSAutoreleasePool</a></li><li><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" rel="external nofollow noopener noreferrer" target="_blank">黑幕背后的 Autorelease</a></li></ul><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 &lt;code&gt;autorelease&lt;/code&gt; 方法，另一部分分析 &lt;code&gt;retain&lt;/code&gt;、&lt;code&gt;release&lt;/code&gt; 方法的实现以及自动引用计数。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="autorelease" scheme="http://yoursite.com/tags/autorelease/"/>
    
  </entry>
  
  <entry>
    <title>14. 关联对象 AssociatedObject 完全解析（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/14_AssociatedObject%20/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/14_AssociatedObject /</id>
    <published>2018-12-02T02:38:11.000Z</published>
    <updated>2018-12-04T08:27:23.213Z</updated>
    
    <content type="html"><![CDATA[<p>我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 <code>@property</code> 并不能在分类中<strong>正确</strong>创建实例变量和存取方法。</p><p>不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。</p><p>这篇文章包含了两方面的内容：</p><ul><li><a href="#关联对象的应用">使用关联对象为已经存在的类中添加属性</a></li><li><a href="#关联对象的实现">关联对象在底层 Objective-C 中的实现</a></li></ul><blockquote><p>注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。</p><p>如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从<a href="#关联对象的实现">这里</a>开始深入了解其底层实现。</p></blockquote><a id="more"></a> <h2 id="关联对象的应用"><a href="#关联对象的应用" class="headerlink" title="关联对象的应用"></a>关联对象的应用</h2><p>关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。</p><h3 id="分类中的-property"><a href="#分类中的-property" class="headerlink" title="分类中的 @property"></a>分类中的 @property</h3><p><code>@property</code> 可以说是一个 Objective-C 编程中的“宏”，它有<a href="https://zh.wikipedia.org/zh/元编程" rel="external nofollow noopener noreferrer" target="_blank">元编程</a>的思想。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">DKObject </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSString *property;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>在使用上述代码时会做三件事：</p><ul><li>生成实例变量 <code>_property</code></li><li>生成 <code>getter</code> 方法 <code>- property</code></li><li>生成 <code>setter</code> 方法 <code>- setProperty:</code></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@implementation DKObject &#123;</span><br><span class="line">    NSString *_property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)<span class="keyword">property</span><span class="title"> </span>&#123;</span><br><span class="line">    return _property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setProperty:(NSString *)<span class="keyword">property</span><span class="title"> </span>&#123;</span><br><span class="line">    _property = <span class="keyword">property</span><span class="title"></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 <code>@property</code> 生成一个属性，那么为什么在分类中不可以呢？</p><p>我们来做一个小实验：创建一个 <code>DKObject</code> 的分类 <code>Category</code>，并添加一个属性 <code>categoryProperty</code>：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> DKObject (Category)</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) NSString *categoryProperty;</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure><p>看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告：</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-warning-category-property.png" alt="objc-ao-warning-category-property"></p><p>在这里的警告告诉我们 <code>categoryProperty</code> 属性的存取方法需要自己手动去实现，或者使用 <code>@dynamic</code> 在运行时实现这些方法。</p><p>换句话说，分类中的 <code>@property</code> 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。</p><h3 id="使用关联对象"><a href="#使用关联对象" class="headerlink" title="使用关联对象"></a>使用关联对象</h3><p>Q：我们为什么要使用关联对象？</p><p>A：因为在分类中 <code>@property</code> 并不会自动生成实例变量以及存取方法，所以<strong>一般使用关联对象为已经存在的类添加『属性』</strong>。</p><p>上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个<strong>伪属性</strong>：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"DKObject+Category.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DKObject</span> (<span class="title">Category</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)categoryProperty &#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCategoryProperty:(<span class="built_in">NSString</span> *)categoryProperty &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这里的 <code>_cmd</code> 代指当前方法的选择子，也就是 <code>@selector(categoryProperty)</code>。</p></blockquote><p>我们使用了两个方法 <code>objc_getAssociatedObject</code> 以及 <code>objc_setAssociatedObject</code> 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。</p><p>在这里有必要解释两个问题：</p><ol><li>为什么向方法中传入 <code>@selector(categoryProperty)</code>？</li><li><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 是干什么的？</li></ol><p>关于第一个问题，我们需要看一下这两个方法的原型：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br></pre></td></tr></table></figure><p><code>@selector(categoryProperty)</code> 也就是参数中的 <code>key</code>，其实可以使用静态指针 <code>static void *</code> 类型的参数来代替，不过在这里，笔者强烈推荐使用 <code>@selector(categoryProperty)</code> 作为 <code>key</code> 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 <code>key</code> 的唯一性。</p><p><code>OBJC_ASSOCIATION_RETAIN_NONATOMIC</code> 又是什么呢？如果我们使用 <code>Command</code> 加左键查看它的定义：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从这里的注释我们能看到很多东西，也就是说不同的 <code>objc_AssociationPolicy</code> 对应了不通的属性修饰符：</p><table><thead><tr><th style="text-align:left">objc_AssociationPolicy</th><th style="text-align:center">modifier</th></tr></thead><tbody><tr><td style="text-align:left">OBJC_ASSOCIATION_ASSIGN</td><td style="text-align:center">assign</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td style="text-align:center">nonatomic, strong</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY_NONATOMIC</td><td style="text-align:center">nonatomic, copy</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_RETAIN</td><td style="text-align:center">atomic, strong</td></tr><tr><td style="text-align:left">OBJC_ASSOCIATION_COPY</td><td style="text-align:center">atomic, copy</td></tr></tbody></table><p>而我们在代码中实现的属性 <code>categoryProperty</code> 就相当于使用了 <code>nonatomic</code> 和 <code>strong</code> 修饰符。</p><blockquote><p>关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，<a href="https://google.com" rel="external nofollow noopener noreferrer" target="_blank">Google</a> 是一个很好的选择。</p></blockquote><p>到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。</p><p>@property` 其实有元编程的思想，它能够为我们自动生成<strong>实例变量以及存取方法</strong>，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">self</span>.<span class="keyword">property</span> &lt;=&gt; [<span class="built_in">self</span> <span class="keyword">property</span>]</span><br><span class="line"><span class="built_in">self</span>.<span class="keyword">property</span> = value &lt;=&gt; [<span class="built_in">self</span> setProperty:value]</span><br></pre></td></tr></table></figure><p>在分类中，因为类的实例变量的布局已经固定，使用 <code>@property</code> 已经<strong>无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量）</strong>，所以我们需要<strong>使用关联对象以及两个方法来模拟构成属性的三个要素</strong>。</p><blockquote><p>如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。</p></blockquote><h2 id="关联对象的实现"><a href="#关联对象的实现" class="headerlink" title="关联对象的实现"></a>关联对象的实现</h2><blockquote><p>探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。</p></blockquote><p>这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>;</span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>;</span><br></pre></td></tr></table></figure><p>三个方法的作用分别是：</p><ul><li>以键值对形式添加关联对象</li><li>根据 <code>key</code> 获取关联对象</li><li>移除所有关联对象</li></ul><p>而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。</p><h3 id="objc-setAssociatedObject"><a href="#objc-setAssociatedObject" class="headerlink" title="objc_setAssociatedObject"></a>objc_setAssociatedObject</h3><p>首先是 <code>objc_setAssociatedObject</code> 方法，这个方法的调用栈并不复杂：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>) </span></span><br><span class="line"><span class="function">└── <span class="keyword">void</span> <span class="title">objc_setAssociatedObject_non_gc</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span></span><br><span class="line"><span class="function">    └── <span class="keyword">void</span> _<span class="title">object_set_associative_reference</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr_t policy</span>)</span></span><br></pre></td></tr></table></figure><p>调用栈中的 <code>_object_set_associative_reference</code> 方法实际完成了设置关联对象的任务：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。</p></blockquote><p>我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用：</p><ul><li><code>AssociationsManager</code></li><li><code>AssociationsHashMap</code></li><li><code>ObjcAssociationMap</code></li><li><code>ObjcAssociation</code></li></ul><h4 id="AssociationsManager"><a href="#AssociationsManager" class="headerlink" title="AssociationsManager"></a>AssociationsManager</h4><p><code>AssociationsManager</code> 在源代码中的定义是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">spinlock_t</span> _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">spinlock_t</span> AssociationsManager::_lock;</span><br><span class="line">AssociationsHashMap *AssociationsManager::_map = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>它维护了 <code>spinlock_t</code> 和 <code>AssociationsHashMap</code> 的单例，初始化它的时候会调用 <code>lock.lock()</code> 方法，在析构时会调用 <code>lock.unlock()</code>，而 <code>associations</code> 方法用于取得一个全局的 <code>AssociationsHashMap</code> 单例。</p><p>也就是说 <code>AssociationsManager</code> 通过持有一个<a href="https://en.wikipedia.org/wiki/Spinlock" rel="external nofollow noopener noreferrer" target="_blank">自旋锁</a> <code>spinlock_t</code> 保证对 <code>AssociationsHashMap</code> 的操作是线程安全的，即<strong>每次只会有一个线程对 AssociationsHashMap 进行操作</strong>。</p><h4 id="如何存储-ObjcAssociation"><a href="#如何存储-ObjcAssociation" class="headerlink" title="如何存储 ObjcAssociation"></a>如何存储 ObjcAssociation</h4><p><code>ObjcAssociation</code> 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。</p><p>首先，<code>AssociationsHashMap</code> 用与保存从对象的 <code>disguised_ptr_t</code> 到 <code>ObjectAssociationMap</code> 的映射：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 <code>ObjectAssociationMap</code> 则保存了从 <code>key</code> 到关联对象 <code>ObjcAssociation</code> 的映射，<strong>这个数据结构保存了当前对象对应的所有关联对象</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123; <span class="keyword">return</span> ::<span class="built_in">malloc</span>(n); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123; ::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>最关键的 <code>ObjcAssociation</code> 包含了 <code>policy</code> 以及 <code>value</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">    id _value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ObjcAssociation(<span class="keyword">uintptr_t</span> policy, id value) : _policy(policy), _value(value) &#123;&#125;</span><br><span class="line">    ObjcAssociation() : _policy(<span class="number">0</span>), _value(nil) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> policy() <span class="keyword">const</span> &#123; <span class="keyword">return</span> _policy; &#125;</span><br><span class="line">    <span class="function">id <span class="title">value</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _value != nil; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line"></span><br><span class="line">        NSObject *obj = [NSObject <span class="keyword">new</span>];</span><br><span class="line">        objc_setAssociatedObject(obj, <span class="meta">@selector</span>(hello), @<span class="string">"Hello"</span>, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的关联对象 <code>ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @&quot;Hello&quot;)</code> 在内存中是这么存储的：</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-associateobjcect.png" alt="objc-ao-associateobjcect"></p><hr><p>接下来我们可以重新回到对 <code>objc_setAssociatedObject</code> 方法的分析了。</p><p>在这里会将方法的执行分为两种情况：</p><ul><li><code>new_value != nil</code> 设置/更新关联对象的值</li><li><code>new_value == nil</code> 删除一个关联对象</li></ul><h4 id="new-value-nil"><a href="#new-value-nil" class="headerlink" title="new_value != nil"></a>new_value != nil</h4><p>先来分析在 <code>new_value != nil</code> 的情况下，该方法的执行是什么样的：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;</span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br><span class="line"></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">            <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">            associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">            (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">            <span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用 <code>old_association(0, nil)</code> 创建一个临时的 <code>ObjcAssociation</code> 对象（用于持有原有的关联对象，方便在方法调用的最后释放值）</li><li><p>调用 <code>acquireValue</code> 对 <code>new_value</code> 进行 <code>retain</code> 或者 <code>copy</code></p> <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> acquireValue(<span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (policy &amp; <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_RETAIN:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_retain);</span><br><span class="line">    <span class="keyword">case</span> OBJC_ASSOCIATION_SETTER_COPY:</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL))objc_msgSend)(value, SEL_copy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化一个 <code>AssociationsManager</code>，并获取唯一的保存关联对象的哈希表 <code>AssociationsHashMap</code></p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AssociationsManager manager<span class="comment">;</span></span><br><span class="line">AssociationsHashMap &amp;associations(<span class="name">manager</span>.associations())<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>先使用 <code>DISGUISE(object)</code> 作为 key 寻找对应的 <code>ObjectAssociationMap</code></p></li><li><p>如果没有找到，初始化一个 <code>ObjectAssociationMap</code>，再实例化 <code>ObjcAssociation</code> 对象添加到 Map 中，并调用 <code>setHasAssociatedObjects</code> 方法，表明当前对象含有关联对象</p> <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line"><span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br></pre></td></tr></table></figure></li><li><p>如果找到了对应的 <code>ObjectAssociationMap</code>，就要看 <code>key</code> 是否存在了，由此来决定是更新原有的关联对象，还是增加一个</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O<span class="function"><span class="title">bjectAssociationMap</span> *refs = i-&gt;</span>second;</span><br><span class="line">O<span class="function"><span class="title">bjectAssociationMap</span>::iterator j = refs-&gt;</span>find(key);</span><br><span class="line"><span class="function"><span class="title">if</span> (j != refs-&gt;</span>end()) &#123;</span><br><span class="line">    <span class="function"><span class="title">old_association</span> = j-&gt;</span>second;</span><br><span class="line">    <span class="function"><span class="title">j</span>-&gt;</span>second = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后的最后，如果原来的关联对象有值的话，会调用 <code>ReleaseValue()</code> 释放关联对象的值</p> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ReleaseValue &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span>(<span class="params"></span>) (<span class="params">ObjcAssociation &amp;association</span>) </span>&#123;</span><br><span class="line">        releaseValue(association.<span class="keyword">value</span>(), association.policy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releaseValue</span>(<span class="params">id <span class="keyword">value</span>, uintptr_t policy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123;</span><br><span class="line">        ((id(*)(id, SEL))objc_msgSend)(<span class="keyword">value</span>, SEL_release);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>到这里，该条件下的方法实现就结束了。</p><h4 id="new-value-nil-1"><a href="#new-value-nil-1" class="headerlink" title="new_value == nil"></a>new_value == nil</h4><p>如果 <code>new_value == nil</code>，就说明我们要删除对应 <code>key</code> 的关联对象，实现如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void _object_set_associative_reference(<span class="name">id</span> object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line"></span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i !=  associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                old_association = j-&gt;second<span class="comment">;</span></span><br><span class="line">                refs-&gt;erase(<span class="name">j</span>)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">old_association</span>.hasValue()) ReleaseValue()(<span class="name">old_association</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下方法的实现与前面的唯一区别就是，我们会调用 <code>erase</code> 方法，擦除 <code>ObjectAssociationMap</code> 中 <code>key</code> 对应的节点。</p><h4 id="setHasAssociatedObjects"><a href="#setHasAssociatedObjects" class="headerlink" title="setHasAssociatedObjects()"></a>setHasAssociatedObjects()</h4><p>其实上面的两种情况已经将 <code>objc_setAssociatedObject</code> 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，<code>setHasAssociatedObjects()</code> 方法的作用是什么？</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> void objc_object:<span class="type"></span>:setHasAssociatedObjects() &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"> retry:<span class="type"></span></span><br><span class="line"><span class="type">    isa_t oldisa </span>= LoadExclusive(&amp;isa.bits);</span><br><span class="line">    isa_t <span class="keyword">new</span><span class="type">isa</span> = oldisa;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">new</span><span class="type">isa</span>.indexed) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">isa</span>.has_assoc) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">new</span><span class="type">isa</span>.has_assoc = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!StoreExclusive(&amp;isa.bits, oldisa.bits, <span class="keyword">new</span><span class="type">isa</span>.bits)) goto retry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会将 <code>isa</code> 结构体中的标记位 <code>has_assoc</code> 标记为 <code>true</code>，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 <code>isa</code> 中的各个标记位都是干什么的。</p><p><img src="/wiki/IOS/Runtime/objc/14_AssociatedObject /objc-ao-isa-struct.png" alt="objc-ao-isa-struct"></p><blockquote><p>如果想要了解关于 isa 的知识，可以阅读<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解 isa</a></p></blockquote><h3 id="objc-getAssociatedObject"><a href="#objc-getAssociatedObject" class="headerlink" title="objc_getAssociatedObject"></a>objc_getAssociatedObject</h3><p>我们既然已经对 <code>objc_setAssociatedObject</code> 的实现已经比较熟悉了，相信对于 <code>objc_getAssociatedObject</code> 的理解也会更加容易。</p><p>方法的调用栈和 <code>objc_setAssociatedObject</code> 非常相似：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span><br><span class="line">└── <span class="keyword">id</span> objc_getAssociatedObject_non_gc(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    └── <span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key)</span><br></pre></td></tr></table></figure><p>而 <code>_object_get_associative_reference</code> 相比于前面方法的实现更加简单。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;</span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">                value = entry.value()<span class="comment">;</span></span><br><span class="line">                policy = entry.policy()<span class="comment">;</span></span><br><span class="line">                if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_retain)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_autorelease)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中寻找关联对象的逻辑和 <code>objc_setAssociatedObject</code> 差不多：</p><ol><li>获取静态变量 <code>AssociationsHashMap</code></li><li>以 <code>DISGUISE(object)</code> 为 key 查找 <code>AssociationsHashMap</code></li><li>以 <code>void *key</code> 为 key 查找 <code>ObjcAssociation</code></li><li><p>根据 <code>policy</code> 调用相应的方法</p> <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id<span class="comment">(*)(id, SEL))objc_msgSend)(value, SEL_retain);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span></span><br><span class="line"><span class="comment">    ((id(*)</span>(id, SEL))objc_msgSend)(value, SEL_autorelease);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回关联对象 <code>ObjcAssociation</code> 的值</p></li></ol><h3 id="objc-removeAssociatedObjects"><a href="#objc-removeAssociatedObjects" class="headerlink" title="objc_removeAssociatedObjects"></a>objc_removeAssociatedObjects</h3><p>关于最后的 <code>objc_removeAssociatedObjects</code> 方法，其实现也相对简单，这是方法的调用栈：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc<span class="number">_</span>removeAssociatedObjects(id <span class="keyword">object</span>)</span><br><span class="line">└── <span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(id <span class="keyword">object</span>)</span><br></pre></td></tr></table></figure><p>这是简化版本的 <code>objc_removeAssociatedObjects</code> 方法实现：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc<span class="number">_</span>removeAssociatedObjects(id <span class="keyword">object</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">object</span> &amp;&amp; <span class="keyword">object</span>-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(<span class="keyword">object</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了加速移除对象的关联对象的速度，我们会通过标记位 <code>has_assoc</code> 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 <code>_object_remove_assocations</code> 方法移除对象上所有的关联对象：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void _object_remove_assocations(id object) &#123;</span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements<span class="comment">;</span></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager<span class="comment">;</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations())<span class="comment">;</span></span><br><span class="line">        if (associations.size() == <span class="number">0</span>) return<span class="comment">;</span></span><br><span class="line">        <span class="keyword">disguised_ptr_t </span><span class="keyword">disguised_object </span>= <span class="keyword">DISGUISE(object);</span></span><br><span class="line"><span class="keyword"> </span>       AssociationsHashMap::iterator i = associations.find(<span class="keyword">disguised_object);</span></span><br><span class="line"><span class="keyword"> </span>       if (i != associations<span class="meta">.end</span>()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            for (ObjectAssociationMap::iterator <span class="keyword">j </span>= refs-&gt;<span class="keyword">begin(), </span>end = refs-&gt;end()<span class="comment">; j != end; ++j) &#123;</span></span><br><span class="line">                elements.push_back(<span class="keyword">j-&gt;second);</span></span><br><span class="line"><span class="keyword"> </span>           &#125;</span><br><span class="line">            delete refs<span class="comment">;</span></span><br><span class="line">            associations.erase(i)<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(elements.<span class="keyword">begin(), </span>elements<span class="meta">.end</span>(), ReleaseValue())<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法会将对象包含的所有关联对象加入到一个 <code>vector</code> 中，然后对所有的 <code>ObjcAssociation</code> 对象调用 <code>ReleaseValue()</code> 方法，释放不再被需要的值。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="关于应用"><a href="#关于应用" class="headerlink" title="关于应用"></a>关于应用</h3><p>本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。</p><ul><li>如果你把属性理解为<strong>通过方法访问的实例变量</strong>，我相信这个问题的答案是不能，<strong>因为分类不能为类增加额外的实例变量</strong>。</li><li>不过如果属性只是一个<strong>存取方法以及存储值的容器的集合</strong>，那么分类是可以实现属性的。</li></ul><blockquote><p><strong>分类中对属性的实现其实只是实现了一个看起来像属性的接口而已</strong>。</p></blockquote><h3 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h3><p>关联对象又是如何实现并且管理的呢：</p><ul><li>关联对象其实就是 <code>ObjcAssociation</code> 对象</li><li>关联对象由 <code>AssociationsManager</code> 管理并在  <code>AssociationsHashMap</code> 存储</li><li>对象的指针以及其对应 <code>ObjectAssociationMap</code> 以键值对的形式存储在 <code>AssociationsHashMap</code> 中</li><li><code>ObjectAssociationMap</code> 则是用于存储关联对象的数据结构</li><li>每一个对象都有一个标记位 <code>has_assoc</code> 指示对象是否含有关联对象</li></ul><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 &lt;code&gt;@property&lt;/code&gt; 并不能在分类中&lt;strong&gt;正确&lt;/strong&gt;创建实例变量和存取方法。&lt;/p&gt;
&lt;p&gt;不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。&lt;/p&gt;
&lt;p&gt;这篇文章包含了两方面的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#关联对象的应用&quot;&gt;使用关联对象为已经存在的类中添加属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#关联对象的实现&quot;&gt;关联对象在底层 Objective-C 中的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。&lt;/p&gt;
&lt;p&gt;如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从&lt;a href=&quot;#关联对象的实现&quot;&gt;这里&lt;/a&gt;开始深入了解其底层实现。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="AssociatedObject" scheme="http://yoursite.com/tags/AssociatedObject/"/>
    
  </entry>
  
  <entry>
    <title>12. 懒惰的 initialize 方法（转载）</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/12_initialize/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/12_initialize/</id>
    <published>2018-12-01T03:38:11.000Z</published>
    <updated>2018-12-03T08:08:09.795Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章可能是对 Objective-C 源代码解析系列文章中最短的一篇了，在 Objective-C 中，我们总是会同时想到 <code>load</code>、<code>initialize</code> 这两个类方法。而这两个方法也经常在一起比较。</p><p>本文会主要介绍：</p><ol><li><code>initialize</code> 方法的调用为什么是惰性的。</li><li>这货能干啥。</li></ol><a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><h2 id="initialize-的调用栈"><a href="#initialize-的调用栈" class="headerlink" title="initialize 的调用栈"></a>initialize 的调用栈</h2><p>在分析其调用栈之前，首先来解释一下，什么是惰性的。</p><p>这是 <code>main.m</code> 文件中的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"XXObject initialize"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数中的代码为空，如果我们运行这个程序：</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/objc-initialize-print-nothing.png" alt="objc-initialize-print-nothing"></p><p>你会发现与 <code>load</code> 方法不同的是，虽然我们在 <code>initialize</code> 方法中调用了 <code>NSLog</code>。但是程序运行之后没有任何输出。</p><p>如果，我们在自动释放池中加入以下代码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="meta">@autoreleasepool</span> &#123;</span><br><span class="line">        __unused XXObject *object = [[XXObject alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行程序：</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/objc-initialize-print-initialize.png" alt="objc-initialize-print-initialize"></p><p>你会发现，虽然我们没有直接调用 <code>initialize</code> 方法。但是，这里也打印出了 <code>XXObject initialize</code> 字符串。</p><blockquote><p><code>initialize</code> <strong>只会在对应类的方法第一次被调用时，才会调用</strong>。</p></blockquote><p>我们在 <code>initialize</code> 方法中打一个断点，来查看这个方法的调用栈：</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/objc-initialize-breakpoint.png" alt="objc-initialize-breakpoint"></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>+[XXObject initialize]</span><br><span class="line"><span class="symbol">1 </span>_class_initialize</span><br><span class="line"><span class="symbol">2 </span>lookUpImpOrForward</span><br><span class="line"><span class="symbol">3 </span>_class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="symbol">4 </span>objc_msgSend</span><br><span class="line"><span class="symbol">5 </span>main</span><br><span class="line"><span class="symbol">6 </span>start</span><br></pre></td></tr></table></figure><p>直接来看调用栈中的 <code>lookUpImpOrForward</code> 方法，<code>lookUpImpOrForward</code> 方法<strong>只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时</strong>才会调用，具体可以看这篇文章，<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从源代码看%20ObjC%20中消息的发送.md" rel="external nofollow noopener noreferrer" target="_blank">从源代码看 ObjC 中消息的发送</a>。</p><p>在这里，我们知道 <code>lookUpImpOrForward</code> 方法是 <code>objc_msgSend</code> 触发的就够了。</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/objc-initialize-print-selector.png" alt="objc-initialize-print-selecto"></p><p>在 lldb 中输入 <code>p sel</code> 打印选择子，会发现当前调用的方法是 <code>alloc</code> 方法，也就是说，<code>initialize</code> 方法是在 <code>alloc</code> 方法之前调用的，<code>alloc</code> 的调用导致了前者的执行。</p><p>其中，使用 <code>if (initialize  &amp;&amp;  !cls-&gt;isInitialized())</code> 来判断当前类是否初始化过：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool isInitialized() &#123;</span><br><span class="line">   <span class="keyword">return</span> getMeta<span class="function"><span class="params">()</span>-&gt;</span>data<span class="function"><span class="params">()</span>-&gt;</span>flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当前类是否初始化过的信息就保存在<a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">元类</a>的 <code>class_rw_t</code> 结构体中的 <code>flags</code> 中。</p></blockquote><p>这是 <code>flags</code> 中保存的信息，它记录着跟当前类的元数据，其中第 16-31 位有如下的作用：</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/objc-initialize-class_rw_t_-bits-flag.png" alt="objc-initialize-class_rw_t_-bits-flag"></p><p><code>flags</code> 的第 29 位 <code>RW_INITIALIZED</code> 就保存了当前类是否初始化过的信息。</p><h2 id="class-initialize-方法"><a href="#class-initialize-方法" class="headerlink" title="_class_initialize 方法"></a>_class_initialize 方法</h2><p>在 <code>initialize</code> 的调用栈中，直接调用其方法的是下面的这个 C 语言函数：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">void _class_initialize(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    Class supercls;</span><br><span class="line">    <span class="keyword">BOOL</span> reallyInitialize = NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 强制父类先调用 initialize 方法</span></span><br><span class="line">    supercls = <span class="keyword">cls</span>-&gt;superclass;</span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize(supercls);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. 通过加锁来设置 RW_INITIALIZING 标志位</span></span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">cls</span>-&gt;isInitialized() &amp;&amp; !<span class="keyword">cls</span>-&gt;isInitializing()) &#123;</span><br><span class="line">            <span class="keyword">cls</span>-&gt;setInitializing();</span><br><span class="line">            reallyInitialize = YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (reallyInitialize) &#123;</span><br><span class="line">        <span class="comment">// 3. 成功设置标志位，向当前类发送 +initialize 消息</span></span><br><span class="line">        _setThisThreadIsInitializingClass(<span class="keyword">cls</span>);</span><br><span class="line"></span><br><span class="line">        ((void(*)(Class, SEL))objc_msgSend)(<span class="keyword">cls</span>, SEL_initialize);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 完成初始化，如果父类已经初始化完成，设置 RW_INITIALIZED 标志位，</span></span><br><span class="line">        <span class="comment">//    否则，在父类初始化完成之后再设置标志位。</span></span><br><span class="line">        monitor_locker_t lock(classInitLock);</span><br><span class="line">        <span class="keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">            _finishInitializing(<span class="keyword">cls</span>, supercls);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _finishInitializingAfter(<span class="keyword">cls</span>, supercls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;isInitializing()) &#123;</span><br><span class="line">        <span class="comment">// 5. 当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回</span></span><br><span class="line">        <span class="keyword">if</span> (_thisThreadIsInitializingClass(<span class="keyword">cls</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            monitor_locker_t lock(classInitLock);</span><br><span class="line">            <span class="keyword">while</span> (!<span class="keyword">cls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">                classInitLock.<span class="built_in">wait</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">        <span class="comment">// 6. 初始化成功后，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _objc_fatal(<span class="string">"thread-safe class init in objc runtime is buggy!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的主要作用自然是向未初始化的类发送 <code>+initialize</code> 消息，不过会强制父类先发送 <code>+initialize</code>。</p><ol><li><p>强制<strong>未初始化过的</strong>父类调用 <code>initialize</code> 方法</p> <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>initialize(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过加锁来设置 <code>RW_INITIALIZING</code> 标志位</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">monitor_locker_t lock(classInitLock);</span><br><span class="line"><span class="function"><span class="title">if</span> (!cls-&gt;</span><span class="function"><span class="title">isInitialized</span>() &amp;&amp; !cls-&gt;</span>isInitializing()) &#123;</span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>setInitializing();</span><br><span class="line">    reallyInitialize = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成功设置标志位、向当前类发送 <code>+initialize</code> 消息</p> <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">void</span>(<span class="name"><span class="builtin-name">*</span></span>)(<span class="name">Class</span>, SEL))objc_msgSend)(<span class="name">cls</span>, SEL_initialize)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>完成初始化，如果父类已经初始化完成，设置 <code>RW_INITIALIZED</code> 标志位。否则，在父类初始化完成之后再设置标志位</p> <figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">monitor_locker_t <span class="built_in">lock</span>(classInitLock);</span><br><span class="line"><span class="keyword">if</span> (!supercls  ||  supercls-&gt;isInitialized()) &#123;</span><br><span class="line">    <span class="variable">_finishInitializing</span>(cls, supercls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable">_finishInitializingAfter</span>(cls, supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回，<strong>保证线程安全</strong></p> <figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_thisThreadIsInitializingClass(<span class="keyword">cls</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    monitor_locker_t lock(classInitLock);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="keyword">cls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">        classInitLock.<span class="built_in">wait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化成功后，直接返回</p> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="管理初始化队列"><a href="#管理初始化队列" class="headerlink" title="管理初始化队列"></a>管理初始化队列</h2><p>因为我们始终要保证父类的初始化方法要在子类之前调用，所以我们需要维护一个 <code>PendingInitializeMap</code> 的数据结构来存储<strong>当前的类初始化需要哪个父类先初始化完成</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/12_initialize/PendingInitializeMap.png" alt="PendingInitializeMap"></p><p>这个数据结构中的信息会被两个方法改变：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!supercls  |<span class="type">|  supercls</span>-&gt;isInitialized()) &#123;</span><br><span class="line">  _finishInitializing(cls, supercls);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  _finishInitializingAfter(cls, supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别是 <code>_finishInitializing</code> 以及 <code>_finishInitializingAfter</code>，先来看一下后者是怎么实现的，也就是<strong>在父类没有完成初始化的时候</strong>调用的方法：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializingAfter(Class cls, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending<span class="comment">;</span></span><br><span class="line">    pending = (PendingInitialize *)malloc(sizeof(*pending))<span class="comment">;</span></span><br><span class="line">    pending-&gt;<span class="keyword">subclass </span>= cls<span class="comment">;</span></span><br><span class="line">    pending-&gt;next = (PendingInitialize *)NXMapGet(pendingInitializeMap, supercls)<span class="comment">;</span></span><br><span class="line">    NXMapInsert(pendingInitializeMap, supercls, pending)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为当前类的父类没有初始化，所以会将子类加入一个数据结构 <code>PendingInitialize</code> 中，这个数据结构其实就类似于一个保存子类的链表。这个链表会以父类为键存储到 <code>pendingInitializeMap</code> 中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NXMapInsert(pendingInitializeMap, supercls, pending);</span><br></pre></td></tr></table></figure><p>而在<strong>父类已经调用了初始化方法</strong>的情况下，对应方法 <code>_finishInitializing</code> 的实现就稍微有些复杂了：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializing(Class <span class="keyword">cls</span>, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">cls</span>-&gt;setInitialized()<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!pendingInitializeMap) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">if</span> (!pending) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    NXMapRemove(pendingInitializeMap, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pending) &#123;</span><br><span class="line">        PendingInitialize *<span class="keyword">next</span> = pending-&gt;<span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">        <span class="keyword">if</span> (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">        free(pending)<span class="comment">;</span></span><br><span class="line">        pending = <span class="keyword">next</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后<strong>递归地将被当前类 block 的子类标记为已初始化</strong>，再把这些当类移除 <code>pendingInitializeMap</code>。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们对 <code>initialize</code> 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性：</p><ol><li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li><li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中</li><li><code>initialize</code> 的运行是线程安全的</li><li>子类会<strong>继承</strong>父类的 <code>initialize</code> 方法</li></ol><p>而其作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></li><li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" rel="external nofollow noopener noreferrer" target="_blank">NSObject +load and +initialize - What do they do?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章可能是对 Objective-C 源代码解析系列文章中最短的一篇了，在 Objective-C 中，我们总是会同时想到 &lt;code&gt;load&lt;/code&gt;、&lt;code&gt;initialize&lt;/code&gt; 这两个类方法。而这两个方法也经常在一起比较。&lt;/p&gt;
&lt;p&gt;本文会主要介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;initialize&lt;/code&gt; 方法的调用为什么是惰性的。&lt;/li&gt;
&lt;li&gt;这货能干啥。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="initialize" scheme="http://yoursite.com/tags/initialize/"/>
    
  </entry>
  
  <entry>
    <title>11. 你真的了解 load 方法么？</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/11_load/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/11_load/</id>
    <published>2018-12-01T03:38:11.000Z</published>
    <updated>2018-12-03T07:49:46.425Z</updated>
    
    <content type="html"><![CDATA[<p>__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。</p><a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>文章的标题与其说是问各位读者，不如说是问笔者自己：<strong>我</strong>真的了解 <code>+ load</code> 方法么？</p></blockquote><p><code>+ load</code> 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个<strong>在整个文件被加载到运行时，在 <code>main</code> 函数调用之前被 ObjC 运行时调用的钩子方法</strong>。其中关键字有这么几个：</p><ul><li>文件刚加载</li><li><code>main</code> 函数之前</li><li>钩子方法</li></ul><p>我在阅读 ObjC 源代码之前，曾经一度感觉自己对 <code>+ load</code> 方法的作用非常了解，直到看了源代码中的实现，才知道以前的以为，只是自己的以为罢了。</p><p>这篇文章会假设你知道：</p><ul><li>使用过 <code>+ load</code> 方法</li><li>知道 <code>+ load</code> 方法的调用顺序（文章中会简单介绍）</li></ul><p>在这篇文章中并不会用大篇幅介绍 <code>+ load</code> 方法的作用<del>其实也没几个作用</del>，关注点主要在以下两个问题上：</p><ul><li><code>+ load</code> 方法是如何被调用的</li><li><code>+ load</code> 方法为什么会有这种调用顺序</li></ul><h2 id="load-方法的调用栈"><a href="#load-方法的调用栈" class="headerlink" title="load 方法的调用栈"></a>load 方法的调用栈</h2><p>首先来通过 <code>load</code> 方法的调用栈，分析一下它到底是如何被调用的。</p><p>下面是程序的全部代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span> @<span class="title">end</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"XXObject load"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码总共只实现了一个 <code>XXObject</code> 的 <code>+ load</code> 方法，主函数中也没有任何的东西：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/11_loadprint-load.png" alt="objc-load-print-load"></p><p>虽然在主函数中什么方法都没有调用，但是运行之后，依然打印了 <code>XXObject load</code> 字符串，也就是说调用了 <code>+ load</code> 方法。</p><h3 id="使用符号断点"><a href="#使用符号断点" class="headerlink" title="使用符号断点"></a>使用符号断点</h3><p>使用 Xcode 添加一个符号断点 <code>+[XXObject load]</code>：</p><blockquote><p>注意这里 <code>+</code> 和 <code>[</code> 之间没有空格</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-symbolic-breakpoint.png" alt="objc-load-symbolic-breakpoint"></p><blockquote><p>为什么要加一个符号断点呢？因为这样看起来比较高级。</p></blockquote><p>重新运行程序。这时，代码会停在 <code>NSLog(@&quot;XXObject load&quot;);</code> 这一行的实现上：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-break-after-add-breakpoint.png" alt="objc-load-break-after-add-breakpoint"></p><p>左侧的调用栈很清楚的告诉我们，哪些方法被调用了：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span> +[XXObject <span class="keyword">load</span>]</span><br><span class="line"><span class="symbol">1 </span> call_class_loads()</span><br><span class="line"><span class="symbol">2 </span> call_load_methods</span><br><span class="line"><span class="symbol">3 </span> load_images</span><br><span class="line"><span class="symbol">4 </span> dyld::notifySingle(dyld_image_states, ImageLoader const*)</span><br><span class="line"><span class="symbol">11 </span>_dyld_start</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/dyld.3.html" rel="external nofollow noopener noreferrer" target="_blank">dyld</a> 是 the dynamic link editor 的缩写，它是苹果的<em>动态链接器</em>。</p><p>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。本文不会对其进行解释</p></blockquote><p>每当有新的镜像加载之后，都会执行 <code>3 load_images</code> 方法进行回调，这里的回调是在整个运行时初始化时 <code>_objc_init</code> 注册的（会在之后的文章中具体介绍）：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dyld_register_image_state_change_handler(<span class="name">dyld_image_state_dependents_initialized</span>, <span class="number">0</span>/*not batch*/, <span class="symbol">&amp;load_images</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>有新的镜像被加载到 runtime 时，调用 <code>load_images</code> 方法，并传入最新镜像的信息列表 <code>infoList</code>：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const char *</span><br><span class="line">load_images(<span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span> <span class="title">state</span>, <span class="title">uint32_t</span> <span class="title">infoCount</span>,</span></span><br><span class="line">            const <span class="class"><span class="keyword">struct</span> <span class="title">dyld_image_info</span> <span class="title">infoList</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    bool found;</span><br><span class="line"></span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    recursive_mutex_locker_t lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        rwlock_writer_t lock2(runtimeLock);</span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        call_load_methods();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h3><p>这里就会遇到一个问题：镜像到底是什么，我们用一个断点打印出所有加载的镜像：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-print-image-info.png" alt="objc-load-print-image-info"></p><p>从控制台输出的结果大概就是这样的，我们可以看到镜像并不是一个 Objective-C 的代码文件，它应该是一个 target 的编译产物。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">(const dyld_image_info) $<span class="number">52</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff8a144000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff8a144168</span> <span class="string">"/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737802</span></span><br><span class="line">&#125;</span><br><span class="line">(const dyld_image_info) $<span class="number">53</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff946d9000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff946d9480</span> <span class="string">"/usr/lib/liblangid.dylib"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737618</span></span><br><span class="line">&#125;</span><br><span class="line">(const dyld_image_info) $<span class="number">54</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x00007fff88016000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff88016d40</span> <span class="string">"/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation"</span></span><br><span class="line">  imageFileModDate = <span class="number">1452737917</span></span><br><span class="line">&#125;</span><br><span class="line">(const dyld_image_info) $<span class="number">55</span> = &#123;</span><br><span class="line">  imageLoadAddress = <span class="number">0x0000000100000000</span></span><br><span class="line">  imageFilePath = <span class="number">0x00007fff5fbff8f0</span> <span class="string">"/Users/apple/Library/Developer/Xcode/DerivedData/objc-dibgivkseuawonexgbqssmdszazo/Build/Products/Debug/debug-objc"</span></span><br><span class="line">  imageFileModDate = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有很多的动态链接库，还有一些苹果为我们提供的框架，比如 Foundation、 CoreServices 等等，都是在这个 <code>load_images</code> 中加载进来的，而这些 <code>imageFilePath</code> 都是对应的<strong>二进制文件</strong>的地址。</p><p>但是如果进入最下面的这个目录，会发现它是一个<strong>可执行文件</strong>，它的运行结果与 Xcode 中的运行结果相同：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-image-binary.png" alt="objc-load-image-binary"></p><h3 id="准备-load-方法"><a href="#准备-load-方法" class="headerlink" title="准备 + load 方法"></a>准备 + load 方法</h3><p>我们重新回到 <code>load_images</code> 方法，如果在扫描镜像的过程中发现了 <code>+ load</code> 符号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">        found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会进入 <code>load_images_nolock</code> 来查找 <code>load</code> 方法：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">bool load_images_nolock(<span class="class"><span class="keyword">enum</span> <span class="title">dyld_image_states</span> <span class="title">state</span>,<span class="title">uint32_t</span> <span class="title">infoCount</span>,</span></span><br><span class="line">                   const <span class="class"><span class="keyword">struct</span> <span class="title">dyld_image_info</span> <span class="title">infoList</span>[])</span></span><br><span class="line">&#123;</span><br><span class="line">    bool found = NO;</span><br><span class="line">    uint32_t i;</span><br><span class="line"></span><br><span class="line">    i = infoCount;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        const headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;</span><br><span class="line">        <span class="keyword">if</span> (!hasLoadMethods(mhdr)) continue;</span><br><span class="line"></span><br><span class="line">        prepare_load_methods(mhdr);</span><br><span class="line">        found = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用 <code>prepare_load_methods</code> 对 <code>load</code> 方法的调用进行准备（将需要调用 <code>load</code> 方法的类添加到一个列表中，后面的小节中会介绍）：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void prepare_load_methods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t <span class="built_in">count</span>, i<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(mhdr, &amp;<span class="built_in">count</span>)<span class="comment">;</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">; i &lt; count; i++) &#123;</span></span><br><span class="line">        <span class="keyword">schedule_class_load(remapClass(classlist[i]));</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line"></span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;<span class="built_in">count</span>)<span class="comment">;</span></span><br><span class="line">    for (i = <span class="number">0</span><span class="comment">; i &lt; count; i++) &#123;</span></span><br><span class="line">        category_t *cat = categorylist[i]<span class="comment">;</span></span><br><span class="line">        Class cls = remapClass(cat-&gt;cls)<span class="comment">;</span></span><br><span class="line">        if (!cls) continue<span class="comment">;  // category for ignored weak-linked class</span></span><br><span class="line">        realizeClass(cls)<span class="comment">;</span></span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized())<span class="comment">;</span></span><br><span class="line">        <span class="keyword">add_category_to_loadable_list(cat);</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>_getObjc2NonlazyClassList</code> 获取所有的类的列表之后，会通过 <code>remapClass</code> 获取类对应的指针，然后调用 <code>schedule_class_load</code> <strong>递归地安排当前类和没有调用 <code>+ load</code> 父类</strong>进入列表。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="keyword">cls</span>-&gt;isRealized())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    schedule_class_load(<span class="keyword">cls</span>-&gt;superclass)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(<span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;setInfo(RW_LOADED)<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 <code>add_class_to_loadable_list(cls)</code> 将当前类加入加载列表之前，会<strong>先把父类加入待加载的列表</strong>，保证父类在子类前调用 <code>load</code> 方法。</p><h3 id="调用-load-方法"><a href="#调用-load-方法" class="headerlink" title="调用 + load 方法"></a>调用 + load 方法</h3><p>在将镜像加载到运行时、对 <code>load</code> 方法的准备就绪之后，执行 <code>call_load_methods</code>，开始调用 <code>load</code> 方法：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void call_load_methods<span class="comment">(void)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0)</span> &#123;</span><br><span class="line">            call_class_loads<span class="comment">()</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        more_categories = call_category_loads<span class="comment">()</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0  ||  more_categories)</span>;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的调用流程大概是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-diagram.png" alt="objc-load-diagra"></p><p>其中 <code>call_class_loads</code> 会从一个待加载的类列表 <code>loadable_classes</code> 中寻找对应的类，然后找到 <code>@selector(load)</code> 的实现并执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used;</span><br><span class="line">    loadable_classes = nil;</span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_classes_used = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        (*load_method)(cls, SEL_load);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这行 <code>(*load_method)(cls, SEL_load)</code> 代码就会调用 <code>+[XXObject load]</code> 方法。</p><blockquote><p>我们会在下面介绍 <code>loadable_classes</code> 列表是如何管理的。</p></blockquote><p>到现在，我们回答了第一个问题：</p><p>Q：<strong><code>load</code> 方法是如何被调用的？</strong></p><p>A：当 Objective-C 运行时初始化的时候，会通过 <code>dyld_register_image_state_change_handler</code> 在每次有新的镜像加入<em>运行时</em>的时候，进行回调。执行 <code>load_images</code> 将所有包含 <code>load</code> 方法的文件加入列表 <code>loadable_classes</code> ，然后从这个列表中找到对应的 <code>load</code> 方法的实现，调用 <code>load</code> 方法。</p><h2 id="加载的管理"><a href="#加载的管理" class="headerlink" title="加载的管理"></a>加载的管理</h2><p>ObjC 对于加载的管理，主要使用了两个列表，分别是 <code>loadable_classes</code> 和 <code>loadable_categories</code>。</p><p>方法的调用过程也分为两个部分，准备 <code>load</code> 方法和调用 <code>load</code> 方法，我更觉得这两个部分比较像生产者与消费者：</p><p><img src="/wiki/IOS/Runtime/objc/11_load/objc-load-producer-consumer-diagram.png" alt="objc-load-producer-consumer-diagra"></p><p><code>add_class_to_loadable_list</code> 方法负责将类加入 <code>loadable_classes</code> 集合，而 <code>call_class_loads</code> 负责消费集合中的元素。</p><p>而对于分类来说，其模型也是类似的，只不过使用了另一个列表 <code>loadable_categories</code>。</p><h3 id="“生产”-loadable-class"><a href="#“生产”-loadable-class" class="headerlink" title="“生产” loadable_class"></a>“生产” loadable_class</h3><p>在调用 <code>load_images -&gt; load_images_nolock -&gt; prepare_load_methods -&gt; schedule_class_load -&gt; add_class_to_loadable_list</code> 的时候会将未加载的类添加到 <code>loadable_classes</code> 数组中：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IMP <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">method</span> =</span> cls-&gt;getLoadMethod();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="function"><span class="keyword">method</span>) <span class="title">return</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        loadable_classes = (struct loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(struct loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">    loadable_classes_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法刚被调用时：</p><ol><li>会从 <code>class</code> 中获取 <code>load</code> 方法： <code>method = cls-&gt;getLoadMethod();</code></li><li>判断当前 <code>loadable_classes</code> 这个数组是否已经被全部占用了：<code>loadable_classes_used == loadable_classes_allocated</code></li><li>在当前数组的基础上扩大数组的大小：<code>realloc</code></li><li>把传入的 <code>class</code> 以及对应的方法的实现加到列表中</li></ol><p>另外一个用于保存分类的列表 <code>loadable_categories</code> 也有一个类似的方法 <code>add_category_to_loadable_list</code>。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    IMP method;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    loadMethodLock.assertLocked();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    method = _category_getLoadMethod(cat);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (!method) return;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    if (loadable_categories_used == loadable_categories_allocated) &#123;</span></span><br><span class="line"><span class="comment">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span></span><br><span class="line"><span class="comment">        loadable_categories = (struct loadable_category *)</span></span><br><span class="line"><span class="comment">            realloc(loadable_categories,</span></span><br><span class="line"><span class="comment">                              loadable_categories_allocated *</span></span><br><span class="line"><span class="comment">                              sizeof(struct loadable_category));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现几乎与 <code>add_class_to_loadable_list</code> 完全相同。</p><p>到这里我们完成了对 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 的提供，下面会开始消耗列表中的元素。</p><h3 id="“消费”-loadable-class"><a href="#“消费”-loadable-class" class="headerlink" title="“消费” loadable_class"></a>“消费” loadable_class</h3><p>调用 <code>load</code> 方法的过程就是“消费” <code>loadable_classes</code> 的过程，<code>load_images -&gt; call_load_methods -&gt; call_class_loads</code> 会从 <code>loadable_classes</code> 中取出对应类和方法，执行 <code>load</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法对所有在 <code>loadable_classes</code> 以及 <code>loadable_categories</code> 中的类以及分类执行 <code>load</code> 方法。</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0)</span> &#123;</span><br><span class="line">        call_class_loads<span class="comment">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    more_categories = call_category_loads<span class="comment">()</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0  ||  more_categories)</span>;</span><br></pre></td></tr></table></figure><p>调用顺序如下：</p><ol><li>不停调用类的 <code>+ load</code> 方法，直到 <code>loadable_classes</code> 为空</li><li>调用<strong>一次</strong> <code>call_category_loads</code> 加载分类</li><li>如果有 <code>loadable_classes</code> 或者更多的分类，继续调用 <code>load</code> 方法</li></ol><p>相比于类 <code>load</code> 方法的调用，分类中 <code>load</code> 方法的调用就有些复杂了：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">static bool call_category_loads(void)</span><br><span class="line">&#123;</span><br><span class="line">    int i, shift;</span><br><span class="line">    bool <span class="attr">new_categories_added</span> = NO;</span><br><span class="line">    // <span class="number">1</span>. 获取当前可以加载的分类列表</span><br><span class="line">    struct loadable_category *<span class="attr">cats</span> = loadable_categories;</span><br><span class="line">    int <span class="attr">used</span> = loadable_categories_used;</span><br><span class="line">    int <span class="attr">allocated</span> = loadable_categories_allocated;</span><br><span class="line">    <span class="attr">loadable_categories</span> = nil;</span><br><span class="line">    <span class="attr">loadable_categories_allocated</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="attr">loadable_categories_used</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    for (<span class="attr">i</span> = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category <span class="attr">cat</span> = cats[i].cat;</span><br><span class="line">        load_method_t <span class="attr">load_method</span> = (load_method_t)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) continue;</span><br><span class="line"></span><br><span class="line">        <span class="attr">cls</span> = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            // <span class="number">2</span>. 如果当前类是可加载的 `cls  &amp;&amp;  cls-&gt;isLoadable()` 就会调用分类的 load 方法</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].<span class="attr">cat</span> = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // <span class="number">3</span>. 将所有加载过的分类移除 `loadable_categories` 列表</span><br><span class="line">    <span class="attr">shift</span> = <span class="number">0</span>;</span><br><span class="line">    for (<span class="attr">i</span> = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used <span class="attr">-=</span> shift;</span><br><span class="line"></span><br><span class="line">    // <span class="number">4</span>. 为 `loadable_categories` 重新分配内存，并重新设置它的值</span><br><span class="line">    <span class="attr">new_categories_added</span> = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    for (<span class="attr">i</span> = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="attr">used</span> == allocated) &#123;</span><br><span class="line">            <span class="attr">allocated</span> = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            <span class="attr">cats</span> = (struct loadable_category *)</span><br><span class="line">                realloc(cats, allocated *</span><br><span class="line">                                  sizeof(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) free(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        <span class="attr">loadable_categories</span> = cats;</span><br><span class="line">        <span class="attr">loadable_categories_used</span> = used;</span><br><span class="line">        <span class="attr">loadable_categories_allocated</span> = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) free(cats);</span><br><span class="line">        <span class="attr">loadable_categories</span> = nil;</span><br><span class="line">        <span class="attr">loadable_categories_used</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="attr">loadable_categories_allocated</span> = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法有些长，我们来分步解释方法的作用：</p><ol><li>获取当前可以加载的分类列表</li><li>如果当前类是可加载的 <code>cls  &amp;&amp;  cls-&gt;isLoadable()</code> 就会调用分类的 <code>load</code> 方法</li><li>将所有加载过的分类移除 <code>loadable_categories</code> 列表</li><li>为 <code>loadable_categories</code> 重新分配内存，并重新设置它的值</li></ol><h2 id="调用的顺序"><a href="#调用的顺序" class="headerlink" title="调用的顺序"></a>调用的顺序</h2><p>你过去可能会听说过，对于 <code>load</code> 方法的调用顺序有两条规则：</p><ol><li>父类先于子类调用</li><li>类先于分类调用</li></ol><p>这种现象是非常符合我们的直觉的，我们来分析一下这种现象出现的原因。</p><p>第一条规则是由于 <code>schedule_class_load</code> 有如下的实现：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void schedule_class_load(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">assert</span>(<span class="keyword">cls</span>-&gt;isRealized())<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">cls</span>-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    schedule_class_load(<span class="keyword">cls</span>-&gt;superclass)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(<span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">cls</span>-&gt;setInfo(RW_LOADED)<span class="comment">; </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过这行代码 <code>schedule_class_load(cls-&gt;superclass)</code> 总是能够保证没有调用 <code>load</code> 方法的父类先于子类加入 <code>loadable_classes</code> 数组，从而确保其调用顺序的正确性。</p><p>类与分类中 <code>load</code> 方法的调用顺序主要在 <code>call_load_methods</code> 中实现：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0)</span> &#123;</span><br><span class="line">        call_class_loads<span class="comment">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    more_categories = call_category_loads<span class="comment">()</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> <span class="comment">(loadable_classes_used &gt; 0  ||  more_categories)</span>;</span><br></pre></td></tr></table></figure><p>上面的 <code>do while</code> 语句能够在一定程度上确保，类的 <code>load</code> 方法会先于分类调用。但是这里不能完全保证调用顺序的正确。</p><p>如果<strong>分类的镜像在类的镜像之前加载到运行时</strong>，上面的代码就没法保证顺序的正确了，所以，我们还需要在 <code>call_category_loads</code> 中判断类是否已经加载到内存中（调用 <code>load</code> 方法）：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">cls</span>  &amp;&amp;  <span class="built_in">cls</span>-&gt;isLoadable()) &#123;</span><br><span class="line">    (*load_method)(<span class="built_in">cls</span>, SEL_load);</span><br><span class="line">    cats[i].cat = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，检查了类是否存在并且是否可以加载，如果都为真，那么就可以调用分类的 load 方法了。</p><h2 id="load-的应用"><a href="#load-的应用" class="headerlink" title="load 的应用"></a>load 的应用</h2><p><code>load</code> 可以说我们在日常开发中可以接触到的调用时间<strong>最靠前的方法</strong>，在主函数运行之前，<code>load</code> 方法就会调用。</p><p>由于它的调用不是<em>惰性</em>的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 <code>load</code> 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 <code>load</code> 方法成为了<a href="http://nshipster.com/method-swizzling/" rel="external nofollow noopener noreferrer" target="_blank">方法调剂</a>的绝佳时机。</p><p>但是由于 <code>load</code> 方法的运行时间过早，所以这里可能不是一个理想的环境，因为<strong>某些类可能需要在在其它类之前加载</strong>，但是这是我们无法保证的。不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" rel="external nofollow noopener noreferrer" target="_blank">NSObject +load and +initialize - What do they do?</a></li><li><a href="http://nshipster.com/method-swizzling/" rel="external nofollow noopener noreferrer" target="_blank">Method Swizzling</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2009-05-22-objective-c-class-loading-and-initialization.html" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Class Loading and Initialization</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="load" scheme="http://yoursite.com/tags/load/"/>
    
  </entry>
  
  <entry>
    <title>13. _class_initialize 源码分析</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/13_class_initialize/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/13_class_initialize/</id>
    <published>2018-12-01T03:38:11.000Z</published>
    <updated>2018-12-04T03:49:16.860Z</updated>
    
    <content type="html"><![CDATA[<p>本文是我自己理解_class_initialize的记录</p><a id="more"></a><h2 id="class-initialize-源码分析"><a href="#class-initialize-源码分析" class="headerlink" title="_class_initialize 源码分析"></a>_class_initialize 源码分析</h2><h3 id="class-initialize-干什么"><a href="#class-initialize-干什么" class="headerlink" title="_class_initialize 干什么"></a>_class_initialize 干什么</h3><p>_class_initialize 主要功能是调用+initialize方法。简化代码如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_initialize(<span class="keyword">Class</span> cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用 +initialize，主要的初始化工作，就是调用这个方法</span></span><br><span class="line">    <span class="comment">// 注意：如果 cls 没有实现 +initialize 方法的话，它会被发给父类</span></span><br><span class="line">    ((<span class="keyword">void</span>(*)(<span class="keyword">Class</span>, SEL))objc_msgSend)(cls, SEL_initialize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程调用-class-initialize的问题"><a href="#多线程调用-class-initialize的问题" class="headerlink" title="多线程调用_class_initialize的问题"></a>多线程调用_class_initialize的问题</h3><p>假如有下面的示例：</p><p><img src="/wiki/IOS/Runtime/objc/13_class_initialize/class_deadloack.png" alt="objc-initialize-print-nothing"></p><p>调用的顺序如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">线程 <span class="number">1</span> ：</span><br><span class="line">    初始化 OWA<span class="function"><span class="title">ddressEntry</span> 类 -&gt;</span></span><br><span class="line">    初始化 OFO<span class="function"><span class="title">bject</span> 类 -&gt;</span></span><br><span class="line">    初始化 OBO<span class="function"><span class="title">bject</span> 类 -&gt;</span></span><br><span class="line">    [OBO<span class="function"><span class="title">bject</span> initialize] 中用了 OBPostLoader 类，里面需要初始化好多类 -&gt;</span></span><br><span class="line">    初始化 OWC<span class="function"><span class="title">onsoleController</span> 类 -&gt;</span></span><br><span class="line">    初始化 OWController 类，发现线程<span class="number">2</span>正在初始化 OWController 类，就阻塞等待线程<span class="number">2</span>完成对 OWController 的初始化工作 ....</span><br><span class="line"> </span><br><span class="line">线程 <span class="number">2</span> ：</span><br><span class="line">    初始化 OWC<span class="function"><span class="title">ontroller</span> 类 -&gt;</span></span><br><span class="line">    初始化 OFObject 类，发现线程<span class="number">1</span>正在初始化 OFObject 类，就阻塞等待线程<span class="number">1</span>完成对 OFObject 类的初始化工作....：</span><br></pre></td></tr></table></figure><p>上面这种多线程场景，就会出现死锁的问题。</p><p>解决办法：</p><p>父类一定比子类先开始初始化。<br>因为 OWController的父类 OFObject 还没有初始化，所以它也不会开始初始化，而是等到父类在同一线程开始初始化，或者在另一线程完成初始化后，才会进行初始化。所以线程2并没有在初始化OWController，线程1也并不需要等待，也就是没有了竞争和死锁。</p><h3 id="保证父类的initialize如何比子类的调用早（早进入）"><a href="#保证父类的initialize如何比子类的调用早（早进入）" class="headerlink" title="保证父类的initialize如何比子类的调用早（早进入）"></a>保证父类的initialize如何比子类的调用早（早进入）</h3><p>父类的initialize如何比子类的调用早 通过下面的代码实现：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (supercls  &amp;&amp;  !supercls-&gt;isInitialized())<span class="comment">///父类递归调用本函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">_</span><span class="keyword">class</span><span class="number">_</span>initialize(supercls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何等待父类调用完成"><a href="#如何等待父类调用完成" class="headerlink" title="如何等待父类调用完成"></a>如何等待父类调用完成</h3><p>假如：有下面一个例子，如何保证父类比子类调用早呢 ？</p><p><img src="/wiki/IOS/Runtime/objc/13_class_initialize/class_initialize_example.png" alt="objc-initialize-print-nothing"></p><p>调用的顺序如下：<br><img src="/wiki/IOS/Runtime/objc/13_class_initialize/class_initialize_cicle.png" alt="objc-initialize-print-nothing"></p><ol><li>首先进入OWAddressEntry 找父类</li><li>OFObject 找父类</li><li>OBObject 执行initialize方法</li><li>[OBObject initialize] 中用了 OBPostLoader 类，里面需要初始化好多类 </li><li>初始化 OWController 类 找父类</li><li>再次进入OFObject 这里就重复进入了， 解决办法，查看父类正在RW_INITIALIZING，就不能在进入，直接开始OFObject的初始化。</li></ol><p>这样就出现了一个问题，OFObject会比父类OBObject早结束initialize方法，这样是一个不完全的初始化，所以先将OFObject保持起来，等到父类完成了，然后在设置OFObject为初始哈完成状态。</p><p>这里就用到了一个数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PendingInitialize</span> &#123;</span></span><br><span class="line">    Class subclass;                 <span class="comment">// 子类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PendingInitialize</span> *<span class="title">next</span>;</span> <span class="comment">// 下一个，看来是一个链表</span></span><br><span class="line">&#125; PendingInitialize;</span><br></pre></td></tr></table></figure><p>保存方法如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _finishInitializingAfter(<span class="keyword">Class</span> cls, <span class="keyword">Class</span> supercls)</span><br><span class="line">&#123;</span><br><span class="line">    PendingInitialize *pending;</span><br><span class="line">    </span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    pending-&gt;subclass = cls; <span class="comment">// pending 记录子类 cls</span></span><br><span class="line">    <span class="comment">// next 指向下一个 pending，因为类会多个子类，所以还是才用了树的结构，next 指向的是兄弟节点</span></span><br><span class="line">    pending-&gt;<span class="keyword">next</span> = (PendingInitialize *) NXMapGet(pendingInitializeMap, supercls);</span><br><span class="line">    <span class="comment">// 将 pending 插入 pendingInitializeMap 中，key 是父类</span></span><br><span class="line">    NXMapInsert(pendingInitializeMap, supercls, pending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果OFObject比OBObject先初始化完成，就调用_finishInitializingAfter将OFObject保存起来，等到父类OBObject初始化完成，在调用_finishInitializing从pendingInitializeMap中删除，同时置OFObject为初始化完成状态。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void _finishInitializing(Class <span class="keyword">cls</span>, Class supercls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">cls</span>-&gt;setInitialized()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // 利用 key <span class="keyword">cls</span> 将 pending链表 从 pendingInitializeMap 中移除</span><br><span class="line">    NXMapRemove(pendingInitializeMap, <span class="keyword">cls</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们对 <code>initialize</code> 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性：</p><ol><li><code>initialize</code> 的调用是惰性的，它会在第一次调用当前类的方法时被调用</li><li>与 <code>load</code> 不同，<code>initialize</code> 方法调用时，所有的类都<strong>已经加载</strong>到了内存中</li><li><code>initialize</code> 的运行是线程安全的</li><li>子类会<strong>继承</strong>父类的 <code>initialize</code> 方法</li></ol><p>而其作用也非常局限，一般我们只会在 <code>initialize</code> 方法中进行一些常量的初始化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></li><li><a href="http://stackoverflow.com/questions/13326435/nsobject-load-and-initialize-what-do-they-do" rel="external nofollow noopener noreferrer" target="_blank">NSObject +load and +initialize - What do they do?</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是我自己理解_class_initialize的记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="initialize" scheme="http://yoursite.com/tags/initialize/"/>
    
  </entry>
  
  <entry>
    <title>10.load_images 函数分析</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/10_load_images/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/10_load_images/</id>
    <published>2018-11-30T02:38:11.000Z</published>
    <updated>2018-11-30T09:44:52.583Z</updated>
    
    <content type="html"><![CDATA[<p>本文分析load_images 函数,该函数完成+load方法的调用。</p><a id="more"></a><h2 id="load-images-相关的数据结构"><a href="#load-images-相关的数据结构" class="headerlink" title="load_images 相关的数据结构"></a>load_images 相关的数据结构</h2><p>在_objc_init 函数中，dyld_register_image_state_change_handler 将 load_images 作为回调函数注册给dylib，所以，当镜像的状态变化时，会回调load_images函数。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _objc_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分析load_images前，先介绍相关的数据结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">load_method_t</span>)</span><span class="params">(id, SEL)</span></span>; <span class="comment">// 用于 +load 方法的 imp 类型</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> &#123;</span> <span class="comment">// 需要被调用 +load 方法的类</span></span><br><span class="line">    Class cls;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// +load 方法对应的 imp</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> &#123;</span> <span class="comment">// 需要被调用 +load 方法的分类</span></span><br><span class="line">    Category cat;  <span class="comment">// may be nil</span></span><br><span class="line">    IMP method; <span class="comment">// +load 方法对应的 imp</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of classes that need +load called (pending superclass +load)</span></span><br><span class="line"><span class="comment">// This list always has superclasses first because of the way it is constructed</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">loadable_classes</span> = <span class="title">nil</span>;</span> <span class="comment">// 这个列表中存放所有需要调用 +load 方法的类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_classes_used = <span class="number">0</span>; <span class="comment">// loadable_classes 列表中已经被使用了多少个位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_classes_allocated = <span class="number">0</span>; <span class="comment">// loadable_classes 列表开辟了多少位置，如果位置不够用了，会进行扩容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// List of categories that need +load called (pending parent class +load)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">loadable_categories</span> = <span class="title">nil</span>;</span> <span class="comment">// 这个列表中存放所有需要执行 +load 方法的分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_categories_used = <span class="number">0</span>; <span class="comment">// loadable_categories 列表中已经被使用了多少个位置</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> loadable_categories_allocated = <span class="number">0</span>; <span class="comment">// loadable_categories 列表开辟了多少位置，如果位置不够用了，会进行扩容</span></span><br></pre></td></tr></table></figure><p>可load 的class相关的数据结构：</p><p><img src="/wiki/IOS/Runtime/objc/10_load_images/loadable_class.png" alt="_read_images 的意义"></p><p>可load 的category相关的数据结构：</p><p><img src="/wiki/IOS/Runtime/objc/10_load_images/loadable_category.png" alt="_read_images 的意义"></p><h2 id="load-images-源码分析"><a href="#load-images-源码分析" class="headerlink" title="load_images 源码分析"></a>load_images 源码分析</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">load_images(<span class="keyword">enum</span> dyld_image_states state, <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">            <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found;</span><br><span class="line">    found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; infoCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 快速扫描镜像中是否有 +load 方法 (其实只查找了镜像中是否有类或分类）</span></span><br><span class="line">        <span class="comment">// imageLoadAddress 是镜像加载的内存地址</span></span><br><span class="line">        <span class="keyword">if</span> (hasLoadMethods((<span class="keyword">const</span> headerType *)infoList[i].imageLoadAddress)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!found) <span class="keyword">return</span> nil; <span class="comment">// 如果没有找到，就直接返回 nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Discover load methods</span></span><br><span class="line">    &#123; <span class="comment">// 加上括号，是为了 runtimeLock 锁，可以在这个块内自动释放，否则下次重入该函数时，会死锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock2(runtimeLock); <span class="comment">// runtimeLock 加写锁</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 做一些准备工作，将需要 +load 的类和分类分别存储到 loadable_classes、loadable_categories 中，</span></span><br><span class="line">        <span class="comment">// 在 call_load_methods() 中才有类可以调 +load</span></span><br><span class="line">        <span class="comment">// 并进一步确认是否真的有类或分类需要调用 +load</span></span><br><span class="line">        found = load_images_nolock(state, infoCount, infoList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">    <span class="comment">// 不加 runtimeLock 锁，是因为 runtimeLock 与递归锁不一样，它是不可重入的，</span></span><br><span class="line">    <span class="comment">// 因为 load_images 中调用 +load 时，会导致其他镜像被 load，</span></span><br><span class="line">    <span class="comment">// 即 load_images 函数会在一个线程上被接连调用多次，如果加上 runtimeLock，就会造成死锁</span></span><br><span class="line">    <span class="keyword">if</span> (found) &#123; <span class="comment">// 确实有类或分类需要 +load</span></span><br><span class="line">        call_load_methods(); <span class="comment">// 就调用 +load</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数分为三部分工作：</p><ol><li>hasLoadMethods 判断是否有load函数</li><li>load_images_nolock 将load的信息添加到全局数据结构中</li><li>call_load_methods 调用load方法</li></ol><h3 id="判断是否含有load方法"><a href="#判断是否含有load方法" class="headerlink" title="判断是否含有load方法"></a>判断是否含有load方法</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool hasLoadMethods(const headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t <span class="keyword">count</span>;</span><br><span class="line">    <span class="comment">// 扫描类列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyClassList(mhdr, &amp;<span class="keyword">count</span>)  &amp;&amp;  <span class="keyword">count</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 扫描分类列表</span></span><br><span class="line">    <span class="keyword">if</span> (_getObjc2NonlazyCategoryList(mhdr, &amp;<span class="keyword">count</span>)  &amp;&amp;  <span class="keyword">count</span> &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果累有load方法，就会被放入<strong>objc_nlclslist section，如果分类有load方法，分类就会被放入</strong>objc_nlcatlist section，所以判断是否有这两个section，就判断出了是否有load方法</p><h3 id="存储含有load方法的类、分类到全局数据中"><a href="#存储含有load方法的类、分类到全局数据中" class="headerlink" title="存储含有load方法的类、分类到全局数据中"></a>存储含有load方法的类、分类到全局数据中</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> </span><br><span class="line">load_images_nolock(<span class="keyword">enum</span> dyld_image_states state,<span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">                   <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">bool</span> found = NO;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    i = infoCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从后往前遍历 infoList 中所有镜像，如果镜像中有 +load 方法（其实只查找了镜像中是否有类或分类）</span></span><br><span class="line">    <span class="comment">// 就对镜像调用 prepare_load_methods，</span></span><br><span class="line">    <span class="comment">// 并且记录下有 +load 方法，只要有一个镜像有 +load ，就返回 YES</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType*)infoList[i].imageLoadAddress;</span><br><span class="line">        <span class="keyword">if</span> (!hasLoadMethods(mhdr)) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为 +load 做一些准备工作</span></span><br><span class="line">        <span class="comment">// 将需要 +load 的类添加到 loadable_classes 列表，</span></span><br><span class="line">        <span class="comment">// 将需要 +load 的分类添加到 loadable_categories 列表</span></span><br><span class="line">        prepare_load_methods(mhdr);</span><br><span class="line">        found = YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用prepare_load_methods 保存信息。</p><figure class="highlight plain"><figcaption><span>prepare_load_methods(const headerType *mhdr)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    size_t count, i;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting(); // runtimeLock 需要事先加好写锁（是在 load_images() 中加的锁）</span><br><span class="line"></span><br><span class="line">    // 获得镜像中所有 objective-2.0 且是非惰性的 类的 列表</span><br><span class="line">    classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 遍历类列表，先取得重映射的类，然后调用 schedule_class_load 函数将其添加到 loadable_classes 列表中</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取得分类列表</span><br><span class="line">    category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">    </span><br><span class="line">    // 遍历分类列表</span><br><span class="line">    for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">        category_t *cat = categorylist[i];</span><br><span class="line">        Class cls = remapClass(cat-&gt;cls); // 取得 分类所属的类 所对应的 重映射类</span><br><span class="line">        if (!cls) continue;  // category for ignored weak-linked class</span><br><span class="line">                             // cls == nil，即 cat-&gt;cls 是 ignored weak-linked 类，就跳过</span><br><span class="line">        realizeClass(cls);  // 将 cls 类 realize 了，里面当然也会一并 realize 了 cls 的祖宗类和元类</span><br><span class="line">        assert(cls-&gt;ISA()-&gt;isRealized()); // 确认 realizeClass 是否已经将 cls 的元类也一并 realize 了，</span><br><span class="line">                                          // 见 realizeClass()</span><br><span class="line">        add_category_to_loadable_list(cat); // 将分类 cat 添加到 loadable_categories 列表中</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数完成的功能有两个：</p><ol><li>调用schedule_class_load 将含有 +load 的类添加到 loadable_classes 列表；</li><li>调用add_category_to_loadable_list 将含有 +load 的分类添加到 loadable_categories 列表</li></ol><h4 id="保存含有load方法的类到loadable-classes"><a href="#保存含有load方法的类到loadable-classes" class="headerlink" title="保存含有load方法的类到loadable_classes"></a>保存含有load方法的类到loadable_classes</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保证 loadable_classes 列表中，父类在前，子类在后，父类的 +load 先被调用</span></span><br><span class="line"><span class="keyword">static</span> void schedule_class_load(<span class="class"><span class="keyword">Class</span> <span class="title">cls</span>)</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span>; <span class="comment">// cls 为 nil，这会出现在根类的时候，结束递归</span></span><br><span class="line">    </span><br><span class="line">    assert(cls-&gt;isRealized());  <span class="comment">// cls 必须已经是 realize 的，即 realize 在 load 之前，</span></span><br><span class="line">                                <span class="comment">// realize 是在 _read_images() 中做的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>; <span class="comment">// 如果该类已经被 load 过了，就直接返回，结束递归</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">    schedule_class_load(cls-&gt;superclass); <span class="comment">// 递归，确保在 loadable_classes 列表中父类排在前面</span></span><br><span class="line"></span><br><span class="line">    add_class_to_loadable_list(cls); <span class="comment">// 将 cls 类添加到 loadable_classes 列表中</span></span><br><span class="line">                                     <span class="comment">// 其中会检查 cls 类是否确实有 +load 方法，只有拥有 +load 方法，才会将其添加到 loadable_classes 列表</span></span><br><span class="line">    </span><br><span class="line">    cls-&gt;setInfo(RW_LOADED); <span class="comment">// 将 cls 类设置为已经 load</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>schedule_class_load  将含有 +load 的类添加到 loadable_classes 列表，需要注意的是：，父类在前，子类在后，父类的 +load 先被调用。内部调用add_class_to_loadable_list 添加到loadable_classes列表中。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">void add_class_to_loadable_list(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    IMP method;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked(); <span class="comment">// loadMethodLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    method = <span class="keyword">cls</span>-&gt;getLoadMethod(); <span class="comment">// 取得 cls 类的 +load 方法的 imp</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">                        <span class="comment">// 如果 cls 类压根儿就没有 +load 方法，那也没有将其添加到 loadable_classes 列表的必要</span></span><br><span class="line">                        <span class="comment">// 直接返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (PrintLoading) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"LOAD: class '%s' scheduled for +load"</span>, </span><br><span class="line">                     <span class="keyword">cls</span>-&gt;nameForLogging());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 loadable_classes 列表已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">        <span class="comment">// 重新计算一下新的大小</span></span><br><span class="line">        loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">        <span class="comment">// 重新开辟新的内存空间，并将原来的数据拷贝过去</span></span><br><span class="line">        loadable_classes = (<span class="keyword">struct</span> loadable_class *)</span><br><span class="line">            realloc(loadable_classes,</span><br><span class="line">                              loadable_classes_allocated *</span><br><span class="line">                              sizeof(<span class="keyword">struct</span> loadable_class));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// cls 插入到列表末尾</span></span><br><span class="line">    loadable_classes[loadable_classes_used].<span class="keyword">cls</span> = <span class="keyword">cls</span>;</span><br><span class="line">    loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">    </span><br><span class="line">    loadable_classes_used++; <span class="comment">// 元素数量 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用getLoadMethod 获取cls 的load方法的函数指针。然后将cls、method 放入到loadable_classes中。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">IMP </span><br><span class="line">objc_class::getLoadMethod()</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// runtimeLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    const method_list_t *mlist;</span><br><span class="line"></span><br><span class="line">    assert(isRealized()); <span class="comment">// 该类必须是 realized 过的</span></span><br><span class="line">    <span class="function"><span class="title">assert</span>(ISA()-&gt;</span>isRealized()); <span class="comment">// 元类也必须是 realized 过的</span></span><br><span class="line">    assert(!isMetaClass()); <span class="comment">// 该类不能是元类</span></span><br><span class="line">    <span class="function"><span class="title">assert</span>(ISA()-&gt;</span>isMetaClass()); <span class="comment">// 该类的 isa 必须是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">mlist</span> = ISA()-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span><span class="function"><span class="title">ro</span>-&gt;</span>baseMethods(); <span class="comment">// +load 是类方法，所以存在了元类中，取出元类的 ro 中的方法列表</span></span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (const auto&amp; meth : *mlist) &#123; <span class="comment">// 遍历元类的方法列表，</span></span><br><span class="line">            const char *<span class="keyword">name</span> = sel_cname(meth.<span class="keyword">name</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcmp(<span class="keyword">name</span>, <span class="string">"load"</span>)) &#123; <span class="comment">// 寻找名字叫 "load" 的方法</span></span><br><span class="line">                return meth.imp; <span class="comment">// 如果找到了，就返回该方法的 imp</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return <span class="literal">nil</span>; <span class="comment">// 找不到就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getLoadMethod 函数循环比较元类中ro中的baseMethods，如果方法名称一样，就返回对应的IMP。</p><h4 id="保存含有load方法的分类到loadable-categories"><a href="#保存含有load方法的分类到loadable-categories" class="headerlink" title="保存含有load方法的分类到loadable_categories"></a>保存含有load方法的分类到loadable_categories</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分类 cat 添加到 loadable_categories 列表中</span></span><br><span class="line">void add_category_to_loadable_list(Category cat)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    IMP method;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    loadMethodLock.assertLocked();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    method = _category_getLoadMethod(cat);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // Don't bother if cat has no +load method</span></span><br><span class="line"><span class="comment">    if (!method) return;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (PrintLoading) &#123;</span></span><br><span class="line"><span class="comment">        _objc_inform("LOAD: category '%s(%s)' scheduled for +load", </span></span><br><span class="line"><span class="comment">                     _category_getClassName(cat), _category_getName(cat));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (loadable_categories_used == loadable_categories_allocated) <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        loadable_categories_allocated = loadable_categories_allocated*2 + 16;</span></span><br><span class="line"><span class="comment">        loadable_categories = (struct loadable_category *)</span></span><br><span class="line"><span class="comment">            realloc(loadable_categories,</span></span><br><span class="line"><span class="comment">                              loadable_categories_allocated *</span></span><br><span class="line"><span class="comment">                              sizeof(struct loadable_category));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    loadable_categories[loadable_categories_used].cat = cat;</span><br><span class="line">    loadable_categories[loadable_categories_used].method = <span class="function"><span class="keyword">method</span>;</span></span><br><span class="line">    loadable_categories_used++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用_category_getLoadMethod 获取分类中load方法的IMP，然后将cat、method放入到loadable_categories</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得分类的 +load 方法对应的 imp，如果没有 +load 方法，就返回 nil</span></span><br><span class="line">IMP </span><br><span class="line">_category_getLoadMethod(Category cat)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// runtimeLock 需要事先加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    mlist = cat-&gt;classMethods; <span class="comment">// 取得分类的类方法列表，因为 +load 也是类方法，位于类方法列表中</span></span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123; <span class="comment">// 遍历类方法列表，查找名为 "load" 的方法</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_cname(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">"load"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp; <span class="comment">// 如果找到了，就将方法的 imp 返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil; <span class="comment">// 没有 +load 方法，就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call_load_methods 获取分类classMethods中方法列表，循环比较方法名称，如果一致，返回方法的IMP。</p><h3 id="调用load方法"><a href="#调用load方法" class="headerlink" title="调用load方法"></a>调用load方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数中调用类的 +load 方法</span></span><br><span class="line"><span class="keyword">void</span> call_load_methods(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用类的load方法"><a href="#调用类的load方法" class="headerlink" title="调用类的load方法"></a>调用类的load方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">call_class_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_class</span> *<span class="title">classes</span> = <span class="title">loadable_classes</span>;</span> <span class="comment">// 先将列表暂存起来，即另一个指针指向列表的内存</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_classes_used; <span class="comment">// 暂存列表中类的数量</span></span><br><span class="line">    loadable_classes = nil; <span class="comment">// loadable_classes 指向指向 nil，与原来的列表脱离关系</span></span><br><span class="line">    loadable_classes_allocated = <span class="number">0</span>; <span class="comment">// 容量清零</span></span><br><span class="line">    loadable_classes_used = <span class="number">0</span>; <span class="comment">// 类的个数清零</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123; <span class="comment">// 遍历暂存的列表</span></span><br><span class="line">        Class cls = classes[i].cls;</span><br><span class="line">        <span class="comment">// 取得该类的 +load 方法的 imp</span></span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)classes[i].method;</span><br><span class="line">        <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// 如果 imp 不存在，没得玩，跳过</span></span><br><span class="line">                             <span class="comment">// 一般情况下，不会这么糟糕，因为 add_class_to_loadable_list() 中对</span></span><br><span class="line">                             <span class="comment">// 没有 +load imp 的类进行了排除</span></span><br><span class="line">        (*load_method)(cls, SEL_load); <span class="comment">// 直接调用 +load 的 imp 函数，跳过 objc_msgSend 速度更快</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Destroy the detached list.</span></span><br><span class="line">    <span class="keyword">if</span> (classes) <span class="built_in">free</span>(classes); <span class="comment">// 将暂存的列表销毁释放</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>load方法的调用时直接执行函数指针，所以不存在runtime中的消息转发，对子类发送load消息，不会执行父类中的load方法。这样保证每个类的load方法都只调用一次。</p><h4 id="调用分类的load方法"><a href="#调用分类的load方法" class="headerlink" title="调用分类的load方法"></a>调用分类的load方法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用分类中的 +load 方法</span></span><br><span class="line"><span class="comment">// 调用者：call_load_methods()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">call_category_loads</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, shift;</span><br><span class="line">    <span class="keyword">bool</span> new_categories_added = NO;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Detach current loadable list.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">loadable_category</span> *<span class="title">cats</span> = <span class="title">loadable_categories</span>;</span></span><br><span class="line">    <span class="keyword">int</span> used = loadable_categories_used;</span><br><span class="line">    <span class="keyword">int</span> allocated = loadable_categories_allocated;</span><br><span class="line">    loadable_categories = nil;</span><br><span class="line">    loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    loadable_categories_used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call all +loads for the detached list.</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        Category cat = cats[i].cat;</span><br><span class="line">        <span class="keyword">load_method_t</span> load_method = (<span class="keyword">load_method_t</span>)cats[i].method;</span><br><span class="line">        Class cls;</span><br><span class="line">        <span class="keyword">if</span> (!cat) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cls = _category_getClass(cat);</span><br><span class="line">        <span class="keyword">if</span> (cls  &amp;&amp;  cls-&gt;isLoadable()) &#123;</span><br><span class="line">            (*load_method)(cls, SEL_load);</span><br><span class="line">            cats[i].cat = nil;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact detached list (order-preserving)</span></span><br><span class="line">    shift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats[i].cat) &#123;</span><br><span class="line">            cats[i-shift] = cats[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    used -= shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy any new +load candidates from the new list to the detached list.</span></span><br><span class="line">    new_categories_added = (loadable_categories_used &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loadable_categories_used; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used == allocated) &#123;</span><br><span class="line">            allocated = allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">            cats = (struct loadable_category *)</span><br><span class="line">                <span class="built_in">realloc</span>(cats, allocated *</span><br><span class="line">                                  <span class="keyword">sizeof</span>(struct loadable_category));</span><br><span class="line">        &#125;</span><br><span class="line">        cats[used++] = loadable_categories[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destroy the new list.</span></span><br><span class="line">    <span class="keyword">if</span> (loadable_categories) <span class="built_in">free</span>(loadable_categories);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reattach the (now augmented) detached list. </span></span><br><span class="line">    <span class="comment">// But if there's nothing left to load, destroy the list.</span></span><br><span class="line">    <span class="keyword">if</span> (used) &#123;</span><br><span class="line">        loadable_categories = cats;</span><br><span class="line">        loadable_categories_used = used;</span><br><span class="line">        loadable_categories_allocated = allocated;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cats) <span class="built_in">free</span>(cats);</span><br><span class="line">        loadable_categories = nil;</span><br><span class="line">        loadable_categories_used = <span class="number">0</span>;</span><br><span class="line">        loadable_categories_allocated = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> new_categories_added;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先将全局中的信息拷贝处理啊，调用分类的load方法。 调用完成之后就将cats[i]中的cat 置位 nil，  对于那些不符合调用load方法的分类不做处理， 这样就会剩下一部分分类。 下面就是整合剩下的分类和新添加到loadable_categories的分类为新的结构。</p><p>上面说明的了分类中的load方法也会调用。并且分类中的load方法不会覆盖本类中的load方法。</p><h2 id="总体的流程图"><a href="#总体的流程图" class="headerlink" title="总体的流程图"></a>总体的流程图</h2><p><img src="/wiki/IOS/Runtime/objc/10_load_images/loadImage_overall.png" alt="load_images 总体流程图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.jianshu.com/p/9e0fc8295c4b" rel="external nofollow noopener noreferrer" target="_blank">Xcode 10 下如何调试objc4-723</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文分析load_images 函数,该函数完成+load方法的调用。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="load_images" scheme="http://yoursite.com/tags/load-images/"/>
    
  </entry>
  
  <entry>
    <title>9. _read_images 从二进制文件中读取类信息</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/9__read_images/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/9__read_images/</id>
    <published>2018-11-27T02:38:11.000Z</published>
    <updated>2018-11-30T06:52:54.328Z</updated>
    
    <content type="html"><![CDATA[<p>_read_images从镜像文件中读取所有类信息、方法信息、分类信息。这篇文章就介绍具体读取了什么信息。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Mach-O 运行的时候，通过dylb加载到内存，须进一步提取出详细的信息，进而使用Mach-O中的类、方法。dylb加载完Mach-O文件后，通知runtime，调用_read_images ，_read_images就是将Mach-O文件中的DATA segment中的数据读入到对应的数据结构中，方便使用。<br><img src="/wiki/IOS/Runtime/objc/9__read_images/read_image_overal.png" alt="_read_images 的意义"></p><p>读取的所有section：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/DATA Segment.png" alt="_read_images 读取的数据示意图"></p><h2 id="read-images函数-代码分析"><a href="#read-images函数-代码分析" class="headerlink" title="_read_images函数 代码分析"></a>_read_images函数 代码分析</h2><h3 id="读取Mach-O指定Section的基础设施"><a href="#读取Mach-O指定Section的基础设施" class="headerlink" title="读取Mach-O指定Section的基础设施"></a>读取Mach-O指定Section的基础设施</h3><p>首先登场的是GETSECT，位于objc-file.mm文件中，GETSECT宏可以生成不同的函数。函数名为name，这些函数完成读取Mach-O文件指定Section的内容。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define GETSECT(name, type, sectname)                                   \</span></span><br><span class="line">type *name(const headerType *mhdr, size_t *outCount) &#123;              \</span><br><span class="line">    return getDataSection&lt;type&gt;(mhdr, sectname, <span class="literal">nil</span>, outCount);     \</span><br><span class="line">&#125;                                                                   \</span><br><span class="line">type *name(const header_info *hi, size_t *outCount) &#123;               \</span><br><span class="line">    return getDataSection&lt;type&gt;(hi-&gt;mhdr, sectname, <span class="literal">nil</span>, outCount); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部会调用getDataSection 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T* <span class="title">getDataSection</span><span class="params">(<span class="keyword">const</span> headerType *mhdr, <span class="keyword">const</span> <span class="keyword">char</span> *sectname, </span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">size_t</span> *outBytes, <span class="keyword">size_t</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> byteCount = <span class="number">0</span>;</span><br><span class="line">    T* data = (T*)getsectiondata(mhdr, <span class="string">"__DATA"</span>, sectname, &amp;byteCount);</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_CONST"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        data = (T*)getsectiondata(mhdr, <span class="string">"__DATA_DIRTY"</span>, sectname, &amp;byteCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outBytes) *outBytes = byteCount;</span><br><span class="line">    <span class="keyword">if</span> (outCount) *outCount = byteCount / <span class="keyword">sizeof</span>(T);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getDataSection 函数会读取<strong>DATA、</strong>DATA_CONST、__DATA_DIRTY Segement中名为sectname的section。</p><p>下面是使用GETSECT定义的函数列表。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//      function name                 content type     section name</span><br><span class="line">GETSECT(<span class="name">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">"__objc_selrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2MessageRefs</span>,         message_ref_t,   <span class="string">"__objc_msgrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassRefs</span>,           Class,           <span class="string">"__objc_classrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2SuperRefs</span>,           Class,           <span class="string">"__objc_superrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2NonlazyClassList</span>,    classref_t,      <span class="string">"__objc_nlclslist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2CategoryList</span>,        category_t *,    "__objc_catlist");</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="string">"__objc_nlcatlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ProtocolList</span>,        protocol_t *,    "__objc_protolist");</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="string">"__objc_protorefs"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>上面10行代码定了了10个函数，分别读取10种section的内容。例如_getObjc2ClassList 函数，会读取 __objc_classlist section，也就是读取镜像中的所有类的列表。 这些函数下面都会用到，是这篇文章的基础。</p><h3 id="首次执行任务—申请存放类的映射表"><a href="#首次执行任务—申请存放类的映射表" class="headerlink" title="首次执行任务—申请存放类的映射表"></a>首次执行任务—申请存放类的映射表</h3><p>_read_images 定义如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void _read_images(<span class="name">header_info</span> **hList, uint32_t hCount)</span><br></pre></td></tr></table></figure><p>入参是map_images_nolock函数处理过的、非重复的、镜像列表和个数。下面只介绍重要的代码段，有部分代码会被忽略，全部代码请看OBJC4源码库。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!doneOnce) </span><br><span class="line"> &#123; <span class="comment">// 这个块里的代码只会执行一次</span></span><br><span class="line">        doneOnce = YES;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// Count classes. Size various table based on the total.</span></span><br><span class="line">        <span class="comment">// 计算类的总数</span></span><br><span class="line">        int <span class="keyword">total</span> = 0; <span class="comment">// 总数</span></span><br><span class="line">        int unoptimizedTotal = 0; <span class="comment">// 未优化的类的总数，不包括处于 shared cache 中的类</span></span><br><span class="line">        <span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">            <span class="keyword">if</span> (_getObjc2ClassList(hi, &amp;<span class="keyword">count</span>)) &#123; <span class="comment">// 获得 header 中所有 objective-2.0 类的列表</span></span><br><span class="line">                <span class="keyword">total</span> += (int)<span class="keyword">count</span>; <span class="comment">// 总数累加</span></span><br><span class="line">                <span class="keyword">if</span> (!hi-&gt;inSharedCache) &#123; <span class="comment">// 如果 header 不在 shared cache 的话，未优化的类的总数累加</span></span><br><span class="line">                    unoptimizedTotal += <span class="keyword">count</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// gdb_objc_realized_classes 中装的是不在 shared cache 中的类，所以如果经过了预优化，</span></span><br><span class="line">        <span class="comment">// 那么就只考虑未优化的那些类，即 unoptimizedTotal，否则考虑全部类 total</span></span><br><span class="line">        int namedClassesSize = </span><br><span class="line">            (isPreoptimized() ? unoptimizedTotal : <span class="keyword">total</span>) * 4 / 3;</span><br><span class="line">        gdb_objc_realized_classes =</span><br><span class="line">            NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// realizedClasses and realizedMetaclasses - less than the full total</span></span><br><span class="line">        realized_class_hash = </span><br><span class="line">            NXCreateHashTable(NXPtrPrototype, <span class="keyword">total</span> / 8, nil);</span><br><span class="line">        realized_metaclass_hash = </span><br><span class="line">            NXCreateHashTable(NXPtrPrototype, <span class="keyword">total</span> / 8, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define EACH_HEADER \                 </span></span><br><span class="line">    hIndex = <span class="number">0</span>;         <span class="string">\</span></span><br><span class="line">    crashlog_header_name(nil) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); <span class="string">\</span></span><br><span class="line">    hIndex++</span><br></pre></td></tr></table></figure><p>上面代码完成的工作：</p><ol><li>这段代码只有第一次进入_read_images才执行，只能执行一次；</li><li>通过_getObjc2ClassList函数获取__objc_classlist section中的所有类的总数 total、不在shared cache中的类的个数unoptimizedTotal；</li><li>创建gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个hash表， 容量由total、unoptimizedTotal 决定。</li></ol><p>gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个表的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/三种全局数据结构.png" alt="存储类的数据结构"></p><h3 id="读取-objc-classlist（所有类列表，存储到gdb-objc-realized-classes-map中"><a href="#读取-objc-classlist（所有类列表，存储到gdb-objc-realized-classes-map中" class="headerlink" title="读取__objc_classlist（所有类列表，存储到gdb_objc_realized_classes map中"></a>读取__objc_classlist（所有类列表，存储到gdb_objc_realized_classes map中</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///代码位于objc-runtime-new文件中</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    bool headerIsBundle = hi-&gt;isBundle(); <span class="comment">// header 是否是 bundle 类型</span></span><br><span class="line">    bool headerIsPreoptimized = hi-&gt;isPreoptimized(); <span class="comment">// header 是否经过预优化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 header 中的所有的 objective-c 2.0 的类</span></span><br><span class="line">    classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历类列表</span></span><br><span class="line">        Class cls = (Class)classlist[i];</span><br><span class="line">        <span class="comment">// 读取该类，会做一些处理，取得新类(逻辑很复杂，完全懵圈)</span></span><br><span class="line">        Class <span class="keyword">new</span><span class="type">Cls</span> = readClass(cls, headerIsBundle, headerIsPreoptimized);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果获得的是一个非空的新类</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">Cls</span> != cls  &amp;&amp;  <span class="keyword">new</span><span class="type">Cls</span>) &#123;</span><br><span class="line">            <span class="comment">// Class was moved but not deleted. Currently this occurs </span></span><br><span class="line">            <span class="comment">// only when the new class resolved a future class.</span></span><br><span class="line">            <span class="comment">// Non-lazily realize the class below.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 类被移动了，但是没有被删除，</span></span><br><span class="line">            <span class="comment">// 这只会发生在新类 resolve 了一个 future 类的情况下</span></span><br><span class="line">            <span class="comment">// 下面以非惰性的方法 realize 了 newCls</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为 resolvedFutureClasses 数组重新开辟一块更大的空间，并将原来的数据拷贝进来</span></span><br><span class="line">            resolvedFutureClasses = (Class *)</span><br><span class="line">                realloc(resolvedFutureClasses, </span><br><span class="line">                                  (resolvedFutureClassCount+<span class="number">1</span>) </span><br><span class="line">                                  * sizeof(Class));</span><br><span class="line">            <span class="comment">// 将 newCls 添加到数组的末尾，resolvedFutureClassCount 加 1</span></span><br><span class="line">            resolvedFutureClasses[resolvedFutureClassCount++] = <span class="keyword">new</span><span class="type">Cls</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GETSECT(_getObjc2ClassList,           classref_t,      <span class="string">"__objc_classlist"</span>);</span><br></pre></td></tr></table></figure><p>这段代码循环所有镜像，通过_getObjc2ClassList函数，读取每个镜像中的__objc_classlist  section中的所有类，然后对每个类调用readClass函数。readClass如果返回的类是future类，存储到resolvedFutureClasses数组中，后面会实现这些future类。</p><h4 id="objc-classlist-理解"><a href="#objc-classlist-理解" class="headerlink" title="__objc_classlist 理解"></a>__objc_classlist 理解</h4><p>首先创建一个命令行程序，添加如下代码：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">LJPersion </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@implementation</span> LJPersion</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (NSString*) classMethod</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span> (NSString *) <span class="selector-tag">instanceMethod</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>编译完成后，使用mashOView 查看__objc_classlist内容：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_section.png" alt="__objc_classlist section "></p><p>__objc_classlist 就是这个镜像中所有的类的列表，我新建的程序只有一个类LJPersion，根据图所示，LJPersion 应该存储在0x0000000100001150中， 然后用hopper 查看0x0000000100001150处的内容，验证存储的内容是否是LJPersion类。</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_LJPersion.png" alt="LJPersion 反汇编结果"></p><p>可以确定0x0000000100001150地址存储的内容就是LJPersion类，同时可以看出类的数据中保存着instanceMethod方法，元类中保存着classMethod方法。</p><h4 id="readClass代码分析"><a href="#readClass代码分析" class="headerlink" title="readClass代码分析"></a>readClass代码分析</h4><p>通过<code>classref_t *classlist = _getObjc2ClassList(hi, &amp;count);</code>将 hi表示的镜像中的所有类读取到classlist中，然后对classlist中的每个类调用readClass函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 读取一个编译器写的 类 或 元类，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 返回新类的指针，有可能是：</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - cls</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - nil (cls 有一个 missing weak-linked 的父类)</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    - 同名的 future 类，该 future 类填充了 cls 类的信息</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 调用者：<span class="emphasis">_read_</span>images() / objc_readClassPair()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line">Class readClass(Class cls,</span><br><span class="line">                <span class="built_in">bool</span> headerIsBundle<span class="comment">/*是否是 bundle*/</span>,</span><br><span class="line">                <span class="built_in">bool</span> headerIsPreoptimized<span class="comment">/*是否被预优化过，即是否来自 shared cache*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> char *mangledName = cls-&gt;mangledName(); <span class="comment">// 取得 cls 的重整后的名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (missingWeakSuperclass(cls)) &#123; <span class="comment">// 查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing</span></span><br><span class="line">        <span class="comment">// 祖宗类里有 missing weak-linked 的</span></span><br><span class="line">        <span class="comment">// 则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -&gt; nil</span></span><br><span class="line">        </span><br><span class="line">        addRemappedClass(cls, nil); <span class="comment">// 将其添加到重映射表里，映射为nil</span></span><br><span class="line">        cls-&gt;superclass = nil; <span class="comment">// 父类指针指向 nil</span></span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class replacing = nil; <span class="comment">// 记录被代替的类</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试将 mangledName 对应的 future 的类从 future_named_class_map 中弹出</span></span><br><span class="line">    <span class="comment">// 如果返回的 newCls 有值，则 newcls 类是以前开辟的一个同名的 future 类，</span></span><br><span class="line">    <span class="comment">// 这个 future 类现在得到了兑现，因为有一个同名的新类 cls 进来了，</span></span><br><span class="line">    <span class="comment">// future 类里的信息会由 cls 中的信息填充（原来 future 类只开辟了内存，里面其实是啥都没的）</span></span><br><span class="line">    <span class="comment">// 并将 cls 代替</span></span><br><span class="line">    <span class="keyword">if</span> (Class newCls = popFutureNamedClass(mangledName)) &#123;</span><br><span class="line">        <span class="comment">// This name was previously allocated as a future class.</span></span><br><span class="line">        <span class="comment">// Copy objc_class to future class's struct.</span></span><br><span class="line">        <span class="comment">// Preserve future's rw data block.</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 但是 newcls 不能是 swift 类，因为太大了？啥意思？swift类能有多大</span></span><br><span class="line">        <span class="keyword">if</span> (newCls-&gt;isSwift()) &#123;</span><br><span class="line">            _objc_fatal(<span class="string">"Can't complete future class request for '%s' "</span></span><br><span class="line">                        <span class="string">"because the real class is too big."</span>, </span><br><span class="line">                        cls-&gt;nameForLogging());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        class_rw_t *rw = newCls-&gt;data();     <span class="comment">// 取得 newCls 中的 rw，rw 中除了 ro 外的其他数据是需要保留的</span></span><br><span class="line">        <span class="keyword">const</span> class_ro_t *old_ro = rw-&gt;ro;   <span class="comment">// 旧的 ro</span></span><br><span class="line">        memcpy(newCls, cls, sizeof(objc_class)); <span class="comment">// 将 cls 中的数据完整得拷贝到 newCls 中</span></span><br><span class="line">        rw-&gt;ro = (class_ro_t *)newCls-&gt;data();   <span class="comment">// rw 中使用新的 ro</span></span><br><span class="line">        newCls-&gt;setData(rw);        <span class="comment">// 将 rw 赋给 newCls，那么 newCls 中使用的还是原来的 rw，只是其中的 ro 变了</span></span><br><span class="line">        free((<span class="keyword">void</span> *)old_ro-&gt;name); <span class="comment">// 旧 ro 中的 name 是在堆上分配的，所以需要释放</span></span><br><span class="line">        free((<span class="keyword">void</span> *)old_ro);       <span class="comment">// 将旧 ro 释放</span></span><br><span class="line">        </span><br><span class="line">        addRemappedClass(cls, newCls); <span class="comment">// 将 cls -&gt; newCls 的重映射添加到映射表中</span></span><br><span class="line">        </span><br><span class="line">        replacing = cls; <span class="comment">// 记录下 cls 类被代替</span></span><br><span class="line">        cls = newCls;   <span class="comment">// 新类 newCls 赋给 cls</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (headerIsPreoptimized  &amp;&amp;  !replacing) &#123; <span class="comment">// 预优化过，且没有被代替</span></span><br><span class="line">        <span class="keyword">assert</span>(getClass(mangledName));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 mangledName -&gt; cls 的映射添加到 gdb_objc_realized_classes 表中</span></span><br><span class="line">        <span class="comment">// 如果上 cls 被 newCls 代替了，那么 replacing 就是老的 cls，即在 gdb_objc_realized_classes 中</span></span><br><span class="line">        <span class="comment">// 也会将老的 cls 代替</span></span><br><span class="line">        addNamedClass(cls, mangledName, replacing);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// for future reference: shared cache never contains MH_BUNDLEs</span></span><br><span class="line">    <span class="keyword">if</span> (headerIsBundle) &#123;</span><br><span class="line">        cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">        cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要的完成的任务用下图表示：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/readClass_liuchengtu.png" alt="LJPersion 反汇编结果"></p><p>其中missingWeakSuperclass 确定cls的祖宗类是否缺失：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断 cls 类的祖宗类中是否有类是 weak-linked 的，或者说已经 missing(丢失)</span></span><br><span class="line"><span class="comment">// 这是一个递归函数</span></span><br><span class="line">static <span class="keyword">bool</span> </span><br><span class="line">missingWeakSuperclass(Class <span class="keyword">cls</span>)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!<span class="keyword">cls</span>-&gt;isRealized()); <span class="comment">// cls 不能是已经 realized 的类，因为 realized 的类一定是正常的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">cls</span>-&gt;superclass) &#123; <span class="comment">// 如果没有父类，则看它是否是根类，若是根类，那么就是正常的，否则它的父类就是丢了</span></span><br><span class="line">                            <span class="comment">// 结束递归</span></span><br><span class="line">        <span class="comment">// superclass nil. This is normal for root classes only.</span></span><br><span class="line">        <span class="keyword">return</span> (!(<span class="keyword">cls</span>-&gt;data()-&gt;flags &amp; RO_ROOT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// superclass not nil. Check if a higher superclass is missing.</span></span><br><span class="line">        <span class="comment">// 如果有父类，则递归调用一直向上查找祖宗类，看是否有丢的了</span></span><br><span class="line">        Class supercls = remapClass(<span class="keyword">cls</span>-&gt;superclass); <span class="comment">// 取得重映射的父类，如果父类是 weak-link 的，</span></span><br><span class="line">                                                      <span class="comment">// 则 remapClass 会返回 nil</span></span><br><span class="line">        assert(<span class="keyword">cls</span> != <span class="keyword">cls</span>-&gt;superclass); <span class="comment">// 这两个断言很奇怪，完全想不到什么奇葩情况下这两个断言会不成立</span></span><br><span class="line">        assert(<span class="keyword">cls</span> != supercls);</span><br><span class="line">        <span class="keyword">if</span> (!supercls) <span class="keyword">return</span> YES; <span class="comment">// 如果父类是 weak-link 的，则 supercls 为 nil，返回 YES，结束递归</span></span><br><span class="line">        <span class="keyword">if</span> (supercls-&gt;isRealized()) <span class="keyword">return</span> NO; <span class="comment">// 如果父类已经被 realized，则直接返回 NO，因为 realized 的类一定是正常的</span></span><br><span class="line">                                               <span class="comment">// 结束递归</span></span><br><span class="line">        <span class="keyword">return</span> missingWeakSuperclass(supercls); <span class="comment">// 否则递归寻找祖宗类们</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重映射表中查找key为cls的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 cls 类的 live class（活动的类）指针，这个指针可能指向一个已经被 reallocated 的结构体（#疑问：什么意思？？）</span></span><br><span class="line"><span class="comment">// 若 cls 是 weak linking（弱连接），则 cls 会被忽略，而返回 nil</span></span><br><span class="line"><span class="comment">// 调用者 ：_class_remap() / missingWeakSuperclass() / realizeClass() /</span></span><br><span class="line"><span class="comment">//         remapClass() / remapClassRef()</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">remapClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class c2; <span class="comment">// 这里没有初始化为 nil，有没有可能指向一块垃圾内存？？</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil; <span class="comment">// 如果 cls 是 nil，则直接返回 nil</span></span><br><span class="line"></span><br><span class="line">    NXMapTable *<span class="built_in">map</span> = remappedClasses(NO); <span class="comment">// 取得 remapped_class_map 映射表，若为空，不创建</span></span><br><span class="line">    <span class="comment">// 如果 map 非空，或者 cls 不是一个 key，NX_MAPNOTAKEY(not a key)，即 cls 压根儿不在 remapped_class_map 映射表里</span></span><br><span class="line">    <span class="comment">// 则将 cls 返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">map</span>  ||  NXMapMember(<span class="built_in">map</span>, cls, (<span class="keyword">void</span>**)&amp;c2) == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        <span class="keyword">return</span> cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c2;  <span class="comment">// 1. 如果 map 是空，则返回的 c2 == nil（#疑问：有没有可能是垃圾内存？？），因为 || 的断路特点，后面的代码不会执行</span></span><br><span class="line">                    <span class="comment">// 2. 如果 map 不为空，并且 cls 确实是 remapped_class_map 中的 key，则 c2 就是取得的 value</span></span><br><span class="line">                    <span class="comment">//      但是其中 key 如果是 ignored weak-linked class 的话，c2 就是 nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remapClass 函数功能是： 从remapped_class_map表中取key为cls的内容。 如果表位空，或者表中没有，直接返回cls，否则返回表中内容。</p><p>addRemappedClass 添加成员到重映射表：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加一个 remapped 的类到 remapped_class_map 映射表中</span></span><br><span class="line"><span class="comment">// newcls 是一个已经被 realized 的 future 类，oldcls 是老的 future 类</span></span><br><span class="line"><span class="comment">// 或者 newcls 是 nil，oldcls 是 ignored weak-linked 类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRemappedClass(Class oldcls, Class newcls)</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    <span class="comment">// 将 oldcls 为 key，newcls 为 value 插入到 remapped_class_map 映射表 中，</span></span><br><span class="line">    <span class="comment">// remappedClasses(YES) 中 YES 是指定如果 remapped_class_map 为空的话，就创建一个</span></span><br><span class="line">    old = NXMapInsert(remappedClasses(YES), oldcls, newcls);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// old 不能为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将oldcls：newcls 添加到 重映射remapped_class_map表中。</p><p>popFutureNamedClass 函数定义如下:</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定 name 对应的 future 类从 future_named_class_map 中移除</span></span><br><span class="line"><span class="comment">// 因为 这个类 已经被 realized 过了，它已经不再处于 future 状态</span></span><br><span class="line"><span class="comment">// 返回 name 对应的 future class，如果没有对应的 future class，就返回 nil</span></span><br><span class="line"><span class="comment">// caller : readClass()</span></span><br><span class="line">static Class popFutureNamedClass(const char *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    Class cls = nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap) &#123; <span class="comment">// 如果 future_named_class_map 非空</span></span><br><span class="line">        <span class="comment">// 利用 key name 将 future class 从 future_named_class_map 移除</span></span><br><span class="line">        <span class="comment">// NXMapKeyFreeingRemove 与 NXMapRemove 功能一样，但是会释放 key，因为 key 是在堆中分配的，原因见 NXMapKeyCopyingInsert()</span></span><br><span class="line">        cls = (Class)NXMapKeyFreeingRemove(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap, name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 name 确实有对应的 future class，并且当前 future_named_class_map 已经空了</span></span><br><span class="line">        <span class="comment">// 就将 future_named_class_map 释放</span></span><br><span class="line">        <span class="keyword">if</span> (cls &amp;&amp; NXCountMapTable(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap) == <span class="number">0</span>) &#123;</span><br><span class="line">            NXFreeMapTable(future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap);</span><br><span class="line">            future<span class="number">_n</span>amed<span class="number">_</span><span class="keyword">class</span><span class="number">_m</span>ap = nil; <span class="comment">// 防止野指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从future_named_class_map中弹出指定名称的类。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>addNamedClass</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Adds name =&gt; cls to </span>the<span class="markdown"> named non-meta class map.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Warns about duplicate class names and keeps </span>the<span class="markdown"> old mapping.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: runtimeLock must be held by </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> </span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 添加 name -&gt; cls 对到 named non-meta class map（gdb<span class="emphasis">_objc_</span>realized_classes）中</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 警告有副本，但是会保持老的映射，即会有多份，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 新的映射被存在了 secondary metaclass map(二级元类映射表) 表中，见 addNonMetaClass()，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"> replacing : 被代替的老的 cls (见 readClass()) 如果有旧映射，但是与 replacing 不符合，还是会保留旧映射，</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">             否则新值会将 gdb_objc_realized_classes 中的旧映射覆盖</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> 调用者：objc<span class="emphasis">_duplicateClass() / objc_</span>registerClassPair() / readClass()</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addNamedClass(Class cls, <span class="keyword">const</span> char *name, Class replacing = nil)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    Class old;</span><br><span class="line">    <span class="comment">// 先根据 name 查找是否有对应的旧类，如果有，并且 old 与 replacing 不同</span></span><br><span class="line">    <span class="comment">// 则报警告，但是会保持老的映射，插入新的映射</span></span><br><span class="line">    <span class="keyword">if</span> ((old = getClass(name))  &amp;&amp;  old != replacing) &#123;</span><br><span class="line">        </span><br><span class="line">        inform_duplicate(name, old, cls); <span class="comment">// 给出警告：名字为 name 的类有两份实现，但只有一份会被使用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// getNonMetaClass uses name lookups. Classes not found by name </span></span><br><span class="line">        <span class="comment">// lookup must be in the secondary meta-&gt;nonmeta table.</span></span><br><span class="line">        addNonMetaClass(cls); <span class="comment">// 将 cls 存入 matacls-&gt;cls 的二级映射表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有旧值，或者指定要覆盖旧值（replacing == old），就将新的 name-&gt;cls 对插入 gdb_objc_realized_classes</span></span><br><span class="line">        NXMapInsert(gdb_objc_realized_classes, name, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">assert</span>(!(cls-&gt;data()-&gt;flags &amp; RO_META)); <span class="comment">// cls 不能是元类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类添加到一级或者二级缓存中。</p><p>readClass 做了下面三件事：</p><ol><li>如果class的祖宗类丢失，将类添加到NXMapTable *remapped_class_map表中，key是cls，value是nil。 最后直接返回 nil。</li><li>从future_named_class_map中查找cls是否是future类，如果是，通过cls实现future类，然后将结果添加到remapped_class_map中，key是cls，value是实现完成的future类——newCls。 同时调用addNamedClass函数，将newCls添加到gdb_objc_realized_classes或 nonmeta_class_map表中。</li><li>其他情况，直接调用addNamedClass函数，将类添加到gdb_objc_realized_classes或nonmeta_class_map表中。 返回cls。  一般代码走这一步。</li></ol><p>下面是这段代码使用的几个新表:</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classlist_readImage_data.png" alt="readClass 使用的表汇总 "></p><h4 id="将类读取到gdb-objc-realized-classes的意义"><a href="#将类读取到gdb-objc-realized-classes的意义" class="headerlink" title="将类读取到gdb_objc_realized_classes的意义"></a>将类读取到gdb_objc_realized_classes的意义</h4><p>为了说明读取类到gdb_objc_realized_classes的意义，举个例子，objc_getClass函数就是通过名字获取对应的类：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class objc_getClass(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">look_up_class</span><span class="params">(aClassName, NO, YES)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 look_up_class 函数：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class </span><br><span class="line">look_up_class(<span class="keyword">const</span> <span class="keyword">char</span> *name, </span><br><span class="line">              <span class="keyword">bool</span> includeUnconnected __attribute__((unused)), </span><br><span class="line">              <span class="keyword">bool</span> includeClassHandler __attribute__((unused)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!name) <span class="keyword">return</span> nil; <span class="comment">// 类名不能为 nil，否则不能查</span></span><br><span class="line"></span><br><span class="line">    Class result;</span><br><span class="line">    <span class="keyword">bool</span> unrealized;</span><br><span class="line">    &#123; <span class="comment">// 加函数块是为了能实现自动释放 runtimeLock 锁，下面也一样</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">rwlock_reader_t <span class="title">lock</span>(<span class="params">runtimeLock</span>)</span>; <span class="comment">// 加读锁</span></span><br><span class="line">        result = getClass(name); <span class="comment">// 利用 getClass 函数查找类</span></span><br><span class="line">        unrealized = result  &amp;&amp;  !result-&gt;isRealized(); <span class="comment">// 如果找到了类，且类没有被 realize，就标记为 unrealized</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unrealized) &#123; <span class="comment">// 类存在，且没有被 realize</span></span><br><span class="line">        <span class="function">rwlock_writer_t <span class="title">lock</span>(<span class="params">runtimeLock</span>)</span>; <span class="comment">// 加写锁</span></span><br><span class="line">        realizeClass(result); <span class="comment">// 将类 realize 了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用 getClass函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 name 查找类，实际上调用的还是 getClass_impl，但是需要对 swift 的类做一些处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// 必须事先被加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try name as-is</span></span><br><span class="line">    Class result = getClass_impl(name); <span class="comment">// 先直接用 name 查找</span></span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 找到直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到，就处理成 swift 类的 mangled name 试试</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Try Swift-mangled equivalent of the given name.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">char</span> *swName = copySwiftV1MangledName(name)) &#123; <span class="comment">// 尝试转成 swift mangled name，函数里判断 name 是否符合</span></span><br><span class="line">                                                       <span class="comment">// swift unmangled name(重整前的名字) 的格式，如果符合就返回 mangled name，</span></span><br><span class="line">                                                       <span class="comment">// 否则返回 nil</span></span><br><span class="line">        result = getClass_impl(swName); <span class="comment">// 用 mangled name 再去找</span></span><br><span class="line">        <span class="built_in">free</span>(swName); <span class="comment">// 将 swName 释放，原因见 copySwiftV1MangledName()</span></span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 不用再判断 result 是否有值，直接将它返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nil; <span class="comment">// 如果连 swift 类都不是，就返回 nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用getClass_impl 函数</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据名字查找类，这个类可能没有被 realize 过</span></span><br><span class="line"><span class="comment">// 该函数被 getClass() 函数调用</span></span><br><span class="line"><span class="keyword">static</span> Class getClass_impl(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked(); <span class="comment">// 必须事先被加锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocated in _read_images </span></span><br><span class="line">    <span class="keyword">assert</span>(gdb_objc_realized_classes); <span class="comment">// gdb_objc_realized_classes 是在 _read_images() 函数中被初始化的(分配内存)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try runtime-allocated table</span></span><br><span class="line">    <span class="comment">// 从 gdb_objc_realized_classes 根据 key 即 name 查找类</span></span><br><span class="line">    Class result = (Class)NXMapGet(gdb_objc_realized_classes, name);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        <span class="keyword">return</span> result; <span class="comment">// 找到了，就将其返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try table from dyld shared cache</span></span><br><span class="line">    <span class="comment">// 如果在 gdb_objc_realized_classes 中找不到，就去预优化的类中找找看（跟 dyld shared cache 有关）</span></span><br><span class="line">    <span class="function"><span class="keyword">return</span> <span class="title">getPreoptimizedClass</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面就是使用了gdb_objc_realized_classes。</p><h3 id="读取-getObjc2ClassRefs、-getObjc2SuperRefs（使用的类、父类），修正重映射类表"><a href="#读取-getObjc2ClassRefs、-getObjc2SuperRefs（使用的类、父类），修正重映射类表" class="headerlink" title="读取_getObjc2ClassRefs、_getObjc2SuperRefs（使用的类、父类），修正重映射类表"></a>读取_getObjc2ClassRefs、_getObjc2SuperRefs（使用的类、父类），修正重映射类表</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up remapped classes</span></span><br><span class="line"><span class="comment">// Class list and nonlazy class list remain unremapped.</span></span><br><span class="line"><span class="comment">// Class refs and super refs are remapped for message dispatching.</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 如果 remapped_class_map 不是空的</span></span><br><span class="line"><span class="keyword">if</span> (!noClassesRemapped()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">        <span class="comment">// 取得 header 中所有的类引用</span></span><br><span class="line">        Class *classrefs = <span class="variable">_getObjc2ClassRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">        <span class="comment">// 遍历这些类引用，fix-up 类引用，从重映射类表中取出新类，如果旧类新类不一致，就将新类赋给这个类引用</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fixme why doesn't test future1 catch the absence of this?</span></span><br><span class="line">        <span class="comment">// 取得镜像中所有类的父类引用</span></span><br><span class="line">        classrefs = <span class="variable">_getObjc2SuperRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">        <span class="comment">// 遍历父类引用，将其 fix-up 了</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">            remapClassRef(&amp;classrefs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过_getObjc2ClassRefs、_getObjc2SuperRefs读取<strong>objc_classrefs、</strong>objc_superrefs， 也就是读取程序中引用的类、父类，将classrefs分别调用remapClassRef，修正重映射表——–remapped_class_map。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>remapClassRef</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Fix up </span>a<span class="markdown"> class ref, in case </span>the<span class="markdown"> class referenced has been reallocated </span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>or is </span>an<span class="markdown"> ignored weak-linked class.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: runtimeLock must be read- or write-locked by </span>the<span class="markdown"> caller</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="comment">// fix-up 一个类引用，万一这个类引用指向的类已经被 reallocated(重新分配？) 或者它是一个 ignored weak-linked 类</span></span><br><span class="line"><span class="comment">// 从重映射类表中用 *clsref 为 key 取出新类，如果 *clsref 不等于新类，则将新类赋给 *clsref</span></span><br><span class="line"><span class="comment">// clsref 是一个二级指针，它指向一个类的指针</span></span><br><span class="line"><span class="comment">// 调用者 ：_read_images()</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> remapClassRef(Class *clsref)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    Class newcls = remapClass(*clsref); <span class="comment">// 用 *clsref 为 key 从重映射类表中取出新类</span></span><br><span class="line">    <span class="keyword">if</span> (*clsref != newcls) &#123; <span class="comment">// 如果 *clsref 不等于新类，则将新类赋给 *clsref</span></span><br><span class="line">        *clsref = newcls;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__objc_classrefs在Mach-O的结构如下。</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_classref.png" alt="__objc_classrefs section "></p><h3 id="读取-objc-selrefs（方法列表）–将读取的方法注册到namedSelectors表中"><a href="#读取-objc-selrefs（方法列表）–将读取的方法注册到namedSelectors表中" class="headerlink" title="读取__objc_selrefs（方法列表）–将读取的方法注册到namedSelectors表中"></a>读取__objc_selrefs（方法列表）–将读取的方法注册到namedSelectors表中</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fix up @selector references fixup @selector 引用</span></span><br><span class="line"><span class="keyword">static</span> size_t UnfixedSelectors; <span class="comment">// 记录 hList 中所有镜像中一共有多少 unfixed 的 selector</span></span><br><span class="line">sel_lock(); <span class="comment">// selLock 上写锁</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    <span class="comment">// 只处理没有预优化的，被预优化过的就跳过</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;isPreoptimized()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">bool</span> isBundle = hi-&gt;isBundle(); <span class="comment">// 是否是 bundle</span></span><br><span class="line">    <span class="comment">// 取得镜像中所有的 selector 引用</span></span><br><span class="line">    SEL *sels = _getObjc2SelectorRefs(hi, &amp;count);</span><br><span class="line">    UnfixedSelectors += count; <span class="comment">// 累加</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历刚才取出的 selector</span></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">char</span> *name = sel_cname(sels[i]); <span class="comment">// 转为char * 字符串</span></span><br><span class="line">        sels[i] = sel_registerNameNoLock(name, isBundle); <span class="comment">// 注册这个 selector 的名字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取Mach-O中的__objc_selrefs section，调用sel_registerNameNoLock方法注册。 </p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 注册 <span class="type">SEL</span> 的名字，不加锁</span><br><span class="line"><span class="type">SEL</span> sel_registerNameNoLock(<span class="keyword">const</span> <span class="built_in">char</span> *name, <span class="built_in">bool</span> copy) &#123;</span><br><span class="line">    <span class="keyword">return</span> __sel_registerName(name, <span class="number">0</span>, copy);  // <span class="type">NO</span> lock, maybe copy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 注册 <span class="type">SEL</span> 的名字，能决定是否加锁和拷贝，拷贝即是否深拷贝 name，见 sel_alloc()</span><br><span class="line">// 调用者：sel_getUid() / sel_registerName() / sel_registerNameNoLock()</span><br><span class="line"><span class="keyword">static</span> <span class="type">SEL</span> __sel_registerName(<span class="keyword">const</span> <span class="built_in">char</span> *name, <span class="built_in">int</span> lock, <span class="built_in">int</span> copy) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">SEL</span> <span class="literal">result</span> = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!namedSelectors) &#123;</span><br><span class="line">        namedSelectors = <span class="type">NXCreateMapTable</span>(<span class="type">NXStrValueMapPrototype</span>, </span><br><span class="line">                                          (unsigned)<span class="type">SelrefCount</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">        // <span class="type">Rescan</span> <span class="keyword">in</span> <span class="keyword">case</span> it was added <span class="keyword">while</span> we dropped the lock</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">SEL</span>)<span class="type">NXMapGet</span>(namedSelectors, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="literal">result</span>) &#123;</span><br><span class="line">        <span class="literal">result</span> = sel_alloc(name, copy);</span><br><span class="line">        // fixme choose a better container (hash <span class="keyword">not</span> map <span class="keyword">for</span> starters)</span><br><span class="line">        <span class="type">NXMapInsert</span>(namedSelectors, sel_getName(<span class="literal">result</span>), <span class="literal">result</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (lock) selLock.unlockWrite();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sel_registerNameNoLock 内部调用了__sel_registerName方法，将(sel Name：SEL) 对插入到namedSelectors表中。</p><p>为啥注册，下面有一段说明</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* @note You must register a method name with the Objective-C runtime<span class="built_in"> system </span><span class="keyword">to</span> obtain the</span><br><span class="line">*  method’s selector before you can <span class="builtin-name">add</span> the method <span class="keyword">to</span> a class definition. <span class="keyword">If</span> the method name</span><br><span class="line">*  has already been registered, this function simply returns the selector.</span><br><span class="line">*</span><br></pre></td></tr></table></figure><p>这里有一个新的表，结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/namedSelectors.png" alt="namedSelectors 表说明"></p><p> 读取的Mach-O 中__objc_selrefs 的内容如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/objc_selref.png" alt="__objc_selrefs 示意图"></p><h4 id="将SEL存储到namedSelectors-Hash表的意义"><a href="#将SEL存储到namedSelectors-Hash表的意义" class="headerlink" title="将SEL存储到namedSelectors Hash表的意义"></a>将SEL存储到namedSelectors Hash表的意义</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Identifies a selector as being valid or invalid.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sel The selector you want to identify.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> YES if selector is valid and has a function implementation, NO otherwise. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@warning</span> On some platforms, an invalid reference (to invalid memory addresses) can cause</span></span><br><span class="line"><span class="comment"> *  a crash. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">BOOL</span> sel_isMapped(SEL sel)</span><br><span class="line">    __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0);</span><br></pre></td></tr></table></figure><p>rumtime 提供了这样一个API，判断SEL 是否被映射，可能其他的系统库会调用。</p><h3 id="读取-objc-msgrefs（OBJC的消息），修正部分SEL的IMP"><a href="#读取-objc-msgrefs（OBJC的消息），修正部分SEL的IMP" class="headerlink" title="读取__objc_msgrefs（OBJC的消息），修正部分SEL的IMP"></a>读取__objc_msgrefs（OBJC的消息），修正部分SEL的IMP</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">       message_ref_t *refs = <span class="variable">_getObjc2MessageRefs</span>(hi, &amp;<span class="built_in">count</span>);</span><br><span class="line">       <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>) continue;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (PrintVtables) &#123;</span><br><span class="line">           <span class="variable">_objc_inform</span>(<span class="string">"VTABLES: repairing %zu unsupported vtable dispatch "</span></span><br><span class="line">                        <span class="string">"call sites in %s"</span>, <span class="built_in">count</span>, hi-&gt;fname);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">count</span>; i++) &#123;</span><br><span class="line">           fixupMessageRef(refs+i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过 _getObjc2MessageRefs 读取Mach-O文件中的 __objc_msgrefs section。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修复一个老的 vtable 调度</span></span><br><span class="line"><span class="comment">// 调用者：_read_images()</span></span><br><span class="line">static void </span><br><span class="line">fixupMessageRef(message_ref_t *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册消息的 sel</span></span><br><span class="line">    <span class="function"><span class="title">msg</span>-&gt;</span><span class="function"><span class="title">sel</span> = sel_registerName((const char *)msg-&gt;</span>sel);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">if</span> (ignoreSelector(msg-&gt;</span>sel)) &#123; <span class="comment">// 如果 sel 是需要被忽略的，就将其 imp 设为 _objc_ignored_method</span></span><br><span class="line">        <span class="comment">// ignored selector - bypass dispatcher</span></span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;_objc_ignored_method;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fixup) &#123; <span class="comment">// 如果消息的 imp 是 objc_msgSend_fixup，即指定了需要将 imp fixup</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (msg-&gt;</span>sel == SEL_alloc) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_alloc;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_allocWithZone) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_allocWithZone;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_retain) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_retain;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_release) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_release;</span><br><span class="line">        &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>sel == SEL_autorelease) &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = (IMP)&amp;objc_autorelease;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fixedup; <span class="comment">// 如果上面都不符合，就将它设置为已经 fixed-up 了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSendSuper2_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSendSuper2_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_stret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_stret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSendSuper2_stret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSendSuper2_stret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#<span class="keyword">if</span> defined(__i386__)  ||  defined(__x86_64__)</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fpret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fpret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#endif</span><br><span class="line">#<span class="keyword">if</span> defined(__x86_64__)</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (msg-&gt;</span>imp == &amp;objc_msgSend_fp2ret_fixup) &#123; </span><br><span class="line">        <span class="function"><span class="title">msg</span>-&gt;</span>imp = &amp;objc_msgSend_fp2ret_fixedup;</span><br><span class="line">    &#125; </span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fixupMessageRef 函数的作用是修正部分SEL的IMP。</p><h3 id="读取-objc-protolist（协议列表），添加到protocol-map表中"><a href="#读取-objc-protolist（协议列表），添加到protocol-map表中" class="headerlink" title="读取__objc_protolist（协议列表），添加到protocol_map表中"></a>读取__objc_protolist（协议列表），添加到protocol_map表中</h3><h4 id="objc-protolist-理解"><a href="#objc-protolist-理解" class="headerlink" title="__objc_protolist 理解"></a>__objc_protolist 理解</h4><p>编写下面代码，展示协议的结构：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">LJProtocal</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">-(<span class="built_in">NSString</span> *) instanceMethod;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *) calssMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) instanceOptMethod;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSString</span> *) calssOptMethod;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>) <span class="built_in">NSString</span> * strProperty;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>用machoview查看：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/protocal_LJProtocal_machoview.png" alt="__objc_protolist 示意图"></p><p>用hopper 查看地址0x 0000000100004260：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/proprotocal_LJProtocla_hoper.png" alt="LJProtocal使用hopper显示结构"></p><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover protocols. Fix up protocol refs. 取得镜像中的协议，读出协议</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    extern objc_class OBJC_CLASS_<span class="variable">$_Protocol</span>;</span><br><span class="line">    <span class="keyword">Class</span> cls = (<span class="keyword">Class</span>)&amp;OBJC_CLASS_<span class="variable">$_Protocol</span>;</span><br><span class="line">    <span class="keyword">assert</span>(cls);</span><br><span class="line">    NXMapTable *protocol_map = protocols();</span><br><span class="line">    bool isPreoptimized = hi-&gt;isPreoptimized();</span><br><span class="line">    bool isBundle = hi-&gt;isBundle();</span><br><span class="line"></span><br><span class="line">    protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;<span class="keyword">count</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = 0; i &lt; <span class="keyword">count</span>; i++) &#123;</span><br><span class="line">        readProtocol(protolist[i], cls, protocol_map, </span><br><span class="line">                     isPreoptimized, isBundle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过_getObjc2ProtocolList 读取__objc_protolist section. 将读取的结果分别调用readProtocol函数。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取一个编译器写的协议</span></span><br><span class="line"><span class="comment">// 调用者：_read_images()</span></span><br><span class="line">static void</span><br><span class="line">readProtocol(protocol_t *newproto,</span><br><span class="line">             Class protocol_class,</span><br><span class="line">             NXMapTable *protocol_map, </span><br><span class="line">             bool headerIsPreoptimized,</span><br><span class="line">             bool headerIsBundle)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This is not enough to make protocols in unloaded bundles safe, </span></span><br><span class="line">    <span class="comment">// but it does prevent crashes when looking up unrelated protocols.</span></span><br><span class="line">    <span class="comment">// 如果镜像是 bundle，就使用 NXMapKeyCopyingInsert 函数，否则使用 NXMapInsert</span></span><br><span class="line">    <span class="comment">// NXMapKeyCopyingInsert 会在堆中拷贝 key</span></span><br><span class="line">    auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据新协议的重整名称，去 protocol_map 映射表中查找老的协议</span></span><br><span class="line">    <span class="function"><span class="title">protocol_t</span> *oldproto = (protocol_t *)getProtocol(newproto-&gt;</span>mangledName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldproto) &#123; <span class="comment">// 如果存在老的协议，就只报个警告，因为不允许有重名的协议</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (headerIsPreoptimized) &#123; <span class="comment">// 如果不存在老的协议，但是镜像是经过预优化的</span></span><br><span class="line">        <span class="comment">// Shared cache initialized the protocol object itself, </span></span><br><span class="line">        <span class="comment">// but in order to allow out-of-cache replacement we need </span></span><br><span class="line">        <span class="comment">// to add it to the protocol table now.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据新协议的重整名称 查找 预优化的缓存协议</span></span><br><span class="line">        <span class="comment">// 但是 getPreoptimizedProtocol 现在一直返回 nil</span></span><br><span class="line">        protocol_t *cacheproto = (protocol_t *)</span><br><span class="line">            <span class="function"><span class="title">getPreoptimizedProtocol</span>(newproto-&gt;</span>mangledName);</span><br><span class="line">        </span><br><span class="line">        protocol_t *installedproto;</span><br><span class="line">        <span class="keyword">if</span> (cacheproto  &amp;&amp;  cacheproto != newproto) &#123;</span><br><span class="line">            <span class="comment">// Another definition in the shared cache wins (because </span></span><br><span class="line">            <span class="comment">// everything in the cache was fixed up to point to it).</span></span><br><span class="line">            installedproto = cacheproto;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 因为 cacheproto 永远是 nil，所以一直走 else 分支</span></span><br><span class="line">            <span class="comment">// This definition wins.</span></span><br><span class="line">            installedproto = newproto;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">assert</span>(installedproto-&gt;</span>getIsa() == protocol_class);</span><br><span class="line">        <span class="function"><span class="title">assert</span>(installedproto-&gt;</span>size &gt;= sizeof(protocol_t));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 新协议的重整名称 -&gt; 新协议 的映射插入 protocol_map 映射表中</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, installedproto-&gt;</span>mangledName, </span><br><span class="line">                 installedproto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">else</span> <span class="keyword">if</span> (newproto-&gt;</span>size &gt;= sizeof(protocol_t)) &#123; <span class="comment">// 如果不存在老的协议，且没有经过预优化，且新协议的大小</span></span><br><span class="line">                                                     <span class="comment">// 比 protocol_t 的标准尺寸要大</span></span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with sufficient storage. Fix it up in place.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        <span class="function"><span class="title">newproto</span>-&gt;</span>initIsa(protocol_class);  <span class="comment">// fixme pinned</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, newproto-&gt;</span><span class="function"><span class="title">mangledName</span>, newproto); // 就将 新协议的重整名称 -&gt;</span> 新协议 的映射插入</span><br><span class="line">                                                                 <span class="comment">// protocol_map 映射表中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在老的协议，且没有经过预优化，且新协议的大小比 protocol_t 的标准尺寸要小</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// New protocol from an un-preoptimized image</span></span><br><span class="line">        <span class="comment">// with insufficient storage. Reallocate it.</span></span><br><span class="line">        <span class="comment">// fixme duplicate protocols from unloadable bundle</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 取大的 size，这里按照上面的逻辑，应该是 sizeof(protocol_t)</span></span><br><span class="line">        <span class="function"><span class="title">size_t</span> size = max(sizeof(protocol_t), (size_t)newproto-&gt;</span>size);</span><br><span class="line">        <span class="comment">// 新建一个 installedproto 协议，在堆中分配内存，并清零</span></span><br><span class="line">        protocol_t *installedproto = (protocol_t *)calloc(size, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 将 newproto 内存上的内容 拷贝到 installedproto 中</span></span><br><span class="line">        <span class="function"><span class="title">memcpy</span>(installedproto, newproto, newproto-&gt;</span>size);</span><br><span class="line">        <span class="comment">// 将 installedproto-&gt;size 设为新的 size</span></span><br><span class="line">        <span class="function"><span class="title">installedproto</span>-&gt;</span><span class="function"><span class="title">size</span> = (__typeof__(installedproto-&gt;</span>size))size;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">installedproto</span>-&gt;</span>initIsa(protocol_class); <span class="comment">// 设置 isa  // fixme pinned</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 installedproto 插入 protocol_map 映射表中</span></span><br><span class="line">        <span class="function"><span class="title">insertFn</span>(protocol_map, installedproto-&gt;</span>mangledName, installedproto);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readProtocol 将读取的协议，存储到protocol_map 表中。 </p><p>存储协议的hash表的介绍如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/protocol_map.png" alt="LJProtocal使用hopper显示结构"></p><h4 id="将协议存储到表的作用"><a href="#将协议存储到表的作用" class="headerlink" title="将协议存储到表的作用"></a>将协议存储到表的作用</h4><p>这里也是举个例子，例如，  NSObject的conformsToProtocol 方法，判断当前类是否遵守协议protocol：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)conformsToProtocol:(Protocol *)protocol &#123;</span><br><span class="line">    <span class="keyword">if</span> (!protocol) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [<span class="keyword">self</span> <span class="keyword">class</span>]; tcls; tcls = tcls-&gt;superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (class_conformsToProtocol(tcls, protocol)) <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环所有当前类–&gt;超类，调用 class_conformsToProtocol方法。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BOOL class_conformsToProtocol(<span class="keyword">Class</span> cls, Protocol *proto_gen)</span><br><span class="line">&#123;</span><br><span class="line">    protocol_t *proto = newprotocol(proto_gen);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">if</span> (!proto_gen) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    rwlock_reader_t lock(runtimeLock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (const <span class="built_in">auto</span>&amp; proto_ref : cls-&gt;data()-&gt;protocols) &#123;</span><br><span class="line">        protocol_t *p = remapProtocol(proto_ref);</span><br><span class="line">        <span class="keyword">if</span> (p == proto |<span class="type">| protocol_conformsToProtocol_nolock</span>(p, proto)) &#123;</span><br><span class="line">            <span class="keyword">return</span> YES;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取出类cls中所有准守的协议，循环调用protocol_conformsToProtocol_nolock，判断两个协议是否一致。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">**********************************************************************/</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">bool</span> </span><br><span class="line">protocol_conformsToProtocol_nolock(protocol_t *<span class="keyword">self</span>, protocol_t *other)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>  ||  !other) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// protocols need not be fixed up</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == strcmp(<span class="keyword">self</span>-&gt;mangledName, other-&gt;mangledName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>-&gt;protocols) &#123;</span><br><span class="line">        uintptr_t i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>-&gt;protocols-&gt;count; i++) &#123;</span><br><span class="line">            protocol_t *proto = remapProtocol(<span class="keyword">self</span>-&gt;protocols-&gt;list[i]);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == strcmp(other-&gt;mangledName, proto-&gt;mangledName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (protocol_conformsToProtocol_nolock(proto, other)) &#123;</span><br><span class="line">                <span class="keyword">return</span> YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果协议的整合名称mangledName一样，认为协议一致，否则循环self中剩下的协议，只要有一个相同，就认为是遵守。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> protocol_t *<span class="title">remapProtocol</span><span class="params">(<span class="keyword">protocol_ref_t</span> proto)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protocol_t</span> *newproto = (<span class="keyword">protocol_t</span> *)</span><br><span class="line">        getProtocol(((<span class="keyword">protocol_t</span> *)proto)-&gt;mangledName);</span><br><span class="line">    <span class="keyword">return</span> newproto ? newproto : (<span class="keyword">protocol_t</span> *)proto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remapProtocol 根据协议的引用在表中找到协议。</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Protocol</span> *getProtocol(<span class="keyword">const</span> <span class="built_in">char</span> *name)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    // <span class="type">Try</span> name <span class="keyword">as</span>-<span class="keyword">is</span>.</span><br><span class="line">    <span class="type">Protocol</span> *<span class="literal">result</span> = (<span class="type">Protocol</span> *)<span class="type">NXMapGet</span>(protocols(), name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>) <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line"></span><br><span class="line">    // <span class="type">Try</span> <span class="type">Swift</span>-mangled equivalent <span class="keyword">of</span> the given name.</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">char</span> *swName = copySwiftV1MangledName(name, <span class="literal">true</span>/*isProtocol*/)) &#123;</span><br><span class="line">        <span class="literal">result</span> = (<span class="type">Protocol</span> *)<span class="type">NXMapGet</span>(protocols(), swName);</span><br><span class="line">        free(swName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getProtocol 通过协议名称找到协议。</p><h3 id="读取-objc-nlclslist（none-lazy类），并实现类"><a href="#读取-objc-nlclslist（none-lazy类），并实现类" class="headerlink" title="读取__objc_nlclslist（none lazy类），并实现类"></a>读取__objc_nlclslist（none lazy类），并实现类</h3><p>__objc_nlclslist section中存储着这样的类：</p><ol><li>类中还有+load方法</li><li>类有静态实例</li></ol><p>这样的类会马上使用，所以需要立马初始化。</p><h4 id="objc-nlclslist-介绍"><a href="#objc-nlclslist-介绍" class="headerlink" title="__objc_nlclslist 介绍"></a>__objc_nlclslist 介绍</h4><p><img src="/wiki/IOS/Runtime/objc/9__read_images/nlclasslist_simple.png" alt="LJProtocal使用hopper显示结构"></p><p>上图说明 如果类中有+load方法，这个类在编译的时候就会放置到__objc_nlclslist section中。 图中上面部分是测试代码，中间部分是machoview查看结果，下面部分是使用hopper查看反汇编地址，证明40e0处存储的是persion类。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Realize non-lazy classes (for +load methods and static instances)</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123;</span><br><span class="line">    classref_t *classlist = </span><br><span class="line">        _getObjc2NonlazyClassList(hi, &amp;count);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) </span><br><span class="line">        &#123;</span><br><span class="line">        Class <span class="keyword">cls</span> = remapClass(classlist[i]);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">cls</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        realizeClass(<span class="keyword">cls</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当类中有+load方法、或者类有静态实例，编译器会将类添加到<strong>objc_nlclslist section中。 上面代码读取</strong>objc_nlclslist 中的所有类，将读出的类调用realizeClass函数实现类。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">static Class realizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看 runtimeLock 是否正确得加了写锁</span></span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro;</span><br><span class="line">    class_rw_t *rw;</span><br><span class="line">    Class supercls;</span><br><span class="line">    Class metacls;</span><br><span class="line">    bool isMeta;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls) return <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果类已经被 realize 过，就不用 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">        return cls;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assert(cls == remapClass(cls)); <span class="comment">// remapClass(cls) 得到的是 cls 对应的重映射类，</span></span><br><span class="line">                                    <span class="comment">// 如果 cls 不存在于 remapped_class_map 映射表，得到的才是 cls 本身，</span></span><br><span class="line">                                    <span class="comment">// 所以这里断言 cls == remapClass(cls) 就是看 cls 是否存在于 remapped_class_map 映射表</span></span><br><span class="line">                                    <span class="comment">// 不存在，就是正确；存在，就是错误</span></span><br><span class="line">                                    <span class="comment">// 不存在，则 cls 既不是 realized future class，也不是 ignored weak-linked class</span></span><br><span class="line">                                    <span class="comment">// 见 remappedClasses()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme verify class is not in an un-dlopened part of the shared cache?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针</span></span><br><span class="line"><span class="comment">//    初始化一个 class_rw_t 结构体</span></span><br><span class="line"><span class="comment">//    设置结构体中 ro 的值以及 flag</span></span><br><span class="line"><span class="comment">//    最后设置正确的 data。</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">ro</span> = (const class_ro_t *)cls-&gt;</span><span class="keyword">data</span>(); <span class="comment">// 因为在 realized 之前，objc_class 中的 class_data_bits_t bits 里</span></span><br><span class="line">                                          <span class="comment">// 本质上存的是 class_ro_t，所以这里只需要转成 class_ro_t 类型就可以了</span></span><br><span class="line">                                          <span class="comment">// 但 future 的类是例外!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_FUTURE) &#123;</span><br><span class="line">        <span class="comment">// 如果 ro 的 flag 里记录了这是一个 future 的类，那么 objc_class 中的 class_data_bits_t bits 里存的是 class_rw_t</span></span><br><span class="line">        <span class="comment">// rw 数据已经被分配好内存了，现在要做的就是填充信息</span></span><br><span class="line">        <span class="comment">// This was a future class. rw data is already allocated.</span></span><br><span class="line">        <span class="function"><span class="title">rw</span> = cls-&gt;</span><span class="keyword">data</span>();  <span class="comment">// 取出 rw</span></span><br><span class="line">        <span class="function"><span class="title">ro</span> = cls-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>ro; <span class="comment">// 取出 ro</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); <span class="comment">// 清除 future 状态，RW_FUTURE 位的值置为 0</span></span><br><span class="line">                                                              <span class="comment">// 设置为 realized + realizing 状态</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                  <span class="comment">// RW_REALIZED 和 RW_REALIZING 位的值置为 1</span></span><br><span class="line">        <span class="comment">// Normal class. Allocate writeable class data.</span></span><br><span class="line">        <span class="comment">// 正常的类的话，就需要开辟内存</span></span><br><span class="line">        rw = (class_rw_t *)calloc(sizeof(class_rw_t), <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>ro = ro; <span class="comment">// 将原来的 ro 赋给新 rw 中的 ro 字段</span></span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>flags = RW_REALIZED|RW_REALIZING; <span class="comment">// 设置为 realized + realizing 状态</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setData(rw); <span class="comment">// 将新的 rw 替换老的 rw</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">isMeta</span> = ro-&gt;</span>flags &amp; RO_META; <span class="comment">// cls 类是否是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">rw</span>-&gt;</span>version = isMeta ? <span class="number">7</span> : <span class="number">0</span>;  <span class="comment">// old runtime went up to 6</span></span><br><span class="line">                            <span class="comment">// 版本，元类是 7，普通类是 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Realize superclass and metaclass, if they aren't already.</span></span><br><span class="line">    <span class="comment">// This needs to be done after RW_REALIZED is set above, for root classes.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// remapClass() 函数是如果参数是一个已经 realized 的 future 类，则返回的是新类，否则返回的是自己</span></span><br><span class="line">    <span class="comment">// 查看 cls 的父类对应的重映射的类，将其 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">supercls</span> = realizeClass(remapClass(cls-&gt;</span>superclass));</span><br><span class="line">    <span class="comment">// 查看 cls 的元类对应的重映射的类，将其 realize 了</span></span><br><span class="line">    <span class="function"><span class="title">metacls</span> = realizeClass(remapClass(cls-&gt;</span>ISA()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update superclass and metaclass in case of remapping</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>superclass = supercls; <span class="comment">// 更新 cls 的父类</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span>initClassIsa(metacls); <span class="comment">// 和元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reconcile instance variable offsets / layout.</span></span><br><span class="line">    <span class="comment">// This may reallocate class_ro_t, updating our ro variable.</span></span><br><span class="line">    <span class="keyword">if</span> (supercls  &amp;&amp;  !isMeta) &#123; <span class="comment">// 根据父类，调整 cls 类 ro 中实例变量的偏移量和布局</span></span><br><span class="line">                                 <span class="comment">// 可能重新分配 class_ro_t，更新 ro</span></span><br><span class="line">        reconcileInstanceVariables(cls, supercls, ro);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set fastInstanceSize if it wasn't set already.</span></span><br><span class="line">    <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">setInstanceSize</span>(ro-&gt;</span>instanceSize); <span class="comment">// 设置成员变量的新的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy some flags from ro to rw</span></span><br><span class="line">    <span class="comment">// 从 ro 拷贝一些 flag 到 rw 中，可能是为了加快查找速度</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (ro-&gt;</span>flags &amp; RO_HAS_CXX_STRUCTORS) &#123; <span class="comment">// 是否有 C++ 构造器/析构器</span></span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxDtor(); <span class="comment">// 设置有 C++ 析构器</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (! (ro-&gt;</span>flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123; <span class="comment">// 不只有 C++ 析构器，那么就是也有 C++ 构造器，真绕啊</span></span><br><span class="line">            <span class="function"><span class="title">cls</span>-&gt;</span>setHasCxxCtor();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .....</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Connect this class to its superclass's subclass lists</span></span><br><span class="line">    <span class="keyword">if</span> (supercls) &#123;</span><br><span class="line">        addSubclass(supercls, cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 methodizeClass 函数来将分类中的方法列表、属性列表、协议列表加载到 methods、 properties 和 protocols 列表数组中</span></span><br><span class="line">    <span class="comment">// Attach categories</span></span><br><span class="line">    methodizeClass(cls);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isMeta) &#123; <span class="comment">// 如果不是元类</span></span><br><span class="line">        addRealizedClass(cls); <span class="comment">// 就把它添加到 realized_class_hash 哈希表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addRealizedMetaclass(cls); <span class="comment">// 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return cls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>realizeClass realize(实现) 指定的 cls 类：</p><ol><li>包括开辟它的 read-write data，也就是 rw，见 class_rw_t 结构体；</li><li>设置类的类型，元类or 普通类；</li><li>递归超类、元类，调用realizeClass。确保超类全部实现过；</li><li>设置superclass指针、元类指针；</li><li>reconcileInstanceVariables ；</li><li>addSubclass 构建类继承体系的链表；</li><li>methodizeClass 调整方法  ；</li><li>添加到全局表中。</li></ol><p>realizeClass 的总体流程如下图：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizeClass.png" alt="realizeClass 的总体流程"></p><h4 id="开辟rw"><a href="#开辟rw" class="headerlink" title="开辟rw"></a>开辟rw</h4><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizemethod_rw.png" alt="realizeClass 的总体流程"></p><p>开辟RW的工作就是：将class_data_bits_t结构中bits的3-&gt;47位指定的RO切断，创建新的class_rw_t结构，3-&gt;47位 重新存储新的class_rw_t结构地址，然后将class_rw_t结构中的ro指针指向原始的class_ro_t结构。</p><h4 id="reconcileInstanceVariables（没看）"><a href="#reconcileInstanceVariables（没看）" class="headerlink" title="reconcileInstanceVariables（没看）"></a>reconcileInstanceVariables（没看）</h4><p>这部分我也不会，没看。</p><h4 id="addSubclass"><a href="#addSubclass" class="headerlink" title="addSubclass"></a>addSubclass</h4><p>构建出的链表如下：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/addClass.png" alt="addSubclass 构成链表的示意图 "></p><h4 id="methodizeClass"><a href="#methodizeClass" class="headerlink" title="methodizeClass"></a>methodizeClass</h4><p>methodizeClass代码如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. fix-up cls 类的方法列表、协议列表、属性列表（但是看代码，被 fix-up 的只有方法列表啊）</span></span><br><span class="line"><span class="comment">//    将 cls 类的所有没有被 attach 的分类 attach 到 cls 上</span></span><br><span class="line"><span class="comment">// 2. 即将分类中的方法、属性、协议添加到 methods、 properties 和 protocols 中</span></span><br><span class="line"><span class="comment">//    runtimeLock 读写锁必须被调用者上写锁，保证线程安全</span></span><br><span class="line">static void methodizeClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看调用者是否已经正确地将 runtimeLock 上了写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">bool</span> isMeta = cls-&gt;</span>isMetaClass(); <span class="comment">// 记录 cls 类是否是元类</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> rw = cls-&gt;</span><span class="function"><span class="title">data</span>(); // 取得 cls 中的 rw，因为在 realizeClass() 中已经处理好了 cls-&gt;</span><span class="keyword">data</span>()，</span><br><span class="line">                           <span class="comment">// 所以里面现在存的确定是 rw，而不是 ro</span></span><br><span class="line">    <span class="function"><span class="title">auto</span> ro = rw-&gt;</span><span class="function"><span class="title">ro</span>; // 取得 rw-&gt;</span>ro</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methodizing for the first time</span></span><br><span class="line">    <span class="keyword">if</span> (PrintConnecting) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CLASS: methodizing class '%s' %s"</span>, </span><br><span class="line">                     <span class="function"><span class="title">cls</span>-&gt;</span>nameForLogging(), isMeta ? <span class="string">"(meta)"</span> : <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Install methods and properties that the class implements itself.</span></span><br><span class="line">    <span class="comment">// 取得 ro 中的 baseMethodList，在将其 prepare 后，插入 rw 的方法列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">method_list_t</span> *list = ro-&gt;</span>baseMethods();</span><br><span class="line">    <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        prepareMethodLists(cls, &amp;list, <span class="number">1</span>, YES, isBundleClass(cls));</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>methods.attachLists(&amp;list, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ro 中的 baseProperties 插入 rw 中的属性列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">property_list_t</span> *proplist = ro-&gt;</span>baseProperties;</span><br><span class="line">    <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>properties.attachLists(&amp;proplist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 ro 中的 baseProtocols 插入 rw 中的协议列表数组中</span></span><br><span class="line">    <span class="function"><span class="title">protocol_list_t</span> *protolist = ro-&gt;</span>baseProtocols;</span><br><span class="line">    <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">        <span class="function"><span class="title">rw</span>-&gt;</span>protocols.attachLists(&amp;protolist, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Root classes get bonus method implementations if they don't have </span></span><br><span class="line">    <span class="comment">// them already. These apply before category replacements.</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (cls-&gt;</span>isRootMetaclass()) &#123; <span class="comment">// 如果是根元类</span></span><br><span class="line">        <span class="comment">// root metaclass</span></span><br><span class="line">        <span class="comment">// 给根元类的 SEL_initialize 指定了对应的 IMP - objc_noop_imp</span></span><br><span class="line">        <span class="comment">// 即给根元类发送 SEL_initialize 消息，不会走到它的 +initialize，而是走 objc_noop_imp，里面啥也不干</span></span><br><span class="line">        addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, <span class="string">""</span>, NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attach categories.</span></span><br><span class="line">    <span class="comment">// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类</span></span><br><span class="line">    category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing 其实这个参数压根没用*/</span>);</span><br><span class="line">    <span class="comment">// 从分类列表中添加方法列表、属性和协议到 cls 类中</span></span><br><span class="line">    <span class="comment">// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？</span></span><br><span class="line">    <span class="comment">// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的</span></span><br><span class="line">    <span class="comment">//         所以压根儿不用再另外排序</span></span><br><span class="line">    attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cats) &#123;</span><br><span class="line">        free(cats); <span class="comment">// 将分类列表释放，见 unattachedCategoriesForClass，</span></span><br><span class="line">                    <span class="comment">// 里面着重强调了调用方需要负责释放分类列表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码完成的四个工作用图中的4条虚线表示：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/relizemethod_method.png" alt="methodizeClass 工作内容 "></p><p>接下来的工作是是分类的处理，这里需要详细的讲下，所以在分出一节 </p><h4 id="分类-处理"><a href="#分类-处理" class="headerlink" title="分类 处理"></a>分类 处理</h4><h5 id="分类的数据结构"><a href="#分类的数据结构" class="headerlink" title="分类的数据结构"></a>分类的数据结构</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存放 locstamped_category_t 的列表</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_list_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count;  <span class="comment">// 数组有几个元素</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">locstamped_category_t</span> <span class="built_in">list</span>[<span class="number">0</span>]; <span class="comment">// 数组的起始地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地的盖了戳的 category，即已经被添加进了 unattachedCategories</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locstamped_category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">category_t</span> *cat;   <span class="comment">//  category</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">header_info</span> *<span class="title">hi</span>;</span>  <span class="comment">// 所属的 header，即所属的镜像</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 分类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">// 分类所属的类，classref_t 专门用于 unremapped 的类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>     <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>      <span class="comment">// 遵循的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性列表，但是并没有卵用... 唉....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/9__read_images/catogory_class.png" alt="分类数据结构 "></p><h5 id="存储所有分类的Map结构"><a href="#存储所有分类的Map结构" class="headerlink" title="存储所有分类的Map结构"></a>存储所有分类的Map结构</h5><p><img src="/wiki/IOS/Runtime/objc/9__read_images/category_map.png" alt="category_map 表 "></p><h5 id="向category-map中添加新的分类"><a href="#向category-map中添加新的分类" class="headerlink" title="向category_map中添加新的分类"></a>向category_map中添加新的分类</h5><p>向category_map中添加新的分类 调用addUnattachedCategoryForClass方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addUnattachedCategoryForClass</span><span class="params">(<span class="keyword">category_t</span> *cat, Class cls, header_info *catHeader)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead</span></span><br><span class="line">    NXMapTable *cats = unattachedCategories(); <span class="comment">// 取得存储所有没有被 attached 的分类的列表</span></span><br><span class="line">    category_list *<span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从所有 unattached 的分类列表中取得 cls 类对应的所有没有被 attach 的分类列表</span></span><br><span class="line">    <span class="built_in">list</span> = (category_list *)NXMapGet(cats, cls);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">list</span>) &#123; <span class="comment">// 如果 cls 没有未  attach 的分类</span></span><br><span class="line">        <span class="comment">// 就开辟出一个单位的空间，用来放新来的这个分类</span></span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            <span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(*<span class="built_in">list</span>) + <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="number">0</span>]), <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则开辟出比原来多一个单位的空间，用来放新来的这个分类，因为 realloc ，所以原来的数据会被拷贝过来</span></span><br><span class="line">        <span class="built_in">list</span> = (category_list *)</span><br><span class="line">            <span class="built_in">realloc</span>(<span class="built_in">list</span>, <span class="keyword">sizeof</span>(*<span class="built_in">list</span>) + <span class="keyword">sizeof</span>(<span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="number">0</span>]) * (<span class="built_in">list</span>-&gt;count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的分类 cat 添加刚刚开辟的位置上</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;<span class="built_in">list</span>[<span class="built_in">list</span>-&gt;count++] = (<span class="keyword">locstamped_category_t</span>)&#123;cat, catHeader&#125;;</span><br><span class="line">    <span class="comment">// 将新的 list 重新插入 cats 中，会覆盖老的 list</span></span><br><span class="line">    NXMapInsert(cats, cls, <span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/9__read_images/addUnattachedCategoryForClass.png" alt="category_map中插入cat"></p><h5 id="将分类附着（attachCategories）到类中"><a href="#将分类附着（attachCategories）到类中" class="headerlink" title="将分类附着（attachCategories）到类中"></a>将分类附着（attachCategories）到类中</h5><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Attach categories.</span></span><br><span class="line"><span class="comment">// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类</span></span><br><span class="line">category_list *cats = unattachedCategoriesForClass(cls, <span class="literal">true</span> <span class="comment">/*realizing 其实这个参数压根没用*/</span>);</span><br><span class="line"><span class="comment">// 从分类列表中添加方法列表、属性和协议到 cls 类中</span></span><br><span class="line"><span class="comment">// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？</span></span><br><span class="line"><span class="comment">// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的</span></span><br><span class="line"><span class="comment">//         所以压根儿不用再另外排序</span></span><br><span class="line">attachCategories(cls, cats, <span class="literal">false</span> <span class="comment">/*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/</span>);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> </span><br><span class="line">attachCategories(Class cls, category_list *cats, <span class="keyword">bool</span> flush_caches)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cats) <span class="keyword">return</span>; <span class="comment">// 如果列表是 nil，直接返回</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印一些信息</span></span><br><span class="line">    <span class="keyword">if</span> (PrintReplacedMethods) &#123;</span><br><span class="line">        printReplacements(cls, cats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> isMeta = cls-&gt;isMetaClass(); <span class="comment">// 记录 cls 类是否是元类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fixme rearrange to remove these intermediate allocations</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在堆中为方法列表数组、属性列表数组、协议列表数组分配足够大内存，注意，它们都是二维数组</span></span><br><span class="line">    <span class="comment">// 后面会将所有分类中的方法列表、属性列表、协议列表的首地址放到里面</span></span><br><span class="line">    <span class="keyword">method_list_t</span> **mlists = (<span class="keyword">method_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*mlists));</span><br><span class="line">    <span class="keyword">property_list_t</span> **proplists = (<span class="keyword">property_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*proplists));</span><br><span class="line">    <span class="keyword">protocol_list_t</span> **protolists = (<span class="keyword">protocol_list_t</span> **)</span><br><span class="line">        <span class="built_in">malloc</span>(cats-&gt;count * <span class="keyword">sizeof</span>(*protolists));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Count backwards through cats to get newest categories first</span></span><br><span class="line">    <span class="keyword">int</span> mcount = <span class="number">0</span>; <span class="comment">// 记录方法的数量</span></span><br><span class="line">    <span class="keyword">int</span> propcount = <span class="number">0</span>; <span class="comment">// 记录属性的数量</span></span><br><span class="line">    <span class="keyword">int</span> protocount = <span class="number">0</span>; <span class="comment">// 记录协议的数量</span></span><br><span class="line">    <span class="keyword">int</span> i = cats-&gt;count; <span class="comment">// 从后开始，保证先取最新的分类</span></span><br><span class="line">    <span class="keyword">bool</span> fromBundle = NO; <span class="comment">// 记录是否是从 bundle 中取的</span></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123; <span class="comment">// 从后往前遍历</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span>&amp; entry = cats-&gt;<span class="built_in">list</span>[i]; <span class="comment">// 分类，locstamped_category_t 类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中的方法列表；如果是元类，取得的是类方法列表；否则取得的是实例方法列表</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *mlist = entry.cat-&gt;methodsForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist; <span class="comment">// 将方法列表放入 mlists 方法列表数组中</span></span><br><span class="line">            fromBundle |= entry.hi-&gt;isBundle(); <span class="comment">// 分类的头部信息中存储了是否是 bundle，将其记住</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中的属性列表，如果是元类，取得是nil</span></span><br><span class="line">        <span class="keyword">property_list_t</span> *proplist = entry.cat-&gt;propertiesForMeta(isMeta);</span><br><span class="line">        <span class="keyword">if</span> (proplist) &#123;</span><br><span class="line">            proplists[propcount++] = proplist; <span class="comment">// 将属性列表放入 proplists 属性列表数组中</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出分类中遵循的协议列表</span></span><br><span class="line">        <span class="keyword">protocol_list_t</span> *protolist = entry.cat-&gt;protocols;</span><br><span class="line">        <span class="keyword">if</span> (protolist) &#123;</span><br><span class="line">            protolists[protocount++] = protolist; <span class="comment">// 将协议列表放入 protolists 协议列表数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> rw = cls-&gt;data(); <span class="comment">// 取出 cls 的 class_rw_t 数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备 mlists 中的方法列表们</span></span><br><span class="line">    prepareMethodLists(cls, mlists, mcount<span class="comment">/*方法列表的数量*/</span>, NO<span class="comment">/*不是基本方法*/</span>, fromBundle<span class="comment">/*是否来自bundle*/</span>);</span><br><span class="line">    rw-&gt;methods.attachLists(mlists, mcount); <span class="comment">// 将准备完毕的新方法列表们添加到 rw 中的方法列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(mlists); <span class="comment">// 释放 mlists</span></span><br><span class="line">    <span class="keyword">if</span> (flush_caches  &amp;&amp;  mcount &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果需要清空方法缓存，并且刚才确实有方法列表添加进 rw 中，</span></span><br><span class="line">                                        <span class="comment">// 不然没有新方法加进来，就没有必要清空，清空是为了避免无法命中缓存的错误</span></span><br><span class="line">                                        <span class="comment">// 因为缓存位置是按照 hash 的方法确定的，详情见 cache_t::find() 函数</span></span><br><span class="line">        flushCaches(cls); <span class="comment">// 清空 cls 类 / cls 类的元类 / cls 类的子孙类 的方法缓存</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rw-&gt;properties.attachLists(proplists, propcount); <span class="comment">// 将新属性列表添加到 rw 中的属性列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(proplists); <span class="comment">// 释放 proplists</span></span><br><span class="line"></span><br><span class="line">    rw-&gt;protocols.attachLists(protolists, protocount); <span class="comment">// 将新协议列表添加到 rw 中的协议列表数组中</span></span><br><span class="line">    <span class="built_in">free</span>(protolists); <span class="comment">// 释放 protolists</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码将 category_list *cats 中的list成员表示的方法列表转化为数组mlists：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/attachCategories_ToArray.png" alt="cats-&gt;list-&gt; mlists"></p><p>转化完成后，调用attachLists方法，附着到类上：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将List** 中的内容附着到method_array_t 上,原理如图：</p><p><img src="/wiki/IOS/Runtime/objc/9__read_images/attachLists_1.png" alt="构建list_array_tt结构 "></p><h4 id="添加全局表"><a href="#添加全局表" class="headerlink" title="添加全局表"></a>添加全局表</h4><p>添加的到全局表的代码如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isMeta) &#123; <span class="comment">// 如果不是元类</span></span><br><span class="line">    addRealizedClass(<span class="keyword">cls</span>); <span class="comment">// 就把它添加到 realized_class_hash 哈希表中</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addRealizedMetaclass(<span class="keyword">cls</span>); <span class="comment">// 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据类的类型，元类还是普通类，调用不同的方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRealizedClass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = NXHashInsert(realizedClasses(), cls); <span class="comment">// 将 cls 插入 realized_class_hash 哈希表中</span></span><br><span class="line">    objc_addRegisteredClass(cls); <span class="comment">// 将 cls 添加到已注册类的哈希表中(objc-auto.mm 中的 AllClasses)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(!cls-&gt;isMetaClass()); <span class="comment">// cls 不能是元类</span></span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// 不能有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通类调用addRealizedClass方法，将类添加到realizedClasses()表中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得存有所有经过 realized 的非元类的哈希表</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXHashTable *<span class="title">realizedClasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> realized_class_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接返回realized_class_hash hash表。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> addRealizedMetaclass(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    <span class="keyword">void</span> *old;</span><br><span class="line">    old = NXHashInsert(realizedMetaclasses(), cls); <span class="comment">// 将 cls 元类添加到 realized_metaclass_hash 哈希表中</span></span><br><span class="line">    <span class="keyword">assert</span>(cls-&gt;isMetaClass()); <span class="comment">// cls 必须是元类</span></span><br><span class="line">    <span class="keyword">assert</span>(!old); <span class="comment">// 不能有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元类调用addRealizedMetaclass 将类添加到 realizedMetaclasses()表中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得存有所有经过 realized 的元类的哈希表</span></span><br><span class="line"><span class="comment">// 该函数被 addRealizedMetaclass()/flushCaches()/removeRealizedMetaclass()函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> NXHashTable *<span class="title">realizedMetaclasses</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> realized_metaclass_hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取分类，remethodize类"><a href="#读取分类，remethodize类" class="headerlink" title="读取分类，remethodize类"></a>读取分类，remethodize类</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discover categories.</span></span><br><span class="line"><span class="keyword">for</span> (EACH_HEADER) &#123; <span class="comment">// 遍历 hList</span></span><br><span class="line">    <span class="comment">// 取得 hi 镜像中的所有分类</span></span><br><span class="line">    category_t **catlist = _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123; <span class="comment">// 遍历所有分类</span></span><br><span class="line">        category_t *cat = catlist[i];</span><br><span class="line">        C<span class="function"><span class="title">lass</span> cls = remapClass(cat-&gt;</span>cls); <span class="comment">// 得到分类所属的类的 live class</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cls) &#123; <span class="comment">// 如果 cls 为空</span></span><br><span class="line">            <span class="comment">// Category's target class is missing (probably weak-linked).</span></span><br><span class="line">            <span class="comment">// Disavow any knowledge of this category.</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 分类所属的类丢了，很多可能是 weak-linked 了</span></span><br><span class="line">            <span class="comment">// 这个分类就是不可信的，完全没有什么鸟用了</span></span><br><span class="line">            catlist[i] = <span class="literal">nil</span>; <span class="comment">// 将这个分类从列表中删除</span></span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Process this category. </span></span><br><span class="line">        <span class="comment">// First, register the category with its target class. </span></span><br><span class="line">        <span class="comment">// Then, rebuild the class's method lists (etc) if </span></span><br><span class="line">        <span class="comment">// the class is realized.</span></span><br><span class="line">        </span><br><span class="line">        bool classExists = NO;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">instanceMethods</span> ||  cat-&gt;</span>protocols  </span><br><span class="line">            ||  <span class="function"><span class="title">cat</span>-&gt;</span>instanceProperties) <span class="comment">// 如果分类中存在实例方法 or 协议 or 实例属性</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加分类到所属的 cls 类上，即把这个分类添加到 cls 对应的所有 unattached 的分类的列表中</span></span><br><span class="line">            addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 cls 类已经被 realized</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cls-&gt;</span>isRealized()) &#123;</span><br><span class="line">                <span class="comment">// 就重新 methodize 一下 cls 类，里面会重新 attachCategories 一下所有未被 attach 的分类</span></span><br><span class="line">                <span class="comment">// 即把这些分类中的方法、协议、属性添加到 cls 类中</span></span><br><span class="line">                remethodizeClass(cls);</span><br><span class="line">                classExists = YES; <span class="comment">// 标记类存在</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果分类中存在类方法 or 协议</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (cat-&gt;</span><span class="function"><span class="title">classMethods</span>  ||  cat-&gt;</span>protocols  </span><br><span class="line">            <span class="comment">/* ||  cat-&gt;classProperties */</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 添加分类到所属类 cls 的元类中</span></span><br><span class="line">            <span class="function"><span class="title">addUnattachedCategoryForClass</span>(cat, cls-&gt;</span>ISA(), hi);</span><br><span class="line">            <span class="comment">// 如果 cls 的元类已经 realized 过了</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (cls-&gt;</span>ISA()-&gt;isRealized()) &#123;</span><br><span class="line">                <span class="comment">// 就重新 methodize 一下 cls 类的元类</span></span><br><span class="line">                <span class="function"><span class="title">remethodizeClass</span>(cls-&gt;</span>ISA());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码发现所有的分类，</p><ol><li>如果分类中包含实例方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls：(cat：hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到类中。</li><li>如果分类中包含类方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls-&gt;ISA()：(cat： hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到元类中。</li></ol><p>remethodizeClass 实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">remethodizeClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    <span class="keyword">bool</span> isMeta;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting(); <span class="comment">// 看 runtimeLock 是否已经被正确得加上了写锁</span></span><br><span class="line"></span><br><span class="line">    isMeta = cls-&gt;isMetaClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-methodizing: check for more categories</span></span><br><span class="line">    <span class="comment">// 取得 cls 类的未被 attach 的分类列表</span></span><br><span class="line">    <span class="keyword">if</span> ((cats = unattachedCategoriesForClass(cls, <span class="literal">false</span><span class="comment">/*not realizing*/</span>))) &#123;</span><br><span class="line">        <span class="comment">// 将分类列表 attach 附加到 cls 类上，因为这不是第一次 methodize，所以需要清空缓存，因为原来的缓存也已经废了</span></span><br><span class="line">        attachCategories(cls, cats, <span class="literal">true</span> <span class="comment">/* 清空方法缓存 flush caches*/</span>);</span><br><span class="line">        <span class="built_in">free</span>(cats); <span class="comment">// 将 cats 释放，原因见 unattachedCategoriesForClass()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>remethodizeClass 调用unattachedCategoriesForClass 取得类所属的分类，调用attachCategories将分类中的方法、协议、属性添加的类中。<br>这个方面和上面的methodizeClass 功能基本相同。methodizeClass比remethodizeClass多一个操作————处理base相关的信息。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>_read_images 主要是读取Mach-O中下面的section ，存储到内存中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GETSECT(<span class="name">_getObjc2SelectorRefs</span>,        SEL,             <span class="string">"__objc_selrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2MessageRefs</span>,         message_ref_t,   <span class="string">"__objc_msgrefs"</span>)<span class="comment">; </span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassRefs</span>,           Class,           <span class="string">"__objc_classrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2SuperRefs</span>,           Class,           <span class="string">"__objc_superrefs"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ClassList</span>,           classref_t,      <span class="string">"__objc_classlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2NonlazyClassList</span>,    classref_t,      <span class="string">"__objc_nlclslist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2CategoryList</span>,        category_t *,    "__objc_catlist");</span><br><span class="line">GETSECT(_getObjc2NonlazyCategoryList, category_t *,    <span class="string">"__objc_nlcatlist"</span>)<span class="comment">;</span></span><br><span class="line">GETSECT(<span class="name">_getObjc2ProtocolList</span>,        protocol_t *,    "__objc_protolist");</span><br><span class="line">GETSECT(_getObjc2ProtocolRefs,        protocol_t *,    <span class="string">"__objc_protorefs"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;_read_images从镜像文件中读取所有类信息、方法信息、分类信息。这篇文章就介绍具体读取了什么信息。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="_read_images" scheme="http://yoursite.com/tags/read-images/"/>
    
  </entry>
  
  <entry>
    <title>8. objc4入口函数</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/8__objc_init/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/8__objc_init/</id>
    <published>2018-11-26T03:38:11.000Z</published>
    <updated>2018-11-27T03:01:14.694Z</updated>
    
    <content type="html"><![CDATA[<p>__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。</p><a id="more"></a><h2 id="objc-init"><a href="#objc-init" class="headerlink" title="_objc_init"></a>_objc_init</h2><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">_objc_init</span>(void)</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="comment">// Register for unmap first, in case some +load unmaps something</span></span><br><span class="line">    <span class="comment">// 首先第一步，注册 unmap 函数，万一有的类的 +load 方法需要 unmap 一些东西</span></span><br><span class="line">    <span class="comment">// unmap，即 un-memory-mapped，这里应该就是取消内存映射，移除镜像的意思</span></span><br><span class="line">    <span class="selector-tag">_dyld_register_func_for_remove_image</span>(&amp;unmap_image);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册镜像状态改变时的回调函数</span></span><br><span class="line">    <span class="selector-tag">dyld_register_image_state_change_handler</span>(dyld_image_state_bound,</span><br><span class="line">                                             <span class="number">1</span><span class="comment">/*batch 是否批处理*/</span>, &amp;map_2_images);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册镜像状态改变时的回调函数，镜像加载完成后，需要调用 +load 时会回调 load_images 函数</span></span><br><span class="line">    <span class="comment">// 不进行批处理，所以 load_images 会被调用多次，每次有新的镜像进来时，都会被调用</span></span><br><span class="line">    <span class="selector-tag">dyld_register_image_state_change_handler</span>(dyld_image_state_dependents_initialized, <span class="number">0</span><span class="comment">/*not batch*/</span>, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先看map_2_images函数，load_images后面一遍介绍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理给定的镜像，这些镜像被 dyld库 映射</span></span><br><span class="line"><span class="comment">// 这个函数其实是一个回调函数，被 dyld 库调用，参数中的镜像信息也是 dyld 库传进来的，详情见 _objc_init()</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">map_2_images(<span class="keyword">enum</span> dyld_image_states state,</span><br><span class="line">             <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">             <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock); <span class="comment">// runtimeLock 加写锁</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在 map_images_nolock 函数中，完成所有 class 的注册、fixup等工作，</span></span><br><span class="line">    <span class="comment">// 还包括初始化自动释放池、初始化 side table 等等工作</span></span><br><span class="line">    <span class="keyword">return</span> map_images_nolock(state, infoCount, infoList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map_2_images内部调用了map_images_nolock函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射镜像，在这个函数中，完成所有 class 的注册、fixup等工作，</span></span><br><span class="line"><span class="comment">// 还包括初始化自动释放池、初始化 side table 等工作</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *</span><br><span class="line">map_images_nolock(<span class="keyword">enum</span> dyld_image_states state,</span><br><span class="line">                  <span class="keyword">uint32_t</span> infoCount,</span><br><span class="line">                  <span class="keyword">const</span> struct dyld_image_info infoList[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> firstTime = YES;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> wantsGC = NO;</span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line">    header_info *hi;</span><br><span class="line">    header_info *hList[infoCount];</span><br><span class="line">    <span class="keyword">uint32_t</span> hCount;</span><br><span class="line">    <span class="keyword">size_t</span> selrefCount = <span class="number">0</span>;</span><br><span class="line">   ....</span><br><span class="line">    <span class="comment">// Find all images with Objective-C metadata.</span></span><br><span class="line">    hCount = <span class="number">0</span>;</span><br><span class="line">    i = infoCount;</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">        <span class="keyword">const</span> headerType *mhdr = (headerType *)infoList[i].imageLoadAddress;</span><br><span class="line"></span><br><span class="line">        hi = addHeader(mhdr);</span><br><span class="line">        <span class="keyword">if</span> (!hi) &#123;</span><br><span class="line">            <span class="comment">// no objc data in this entry</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mhdr-&gt;filetype == MH_EXECUTE) &#123;</span><br><span class="line">            <span class="comment">// Size some data structures based on main executable's size</span></span><br><span class="line">            _getObjcSelectorRefs(hi, &amp;selrefCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hList[hCount++] = hi</span><br><span class="line">    &#125;</span><br><span class="line">   ....</span><br><span class="line">    _read_images(hList, hCount);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map_images_nolock对所有的镜像列表执行addHeader，主要过滤重复的镜像。</p><p>接着调用_read_images函数。_read_images比较复杂，后面文章分析。下面看看addHeader的具体实现：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> header_info * addHeader(<span class="keyword">const</span> headerType *mhdr)</span><br><span class="line">&#123;</span><br><span class="line">    header_info *hi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bad_magic(mhdr)) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Didn't find an hinfo in the dyld shared cache.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Weed out duplicates</span></span><br><span class="line">        <span class="keyword">for</span> (hi = FirstHeader; hi; hi = hi-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mhdr == hi-&gt;mhdr) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Locate the __OBJC segment</span></span><br><span class="line">        size_t info_size = <span class="number">0</span>;</span><br><span class="line">        unsigned <span class="keyword">long</span> seg_size;</span><br><span class="line">        <span class="keyword">const</span> objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size);</span><br><span class="line">        <span class="keyword">const</span> uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&amp;seg_size);</span><br><span class="line">        <span class="keyword">if</span> (!objc_segment  &amp;&amp;  !image_info) <span class="keyword">return</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allocate a header_info entry.</span></span><br><span class="line">        hi = (header_info *)calloc(sizeof(header_info), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up the new header_info entry.</span></span><br><span class="line">        hi-&gt;mhdr = mhdr;</span><br><span class="line">        hi-&gt;info = image_info;</span><br><span class="line">        hi-&gt;fname = dyld_image_path_containing_address(hi-&gt;mhdr);</span><br><span class="line">        hi-&gt;loaded = <span class="keyword">true</span>;</span><br><span class="line">        hi-&gt;inSharedCache = <span class="keyword">false</span>;</span><br><span class="line">        hi-&gt;allClassesRealized = NO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dylibs are not allowed to unload</span></span><br><span class="line">    <span class="comment">// ...except those with image_info and nothing else (5359412)</span></span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;mhdr-&gt;filetype == MH_DYLIB  &amp;&amp;  _hasObjcContents(hi)) &#123;</span><br><span class="line">        dlopen(hi-&gt;fname, RTLD_NOLOAD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    appendHeader(hi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hi;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addHeader将传入的headerType参数mhdr 构造出header_info类型，最后调用appendHeader函数：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void appendHeader(header_info *hi)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Add the header to the header list. </span></span><br><span class="line">    <span class="comment">// The header is appended to the list, to preserve the bottom-up order.</span></span><br><span class="line">    HeaderCount++;</span><br><span class="line">    <span class="function"><span class="title">hi</span>-&gt;</span>next = NULL;</span><br><span class="line">    <span class="keyword">if</span> (!FirstHeader) &#123;</span><br><span class="line">        <span class="comment">// list is empty</span></span><br><span class="line">        FirstHeader = LastHeader = hi;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!LastHeader) &#123;</span><br><span class="line">            <span class="comment">// list is not empty, but LastHeader is invalid - recompute it</span></span><br><span class="line">            LastHeader = FirstHeader;</span><br><span class="line">            <span class="function"><span class="title">while</span> (LastHeader-&gt;</span><span class="function"><span class="title">next</span>) LastHeader = LastHeader-&gt;</span>next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// LastHeader is now valid</span></span><br><span class="line">        L<span class="function"><span class="title">astHeader</span>-&gt;</span>next = hi;</span><br><span class="line">        LastHeader = hi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>appendHeader 将hi放入FirstHeader的列表中。<br>其中FirstHeader、LastHeader的定义如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">header_info</span> <span class="meta">*FirstHeader</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span>  <span class="string">//</span> <span class="literal">NULL</span> <span class="string">means</span> <span class="string">empty</span> <span class="string">list</span> <span class="string">第一个</span> <span class="string">image(镜像)</span></span><br><span class="line"><span class="string">header_info</span> <span class="meta">*LastHeader</span>  <span class="string">=</span> <span class="number">0</span><span class="string">;</span>  <span class="string">//</span> <span class="literal">NULL</span> <span class="string">means</span> <span class="string">invalid;</span> <span class="string">recompute</span> <span class="string">it</span></span><br><span class="line"><span class="string">int</span> <span class="string">HeaderCount</span> <span class="string">=</span> <span class="number">0</span><span class="string">;</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>map_2_images  主要完成的工作如下：</p><ol><li>镜像去重复</li><li>对于每个镜像，从dyld_image_info 构造出header_info结构</li><li>将header_info结构添加到列表FirstHeader中，LastHeader 指向列表的最后一个元素。</li><li>执行_read_images，后续讲解。</li></ol><p>转化的header_info结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/8__objc_init/headerInfo.png" alt="dyld_image_info转化为header_info结构"></p><p>FirstHeader 的链表结构如下图所示,这里记录了objc库加载的所有的镜像。</p><p><img src="/wiki/IOS/Runtime/objc/8__objc_init/firstHeader.png" alt="FirstHeader 的链表"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="__objc_init" scheme="http://yoursite.com/tags/objc-init/"/>
    
  </entry>
  
  <entry>
    <title>7. NXMapTable数据结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/7_NXMapTable/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/7_NXMapTable/</id>
    <published>2018-11-22T16:38:11.000Z</published>
    <updated>2018-11-23T11:27:02.923Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍NXMapTable数据结构</p><a id="more"></a><h2 id="NXMapTable-数据结构"><a href="#NXMapTable-数据结构" class="headerlink" title="NXMapTable 数据结构"></a>NXMapTable 数据结构</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTable</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private data structure; may change */</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTablePrototype</span>*<span class="title">prototype</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span>count;</span><br><span class="line">    <span class="keyword">unsigned</span>nbBucketsMinusOne;</span><br><span class="line">    <span class="keyword">void</span>*buckets;</span><br><span class="line">&#125; NXMapTable OBJC_MAP_AVAILABILITY;</span><br></pre></td></tr></table></figure><p>count 存储的个数， nbBucketsMinusOne 容量减1， buckets 存储数据。</p><p>_NXMapTablePrototype定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NXMapTablePrototype</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>(*hash)(NXMapTable *, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">int</span>(*isEqual)(NXMapTable *, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span>(*<span class="built_in">free</span>)(NXMapTable *, <span class="keyword">void</span> *key, <span class="keyword">void</span> *value);</span><br><span class="line">    <span class="keyword">int</span>style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXMapTablePrototype OBJC_MAP_AVAILABILITY;</span><br></pre></td></tr></table></figure><p>_NXMapTablePrototype 结构存储三个函数指针hash、 isEqual、 free。</p><p>类图如下:</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_class.png" alt="NXMapTable类图"></p><h3 id="主要的接口"><a href="#主要的接口" class="headerlink" title="主要的接口"></a>主要的接口</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXMapTable *<span class="title">NXCreateMapTableFromZone</span><span class="params">(NXMapTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">void</span> *z)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"><span class="function">NXMapTable *<span class="title">NXCreateMapTable</span><span class="params">(NXMapTablePrototype prototype, <span class="keyword">unsigned</span> capacity)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NXFreeMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NXResetMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">NXCompareMapTables</span><span class="params">(NXMapTable *table1, NXMapTable *table2)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">NXCountMapTable</span><span class="params">(NXMapTable *table)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapMember</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">void</span> **value)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapGet</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapInsert</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">const</span> <span class="keyword">void</span> *value)</span> OBJC_MAP_AVAILABILITY</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXMapRemove</span><span class="params">(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> OBJC_MAP_AVAILABILITY</span>;</span><br></pre></td></tr></table></figure><h3 id="NXCreateMapTableFromZone"><a href="#NXCreateMapTableFromZone" class="headerlink" title="NXCreateMapTableFromZone"></a>NXCreateMapTableFromZone</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">NXMapTable *NXCreateMapTableFromZone(NXMapTablePrototype prototype, unsigned capacity, void *z) &#123;</span><br><span class="line">    NXMapTable*<span class="keyword">table</span> = (NXMapTable <span class="comment">*)malloc_zone_malloc((malloc_zone_t *)z, sizeof(NXMapTable))</span>;</span><br><span class="line">    NXMapTablePrototype*proto;</span><br><span class="line">    <span class="keyword">if</span> (! prototypes) prototypes = NXCreateHashTable(protoPrototype, <span class="number">0</span>, NULL);</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash || ! prototype.isEqual || ! prototype.<span class="keyword">free</span> || prototype.style) &#123;</span><br><span class="line">_objc_inform(<span class="string">"*** NXCreateMapTable: invalid creation parameters\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = (NXMapTablePrototype *)NXHashGet(prototypes, &amp;prototype); </span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">proto = (NXMapTablePrototype *)malloc(sizeof(NXMapTablePrototype));</span><br><span class="line">*proto = prototype;</span><br><span class="line">    (void)NXHashInsert(prototypes, proto);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>-&gt;prototype <span class="comment">= proto</span>;<span class="comment"> table-&gt;count = 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">= exp2u(log2u(capacity)+1) - 1</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= allocBuckets(z, table-&gt;nbBucketsMinusOne + 1)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NXMapTable *NXCreateMapTable(NXMapTablePrototype prototype, unsigned capacity) &#123;</span><br><span class="line">    return NXCreateMapTableFromZone(prototype, capacity, malloc_default_zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NXCreateMapTableFromZone 主要工作：</p><ol><li>创建table</li><li>处理proto，如果先前没有prototype，存储在prototypes全局hash表中。</li><li>赋值成员。</li></ol><h3 id="NXFreeMapTable"><a href="#NXFreeMapTable" class="headerlink" title="NXFreeMapTable"></a>NXFreeMapTable</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void NXFreeMapTable(NXMapTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    NXResetMapTable(<span class="keyword">table</span>);</span><br><span class="line">    freeBuckets(<span class="keyword">table</span>-&gt;buckets);</span><br><span class="line">    free(<span class="keyword">table</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void NXResetMapTable(NXMapTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    void(*freeProc)(struct _NXMapTable *, void *, void *) = <span class="keyword">table</span>-&gt;prototype-&gt;free;</span><br><span class="line">    unsignedindex = <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">+ 1</span>;</span><br><span class="line">    while (index--) &#123;</span><br><span class="line">if (pairs-&gt;key != NX_MAPNOTAKEY) &#123;</span><br><span class="line">    freeProc(<span class="keyword">table</span>, (void <span class="comment">*)pairs-&gt;key, (void *)pairs-&gt;value)</span>;</span><br><span class="line">    pairs-&gt;key = NX_MAPNOTAKEY; pairs-&gt;value = NULL;</span><br><span class="line">&#125;</span><br><span class="line">pairs++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环调用free函数， 删除存储的数据。</p><h3 id="NXCountMapTable"><a href="#NXCountMapTable" class="headerlink" title="NXCountMapTable"></a>NXCountMapTable</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned NXCountMapTable(NXMapTable *<span class="keyword">table</span>) &#123; <span class="keyword">return</span> <span class="keyword">table</span>-&gt;<span class="keyword">count</span>; &#125;</span><br></pre></td></tr></table></figure><p>获取table中存储数据的个数。返回NXMapTable的count成员。</p><h3 id="NXMapMember"><a href="#NXMapMember" class="headerlink" title="NXMapMember"></a>NXMapMember</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">void</span> *_NXMapMember(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> **value) &#123;</span><br><span class="line">    MapPair*pairs = (MapPair *)table-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(table, <span class="built_in">key</span>);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">key</span> == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, pair-&gt;<span class="built_in">key</span>, <span class="built_in">key</span>)) &#123;</span><br><span class="line">*value = (<span class="keyword">void</span> *)pair-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)pair-&gt;<span class="built_in">key</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> ((index2 = nextIndex(table, index2)) != index) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;<span class="built_in">key</span> == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, pair-&gt;<span class="built_in">key</span>, <span class="built_in">key</span>)) &#123;</span><br><span class="line">    *value = (<span class="keyword">void</span> *)pair-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)pair-&gt;<span class="built_in">key</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *NXMapMember(NXMapTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> **value) &#123;</span><br><span class="line">    <span class="keyword">return</span> _NXMapMember(table, <span class="built_in">key</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NXMapMember 获取给定key对应的值，该函数首先通过bucketOf取出索引：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> bucketOf(NXMapTable *<span class="keyword">table</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span>hash = (<span class="keyword">table</span>-&gt;prototype-&gt;hash)(<span class="keyword">table</span>, key);</span><br><span class="line">    <span class="keyword">return</span> hash &amp; <span class="keyword">table</span>-&gt;nbBucketsMinusOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bucketOf 函数通过key计算出hash值，然后将hash值和table-&gt;nbBucketsMinusOne按位与，执行的结果一定小于等于 table-&gt;nbBucketsMinusOne，也就是一定小于容量，不会产生一个超出容量的索引。 </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapPair*pair = pairs + <span class="keyword">index</span>;</span><br></pre></td></tr></table></figure><p>通过索引找到存储的内容pair，类型是MapPair。</p><p>接着根据pair的内容，分三种情况：</p><ol><li>索引位置位的内容为空，直接返回NX_MAPNOTAKEY,value值不设置。</li><li>索引位置的内容不空，但是key一样，返回key，设置value的内容为当前pair的value。</li><li>索引位置内容不空，并且key不一样，循环查找下一个位置，直到找到一个位置，这个位置的key和传入的key相等。返回key，设置value的内容为当前pair的value。</li></ol><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br></pre></td></tr></table></figure><p>如果找到的位置没有内容，直接返回NX_MAPNOTAKEY。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isEqual(table, <span class="built_in">pair</span>-&gt;key, key)) &#123;</span><br><span class="line">*value = (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;key;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果索引位置的key相同，传出key对应的内容。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> ((index2 = nextIndex(table, index2)) != index) &#123;</span><br><span class="line">    <span class="built_in">pair</span> = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pair</span>-&gt;key == NX_MAPNOTAKEY) <span class="keyword">return</span> NX_MAPNOTAKEY;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(table, <span class="built_in">pair</span>-&gt;key, key)) &#123;</span><br><span class="line">    *value = (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;value;</span><br><span class="line"><span class="keyword">return</span> (<span class="literal">void</span> *)<span class="built_in">pair</span>-&gt;key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果索引的位置有值，且key不相等，循环查找下一个位置，直到找到相同的key，或者循环完成。</p><p>其中nextIndex 函数计算出下一个索引。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> INLINE <span class="keyword">unsigned</span> nextIndex(NXMapTable *<span class="keyword">table</span>, <span class="keyword">unsigned</span> index) &#123;</span><br><span class="line">    <span class="keyword">return</span> (index + <span class="number">1</span>) &amp; <span class="keyword">table</span>-&gt;nbBucketsMinusOne;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以递增的示意图如下：</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_find_next_index.gif" alt="索引完整循环实例"></p><h3 id="NXMapInsert"><a href="#NXMapInsert" class="headerlink" title="NXMapInsert"></a>NXMapInsert</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">void *NXMapInsert(NXMapTable *<span class="keyword">table</span>, const <span class="comment">void *key, const void *value) &#123;</span></span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(<span class="keyword">table</span>, key);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    <span class="keyword">if</span> (key == NX_MAPNOTAKEY) &#123;</span><br><span class="line">_objc_inform(<span class="string">"*** NXMapInsert: invalid key: -1\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unsigned numBuckets = <span class="keyword">table</span>-&gt;nbBucketsMinusOne <span class="comment">+ 1</span>;</span><br><span class="line"></span><br><span class="line">    if (pair-&gt;key == NX_MAPNOTAKEY) &#123;</span><br><span class="line">        pair-&gt;key = key; pair-&gt;value = value;</span><br><span class="line">        <span class="keyword">table</span>-&gt;count++;</span><br><span class="line">        if (<span class="keyword">table</span>-&gt;count <span class="comment">* 4 &gt; numBuckets * 3) _NXMapRehash(table)</span>;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key))</span><br><span class="line">    &#123;</span><br><span class="line">        const void*old = pair-&gt;value;</span><br><span class="line">        <span class="keyword">if</span> (old != value) pair-&gt;value = value;<span class="comment">/* avoid writing unless needed! */</span></span><br><span class="line">        return (void *)old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">table</span>-&gt;count <span class="comment">== numBuckets) &#123;</span></span><br><span class="line">        <span class="comment">/* no room: rehash and retry */</span></span><br><span class="line">        _NXMapRehash(<span class="keyword">table</span>);</span><br><span class="line">        return NXMapInsert(<span class="keyword">table</span>, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        unsignedindex2 = index;</span><br><span class="line">        <span class="keyword">while</span> ((index2 = nextIndex(<span class="keyword">table</span>, index2)) != index) &#123;</span><br><span class="line">            pair = pairs + index2;</span><br><span class="line">            <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY)</span><br><span class="line">            &#123;</span><br><span class="line">                  pair-&gt;key = key; pair-&gt;value = value;</span><br><span class="line">                <span class="keyword">table</span>-&gt;count++;</span><br><span class="line">                if (<span class="keyword">table</span>-&gt;count <span class="comment">* 4 &gt; numBuckets * 3) _NXMapRehash(table)</span>;</span><br><span class="line">                return NULL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key))</span><br><span class="line">            &#123;</span><br><span class="line">                const void*old = pair-&gt;value;</span><br><span class="line">                <span class="keyword">if</span> (old != value) pair-&gt;value = value;<span class="comment">/* avoid writing unless needed! */</span></span><br><span class="line">                return (void *)old;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* no room: can't happen! */</span></span><br><span class="line">_objc_inform(<span class="string">"**** NXMapInsert: bug\n"</span>);</span><br><span class="line">return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码有几个关键的地方：</p><ol><li>容量大于3/4 就扩容，扩大为原来的2倍。</li><li>添加分为三种情况： 索引位置为空，直接插入、索引位置不空，key相同，替换新的内容、索引位置内容不空，key不相同，循环查找下一个内容为空的位置，如果找到，插入，否则什么页不做。</li></ol><p>下面两图分别说明上面的三种情况 。</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_1.gif" alt="插入位置为空  or 插入位置不为空，但key相同"></p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXHashTable_2.gif" alt="插入位置不空，key相同"></p><h3 id="NXMapRemove"><a href="#NXMapRemove" class="headerlink" title="NXMapRemove"></a>NXMapRemove</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">void *NXMapRemove(NXMapTable *<span class="keyword">table</span>, const <span class="comment">void *key) &#123;</span></span><br><span class="line">    MapPair*pairs = (MapPair *)<span class="keyword">table</span>-&gt;buckets;</span><br><span class="line">    unsignedindex = bucketOf(<span class="keyword">table</span>, key);</span><br><span class="line">    MapPair*pair = pairs + index;</span><br><span class="line">    unsignedchain = <span class="number">1</span>; <span class="comment">/* number of non-nil pairs in a row */</span></span><br><span class="line">    intfound = <span class="number">0</span>;</span><br><span class="line">    const void*old = NULL;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) return NULL;</span><br><span class="line">    mapRemove ++;</span><br><span class="line">    <span class="comment">/* compute chain */</span></span><br><span class="line">    &#123;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) &#123;found <span class="comment">++</span>;<span class="comment"> old = pair-&gt;value</span>;<span class="comment"> &#125;</span></span><br><span class="line">while ((index2 = nextIndex(<span class="keyword">table</span>, index2)) != index) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (pair-&gt;key == NX_MAPNOTAKEY) break;</span><br><span class="line">    <span class="keyword">if</span> (isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) &#123;found <span class="comment">++</span>;<span class="comment"> old = pair-&gt;value</span>;<span class="comment"> &#125;</span></span><br><span class="line">    chain++;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (! found) return NULL;</span><br><span class="line">    <span class="keyword">if</span> (found != <span class="number">1</span>) _objc_inform(<span class="string">"**** NXMapRemove: incorrect table\n"</span>);</span><br><span class="line">    <span class="comment">/* remove then reinsert */</span></span><br><span class="line">    &#123;</span><br><span class="line">MapPairbuffer[<span class="number">16</span>];</span><br><span class="line">MapPair*aux = (chain &gt; <span class="number">16</span>) ? (MapPair *)malloc(sizeof(MapPair)*(chain<span class="number">-1</span>)) : buffer;</span><br><span class="line">unsignedauxnb = <span class="number">0</span>;</span><br><span class="line">intnb = chain;</span><br><span class="line">unsignedindex2 = index;</span><br><span class="line"><span class="keyword">while</span> (nb--) &#123;</span><br><span class="line">    pair = pairs + index2;</span><br><span class="line">    <span class="keyword">if</span> (! isEqual(<span class="keyword">table</span>, pair-&gt;key, key)) aux[auxnb++] = *pair;</span><br><span class="line">    pair-&gt;key = NX_MAPNOTAKEY; pair-&gt;value = NULL;</span><br><span class="line">    index2 = nextIndex(<span class="keyword">table</span>, index2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">table</span>-&gt;count <span class="comment">-= chain</span>;</span><br><span class="line">if (auxnb != chain<span class="number">-1</span>) _objc_inform(<span class="string">"**** NXMapRemove: bug\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (auxnb--) NXMapInsert(<span class="keyword">table</span>, aux[auxnb].key, aux[auxnb].value);</span><br><span class="line">if (chain &gt; <span class="number">16</span>) free(aux);</span><br><span class="line">    &#125;</span><br><span class="line">    return (void *)old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除指定key的内容分为下面几步：</p><ol><li>通过key找到索引</li><li>如果key对于的MapPair为空，直接返回</li><li>计算key存储数据的实际位置和应该存储位置的距离chain。这段距离内的元素的存储位置可能不是按照对应位置存储的。</li><li>删除chain内的元素，重新插入chain-1 个元素。</li></ol><p>用下面图理解删除的代码。</p><p><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_1.png" alt="初始情况有两个元素，5，7"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_2.png" alt="插入元素20"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_3.png" alt="插入元素5，发现5的位置被20占用，往后查找空位置"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_4.png" alt="查找到的空位置是8，保存5，在次基础上开始删除"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_5.png" alt="chain=4，表示和应该存储位置偏移了4个距离"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_6.png" alt="删除四个元素，其中5，6，7保存"><br><img src="/wiki/IOS/Runtime/objc/7_NXMapTable/NXMaptable_delete_7.png" alt="重新插入5，6，7，修正了存储数据"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍NXMapTable数据结构&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>6. 上古时代 Objective-C 中哈希表的实现(转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/6_NXHashTable/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/6_NXHashTable/</id>
    <published>2018-11-22T02:38:11.000Z</published>
    <updated>2018-11-22T09:42:23.102Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><p>文章会介绍上古时代 Objective-C 哈希表，也就是 <code>NXHashTable</code> ：</p><ul><li><code>NXHashTable</code> 的实现</li><li><code>NXHashTable</code> 的性能分析</li><li><code>NXHashTable</code> 的作用</li></ul><p><code>NXHashTable</code> 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。</p><blockquote><p>文中会涉及一些数据结构方面的简单知识，例如<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>。</p><p>注意：<strong>文章中分析的不是 <code>NSHashTable</code> 而是 <code>NXHashTable</code>。</strong></p></blockquote><a id="more"></a><h2 id="NXHashTable"><a href="#NXHashTable" class="headerlink" title="NXHashTable"></a>NXHashTable</h2><p><code>NXHashTable</code> 的实现位于 <code>hashtable2.mm</code> 文件，我们先来看一下 <code>NXHashTable</code> 的结构以及重要的接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> NXHashTablePrototype *prototype;</span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    <span class="keyword">unsigned</span> nbBuckets;</span><br><span class="line">    <span class="keyword">void</span> *buckets;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *info;</span><br><span class="line">&#125; NXHashTable;</span><br></pre></td></tr></table></figure><p>对于结构体中的 <code>NXHashTablePrototype</code> 属性暂且不说，其中的 <code>buckets</code> 是真正用来<strong>存储数据的数组</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXHashTable *<span class="title">NXCreateHashTableFromZone</span> <span class="params">(NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *z)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">NXCountHashTable</span> <span class="params">(NXHashTable *table)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NXHashMember</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashGet</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashInsert</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashRemove</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>我们会以上面的这些方法作为切入点，分析 <code>NXHashTable</code> 的实现。</p><h3 id="NXCreateHashTableFromZone"><a href="#NXCreateHashTableFromZone" class="headerlink" title="NXCreateHashTableFromZone"></a>NXCreateHashTableFromZone</h3><p><code>NXHashTable</code> 使用 <code>NXCreateHashTableFromZone</code> 方法初始化：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123;</span><br><span class="line">    NXHashTable*<span class="keyword">table</span>;</span><br><span class="line">    NXHashTablePrototype *proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span> = ALLOCTABLE(z);</span><br><span class="line">    if (! prototypes) bootstrap ();</span><br><span class="line">    <span class="keyword">if</span> (! prototype.hash) prototype.hash = NXPtrHash;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual;</span><br><span class="line">    <span class="keyword">if</span> (! prototype.<span class="keyword">free</span>) prototype.<span class="keyword">free</span> = NXNoEffectFree;</span><br><span class="line"></span><br><span class="line">    proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    <span class="keyword">if</span> (! proto) &#123;</span><br><span class="line">        proto = (NXHashTablePrototype *) malloc(sizeof (NXHashTablePrototype));</span><br><span class="line">        bcopy ((const char*)&amp;prototype, (char*)proto, sizeof (NXHashTablePrototype));</span><br><span class="line">        (void) NXHashInsert (prototypes, proto);</span><br><span class="line">        proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">table</span>-&gt;prototype <span class="comment">= proto</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;info <span class="comment">= info</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBuckets <span class="comment">= GOOD_CAPACITY(capacity)</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= ALLOCBUCKETS(z, table-&gt;nbBuckets)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个方法中，绝大多数代码都是用来初始化 <code>table-&gt;prototype</code> 的，我们先把这部分全部忽略，分析一下简略版本的实现。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123;</span><br><span class="line">    NXHashTable*<span class="keyword">table</span>;</span><br><span class="line">    NXHashTablePrototype *proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span> = ALLOCTABLE(z);</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">table</span>-&gt;count <span class="comment">= 0</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;info <span class="comment">= info</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;nbBuckets <span class="comment">= GOOD_CAPACITY(capacity)</span>;</span><br><span class="line">    <span class="keyword">table</span>-&gt;buckets <span class="comment">= ALLOCBUCKETS(z, table-&gt;nbBuckets)</span>;</span><br><span class="line">    return <span class="keyword">table</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>ALLOCTABLE</code>、<code>GOOD_CAPACITY</code> 以及 <code>ALLOCBUCKETS</code> 都是用来辅助初始化的宏：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">ALLOCTABLE</span>(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">GOOD_CAPACITY</span>(c) (exp2m1u (log2u (c)+<span class="number">1</span>))</span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">ALLOCBUCKETS</span>(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket)))</span><br></pre></td></tr></table></figure><p><code>ALLOCTABLE</code> 和 <code>ALLOCBUCKETS</code> 只是调用了 <code>malloc_zone_calloc</code> 来初始化相应的结构体，而 <code>GOOD_CAPACITY</code> 有一些特殊，我们来举个例子说明：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c   binary  result</span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>       <span class="number">1</span> </span><br><span class="line"><span class="number">2</span>   <span class="number">10</span>      <span class="number">3</span>(<span class="number">0b11</span>)</span><br><span class="line"><span class="number">6</span>   <span class="number">110</span>     <span class="number">7</span>(<span class="number">0b111</span>)</span><br><span class="line"><span class="number">100</span> <span class="number">1100100</span> <span class="number">127</span>(<span class="number">0b111</span> <span class="number">1111</span>)</span><br></pre></td></tr></table></figure><p><code>c</code> 表示传入参数，<code>binary</code> 表示二进制下的参数，而 <code>result</code> 就是 <code>GOOD_CAPACITY</code> 返回的结果。</p><blockquote><p>每次返回当前位数下的二进制最大值。</p></blockquote><p>获得 <code>table-&gt;nbBuckets</code> 之后，再初始化 <code>table-&gt;nbBuckets * sizeof (HashBucket)</code> 大小的内存空间。</p><h4 id="NXHashTablePrototype"><a href="#NXHashTablePrototype" class="headerlink" title="NXHashTablePrototype"></a>NXHashTablePrototype</h4><p>在继续分析其它方法之前，我们需要先知道 <code>NXHashTablePrototype</code> 是什么：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> (*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> (*isEqual)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">const</span> <span class="keyword">void</span> *data1, <span class="keyword">const</span> <span class="keyword">void</span> *data2);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">const</span> <span class="keyword">void</span> *info, <span class="keyword">void</span> *data);</span><br><span class="line">    <span class="keyword">int</span> style; <span class="comment">/* reserved for future expansion; currently 0 */</span></span><br><span class="line">&#125; NXHashTablePrototype;</span><br></pre></td></tr></table></figure><p><code>NXHashTablePrototype</code> 中存储了 <code>hash</code>、<code>isEqual</code> 和 <code>free</code> 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。</p><p>在 <code>hashtable2.mm</code> 文件中有一个宏 <code>ISEQUAL</code> 就是用了 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 来判断两个数据是否相等：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ISEQUAL(<span class="name">table</span>, data1, data2) ((<span class="name">data1</span> == data2) || (<span class="name">*table-&gt;prototype-&gt;isEqual</span>)(<span class="name">table-&gt;info</span>, data1, data2))</span><br></pre></td></tr></table></figure><p>可以说，<code>NXHashTablePrototype</code> 中存储了一些<strong>构建哈希表必要的函数指针</strong>。</p><blockquote><p>因为 <code>NXHashTable</code> 使用<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。</p></blockquote><h4 id="HashBucket"><a href="#HashBucket" class="headerlink" title="HashBucket"></a>HashBucket</h4><p>在这里另一个需要注意的数据结构就是 <code>HashBucket</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> count;</span><br><span class="line">    oneOrMany elements;</span><br><span class="line">&#125; HashBucket;</span><br></pre></td></tr></table></figure><p><code>oneOrMany</code> 是一个 <code>union</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *one;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> **many;</span><br><span class="line">&#125; oneOrMany;</span><br></pre></td></tr></table></figure><blockquote><p>这么设计的主要原因是<strong>提升性能</strong>。</p></blockquote><p>如果 <code>HashBucket</code> 中只有一个元素，那么就直接访问 <code>one</code>，否则访问 <code>many</code>，遍历这个 <code>many</code> 列表。</p><h3 id="NXCountHashTable"><a href="#NXCountHashTable" class="headerlink" title="NXCountHashTable"></a>NXCountHashTable</h3><p><code>NXCountHashTable</code> 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 <code>NXHashTable</code> 结构体中的 <code>count</code>。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unsigned NXCountHashTable (NXHashTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    return <span class="keyword">table</span>-&gt;count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NXHashMember"><a href="#NXHashMember" class="headerlink" title="NXHashMember"></a>NXHashMember</h3><p><code>NXHashMember</code> 的函数签名虽然会返回 <code>int</code>，其实它是一个布尔值，会判断当前的 <code>NXHashTable</code> 中是否包含传入的数据：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> NXHashMember (NXHashTable *<span class="keyword">table</span>, <span class="keyword">const</span> <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(<span class="keyword">table</span>, data);</span><br><span class="line">    <span class="keyword">unsigned</span>j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(<span class="keyword">table</span>, data, bucket-&gt;elements<span class="variable">.one</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements<span class="variable">.many</span>;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(<span class="keyword">table</span>, data, *pairs)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>BUCKETOF</code> 对 <code>data</code> 进行 hash，将结果与哈希表的 <code>buckets</code> 数取模，返回 <code>buckets</code> 数组中对应的 <code>NXHashBucket</code>。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#<span class="function"><span class="title">define</span> BUCKETOF(table, <span class="keyword">data</span>) (((HashBucket *)table-&gt;</span><span class="function"><span class="title">buckets</span>)+((*table-&gt;</span><span class="function"><span class="title">prototype</span>-&gt;</span><span class="function"><span class="title">hash</span>)(table-&gt;</span><span class="function"><span class="title">info</span>, <span class="keyword">data</span>) % table-&gt;</span>nbBuckets))</span><br></pre></td></tr></table></figure><p>在获取了 <code>bucket</code> 之后，根据其中元素个数的不同，选择不同的分支：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ISEQUAL(<span class="built_in">table</span>, data, bucket-&gt;elements.one);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">pairs</span> = bucket-&gt;elements.many;</span><br><span class="line"><span class="keyword">while</span> (j<span class="comment">--) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(<span class="built_in">table</span>, data, *<span class="built_in">pairs</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pairs</span> ++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>count == 0</code>，直接返回</li><li><code>count == 1</code>，使用 <code>ISEQUAL</code> 比较查找的数据与 <code>bucket-&gt;elements.one</code> </li><li><p><code>count &gt; 1</code>，依次与 <code>bucket-&gt;elements.many</code> 中的值进行比较</p><blockquote><p>你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 <a href="#nxhashinsert">NXHashInsert</a> 中解释。</p></blockquote></li></ul><h3 id="NXHashGet"><a href="#NXHashGet" class="headerlink" title="NXHashGet"></a>NXHashGet</h3><blockquote><p>其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 <code>NXHashTablePrototype</code> 时，因为默认的 <code>NXHashTablePrototype</code> 中的 <code>isEqual</code> 函数指针只是比较两个数据的指针是否相同。</p><p>其最大作用就是查看当前 <code>data</code> 是不是在表中。</p><p>如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。</p></blockquote><p>它的实现跟上面的 <code>NXHashMember</code> 区别并不大，这里就不过多介绍了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">NXHashGet</span> <span class="params">(NXHashTable *table, <span class="keyword">const</span> <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(table, data);</span><br><span class="line">    <span class="keyword">unsigned</span>j = bucket-&gt;count;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span>**pairs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ISEQUAL(table, data, bucket-&gt;elements.one)</span><br><span class="line">        ? (<span class="keyword">void</span> *) bucket-&gt;elements.one : <span class="literal">NULL</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs = bucket-&gt;elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, data, *pairs)) <span class="keyword">return</span> (<span class="keyword">void</span> *) *pairs;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NXHashInsert"><a href="#NXHashInsert" class="headerlink" title="NXHashInsert"></a>NXHashInsert</h3><p><code>NXHashInsert</code> 是 <code>NXHashTable</code> 中比较重要的方法，其作用就是向表中插入数据：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">void *NXHashInsert (NXHashTable *table, const void *<span class="keyword">data</span>) &#123;</span><br><span class="line">    HashBucket *bucket = BUCKETOF(table, <span class="keyword">data</span>);</span><br><span class="line">    <span class="function"><span class="title">unsigned</span> j = bucket-&gt;</span>count;</span><br><span class="line">    const void **pairs;</span><br><span class="line">    const void **newt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) &#123;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) &#123;</span><br><span class="line">            <span class="function"><span class="title">const</span> void *old = bucket-&gt;</span>elements.one;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">            return (void *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">        <span class="function"><span class="title">newt</span>[1] = bucket-&gt;</span>elements.one;</span><br><span class="line">        *newt = <span class="keyword">data</span>;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">        <span class="function"><span class="title">if</span> (table-&gt;</span><span class="function"><span class="title">count</span> &gt; table-&gt;</span>nbBuckets) _NXHashRehash (table);</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">pairs</span> = bucket-&gt;</span>elements.many;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">            const void*old = *pairs;</span><br><span class="line">            *pairs = <span class="keyword">data</span>;</span><br><span class="line">            return (void *) old;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">newt</span> = ALLOCPAIRS(z, bucket-&gt;</span>count+<span class="number">1</span>);</span><br><span class="line">    <span class="function"><span class="title">if</span> (bucket-&gt;</span><span class="function"><span class="title">count</span>) bcopy ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)(newt+1), bucket-&gt;</span>count * PTRSIZE);</span><br><span class="line">    *newt = <span class="keyword">data</span>;</span><br><span class="line">    FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>count++; </span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">if</span> (table-&gt;</span><span class="function"><span class="title">count</span> &gt; table-&gt;</span>nbBuckets) _NXHashRehash (table);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况：</p><ul><li><code>bucket-&gt;count == 0</code></li><li><code>bucket-&gt;count == 1</code></li><li><code>bucket-&gt;count &gt; 1</code></li></ul><p>如果对应的 <code>bucket</code> 为空：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (! <span class="keyword">j) </span>&#123;</span><br><span class="line">    <span class="keyword">bucket-&gt;count++; </span></span><br><span class="line">    <span class="keyword">bucket-&gt;elements.one </span>= data<span class="comment">;</span></span><br><span class="line">    table-&gt;<span class="built_in">count</span>++<span class="comment">;</span></span><br><span class="line">    return NULL<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>将数据直接填入 <code>bucket</code>，增加 <code>bucket</code> 中元素的数目，以及 <code>table</code> 中存储的元素的数目：<br>6_NXHashTable/<br><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-empty.gif" alt="objc-hashtable-insert-empty"></p><p>如果原来的 <code>buckets</code> 中有一个元素，它会替换或者使用 <code>many</code> 替换原来的 <code>one</code>：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) &#123;</span><br><span class="line">        <span class="function"><span class="title">const</span> void*old = bucket-&gt;</span>elements.one;</span><br><span class="line">        <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = <span class="keyword">data</span>;</span><br><span class="line">        return (void *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    newt = ALLOCPAIRS(z, <span class="number">2</span>);</span><br><span class="line">    <span class="function"><span class="title">newt</span>[1] = bucket-&gt;</span>elements.one;</span><br><span class="line">    *newt = <span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line">    <span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当前数据 <code>data</code> 如果与 <code>bucket</code> 中存储的数据相同，就会更新这个数据，否则就会使用 <code>ALLOCPAIRS</code> 初始化一个新的数组，然后将 <code>data</code> 和原来的数据传入。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-one.gif.gif" alt="objc-hashtable-insert-one.gif"></p><p>但是如果原来的 <code>bucket</code> 中存储的元素大于 1，那么会在链表的头部追加一个新的元素：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (j--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">        const void*old = *pairs;</span><br><span class="line">        *pairs = <span class="keyword">data</span>;</span><br><span class="line">        return (void *) old;</span><br><span class="line">    &#125;;</span><br><span class="line">    pairs ++;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="title">newt</span> = ALLOCPAIRS(z, bucket-&gt;</span>count+<span class="number">1</span>);</span><br><span class="line"><span class="function"><span class="title">if</span> (bucket-&gt;</span><span class="function"><span class="title">count</span>) bcopy ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)(newt+1), bucket-&gt;</span>count * PTRSIZE);</span><br><span class="line">*newt = <span class="keyword">data</span>;</span><br><span class="line">FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line"><span class="function"><span class="title">bucket</span>-&gt;</span>count++;</span><br><span class="line"><span class="function"><span class="title">bucket</span>-&gt;</span>elements.many = newt;</span><br><span class="line"><span class="function"><span class="title">table</span>-&gt;</span>count++;</span><br></pre></td></tr></table></figure><p>上面的代码使用 <code>bcopy</code> 将原链表中元素拷贝到新的数组 <code>newt</code> 中。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-insert-many.gif.gif" alt="objc-hashtable-insert-many.gif"></p><p>在每次添加完一个元素之后，都会进行下面的判断：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">table</span>-&gt;<span class="keyword">count</span> &gt; <span class="keyword">table</span>-&gt;nbBuckets) _NXHashRehash (<span class="keyword">table</span>);</span><br></pre></td></tr></table></figure><blockquote><p>上面的这行代码会保证<strong>哈希表中的元素数据小于等于表中的 bucket 数量</strong>。</p></blockquote><p>这就是 <code>buckets</code> 后面的列表非常短的原因，在理想情况下，<strong>每一个 <code>buckets</code> 中都只存储一个或零个元素</strong>。</p><h4 id="NXHashRehash"><a href="#NXHashRehash" class="headerlink" title="_NXHashRehash"></a>_NXHashRehash</h4><p>如果哈希表在添加元素后，其中的数据多于 <code>buckets</code> 数量，就会对 <code>NXHashTable</code> 进行 <code>_NXHashRehash</code> 操作。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static void _NXHashRehash (NXHashTable *<span class="keyword">table</span>) &#123;</span><br><span class="line">    _NXHashRehashToCapacity (<span class="keyword">table</span>, MORE_CAPACITY(<span class="keyword">table</span>-&gt;nbBuckets));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它调用 <code>_NXHashRehashToCapacity</code> 方法来扩大 <code>NXHashTable</code> 的容量（<code>HashBucket</code> 的个数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MORE_CAPACITY(b) (b*2+1)</span></span><br></pre></td></tr></table></figure><p>而 <code>MORE_CAPACITY</code> 会将当前哈希表的容量翻倍，并将新的容量传入 <code>_NXHashRehashToCapacity</code> 中：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void _NXHashRehashToCapacity (NXHashTable *table, unsigned newCapacity) &#123;</span><br><span class="line">    NXHashTable*old;</span><br><span class="line">    NXHashStatestate;</span><br><span class="line">    void*aux;</span><br><span class="line">    __unused void *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    old = ALLOCTABLE(z);</span><br><span class="line">    <span class="function"><span class="title">old</span>-&gt;</span><span class="function"><span class="title">prototype</span> = table-&gt;</span><span class="function"><span class="title">prototype</span>; old-&gt;</span><span class="function"><span class="title">count</span> = table-&gt;</span>count;</span><br><span class="line">    <span class="function"><span class="title">old</span>-&gt;</span><span class="function"><span class="title">nbBuckets</span> = table-&gt;</span><span class="function"><span class="title">nbBuckets</span>; old-&gt;</span><span class="function"><span class="title">buckets</span> = table-&gt;</span>buckets;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span>nbBuckets = newCapacity;</span><br><span class="line">    <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span> = 0; table-&gt;</span><span class="function"><span class="title">buckets</span> = ALLOCBUCKETS(z, table-&gt;</span>nbBuckets);</span><br><span class="line">    state = NXInitHashState (old);</span><br><span class="line">    <span class="keyword">while</span> (NXNextHashState (old, &amp;state, &amp;aux))</span><br><span class="line">        (void) NXHashInsert (table, aux);</span><br><span class="line">    freeBuckets (old, NO);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">free</span> (old-&gt;</span>buckets);</span><br><span class="line">    free (old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>创建一个 <code>NXHashTable</code> 的指针指向原哈希表</li><li>改变哈希表的 <code>nbBuckets</code>，并重新初始化哈希表的 <code>buckets</code> 数组</li><li>重新将元素插入到哈希表中</li><li>释放原哈希表 <code>old</code> 以及 <code>buckets</code></li></ol><h4 id="NXHashState"><a href="#NXHashState" class="headerlink" title="NXHashState"></a>NXHashState</h4><p>在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 <code>NXHashState</code>，这个结构体主要作用是遍历 <code>NXHashTable</code> 中的元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125; NXHashState;</span><br></pre></td></tr></table></figure><p>我们可以使用如下的代码对哈希表中的元素进行遍历：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unsigned count = <span class="number">0</span>;</span><br><span class="line">MyData *data;</span><br><span class="line">NXHashState <span class="keyword">state</span> = NXInitHashState(<span class="built_in">table</span>);</span><br><span class="line">while (NXNextHashState(<span class="built_in">table</span>, &amp;<span class="keyword">state</span>, &amp;data)) &#123;</span><br><span class="line">   count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码片段中调用了两个方法，分别是 <code>NXInitHashState</code> 以及 <code>NXNextHashState</code>：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NXHashState NXInitHashState (NXHashTable *<span class="built_in">table</span>) &#123;</span><br><span class="line">    NXHashState<span class="keyword">state</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">state</span>.i = table-&gt;nbBuckets;</span><br><span class="line">    <span class="keyword">state</span>.j = <span class="number">0</span>;</span><br><span class="line">    return <span class="keyword">state</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>NXInitHashState</code> 会将 <code>NXHashState</code> 指向哈希表的最末端：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-hash-state-init.png" alt="objc-hashtable-hash-state-init"></p><blockquote><p>这个位置其实并不属于 <code>NXHashTable</code>，它一定会为空。</p></blockquote><p>而每次调用 <code>NXNextHashState</code> 都会向『前』移动一次：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int NXNextHashState (NXHashTable *table, NXHashState *state, void **<span class="keyword">data</span>) &#123;</span><br><span class="line">    H<span class="function"><span class="title">ashBucket</span>*buckets = (HashBucket *) table-&gt;</span>buckets;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">while</span> (state-&gt;</span>j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (state-&gt;</span>i == <span class="number">0</span>) return NO;</span><br><span class="line">        <span class="function"><span class="title">state</span>-&gt;</span><span class="function"><span class="title">i</span>--; state-&gt;</span><span class="function"><span class="title">j</span> = buckets[state-&gt;</span>i].count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">state</span>-&gt;</span>j--;</span><br><span class="line">    <span class="function"><span class="title">buckets</span> += state-&gt;</span>i;</span><br><span class="line">    *<span class="function"><span class="title">data</span> = (void *) ((buckets-&gt;</span>count == <span class="number">1</span>)</span><br><span class="line">                      ? <span class="function"><span class="title">buckets</span>-&gt;</span><span class="function"><span class="title">elements</span>.one : buckets-&gt;</span><span class="function"><span class="title">elements</span>.many[state-&gt;</span>j]);</span><br><span class="line">    return YES;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的 gif 为我们展示了每一次调用 <code>NXNextHashState</code> 方法之后当前的 <code>NXHashState</code>：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-hashstate-next.gif" alt="objc-hashtable-hashstate-next"></p><h3 id="NXHashRemove"><a href="#NXHashRemove" class="headerlink" title="NXHashRemove"></a>NXHashRemove</h3><p>这里的 <code>NXHashRemove</code>在某种意义上是 <code>NXHashInsert</code> 的逆操作：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void *NXHashRemove (NXHashTable *table, const void *<span class="keyword">data</span>) &#123;</span><br><span class="line">    HashBucket*bucket = BUCKETOF(table, <span class="keyword">data</span>);</span><br><span class="line">    <span class="function"><span class="title">unsigned</span>j = bucket-&gt;</span>count;</span><br><span class="line">    const void**pairs;</span><br><span class="line">    const void**newt;</span><br><span class="line">    __unused void *z = ZONE_FROM_PTR(table);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! j) return NULL;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function"><span class="title">if</span> (! ISEQUAL(table, <span class="keyword">data</span>, bucket-&gt;</span>elements.one)) return NULL;</span><br><span class="line">        <span class="function"><span class="title">data</span> = bucket-&gt;</span>elements.one;</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>elements.one = NULL;</span><br><span class="line">        return (void *) <span class="keyword">data</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="title">pairs</span> = bucket-&gt;</span>elements.many;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, pairs[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = pairs[<span class="number">1</span>]; <span class="keyword">data</span> = pairs[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, pairs[<span class="number">1</span>])) &#123;</span><br><span class="line">            <span class="function"><span class="title">bucket</span>-&gt;</span>elements.one = pairs[<span class="number">0</span>]; <span class="keyword">data</span> = pairs[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> return NULL;</span><br><span class="line">        FREEPAIRS (pairs);</span><br><span class="line">        <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>count--;</span><br><span class="line">        return (void *) <span class="keyword">data</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ISEQUAL(table, <span class="keyword">data</span>, *pairs)) &#123;</span><br><span class="line">            <span class="keyword">data</span> = *pairs;</span><br><span class="line">            <span class="comment">/* we shrink this bucket */</span></span><br><span class="line">            <span class="function"><span class="title">newt</span> = (bucket-&gt;</span>count-<span class="number">1</span>)</span><br><span class="line">            ? ALLOCPAIRS(<span class="function"><span class="title">z</span>, bucket-&gt;</span>count-<span class="number">1</span>) : NULL;</span><br><span class="line">            <span class="function"><span class="title">if</span> (bucket-&gt;</span>count-<span class="number">1</span> != j)</span><br><span class="line">                <span class="function"><span class="title">bcopy</span> ((const char*)bucket-&gt;</span><span class="function"><span class="title">elements</span>.many, (char*)newt, PTRSIZE*(bucket-&gt;</span>count-j-<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (j)</span><br><span class="line">                <span class="function"><span class="title">bcopy</span> ((const char*)(bucket-&gt;</span><span class="function"><span class="title">elements</span>.many + bucket-&gt;</span><span class="function"><span class="title">count</span>-j), (char*)(newt+bucket-&gt;</span>count-j-<span class="number">1</span>), PTRSIZE*j);</span><br><span class="line">            FREEPAIRS (<span class="function"><span class="title">bucket</span>-&gt;</span>elements.many);</span><br><span class="line">            <span class="function"><span class="title">table</span>-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span><span class="function"><span class="title">count</span>--; bucket-&gt;</span>elements.many = newt;</span><br><span class="line">            return (void *) <span class="keyword">data</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        pairs ++;</span><br><span class="line">    &#125;;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现也分为三种情况，不过在这里就不多说了。</p><h2 id="NXHashTable-的性能"><a href="#NXHashTable-的性能" class="headerlink" title="NXHashTable 的性能"></a>NXHashTable 的性能</h2><p>在已经熟悉了 <code>NXHashTable</code> 的具体实现之后，我们要分析插入<strong>不同数据量级</strong>的情况下，所需要的时间，这里是主程序的代码，分别测试了在 <code>100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000</code> 数据下 <code>NXHashTable</code> 的性能表现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"hashtable2.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *capacities = @[</span><br><span class="line">            @<span class="number">100</span>,</span><br><span class="line">            @<span class="number">1000</span>,</span><br><span class="line">            @<span class="number">10000</span>,</span><br><span class="line">            @<span class="number">100000</span>,</span><br><span class="line">            @<span class="number">1000000</span>,</span><br><span class="line">            @<span class="number">2000000</span>,</span><br><span class="line">            @<span class="number">3000000</span>,</span><br><span class="line">            @<span class="number">5000000</span>,</span><br><span class="line">            @<span class="number">10000000</span></span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *capacity <span class="keyword">in</span> capacities) &#123;</span><br><span class="line">            NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">NSDate</span> *methodStart = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; capacity.integerValue; i++) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%ld"</span>, (<span class="keyword">long</span>)i];</span><br><span class="line">                NXHashInsert(hashTable, (__bridge <span class="keyword">void</span> *)value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSDate</span> *methodFinish = [<span class="built_in">NSDate</span> date];</span><br><span class="line">            <span class="built_in">NSTimeInterval</span> executionTime = [methodFinish timeIntervalSinceDate:methodStart];</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Capacities: %@, executionTime = %f, meanTime = %.10f"</span>, capacity, executionTime, executionTime / capacity.integerValue);</span><br><span class="line"></span><br><span class="line">            free(hashTable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中初始化了一个 <code>capacities</code> 存储需要测量的数据量级，然后调用 <code>NXHashInsert</code> 方法将相当数量级的数据添加到哈希表中：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000334</td><td style="text-align:right">0.0000033402</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.001962</td><td style="text-align:right">0.0000019619</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.022001</td><td style="text-align:right">0.0000022001</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.349998</td><td style="text-align:right">0.0000035000</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">2.622551</td><td style="text-align:right">0.0000026226</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">4.165023</td><td style="text-align:right">0.0000020825</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">6.973098</td><td style="text-align:right">0.0000023244</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">13.179743</td><td style="text-align:right">0.0000026359</td></tr><tr><td style="text-align:right"><strong>10000000</strong></td><td style="text-align:right"><strong>53.387356</strong></td><td style="text-align:right"><strong>0.0000053387</strong></td></tr></tbody></table><p>在对 <code>NXHashTable</code> 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。</p><p>如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是<strong>在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的</strong>。</p><p>如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">NXHashTable *<span class="title">NXCreateHashTable</span> <span class="params">(NXHashTablePrototype prototype, <span class="keyword">unsigned</span> capacity, <span class="keyword">const</span> <span class="keyword">void</span> *info)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数的签名中包含一个 <code>capacity</code> 的参数，我们在上面的代码中传入了 0，也就是最开始的 <code>buckets</code> 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。</p><blockquote><p><code>capacity</code> 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。</p></blockquote><p>如果在创建 <code>NXHashTable</code> 时传入 <code>capacity.integerValue</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">NXHashTable</span> <span class="meta">*hashTable</span> <span class="string">=</span> <span class="string">NXCreateHashTable(NXPtrPrototype,</span> <span class="string">capacity.integerValue,</span> <span class="literal">NULL</span><span class="string">);</span></span><br></pre></td></tr></table></figure><p>重新运行代码，测量性能：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000740</td><td style="text-align:right">0.0000073999</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.003442</td><td style="text-align:right">0.0000034420</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.023341</td><td style="text-align:right">0.0000023341</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.215209</td><td style="text-align:right">0.0000021521</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.836802</td><td style="text-align:right">0.0000018368</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">3.683246</td><td style="text-align:right">0.0000018416</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">5.474610</td><td style="text-align:right">0.0000018249</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">10.576254</td><td style="text-align:right">0.0000021153</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">46.725459</td><td style="text-align:right">0.0000046725</td></tr></tbody></table><p>虽然在测试 <code>10,000,000</code> 数据时其平均时间依然是 <code>5,000,000</code> 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。</p><p>如果我们使用 Instrument 对有无 <code>capacity</code> 的情况进行比较（这是在使用 <code>2,000,000</code> 数据时进行的测试）：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-instrument.png" alt="objc-hashtable-instrument"></p><p>没有传入 <code>capacity</code> 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 <code>capacity</code> 的哈希表会在代码刚运行时就初始化足够大的数组。</p><h2 id="NSMutableArray-性能"><a href="#NSMutableArray-性能" class="headerlink" title="NSMutableArray 性能"></a>NSMutableArray 性能</h2><blockquote><p>这部分只算是一个小插曲，你可以选择跳过这一小节的内容。</p></blockquote><p><code>NSMutableArray</code> 的构造器 <code>- (instancetype)initWithCapacity:(NSUInteger)numItems</code> 也有一个参数 <code>capacity</code>，虽然数组和哈希表是两种数据结构。</p><blockquote><p>不过我们这里主要研究的是：<strong>传入 <code>capacity</code> 是否会对性能造成影响</strong>。</p></blockquote><p>首先是使用 <code>init</code> 创建的 <code>NSMutableArray</code> 数组，也就是没有传入 <code>capacity</code>：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000539</td><td style="text-align:right">0.0000053900</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.003185</td><td style="text-align:right">0.0000031850</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.074033</td><td style="text-align:right">0.0000074033</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.370899</td><td style="text-align:right">0.0000037090</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.504855</td><td style="text-align:right">0.0000015049</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">2.852519</td><td style="text-align:right">0.0000014263</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">3.995536</td><td style="text-align:right">0.0000013318</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">6.833879</td><td style="text-align:right">0.0000013668</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">14.444605</td><td style="text-align:right">0.0000014445</td></tr></tbody></table><p>下面是使用 <code>initWithCapacity:</code> 创建的数组：</p><table><thead><tr><th style="text-align:right">Capacities</th><th style="text-align:right">Execution Time</th><th style="text-align:right">Mean Time</th></tr></thead><tbody><tr><td style="text-align:right">100</td><td style="text-align:right">0.000256</td><td style="text-align:right">0.0000025600</td></tr><tr><td style="text-align:right">1000</td><td style="text-align:right">0.001775</td><td style="text-align:right">0.0000017750</td></tr><tr><td style="text-align:right">10000</td><td style="text-align:right">0.015906</td><td style="text-align:right">0.0000015906</td></tr><tr><td style="text-align:right">100000</td><td style="text-align:right">0.174376</td><td style="text-align:right">0.0000017438</td></tr><tr><td style="text-align:right">1000000</td><td style="text-align:right">1.650481</td><td style="text-align:right">0.0000016505</td></tr><tr><td style="text-align:right">2000000</td><td style="text-align:right">2.802310</td><td style="text-align:right">0.0000014012</td></tr><tr><td style="text-align:right">3000000</td><td style="text-align:right">4.451261</td><td style="text-align:right">0.0000014838</td></tr><tr><td style="text-align:right">5000000</td><td style="text-align:right">7.093753</td><td style="text-align:right">0.0000014188</td></tr><tr><td style="text-align:right">10000000</td><td style="text-align:right">14.598415</td><td style="text-align:right">0.0000014598</td></tr></tbody></table><p>你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。</p><p>但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 <code>capacity</code> 的 <code>NSMutableArray</code> 会在可变数组内存占用增加前出现一个<strong>短暂的内存分配峰值</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-nsarray-instrument.png" alt="objc-hashtable-nsarray-instrument"></p><p>导致这一现象的原始可能是：在将原数组中的内容移入新数组时，<strong>临时变量申请了大量的内存空间</strong>。</p><blockquote><p>在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。</p></blockquote><h2 id="NXHashTable-的应用"><a href="#NXHashTable-的应用" class="headerlink" title="NXHashTable 的应用"></a>NXHashTable 的应用</h2><p>在整个 objc/runtime 中，作为<strong>私有</strong>的数据结构 <code>NXHashTable</code>，直接使用了它的就是<strong>存储所有类或者元类</strong>的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> NXHashTable *realized_class_hash = <span class="keyword">nil</span>;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>objc_copyClassList</code> 获取类的数组：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Class *</span><br><span class="line">objc_copyClassList(unsigned int *outCount)</span><br><span class="line">&#123;</span><br><span class="line">    rwlock_writer_t lock(runtimeLock)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    realizeAllClasses()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Class *result = nil<span class="comment">;</span></span><br><span class="line">    NXHashTable *classes = realizedClasses()<span class="comment">;</span></span><br><span class="line">    unsigned int <span class="built_in">count</span> = NXCountHashTable(classes)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    if (<span class="built_in">count</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Class cls<span class="comment">;</span></span><br><span class="line">        NXHashState state = NXInitHashState(classes)<span class="comment">;</span></span><br><span class="line">        result = (Class *)malloc((<span class="number">1</span>+<span class="built_in">count</span>) * sizeof(Class))<span class="comment">;</span></span><br><span class="line">        <span class="built_in">count</span> = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">        while (NXNextHashState(classes, &amp;state, (void **)&amp;cls)) &#123;</span><br><span class="line">            result[<span class="built_in">count</span>++] = cls<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="built_in">count</span>] = nil<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    if (outCount) *outCount = <span class="built_in">count</span><span class="comment">;</span></span><br><span class="line">    return result<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 <code>realizedClasses</code> 返回 <code>realized_class_hash</code> 哈希表</li><li>使用 <code>NSHashState</code> 遍历 <code>realized_class_hash</code> 中的类，并将所有的类存入 <code>result</code></li></ol><p>接下来使用上面的方法，打印出 <code>realized_class_hash</code> 中存储的所有类：</p><p><img src="/wiki/IOS/Runtime/objc/6_NXHashTable/objc-hashtable-copy-class-list.png" alt="objc-hashtable-copy-class-list"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p><code>NXHashTable</code> 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。</p></blockquote><p><code>NXHashTable</code> 可以说有着<strong>非常非常</strong>久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hashtable2.mm 文件中</span></span><br><span class="line"></span><br><span class="line">hashtable2.m</span><br><span class="line">Copyright <span class="number">1989</span><span class="number">-1996</span> NeXT Software, Inc.</span><br><span class="line">Created by Bertrand Serlet, Feb <span class="number">89</span></span><br></pre></td></tr></table></figure><p><code>NSHashTable</code> 对哈希表的实现还是非常优雅的，可以说非常标准的使用了<a href="https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists" rel="external nofollow noopener noreferrer" target="_blank">拉链法</a>实现哈希表。</p><p>不过现在，我们会使用 <code>NSHashTable</code> 来取代这个上古时代的产物。</p><blockquote><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">Draveness · Github</a></p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 &lt;code&gt;x86_64&lt;/code&gt; 架构下运行的，对于在 arm64 中运行的代码会特别说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章会介绍上古时代 Objective-C 哈希表，也就是 &lt;code&gt;NXHashTable&lt;/code&gt; ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的性能分析&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;NXHashTable&lt;/code&gt; 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中会涉及一些数据结构方面的简单知识，例如&lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_table#Separate_chaining_with_linked_lists&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;拉链法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;文章中分析的不是 &lt;code&gt;NSHashTable&lt;/code&gt; 而是 &lt;code&gt;NXHashTable&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>5. list_array_tt 结构详解</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/5list_array_tt/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/5list_array_tt/</id>
    <published>2018-11-20T02:38:11.000Z</published>
    <updated>2018-11-21T11:17:50.320Z</updated>
    
    <content type="html"><![CDATA[<p>list_array_tt 是个模板类，可以实例化出method_array_t，method_array_t在class_rw_t中使用，存储多个分类中的方法列表。</p><a id="more"></a><h2 id="list-array-tt-总的源码和类图"><a href="#list-array-tt-总的源码和类图" class="headerlink" title="list_array_tt 总的源码和类图"></a>list_array_tt 总的源码和类图</h2><p>下面是list_array_tt的源码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment"> Element 是元数据类型，比如 method_t</span></span><br><span class="line"><span class="comment"> List 是元数据的列表类型，比如 method_list_t</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 一个 list_array_tt 的值可能有三种情况：</span></span><br><span class="line"><span class="comment"> - 空的</span></span><br><span class="line"><span class="comment"> - 一个指针指向一个单独的列表</span></span><br><span class="line"><span class="comment"> - 一个数组，数组中都是指针，每个指针分别指向一个列表</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">* countLists/beginLists/endLists iterate the metadata lists</span></span><br><span class="line"><span class="comment">* count/begin/end iterate the underlying metadata elements</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list_array_tt</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">array_t</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> count;   <span class="comment">/// 有多少个List*</span></span><br><span class="line">        List* lists[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> size_t <span class="title">byteSize</span><span class="params">(<span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">array_t</span>) + count*<span class="keyword">sizeof</span>(lists[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">size_t</span> byteSize() &#123;</span><br><span class="line">            <span class="keyword">return</span> byteSize(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        List **lists;</span><br><span class="line">        List **listsEnd;</span><br><span class="line">        <span class="keyword">typename</span> List::iterator m, mEnd;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">        iterator(List **begin, List **end) </span><br><span class="line">            : lists(begin), listsEnd(end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin != end) &#123;</span><br><span class="line">                m = (*begin)-&gt;begin();</span><br><span class="line">                mEnd = (*begin)-&gt;end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Element&amp; <span class="keyword">operator</span> * () <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> *m;</span><br><span class="line">        &#125;</span><br><span class="line">        Element&amp; <span class="keyword">operator</span> * () &#123;</span><br><span class="line">            <span class="keyword">return</span> *m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> iterator&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists != rhs.lists) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (lists == listsEnd) <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// m is undefined</span></span><br><span class="line">            <span class="keyword">if</span> (m != rhs.m) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> ++ () &#123;</span><br><span class="line">            assert(m != mEnd);</span><br><span class="line">            m++;</span><br><span class="line">            <span class="keyword">if</span> (m == mEnd) &#123;</span><br><span class="line">                assert(lists != listsEnd);</span><br><span class="line">                lists++;</span><br><span class="line">                <span class="keyword">if</span> (lists != listsEnd) &#123;</span><br><span class="line">                    m = (*lists)-&gt;begin();</span><br><span class="line">                    mEnd = (*lists)-&gt;end();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        List* <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> arrayAndFlag;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasArray</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arrayAndFlag &amp; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">array_t</span> *<span class="built_in">array</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">array_t</span> *)(arrayAndFlag &amp; ~<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">array_t</span> *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        arrayAndFlag = (<span class="keyword">uintptr_t</span>)<span class="built_in">array</span> | <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 所有的list的所有元素总数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> count() &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> lists = beginLists(), end = endLists(); </span><br><span class="line">             lists != end;</span><br><span class="line">             ++lists)</span><br><span class="line">        &#123;</span><br><span class="line">            result += (*lists)-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iterator(beginLists(), endLists());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List **e = endLists();</span><br><span class="line">        <span class="keyword">return</span> iterator(e, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> countLists() &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List** <span class="title">beginLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;lists;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List** <span class="title">endLists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;lists + <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span> + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &amp;<span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                    oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">            <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">            List* oldList = <span class="built_in">list</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">            setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">            <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">            <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">                   addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tryFree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>()-&gt;count; i++) &#123;</span><br><span class="line">                try_free(<span class="built_in">array</span>()-&gt;lists[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            try_free(<span class="built_in">array</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            try_free(<span class="built_in">list</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Result&gt;</span><br><span class="line">    <span class="function">Result <span class="title">duplicate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">            <span class="keyword">array_t</span> *a = <span class="built_in">array</span>();</span><br><span class="line">            result.setArray((<span class="keyword">array_t</span> *)memdup(a, a-&gt;byteSize()));</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; a-&gt;count; i++) &#123;</span><br><span class="line">                result.<span class="built_in">array</span>()-&gt;lists[i] = a-&gt;lists[i]-&gt;duplicate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">            result.<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;duplicate();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.<span class="built_in">list</span> = nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/arraylist_t_class.png" alt="list_array_tt 类结构图"></p><p>由图可以看出，list_array_tt结构的成员是一个匿名的union，或者存储单个类型为List*的list,或者存储多个列表，多个list使用arrayAndFlag表示，arrayAndFlag是个符合结构，低1位存储标志，高63位存储多个列表的地址，低位为1，表示多个列表，为0表示一个列表。</p><p>arrayAndFlag 高位存储一个地址，指向的类型是array_t，array_t有两个成员，第一个count表示列表的个数，lists存储List*类型的指针数组。 </p><h2 id="list-array-tt-部分源码分析"><a href="#list-array-tt-部分源码分析" class="headerlink" title="list_array_tt 部分源码分析"></a>list_array_tt 部分源码分析</h2><p>下面看最基本的三个方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasArray</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arrayAndFlag &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">array_t</span> *<span class="built_in">array</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">array_t</span> *)(arrayAndFlag &amp; ~<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setArray</span><span class="params">(<span class="keyword">array_t</span> *<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    arrayAndFlag = (<span class="keyword">uintptr_t</span>)<span class="built_in">array</span> | <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasArray 判断存储的是一个列表，还是多个列表。</p><p>array返回多个列表的地址，返回类型是<code>array_t *</code></p><p>setArray设置多个列表。将多个列表的地址和1与操作，存储在arrayAndFlag中。</p><p>下面首先看beginLists、endLists方法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">List</span>** beginLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>()-&gt;lists;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">List</span>** endLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">array</span>()-&gt;lists + <span class="keyword">array</span>()-&gt;count;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span> + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;<span class="keyword">list</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>beginLists 返回列表的首元素的地址，endLists返回列表尾后元素的地址。为了方便理解，画了下图：</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/begainlist_endlist.png" alt="begainlist、endlist方法结果示意图">  </p><p>图中需要注意命名规则，list表示单个列表，lists表示多个列表。</p><p>如上图所示，当list_array_tt存储一个<code>List*</code>时，beginLists返回list的地址、当list_array_tt存储多个<code>List*</code>时，beginLists返回lists的地址，返回类型是<code>List**</code>。 </p><p>同理，当list_array_tt存储一个<code>List*</code>时，endLists返回list尾后地址、当list_array_tt存储多个<code>List*</code>时，endLists返回lists的尾后地址，就是最后一个List<em>的末尾。返回类型是`List*</em>`</p><p>图中红色的线表示beginLists、endLists指向的地址。</p><p>下面在来看countLists方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> countLists() &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>countLists返回<code>List*</code>的个数，如果是单个列表，返回1，多个列表返回array()-&gt;count。</p><p>下面看最关键的函数attachLists，这个函数个将分类的方法列表添加到原始类的方法列表上面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachLists</span><span class="params">(List* <span class="keyword">const</span> * addedLists, <span class="keyword">uint32_t</span> addedCount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (addedCount == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasArray()) &#123;</span><br><span class="line">        <span class="comment">// many lists -&gt; many lists</span></span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = <span class="built_in">array</span>()-&gt;count;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>(), <span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        memmove(<span class="built_in">array</span>()-&gt;lists + addedCount, <span class="built_in">array</span>()-&gt;lists, </span><br><span class="line">                oldCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">list</span>  &amp;&amp;  addedCount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 0 lists -&gt; 1 list</span></span><br><span class="line">        <span class="built_in">list</span> = addedLists[<span class="number">0</span>];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 1 list -&gt; many lists</span></span><br><span class="line">        List* oldList = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> oldCount = oldList ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">uint32_t</span> newCount = oldCount + addedCount;</span><br><span class="line">        setArray((<span class="keyword">array_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">array_t</span>::byteSize(newCount)));</span><br><span class="line">        <span class="built_in">array</span>()-&gt;count = newCount;</span><br><span class="line">        <span class="keyword">if</span> (oldList) <span class="built_in">array</span>()-&gt;lists[addedCount] = oldList;</span><br><span class="line">        <span class="built_in">memcpy</span>(<span class="built_in">array</span>()-&gt;lists, addedLists, </span><br><span class="line">               addedCount * <span class="keyword">sizeof</span>(<span class="built_in">array</span>()-&gt;lists[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数分为三部分，分别处理：</p><ol><li>多个列表添加新的列表</li><li>单个列表添加新的列表</li><li>空列表添加新的列表</li></ol><p>多个列表时： 首先计算所有列表的总数，申请大的空间，将原有列表和新addedLists添加到新的空间中。</p><p><code>else if</code>是处理在空列表中添加一个新元素的列表addedLists。</p><p><code>else</code> 分支处理在空列表中添加多个元素的列表、或者在原来一个元素的列表(list)中添加新列表addedLists，添加的结果列表中存储多个列表。所以一起处理。处理的流程和第一个分支类似。</p><p>下面是部分在原有5个元素的列中中添加两个元素的列表addedLists的示意图。</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/attachLists.png" alt="attachLists添加2个元素的示意图">  </p><h2 id="list-array-tt-迭代器"><a href="#list-array-tt-迭代器" class="headerlink" title="list_array_tt 迭代器"></a>list_array_tt 迭代器</h2><p>下面看begin、end方法：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">iterator</span> begin() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">iterator</span>(beginLists(), endLists());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">iterator</span> <span class="keyword">end</span>() &#123;</span><br><span class="line">    <span class="type">List</span> **e = endLists();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">iterator</span>(e, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>begin、end方法返回list_array_tt的首元素迭代器和尾后元素迭代器。</p><p>迭代器有四个元素：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> **lists;</span><br><span class="line"><span class="built_in">List</span> **listsEnd;</span><br><span class="line">typename <span class="built_in">List</span><span class="type">::iterator</span> m, mEnd;</span><br></pre></td></tr></table></figure><p>首迭代器四个成员指向的位置如图所示：</p><p><img src="/wiki/IOS/Runtime/objc/5list_array_tt/arraylist_tt_iterator.png" alt="迭代器示意图">  </p><p>根据上图可以容易的理解迭代器的各个成员的指向。那么迭代器重要的操作++就比较容易理解了。代码如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator&amp; operator ++ () &#123;</span><br><span class="line">    assert(m != mEnd);</span><br><span class="line">    m++;</span><br><span class="line">    <span class="keyword">if</span> (m == mEnd) &#123;</span><br><span class="line">        assert(lists != listsEnd);</span><br><span class="line">        lists++;</span><br><span class="line">        <span class="keyword">if</span> (lists != listsEnd) &#123;</span><br><span class="line">            <span class="function"><span class="title">m</span> = <span class="params">(*lists)</span>-&gt;</span>begin();</span><br><span class="line">            <span class="function"><span class="title">mEnd</span> = <span class="params">(*lists)</span>-&gt;</span>end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在是类别的元素的（method_t）的迭代器指向++操作，即m执行++，如果元素的迭代器迭代完成，即，m==mEnd,退出到外部，指向lists的++操作,然后在继续内部元素的迭代器操作。以此类推。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;list_array_tt 是个模板类，可以实例化出method_array_t，method_array_t在class_rw_t中使用，存储多个分类中的方法列表。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>4. 方法列表entsize_list_tt结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/4entsize_list_tt/</id>
    <published>2018-11-03T02:38:11.000Z</published>
    <updated>2018-11-21T07:07:58.184Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中</p><a id="more"></a><h2 id="entsize-list-tt-简单介绍"><a href="#entsize-list-tt-简单介绍" class="headerlink" title="entsize_list_tt 简单介绍"></a>entsize_list_tt 简单介绍</h2><p>类的编译后的数据存储在class_ro_t结构中，其中各种方法列表、变量列表、属性列表的类型分别是method_list_t、ivar_list_t、property_list_t，这些类型全部继承于entsize_list_tt。class_ro_t的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RO 就是 Read Only</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;  <span class="comment">// 基本方法列表，存储编译期确定的方法</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;       <span class="comment">// 类的成员变量列表，存储编译期确定的成员变量</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties; <span class="comment">// 基本属性列表，存储编译期确定的属性</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>method_list_t 继承于entsize_list_tt 的源码如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, <span class="number">0x3</span>&gt; &#123; // <span class="number">0x3</span> 就是 <span class="number">0b11</span></span><br><span class="line">                                                                       // 即 flag 占 <span class="number">2</span> 个 bit，用来放 fixedup markers</span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面就开始学习entsize_list_tt数据结构。</p><h2 id="entsize-list-tt-详细分析"><a href="#entsize-list-tt-详细分析" class="headerlink" title="entsize_list_tt 详细分析"></a>entsize_list_tt 详细分析</h2><p>entsize_list_tt其实就是一个列表，用来存储编译完成后类的属性。由于位于class_ro_t结构中，所以这个结构是只读的，没有写方法，只有访问的相关方法，定义如下，只包含了部分代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entsize_list_tt 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。</span></span><br><span class="line"><span class="comment">// Element 表示元素类型，List 用于指定容器类型，</span></span><br><span class="line"><span class="comment">// 最后一个参数为标记位, 用来在 entsize field 里存放一些额外的 bits，也就是 flags</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Element, <span class="keyword">typename</span> List, <span class="keyword">uint32_t</span> FlagMask&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">entsize_list_tt</span> &#123;</span></span><br><span class="line">    <span class="comment">// entsize 和 flags 存在了一起，需要用 FlagMask 进行区分哪些 bits 里存的是 flags</span></span><br><span class="line">    <span class="comment">// entsize 就是每个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsizeAndFlags;</span><br><span class="line">    <span class="keyword">uint32_t</span> count; <span class="comment">// 元素的总数</span></span><br><span class="line">    Element first;  <span class="comment">// 第一个元素，其他的元素紧跟在其后面</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出 entsize 单个元素的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> entsize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; ~FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出 flags</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> entsizeAndFlags &amp; FlagMask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素，i &lt;= count</span></span><br><span class="line">    <span class="comment">// 如果 i 等于 count，取得的就是最后一个元素的末尾地址</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">getOrEnd</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt;= count);</span><br><span class="line">        <span class="comment">// 从第一个元素开始，加上偏移量 i * 单个元素的大小</span></span><br><span class="line">        <span class="comment">// 就是 i 索引处的元素</span></span><br><span class="line">        <span class="keyword">return</span> *(Element *)((<span class="keyword">uint8_t</span> *)&amp;first + i*entsize()); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指定 索引 处的元素</span></span><br><span class="line">    <span class="comment">// i 必须小于总数</span></span><br><span class="line">    <span class="function">Element&amp; <span class="title">get</span><span class="params">(<span class="keyword">uint32_t</span> i)</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">        assert(i &lt; count);</span><br><span class="line">        <span class="keyword">return</span> getOrEnd(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取得整个 entsize_list_tt 对象以及其保存的所有元素占多少内存</span></span><br><span class="line">    <span class="keyword">size_t</span> byteSize() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="comment">// sizeof(*this) 计算是对象本身占的大小，其中还包括了第一个元素</span></span><br><span class="line">        <span class="comment">// (count-1)*entsize() 计算的是除了第一个元素外，其他所有元素占的大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(*<span class="keyword">this</span>) + (count<span class="number">-1</span>)*entsize();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span>;</span></span><br><span class="line">    <span class="comment">// 取得指向容器的第一个元素的迭代器，返回值是变量，可以变</span></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), <span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取得指向容器尾部的迭代器，注意是尾部，也就是最后一个元素的末尾，并不是最后的一个元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> iterator(*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> List*&gt;(<span class="keyword">this</span>), count); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向前声明</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">        Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line">        <span class="comment">// start 是当前的索引</span></span><br><span class="line">        iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">            : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">            , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">            , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">        &#123; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器向后移动 delta 个位置</span></span><br><span class="line">        <span class="keyword">const</span> iterator&amp; <span class="keyword">operator</span> += (<span class="keyword">ptrdiff_t</span> delta) &#123;</span><br><span class="line">            <span class="comment">// 计算出新元素的地址，保存起来</span></span><br><span class="line">            element = (Element*)((<span class="keyword">uint8_t</span> *)element + delta*entsize);</span><br><span class="line">            <span class="comment">// 索引也加上 delta</span></span><br><span class="line">            index += (<span class="keyword">int32_t</span>)delta;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ....   </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>entsize_list_tt 是个模板，可以实例化出method_list_t、ivar_list_t、property_list_t三种类型。有三个数据成员，entsizeAndFlags 是个复合成员，高位表示元素的大小，低位是个标志位，entsize、Flags具体占用多少位，根据模板参数FlagMask决定。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x3 就是 0b11,即 flag 占 2 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">method_t</span>, <span class="keyword">method_list_t</span>, <span class="number">0x3</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">ivar_t</span>, <span class="keyword">ivar_list_t</span>, <span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// flag 占 0 个 bit</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> :</span> entsize_list_tt&lt;<span class="keyword">property_t</span>, <span class="keyword">property_list_t</span>, <span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure><p>method_list_t 实例化时，递给FlagMask的模板实参是0x3，转化为二进制为0b11，占用两位。那么在method_list_t结构中，entsizeAndFlags 表示的entsize占用30位，Flags占用2位。</p><p>count 表示列表中存储元素的个数，first 表示首元素。注意他不是个指针，只是一个首元素，后面的元素会挨着first顺序存储。</p><p>method_list_t 的方法基本都是访问属性的。慢慢看着注释应该嫩看懂。</p><p>类图以方法列表method_list_t为例，里面存储的元素是method_t类型：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt类图.png" alt="entisize_list_tt类图"></p><h2 id="entisize-list-tt-内存布局"><a href="#entisize-list-tt-内存布局" class="headerlink" title="entisize_list_tt 内存布局"></a>entisize_list_tt 内存布局</h2><p>为了进一步理解这个结构，我用hopper抓了一个这样的结构，如图所示，</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_hopper.png" alt="entisize_list_tt 实例数据"></p><p>我们将这个数据放入内存，内存结构大致如下：</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_memory.png" alt="entisize_list_tt 内存布局"></p><p>entsizeAndFlags 的值是0x18，转化为二进制，为0b1,1000，那么entsize的值去高20位，还是0b1,1000，十进制为24表示元素的大小是24，然后继续看元素，元素的类型是method_t，大小为24，验证了entsize的含义。flag取低二位，为0 。</p><p>接下来的count的值是3，表示有三个元素。后面紧跟着三个元素。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>既然entsize_list_tt是一个列表，那么就需要一个迭代器，从而枚举列表内部的元素。迭代器是个内部类，重载了很多方法，迭代器类主要的方法是构造函数，剩下的全部是重载运算符，大致雷同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> entsize; <span class="comment">// 元素的大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> index;  <span class="comment">// 当前的索引  // keeping track of this saves a divide in operator-</span></span><br><span class="line">Element* element;  <span class="comment">// 指向当前的元素的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上</span></span><br><span class="line"><span class="comment">// start 是当前的索引</span></span><br><span class="line">iterator(<span class="keyword">const</span> List&amp; <span class="built_in">list</span>, <span class="keyword">uint32_t</span> start = <span class="number">0</span>)</span><br><span class="line">    : entsize(<span class="built_in">list</span>.entsize())  <span class="comment">// 记录 List 中单个元素的大小</span></span><br><span class="line">    , index(start)   <span class="comment">// 记录当前的索引</span></span><br><span class="line">    , element(&amp;<span class="built_in">list</span>.getOrEnd(start))  <span class="comment">// 保存当前的元素的地址</span></span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><p>下面是迭代器的示意图。</p><p><img src="/wiki/IOS/Runtime/objc/4entsize_list_tt/entisize_list_tt_iterator.png" alt="entisize_list_tt 迭代器示意图"></p><p>示意图中列出指向首元素的迭代器begin、尾后迭代器end、和begin+2的内存结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="entsize_list_tt" scheme="http://yoursite.com/tags/entsize-list-tt/"/>
    
  </entry>
  
  <entry>
    <title>3. NSObject 基本完整类图</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/3NSObject/</id>
    <published>2018-11-02T02:38:11.000Z</published>
    <updated>2018-11-21T07:07:48.250Z</updated>
    
    <content type="html"><![CDATA[<p>本文保存了NSObject的基本完整类图。方便以后理解。</p><a id="more"></a><h2 id="NSObject-完整类图"><a href="#NSObject-完整类图" class="headerlink" title="NSObject 完整类图"></a>NSObject 完整类图</h2><p>NSObject 基本完整类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/NSObject_picture.png" alt="NSObject 完整类图"></p><p>objc_class 有四个成员，本图说明两个非常重要的成员- isa、bits。 isa指向对象的类（或者类的元类）；bits定义了类的数据，包括类的属性、方法、协议、ivar 。 它的类型是class_data_bits_t，class_data_bits_t 有一个成员，类型是uintptr_t，64位。其中1~3位表示一个属性，3~47位表示一个指针，如果class还没有实现，这个指针指向class_ro_t类型，表示类编译完后的只读属性。当类实现后，这个指针指向了class_rw_t类型，表示runtime实现完class后类的数据，这是，数据里面已经包括了分类的方法信息。</p><h2 id="使用hopper查看类结构"><a href="#使用hopper查看类结构" class="headerlink" title="使用hopper查看类结构"></a>使用hopper查看类结构</h2><p>首先定义类LJObject，头文件如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LJObject.h</span></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObject </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>实现文件如下 ：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"LJObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">LJObject</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSString</span> *) funcValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span>*) printDefaultName:(<span class="built_in">NSString</span> *) strName</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(<span class="built_in">NSString</span> *)printDefaultValue:(<span class="built_in">NSString</span> *)strValue</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>使用hopper查看的结构如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_nsobject.png" alt="hopper 查看类的结构"></p><h2 id="五小结构"><a href="#五小结构" class="headerlink" title="五小结构"></a>五小结构</h2><h3 id="method-t"><a href="#method-t" class="headerlink" title="method_t"></a>method_t</h3><p>方法的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名，就是 SEL</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法类型字符串，有的地方又称 method signature 方法签名</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向方法的函数实现的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3_method_t.png" alt="method_t类图"></p><p>hopper查看的结果如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/hoper_method_t.jpg" alt="hopper 查看method_t结构"></p><p>总结method_t值包含三个属性，方法名字、方法签名、方法的实现。</p><h3 id="ivar-t"><a href="#ivar-t" class="headerlink" title="ivar_t"></a>ivar_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成员变量结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset; <span class="comment">// 偏移量 用 __OFFSETOFIVAR__ 计算</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 成员变量名  比如 "_name"</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type; <span class="comment">// 成员变量的类型 比如 "@\"NSString\""</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw; <span class="comment">// 对齐</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;  <span class="comment">// 成员变量占多少内存</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3ivar.png" alt="ivar_t类图"></p><h3 id="property-t"><a href="#property-t" class="headerlink" title="property_t"></a>property_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 属性名，堆中分配</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// 属性的特性字符串，标识了属性有哪些特性</span></span><br><span class="line">                            <span class="comment">// 该字符串是在堆中分配的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3property.png" alt="property_t 类图"></p><h3 id="protocol-t"><a href="#protocol-t" class="headerlink" title="protocol_t"></a>protocol_t</h3><p>定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协议结构体，继承自 objc_object</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protocol_t</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *mangledName;    <span class="comment">// 重整后的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 它在 objc_allocateProtocol() 中被赋值，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样，</span></span><br><span class="line">                                <span class="comment">// 重整名字是编译器给出的，加了 swift 复杂前缀的，用于混编时区分 oc协议 和 swift协议，</span></span><br><span class="line">                                <span class="comment">// 而 demangledName 取消重整的名称，应该就是去掉前缀的正常的名字</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>  <span class="comment">// 子协议列表，见 protocol_addProtocol()</span></span><br><span class="line">                                        <span class="comment">// 又可以称为 incorporated protocols 合并的协议</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_list_t</span> *instanceMethods;  <span class="comment">// 必选(required)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *classMethods;   <span class="comment">//  必选(required)的类方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalInstanceMethods; <span class="comment">// 可选(optional)的实例方法</span></span><br><span class="line">    <span class="keyword">method_list_t</span> *optionalClassMethods;  <span class="comment">// 可选(optional)的类方法</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">property_list_t</span> *instanceProperties;  <span class="comment">// 实例属性，当前协议只支持 required 的实例属性，</span></span><br><span class="line">                                          <span class="comment">// 协议中也是可以添加属性的，</span></span><br><span class="line">                                          <span class="comment">// 不知道会不会生成成员变量，但生成 set 和 get 方法是一定有的</span></span><br><span class="line">                                          <span class="comment">// 比如 NSObject 协议，就有几个 readonly 的属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint32_t</span> size;   <span class="comment">// 这个协议的大小，其中也包括了 extendedMethodTypes 整个数组的大小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;  <span class="comment">// 标记 跟 PROTOCOL_FIXED_UP_1 / PROTOCOL_FIXED_UP_2 有关系</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="comment">// 这句话的意思，好像是下面这几个成员变量不一定有，</span></span><br><span class="line">    <span class="comment">// 所以用到它们的时候都检查了下 size 是否足够大，比如 hasExtendedMethodTypesField() 和 protocol_t::demangledName()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> **extendedMethodTypes; <span class="comment">// 扩展方法类型数组，每个元素是一个扩展类型字符串</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *_demangledName; <span class="comment">// 取消重整的协议名称，为了兼容 swift 协议而准备的，</span></span><br><span class="line">                                <span class="comment">// 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样</span></span><br><span class="line">                                <span class="comment">// 见 demangledName()</span></span><br><span class="line">                                <span class="comment">// demangledName 取消重整的名称，应该就是去掉 swift 前缀的正常的名字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3protocal.png" alt="protocol_t 类图"></p><h3 id="category-t"><a href="#category-t" class="headerlink" title="category_t"></a>category_t</h3><p>定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 分类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;   <span class="comment">// 分类所属的类，classref_t 专门用于 unremapped 的类</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span>  <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>     <span class="comment">// 类方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>      <span class="comment">// 遵循的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span> <span class="comment">// 属性列表，但是并没有卵用... 唉....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3category.png" alt="category_t 类图"></p><h3 id="五小结构总图"><a href="#五小结构总图" class="headerlink" title="五小结构总图"></a>五小结构总图</h3><p><img src="/wiki/IOS/Runtime/objc/3NSObject/3five.png" alt="5小结构总图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文保存了NSObject的基本完整类图。方便以后理解。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>2. class_data_bits_t 结构</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/2_NSObject_objc_object/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/2_NSObject_objc_object/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-22T09:31:13.847Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><p>在上一篇分析 <code>isa</code> 的文章<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解 isa</a> 中曾经说到过实例方法被调用时，会通过其持有 <code>isa</code> 指针寻找对应的类，然后在其中的 <code>class_data_bits_t</code> 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。</p><p>这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。</p><h2 id="方法在内存中的位置"><a href="#方法在内存中的位置" class="headerlink" title="方法在内存中的位置"></a>方法在内存中的位置</h2><p>先来了解一下 ObjC 中类的结构图：<br><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class.png" alt="类的结构图"></p><ul><li><code>isa</code> 是指向元类的指针，不了解元类的可以看 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><code>super_class</code> 指向当前类的父类</li><li><code>cache</code> 用于缓存指针和 <code>vtable</code>，加速方法的调用</li><li><code>bits</code> 就是存储类的方法、属性和遵循的协议等信息的地方</li></ul><h3 id="class-data-bits-t-结构体"><a href="#class-data-bits-t-结构体" class="headerlink" title="class_data_bits_t 结构体"></a><code>class_data_bits_t</code> 结构体</h3><p>这一小结会分析类结构体中的 <code>class_data_bits_t bits</code>。其中只含有一个 64 位的 <code>bits</code> 用于存储与类有关的信息，它的定义如下 ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values are the FAST_ flags above.</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits; <span class="comment">// 只有这个一个成员变量，所有数据都存在这里，包括 rw 的地址和一些 flag</span></span><br><span class="line">                    <span class="comment">// 1. 在 realized 之前，bits 存的是 ro 的地址，</span></span><br><span class="line">                    <span class="comment">// 2. realized 后，bits 存 rw 的地址，rw 里的存有 ro 的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从定义可以看出，这只用一个成员，但是也类似位域，不同的位有不同的作用，bit不像isa使用位域定义，他使用移位定义，如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class is a Swift class</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)  <span class="comment">// 用于判断 Swift 类</span></span></span><br><span class="line"><span class="comment">// class or superclass has default retain/release/autorelease/retainCount/</span></span><br><span class="line"><span class="comment">//   _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)  <span class="comment">// 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法</span></span></span><br><span class="line"><span class="comment">// class's instances requires raw isa</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)  <span class="comment">// 当前类的实例需要 raw isa</span></span></span><br><span class="line"><span class="comment">// data pointer</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL <span class="comment">// 存 rw 的地址的位置</span></span></span><br></pre></td></tr></table></figure><p>全部是FAST开头，说明可以快速取到，而不用去次级对象中取。还有以RW、RO开头的宏，表示在次级的class_rw_t、class_ro_t结构的标志位。class_data_bits_t的类图如下：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class-data-bits-t.png" alt="objc-method-class-data-bits-t"></p><p>在 <code>objc_class</code> 结构体中的注释写到 <code>class_data_bits_t</code> 相当于 <code>class_rw_t</code> 指针加上 rr/alloc 的标志。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class_data_bits_t</span> bits;    <span class="comment">// class_rw_t * plus custom rr/alloc flags</span></span><br></pre></td></tr></table></figure><p>它为我们提供了便捷方法用于返回其中的 <code>class_rw_t *</code> 指针：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">class_rw_t</span>* <span class="class"><span class="keyword">data</span>() &#123;</span></span><br><span class="line"><span class="class">   <span class="title">return</span> (<span class="title">class_rw_t</span> *)(<span class="title">bits</span> &amp; <span class="type">FAST_DATA_MASK</span>);</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><p>将 <code>bits</code> 与 <code>FAST_DATA_MASK</code> 进行位运算，只取其中的 <code>[3, 47]</code> 位转换成 <code>class_rw_t *</code> 返回。</p><blockquote><p>在 x86_64 架构上，Mac OS <strong>只使用了其中的 47 位来为对象分配地址</strong>。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。</p></blockquote><p>因为 <code>class_rw_t *</code> 指针只存于第 <code>[3, 47]</code> 位，所以可以使用最后三位来存储关于当前类的其他信息：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-class_data_bits_t.png" alt="objc-method-class_data_bits_t"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_IS_SWIFT           (1UL&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_HAS_DEFAULT_RR     (1UL&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_REQUIRES_RAW_ISA   (1UL&lt;&lt;2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK          0x00007ffffffffff8UL</span></span><br></pre></td></tr></table></figure><ul><li><code>isSwift()</code><ul><li><code>FAST_IS_SWIFT</code> 用于判断 Swift 类</li></ul></li><li><code>hasDefaultRR()</code><ul><li><code>FAST_HAS_DEFAULT_RR</code> 当前类或者父类含有默认的 <code>retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference</code> 方法</li></ul></li><li><code>requiresRawIsa()</code><ul><li><code>FAST_REQUIRES_RAW_ISA</code> 当前类的实例需要 raw <code>isa</code></li></ul></li></ul><p>执行 <code>class_data_bits_t</code> 结构体中的 <code>data()</code> 方法或者调用 <code>objc_class</code> 中的 <code>data()</code> 方法会返回同一个 <code>class_rw_t *</code> 指针，因为 <code>objc_class</code> 中的方法只是对 <code>class_data_bits_t</code> 中对应方法的封装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// objc_class 中的 data() 方法</span><br><span class="line">class_data_bits_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t *data() &#123; </span><br><span class="line">   return bits.data();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// class_data_bits_t 中的 data() 方法</span><br><span class="line">uintptr_t bits;</span><br><span class="line"></span><br><span class="line">class_rw_t* data() &#123;</span><br><span class="line">   return (class_rw_t *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="class-rw-t-和-class-ro-t"><a href="#class-rw-t-和-class-ro-t" class="headerlink" title="class_rw_t 和 class_ro_t"></a><code>class_rw_t</code> 和 <code>class_ro_t</code></h3><p>ObjC 类中的属性、方法还有遵循的协议等信息都保存在 <code>class_rw_t</code> 中：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct class_rw_t &#123;</span><br><span class="line">    uint32_t flags<span class="comment">;</span></span><br><span class="line">    uint32_t version<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    const class_ro_t *ro<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    method_array_t methods<span class="comment">;</span></span><br><span class="line">    property_array_t properties<span class="comment">;</span></span><br><span class="line">    protocol_array_t protocols<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    Class firstSubclass<span class="comment">;</span></span><br><span class="line">    Class nextSiblingClass<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中还有一个指向常量的指针 <code>ro</code>，其中存储了<strong>当前类在编译期就已经确定的属性、方法以及遵循的协议</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart;</span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;</span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList;</span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout;</span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>在编译期间</strong>类的结构中的 <code>class_data_bits_t *data</code> 指向的是一个 <code>class_ro_t *</code> 指针：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>然后在加载 <em>ObjC 运行时</em>的时候调用 <code>realizeClass</code> 方法：</p><ol><li>从 <code>class_data_bits_t</code> 调用 <code>data</code> 方法，将结果从 <code>class_rw_t</code> 强制转换为 <code>class_ro_t</code> 指针</li><li>初始化一个 <code>class_rw_t</code> 结构体</li><li>设置结构体 <code>ro</code> 的值以及 <code>flag</code></li><li>最后设置正确的 <code>data</code>。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>下图是 <code>realizeClass</code> 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-realize-class.png" alt="objc-method-after-realize-class"></p><p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p><h2 id="XXObject"><a href="#XXObject" class="headerlink" title="XXObject"></a>XXObject</h2><p>下面，我们将分析一个类 <code>XXObject</code> 在运行时初始化过程中内存的更改，这是 <code>XXObject</code> 的接口与实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXObject.h 文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">XXObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXObject.m 文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"XXObject.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XXObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)hello &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-target.png" alt="objc-method-target"></p><p>这是主程序的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &quot;XXObject.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Class cls = [XXObject class];</span><br><span class="line">        NSLog(@&quot;%p&quot;, cls);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译后内存中类的结构"><a href="#编译后内存中类的结构" class="headerlink" title="编译后内存中类的结构"></a>编译后内存中类的结构</h3><p>因为<strong>类在内存中的位置是编译期就确定的</strong>，先运行一次代码获取 <code>XXObject</code> 在内存中的地址。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x100001168</span></span><br></pre></td></tr></table></figure><p>接下来，在整个 ObjC 运行时初始化之前，也就是 <code>_objc_init</code> 方法中加入一个断点：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-compile.png" alt="objc-method-after-compile"></p><p>然后在 lldb 中输入以下命令：</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)<span class="number">0</span>x100001168</span><br><span class="line">(objc_class *) <span class="variable">$0</span> = <span class="number">0</span>x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)<span class="number">0</span>x100001188</span><br><span class="line">(class_data_bits_t *) <span class="variable">$1</span> = <span class="number">0</span>x0000000100001188</span><br><span class="line">(lldb) p <span class="variable">$1</span>-&gt;data()</span><br><span class="line">warning: could not <span class="built_in">load</span> <span class="literal">any</span> Objective-C class information. This will significantly reduce the quality of type information available.</span><br><span class="line">(class_rw_t *) <span class="variable">$2</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p (class_ro_t *)<span class="variable">$2</span> // 将 class_rw_t 强制转化为 class_ro_t</span><br><span class="line">(class_ro_t *) <span class="variable">$3</span> = <span class="number">0</span>x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$3</span></span><br><span class="line">(class_ro_t) <span class="variable">$4</span> = &#123;</span><br><span class="line">  <span class="keyword">flags</span> = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  name = <span class="number">0</span>x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0</span>x00000001000010c8</span><br><span class="line">  baseProtocols = <span class="number">0</span>x0000000000000000</span><br><span class="line">  ivars = <span class="number">0</span>x0000000000000000</span><br><span class="line">  weakIvarLayout = <span class="number">0</span>x0000000000000000 <span class="variable">&lt;no value available&gt;</span></span><br><span class="line">  baseProperties = <span class="number">0</span>x0000000000000000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-print-before-realize.png" alt="objc-method-lldb-print-before-realize"></p><p>现在我们获取了类经过编译器处理后的只读属性 <code>class_ro_t</code>：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(class_ro_t) $<span class="number">4</span> = &#123;</span><br><span class="line">  flags = <span class="number">128</span></span><br><span class="line">  instanceStart = <span class="number">8</span></span><br><span class="line">  instanceSize = <span class="number">8</span></span><br><span class="line">  reserved = <span class="number">0</span></span><br><span class="line">  ivarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  name = <span class="number">0x0000000100000f7a</span> <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = <span class="number">0x00000001000010c8</span></span><br><span class="line">  baseProtocols = <span class="number">0x0000000000000000</span></span><br><span class="line">  ivars = <span class="number">0x0000000000000000</span></span><br><span class="line">  weakIvarLayout = <span class="number">0x0000000000000000</span> &lt;no value available&gt;</span><br><span class="line">  baseProperties = <span class="number">0x0000000000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里面只有 <code>baseMethodList</code> 和 <code>name</code> 是有值的，其它的 <code>ivarLayout</code>、 <code>baseProtocols</code>、 <code>ivars</code>、<code>weakIvarLayout</code> 和 <code>baseProperties</code> 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。</p><p>通过下面的命令查看 <code>baseMethodList</code> 中的内容：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">4</span>.baseMethodList</span><br><span class="line">(method_list_t *) $<span class="number">5</span> = <span class="number">0</span>x00000001000010c8</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">0</span>)</span><br><span class="line">(method_t) $<span class="number">6</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject<span class="selector-class">.m</span>:<span class="number">13</span>)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) <span class="selector-tag">p</span> $<span class="number">5</span>-&gt;get(<span class="number">1</span>)</span><br><span class="line">Assertion failed: (<span class="selector-tag">i</span> &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new<span class="selector-class">.h</span>, line <span class="number">110</span>.</span><br><span class="line">error: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-print-method-list.png" alt="objc-method-lldb-print-method-list"></p><p>使用 <code>$5-&gt;get(0)</code> 时，成功获取到了 <code>-[XXObject hello]</code> 方法的结构体 <code>method_t</code>。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。</p><h3 id="realizeClass"><a href="#realizeClass" class="headerlink" title="realizeClass"></a>realizeClass</h3><p>这篇文章中不会对 <code>realizeClass</code> 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括：</p><ul><li>分配可读写数据空间</li><li>返回真正的类结构</li></ul><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">Class</span> realizeClass(<span class="keyword">Class</span> cls)</span><br></pre></td></tr></table></figure><p>上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 <code>XXObject</code>：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-lldb-breakpoint.png" alt="objc-method-lldb-breakpoint"></p><p>这里直接判断两个指针是否相等，而不使用 <code>[NSStringFromClass(cls) isEqualToString:@&quot;XXObject&quot;]</code> 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 <code>XXObject</code>。</p><blockquote><p>直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。</p></blockquote><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-breakpoint-before-set-rw.png" alt="objc-method-breakpoint-before-set-r"></p><p>这个断点就设置在这里，因为 <code>XXObject</code> 是一个正常的类，所以会走 <code>else</code> 分支为<strong>可写的类数据</strong>分配内存。</p><blockquote><p>运行代码时，因为每次都会判断当前类指针是不是指向的 <code>XXObject</code>，所以会等一会才会进入断点。</p></blockquote><p>在这时打印类结构体中的 <code>data</code> 的值，发现其中的布局依旧是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-before-realize.png" alt="objc-method-before-realize"></p><p>在运行完这段代码之后:</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-realize-breakpoint.png" alt="objc-method-after-realize-breakpoint"></p><p>我们再来打印类的结构:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">(lldb) p (objc_class *)cls <span class="comment">// 打印类指针</span></span><br><span class="line">(objc_class *) <span class="variable">$262</span> = 0x0000000100001168</span><br><span class="line">(lldb) p (class_data_bits_t *)0x0000000100001188 <span class="comment">// 在类指针上加 32 的 offset 打印 class_data_bits_t 指针</span></span><br><span class="line">(class_data_bits_t *) <span class="variable">$263</span> = 0x0000000100001188</span><br><span class="line">(lldb) p *<span class="variable">$263</span> <span class="comment">// 访问 class_data_bits_t 指针的内容</span></span><br><span class="line">(class_data_bits_t) <span class="variable">$264</span> = (bits = 4302315312)</span><br><span class="line">(lldb) p <span class="variable">$264</span>.data() <span class="comment">// 获取 class_rw_t</span></span><br><span class="line">(class_rw_t *) <span class="variable">$265</span> = 0x0000000100701f30</span><br><span class="line">(lldb) p *<span class="variable">$265</span> <span class="comment">// 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了</span></span><br><span class="line">(class_rw_t) <span class="variable">$266</span> = &#123;</span><br><span class="line">  flags = 2148007936</span><br><span class="line">  <span class="keyword">version</span> = 0</span><br><span class="line">  ro = 0x00000001000010e8</span><br><span class="line">  methods = &#123;</span><br><span class="line">    list_array_tt&lt;method_t, method_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  properties = &#123;</span><br><span class="line">    list_array_tt&lt;property_t, property_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  protocols = &#123;</span><br><span class="line">    list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123;</span><br><span class="line">       = &#123;</span><br><span class="line">        <span class="keyword">list</span> = 0x0000000000000000</span><br><span class="line">        arrayAndFlag = 0</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  firstSubclass = nil</span><br><span class="line">  nextSiblingClass = nil</span><br><span class="line">  demangledName = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$266</span>.ro <span class="comment">// 获取 class_ro_t 指针</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t *) <span class="variable">$267</span> = 0x00000001000010e8</span><br><span class="line">(lldb) p *<span class="variable">$267</span> <span class="comment">// 访问 class_ro_t 指针的内容</span></span><br><span class="line">(<span class="keyword">const</span> class_ro_t) <span class="variable">$268</span> = &#123;</span><br><span class="line">  flags = 128</span><br><span class="line">  instanceStart = 8</span><br><span class="line">  instanceSize = 8</span><br><span class="line">  reserved = 0</span><br><span class="line">  ivarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  name = 0x0000000100000f7a <span class="string">"XXObject"</span></span><br><span class="line">  baseMethodList = 0x00000001000010c8</span><br><span class="line">  baseProtocols = 0x0000000000000000</span><br><span class="line">  ivars = 0x0000000000000000</span><br><span class="line">  weakIvarLayout = 0x0000000000000000 &lt;<span class="keyword">no</span> value available&gt;</span><br><span class="line">  baseProperties = 0x0000000000000000</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$268</span>.baseMethodList <span class="comment">// 获取基本方法列表</span></span><br><span class="line">(method_list_t *<span class="keyword">const</span>) <span class="variable">$269</span> = 0x00000001000010c8</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(0) <span class="comment">// 访问第一个方法</span></span><br><span class="line">(method_t) <span class="variable">$270</span> = &#123;</span><br><span class="line">  name = <span class="string">"hello"</span></span><br><span class="line">  types = 0x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line">  imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.<span class="keyword">m</span>:13)</span><br><span class="line">&#125;</span><br><span class="line">(lldb) p <span class="variable">$269</span>-&gt;<span class="built_in">get</span>(1) <span class="comment">// 尝试访问第二个方法，越界</span></span><br><span class="line"><span class="keyword">error</span>: Execution was interrupted, reason: signal SIGABRT.</span><br><span class="line">The process has been returned to the state before expression evaluation.</span><br><span class="line">Assertion failed: (i &lt; <span class="keyword">count</span>), function get, <span class="keyword">file</span> /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.<span class="keyword">h</span>, <span class="keyword">line</span> 110.</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-print-class-struct-after-realize.png" alt="objc-method-print-class-struct-after-realize"></p><blockquote><p>最后一个操作实在是截取不到了</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;data();</span><br><span class="line"><span class="keyword">class_rw_t</span> *rw = (<span class="keyword">class_rw_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">class_rw_t</span>), <span class="number">1</span>);</span><br><span class="line">rw-&gt;ro = ro;</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING;</span><br><span class="line">cls-&gt;setData(rw);</span><br></pre></td></tr></table></figure><p>在上述的代码运行之后，类的只读指针 <code>class_ro_t</code> 以及可读写指针 <code>class_rw_t</code> 都被正确的设置了。但是到这里，其 <code>class_rw_t</code> 部分的方法等成员的指针 <code>methods</code>、 <code>protocols</code> 和 <code>properties</code> 均为空，这些会在 <code>methodizeClass</code> 中进行设置：</p><p><img src="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/objc-method-after-methodizeClass.png" alt="objc-method-after-methodizeClass"></p><p>在这里调用了 <code>method_array_t</code> 的 <code>attachLists</code> 方法，将 <code>baseMethods</code> 中的方法添加到 <code>methods</code> 数组之后。我们访问 <code>methods</code> 才会获取当前类的实例方法。</p><h2 id="方法的结构"><a href="#方法的结构" class="headerlink" title="方法的结构"></a>方法的结构</h2><p>说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct method_t &#123;</span><br><span class="line">    SEL name<span class="comment">;</span></span><br><span class="line">    const char *types<span class="comment">;</span></span><br><span class="line">    IMP imp<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>其中包含方法名，类型还有方法的实现指针 <code>IMP</code>：</p><p>上面的 <code>-[XXObject hello]</code> 方法的结构体是这样的：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">"hello"</span></span><br><span class="line"><span class="attr">types</span> = <span class="number">0</span>x0000000100000fa4 <span class="string">"v16@0:8"</span></span><br><span class="line"><span class="attr">imp</span> = <span class="number">0</span>x0000000100000e90 (method`-[XXObject hello] at XXObject.m:<span class="number">13</span></span><br></pre></td></tr></table></figure><p>方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 <code>&quot;v16@0:8&quot;</code> 这在 ObjC 中叫做<em>类型编码</em>(Type Encoding)，你可以看这篇<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a>了解与类型编码相关的信息。</p><p>对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分析方法在内存中的位置时，笔者最开始一直在尝试寻找<strong>只读</strong>结构体 <code>class_ro_t</code> 中 <code>baseMethods</code> 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 <code>methodizeClass</code> 方法一直向上找，直到 <code>_obj_init</code> 方法也没有找到设置只读区域的 <code>baseMethods</code> 的方法。</p><p>而且在 runtime 初始化之后，<code>realizeClass</code> 之前，从 <code>class_data_bits_t</code> 结构体中获取的 <code>class_rw_t</code> 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 <code>realizeClass</code> 中发现原来在这时并不是 <code>class_rw_t</code> 结构体，而是<code>class_ro_t</code>，才明白错误的原因。</p><p>后来突然想到类的一些方法、属性和协议实在编译期决定的（<code>baseMethods</code> 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。</p><ol><li>类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。</li><li>类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 <code>realizeClass</code> 执行之后，才放到了 <code>class_rw_t</code> 指向的只读区域 <code>class_ro_t</code>，这样我们即可以在运行时为 <code>class_rw_t</code> 添加方法，也不会影响类的只读结构。</li><li>在 <code>class_ro_t</code> 中的属性在运行期间就不能改变了，再添加方法时，会修改 <code>class_rw_t</code> 中的 <code>methods</code> 列表，而不是 <code>class_ro_t</code> 中的 <code>baseMethods</code>，对于方法的添加会在之后的文章中分析。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 &lt;code&gt;x86_64&lt;/code&gt; 架构下运行的，对于在 arm64 中运行的代码会特别说明
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="NSObject" scheme="http://yoursite.com/tags/NSObject/"/>
    
  </entry>
  
  <entry>
    <title>1. 从 NSObject 的初始化了解 isa（转载)</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/1_NSObject_isa/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/1_NSObject_isa/</id>
    <published>2018-11-01T02:38:11.000Z</published>
    <updated>2018-11-22T09:30:02.116Z</updated>
    
    <content type="html"><![CDATA[<p>本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件</p><a id="more"></a><blockquote><p>因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 <code>x86_64</code> 架构下运行的，对于在 arm64 中运行的代码会特别说明。</p></blockquote><h2 id="OC的类是一个结构体"><a href="#OC的类是一个结构体" class="headerlink" title="OC的类是一个结构体"></a>OC的类是一个结构体</h2><p>所有的OC类其实都是一个c语言的结构体，我们可以通过clang -rewrite-objc 命令重写OC类为C++类。来理解OC的类就是一个C语言的结构体。下面是重写的实例，类的定义如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">LJObjc</span>:NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong) NSString *strName;</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span>(nonatomic, strong)NSString *strVale;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">-</span>(NSString *) <span class="selector-tag">funcValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line">+(NSString*) <span class="selector-tag">printDefaultName</span><span class="selector-pseudo">:(NSString</span> *) <span class="selector-tag">strName</span>;</span><br><span class="line"></span><br><span class="line">+(NSString *)<span class="selector-tag">printDefaultValue</span><span class="selector-pseudo">:(NSString</span> *)<span class="selector-tag">strValue</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">implementation</span> <span class="selector-tag">LJObjc</span></span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">end</span></span><br></pre></td></tr></table></figure><p>在从重写后的输出文件中，我们找到LJObjc的定义，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">LJObjc</span>;</span></span><br></pre></td></tr></table></figure><p>可以看出，OC类就是一个C的结构体。</p><p>既然所有的OC对都是一个结构体，这个结构体就是struct objc_object。定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>objc_object结构中只有一个 <code>isa_t</code>类型成员。所以我们可以说含有isa的结构体都是一个对象。</p><blockquote><p>所有继承自 <code>NSObject</code> 的类实例化后的对象都会包含一个类型为 <code>isa_t</code> 的结构体。</p></blockquote><p>虽然上面重写LJObjc后的C语言结构体是一个objc_object对象，但实际上他是一个objc_class结构体，由于objc_class继承与objc_object，  所以本质上objc_class 也是一个objc_object结构。<br>objc_class定义如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct objc_class : objc_object &#123;</span><br><span class="line">    isa_t isa<span class="comment">;</span></span><br><span class="line">    Class superclass<span class="comment">;</span></span><br><span class="line">    <span class="keyword">cache_t </span><span class="keyword">cache;</span></span><br><span class="line"><span class="keyword"> </span>   class_data_bits_t <span class="keyword">bits;</span></span><br><span class="line"><span class="keyword">&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>由于 <code>objc_class</code> 结构体是继承自 <code>objc_object</code> 的，所以在这里显式地写出了 <code>isa_t isa</code> 这个成员变量。</p></blockquote><p>到这里，我们就明白了：<strong>Objective-C 中类也是一个对象</strong>。</p><h2 id="isa-指针的作用与元类"><a href="#isa-指针的作用与元类" class="headerlink" title="isa 指针的作用与元类"></a><code>isa</code> 指针的作用与元类</h2><p> <code>isa</code> 包含了什么呢？回答这个问题之前，要引入了另一个概念 <em>元类(meta class)</em>，我们先了解一些关于元类的信息。</p><p>因为在 Objective-C 中，对象的方法并<strong>没有存储于对象的结构体中</strong>（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。</p><p>当<strong>实例方法</strong>被调用时，它要通过自己持有的 <code>isa</code> 来查找对应的类，然后在这里的 <code>class_data_bits_t</code> 结构体中查找对应方法的实现。同时，每一个 <code>objc_class</code> 也有一个<strong>指向自己的父类的指针</strong> <code>super_class</code> 用来查找继承的方法。</p><blockquote><p>关于如何在 <code>class_data_bits_t</code> 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md" rel="external nofollow noopener noreferrer" target="_blank">深入解析 ObjC 中方法的结构</a></p></blockquote><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-pointer.png" alt="isa 指针-- 实例找到类"></p><p>但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入<em>元类</em>来保证无论是类还是对象都能<strong>通过相同的机制查找方法的实现</strong>。</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-meta-class.png" alt="元类的引入"></p><p>让每一个类的 <code>isa</code> 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的：</p><ul><li>实例方法调用时，通过对象的 <code>isa</code> 在类中获取方法的实现</li><li>类方法调用时，通过类的 <code>isa</code> 在元类中获取方法的实现</li></ul><p>下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-diagram.png" alt="元类"></p><blockquote><p>图片来自 <a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></p></blockquote><p>有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 <code>isa</code>，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 <a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></p><h2 id="结构体-isa-t"><a href="#结构体-isa-t" class="headerlink" title="结构体 isa_t"></a>结构体 <code>isa_t</code></h2><p>其实 <code>isa_t</code> 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x001f800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;56)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;7)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这是在 <code>__x86_64__</code> 上的实现，对于 iPhone5s 等架构为 <code>__arm64__</code> 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 <a href="#arm64">arm64 上结构体的实现</a></p></blockquote><p><strong>在本篇文章中, 我们会以 <code>__x86_64__</code> 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析</strong>。在我看来，这个细节不会影响对 <code>isa</code> 指针的理解，不过还是要知道的。</p><p>下面是一张isa_t的类图，便于理解</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-class-object-class.png" alt="isa类图"></p><p>笔者对这个 <code>isa_t</code> 的实现声明顺序有一些更改，更方便分析和理解。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>isa_t</code> 是一个 <code>union</code> 类型的结构体，对 <code>union</code> 不熟悉的读者可以看这个 stackoverflow 上的<a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">回答</a>. 也就是说其中的 <code>cls</code>、 <code>bits</code> 还有结构体共用同一块地址空间。而 <code>isa</code> 总共会占据 64 位的内存空间（决定于其中的结构体）</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat.png" alt="isa各个位域的含义"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h2 id="isa-的初始化"><a href="#isa-的初始化" class="headerlink" title="isa 的初始化"></a><code>isa</code> 的初始化</h2><p>我们可以通过 <code>isa</code> 初始化的方法 <code>initIsa</code> 来初步了解这 64 位的 bits 的作用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///定义位于objc-object.h文件</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initInstanceIsa(Class cls, <span class="keyword">bool</span> hasCxxDtor)</span><br><span class="line">&#123;</span><br><span class="line">    initIsa(cls, <span class="literal">true</span>, hasCxxDtor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">objc_object::initIsa(Class cls, <span class="keyword">bool</span> indexed, <span class="keyword">bool</span> hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (!indexed) &#123;</span><br><span class="line">        isa.cls = cls;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        isa.bits = ISA_MAGIC_VALUE;</span><br><span class="line">        isa.has_cxx_dtor = hasCxxDtor;</span><br><span class="line">        isa.shiftcls = (<span class="keyword">uintptr_t</span>)cls &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="indexed-和-magic"><a href="#indexed-和-magic" class="headerlink" title="indexed 和 magic"></a><code>indexed</code> 和 <code>magic</code></h3><p>当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 <code>initIsa</code> 方法，由于在 <code>initInstanceIsa</code> 方法中传入了 <code>indexed = true</code>，所以，我们简化一下这个方法的实现：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">inline void objc_object::initIsa(Class cls, <span class="keyword">bool </span>indexed, <span class="keyword">bool </span>hasCxxDtor) </span><br><span class="line">&#123; </span><br><span class="line">    isa.<span class="keyword">bits </span>= ISA_MAGIC_VALUE<span class="comment">;</span></span><br><span class="line">    isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br><span class="line">    isa.<span class="keyword">shiftcls </span>= (uintptr_t)cls &gt;&gt; <span class="number">3</span><span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对整个 <code>isa</code> 的值 <code>bits</code> 进行设置，传入 <code>ISA_MAGIC_VALUE</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x001d800000000001ULL</span></span><br></pre></td></tr></table></figure><p>我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-bits.png" alt="objc-isa-isat-bits"></p><p>从图中了解到，在使用 <code>ISA_MAGIC_VALUE</code> 设置 <code>isa_t</code> 结构体之后，实际上只是设置了 <code>indexed</code> 以及 <code>magic</code> 这两部分的值。</p><ul><li><p>其中 <code>indexed</code> 表示 <code>isa_t</code> 的类型</p><ul><li><p>0 表示 <code>raw isa</code>，也就是没有结构体的部分，访问对象的 <code>isa</code> 会直接返回一个指向 <code>cls</code> 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    isa_t() &#123; &#125;</span><br><span class="line">    isa_t(uintptr_t value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    uintptr_t bits;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>1 表示当前 <code>isa</code> 不是指针，但是其中也有 <code>cls</code> 的信息，只是其中<strong>关于类的指针都是保存在 <code>shiftcls</code> 中</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">44</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">8</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>magic</code> 的值为 <code>0x3b</code> 用于调试器判断当前对象是真的对象还是没有初始化的空间</p></li></ul><h3 id="has-cxx-dtor"><a href="#has-cxx-dtor" class="headerlink" title="has_cxx_dtor"></a><code>has_cxx_dtor</code></h3><p>在设置 <code>indexed</code> 和 <code>magic</code> 值之后，会设置 <code>isa</code> 的 <code>has_cxx_dtor</code>，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.has_cxx_dtor = hasCxxDtor<span class="comment">;</span></span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-bits-has-css-dtor.png" alt="objc-isa-isat-bits-has-css-dto"></p><h3 id="shiftcls"><a href="#shiftcls" class="headerlink" title="shiftcls"></a><code>shiftcls</code></h3><p>在为 <code>indexed</code>、 <code>magic</code> 和 <code>has_cxx_dtor</code> 设置之后，我们就要将当前对象对应的类指针存入 <code>isa</code> 结构体中了。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0</strong>。</p><p>绝大多数机器的架构都是 <a href="https://en.wikipedia.org/wiki/Byte_addressing" rel="external nofollow noopener noreferrer" target="_blank">byte-addressable</a> 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 <code>000</code>，我们只会用其中的 30 位来表示对象的地址。 </p></blockquote><p>而 ObjC 中的类指针的地址后三位也为 0，在 <code>_class_createInstanceFromZone</code> 方法中打印了调用这个方法传入的类指针：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-cls.png" alt="objc-isa-print-cls"></p><p>可以看到，这里打印出来的<strong>所有类指针十六进制地址的最后一位都为 8 或者 0</strong>。也就是说，类指针的后三位都为 0，所以，我们在上面存储 <code>Class</code> 指针时右移三位是没有问题的。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isa.shiftcls = (uintptr_t)cls <span class="meta">&gt;&gt; </span><span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>如果再尝试打印对象指针的话，会发现所有对象内存地址的<strong>后四位</strong>都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。 </p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-object.png" alt="objc-isa-print-object"></p><blockquote><p>使用整个指针大小的内存来存储 <code>isa</code> 指针有些浪费，尤其在 64 位的 CPU 上。在 <code>ARM64</code> 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 <code>isa</code> 留下 34 位用于性能的优化。</p><p>Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.<br>from <a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></p></blockquote><p>我尝试运行了下面的代码将 <code>NSObject</code> 的类指针和对象的 <code>isa</code> 打印出来，具体分析一下</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-print-class-object.png" alt="objc-isa-print-class-object"></p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span><span class="number">_p</span>ointer: <span class="number">0000000001011101100000000000000100000000001110101110000011111001</span> <span class="comment">// 补全至 64 位</span></span><br><span class="line"><span class="keyword">class</span><span class="number">_p</span>ointer:                                 <span class="number">100000000001110101110000011111000</span></span><br></pre></td></tr></table></figure><blockquote><p>编译器对直接访问 <code>isa</code> 的操作会有警告，因为直接访问 <code>isa</code> 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 <a href="#ISA(">ISA()</a>) 方法来获取类指针。</p></blockquote><p>代码中的 <code>object</code> 对象的 <code>isa</code> 结构体中的内容是这样的：</p><p><img src="/wiki/IOS/Runtime/objc/1_NSObject_isa/objc-isa-isat-class-highlight-bits.png" alt="objc-isa-isat-class-highlight-bits"></p><p>其中红色的为<strong>类指针</strong>，与上面打印出的 <code>[NSObject class]</code> 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 <code>isa</code> 时对 <code>initIsa</code> 方法的分析是正确的。它设置了 <code>indexed</code>、<code>magic</code> 以及 <code>shiftcls</code>。</p><h3 id="ISA-方法"><a href="#ISA-方法" class="headerlink" title="ISA() 方法"></a><a id="ISA()"></a>ISA() 方法</h3><p>因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 <code>ISA()</code> 来返回类指针。</p><p>其中 <code>ISA_MASK</code> 是宏定义，这里通过掩码的方式获取类指针：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define ISA_MASK 0x00007ffffffffff8ULL</span></span><br><span class="line"><span class="keyword">inline</span> <span class="class"><span class="keyword">Class</span> </span></span><br><span class="line">objc_object::ISA() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="class"><span class="keyword">Class</span>)(<span class="title">isa</span>.<span class="title">bits</span> &amp; <span class="title">ISA_MASK</span>);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其它-bits"><a href="#其它-bits" class="headerlink" title="其它 bits"></a>其它 bits</h3><p>在 <code>isa_t</code> 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用</p><ul><li><code>has_assoc</code><ul><li>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</li></ul></li><li><code>weakly_referenced</code><ul><li>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</li></ul></li><li><code>deallocating</code><ul><li>对象正在释放内存</li></ul></li><li><code>has_sidetable_rc</code><ul><li>对象的引用计数太大了，存不下</li></ul></li><li><code>extra_rc</code><ul><li>对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，<code>extra_rc</code> 的值就为 9</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">   uintptr_t indexed           : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_assoc         : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_cxx_dtor      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">shiftcls </span>         : <span class="number">44</span><span class="comment">;</span></span><br><span class="line">   uintptr_t magic             : <span class="number">6</span><span class="comment">;</span></span><br><span class="line">   uintptr_t weakly_referenced : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t deallocating      : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t has_sidetable_rc  : <span class="number">1</span><span class="comment">;</span></span><br><span class="line">   uintptr_t <span class="keyword">extra_rc </span>         : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="arm64-架构中的-isa-t-结构体"><a href="#arm64-架构中的-isa-t-结构体" class="headerlink" title="arm64 架构中的 isa_t 结构体"></a><a id="arm64"></a>arm64 架构中的 <code>isa_t</code> 结构体</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> &#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">       <span class="keyword">uintptr_t</span> indexed           : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ol><li>对象： 含有isa指针的结构都是对象，包括类，实例。</li><li>isa指针的作用之一，统一类方法和实例方法的调用机制</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtHowMessagingWorks.html" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a></li><li><a href="http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Classes_and_metaclasses</a></li><li><a href="http://stackoverflow.com/questions/18997362/storing-things-in-isa" rel="external nofollow noopener noreferrer" target="_blank">Storing things in isa</a></li><li><a href="http://stackoverflow.com/questions/252552/why-do-we-need-c-unions" rel="external nofollow noopener noreferrer" target="_blank">Why do we need C Unions?</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" rel="external nofollow noopener noreferrer" target="_blank">objc_explain_Non-pointer_isa</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.mikeash.com/pyblog/friday-qa-2013-09-27-arm64-and-you.html" rel="external nofollow noopener noreferrer" target="_blank">ARM64 and You</a></li><li><a href="http://blog.xcodev.com/posts/tagged-pointer-and-64-bit/" rel="external nofollow noopener noreferrer" target="_blank">64位与Tagged Pointer</a></li></ul><p>Follow: <a href="https://github.com/Draveness" rel="external nofollow noopener noreferrer" target="_blank">@Draveness</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文讲解Runtime中的isa指针，本文全部抄袭，  代码位于《objc-private.h》文件&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="isa" scheme="http://yoursite.com/tags/isa/"/>
    
  </entry>
  
  <entry>
    <title>0. 参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/objc/0_refer/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/objc/0_refer/</id>
    <published>2018-10-31T16:38:11.000Z</published>
    <updated>2018-11-26T10:12:35.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li><li><a href="https://www.jianshu.com/p/9e0fc8295c4b" rel="external nofollow noopener noreferrer" target="_blank">Xcode 10 下如何调试objc4-723</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Draveness/analyze&quot; rel=&quot;exte
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="objc" scheme="http://yoursite.com/categories/IOS/Runtime/objc/"/>
    
    
      <category term="list_array_tt" scheme="http://yoursite.com/tags/list-array-tt/"/>
    
  </entry>
  
  <entry>
    <title>关键字使用的位置</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E9%99%84%E5%BD%95/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/附录/关键字使用的位置/</id>
    <published>2018-09-20T04:07:12.000Z</published>
    <updated>2018-09-20T07:30:27.282Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>关键字</th><th>说明</th></tr></thead><tbody><tr><td>static</td><td>static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中</td></tr><tr><td>explicit</td><td>explicit只对一个实参的构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外定义时不应该重复使用</td></tr><tr><td>=default</td><td>当我们在类内用=default修饰成员声明时，合成的函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default</td></tr><tr><td>=delete</td><td>必须出现在函数第一次声明的时候</td></tr><tr><td>virtual</td><td>只能出现在类内部的声明语句中之前，不能用于类外部的函数定义</td></tr><tr><td>override</td><td></td></tr><tr><td>final</td><td>类的名字后面，防止继承</td></tr><tr><td>=0</td><td>只能出现在类内部的虚函数声明语句处</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;static&lt;/td&gt;
&lt;td&gt;static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中&lt;/td&gt;
&lt;/tr
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="附录" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E9%99%84%E5%BD%95/"/>
    
    
      <category term="关键字使用的位置" scheme="http://yoursite.com/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E4%BD%BF%E7%94%A8%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    
  </entry>
  
</feed>
