<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-10T11:20:06.488Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数、枚举、可选项、结构体、闭包、属性、chushih</title>
    <link href="http://yoursite.com/wiki/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/3_%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/视频学习记录/Swift/3_函数/</id>
    <published>2020-01-09T01:07:12.000Z</published>
    <updated>2020-01-10T11:20:06.488Z</updated>
    
    <content type="html"><![CDATA[<p>函数 、枚举、可选项等学习记录</p><a id="more"></a><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ol><li>形参默认是let</li><li>函数体是单一表达式，隐式返回</li><li>返回元组，多参数返回</li><li><p>函数的注释： </p> <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> Parameter <span class="symbol">v1:</span></span></span><br><span class="line"><span class="ruby">- Parameter <span class="symbol">v2:</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">- <span class="symbol">Returns:</span></span></span><br><span class="line"><span class="ruby">- <span class="symbol">Note:</span></span></span><br></pre></td></tr></table></figure></li><li><p>参数标签：下划线可以省略参数标签</p></li><li>参数默认值：由于swift拥有参数标签，对默认参数没有从右向左的顺序的限制</li><li>可变参数： 类型后面三个点，一个函数只能有一个可变参数，紧跟在可变参数后面参数不能省略参数标签</li><li>输入输出参数： 类型签名添加inout， inout参数不能有默认值，本质是引用</li><li>函数重载：参数个数|参数类型|参数标签不同都构成函数重载，返回值不构成函数重载</li><li>内联函数：不会内联的函数包括：函数体比较长，包含递归、动态派发<code>@inline(never)  @inline(__always)</code></li><li>函数类型，条用的时候不需要参数标签</li><li>typealias 用来给类型其别名 <code>typealias Byte = Int8</code></li></ol><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ol><li><p>枚举的用法</p> <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Direction</span>&#123;</span></span><br><span class="line">       <span class="keyword">case</span> north</span><br><span class="line">       <span class="keyword">case</span> south</span><br><span class="line">       <span class="keyword">case</span> east</span><br><span class="line">       <span class="keyword">case</span> west</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关联值：枚举的成员值和其他类型的值关联存储在一起</p></li><li>原始值：枚举成员可以使用相同类型的默认值预先对应，这个默认值叫做原始值，定义方法：在枚举类型后面指定类型</li><li>所以：枚举相关的名称有：成员值、原始值（不占用枚举变量的内存）、关联值</li><li>隐式原始值： 如果枚举的原始值类型是Int、Stirng，swift会自动分配原始值</li><li>递归枚举： indirect关键字指定</li><li>MemoryLayout ： stride分配内存， size 实际用到的大小、 alignment对齐参数 </li></ol><h2 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h2><ol><li>在类型后面添加问号来定义一个可选类型</li><li>如果为nil：那么它是一个空盒子</li><li>如果不为nil，那么盒子里面装的是被包装类型的数据</li><li>使用感叹号取出盒子中包装的值取出来—强制解包</li><li>如果对nil的可选项进行强制解包会产生运行错误。</li><li>判断可选项是否包含值 <code>if num != nil</code></li><li>可选绑定：如果包含值，自动解包，赋值给临时变量，返回true，否则返回false</li><li>空合并运算符 <code>a ?? b</code>。a是可选项、b可以是可选项，也可以不是、ab类型相同、如果b不是可选项，返回a会自动解包。</li><li>guard 如果条件为false时就执行大括号中的代码；如果条件为true，跳过guard语句；guard绑定的常量变量外层作用域中也能使用。</li><li>可选的本质是枚举  </li></ol><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ol><li>一旦结构体定义时定义了初始化器， 编译器就不会再帮自动生成初始化器</li><li>如果类的所有成员都在定义的时候指定了初始值，编译器会为类生成无参的初始化器</li><li>结构体是值类型，类是引用类型</li><li>值类型赋值，是直接将所有的内容拷贝一份，是深拷贝</li><li>引用类型赋值： 是将内存地址拷贝一份</li><li><p>对象的堆空间的申请过程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class.__allocating_init()</span><br><span class="line">libswiftCore<span class="selector-class">.dylib</span>: _swift_allocObject_</span><br><span class="line">libswiftCore<span class="selector-class">.dylib</span>: _swift_slowAlloc_</span><br><span class="line">libsystem_malloc<span class="selector-class">.dylib</span>: malloc</span><br><span class="line">``</span><br></pre></td></tr></table></figure></li><li><p>malloc函数分配的内存大小是16的倍数</p></li><li>通过<code>class_getInstancSize</code>可以得知：类的对象至少需要占用多少内存</li><li>方法占用内存吗？不占用</li></ol><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的结构如下：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="params">(参数列表)</span>-&gt;</span> 返回值 <span class="keyword">in</span></span><br><span class="line">    函数体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>尾随闭包简化函数调用，增强可读性。闭包作为函数的最后一个参数使用时</li><li>闭包： 一个函数和它所捕获的变量、常量环境组合起来，称为闭包</li><li>自动闭包  <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> @autoclosure 会将<span class="number">20</span>封装成闭包 &#123;<span class="number">20</span>&#125;</span><br><span class="line"><span class="number">2.</span> 只支持()-&gt;T格式的函数 </span><br><span class="line"><span class="number">3.</span> 空合并运算符只用了autoclosure技术</span><br><span class="line"><span class="number">4.</span> 有无autoclosure构成了函数重载</span><br><span class="line"><span class="number">5.</span> 使用autoclosure的地方最好注明，这个值会被延迟执行</span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Circle &#123;</span><br><span class="line">    var radius: Double</span><br><span class="line">    var diameter: Double &#123;</span><br><span class="line">        <span class="builtin-name">set</span>(newDiameter) &#123;</span><br><span class="line">           <span class="built_in"> radius </span>= newDiameter/2</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="builtin-name">get</span> &#123;</span><br><span class="line">            radius<span class="number">*2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义计算属性只能用var，不能用let </li><li>延迟存储属性： 第一次用到的时候才进行初始化，lazy属性必须是var，let必须在实例初始化完成之前就拥有值，所以lazy和let是互斥的。多线程不安全</li><li>当结构体包含一个延迟存储属性时，只有var才能访问延迟存储属性，因为延迟粗才能属性会改变结构体的内存</li><li><p>可以为非lay的var存储属性设置属性观察器  </p> <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> radius: <span class="type">Double</span> &#123;</span><br><span class="line">           <span class="keyword">willSet</span> &#123;</span><br><span class="line">               <span class="built_in">print</span>(<span class="string">"willset"</span>)</span><br><span class="line">           &#125; </span><br><span class="line">           disSet &#123;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>willSet 会传递新值，didSet会传递旧值</p></li><li>在初始化器中设置属性值不会触发willSet和didSet</li><li>在属性定义时设置初始值也不会触发willSet和didSet</li><li>属性观测器、计算属性的功能同样可以应用在全局变量、局部变量上</li></ol><h3 id="inout的本质总结"><a href="#inout的本质总结" class="headerlink" title="inout的本质总结"></a>inout的本质总结</h3><p>如果实参有物理内存地址，且没有设置属性观测器： 直接将实参的内存地址传入函数(实参进行引用传递)</p><p>如果实参是计算属性或者设置了属性观测器： 采用copy in copy out的做法</p><ol><li>调用该函数时，先复制实参的值，参数副本[get] </li><li>将副本的内存地址传入函数(副本进行引用传递)， 在函数内部可以修改副本的值</li><li>函数返回后，再将副本的值覆盖实参的值[set]</li></ol><p>所以： inout的本质就是引用传递(地址传递)</p><p>可以通过static 定义类型属性，在类中，也可以通过class定义类型属性</p><p>类型属性： 类型存储属性默认是lazy的，多线程安全，不需要设定初始值，应为类对象没有向实例一样的初始化器。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>重写属性：</p><ol><li>子类可以将父类的属性(存储、计算)重写为计算属性</li><li>子类不可以将父类属性重写为存储属性</li><li>只能重写var属性，不能重写let属性</li><li>子类重写后的属性权限不能小于父类属性的权限<ol><li>如果父类属性是只读的，那么子类重写后的属性可以是只读的，也可以是可读写的</li><li>如果父类属性是可读写的，那么子类重写后的属性必须是可读写的</li></ol></li><li>可以在子类中为父类属性(除只读计算属性、let属性)增加属性观测器</li><li>被final修饰的方法、小标、属性禁止被重写，被final修饰的类禁止被继承</li></ol><h2 id="初始化器"><a href="#初始化器" class="headerlink" title="初始化器"></a>初始化器</h2><ol><li>类、结构体、枚举都可以定义初始化器</li><li>类有两种初始化器： 指定初始化器、便捷初始化器</li></ol><h3 id="初始化器相互调用规则："><a href="#初始化器相互调用规则：" class="headerlink" title="初始化器相互调用规则："></a>初始化器相互调用规则：</h3><ol><li>指定初始化器必须从他的直系父类条用指定初始化器</li><li>便捷初始化器必须从相同的类中调用另一个初始化器</li><li>便捷初始化器最终必须调用一个指定初始化器</li></ol><h3 id="两段式初始化："><a href="#两段式初始化：" class="headerlink" title="两段式初始化："></a>两段式初始化：</h3><ol><li>外层调用指定、便捷初始化器</li><li>分配内存给实例，但并未初始化</li><li>指定初始化器确保当前类定义的存储属性都初始化</li><li>指定初始化器调用父类的指定初始化器，不断向上调用，形成初始化器链</li></ol><p>第二阶段：设置新的存储属性</p><ol><li>从顶部初始化器往下，链中每一个指定初始化器有机会进一步定制实例</li><li>初始化器能够使用self</li><li>最终，链中任何便捷初始化器都有机会定制实例及使用self</li></ol><h3 id="重写："><a href="#重写：" class="headerlink" title="重写："></a>重写：</h3><p>如果子类写一个匹配父类便捷初始化器的初始化器，不用加水override，因为父类的便捷初始化器永远不会通过子类直接调用，因为，严格来说，子类无法重写父类的便捷初始化器。</p><h3 id="自动继承："><a href="#自动继承：" class="headerlink" title="自动继承："></a>自动继承：</h3><ol><li>如果子类没有自定义任何指定初始化器，会自动继承父类所有指定初始化器</li><li>如果子类提供父类所有指定初始化器的实现(用么通过方式1继承，要么重写)，子类自动继承所有父类便捷初始化器</li><li>就算子类添加了更多的便捷初始化器，这些规则仍然适用</li><li>子类以便捷初始化器的形式重写父类的指定初始化器，也可以作为满足规则2的一部分。</li></ol><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><ol><li>用required修饰指定初始化器，表明所有子类都必须实现该初始化器(通过继承或者重写实现)</li><li>如果子类重写了required初始化器，也不需加上required ，不用加override</li></ol><h3 id="属性观测器"><a href="#属性观测器" class="headerlink" title="属性观测器"></a>属性观测器</h3><p>父类的属性在它自己的初始化器中赋值不会触发属性观测器，单在子类的初始化器中赋值会触发</p><h3 id="可失败初始化器"><a href="#可失败初始化器" class="headerlink" title="可失败初始化器"></a>可失败初始化器</h3><ol><li>不允许同时定义参数标签、参数个数、参数类型相同的可失败初始化器和非可失败初始化器</li><li>可以使用init！定义隐式解包的可失败初始化器</li><li>可失败初始化器可以调用非可失败初始化器、非可失败初始化器调用可失败初始化器需要进行解包</li><li>如果初始化器调用一个可失败初始化器导致失败，那么整个初始化过程都失败，并且之后的代码都停止执行</li><li>可以用一个非可失败初始化器重写一个可失败初始化器，反过来不行</li></ol><h3 id="反初始化器"><a href="#反初始化器" class="headerlink" title="反初始化器"></a>反初始化器</h3><ol><li>deinit不接受任何参数，不能写小括号，不能自行调用</li><li>父类的deinit能被子类继承</li><li>子类的deinit实现执行完毕后，会调用父类的deinit</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><h3 id="协议中的属性"><a href="#协议中的属性" class="headerlink" title="协议中的属性"></a>协议中的属性</h3><ol><li>必须用var关键字，为啥？</li><li>实现协议时的属性权限不小于协议中定义的属性权限</li><li>get、set 用var存储属性或get、set计算属性实现</li><li>协议定义get 用任何属性都可以实现</li></ol><p>协议中使用static定义类型方法、类型属性、类型下标</p><ol><li>协议中可以定义初始化器init</li><li>非final类实现时必须加上required</li><li>如果从协议实现的初始化器，刚好是重写了父类的指定初始化器，那么这个初始化必须同时加上requied 、 override</li></ol><h3 id="Any-、AnyObject"><a href="#Any-、AnyObject" class="headerlink" title="Any 、AnyObject"></a>Any 、AnyObject</h3><ol><li>Any 任意类型</li><li>AnyObject 任意类类型，协议后天写上AnyObject代表只有类能准守这个协议</li><li>在协议后面写上class也代表只有类能准守这个协议</li><li>is用来判断是否某种类型， as 用作强制类型转换</li><li>X.self、 X.Type、 AnyClass ，X.self 是一个原类型的指针，metadata存放这类型相关的信息</li><li>X.self 属于X.type类型  </li><li>Self 一般用作返回值类型，限定返回值跟方法调用者必须是同一类型</li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>throw抛出自定义Error</li><li>可能抛出Erro的函数必须加上throws声明</li><li>需要使用try调用可能会抛出Error的函数</li><li>使用do catch 捕获Error</li><li>rethrow 函数本身不会抛出异常，但调用闭包参数抛出异常</li><li>defer 用来定义任何方式(抛出错误、return)离开代码块前必须执行的代码</li><li>defer的顺序于定义的顺序相反</li><li>不得不实现，但不希望别人调用，使用fatalError</li><li>局部作用域使用do 关键字</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>将类型参数化，提高代码的复用率，减少代码量</p><ol><li>泛型函数赋值给变量，必要有意思  <code>var fn:(Int,Double)-&gt;() = test</code></li><li>关联类型(给协议中用到的类型定义一个占位名称)</li><li>类型约束</li><li>如果协议中有关联类型，作为返回值，报错？ 因为不知道具体返回的类型中的关联类型是什么，所以就有了不透明类型</li><li>使用some 声明一个不透明类型</li><li>some限制只能返回一种类型</li><li>可选项的本质是枚举 。none 0、 some 1</li></ol><h2 id="String、Array"><a href="#String、Array" class="headerlink" title="String、Array"></a>String、Array</h2><ol><li>代码区、 常量区、全局区、 堆空间、栈空间、 动态库</li><li>符号的延迟绑定通过dyld_stub_binder完成</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>如果希望自定义初始化器的同时，编译器也能够生成默认初始化器</p><ol><li>可以在扩展中编写自定义初始化器</li><li>required 初始化器不不能卸载扩展中</li><li>扩展可以给协议提供默认实现， 也间距实现可选协议的效果</li><li>扩展可以给协议扩充《协议中从未声明过的方法》</li><li>复合条件才能扩展</li></ol><h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><ol><li>五个访问级别  open、 public、 internal、 fileprivate、private </li><li>访问级别使用的规则： 一个实体不可以被更低访问级别的实体定义</li><li>元组类型的访问级别是所有成员类型最低的那个</li><li>泛型类型的访问级别是类型的访问级别以及所有泛型类型参数的访问级别中最低的那个</li><li>子类重写成员的访问级别&gt;=子类的访问级别或者父类被重写成员的访问级别</li><li>可以给setter单独设置一个比getter更低的访问级别，泳衣限制写的权限</li><li>不能给枚举的每个case单独设置访问级别，每个case自动接收enum的访问级别</li><li>协议中定义的要求自动接收协议的访问级别，不能单独设置访问级别，public协议定义的要求也是public的</li><li>如果没有显示设置扩展的访问级别，扩展添加的成员自动接收扩展的访问级别，可以单独给扩展添加的成员设置访问级别</li><li>不能给用于准守协议的扩展显示设置扩展的访问级别</li><li>在同一文件中的扩展，可以写成类似多个部分的类型声明，在原本的声明中声明一个私有成员，可以在统一文件的扩展中访问它</li><li>将方法赋值给let或者var ，这个也比较有意思  <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn3: <span class="function"><span class="params">(Persion)</span> -&gt;</span> <span class="function"><span class="params">((Int) -&gt; ())</span> = <span class="title">Persion</span>.<span class="title">run</span> ///将实例方法赋值给变量</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ol><li><code>UnsafePointer&lt;Pointee&gt;</code>  类似于 <code>const Pointee *</code></li><li><code>UnsafeMutablePointer&lt;Pointee&gt;</code> 类似于 <code>Pointee *</code></li><li><code>UnsafeRawPointer</code>  类似于 <code>const void *</code></li><li><code>UnsafeMutableRawPointer</code> 类似于 <code>void *</code></li></ol><ol><li>获取变量的指针 <code>withUnsafeMutablePointer(to: &amp;age){return $0}</code></li><li><p>获取执行堆空间实例的指针</p> <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">ptr</span> = withUnsafePointer(to: &amp;person)&#123;<span class="type">UnsafeRawPointer</span>($<span class="number">0</span>)&#125;</span><br><span class="line"><span class="keyword">var</span> heapPtr = <span class="type">UnsafeRawPointer</span>(bitPattern: <span class="keyword">ptr</span>.load(<span class="keyword">as</span>:<span class="type">Uint</span>.self))</span><br></pre></td></tr></table></figure></li><li><p>创建指针 <code>var ptr = malloc(16)&#39;</code>var ptr = UnsafeMutableRawPointer.allocate(byteCount:16,alignment:1)`</p></li><li>指针之间的切换<code>ptr.assumingMemoryBound(to:Int.self).pontee = 11</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 测试泛型指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testPointer</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(<span class="number">_</span> ptr: UnsafeMutablePointer&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">            ptr.pointee += <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">test2</span><span class="params">(<span class="number">_</span> ptr: UnsafePointer&lt;Int&gt;)</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(ptr.pointee)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        test1(&amp;age)</span><br><span class="line">        test2(&amp;age)</span><br><span class="line">        <span class="built_in">print</span>(age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 测试raw 指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">testRawPointer</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">10</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">test3</span><span class="params">(<span class="number">_</span> ptr: UnsafeMutableRawPointer)</span></span> &#123;</span><br><span class="line">            ptr.storeBytes(of: <span class="number">20</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">test4</span><span class="params">(<span class="number">_</span> ptr: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(ptr.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        test3(&amp;age)</span><br><span class="line">        test4(&amp;age)</span><br><span class="line">        <span class="built_in">print</span>(age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///获取指向自动变量的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getAutoVarPointer</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="keyword">var</span> age = <span class="number">11</span></span><br><span class="line">        <span class="keyword">var</span> ptr1 = <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;age) &#123; $<span class="number">0</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> ptr2 = <span class="built_in">withUnsafePointer</span>(to: &amp;age) &#123;$<span class="number">0</span>&#125;</span><br><span class="line">        ptr1.pointee = <span class="number">22</span></span><br><span class="line">        <span class="built_in">print</span>(ptr2.pointee)</span><br><span class="line">        <span class="built_in">print</span>(age)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> ptr3 = <span class="built_in">withUnsafeMutablePointer</span>(to: &amp;age) &#123; <span class="type">UnsafeMutableRawPointer</span>($<span class="number">0</span>)&#125;</span><br><span class="line">        <span class="keyword">var</span> ptr4 = <span class="built_in">withUnsafePointer</span>(to: &amp;age) &#123; <span class="type">UnsafeRawPointer</span>($<span class="number">0</span>)  &#125;</span><br><span class="line">        ptr3.storeBytes(of: <span class="number">33</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        <span class="built_in">print</span>(ptr4.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        <span class="built_in">print</span>(age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///获取指向堆空间实例的指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getHeapVarPointer</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;  &#125;</span><br><span class="line">        <span class="keyword">var</span> persion = <span class="type">Persion</span>()</span><br><span class="line">        <span class="keyword">var</span> ptr = <span class="built_in">withUnsafePointer</span>(to: &amp;persion) &#123; <span class="type">UnsafeRawPointer</span>($<span class="number">0</span>) &#125;</span><br><span class="line">        <span class="keyword">var</span> heapPtr = <span class="type">UnsafeRawPointer</span>(bitPattern: ptr.load(<span class="keyword">as</span>: <span class="type">UInt</span>.<span class="keyword">self</span>))</span><br><span class="line">        <span class="built_in">print</span>(heapPtr!)</span><br><span class="line">        <span class="built_in">print</span>(persion)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///使用地址创建指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createAddressPointer</span><span class="params">()</span></span> -&gt; () &#123;</span><br><span class="line">        <span class="keyword">var</span> ptr = <span class="type">UnsafeRawPointer</span>(bitPattern: <span class="number">0x1122</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> ptr1 = malloc(<span class="number">16</span>)</span><br><span class="line">        <span class="comment">//存</span></span><br><span class="line">        ptr1?.storeBytes(of: <span class="number">11</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        ptr1?.storeBytes(of: <span class="number">22</span>, toByteOffset: <span class="number">8</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取</span></span><br><span class="line">        <span class="built_in">print</span>(ptr1?.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        <span class="built_in">print</span>(ptr1?.load(fromByteOffset: <span class="number">8</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//销毁</span></span><br><span class="line">        free(ptr1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 使用allocate 创建raw指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createRawPointerByAllocate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> ptr2 = <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存</span></span><br><span class="line">        ptr2.storeBytes(of: <span class="number">11</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        ptr2.advanced(by: <span class="number">8</span>).storeBytes(of: <span class="number">22</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读</span></span><br><span class="line">        <span class="built_in">print</span>(ptr2.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        <span class="built_in">print</span>(ptr2.advanced(by: <span class="number">8</span>).load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>))</span><br><span class="line">        ptr2.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///使用allocate 创建泛型指针</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">createTypePointerByAllocate</span><span class="params">()</span></span>  &#123;</span><br><span class="line">        <span class="keyword">var</span> ptr = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="number">3</span>)</span><br><span class="line">        ptr.initialize(to: <span class="number">11</span>)</span><br><span class="line">        ptr.successor().initialize(to: <span class="number">22</span>)</span><br><span class="line">        ptr.successor().successor().initialize(to: <span class="number">33</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(ptr.pointee)</span><br><span class="line">        <span class="built_in">print</span>((ptr+<span class="number">1</span>).pointee)</span><br><span class="line">        <span class="built_in">print</span>((ptr+<span class="number">2</span>).pointee)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(ptr[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(ptr[<span class="number">1</span>])</span><br><span class="line">        <span class="built_in">print</span>(ptr[<span class="number">2</span>])</span><br><span class="line">        ptr.deinitialize(<span class="built_in">count</span>: <span class="number">3</span>)</span><br><span class="line">        ptr.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///指针之间的切换</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">convertPointer</span><span class="params">()</span></span>  &#123;</span><br><span class="line">        <span class="keyword">var</span> ptr = <span class="type">UnsafeMutableRawPointer</span>.allocate(byteCount: <span class="number">16</span>, alignment: <span class="number">1</span>)</span><br><span class="line">        ptr.assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>).pointee = <span class="number">11</span></span><br><span class="line">        (ptr+<span class="number">8</span>).assumingMemoryBound(to: <span class="type">Int</span>.<span class="keyword">self</span>).pointee = <span class="number">22</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">unsafeBitCast</span>(ptr, to: <span class="type">UnsafePointer</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">self</span>).pointee)  <span class="comment">//11</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">unsafeBitCast</span>(ptr+<span class="number">8</span>, to: <span class="type">UnsafePointer</span>&lt;<span class="type">Double</span>&gt;.<span class="keyword">self</span>).pointee)</span><br><span class="line">        ptr.deallocate()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;函数 、枚举、可选项等学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="视频学习记录" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Swift" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift简介</title>
    <link href="http://yoursite.com/wiki/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/2_swift%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/wiki/视频学习记录/Swift/2_swift简介/</id>
    <published>2020-01-08T02:07:12.000Z</published>
    <updated>2020-01-08T06:59:15.548Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言pdf 学习记录</p><a id="more"></a><h2 id="swift的版本"><a href="#swift的版本" class="headerlink" title="swift的版本"></a>swift的版本</h2><ol><li>API(application programing interface) 应用程序编程接口，源码和库之间的接口</li><li>ABI(application Binary Interface) 应用程序二进制接口，应用程序与操作系统之间的底层接口，涉及的内容有：目标文件的格式，数据类型的大小布局对齐、函数调用的约定。</li></ol><h2 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h2><p>swift code -&gt; swift AST -&gt; Raw Swift IL -&gt; Canonical swift IL -&gt; LLVM IR -&gt; assemble</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言pdf 学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="视频学习记录" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Swift" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>汇编语言</title>
    <link href="http://yoursite.com/wiki/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/1_%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/wiki/视频学习记录/Swift/1_汇编语言/</id>
    <published>2020-01-08T02:07:12.000Z</published>
    <updated>2020-01-08T06:35:58.317Z</updated>
    
    <content type="html"><![CDATA[<p>汇编语言pdf 学习记录</p><a id="more"></a><h2 id="寄存器和内存"><a href="#寄存器和内存" class="headerlink" title="寄存器和内存"></a>寄存器和内存</h2><ol><li>通常，CPU会先将内存中的数据存储到寄存器中，然后再对寄存器中的数据进行运算</li><li><p>假设对内存中的数据做加1处理  </p><ul><li>cpu首先会将内存空间的值放到rax中， movq  内存地址  %rax</li><li>然后让寄存器和1相加， addq  $0x1,  %rax</li><li>最后将值赋值给内存空间： movq %rax, 内存空间</li></ul></li></ol><h2 id="编程语言的发展"><a href="#编程语言的发展" class="headerlink" title="编程语言的发展"></a>编程语言的发展</h2><ol><li>机器语言  0，1 组成</li><li>汇编语言 assemble language  用符号代替了0，1 比机器语言便于阅读和记忆 </li><li>高级语言</li></ol><h2 id="汇编语言的种类"><a href="#汇编语言的种类" class="headerlink" title="汇编语言的种类"></a>汇编语言的种类</h2><ol><li>intel windows派系</li><li>AT&amp;T Unix派系</li></ol><p>IOS开发者</p><ol><li>AT&amp;T  IOS模拟器</li><li>ARM IOS真机</li></ol><h2 id="常见汇编"><a href="#常见汇编" class="headerlink" title="常见汇编"></a>常见汇编</h2><table><thead><tr><th>名称</th><th>AT&amp;T汇编</th><th>说明</th></tr></thead><tbody><tr><td>寄存器的名称</td><td>%rax</td><td></td></tr><tr><td>操作数顺序</td><td>movq %rax, %rdx</td><td>将rax的值赋值给rdx</td></tr><tr><td>常数立即数</td><td>movq $0x10, %rax</td><td>将0x10赋值给rax</td></tr><tr><td>内存赋值</td><td>movq $0ax, 0x1ff7(%rip)</td><td>将0xa赋值给地址未rip+ 0x1ff7 的内存空间</td></tr><tr><td>取值内存</td><td>leaq -0x18(%rbp), %rax</td><td>将rbp -0x18 这个地址赋值给rax</td></tr><tr><td>操作数长度</td><td>movl,movb,mobw</td><td>b byte,s short 16bit,w word 16bit,l long 32 bit,q quad 64 bits</td></tr></tbody></table><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>有16个通用寄存器</p><ol><li>rax、rbx、rcx、rdx、rsi、rdi，rbp、rsp</li><li>r8、r9 、r10、 r11、r12、r13、r14、r15</li></ol><p>寄存器的具体用途</p><ol><li>rax、rdx常用作函数返回值使用</li><li>rdi、rsi、rdx、rcx、r8、r9 等寄存器常用语存放函数的参数</li><li>rbp、rsp 用于栈操作</li><li>rip作为指令指针<ol><li>存储着CPU下一条要执行的指令地址</li><li>一旦CPU读取一条指令，rip会自动指向下一条指令</li></ol></li></ol><h2 id="lldb常用指令"><a href="#lldb常用指令" class="headerlink" title="lldb常用指令"></a>lldb常用指令</h2><ol><li>读取寄存器的值 ： register read/格式  register read/x</li><li>修改寄存器的值 register write 寄存器名称 数值  register wirte rax 0</li><li>读取内存中的值 x/数量 格式 字节大小 内存地址 —- x/3xw 0x1000000</li><li>修改内存中的值 memory write 内存地址 数值 —-memory write 0x00000 10</li></ol><p>其中格式：</p><ol><li>x 是16进制</li><li>f 浮点</li><li>d 十进制</li></ol><p>其中的字节大小</p><ol><li>b  byte 1字节</li><li>h half word 2字节</li><li>w word 4字节</li><li>g gaint word 8字节</li></ol><p>断定指令</p><ol><li>thred step-over next n  单步运行，把子函数整体异步执行(源码级别)</li><li>thrad step-in step s 单不运行，把子函数当做整体异步执行(汇编级别)</li><li>threa step-ins-over nexti ni 单步运行，把子函数当做整体异步执行(汇编级别)</li><li>thread step-inst、stepi、si 单步运行，遇到子函数进入子函数(汇编解包)</li><li>thread step-out、finish 直接运行完当前函数的所有代码，返回到上一个函数，遇到断点卡住</li></ol><h2 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h2><ol><li>内存格式是0x1bc(%rip)，一般是全局变量，全局区(数据段)</li><li>内存地址格式为-0x78(%rbp),一般是局部变量，栈空间</li><li>内存地址格式为：0x10(%rax)， 一般是堆空间，因为mallc 返回的地址存储在rax中 </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;汇编语言pdf 学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="视频学习记录" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Swift" scheme="http://yoursite.com/categories/%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/Swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>YYCache 源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/YYCache/YYCache/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/YYCache/YYCache/</id>
    <published>2020-01-02T04:07:12.000Z</published>
    <updated>2020-01-02T11:22:12.208Z</updated>
    
    <content type="html"><![CDATA[<p>学习YYCache开源库</p><a id="more"></a><h2 id="一、基本结构"><a href="#一、基本结构" class="headerlink" title="一、基本结构"></a>一、基本结构</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        -------YYCache------</span><br><span class="line">        |<span class="string">                   </span>|</span><br><span class="line">        |<span class="string">                   </span>|</span><br><span class="line">YYMemoryCache      YYDiskCache(磁盘缓存的接口层)</span><br><span class="line">                            |</span><br><span class="line"><span class="string">                            </span>|</span><br><span class="line">          YYKVStorage实现层(小数据SQLite存储、大数据文件存储)</span><br><span class="line">                            |</span><br><span class="line"><span class="string">                            </span>|</span><br><span class="line">                 ------------------------</span><br><span class="line">                 |<span class="string">                       </span>|</span><br><span class="line">                 |<span class="string">                       </span>|</span><br><span class="line">       小数据SQLite存储          大数据文件存储，SQLite辅助存储卫星数据，</span><br><span class="line">                               包括修改时间、访问时间、key等数据,方便查找</span><br></pre></td></tr></table></figure><h2 id="二、内存缓存"><a href="#二、内存缓存" class="headerlink" title="二、内存缓存"></a>二、内存缓存</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>使用双向链表实现了LRU缓存策略，数据结构采用自顶向下的方式说明：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@implementation YYMemoryCache &#123;</span><br><span class="line">    pthread_mutex_t <span class="variable">_lock</span>;</span><br><span class="line">    <span class="variable">_YYLinkedMap</span> *<span class="variable">_lru</span>;</span><br><span class="line">    dispatch_queue_t <span class="variable">_queue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">其中<span class="variable">_lru</span>就是LRU的具体结构</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="variable">_YYLinkedMap</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    CFMutableDictionaryRef <span class="variable">_dic</span>; <span class="comment">// do not set object directly</span></span><br><span class="line">    NSUInteger <span class="variable">_totalCost</span>;</span><br><span class="line">    NSUInteger <span class="variable">_totalCount</span>;</span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_head</span>; <span class="comment">// MRU, do not change it directly</span></span><br><span class="line">    <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_tail</span>; <span class="comment">// LRU, do not change it directly</span></span><br><span class="line">    BOOL <span class="variable">_releaseOnMainThread</span>;</span><br><span class="line">    BOOL <span class="variable">_releaseAsynchronously</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">分为两个结构：</span><br><span class="line"></span><br><span class="line">一个是hash表<span class="variable">_dic</span>用作快速查找，以「Key：<span class="variable">_YYLinkedMapNode</span>」的形式存储</span><br><span class="line">一个是双向链表，用<span class="variable">_head</span>、<span class="variable">_tail</span>存储头尾节点，为了实现LRU缓存淘汰算法，头结点插入，尾结点删除</span><br></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@interface <span class="variable">_YYLinkedMapNode</span> : NSObject &#123;</span><br><span class="line">    @package</span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_prev</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="variable">__unsafe_unretained</span> <span class="variable">_YYLinkedMapNode</span> *<span class="variable">_next</span>; <span class="comment">// retained by dic</span></span><br><span class="line">    id <span class="variable">_key</span>;</span><br><span class="line">    id <span class="variable">_value</span>;</span><br><span class="line">    NSUInteger <span class="variable">_cost</span>;</span><br><span class="line">    NSTimeInterval <span class="variable">_time</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这个是具体的节点信息</span><br></pre></td></tr></table></figure><h3 id="添加逻辑"><a href="#添加逻辑" class="headerlink" title="添加逻辑"></a>添加逻辑</h3><ol><li>从_dic中找出节点</li><li>如果节点已经存在，移到链表头（最新访问）</li><li>如果_dic中没有，创建新节点，头插</li><li>最后，如果超过容量，循环删除尾结点</li></ol><h3 id="删除逻辑"><a href="#删除逻辑" class="headerlink" title="删除逻辑"></a>删除逻辑</h3><p>在_dic中通过key找到节点（_YYLinkedMapNode），在_dic和链表中同时删除</p><h3 id="按照时间删除"><a href="#按照时间删除" class="headerlink" title="按照时间删除"></a>按照时间删除</h3><p>循环的取出尾结点，如果早于指定时间，删除，直到尾节点时间晚于指定时间。</p><h3 id="按照成本删除"><a href="#按照成本删除" class="headerlink" title="按照成本删除"></a>按照成本删除</h3><p>如果总成本大于指定的cost，循环的取出尾结点，删除。直到总成本小于cost</p><h3 id="YYCache没有使用NSCache的原因"><a href="#YYCache没有使用NSCache的原因" class="headerlink" title="YYCache没有使用NSCache的原因"></a>YYCache没有使用NSCache的原因</h3><ol><li>It uses LRU (least-recently-used) to remove objects; NSCache’s eviction method is non-deterministic.</li><li>it can be controlled by cost, count and age; NSCache’s limits are imprecise.</li><li>It can be configured to automatically evict objects when receive memory warning or app enter background.</li></ol><h2 id="三、磁盘缓存"><a href="#三、磁盘缓存" class="headerlink" title="三、磁盘缓存"></a>三、磁盘缓存</h2><h3 id="磁盘存储结构"><a href="#磁盘存储结构" class="headerlink" title="磁盘存储结构"></a>磁盘存储结构</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/path/</span></span><br><span class="line">     <span class="string">/manifest.sqlite</span>   存储记录的相关信息</span><br><span class="line">     <span class="string">/manifest.sqlite-shm</span>  共享内存使用的？</span><br><span class="line">     <span class="string">/manifest.sqlite-wal</span>  wal模式恢复数据库使用</span><br><span class="line">     <span class="string">/data/</span> 大数据实际存储位置</span><br><span class="line">          <span class="string">/e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line">          <span class="string">/e10adc3949ba59abbe56e057f20f883e</span></span><br><span class="line">     <span class="string">/trash/</span> 删除的时候会首先移动到这里</span><br><span class="line">           <span class="string">/unused_file_or_folder</span></span><br></pre></td></tr></table></figure><p>缓存对象表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> manifest (</span><br><span class="line">    <span class="keyword">key</span>                 <span class="built_in">text</span>,</span><br><span class="line">    filename            <span class="built_in">text</span>,</span><br><span class="line">    <span class="keyword">size</span>                <span class="built_in">integer</span>,</span><br><span class="line">    inline_data         <span class="built_in">blob</span>,</span><br><span class="line">    modification_time   <span class="built_in">integer</span>,</span><br><span class="line">    last_access_time    <span class="built_in">integer</span>,</span><br><span class="line">    extended_data       <span class="built_in">blob</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">key</span>)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">YYKVStorage</span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">|-----数据的size小于阈值存储与SQLite中，也就是value直接存储在表中</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">|-----没有限制：SQLite和文件都存储   </span></span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">|-----大于阈值：使用文件存储Value，表中只存储卫星数据(修改时间、访问时间、key等)，</span></span><br><span class="line">便于查找、删除</span><br></pre></td></tr></table></figure><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><ol><li>如果存储方式是文件，将数据写入文件，进入第三步，更新SQLite中的卫星数据</li><li>如果存储类型是SQLite，进入第三步存储数据</li><li>使用SQL语句存储：insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);如果是存储卫星数据inline_data为NULL。</li></ol><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ol><li>如果存储方式是文件，将数据从文件删除，进入第三步删除SQLite中的卫星数据</li><li>如果存储类型是SQLite，进入第三步直接删除数据</li><li>使用SQL语句存储：insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);如果是存储卫星数据inline_data为NULL。</li></ol><h3 id="删除大小大于size的记录"><a href="#删除大小大于size的记录" class="headerlink" title="删除大小大于size的记录"></a>删除大小大于size的记录</h3><ol><li>使用SQL找出条目的名称 select filename from manifest where size &gt; ?1 and filename is not null;</li><li>删除文件</li><li>删除条目 delete from manifest where size &gt; ?1;</li></ol><h3 id="删除时间早于time的对象"><a href="#删除时间早于time的对象" class="headerlink" title="删除时间早于time的对象"></a>删除时间早于time的对象</h3><ol><li>数据库中找出时间（time）前修改的对象<br>select filename from manifest where last_access_time &lt; ?1 and filename is not null;</li><li>删除文件</li><li>数据库中删除记录 delete from manifest where last_access_time &lt; ?1;</li></ol><h3 id="四、YYCache中使用的所有的SQL语句"><a href="#四、YYCache中使用的所有的SQL语句" class="headerlink" title="四、YYCache中使用的所有的SQL语句"></a>四、YYCache中使用的所有的SQL语句</h3><ol><li>建表：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pragma</span> journal_mode = wal; <span class="keyword">pragma</span> <span class="keyword">synchronous</span> = <span class="keyword">normal</span>; <span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> manifest (<span class="keyword">key</span> <span class="built_in">text</span>, filename <span class="built_in">text</span>, <span class="keyword">size</span> <span class="built_in">integer</span>, inline_data <span class="built_in">blob</span>, modification_time <span class="built_in">integer</span>, last_access_time <span class="built_in">integer</span>, extended_data <span class="built_in">blob</span>, primary <span class="keyword">key</span>(<span class="keyword">key</span>)); <span class="keyword">create</span> <span class="keyword">index</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="keyword">exists</span> last_access_time_idx <span class="keyword">on</span> manifest(last_access_time);</span><br></pre></td></tr></table></figure><ol><li>新增一条记录</li></ol><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert <span class="keyword">or</span> replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (<span class="string">?1</span>, <span class="string">?2</span>, <span class="string">?3</span>, <span class="string">?4</span>, <span class="string">?5</span>, <span class="string">?6</span>, <span class="string">?7</span>);</span><br></pre></td></tr></table></figure><ol><li>更新一条记录的修改时间</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> manifest <span class="keyword">set</span> last_access_time = ?<span class="number">1</span> <span class="keyword">where</span> <span class="keyword">key</span> = ?<span class="number">2</span>;</span><br></pre></td></tr></table></figure><ol><li>删除记录为key的一个对象：</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> manifest <span class="keyword">where</span> <span class="keyword">key</span> = ?<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>删除多个对象</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> manifest <span class="keyword">where</span> <span class="keyword">key</span> <span class="keyword">in</span> (%@);</span><br></pre></td></tr></table></figure><ol><li>删除szie大于某个值的记录</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> manifest <span class="keyword">where</span> <span class="keyword">size</span> &gt; ?<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>删除时间久的对象</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> manifest <span class="keyword">where</span> last_access_time &lt; ?<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>查找某个对象</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">key</span>, filename, <span class="keyword">size</span>, modification_time, last_access_time, extended_data <span class="keyword">from</span> manifest <span class="keyword">where</span> <span class="keyword">key</span> = ?<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>查找大于size的记录的filename：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> filename <span class="keyword">from</span> manifest <span class="keyword">where</span> <span class="keyword">size</span> &gt; ?<span class="number">1</span> <span class="keyword">and</span> filename <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ol><li>查找修改时间久的指定个数对象：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">key</span>, filename, <span class="keyword">size</span> <span class="keyword">from</span> manifest <span class="keyword">order</span> <span class="keyword">by</span> last_access_time <span class="keyword">asc</span> <span class="keyword">limit</span> ?<span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li>获取存储的对象的总大小：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">sum</span>(<span class="keyword">size</span>) <span class="keyword">from</span> manifest;</span><br></pre></td></tr></table></figure><ol><li>获取存储数量：</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(*) <span class="keyword">from</span> manifest;</span><br></pre></td></tr></table></figure><h3 id="五、学习到的SQL知识"><a href="#五、学习到的SQL知识" class="headerlink" title="五、学习到的SQL知识"></a>五、学习到的SQL知识</h3><p>sqlite3_stmt 的理解，它就是prepared statement。表示编译过的SQL语句，SQL语句编译过才能执行（SQL语句类比为应用程序，将程序的代码编译后，才能执行）</p><p>sqlite3_stmt的生命周期：</p><ol><li>sqlite3_prepare_v2 创建 prepared statement</li><li>使用sqlite3_bind_* 向参数[parameters] 绑定值</li><li>使用sqlite3_step() 一次或多次执行SQL语句</li><li>使用 sqlite3_reset() 重置到第二步</li><li>使用sqlite3_finalize()销毁对象</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习YYCache开源库&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="YYCache" scheme="http://yoursite.com/categories/IOS/opensource/YYCache/"/>
    
    
      <category term="logan" scheme="http://yoursite.com/tags/logan/"/>
    
  </entry>
  
  <entry>
    <title>Universal Links</title>
    <link href="http://yoursite.com/wiki/IOS/%E6%9A%82%E6%97%A0%E5%88%86%E7%B1%BB/UniversalLinks/"/>
    <id>http://yoursite.com/wiki/IOS/暂无分类/UniversalLinks/</id>
    <published>2019-12-30T04:07:12.000Z</published>
    <updated>2020-01-02T11:02:55.846Z</updated>
    
    <content type="html"><![CDATA[<p>Universal Links  基本原理</p><a id="more"></a><h2 id="Universal-Links-基本原理"><a href="#Universal-Links-基本原理" class="headerlink" title="Universal Links  基本原理"></a>Universal Links  基本原理</h2><p><img src="/wiki/IOS/暂无分类/UniversalLinks/UniversalLinks.png" alt="Universal Links 记录"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Universal Links  基本原理&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="暂无分类" scheme="http://yoursite.com/categories/IOS/%E6%9A%82%E6%97%A0%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="Universal Links" scheme="http://yoursite.com/tags/Universal-Links/"/>
    
  </entry>
  
  <entry>
    <title>IOS 知识点总结</title>
    <link href="http://yoursite.com/wiki/IOS/Theory/IOS%20%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yoursite.com/wiki/IOS/Theory/IOS 知识点/</id>
    <published>2019-12-19T04:07:12.000Z</published>
    <updated>2020-01-06T11:18:20.749Z</updated>
    
    <content type="html"><![CDATA[<p>本文按总结IOS常用的知识点</p><a id="more"></a><h2 id="常用知识点"><a href="#常用知识点" class="headerlink" title="常用知识点"></a>常用知识点</h2><ol><li><a href="https://www.jianshu.com/p/5254f1277dba" rel="external nofollow noopener noreferrer" target="_blank">小结iOS中的copy</a></li><li><a href="https://mp.weixin.qq.com/s/0o0SS0Bds2vB6hDjQfEl4w" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者 2019 面试总结</a></li></ol><h2 id="学习过的知识"><a href="#学习过的知识" class="headerlink" title="学习过的知识"></a>学习过的知识</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性的设置方法</span><br><span class="line">objc_setProperty_nonatomic_copy</span><br><span class="line"><span class="symbol">copyWithZone:</span></span><br></pre></td></tr></table></figure><ol><li><a href="https://www.jianshu.com/p/644fdc7503bc" rel="external nofollow noopener noreferrer" target="_blank">GCD实现多个请求都完成之后返回结果</a></li><li><a href="https://www.jianshu.com/p/ea36e0f2e7ae" rel="external nofollow noopener noreferrer" target="_blank">质量监控-卡顿检测</a></li><li><a href="https://www.jianshu.com/p/cff4ba1f8a17" rel="external nofollow noopener noreferrer" target="_blank">iOS深拷贝和浅拷贝</a></li><li><a href="https://www.jianshu.com/p/6ea244222ee4" rel="external nofollow noopener noreferrer" target="_blank">[iOS] 打包原理及脚本自动打包的实现</a></li><li><a href="https://casatwy.com/modulization_in_action.html" rel="external nofollow noopener noreferrer" target="_blank">在现有工程中实施基于CTMediator的组件化方案</a></li><li><a href="https://casatwy.com/iOS-Modulization.html" rel="external nofollow noopener noreferrer" target="_blank">iOS应用架构谈 组件化方案</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文按总结IOS常用的知识点&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Theory" scheme="http://yoursite.com/categories/IOS/Theory/"/>
    
    
      <category term="IOS理论知识" scheme="http://yoursite.com/tags/IOS%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>IOS知识简洁版</title>
    <link href="http://yoursite.com/wiki/IOS/Theory/IOS%E7%9F%A5%E8%AF%86%E7%AE%80%E6%B4%81%E7%89%88/"/>
    <id>http://yoursite.com/wiki/IOS/Theory/IOS知识简洁版/</id>
    <published>2019-12-19T04:07:12.000Z</published>
    <updated>2020-01-08T10:12:40.555Z</updated>
    
    <content type="html"><![CDATA[<p>本文按总结IOS常用的知识点</p><a id="more"></a><h2 id="HTTP三次握手、四次挥手"><a href="#HTTP三次握手、四次挥手" class="headerlink" title="HTTP三次握手、四次挥手"></a>HTTP三次握手、四次挥手</h2><p>TCP是一种可靠的面向连接的协议，而UDP不是可靠的，或说是无连接的协议。</p><p>TCP 和UDP的区别：</p><ol><li>TCP的可靠性是强的，它是可靠的，连接性，是面向连接的，报文，是面向字节流的，效率是，传输效率低，双工性，全双工，流量控制是滑动窗口，拥塞控制是慢开始，拥塞避免，快重传，快恢复的，传输速度是慢的，应用场景是对效率要求低，对准确性要求高或者要求有连接的场景。</li><li>UDP的不是可靠的，无连接的，面向报文的，传输效率高的，一对一，一对多，多对一，多对多，流量控制，无，拥塞控制，无，但是传输速度是快的，应用场景是对效率要求高，对准确性要求低的。</li></ol><p>三次握手的过程：</p><ol><li>第一次握手是在建立连接，客户端发送连接请求报文段，把标有SYN的数据包发给服务器端即为接收端。</li><li>第二次握手是服务器端即接收端收到客户端的SYN的报文段，同时发送标有SYN/ACK的数据包。</li><li>第三次握手是客户端收到服务器端的SYN/ACK的数据包后，向服务器端发送标有ACK的数据包。</li></ol><p>四次挥手：</p><ol><li>第一次挥手：客户端设置seq和 ACK ,向服务器发送一个 FIN=1报文段。此时，（第一次挥手，FIN=1，seq=u）客户端进入 FIN_WAIT 状态，表示客户端没有数据要发送给服务端了。</li><li>第二次挥手：服务端收到了客户端发送的 FIN 报文段，向客户端回了一个 ACK 报文段。</li><li>第三次挥手：服务端向客户端发送FIN 报文段，请求关闭连接，同时服务端进入 LAST_ACK 状态。</li><li>第四次挥手：客户端收到服务端发送的 FIN 报文段后，向服务端发送 ACK 报文段,然后客户端进入 TIME_WAIT 状态。服务端收到客户端的 ACK 报文段以后，就关闭连接。此时，客户端等待 2MSL（指一个片段在网络中最大的存活时间）后依然没有收到回复，则说明服务端已经正常关闭，这样客户端就可以关闭连接了。</li></ol><p>参考链接： <a href="https://mp.weixin.qq.com/s/OYNDJ9tzfZCIdPMyts2jtw" rel="external nofollow noopener noreferrer" target="_blank">TCP的 “三次握手” 和“四次挥手”，到底是什么鬼？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文按总结IOS常用的知识点&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Theory" scheme="http://yoursite.com/categories/IOS/Theory/"/>
    
    
      <category term="IOS理论知识" scheme="http://yoursite.com/tags/IOS%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>AlamoFire 源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/AlamoFire/alamofile%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/AlamoFire/alamofile学习/</id>
    <published>2019-12-15T10:07:12.000Z</published>
    <updated>2019-12-17T09:36:31.304Z</updated>
    
    <content type="html"><![CDATA[<p>AlamoFire 学习</p><a id="more"></a><h2 id="一、AlamoFire-使用"><a href="#一、AlamoFire-使用" class="headerlink" title="一、AlamoFire 使用"></a>一、AlamoFire 使用</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///创建一个请求</span></span><br><span class="line">let request = AF.request(<span class="string">"https://httpbin.org/post"</span>, method: .post)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个完成Block，序列化器序列的类型String</span></span><br><span class="line">request<span class="selector-class">.responseString</span> &#123; response <span class="keyword">in</span></span><br><span class="line">                requestComplete(response<span class="selector-class">.response</span>, response.result)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>下面是两个函数的定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">                               method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               headers: HTTPHeaders? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               interceptor: RequestInterceptor? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">DataRequest</span> </span><br><span class="line">                               </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">responseString</span><span class="params">(queue: DispatchQueue = .main,</span></span></span><br><span class="line"><span class="function"><span class="params">                               encoding: String.Encoding? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               completionHandler: @escaping <span class="params">(AFDataResponse&lt;String&gt;)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Self</span></span><br></pre></td></tr></table></figure><p>首先我定的策略是农村包围城市，先了解request函数的参数中使用的类型，完事后，再进入函数体内部，了解原理。</p><h2 id="二、-AF命名空间"><a href="#二、-AF命名空间" class="headerlink" title="二、 AF命名空间"></a>二、 AF命名空间</h2><p>Alamofire是入口文件，文件中定义了一个枚举，充当命名空间的作用。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">AF</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> version = <span class="string">"5.0.0-rc.3"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">                               method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               headers: HTTPHeaders? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               interceptor: RequestInterceptor? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">DataRequest</span> &#123;</span><br><span class="line">                               ....</span><br><span class="line">                               &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候调用AF.request。防止request和其他的request冲突，包装在AF中，起到命名空间的作用。</p><h2 id="三、-URLConvertible"><a href="#三、-URLConvertible" class="headerlink" title="三、 URLConvertible"></a>三、 URLConvertible</h2><p>URLConvertible 是一个协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">URLConvertible</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">asURL</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个协议的作用是创建一个URL对象。并且String、URL、URLComponents结构都遵守了这个协议，那么， 好处是什么呢？</p><p>扩大了参数的类型，也就是说可以给request方法传递String、URL、URLComponents类型的参数，函数内部使用asURL方法统一获取URL对象。</p><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><p>请求方式定义为HTTPMethod结构体类型，封装了请求的方式。</p><h2 id="编码器"><a href="#编码器" class="headerlink" title="编码器"></a>编码器</h2><p>编码器定义一个协议，所有的编码器准守改协议 – ParameterEncoding</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ParameterEncoding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该协议定义了如何将请求参数编码到请求urlRequest中。</p><p>alamofire中定义了URLEncoding、JSONEncoding两种编码器实现了ParameterEncoding协议。</p><h3 id="URLEncoding-类"><a href="#URLEncoding-类" class="headerlink" title="URLEncoding 类"></a>URLEncoding 类</h3><p>遵守ParameterEncoding协议，创建基于url-encoded的查询串，设置或添加到URL上，或者HTTP的body中。对于集合类型的参数如何编码，没有公开的规范，所以对于数组编码为形如foo[]=1&amp;foo[]=2的格式，字典形如foo[bar]=baz格式。可以通过ArrayEncoding删除中括号，BoolEncoding可以配置布尔值如何编码(比如true 1，false 0)</p><p>一、Destination 枚举 </p><p>url编码的查询串是否添加到已有查询串，还是添加到HTTP Body中</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Destination</span> &#123;</span></span><br><span class="line">        /<span class="regexp">//</span> GET、HEAD、DELETE 查询，其他的请求放在Body中</span><br><span class="line">        <span class="keyword">case</span> methodDependent</span><br><span class="line">        <span class="keyword">case</span> queryString</span><br><span class="line">        <span class="keyword">case</span> httpBody</span><br><span class="line">        func encodesParametersInURL(<span class="keyword">for</span> <span class="symbol">method:</span> HTTPMethod) -&gt; Bool &#123;</span><br><span class="line">            switch <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">methodDependent:</span> <span class="keyword">return</span> [.get, .head, .delete].contains(method)</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">queryString:</span> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">httpBody:</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二、 ArrayEncoding 枚举 </p><p>配置Array参数如何编码</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">ArrayEncoding</span> &#123;</span></span><br><span class="line">        <span class="keyword">case</span> brackets</span><br><span class="line">        <span class="keyword">case</span> noBrackets</span><br><span class="line">        func encode(<span class="symbol">key:</span> String) -&gt; String &#123;</span><br><span class="line">            switch <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">brackets:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"\(key)[]"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">noBrackets:</span></span><br><span class="line">                <span class="keyword">return</span> key</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三、 BoolEncoding </p><p>配置Bool参数如何编码</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">enum</span> BoolEncoding &#123;</span><br><span class="line">        /// Encode `<span class="literal">true</span>` as `<span class="number">1</span>` <span class="literal">and</span> `<span class="literal">false</span>` as `<span class="number">0</span>`. This is the <span class="keyword">default</span> behavior.</span><br><span class="line">        <span class="keyword">case</span> numeric</span><br><span class="line">        /// Encode `<span class="literal">true</span>` <span class="literal">and</span> `<span class="literal">false</span>` as <span class="built_in">string</span> literals.</span><br><span class="line">        <span class="keyword">case</span> literal</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(value: Bool)</span> -&gt; <span class="title">String</span> &#123;</span></span><br><span class="line">            <span class="keyword">switch</span> self &#123;</span><br><span class="line">            <span class="keyword">case</span> .numeric:</span><br><span class="line">                <span class="keyword">return</span> value ? <span class="string">"1"</span> : <span class="string">"0"</span></span><br><span class="line">            <span class="keyword">case</span> .literal:</span><br><span class="line">                <span class="keyword">return</span> value ? <span class="string">"true"</span> : <span class="string">"false"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>四、 属性</p><ol><li>default 返回编码方式是.methodDependent的编码器(URLEncoding)</li><li>queryString 返回编码方式是.queryString的编码器(URLEncoding)</li><li>httpBody 返回编码方式是.httpBody的编码器(URLEncoding)</li><li>destination 目标编码方式 (实例属性)</li><li>arrayEncoding 编码使用的array的编码方式 (实例属性)</li><li>boolEncoding 编码器编码Bool属性使用的编码方式 (实例属性)</li></ol><p>五 方法 </p><p>实现了编码方法 </p><h3 id="JSONEncoding"><a href="#JSONEncoding" class="headerlink" title="JSONEncoding"></a>JSONEncoding</h3><p>使用JSONSerialization 将请求参数编码为JSON格式 ，并将Content type 设置为 application/json</p><h2 id="拦截器部分（RequestInterceptor适配、重试）"><a href="#拦截器部分（RequestInterceptor适配、重试）" class="headerlink" title="拦截器部分（RequestInterceptor适配、重试）"></a>拦截器部分（RequestInterceptor适配、重试）</h2><h3 id="RequestAdapter-协议"><a href="#RequestAdapter-协议" class="headerlink" title="RequestAdapter 协议"></a>RequestAdapter 协议</h3><p>可以翻译为请求适配器，可以对URLRequest inspect、ptionally adapt，适配后，会执行completion block。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RequestAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Inspects and adapts the specified `URLRequest` in some manner and calls the completion handler with the Result.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adapt</span><span class="params">(<span class="number">_</span> urlRequest: URLRequest, <span class="keyword">for</span> session: Session, completion: @escaping <span class="params">(Result&lt;URLRequest, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result-表示结果的枚举"><a href="#Result-表示结果的枚举" class="headerlink" title="Result 表示结果的枚举"></a>Result 表示结果的枚举</h3><p>封装了成功和失败两个关联值的枚举</p><h3 id="RetryResult重试枚举"><a href="#RetryResult重试枚举" class="headerlink" title="RetryResult重试枚举"></a>RetryResult重试枚举</h3><p>封装了立即重试(retry)、延迟重试(retryWithDelay，关联了延时时间)、不重试（doNotRetry）、某种错误不重试(doNotRetryWithError，关联了某种类型的错误)</p><h3 id="RequestRetrier协议"><a href="#RequestRetrier协议" class="headerlink" title="RequestRetrier协议"></a>RequestRetrier协议</h3><p>RequestRetrier协议封装了：请求被session manager执行后，并遇到错误，是否重试。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">retry</span>(_ <span class="attribute">request</span>: Request, for <span class="attribute">session</span>: Session, dueTo <span class="attribute">error</span>: Error, <span class="attribute">completion</span>: <span class="variable">@escaping</span> (RetryResult) -&gt; Void)</span><br></pre></td></tr></table></figure><p>当决定重试时，通过completion完成重试</p><h3 id="RequestInterceptor-协议"><a href="#RequestInterceptor-协议" class="headerlink" title="RequestInterceptor 协议"></a>RequestInterceptor 协议</h3><p>准守RequestAdapter和RequestRetrier协议。</p><h3 id="Adapter-类"><a href="#Adapter-类" class="headerlink" title="Adapter 类"></a>Adapter 类</h3><p>基于闭包的RequestAdapter类型，准守RequestInterceptor协议</p><h3 id="Retrier-类"><a href="#Retrier-类" class="headerlink" title="Retrier 类"></a>Retrier 类</h3><p>基于闭包的RequestRetrier，准守RequestInterceptor协议</p><h3 id="Interceptor类"><a href="#Interceptor类" class="headerlink" title="Interceptor类"></a>Interceptor类</h3><p>可以使用多个RequestAdapter、RequestRetrier进行拦截，继承于RequestInterceptor。</p><p>内部存储多个RequestAdapter、RequestRetrier进行拦截</p><h2 id="ServerTrustManager–服务信任管理"><a href="#ServerTrustManager–服务信任管理" class="headerlink" title="ServerTrustManager–服务信任管理"></a>ServerTrustManager–服务信任管理</h2><p>管理 ServerTrustEvaluating和host的映射。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTrustManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 是否所有host都需要被评估，默认true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> allHostsMustBeEvaluated: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// host 与host对应的policies的字典</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> evaluators: [<span class="type">String</span>: <span class="type">ServerTrustEvaluating</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///返回host对应的评估器(ServerTrustEvaluating)</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">serverTrustEvaluator</span><span class="params">(forHost host: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">ServerTrustEvaluating</span>?;</span><br></pre></td></tr></table></figure><h3 id="ServerTrustEvaluating-评估器协议"><a href="#ServerTrustEvaluating-评估器协议" class="headerlink" title="ServerTrustEvaluating 评估器协议"></a>ServerTrustEvaluating 评估器协议</h3><p>描述了评估服务器信任的API </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> trust: SecTrust, forHost host: String)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><p>评估给定host的trust是否可行</p><h3 id="DefaultTrustEvaluator"><a href="#DefaultTrustEvaluator" class="headerlink" title="DefaultTrustEvaluator"></a>DefaultTrustEvaluator</h3><p>使用服务器默认信任评估的评估器，可以控制是否验证挑战(challenge)提供的host</p><p>评估思路：</p><ol><li>host -&gt;SecPolicy </li><li>调用SecTrustSetPolicies函数，给SecTrust设置策略</li><li>调用SecTrustEvaluateWithError，验证SecTrust</li></ol><h3 id="RevocationTrustEvaluator-类"><a href="#RevocationTrustEvaluator-类" class="headerlink" title="RevocationTrustEvaluator  类"></a>RevocationTrustEvaluator  类</h3><p>使用默认的和撤销服务信任评估的评估器，继承ServerTrustEvaluating协议。</p><p>该信任评估和DefaultTrustEvaluator 的主要区别是创建策略的方法不同，使用的函数是SecPolicyCreateRevocation。</p><h3 id="PinnedCertificatesTrustEvaluator"><a href="#PinnedCertificatesTrustEvaluator" class="headerlink" title="PinnedCertificatesTrustEvaluator"></a>PinnedCertificatesTrustEvaluator</h3><p>使用证书评估服务器，只要任何一张固定证书匹配服务器的任何一张证书，就认为服务器是可信的。</p><p>自签名证书：</p><ol><li>调用SecTrustSetAnchorCertificates 函数，将证书添加到trust中。trust包含需要验证的证书、验证使用的策略、可选的验证证书的证书(AnchorCertificates )</li><li>SecTrustSetAnchorCertificatesOnly ，必须调用的，如果不调用，只用使用AnchorCertificates验证证书。调用了可以使用其他的证书，比如系统证书？</li><li>调用 SecTrustEvaluateWithError函数评估服务器信任</li></ol><p>正常情况：</p><p>判断固定证书是否包含在服务器的证书中，调用Set的 isDisjoint方法。</p><p>证书的读取方法 </p><ol><li>PinnedCertificatesTrustEvaluator初始哈方法中，调用了Bundle.main.af.certificates函数。</li><li>Bundle的扩展中有certificates计算属性，读取.cer, CER, .crt, .CRT, .der后缀文件。</li></ol><h3 id="PublicKeysTrustEvaluator"><a href="#PublicKeysTrustEvaluator" class="headerlink" title="PublicKeysTrustEvaluator"></a>PublicKeysTrustEvaluator</h3><p>使用公钥评估服务器信任。</p><h2 id="RedirectHandler-–-重定向处理"><a href="#RedirectHandler-–-重定向处理" class="headerlink" title="RedirectHandler – 重定向处理"></a>RedirectHandler – 重定向处理</h2><p>如何处理“服务端返回的重定向响应”—要求重定向到新的请求。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">task</span>(_ <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">              willBeRedirectedTo <span class="attribute">request</span>: URLRequest,</span><br><span class="line">              for <span class="attribute">response</span>: HTTPURLResponse,</span><br><span class="line">              <span class="attribute">completion</span>: <span class="variable">@escaping</span> (URLRequest?) -&gt; Void)</span><br></pre></td></tr></table></figure><h3 id="Redirector-结构体"><a href="#Redirector-结构体" class="headerlink" title="Redirector 结构体"></a>Redirector 结构体</h3><p>是一个便利的RedirectHandler，可以follow、not follow、modify a redirect。</p><p>扩展里面做了默认实现，</p><ol><li>follow，执行completion Block，参数是重定向指定的新请求。</li><li>not fllow 执行completion Block，参数是nil</li><li>如果是modify，使用modify关联的Closure创建新的请求，然后执行completion Block，参数是修改过的请求。</li></ol><h2 id="CachedResponseHandler-缓存协议"><a href="#CachedResponseHandler-缓存协议" class="headerlink" title="CachedResponseHandler 缓存协议"></a>CachedResponseHandler 缓存协议</h2><p>初始data task 是否缓存响应。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">dataTask</span>(_ <span class="attribute">task</span>: URLSessionDataTask,</span><br><span class="line">                  willCacheResponse <span class="attribute">response</span>: CachedURLResponse,</span><br><span class="line">                  <span class="attribute">completion</span>: <span class="variable">@escaping</span> (CachedURLResponse?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>completion 是执行缓存操作的Block，有三种情况</p><ol><li>服务器提供的缓存响应</li><li>修改响应的缓存</li><li>nil，不缓存</li></ol><h3 id="ResponseCacher-结构体"><a href="#ResponseCacher-结构体" class="headerlink" title="ResponseCacher 结构体"></a>ResponseCacher 结构体</h3><p>ResponseCacher是一个便利的缓存处理器（CachedResponseHandler），可以处理缓存、不缓存、修改缓存。</p><h2 id="RequestDelegate-请求代理"><a href="#RequestDelegate-请求代理" class="headerlink" title="RequestDelegate 请求代理"></a>RequestDelegate 请求代理</h2><p>执行URLSessionDelegate的方法的类。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private let fileManager: FileManager</span><br><span class="line">weak var <span class="keyword">state</span>Provider: SessionStateProvider?</span><br></pre></td></tr></table></figure><h3 id="SessionStateProvider"><a href="#SessionStateProvider" class="headerlink" title="SessionStateProvider"></a>SessionStateProvider</h3><p>SessionStateProvider协议提供Session的各种状态，包括主要的三要素：信任评估、 重定向、缓存。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverTrustManager: ServerTrustManager? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> redirectHandler: RedirectHandler? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cachedResponseHandler: CachedResponseHandler? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>一、SessionStateProvider功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SessionStateProvider</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="keyword">for</span> task: URLSessionTask)</span></span> -&gt; <span class="type">Request</span>? <span class="comment">//创建请求</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didGatherMetricsForTask</span><span class="params">(<span class="number">_</span> task: URLSessionTask)</span></span> <span class="comment">//度量完成</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didCompleteTask</span><span class="params">(<span class="number">_</span> task: URLSessionTask)</span></span><span class="comment">//任务完成</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">credential</span><span class="params">(<span class="keyword">for</span> task: URLSessionTask, <span class="keyword">in</span> protectionSpace: URLProtectionSpace)</span></span> -&gt; <span class="type">URLCredential</span>?<span class="comment">//创建凭证</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cancelRequestsForSessionInvalidation</span><span class="params">(with error: Error?)</span></span><span class="comment">//session非法时，取消请求 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、 执行URLSessionDelegate的代理方法 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, didBecomeInvalidWithError <span class="attribute">error</span>: Error?) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">eventMonitor</span>?<span class="selector-class">.urlSession</span>(session, <span class="attribute">didBecomeInvalidWithError</span>: error)</span><br><span class="line"> <span class="selector-tag">stateProvider</span>?<span class="selector-class">.cancelRequestsForSessionInvalidation</span>(<span class="attribute">with</span>: error)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>session无效后，取消请求。</p><p>三、 URLSessionTaskDelegate 的代理方法 </p><p>插曲，下面是挑战的结构 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URLAuthenticationChallenge(挑战)</span><br><span class="line">    URLProtectionSpace(保护空间)  </span><br><span class="line">        realm 认证域</span><br><span class="line">        host  </span><br><span class="line">        port</span><br><span class="line">        authenticationMethod</span><br><span class="line">    proposedCredential: URLCredential(凭证)</span><br><span class="line">    用户名密码类型凭证</span><br><span class="line">    证书类型凭证</span><br><span class="line">    被接受的specified trust</span><br></pre></td></tr></table></figure><p>3.1 认证代理方法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         didReceive <span class="attribute">challenge</span>: URLAuthenticationChallenge,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void)</span><br></pre></td></tr></table></figure></p><p>根据挑战URLAuthenticationChallenge，创建凭证URLCredential。调用completionHandler接受挑战，参数是challenge.protectionSpace.authenticationMethod、凭证。</p><p>3.1 数据发送代理方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession,</span></span></span><br><span class="line"><span class="function"><span class="params">                         task: URLSessionTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                         didSendBodyData bytesSent: Int64,</span></span></span><br><span class="line"><span class="function"><span class="params">                         totalBytesSent: Int64,</span></span></span><br><span class="line"><span class="function"><span class="params">                         totalBytesExpectedToSend: Int64)</span></span></span><br></pre></td></tr></table></figure></p><p>3.3  需要请求体代理方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         needNewBodyStream <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (InputStream?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>3.4 重定向代理方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         willPerformHTTPRedirection <span class="attribute">response</span>: HTTPURLResponse,</span><br><span class="line">                         newRequest <span class="attribute">request</span>: URLRequest,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (URLRequest?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>3.5 度量完成 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)</span></span></span><br></pre></td></tr></table></figure><p>3.6 请求完成 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, <span class="attribute">task</span>: URLSessionTask, didCompleteWithError <span class="attribute">error</span>: Error?) &#123;</span><br><span class="line">        <span class="selector-tag">eventMonitor</span>?<span class="selector-class">.urlSession</span>(session, <span class="attribute">task</span>: task, <span class="attribute">didCompleteWithError</span>: error)</span><br></pre></td></tr></table></figure><p>四、 URLSessionDataDelegate代理 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到数据</span></span><br><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, <span class="attribute">dataTask</span>: URLSessionDataTask, didReceive <span class="attribute">data</span>: Data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存响应</span></span><br><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">dataTask</span>: URLSessionDataTask,</span><br><span class="line">                         willCacheResponse <span class="attribute">proposedResponse</span>: CachedURLResponse,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (CachedURLResponse?) -&gt; Void)</span><br></pre></td></tr></table></figure><h3 id="小小节"><a href="#小小节" class="headerlink" title="小小节"></a>小小节</h3><p>SessionDelegate 主要就是执行URLSession的代理。每个代理的工作是</p><ol><li>调用事件监控对应的方法(EventMonitor)</li><li>二是调用SessionStateProvider中定制方法、或者SessionStateProvider中的评估器、重定向器、缓冲器方法。</li></ol><p>所以，SessionStateProvider中的评估器、重定向器、缓冲器，就是为了将复杂的功能分离出去，独立为模块。</p><h2 id="序列化响应"><a href="#序列化响应" class="headerlink" title="序列化响应"></a>序列化响应</h2><h3 id="DataResponseSerializerProtocol-协议"><a href="#DataResponseSerializerProtocol-协议" class="headerlink" title="DataResponseSerializerProtocol 协议"></a>DataResponseSerializerProtocol 协议</h3><p>DataResponseSerializerProtocol 协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataResponseSerializerProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of serialized object to be created.</span></span><br><span class="line">    associatedtype <span class="type">SerializedObject</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">serialize</span><span class="params">(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SerializedObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了序列化的方法 </p><h3 id="DownloadResponseSerializerProtocol-协议"><a href="#DownloadResponseSerializerProtocol-协议" class="headerlink" title="DownloadResponseSerializerProtocol 协议"></a>DownloadResponseSerializerProtocol 协议</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DownloadResponseSerializerProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of serialized object to be created.</span></span><br><span class="line">    associatedtype <span class="type">SerializedObject</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">serializeDownload</span><span class="params">(request: URLRequest?, response: HTTPURLResponse?, fileURL: URL?, error: Error?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SerializedObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了下载请求序列化的方法 </p><h3 id="ResponseSerializer"><a href="#ResponseSerializer" class="headerlink" title="ResponseSerializer"></a>ResponseSerializer</h3><p>能够处理数据和下载的序列化器</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol ResponseSerializer: DataResponseSerializerProtocol &amp; DownloadResponseSerializerProtocol &#123;</span><br><span class="line">    <span class="comment"><span class="markdown">/// 准备数据</span></span></span><br><span class="line">    <span class="keyword">var</span> dataPreprocessor: DataPreprocessor &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment"><span class="markdown">/// <span class="code">`HTTPMethod`</span>s for which empty response bodies </span>are<span class="markdown"> considered appropriate.</span></span></span><br><span class="line">    <span class="keyword">var</span> emptyRequestMethods: <span class="built_in">Set</span>&lt;HTTPMethod&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment"><span class="markdown">/// HTTP response codes for which empty response bodies </span>are<span class="markdown"> considered appropriate.</span></span></span><br><span class="line">    <span class="keyword">var</span> emptyResponseCodes: <span class="built_in">Set</span>&lt;Int&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="DataPreprocessor-数据预处理器"><a href="#DataPreprocessor-数据预处理器" class="headerlink" title="DataPreprocessor 数据预处理器"></a>DataPreprocessor 数据预处理器</h3><p>序列化前的数据处理 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataPreprocessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Process           `Data` before it's handled by a serializer.</span></span><br><span class="line">    <span class="comment">/// - Parameter data: The raw `Data` to process.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preprocess</span><span class="params">(<span class="number">_</span> data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseSerializer-协议扩展"><a href="#ResponseSerializer-协议扩展" class="headerlink" title="ResponseSerializer  协议扩展"></a>ResponseSerializer  协议扩展</h3><p>该部分扩展添加了是否允许空响应的识别。</p><p>一、 判断请求是否允许空响应,从请求方式判断，Head允许<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">requestAllowsEmptyResponseData</span><span class="params">(<span class="number">_</span> request: URLRequest?)</span></span> -&gt; <span class="type">Bool</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> request.flatMap &#123; $<span class="number">0</span>.httpMethod &#125;</span><br><span class="line">            .flatMap(<span class="type">HTTPMethod</span>.<span class="keyword">init</span>)</span><br><span class="line">            .<span class="built_in">map</span> &#123; emptyRequestMethods.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>二、 判断响应是否允许空响应，从响应码判断，204 205 允许<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">responseAllowsEmptyResponseData</span><span class="params">(<span class="number">_</span> response: HTTPURLResponse?)</span></span> -&gt; <span class="type">Bool</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> response.flatMap &#123; $<span class="number">0</span>.statusCode &#125;</span><br><span class="line">            .<span class="built_in">map</span> &#123; emptyResponseCodes.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="DataRequest-在序列化文件中的扩展"><a href="#DataRequest-在序列化文件中的扩展" class="headerlink" title="DataRequest 在序列化文件中的扩展"></a>DataRequest 在序列化文件中的扩展</h3><p>一、 默认的只添加序列化完成的闭包，没有序列化功能 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">response</span>(<span class="attribute">queue</span>: DispatchQueue = .main, <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Data?&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><p>二、 添加一个包含序列化器的完成处理闭包<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@discardableResult</span></span><br><span class="line">public func response&lt;<span class="attribute">Serializer</span>: DataResponseSerializerProtocol&gt;(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                                                                     <span class="attribute">responseSerializer</span>: Serializer,</span><br><span class="line">                                                                     <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Serializer.SerializedObject&gt;) -&gt; Void)</span><br></pre></td></tr></table></figure></p><p>内部调用appendResponseSerializer添加了一个序列化的block，block内部的工作 </p><ol><li>调用responseSerializer的序列化方法 serialize</li><li>将序列化的结果封装到result中，包含序列化完的数据、错误</li><li>封装DataResponse类型的response，包括request、response、data、serializationDuration、result</li><li>如果！(有错误有代理) 将完成block添加的responseSerializerDidComplete中</li><li>如果 (有错误有代理) ,调用重试结果</li></ol><p>重试的逻辑</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">序列化发生错误时，参数是序列化完成hander ：completionHandler</span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">| 调用</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line">Session-&gt;retryResult函数： retryCompletion</span><br><span class="line">                            <span class="string">|</span></span><br><span class="line">                            <span class="string">| 创建retryCompletion逻辑如下，参数是RetryResult</span></span><br><span class="line">                            <span class="string">|  </span></span><br><span class="line">                            <span class="number">1</span>. 如果不重试didComplete = completionHandler(response)</span><br><span class="line">                            <span class="number">2</span>. 有错误不重试，组装错误，didComplete =completionHandler(response)</span><br><span class="line">                            <span class="number">3</span>. 重试，执行重试操作</span><br><span class="line">                            <span class="number">4</span>. didComplete存储到session的 responseSerializerCompletions</span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">| retryResult函数内部逻辑</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line">    <span class="number">1</span>. 取得retrier：RequestRetrier </span><br><span class="line">    <span class="number">2</span>. 调用retry : 完成block，命名为 retryCompletion1</span><br><span class="line">                            <span class="string">|</span></span><br><span class="line">                            A. 重试没有错误，执行retryCompletion(result)</span><br><span class="line">                            B. 有错误，retryCompletion(.doNotRetryWithError(retryError))</span><br><span class="line">                    <span class="string">|</span></span><br><span class="line">                    <span class="string">| retry函数的逻辑</span></span><br><span class="line">                    <span class="string">|</span></span><br><span class="line">                    执行retryHandler函数： retryCompletion1</span><br></pre></td></tr></table></figure><p>上面是最外层，最外层的block最小，越下面的封装，block越大，最内侧的函数完成后执行最大的block，一直向最外层(顶部最小)扩展 </p><p>添加一个string类型的序列化器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">responseString</span>(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                               <span class="attribute">encoding</span>: String.Encoding? = nil,</span><br><span class="line">                               <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;String&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><p>添加一个JSON类型的序列化器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">responseJSON</span>(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                             <span class="attribute">options</span>: JSONSerialization.ReadingOptions = .allowFragments,</span><br><span class="line">                             <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Any&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>Request</code> is the common superclass of all Alamofire request types and provides common state, delegate, and callback  handling.</p><p>request是有状态的，通过内部枚举State表征。状态通过resume、suspend、cancel函数改变。</p><h3 id="初始状态部分"><a href="#初始状态部分" class="headerlink" title="初始状态部分"></a>初始状态部分</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">id:</span> UUID 为request提供唯一标识，用于hash、相等</span><br><span class="line"><span class="symbol">underlyingQueue:</span> DispatchQueue 内部异步操作的串行队列</span><br><span class="line"><span class="symbol">serializationQueue:</span> DispatchQueue 序列化使用的队列</span><br><span class="line"><span class="symbol">eventMonitor:</span> EventMonitor?   事件监控</span><br><span class="line"><span class="symbol">interceptor:</span> RequestInterceptor? 拦截器(重试器、适配器)</span><br><span class="line"><span class="symbol">delegate:</span> RequestDelegate?</span><br></pre></td></tr></table></figure><h3 id="可变状态部分"><a href="#可变状态部分" class="headerlink" title="可变状态部分"></a>可变状态部分</h3><p>通过结构体MutableState封装，包括进度、重定向、缓存、cURL、响应序列化、凭证、请求、task、metrics、重试次数、错误。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protectedMutableState: Protector<span class="symbol">&lt;MutableState&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct MutableState &#123;</span><br><span class="line">        <span class="comment"><span class="markdown">/// State of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> state: State = .initialized</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`ProgressHandler`</span> and <span class="code">`DispatchQueue`</span> provided for upload progress callbacks.</span></span></span><br><span class="line">        <span class="keyword">var</span> uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`ProgressHandler`</span> and <span class="code">`DispatchQueue`</span> provided for download progress callbacks.</span></span></span><br><span class="line">        <span class="keyword">var</span> downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`RedirectHandler`</span> provided for to handle request redirection.</span></span></span><br><span class="line">        <span class="keyword">var</span> redirectHandler: RedirectHandler?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`CachedResponseHandler`</span> provided to handle response caching.</span></span></span><br><span class="line">        <span class="keyword">var</span> cachedResponseHandler: CachedResponseHandler?</span><br><span class="line">        <span class="comment"><span class="markdown">/// Closure called when </span>the<span class="markdown"> <span class="code">`Request`</span> is able to create </span>a<span class="markdown"> cURL description of itself.</span></span></span><br><span class="line">        <span class="keyword">var</span> cURLHandler: ((<span class="built_in">String</span>) -&gt; Void)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// Response serialization closures that handle response parsing.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializers: [() -&gt; Void] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Response serialization completion closures executed once all response serializers </span>are<span class="markdown"> complete.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializerCompletions: [() -&gt; Void] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Whether response serializer processing is finished.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializerProcessingFinished = <span class="keyword">false</span></span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`URLCredential`</span> used for authentication challenges.</span></span></span><br><span class="line">        <span class="keyword">var</span> credential: URLCredential?</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLRequest`</span>s created by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> requests: [URLRequest] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLSessionTask`</span>s created by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> tasks: [URLSessionTask] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLSessionTaskMetrics`</span> values gathered by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>. Should correspond</span></span></span><br><span class="line">        <span class="comment"><span class="markdown">/// exactly </span>the<span class="markdown"> </span>the<span class="markdown"> <span class="code">`tasks`</span> created.</span></span></span><br><span class="line">        <span class="keyword">var</span> metrics: [URLSessionTaskMetrics] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Number of times any retriers provided retried </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> retryCount = <span class="number">0</span></span><br><span class="line">        <span class="comment"><span class="markdown">/// Final <span class="code">`AFError`</span> for </span>the<span class="markdown"> <span class="code">`Request`</span>, whether from various internal Alamofire calls or as </span>a<span class="markdown"> result of </span>a<span class="markdown"> <span class="code">`task`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> error: AFError?</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部结构体MutableState 封装可变状态，可能被外部访问</p><h3 id="进度部分"><a href="#进度部分" class="headerlink" title="进度部分"></a>进度部分</h3><p>包括进度对象和进度处理器 </p><h3 id="重定向、缓存"><a href="#重定向、缓存" class="headerlink" title="重定向、缓存"></a>重定向、缓存</h3><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>返回 lastTask?.response as? HTTPURLResponse</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>数组存储着task</p><p>下面是功能部分 </p><h3 id="内部功能"><a href="#内部功能" class="headerlink" title="内部功能"></a>内部功能</h3><p>一 、didFailToCreateURLRequest</p><p>didFailToCreateURLRequest  —retryOrFinish – 调用delegate的retryResult—传递的block内部有finish– processNextResponseSerializer– 找出下一个序列化Hander在serializationQueue队列中执行，如果没有下一个句柄，表示序列化完成执行完成序列化Hander responseSerializerCompletions –&gt; cleanup</p><p>didCompleteTask 也是调用 retryOrFinish函数 </p><h3 id="验证响应"><a href="#验证响应" class="headerlink" title="验证响应"></a>验证响应</h3><p>实现在Validation文件中，验证response code、 response mime type 包含在request accept type中</p><h2 id="Protector"><a href="#Protector" class="headerlink" title="Protector"></a>Protector</h2><p>线程安全的设计思想,定义一个Protector的类，类中有一个锁，需要加锁操作放在block中。 </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UnfairLock </span><br><span class="line">     unfairLock: os_unfair_lock_t  锁对象</span><br><span class="line">     aroud  输入无参闭包，加锁执行，返回闭包结果</span><br><span class="line">     </span><br><span class="line">     func around&lt;T&gt;<span class="function"><span class="params">(_ closure: () -&gt; T)</span> -&gt;</span> T &#123;</span><br><span class="line">        lock(); </span><br><span class="line">        defer &#123; </span><br><span class="line">             unlock() </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closure()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Protector </span><br><span class="line">    <span class="keyword">let</span> lock = UnfairLock()</span><br><span class="line">    <span class="keyword">var</span> value: T</span><br><span class="line">    directValue 获取加锁对象</span><br><span class="line">    read 读保护资源的操作 ，入参block<span class="function"><span class="params">(带参数)</span> -&gt;</span>封装<span class="function"><span class="params">(非无参数的block)</span>-&gt;</span>调用锁的aroud方法</span><br><span class="line">    write 写保护资源的操作</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li>不用每个受保护资源都写加锁解锁代码。</li><li>泛型使Protector能容纳任何类型。</li></ol><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ol><li>创建和管理request</li><li>提供了request的基本功能：队列、拦截、信任管理、缓存响应</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">session: URLSession  创建task使用的session</span></span><br><span class="line"><span class="section">delegate: SessionDelegate 处理URLSessionDelegate的代理，并与Request交互</span></span><br><span class="line"><span class="section">rootQueue: DispatchQueue 内部回调、状态更新的队列，必须是串行队列</span></span><br><span class="line"><span class="section">startRequestsImmediately: Bool 创建request后，是否立即调用resume</span></span><br><span class="line"><span class="section">requestQueue: DispatchQueue 可以异步创建请求，默认使用rootQueue</span></span><br><span class="line"><span class="section">serializationQueue: DispatchQueue  解析响应使用的队列</span></span><br><span class="line"><span class="section">interceptor: RequestInterceptor? 包括重试、适配器</span></span><br><span class="line"><span class="section">serverTrustManager: ServerTrustManager? 评估信任挑战、提供证书、公钥</span></span><br><span class="line"><span class="section">redirectHandler: RedirectHandler?  提供定制化重定向</span></span><br><span class="line"><span class="section">cachedResponseHandler: CachedResponseHandler? 响应缓存管理</span></span><br><span class="line"><span class="section">eventMonitor: CompositeEventMonitor  session事件、请求事件的监控</span></span><br><span class="line"><span class="section">defaultEventMonitors: [EventMonitor]  默认的通知类型监控</span></span><br><span class="line">requestTaskMap = RequestTaskMap() request和task的映射</span><br><span class="line"><span class="section">activeRequests: Set&lt;Request&gt;  激活状态的请求</span></span><br></pre></td></tr></table></figure><p>EventMonitor ： 包括session的事件和request生命周期中的事件</p><p>SessionDelegate  ：执行URLSessionDelegate的代理</p><h2 id="RequestTaskMap"><a href="#RequestTaskMap" class="headerlink" title="RequestTaskMap"></a>RequestTaskMap</h2><p>存储请求和tast的双向映射，两个字典 ，下标操作的新值未空是删除功能</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionDelegate</span><br><span class="line"> fileManager</span><br><span class="line"> 处理下载文件时候使用</span><br><span class="line">       <span class="keyword">state</span>Provider</span><br><span class="line">       serverTrustManager</span><br><span class="line">        ServerTrustManager类型</span><br><span class="line">        管理host ServerTrustEvaluating映射</span><br><span class="line">       redirectHandler</span><br><span class="line">       cachedResponseHandler   </span><br><span class="line">       </span><br><span class="line">       eventMonitor</span><br><span class="line">       包括session的事件和request生命周期中的事件</span><br><span class="line">           queue</span><br></pre></td></tr></table></figure><h2 id="Extended命名作用域"><a href="#Extended命名作用域" class="headerlink" title="Extended命名作用域"></a>Extended命名作用域</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">AlamofireExtended</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">AlamofireExtension</span> <span class="title">where</span> <span class="title">ExtendedType</span> == [<span class="title">SecCertificate</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">Data</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> type.<span class="built_in">map</span> &#123; <span class="type">SecCertificateCopyData</span>($<span class="number">0</span>) <span class="keyword">as</span> <span class="type">Data</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> publicKeys: [<span class="type">SecKey</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> type.compactMap &#123; $<span class="number">0</span>.af.publicKey &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AlamofireExtension</span>&lt;<span class="title">ExtendedType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">ExtendedType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">AlamofireExtended</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> af: <span class="type">AlamofireExtension</span>&lt;<span class="type">ExtendedType</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">AlamofireExtended</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> af: <span class="type">AlamofireExtension</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">AlamofireExtension</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span>&#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明Array准守AlamofireExtended协议， AlamofireExtended协议中有一个af属性，类型是AlamofireExtension结构体类型。</p><p>也就是说如果让Array准守AlamofireExtended协议，即Array中存在名为af计算属性<br>充当命名空间的作用。</p><p>如果想给Array扩展功能，让Array遵守AlamofireExtended，然后给 AlamofireExtension添加扩展功能，通过type成员找到原始期望扩展的类Array。</p><p>实际上就是加了个中间层。把系统类的扩展转移到了AlamofireExtension中。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array ： AlamofireExtended </span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line">af属性：AlamofireExtension<span class="variable">&lt;&gt;</span></span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line">type：被扩展的类型</span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line"><span class="variable">&lt;-------AlamofireExtension通过type可以直接找到Array本身</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlamofireExtension <span class="keyword">where</span> ExtendedType: <span class="built_in">Array</span> <span class="comment">//只要扩展的是array才能调用的方法</span></span><br></pre></td></tr></table></figure><p>下面是使用方法的理解“</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">certificates:[SecCertificate]</span><br><span class="line">certificates<span class="selector-class">.af</span><span class="selector-class">.publicKeys</span> </span><br><span class="line"></span><br><span class="line">extension Array: AlamofireExtended &#123;&#125;</span><br><span class="line">public extension AlamofireExtension where ExtendedType == [SecCertificate] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 枚举证书，获取公钥</span></span><br><span class="line">    <span class="selector-tag">var</span> publicKeys: [SecKey] &#123;</span><br><span class="line">        return type<span class="selector-class">.compactMap</span> &#123; $<span class="number">0</span><span class="selector-class">.af</span><span class="selector-class">.publicKey</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学习到的知识"><a href="#学习到的知识" class="headerlink" title="学习到的知识"></a>学习到的知识</h2><h3 id="OptionSet"><a href="#OptionSet" class="headerlink" title="OptionSet"></a>OptionSet</h3><p>OptionSet可以描述位集，每一位表示集合中的一个成员，该协议可以做一些结合的运算。协议有一个rawValue、一些选项。其中选项的值未1、2、4、8 等。以使每个位表示一个选项。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShippingOptions</span></span>: OptionSet &#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: Int</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nextDay    = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondDay  = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> priority   = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> standard   = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> express: ShippingOptions = [.nextDay, .secondDay]</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> all: ShippingOptions = [.express, .priority, .standard]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感想：</p><ol><li>相关的两个成员属性使用元组表示，可以减少属性个数，便于管理</li><li>只要有几种可选的处理方式，就使用枚举。枚举应用非常多</li><li>函数式编程，消费掉一个参数，生成新的block。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AlamoFire 学习&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="AlamoFire" scheme="http://yoursite.com/categories/IOS/opensource/AlamoFire/"/>
    
    
      <category term="AlamoFire" scheme="http://yoursite.com/tags/AlamoFire/"/>
    
  </entry>
  
  <entry>
    <title>英语单词</title>
    <link href="http://yoursite.com/wiki/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/wiki/英语/英语单词/</id>
    <published>2019-12-09T04:07:12.000Z</published>
    <updated>2019-12-09T08:37:22.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="英语单词"><a href="#英语单词" class="headerlink" title="英语单词"></a>英语单词</h2><ol><li>semantics  英  [sɪˈmæntɪks]   美  [sɪˈmæntɪks] n. [语] 语义学；语义论</li><li>compliant 英 [kəmˈplaɪənt]   美 [kəmˈplaɪənt]  adj. 顺从的;百依百顺的;俯首帖耳的;(与系列规则相)符合的，一致的</li><li>attach 英 [əˈtætʃ]   美 [əˈtætʃ]   v. 把…固定，把…附(在…上);认为有重要性(或意义、价值、分量等);重视;(有时不受欢迎或未受邀请而)参加，和…在一起，缠着</li><li>inspect 英 [ɪnˈspekt]   美 [ɪnˈspekt]   v. 检查;查看;审视;视察</li><li>adapt 英 [əˈdæpt]   美 [əˈdæpt]   v. 使适应，使适合(新用途、新情况);适应(新情况);改编;改写</li><li>revoke  英  [rɪˈvəʊk]   美  [rɪˈvoʊk] vt. 撤回，取消；废除</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;英语单词&quot;&gt;&lt;a href=&quot;#英语单词&quot; class=&quot;headerlink&quot; title=&quot;英语单词&quot;&gt;&lt;/a&gt;英语单词&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;semantics  英  [sɪˈmæntɪks]   美  [sɪˈmæntɪks] n. [语] 语义学；
      
    
    </summary>
    
      <category term="英语" scheme="http://yoursite.com/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>获取Block捕获的变量</title>
    <link href="http://yoursite.com/wiki/IOS/Block/block_getCapture/"/>
    <id>http://yoursite.com/wiki/IOS/Block/block_getCapture/</id>
    <published>2019-12-04T04:07:12.000Z</published>
    <updated>2019-12-04T07:53:46.694Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解获取block捕获变量的原理，参考<a href="https://www.jianshu.com/p/8f02158649c5" rel="external nofollow noopener noreferrer" target="_blank">一种查看Block中引用的所有外部对象的实现方法</a></p><a id="more"></a><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void <span class="symbol">*</span>isa;</span><br><span class="line">volatile int32_t flags; // contains ref count</span><br><span class="line">int32_t reserved;</span><br><span class="line">void <span class="symbol">*</span>invoke;</span><br><span class="line">struct Block_descriptor_1 <span class="symbol">*</span>descriptor;</span><br><span class="line">struct Block_descriptor_2 <span class="symbol">*</span>descriptor2</span><br><span class="line">struct Block_descriptor_3 <span class="symbol">*</span>descriptor3</span><br><span class="line">        |</span><br><span class="line"><span class="string">        </span>|<span class="string">---------signature</span></span><br><span class="line"><span class="string">        </span>|<span class="string">---------layout</span></span><br><span class="line"><span class="string">                     </span>|<span class="string"> 压缩格式    0x02 3 4 表示有2个强引用、3个__block、4个弱引用对象</span></span><br><span class="line"><span class="string">strong NSObject * obj1; ------------</span>|<span class="string"> </span>|<span class="string">  </span>|</span><br><span class="line">strong NSObject <span class="symbol">*</span> obj2; ------------|<span class="string"> </span>|<span class="string">  </span>|</span><br><span class="line">                                      |<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj3;--------------|<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj4;--------------|<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj5;--------------|<span class="string">  </span>|</span><br><span class="line">                                         |</span><br><span class="line"><span class="string">__weak NSObject * obj6;------------------</span>|</span><br><span class="line">__weak NSObject <span class="symbol">*</span> obj7;------------------|</span><br><span class="line"><span class="string">__weak NSObject * obj8;------------------</span>|</span><br><span class="line">__weak NSObject <span class="symbol">*</span> obj9;------------------|</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void *isa;</span><br><span class="line">volatile int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">int32_t reserved;</span><br><span class="line">void *invoke;</span><br><span class="line">struct Block_descriptor_1 *descriptor;</span><br><span class="line">struct Block_descriptor_2 *descriptor2</span><br><span class="line">struct Block_descriptor_3 *descriptor3</span><br><span class="line">        |</span><br><span class="line">        |---------signature</span><br><span class="line">        |---------layout</span><br><span class="line">                     | 非压缩格式 <span class="number">0x32</span> <span class="number">43</span> <span class="number">54</span> ... <span class="number">00</span></span><br><span class="line">strong NSObject * obj1; ------------| |  | <span class="number">0x32</span> 高<span class="number">4</span>位中<span class="number">3</span>表示强引用类型</span><br><span class="line">strong NSObject * obj2; ------------| |  |      低<span class="number">4</span>位中的<span class="number">2</span>表示有<span class="number">2</span>个对象 </span><br><span class="line">                                      |  |</span><br><span class="line">__block NSObject * obj3;--------------|  | <span class="number">0x43</span> 高<span class="number">4</span>位中<span class="number">4</span>表示__block类型</span><br><span class="line">__block NSObject * obj4;--------------|  |      低<span class="number">4</span>位中的<span class="number">3</span>表示有<span class="number">2</span>个对象 </span><br><span class="line">__block NSObject * obj5;--------------|  |</span><br><span class="line">                                         |</span><br><span class="line">__weak NSObject * obj6;------------------| <span class="number">0x54</span> 高<span class="number">4</span>位中<span class="number">5</span>表示若引用类型</span><br><span class="line">__weak NSObject * obj7;------------------|      低<span class="number">4</span>位中的<span class="number">4</span>表示有<span class="number">4</span>个对象 </span><br><span class="line">__weak NSObject * obj8;------------------|</span><br><span class="line">__weak NSObject * obj9;------------------|</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解获取block捕获变量的原理，参考&lt;a href=&quot;https://www.jianshu.com/p/8f02158649c5&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;一种查看Block中引用的所有外部对象的实现方法
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/categories/IOS/Block/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>18 swift OC 混合编程</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/18%20swift%20OC/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/18 swift OC/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-26T10:45:33.885Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用</p><p>补存内容 ： catch默认存在error</p><p>#warning()<br>// TODO:  </p><p>编码习惯： xcode自己生成的类冒号跟着前面        </p><p>@UIApplicationMain  就是新的入口 </p><p>Swift调用OC写的东西 </p><p>1 新建桥接文件 ： targetName-Bridging-Header.h  就是OC暴露给swift的东西<br>@_silgen_name(“sum”) func malloc(v1: Int32, v2: Int) -&gt; Int32</p><p>swift 暴露给OC的条件</p><ol><li>继承NSObject</li><li>objcMembers    或使用@objc 修饰需要暴露的成员 </li></ol><p>@objc  还能修改暴露给OC的类名的名称， 方法名 </p><p>字符串处理 ：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用&lt;/p&gt;
&lt;p&gt;补存内容 ： catch默认存在error&lt;/p&gt;
&lt;p&gt;#warning()&lt;br&gt;// TODO:  &lt;/p&gt;
&lt;p&gt;编码习惯： xcode自己生成的类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>协议</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11%20%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/11 协议/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:22:03.805Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>协议中的变量： 属性一律var</li><li>协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类的必要初始化器， 子类实现的时候，可以省略override。</li><li>非可失败的初始化器 ：  非可失败、 ！</li><li>可失败： 三种可以</li><li>协议组合 &amp;</li><li>类型属性必须是static</li><li>遍历枚举  CaseIterable   allcases</li><li>CustomStringConvertible description</li><li>any anyObject 只能被类准守</li><li>is 判断是否是某种类型 as ？ Student 可选项 as Any</li><li>metadata 元类型</li><li>Persion.self 和堆空间的前8个字节存储一样的内容  就是元类型</li><li>Persion.Type</li><li><p>AnyClass = AnyObject.type</p></li><li><p>类名和X.self有很多相同点，可以调用方法，不同点：X.self能赋值给变量，类名不能复制给变量。</p></li></ul><ol><li>使用元类型调用的初始化方法一定是requied的，因为你可以给元类型传递一个子类的对象，如果子类没有该初始化方法，那么就失败。为了不失败，所以标记为requied</li><li>Self  应用于返回值，如果协议中定义的方法返回当前对象，在子类中就需要返回子类对象，所以使用Self</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;协议中的变量： 属性一律var&lt;/li&gt;
&lt;li&gt;协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>14 枚举的本质、溢出运算符</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14%20%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%81%E6%BA%A2%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/14 枚举的本质、溢出运算符/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-25T05:52:49.910Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>运算符重载</p><p>运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能</p><p>运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法</p><p>static prefix func -(Int)-&gt; Int  {</p><p>}</p><p>Equatable协议<br>如果一个类已经有相等的方法，也要声明为准守Equatable协议，好处</p><p>明确告诉别人，我有比较功能<br>很多有要求Equatable协议的地方，都可以使用了<br>也能使用!= 运算符</p><p>对于引用类型，比较存储的地址值是否相等使用 ===       !==</p><p>Comparable 协议</p><p>比较的结果三种情况</p><p>自定义运算符<br>prefix operator<br>postfix operator<br>infix operator : 优先级组</p><p>结合性 ： 多个运算符，描述先从左边开始，还是先从右边开始 ，如果没有结合性，表示不允许连续出现多个运算符<br>优先级 ： 高于什么，低于什么<br>assignment ： 在可选链拥有和赋值运算符有一样的优先级</p><p>扩展</p><p>不能添加存储属性： 不能改变内存结构<br>扩展可以给协议提供默认实现，也间接的实现了可选协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;运算符重载&lt;/p&gt;
&lt;p&gt;运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能&lt;/p&gt;
&lt;p&gt;运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法&lt;/p&gt;
&lt;p&gt;static prefix func -(Int)
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%20/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/12 错误处理 /</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:24:12.017Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>常见的错误</strong>：</p><ol><li>语法</li><li>逻辑</li><li>运行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;常见的错误&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>13 汇编分析String、Array的结构</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13%20%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90String%E3%80%81Array%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/13 汇编分析String、Array的结构/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-22T06:52:10.463Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>0x30是数字0的ascii码</li><li>tag pointer 干嘛用的？直接将内容放在变量的地址中</li><li>rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验证。</li></ul><p>长度大于0xf 的存储情况：</p><ol><li>rax 长度   </li><li>rdx 地址，地址-0x7ffffffffffffe0=真实存储地址</li></ol><p>内存分布情况：</p><ol><li>代码区</li><li>常量区</li><li>全局区</li><li>堆区</li><li>栈区</li></ol><p>内存布局图：</p><ol><li>mach-o</li><li>运行内存</li><li>动态库</li></ol><blockquote><p>小技巧： 字符串的真实地址 ： 后面的地址+0x20</p><p>小技巧：1后面跟着4个0 一般是全局区，如果不是那么一般是堆区</p></blockquote><p>append干了什么事情： 变为堆空间， 跳过32字节，后面就是内容是存储的真实字符串</p><p><strong>小小总结：</strong></p><ol><li>字符串长度&lt;=0xf  字符串内容直接存储在变量的内存中</li><li>字符串的长度&gt;0xf,字符串存放在常量区（__TEXT.cstring）,地址信息存储在在变量的后8自己中，真实地址= 后面的地址+0x20</li><li>append 后有大于0xf，会开辟空间</li></ol><p><strong>dyld_stub_binder</strong></p><ol><li>stub 翻译为符号</li><li>动态库中的函数，加载完动态库才能知道（也就是运行的时候才知道），那么编译的时候怎么办？ 放置一个占位地址，这个函数就是一个占位地址</li></ol><p><strong>数组的内存结构</strong></p><p> arr占用8字节，这8字节存储着堆空间地址，堆空间结构：</p><ol><li>？</li><li>引用计数</li><li>元素数量</li><li>数组容量</li><li>元素1</li><li>元素2</li><li>元素3</li><li>元素n</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;0x30是数字0的ascii码&lt;/li&gt;
&lt;li&gt;tag pointer 干嘛用的？直接将内容放在变量的地址中&lt;/li&gt;
&lt;li&gt;rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Block的本质</title>
    <link href="http://yoursite.com/wiki/IOS/Block/block/"/>
    <id>http://yoursite.com/wiki/IOS/Block/block/</id>
    <published>2019-09-27T04:07:12.000Z</published>
    <updated>2019-09-29T02:28:33.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解block的本质</p><a id="more"></a><h2 id="block的底层实现"><a href="#block的底层实现" class="headerlink" title="block的底层实现"></a>block的底层实现</h2><p>源码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (^<span class="keyword">block)(void) </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="name">*block</span>)(<span class="name">void</span>) = &amp;__main_block_impl_0(<span class="name">__main_block_func_0</span>, <span class="symbol">&amp;__main_block_desc_0_DATA</span>)<span class="comment">;</span></span><br><span class="line">block-&gt;FuncPtr(<span class="name">block</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>所以，block 的本质是<code>__main_block_impl_0</code>结构体，构造一个<code>__main_block_impl_0</code>结构，将<code>__main_block_impl_0</code>的地址赋值给block,执行block的过程是通过block找到函数指针FuncPtr，调用。  <code>__main_block_impl_0</code>的结构如下（这几个结构体名字不好记，牢记impl是整体实现，实现里面有函数指针func）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>包含两个成员，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;   <span class="comment">//isa，说明是OC对象</span></span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;  <span class="comment">//block内的代码封装为函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>其中，函数指针 <code>__main_block_func_0</code>的定义</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量字符串定义在数据区</span></span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>整体捋下思路，block的结构简单理解为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Block是一个<span class="keyword">impl</span>结构  -&gt;__block_impl     -&gt; isa，表明是OC对象</span><br><span class="line">                   |                  -&gt; func函数指针,封装block的代码</span><br><span class="line">                   |</span><br><span class="line">                   -&gt; 描述</span><br></pre></td></tr></table></figure><blockquote><p>总结: block的本质就是封装了函数调用以及函数调用环境的OC对象</p></blockquote><h2 id="带参数的block"><a href="#带参数的block" class="headerlink" title="带参数的block"></a>带参数的block</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) = ^(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d,%d"</span>,a,b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">block</span>(c, d);</span><br></pre></td></tr></table></figure><p>翻译为CPP代码:</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化<span class="keyword">block</span>对象</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) =</span><br><span class="line">&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line">//执行<span class="keyword">block</span></span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>, c, d);</span><br></pre></td></tr></table></figure><p>各个结构的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block的底层结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//block内的函数指针</span></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself, int a, int b) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_3e8a17_mi_0,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><h2 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h2><ol><li>在OC中变量的类型主要使用三种, 分别是auto、static、全局变量, 其中auto和static修饰的是局部变量</li><li>对这三种类型的变量, block在使用使用时, 会有不同的捕获方式</li></ol><h3 id="auto变量捕获-值捕获"><a href="#auto变量捕获-值捕获" class="headerlink" title="auto变量捕获(值捕获)"></a>auto变量捕获(值捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    int age;  <span class="comment">//多了一个成员变量</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int _age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//age的赋值是通过构造函数初始化列表完成的</span></span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">    int age = __cself-&gt;age; <span class="comment">// bound by copy 取出block结构内的age</span></span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_82fbf9_mi_0,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，block对于auto变量会值不会，通过在block底层结构中增加捕获的变量定义。</p><h3 id="static变量捕获-指针捕获"><a href="#static变量捕获-指针捕获" class="headerlink" title="static变量捕获(指针捕获)"></a>static变量捕获(指针捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);  //输出<span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//将age的地址传入block的构造函数中</span></span><br><span class="line">void <span class="comment">(*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age);</span></span><br><span class="line"><span class="comment">age = 25;</span></span><br><span class="line"><span class="comment">block-&gt;FuncPtr(__block_impl *)</span><span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  int *age;   <span class="comment">//定义为指针类型</span></span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//构造列表是初始化age指针</span></span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">  int *age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_1d503d_mi_0,(*age));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="block中使用全局变量-不会捕获"><a href="#block中使用全局变量-不会捕获" class="headerlink" title="block中使用全局变量(不会捕获)"></a>block中使用全局变量(不会捕获)</h3><p>全局变量不捕获</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/wiki/IOS/Block/block/block1.png" alt="block总结"></p><h2 id="点点滴滴"><a href="#点点滴滴" class="headerlink" title="点点滴滴"></a>点点滴滴</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="keyword">arch</span> arm64 -rewrite-objc main.<span class="built_in">m</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解block的本质&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/categories/IOS/Block/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>学习runtime的参考文档</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/reffer/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/reffer/</id>
    <published>2019-09-19T03:38:11.000Z</published>
    <updated>2019-09-19T07:15:43.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录学习runtime过程中，有用的文档。</p><a id="more"></a><h2 id="学习过的文档"><a href="#学习过的文档" class="headerlink" title="学习过的文档"></a>学习过的文档</h2><ol><li><a href="https://juejin.im/user/5a329c1351882529707931f0/posts" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记</a></li><li><a href="https://juejin.im/post/5b248ad151882574e808d3c9" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第一天: Objective-C的本质</a></li><li><a href="https://juejin.im/post/5b646f44f265da0fae4f3e6c" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第二天: OC对象的分类</a></li><li></li></ol><h2 id="通用文档"><a href="#通用文档" class="headerlink" title="通用文档"></a>通用文档</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录学习runtime过程中，有用的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>多线程参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/referr/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/referr/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-18T10:39:43.475Z</updated>
    
    <content type="html"><![CDATA[<p>记录读过的文章</p><a id="more"></a><h2 id="读过的文章"><a href="#读过的文章" class="headerlink" title="读过的文章"></a>读过的文章</h2><ol><li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></li><li><a href="https://objccn.io/issue-2-1/#challenges" rel="external nofollow noopener noreferrer" target="_blank">并发编程：API 及挑战</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" rel="external nofollow noopener noreferrer" target="_blank">深入理解RunLoop</a>    </li><li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『RunLoop』详尽总结</a></li></ol><h2 id="需要读的"><a href="#需要读的" class="headerlink" title="需要读的"></a>需要读的</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrency Programming Guide</a></li><li><a href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/" rel="external nofollow noopener noreferrer" target="_blank">浅谈iOS多线程(源码)</a></li><li><a href="https://objccn.io/issue-2-3/" rel="external nofollow noopener noreferrer" target="_blank">底层并发 API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录读过的文章&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperation/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperation/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T09:45:48.872Z</updated>
    
    <content type="html"><![CDATA[<p>NSOperation类文档学习记录</p><a id="more"></a><h2 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h2><p>依赖可以控制操作执行的顺序，相关函数：</p><ol><li>addDependency</li><li>removeDependency</li></ol><p>当依赖的operation全部为完成状态时，operation才能为ready的状态。当最后一个依赖完成后，operation的状态变为ready状态。</p><p>依赖不区分operation是完成了还是取消了。</p><h2 id="KVO属性"><a href="#KVO属性" class="headerlink" title="KVO属性"></a>KVO属性</h2><p>KVO属性包括：</p><ol><li>isCancelled</li><li>isAsynchronous</li><li>isExecuting</li><li>isFinished</li><li>isReady</li><li>dependencies</li><li>queuePriority</li><li>completionBlock</li></ol><h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>多线程调用NSOperation的方法时安全的，不需要加锁。<br>子类的自定义方法需要考虑多线程问题。</p><h2 id="异步VS同步"><a href="#异步VS同步" class="headerlink" title="异步VS同步"></a>异步VS同步</h2><p>操作可以手动执行、也可以添加到queue中执行。</p><p>手动执行（直接调用start方法），分为同步operation和异步operation ，同步在当前线程立即执行。异步在新的线程执行任务。</p><p>如果操作在队列中执行，一般定义为同步的，队列不关注asynchronous属性，总是在一个单独的线程中调用start方法。所有没有理由设计为异步的。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>非并发队列：重写 main方法。<br>并发队列：需要重写start、 asynchronous、executing、finished方法。</p><p><strong>注意是否重写main决定了是否是并发操作。</strong></p><p>下面是子类化的要点：</p><ol><li>在并发队列中，start方法负责异步开始操作。</li><li>start方法中需要通过KVO更新operation的executing状态为YES。</li><li>operation完成或取消后，并发队列必须通过KVO更新isExecuting为NO 和 isFinished为YES。如果是取消，也需要更新isFinished状态为YES。</li><li>operation 只有完成了，才能从queue中移除。</li><li>同时需要重写 executing、finished属性（KVC）。</li><li>start方法需要检查是否operation被取消了。</li><li>如果定制了依赖，需要KVO isReady属性。</li></ol><p><strong>状态管理</strong>：</p><ol><li>isReady，一般不用管理，依赖的时候处理。</li><li>isExecuting，替换了start方法，一定要替换isExecuting方法，并在start开始的时候发出KVO</li><li>isFinished，替换了start方法，一定要替换isFinished方法。operation完成或取消，发出KVO</li><li>isCancelled，不需要发出KVO</li></ol><p><strong>响应取消</strong></p><p>一旦将operation添加到queue中，queue就掌管了operation。你可以通过调用operation的cancell方法取消，或者通过queue的cancelAllOperations取消。</p><p>执行中的任务并不会立马取消， 你必须显式的检测状态，需要的时候取消。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSOperation类文档学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperaionQueue 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperaionQueue/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperaionQueue/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-12-09T06:34:14.171Z</updated>
    
    <content type="html"><![CDATA[<p>记录NSOperaionQueue的理解</p><a id="more"></a><p><img src="/wiki/IOS/多线程/NSOperaionQueue/operaionQueue.png" alt="Queue执行operaion的流程"><br><img src="/wiki/IOS/多线程/NSOperaionQueue/2.png" alt="是否并发文档"></p><h2 id="NSOperation与GCD区别"><a href="#NSOperation与GCD区别" class="headerlink" title="NSOperation与GCD区别"></a>NSOperation与GCD区别</h2><p>其实我们在通过NSOperation和GCD进行开发过程中，会发现两者执行的方式有许多相似之处，NSOperation和GCD参照对比，NSOperationQueue和dispatch_queue参照对比，但是两者之间还是有许多差别的，具体区别:</p><ol><li><p>GCD的核心是C语言写的系统服务，执行和操作简单高效，因此NSOperation底层也通过GCD实现，换个说法就是NSOperation是对GCD更高层次的抽象，这是他们之间最本质的区别。因此如果希望自定义任务，建议使用NSOperation</p></li><li><p>依赖关系，NSOperation可以设置两个NSOperation之间的依赖，第二个任务依赖于第一个任务完成执行，GCD无法设置依赖关系，不过可以通过dispatch_barrier_async来实现这种效果；</p></li><li>KVO(键值对观察)，NSOperation和容易判断Operation当前的状态(是否执行，是否取消)，对此GCD无法通过KVO进行判断；</li><li>优先级，NSOperation可以设置自身的优先级，但是优先级高的不一定先执行，GCD只能设置队列的优先级，无法在执行的block设置优先级；</li><li>继承，NSOperation是一个抽象类，实际开发中常用的两个类是NSInvocationOperation和NSBlockOperation，同样我们可以自定义NSOperation，GCD执行任务可以自由组装，没有继承那么高的代码复用度；</li><li>效率，直接使用GCD效率确实会更高效，NSOperation会多一点开销，但是通过NSOperation可以获得依赖，优先级，继承，键值对观察这些优势，相对于多的那么一点开销确实很划算，鱼和熊掌不可得兼，取舍在于开发者自己；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录NSOperaionQueue的理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
</feed>
