<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-08T03:57:44.740Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>aspect源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/Aspects/aspect/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/Aspects/aspect/</id>
    <published>2019-08-08T02:07:12.000Z</published>
    <updated>2019-08-08T03:57:44.740Z</updated>
    
    <content type="html"><![CDATA[<p>图解<a href="https://github.com/steipete/Aspects" rel="external nofollow noopener noreferrer" target="_blank">aspect</a>。</p><a id="more"></a><h2 id="图解aspect"><a href="#图解aspect" class="headerlink" title="图解aspect"></a>图解aspect</h2><p>aspect 切方法分为两种：</p><ol><li>为实例切方法，只实例有效，类的其他实例不受影响，类似KVO，原理是交换了isa。</li><li>为类切方法： 交换了类的实例方法，所有实例都生效。</li></ol><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_1.png" alt="aspect主流程"></p><p>其实看过原理后，就交换了两个方法，一个是当前selector，一个是forwardInvocation。<br><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_2.png" alt="aspect交换方法后的结果"></p><p>一定要理解方法的中包含SEL、IMP，SEL理解为方法的名称，IMP是方法的代码实现，图中很多地方使用SEL、IMP后缀区分两着。</p><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_3.png" alt="aspect执行切片方法的流程"></p><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_4.png" alt="aspect执行切片方法的流程直观理解"><br>特别注意步骤9，解决的是如果向切片类发送了非切片方法，还走原来的消息转发流程，如不认识的方法报 not recognize selector send to instance错误。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解&lt;a href=&quot;https://github.com/steipete/Aspects&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;aspect&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="Aspects" scheme="http://yoursite.com/categories/IOS/opensource/Aspects/"/>
    
    
      <category term="aspect" scheme="http://yoursite.com/tags/aspect/"/>
    
  </entry>
  
  <entry>
    <title>方法交换理解</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/method_swizzing/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/日常总结/method_swizzing/</id>
    <published>2019-08-06T03:38:11.000Z</published>
    <updated>2019-08-06T08:40:11.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解方法交换写法的含义</p><a id="more"></a><h2 id="方法交换源码解读"><a href="#方法交换源码解读" class="headerlink" title="方法交换源码解读"></a>方法交换源码解读</h2><p>下面是方法交换的常用源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector</span><br><span class="line">&#123;</span><br><span class="line">    Class <span class="class"><span class="keyword">class</span> = [<span class="title">self</span> <span class="title">class</span>];</span></span><br><span class="line">    </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">origSelector);</span></span></span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">newSelector);</span></span></span><br><span class="line">    </span><br><span class="line">    BOOL didAddMethod = class_addMethod(<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                        origSelector,</span><br><span class="line">                                        method_getImplementation(swizzledMethod),</span><br><span class="line">                                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                            newSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。</p><p>下面分析 class_addMethod的源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, <span class="literal">NO</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class_addMethod 内部调用了addMethod，并将addMethod的结果取反，作为返回值。其中replace参数（最后一个）传递NO，表示如果类中存在该方法（originalMethod），不替换。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static IMP </span><br><span class="line">addMethod(Class cls, SEL <span class="keyword">name</span>, IMP imp, const char *types, bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    assert(types);</span><br><span class="line">    <span class="function"><span class="title">assert</span>(cls-&gt;</span>isRealized());</span><br><span class="line"></span><br><span class="line">    method_t *m;</span><br><span class="line">    <span class="keyword">if</span> ((m = getMethodNoSuper_nolock(cls, <span class="keyword">name</span>))) &#123;</span><br><span class="line">        <span class="comment">// already exists</span></span><br><span class="line">        <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">            <span class="function"><span class="title">result</span> = m-&gt;</span>imp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fixme optimize</span></span><br><span class="line">        method_list_t *newlist;</span><br><span class="line">        newlist = (method_list_t *)calloc(sizeof(*newlist), <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>entsizeAndFlags = </span><br><span class="line">            (uint32_t)sizeof(method_t) | fixed_up_method_list;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>count = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.types = strdupIfMutable(types);</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, <span class="number">1</span>, NO, NO);</span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>methods.attachLists(&amp;newlist, <span class="number">1</span>);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先查找类是否有方法，如果有，返回方法，如果没有添加并返回空，所以addMethod的返回值可以理解为<strong>返回旧的方法</strong>。</p><p>所以进一步理解class_addMethod返回值的含义： 它取反了addMethod的结果，所以，添加成功，返回yes，没有添加成功（也就是存在方法），返回no。</p><p>方法添加成功，也就是类中没有originalMethod方法，调用了class_replaceMethod，接着看class_replaceMethod方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMP </span><br><span class="line">class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> addMethod(cls, name, imp, types ?: <span class="string">""</span>, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面class_addMethod添加成功，说明原始类是没有旧方法，也就不用管我们添加的旧方法，所以直接调用class_replaceMethod将<strong>添加的方法originalMethod</strong>换为新方法即可，不需要交换，所以，传递给addMethod方法的最后一个参数是yes，<strong>直接替换</strong>。</p><p>如果没有添加成功，说明原类中有originalMethod，所以不能直接替换，如果直接替换了，调用原方法的函数就会出问题（死循环），需要交换，条用method_exchangeImplementations交换方法。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(<span class="function"><span class="keyword">Method</span> <span class="title">m1_gen</span>, <span class="title">Method</span> <span class="title">m2_gen</span>)</span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    IMP m1_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    old_method *m1 = oldmethod(m1_gen);</span></span></span><br><span class="line"><span class="function"><span class="comment">    old_method *m2 = oldmethod(m2_gen);</span></span></span><br><span class="line"><span class="function"><span class="comment">    if (!m1  ||  !m2) return;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    impLock.lock();</span></span></span><br><span class="line"><span class="function"><span class="comment">    m1_imp = m1-&gt;method_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    m1-&gt;method_imp = m2-&gt;method_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    m2-&gt;method_imp = m1_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    impLock.unlock();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解方法交换写法的含义&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="日常总结" scheme="http://yoursite.com/categories/IOS/Runtime/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1_10/3_%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/LeetCode/top1_10/3_无重复字符的最长子串/</id>
    <published>2019-07-25T09:07:12.000Z</published>
    <updated>2019-07-25T09:31:21.420Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/wiki/数据结构与算法/LeetCode/top1_10/3_无重复字符的最长子串/1_两数之和/problem.png" alt="题目"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">       <span class="comment">// num = [2, 7, 11, 15] target = 9</span></span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i, v) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="comment">// i = 0, v = 2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - v] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dict[v] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"NO Output"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/数据结构与算法/LeetCode/top1_10/3_无重复字符的最长子
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="top1_10" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1-10/"/>
    
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1_10/5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/LeetCode/top1_10/5_最长回文子串/</id>
    <published>2019-07-25T09:07:12.000Z</published>
    <updated>2019-07-25T09:31:21.420Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/wiki/数据结构与算法/LeetCode/top1_10/5_最长回文子串/1_两数之和/problem.png" alt="题目"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">       <span class="comment">// num = [2, 7, 11, 15] target = 9</span></span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i, v) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="comment">// i = 0, v = 2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - v] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dict[v] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"NO Output"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/数据结构与算法/LeetCode/top1_10/5_最长回文子串/1_
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="top1_10" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1-10/"/>
    
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1_10/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/</id>
    <published>2019-07-25T09:07:12.000Z</published>
    <updated>2019-07-25T09:31:21.420Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/problem.png" alt="题目"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">       <span class="comment">// num = [2, 7, 11, 15] target = 9</span></span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i, v) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="comment">// i = 0, v = 2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - v] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dict[v] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"NO Output"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/prob
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="top1_10" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1-10/"/>
    
    
  </entry>
  
  <entry>
    <title>4.4 最短路径</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/4.4%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/</id>
    <published>2019-07-25T04:07:12.000Z</published>
    <updated>2019-07-25T07:30:53.139Z</updated>
    
    <content type="html"><![CDATA[<p>记录最短路径相关的主要内容</p><a id="more"></a><p>最短路径： 在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中权重最小者</p><p>最短路径树： 包含了顶点s到所有可达的顶点的最短路径</p><h2 id="加权有向图的数据结构"><a href="#加权有向图的数据结构" class="headerlink" title="加权有向图的数据结构"></a>加权有向图的数据结构</h2><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/edgeweight_direct_graph.png" alt="加权有向图邻接表"></p><p>下面是实现的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDigraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _vertex: <span class="type">Int</span>  <span class="comment">//顶点的个数</span></span><br><span class="line">    <span class="keyword">var</span> _edges: <span class="type">Int</span> <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">var</span> _adj: [[<span class="type">DirectedEdge</span>]] <span class="comment">//邻接表</span></span><br><span class="line">    <span class="keyword">init</span>(vertex: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._vertex = vertex</span><br><span class="line">        <span class="keyword">self</span>._edges = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>._adj = [[<span class="type">DirectedEdge</span>]](repeating: [<span class="type">DirectedEdge</span>](), <span class="built_in">count</span>: vertex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>?(inStream: <span class="type">ReadFile</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">        <span class="keyword">if</span> v != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="keyword">init</span>(vertex: v!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> edge = inStream.readInt()  <span class="comment">//读取边数</span></span><br><span class="line">        <span class="keyword">guard</span> edge != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;edge! &#123;</span><br><span class="line">            <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">            <span class="keyword">let</span> w = inStream.readInt()</span><br><span class="line">            <span class="keyword">let</span> weight = inStream.readDouble()</span><br><span class="line">            <span class="keyword">if</span> v != <span class="literal">nil</span> &amp;&amp; w != <span class="literal">nil</span> &amp;&amp; weight != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> edge = <span class="type">DirectedEdge</span>(v: v!, w: w!, weight: weight!)</span><br><span class="line">                <span class="keyword">self</span>.addEdge(edge)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">v</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回顶点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._vertex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">e</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;  <span class="comment">//返回边数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._edges</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addEdge</span><span class="params">(<span class="number">_</span> edge: DirectedEdge)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._adj[edge.form()].insert(edge, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">self</span>._edges += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adj</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; [<span class="type">DirectedEdge</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._adj[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">edges</span><span class="params">()</span></span> -&gt; [<span class="type">DirectedEdge</span>] &#123; <span class="comment">//枚举所有的边</span></span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">DirectedEdge</span>]()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="keyword">self</span>._vertex &#123;</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> <span class="keyword">self</span>.adj(v) &#123;</span><br><span class="line">                result.insert(e, at: <span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路径的数据结构"><a href="#最短路径的数据结构" class="headerlink" title="最短路径的数据结构"></a>最短路径的数据结构</h3><ol><li>最短路径树中的边，由定点索引的DerectedEdge对象的数组edgeTpo[],其中edge[v]的值未树中连接v和它的父节点的边，也是从s到v的最短路径上的最后一条边</li><li>到达起点的距离： 由定点索引的数据distTo[]，其中distTo[v]为从s到v的已知最短路径的长度</li></ol><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/shotPath_data.png" alt="最短路径的数据结构"></p><h3 id="边的松弛"><a href="#边的松弛" class="headerlink" title="边的松弛"></a>边的松弛</h3><p>放松边v-&gt;w意味着检测从s到w的最短路径是否先从s到v，然后再由v到w，如果是，则根据这个情况，更新数据结构的内容</p><p>放松一条边，意味着将橡皮筋移到一条更短的路径上，从而缓解了橡皮筋的压力</p><p>如果relax改变了边e相关的顶点distTo[e.to()]的值，称为e的放松是成功的。</p><p>下图是松弛的示意图</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/relax.png" alt="边的松弛"></p><p>下面是边的松弛代码</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func relax(<span class="number">_</span> <span class="keyword">edge</span>: DirectedEdge)  &#123;  <span class="comment">//边的松弛</span></span><br><span class="line">    <span class="keyword">let</span> v = <span class="keyword">edge</span><span class="variable">.form</span>()</span><br><span class="line">    <span class="keyword">let</span> w = <span class="keyword">edge</span><span class="variable">.to</span>()</span><br><span class="line">    <span class="keyword">if</span> distTo[w] &gt; distTo[v] + <span class="keyword">edge</span><span class="variable">.weight</span>() &#123;</span><br><span class="line">        distTo[w] = distTo[v] + <span class="keyword">edge</span><span class="variable">.weight</span>()</span><br><span class="line">        edgeTo[w] = <span class="keyword">edge</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点松弛"><a href="#顶点松弛" class="headerlink" title="顶点松弛"></a>顶点松弛</h3><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/relax_vertex.png" alt="顶点松弛"></p><p>顶点松弛代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relax</span><span class="params">(<span class="number">_</span> graph: EdgeWeightedDigraph, v: Int)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> edge <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">        <span class="keyword">let</span> w = edge.to()</span><br><span class="line">        <span class="keyword">if</span> distTo[w] &gt; distTo[v] + edge.weight() &#123;</span><br><span class="line">            distTo[w] = distTo[v] + edge.weight()</span><br><span class="line">            edgeTo[w] = edge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最短路径算法的理论基础"><a href="#最短路径算法的理论基础" class="headerlink" title="最短路径算法的理论基础"></a>最短路径算法的理论基础</h2><h3 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h3><p>命题P：令G为一幅加权有向图，顶点s是G的起点，distTo[] 是一个由顶点索引的数组，保存的是G中路径的长度，对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的顶点v，该值是无穷大。 当且仅当对于从v到w的任意一条边e，这些值满足distTo[w] &lt;= distTo[v] + e.weight()</p><p>命题J： distTo[s] 的初始值为0. 其他distTo[] 元素初始化为无穷大，继续如下操作：</p><p>放松G中的任意边，知道不存在有效的边为止，这里有效的含义是没有被放松过。</p><h2 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h2><p>思路： 首先将distTo[s] 初始化为0. distTo[] 中的其他元素初始化为无穷大，然后将distTo最小的非树顶点放松，并加入树中。</p><p>命题R： Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。</p><p>Prim算法每次添加的都是离树最近的顶点，Dijkstra算法每次添加的都是离起点最近的顶点。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/Dijkstra_trace.png" alt="Dijkstra 算法轨迹"></p><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> edgeTo: [<span class="type">DirectedEdge</span>] <span class="comment">//保存路径树，只是和索引顶点连接的父节点对象</span></span><br><span class="line">    <span class="keyword">var</span> distTo: [<span class="type">Double</span>] <span class="comment">//所以是顶点， 顶点到起点的距离</span></span><br><span class="line">    <span class="keyword">var</span> pq: <span class="type">IndexMinPQ</span>&lt;<span class="type">Double</span>&gt;</span><br><span class="line">    <span class="keyword">let</span> s: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">EdgeWeightedDigraph</span>, s: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> vertexCount = graph.v()</span><br><span class="line">        <span class="keyword">self</span>.edgeTo = [<span class="type">DirectedEdge</span>](repeating: <span class="type">DirectedEdge</span>(), <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>.distTo = [<span class="type">Double</span>](repeating: <span class="type">Double</span>(<span class="type">Int</span>.<span class="built_in">max</span>), <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        pq = <span class="type">IndexMinPQ</span>&lt;<span class="type">Double</span>&gt;(maxN: vertexCount)!</span><br><span class="line">        <span class="keyword">self</span>.s = s</span><br><span class="line">        <span class="comment">//第二阶段构造</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">try</span>! pq.insert(index: s, forKey: <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">while</span> !pq.isEmpty() &#123;</span><br><span class="line">            relax(graph,<span class="keyword">try</span>! pq.delMin())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">relax</span><span class="params">(<span class="number">_</span> edge: DirectedEdge)</span></span>  &#123;  <span class="comment">//边的松弛</span></span><br><span class="line">        <span class="keyword">let</span> v = edge.form()</span><br><span class="line">        <span class="keyword">let</span> w = edge.to()</span><br><span class="line">        <span class="keyword">if</span> distTo[w] &gt; distTo[v] + edge.weight() &#123;</span><br><span class="line">            distTo[w] = distTo[v] + edge.weight()</span><br><span class="line">            edgeTo[w] = edge</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">relax</span><span class="params">(<span class="number">_</span> graph: EdgeWeightedDigraph, <span class="number">_</span> v: Int)</span></span>  &#123; <span class="comment">//顶点的松弛</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            <span class="keyword">let</span> w = edge.to()</span><br><span class="line">            <span class="keyword">if</span> distTo[w] &gt; distTo[v] + edge.weight() &#123;</span><br><span class="line">                distTo[w] = distTo[v] + edge.weight()</span><br><span class="line">                edgeTo[w] = edge</span><br><span class="line">                <span class="keyword">if</span> pq.<span class="built_in">contains</span>(w) &#123;</span><br><span class="line">                    <span class="keyword">try</span>! pq.changeKey(index: w, forKey: distTo[w])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>! pq.insert(index: w, forKey: distTo[w])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">distTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hasPathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; <span class="type">Double</span>(<span class="type">Int</span>.<span class="built_in">max</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; [<span class="type">DirectedEdge</span>]? &#123;</span><br><span class="line">        <span class="keyword">if</span> !hasPathTo(v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> path = <span class="type">Stack</span>&lt;<span class="type">DirectedEdge</span>&gt;()</span><br><span class="line">        <span class="keyword">var</span> x = edgeTo[v]</span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            path.push(x)</span><br><span class="line">            x =  edgeTo[x.form()]</span><br><span class="line">        &#125; <span class="keyword">while</span> x.form() != <span class="keyword">self</span>.s</span><br><span class="line">        path.push(x)  <span class="comment">//添加第一条路径</span></span><br><span class="line">        <span class="keyword">return</span> path.iterater()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无环加权图中最短路径算法"><a href="#无环加权图中最短路径算法" class="headerlink" title="无环加权图中最短路径算法"></a>无环加权图中最短路径算法</h2><p>无环图处理更快，按照拓扑顺序遍历 ，不需要自己维护优先队列了</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/topo_path.png" alt="无环加权图的最短路径"></p><ol><li>用深度优先搜索得到图的顶点的拓扑顺序5  1  3  6  4  7  0  2</li><li>将顶点5 和从他指出的所有边添加到树中</li><li>将顶点1 和边1-&gt;3 添加到树中</li><li>将顶点3和边3-&gt;6添加到树中，边3-&gt;7失效</li><li>将顶点6和6-&gt;2 6-0添加到树中，边6-&gt;4失效</li><li>将顶点4和4-&gt;0添加到树中，边4-&gt;7和6-&gt;0 已经失效</li><li>将顶点7和边7-&gt;2添加到树中， 边6-&gt;2失效</li><li>将顶底0 添加到树中，边0-&gt;2失效</li><li>将顶点2添加到树中</li></ol><p>命题S： 按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。</p><h3 id="最长路径"><a href="#最长路径" class="headerlink" title="最长路径"></a>最长路径</h3><p>命题T： 解决无环加权有向图中最长路径问题所需的事件与V+E成正比。</p><p>证明： 给定一个最长路径问题，复制原始无环加权有向图得到一个副本，并将副本中的所有权重变为负值，这样，副本中的最短路径即为原图中的最长路径，要将最短路径问题的答案转化为最长路径问题的答案，只需要将方案中权重变为正值即可。 根据命题S可得到算法的时间复杂度为E+V</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/topo_long_path.png" alt="无环加权图的最长路径算法轨迹"></p><p>最长路径的应用： 优先级限制下的并行任务调度。 也叫关键路径法</p><h3 id="优先级限制下的并行任务调度"><a href="#优先级限制下的并行任务调度" class="headerlink" title="优先级限制下的并行任务调度"></a>优先级限制下的并行任务调度</h3><p>任务如下：</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/task_data.png" alt="任务问题"></p><p>解决并行任务调度问题的关键路径方法的步骤如下： 创建一幅无环加权有向图，其中包括一个起点s和一个重点t，且每个任务都对应着两个顶点，一个起始顶点和一个结束顶点。对于每个任务都有一条从他的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每个优先级限制v-&gt;w，添加一条从v的结束顶点指向w的起始顶点的权重为0的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为0的边，以及一条从该任务的结束顶点到终点的权重为0的边。这样一个任务预计的开始时间即为从起点到它的起始顶点的最长距离。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/task.png" alt="任务建模为图"></p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/task_long_path.png" alt="任务的关键路径"></p><p>下面讲了一个最后期限下的并行任务调度，引出了负权重可能在实际中的用处，进入下一节</p><h2 id="一般加权有向图中的最短路径问题"><a href="#一般加权有向图中的最短路径问题" class="headerlink" title="一般加权有向图中的最短路径问题"></a>一般加权有向图中的最短路径问题</h2><h3 id="负权重环"><a href="#负权重环" class="headerlink" title="负权重环"></a>负权重环</h3><p>加权有向图中的负权重环是一个总权重为负的有向环</p><p>负权重环存在的情况下，可以构建任意小的路径，所以研究最短路径没啥意义</p><p>命题X（Bellman-ford算法）：在任意含有V个顶点的加权有向图中给定起点s ，从s无法到达任何负权重环，以下算法能够解决其中的单点点最短路径问题： 将diatTo[s]初始化为0，其他distTo[]元素初始化为无穷大，以任意顺序放松有向图中的所有边，重复V轮。证明使用归纳法</p><p>Dellman-ford： 只有上一轮中的distTo[]值发送变化的顶点指出的边才能改变其他distTo[]元素的值，为了记住这样的顶点，使用FIFO优先队列。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/bellmanford_trace.png" alt="任务的关键路径"></p><p>说明：</p><ol><li>放松边1-3  将顶点3加入队列中</li><li>放松边3-6 将顶点6加入队列中</li><li>放松边6-4 6-0 6-2，将顶点4 0 2 加入队列中</li><li>放松边4-7 4-5 将顶点7 4 加入队列中，放松已经失效的边0-4 0 -2 软后再放松2-7 并重新为4 -7着色</li><li>放松7 -5 并重新为4-5着色，办不将顶点5加入队列中，他已经在队列中了，放松已经失效的边7-3 然后放松已经失效的边5-1 5-4 5-7 此时队列为空</li></ol><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录最短路径相关的主要内容&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
      <category term="第4章图" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>4.3 最小生成树</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/4.3%20%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/</id>
    <published>2019-07-23T04:07:12.000Z</published>
    <updated>2019-07-24T11:06:35.009Z</updated>
    
    <content type="html"><![CDATA[<p>图的生成树是它的一棵含有所有顶点的无环连通子图，一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之后)最小的生成树</p><p>最小生成树的解决方法有： prim算法、kruskal算法</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>树的性质：</p><ol><li>用一条边连接树中的任意两个顶点都会产生一个新的环</li><li>从树中删去一条边会得到两棵独立的树</li></ol><p>切分定理： 图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合，横切边是一条连接两个属于不同集合的顶点的边</p><p>命题j： 在一幅加权图中，给定任意的切分，它的横切边中权重最小者必然属于图的最小生成树</p><p>证明： 令e为权重最小的横切边，T为图的最小生成树，我们采用反证法：假设T不包含e，那么如果将e假如T，得到的图必要包含一条经过e的环，且这个环至少包含另一条横切边，设为f ，f的权重必然大于e，那么我们删除调f，而保留e就可以得到一颗权重更小的生成树。和我们的假设矛盾。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/mst_propery.png" alt="最小生成树的性质"></p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/mst_cut.png" alt="最小生成树的切分原理"></p><p>命题K(最小生成树的贪心算法) 下面这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下，所有边均为灰色，找到一种切分，它产生的横切边均不为黑色，将它的权重最小的横切边标记为黑色，反复，知道标记了V-1条黑色的边为止。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/mst_cut_process.png" alt="小生成树的贪心算法的过程展示"></p><h2 id="加权无向图的数据类型"><a href="#加权无向图的数据类型" class="headerlink" title="加权无向图的数据类型"></a>加权无向图的数据类型</h2><p>边的代码实现如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EdgeError</span>: <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> invalidEdge(egdg: <span class="type">Int</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> :<span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _v: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> _w: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> _weight: <span class="type">Double</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(v: <span class="type">Int</span>, w: <span class="type">Int</span>, weight: <span class="type">Double</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._v = v</span><br><span class="line">        <span class="keyword">self</span>._w = w</span><br><span class="line">        <span class="keyword">self</span>._weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">weight</span><span class="params">()</span></span> -&gt; <span class="type">Double</span> &#123;  <span class="comment">//返回权重</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._weight</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">either</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回任意一个顶点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._v</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">other</span><span class="params">(<span class="number">_</span> v: Int)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回另一个顶点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>._v == v &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._w</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>._w == v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._v</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"取顶点错误"</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">EdgeError</span>.invalidEdge(egdg: v)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> &lt; (lhs: Edge, rhs: Edge) -&gt; <span class="title">Bool</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> lhs._weight &lt; rhs._weight &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Edge, rhs: Edge)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>  lhs._weight == rhs._weight &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>.<span class="keyword">init</span>(format: <span class="string">"%d,%d,%.2f"</span>, <span class="keyword">self</span>._v, <span class="keyword">self</span>._w, <span class="keyword">self</span>._weight)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加权图的实现如下：</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _vertex: <span class="keyword">Int</span>  <span class="comment">//顶点的个数</span></span><br><span class="line">    <span class="keyword">var</span> _edges: <span class="keyword">Int</span> <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">var</span> _adj: [[Edge]] <span class="comment">//邻接表</span></span><br><span class="line">    init(vertex: <span class="keyword">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._vertex = vertex</span><br><span class="line">        <span class="keyword">self</span>._edges = <span class="number">0</span></span><br><span class="line">        <span class="keyword">self</span>._adj = [[Edge]](repeating: [Edge](), count: vertex)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    convenience init?(inStream: ReadFile) &#123;</span><br><span class="line">        <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">        <span class="keyword">if</span> v != nil &#123;</span><br><span class="line">            <span class="keyword">self</span>.init(vertex: v!)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> edge = inStream.readInt()</span><br><span class="line">        <span class="keyword">if</span> edge != nil &#123;</span><br><span class="line">            <span class="keyword">for</span> _ in <span class="number">0.</span>.&lt;edge! &#123;</span><br><span class="line">                <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">                <span class="keyword">let</span> w = inStream.readInt()</span><br><span class="line">                <span class="keyword">let</span> weight = inStream.readDouble()</span><br><span class="line">                <span class="keyword">if</span> v != nil &amp;&amp; w != nil &amp;&amp; weight != nil &#123;</span><br><span class="line">                    <span class="keyword">let</span> edge = Edge(v: v!, w: w!, weight: weight!)</span><br><span class="line">                    <span class="keyword">self</span>.addEdge(edge)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> nil</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nil</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func v() -&gt; <span class="keyword">Int</span> &#123; <span class="comment">//返回顶点数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._vertex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func e() -&gt; <span class="keyword">Int</span> &#123;  <span class="comment">//返回边数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._edges</span><br><span class="line">    &#125;</span><br><span class="line">    func addEdge(_ edge: Edge) &#123;</span><br><span class="line">        <span class="keyword">let</span> v = edge.either()</span><br><span class="line">        <span class="keyword">let</span> w = <span class="keyword">try</span>! edge.other(v)</span><br><span class="line">        <span class="keyword">self</span>._adj[v].insert(edge, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">self</span>._adj[w].insert(edge, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">self</span>._edges += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func adj(_ v: <span class="keyword">Int</span>) -&gt; [Edge] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._adj[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func edges() -&gt; [Edge] &#123; <span class="comment">//枚举所有的边</span></span><br><span class="line">        <span class="keyword">var</span> result = [Edge]()</span><br><span class="line">        <span class="keyword">for</span> v in <span class="number">0.</span>.&lt;<span class="keyword">self</span>._vertex &#123;</span><br><span class="line">            <span class="keyword">for</span> e in <span class="keyword">self</span>.adj(v) &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">try</span>! e.other(v) &gt; v &#123;</span><br><span class="line">                    result.insert(e, at: <span class="number">0</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func toString() -&gt; String &#123;</span><br><span class="line">        <span class="keyword">var</span> result: String  =</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        \(self.v()) vertixes \(self.e()) edges \n</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="number">0.</span>.&lt;<span class="keyword">self</span>.v() &#123;</span><br><span class="line">            result += <span class="string">"\(i) :"</span></span><br><span class="line">            <span class="keyword">for</span> w in <span class="keyword">self</span>.adj(i) &#123;</span><br><span class="line">                result += <span class="string">"\(w.toString())   "</span></span><br><span class="line">            &#125;</span><br><span class="line">            result +=</span><br><span class="line">            <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            \n</span></span><br><span class="line"><span class="string">            "</span><span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> func test() &#123;</span><br><span class="line">        <span class="keyword">let</span> path = TinyEWG</span><br><span class="line">        <span class="keyword">let</span> file = ReadFile(fileName: path)</span><br><span class="line">        guard  file != nil <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">"建立文件失败！！！"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> edgeGraph = EdgeWeightedGraph(inStream: file!)</span><br><span class="line">        guard edgeGraph != nil <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">print</span>(<span class="string">"建立图失败"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> result = edgeGraph!.toString()</span><br><span class="line">        <span class="keyword">print</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树的API-和测试用例"><a href="#最小生成树的API-和测试用例" class="headerlink" title="最小生成树的API 和测试用例"></a>最小生成树的API 和测试用例</h2><p>最小生成树的表示方法：</p><ol><li>一组边的列表</li><li>一幅加权无向图</li><li>一个以顶点为索引且包含父节点链接的数组</li></ol><h2 id="Prim-算法"><a href="#Prim-算法" class="headerlink" title="Prim 算法"></a>Prim 算法</h2><p>思路： 一开始，这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中顶点与不在树中的顶点，且权重最小的边假如树中（即由树中顶点所定义的切分中的一条横切边）。</p><p>每当我们向树中添加一条边之后，也向树中添加一个顶点。 就要将连接这个顶点和其他所有不在树中的顶点加入到优先队列中，用marked[]来标识， 但是还有一点，连接新加入树中的顶点，与其他已经在树中的顶点的所有边都失效了。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/prim_trace.png" alt="prim算法的轨迹"></p><p>源码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]  <span class="comment">//标记是否加入最小生成树中</span></span><br><span class="line">    <span class="keyword">var</span> _mst: <span class="type">Queue</span>&lt;<span class="type">Edge</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> _pq: <span class="type">MinPQ</span>&lt;<span class="type">Edge</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">EdgeWeightedGraph</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> vertexCount = graph.v()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>._mst = <span class="type">Queue</span>&lt;<span class="type">Edge</span>&gt;()</span><br><span class="line">        <span class="keyword">self</span>._pq = <span class="type">MinPQ</span>&lt;<span class="type">Edge</span>&gt;(priorityFunction: &#123;  <span class="comment">//优先队列，小的优先级高</span></span><br><span class="line">            <span class="keyword">return</span> $<span class="number">0</span> &lt; $<span class="number">1</span></span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二阶段了 ，自定义操作</span></span><br><span class="line">        visit(graph, <span class="number">0</span>) <span class="comment">//将顶点0的邻接表添加到优先队列中</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> !<span class="keyword">self</span>._pq.isEmpty &#123;</span><br><span class="line">            <span class="keyword">let</span> e = <span class="keyword">self</span>._pq.dequeue()!  <span class="comment">//从优先队列中取出一条边</span></span><br><span class="line">            <span class="keyword">let</span> v = e.either()</span><br><span class="line">            <span class="keyword">let</span> w = <span class="keyword">try</span>! e.other(v)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>._marked[v] &amp;&amp; <span class="keyword">self</span>._marked[w] &#123; <span class="comment">//如果两个顶点都在树上，那么边是失效的</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>._mst.enqueue(e)</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[v] &#123;</span><br><span class="line">                <span class="keyword">self</span>.visit(graph, v)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;</span><br><span class="line">                <span class="keyword">self</span>.visit(graph, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(<span class="number">_</span> graph: EdgeWeightedGraph, <span class="number">_</span> v: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[<span class="keyword">try</span>! edge.other(v)] &#123;</span><br><span class="line">                _pq.equeue(edge)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">edges</span><span class="params">()</span></span> -&gt; [<span class="type">Edge</span>] &#123;  <span class="comment">//返回最小生成树的边的列表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._mst.iterater()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法的即时实现"><a href="#Prim算法的即时实现" class="headerlink" title="Prim算法的即时实现"></a>Prim算法的即时实现</h2><p>思路： 我们感兴趣的只有连接树顶点和非树顶点中权重最小的边，当我们将点点v添加到树中时，对于每个非树顶点w产生的变化只可能使得w到最小生成树的距离更近了，简而言之，我们不需要在优先队列中保存所有从w到树顶点的边—–而只需要保存其中权重最小的边，在将v添加到树中后，检测是否需要更新这条权重最小的边，因为，v-w可能权重更小，我们只需要遍历v的邻接表就可以完成这个任务。</p><p>核心： 我们只会在优先队列中保存每个非树顶点w的一条边，将它与树中的顶点连接起来权重最小的那条边。</p><p>上面思路理解可以参考下图：</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/Prim_fast.png" alt="prim即时算法的思路原理"></p><p>edgeTo[] 和distTo[] 的理解：</p><ol><li>如果顶点v不在树中，但至少还有一条边和树相连，那么edgeTo[v] 是将v和树相连的最短边，distTo[v]  是这条边的权重</li><li>所有这类顶点v都保存在一条优先队列中。</li><li>每次从优先队列中出最小的边，更新其他还在优先队列中的边</li><li>已经出优先队列的，就是最小生成树的边。</li></ol><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/Prim_trace_eager.png" alt="prim算法的即时轨迹"></p><p>图中颜色的说明：</p><ol><li>黑色： 最小生成树中的顶点</li><li>灰色： 非最小生成树中的顶点</li><li>黑色： 最小生成树的边</li><li>红色： 优先队列中的索引对</li><li>红色： 非最小生成树顶点连接到最小生成树的最短边</li></ol><p>实现代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">extension <span class="string">Double:</span> RequireInit &#123;&#125;</span><br><span class="line"><span class="comment">//Prim算法的即时版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> &#123;</span></span><br><span class="line">    var <span class="string">edgeTo:</span> [Edge] <span class="comment">//保存最小生成树的顶点列表，索引顶点，值到该顶点的边</span></span><br><span class="line">    var <span class="string">distTo:</span> [Double] <span class="comment">//保存边的距离</span></span><br><span class="line">    var <span class="string">marked:</span> [Bool]  <span class="comment">//if true on tree</span></span><br><span class="line">    var <span class="string">pq:</span> IndexMinPQ&lt;Double&gt;</span><br><span class="line">    </span><br><span class="line">    init(<span class="string">graph:</span> EdgeWeightedGraph) &#123;</span><br><span class="line">        let vertexCount = graph.v()</span><br><span class="line">        edgeTo = [Edge](<span class="string">repeating:</span> Edge(), <span class="string">count:</span> vertexCount)</span><br><span class="line">        distTo = [Double](<span class="string">repeating:</span> Double(Int.max), <span class="string">count:</span> vertexCount)</span><br><span class="line">        marked = [Bool](<span class="string">repeating:</span> <span class="literal">false</span>, <span class="string">count:</span> vertexCount)</span><br><span class="line">        pq = IndexMinPQ&lt;Double&gt;(<span class="string">maxN:</span> vertexCount)!</span><br><span class="line">        distTo[<span class="number">0</span>] = <span class="number">0.0</span></span><br><span class="line">        <span class="keyword">try</span>! pq.insert(<span class="string">index:</span> <span class="number">0</span>, <span class="string">forKey:</span> <span class="number">0.0</span>)</span><br><span class="line">        <span class="keyword">while</span> !pq.isEmpty() &#123;</span><br><span class="line">            visit(<span class="string">graph:</span> graph, <span class="string">v:</span> <span class="keyword">try</span>! pq.delMin())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func visit(<span class="string">graph:</span> EdgeWeightedGraph, <span class="string">v:</span>Int)  &#123;</span><br><span class="line">        marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            let w = <span class="keyword">try</span>! edge.other(v)</span><br><span class="line">            <span class="keyword">if</span> marked[w] &#123; <span class="keyword">continue</span> &#125; <span class="comment">//跳过失效的边</span></span><br><span class="line">            <span class="keyword">if</span> edge.weight() &lt; distTo[w] &#123;</span><br><span class="line">                edgeTo[w] = edge <span class="comment">// Edge e is new best connection from tree to w.</span></span><br><span class="line">                distTo[w] = edge.weight()</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> pq.contains(w) &#123;</span><br><span class="line">                    <span class="keyword">try</span>! pq.changeKey(<span class="string">index:</span> w, <span class="string">forKey:</span> distTo[w])</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span>! pq.insert(<span class="string">index:</span> w, <span class="string">forKey:</span> distTo[w])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func edges() -&gt; [Edge] &#123;</span><br><span class="line">        <span class="keyword">return</span> edgeTo</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p>思路： 按照边的权重顺序(从小到大)处理他们，将加入最小生成树中，加入的边不会和已经加入的边构成环，直到树中有V-1条边为止。</p><p>正确性证明（Kruskal能够计算任意加权无向图的最小生成树）：如果下一条被加入最小生成树的边不会和已有的黑色边构成换，那么它就跨越了由所有和树顶点相邻的顶点组成的集合  以及他们的补集构成的一个切分</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/Kruskal.png" alt="Kruskal算法的轨迹"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图的生成树是它的一棵含有所有顶点的无环连通子图，一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之后)最小的生成树&lt;/p&gt;
&lt;p&gt;最小生成树的解决方法有： prim算法、kruskal算法&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
      <category term="第4章图" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>4.2 有向图</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/4.2%20%E6%9C%89%E5%90%91%E5%9B%BE/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/</id>
    <published>2019-07-19T04:07:12.000Z</published>
    <updated>2019-07-23T07:48:29.036Z</updated>
    
    <content type="html"><![CDATA[<p>有向图学习记录</p><a id="more"></a><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>有向图： 一幅有方向性的图是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。</p><p>出度： 顶点指出的边的总数</p><p>入度： 指向该顶点的边的总数</p><p>有向环： 一条至少含有一条边，且起点和终点相同的有向路径</p><p>可达性： 存在v到w的路径时，我们称顶点w能够由顶点v到达</p><h2 id="有向图数据类型"><a href="#有向图数据类型" class="headerlink" title="有向图数据类型"></a>有向图数据类型</h2><p>有向图实现代码</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _vertex: <span class="keyword">Int</span> <span class="comment">//顶点个数</span></span><br><span class="line">    <span class="keyword">var</span> _edges: <span class="keyword">Int</span> = <span class="number">0</span>  <span class="comment">//边数</span></span><br><span class="line">    <span class="keyword">var</span> _adj:[[<span class="keyword">Int</span>]] <span class="comment">//邻接表二维数组</span></span><br><span class="line">    init(v: <span class="keyword">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._vertex = v</span><br><span class="line">        <span class="keyword">self</span>._adj = [[<span class="keyword">Int</span>]](repeating: [<span class="keyword">Int</span>](), count: v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func v() -&gt; <span class="keyword">Int</span> &#123;  <span class="comment">//返回顶点的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._vertex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func e() -&gt; <span class="keyword">Int</span> &#123;  <span class="comment">//返回边的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._edges</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func addEdge(_ v: <span class="keyword">Int</span>, _ w:<span class="keyword">Int</span> )  &#123;  <span class="comment">//添加v-&gt;w的边</span></span><br><span class="line">        <span class="keyword">self</span>._adj[v].insert(w, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">self</span>._edges += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func adj(_ v: <span class="keyword">Int</span>) -&gt; [<span class="keyword">Int</span>] &#123;  <span class="comment">//返回顶点v的邻接表</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._adj[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func reverse() -&gt; Digraph &#123;</span><br><span class="line">        <span class="keyword">let</span> r = Digraph(v: <span class="keyword">self</span>.v())</span><br><span class="line">        <span class="keyword">for</span> v in <span class="number">0.</span>.&lt;<span class="keyword">self</span>.v() &#123;</span><br><span class="line">            <span class="keyword">for</span> w in <span class="keyword">self</span>.adj(v)  &#123;</span><br><span class="line">                r.addEdge(v, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func toString() -&gt; String &#123;</span><br><span class="line">        <span class="keyword">var</span> result: String  =</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        \(self.v()) vertixes \(self.e()) edges \n</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i in <span class="number">0.</span>.&lt;<span class="keyword">self</span>.v() &#123;</span><br><span class="line">            result += <span class="string">"\(i) :"</span></span><br><span class="line">            <span class="keyword">for</span> w in <span class="keyword">self</span>.adj(i) &#123;</span><br><span class="line">                result += <span class="string">"\(w) "</span></span><br><span class="line">            &#125;</span><br><span class="line">            result +=</span><br><span class="line">            <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">            \n</span></span><br><span class="line"><span class="string">            "</span><span class="string">""</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的邻接表如下图所示：</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/Digraph.png" alt="有向图对应的邻接表内存图"></p><h2 id="有向图的可达性"><a href="#有向图的可达性" class="headerlink" title="有向图的可达性"></a>有向图的可达性</h2><p>代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedDFS</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]  <span class="comment">// 标记节点是否调用过dfs， 索引是顶点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>, s: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: graph.v())</span><br><span class="line">        dfs(graph, s)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>, sources: [<span class="type">Int</span>]) &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: graph.v())</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> sources &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[s] &#123;</span><br><span class="line">                dfs(graph, s)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> graph: Digraph,<span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;</span><br><span class="line">                dfs(graph, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">marked</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._marked[v]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/DrectedDFS.png" alt="有向图使用深度优先测试连通性"></p><h2 id="环和有向无环图"><a href="#环和有向无环图" class="headerlink" title="环和有向无环图"></a>环和有向无环图</h2><p>一幅有向图有环吗？ 深度优先搜索也能解决这个问题</p><p>由系统维护的递归调用的栈表示的真是“当前” 正在遍历的有向路径，一旦我们找到了一条边，v-&gt;w且w已经存在于栈中，就找到了一个环，因为栈比欧式的是一条w-&gt;v 的有向路径，而v-&gt;w正好补全了这个环。</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/find_directed_cycle.png" alt="环检测的思路"></p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/find_directed_cycle_trace.png" alt="环检测的轨迹"></p><p>下面是检测是否有环的检测代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]</span><br><span class="line">    <span class="keyword">var</span> _edgeTo: [<span class="type">Int</span>]</span><br><span class="line">    <span class="keyword">var</span> _cycle: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;?</span><br><span class="line">    <span class="keyword">var</span> _onStack: [<span class="type">Bool</span>]</span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> vertexCount = graph.v()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>._edgeTo = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>._onStack = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="number">0</span>..&lt;vertexCount &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[v] &#123;</span><br><span class="line">                dfs(graph, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> graph: Digraph, <span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">self</span>._onStack[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;  <span class="comment">//如果没有标记，递归标记（这里不需要判断换，没有标记过，肯定不在调用栈上）</span></span><br><span class="line">                <span class="keyword">self</span>._edgeTo[w] = v</span><br><span class="line">                dfs(graph, w)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//标记过了，可以判断这个顶点是否在栈上</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>._onStack[w] &#123; <span class="comment">//有环</span></span><br><span class="line">                    <span class="keyword">self</span>._cycle = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">                    <span class="keyword">var</span> x = v</span><br><span class="line">                    <span class="keyword">repeat</span> &#123;</span><br><span class="line">                        <span class="keyword">self</span>._cycle?.push(x)</span><br><span class="line">                        x = <span class="keyword">self</span>._edgeTo[x]</span><br><span class="line">                    &#125; <span class="keyword">while</span> x != w</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">self</span>._cycle?.push(w)</span><br><span class="line">                    <span class="keyword">self</span>._cycle?.push(v)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>._onStack[v] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hasCycle</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._cycle != <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cycle</span><span class="params">()</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.hasCycle() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>._cycle!.iterater()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="type">Int</span>]()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出深度优先搜索的遍历顺序</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked:[<span class="type">Bool</span>]</span><br><span class="line">    <span class="keyword">var</span> _pre: <span class="type">Queue</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> _post: <span class="type">Queue</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> _reversePost: <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>) &#123;</span><br><span class="line">        _pre = <span class="type">Queue</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        _post = <span class="type">Queue</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        _reversePost = <span class="type">Stack</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">        <span class="keyword">let</span> vertexCount = graph.v()</span><br><span class="line">        _marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="number">0</span>..&lt;vertexCount &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[v] &#123;</span><br><span class="line">                dfs(graph, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> graph: Digraph,<span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">self</span>._pre.enqueue(v)</span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> graph.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;</span><br><span class="line">                dfs(graph, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>._post.enqueue(v)</span><br><span class="line">        <span class="keyword">self</span>._reversePost.push(v)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pre</span><span class="params">()</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._pre.iterater()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">post</span><span class="params">()</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._post.iterater()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">reversePost</span><span class="params">()</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._reversePost.iterater()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拓扑顺序</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topological</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _order: [<span class="type">Int</span>]?</span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cycle = <span class="type">DirectedCycle</span>(graph: graph)</span><br><span class="line">        <span class="keyword">if</span> !cycle.hasCycle() &#123;</span><br><span class="line">            <span class="keyword">let</span> dfs = <span class="type">DepthFirstOrder</span>(graph: graph)</span><br><span class="line">            <span class="keyword">self</span>._order = dfs.reversePost()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">order</span><span class="params">()</span></span> -&gt; [<span class="type">Int</span>]? &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._order</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isDAG</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._order != <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="blue"><br>命题F： 一幅有向无环图的拓扑排序即为所有顶点的逆后序排序</font></p><p>证明： 对于任意边 v-&gt;w，在调用dfs(v)时，下面三种情况必有一种成立</p><ol><li>dfs(w) 已经被调用过，且已经返回了(w已经标记了)</li><li>dfs(w) 还没有被调用(w还未被标记)，因此v-&gt;w会直接或间接调用并返回dfs(w) ，且dfs(w) 会在dfs(v) 返回之前返回</li><li>dfs(w) 已经被调用，但还没有返回，证明的关键在于此，在有向无环图中，这种情况是不可能出现的，这是由于递归调用链意味着存在w到v的路径，但存在v-&gt;w的表示存在一个环<br><br>在两种可能的情况中，dfs(w) 都会在dfs(v) 之前完成，因此在后续排列中w排列在v之前，而在逆后序中，w排在v之后，因此任意一条边v-&gt;w都如我们所愿从排名较前的顶点指向排名较后的顶点。</li></ol><p>命题G： 使用深度优先搜索，对有向无环图进行拓扑排序，所需的时间和V+E成正比</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/topo.png" alt="拓扑的轨迹图"></p><h2 id="有向图中的强连通性"><a href="#有向图中的强连通性" class="headerlink" title="有向图中的强连通性"></a>有向图中的强连通性</h2><p>强连通性： 如果两个顶点v和w是相互可达的，则，他们是强连通的。</p><p>强连通分量的定义是基于顶点的，是由于： 有些边的两个顶点都在同一个连通分量中，而有限边连接的顶点在不同的强连通分量中。</p><p>kosarajuCC算法：</p><ol><li>在给定一幅有向图G中，使用DepthFirstOrder来计算它的反向图$$G^R$$的逆后序排列</li><li>在G中进行标准的深度优先搜索，但是，要按照刚才计算得到的顺序来访问所有未标记的顶点</li><li>在构造函数中，所有在同一个递归dfs() 调用中被访问到的顶点都在同一个连通分量中，将他们按照和CC相同的方式识别出来</li></ol><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/kasarajuCC.png" alt="kasarajuCC的正确性证明"></p><p>实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KosarajuCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]  <span class="comment">//已达顶点</span></span><br><span class="line">    <span class="keyword">var</span> _id: [<span class="type">Int</span>]  <span class="comment">//分量标识，索引顶点，值是连通分量标识</span></span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span>  <span class="comment">//分量个数</span></span><br><span class="line">    <span class="keyword">init</span>(graph: <span class="type">Digraph</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> vertexCount = graph.v()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>._id = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> order = <span class="type">DepthFirstOrder</span>(graph: graph.<span class="built_in">reverse</span>())</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> order.reversePost() &#123;</span><br><span class="line">            <span class="keyword">if</span> !_marked[s] &#123;</span><br><span class="line">                dfs(graph, s)</span><br><span class="line">                <span class="keyword">self</span>._count += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> G: Digraph, <span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>._id[v] = <span class="keyword">self</span>._count</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="type">G</span>.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;</span><br><span class="line">                dfs(<span class="type">G</span>, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">stronglyConnected</span><span class="params">(<span class="number">_</span> v: Int, <span class="number">_</span> w: Int)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="comment">//判断两个顶点是否连通</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._id[v] == <span class="keyword">self</span>._id[w]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回顶点属于的连通分量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._id[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回连通分量的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.2 有向图/kasarajucc_trace.png" alt="kasarajuCC轨迹图"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有向图学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
      <category term="第4章图" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>4.1 无向图</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/4.1%20%E6%97%A0%E5%90%91%E5%9B%BE/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/</id>
    <published>2019-07-19T04:07:12.000Z</published>
    <updated>2019-07-23T07:58:58.459Z</updated>
    
    <content type="html"><![CDATA[<p>图： 由一组顶点和一组能够将两个顶点相连的边组成的</p><a id="more"></a><h2 id="术语表"><a href="#术语表" class="headerlink" title="术语表"></a>术语表</h2><p>当两个顶点通过一条边相连时，我们称这两个顶点是<strong>相邻的</strong> 并称该连接依附于这两个顶点。某个顶点的<strong>度数</strong>即为依附于他的边的总数。</p><p>路径： 在图中，路径是由边顺序连接的一系列顶点。路径或环的长度为其中包含的边数</p><p>连通： 当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是连通的。</p><p>连通图： 如果顶点是物理存在的对象，如绳节，边是绳子， 任意顶点提起，连通图是一个整体。</p><p>树： 无环连通图</p><p>生成树： 连通图的生成树是它的一副子图，包含图中所有顶点，且是一颗树   </p><p>V个顶点图的树的条件：</p><ol><li>G有V-1条边且不含有环</li><li>G有V-1条边，且是连通</li><li>G是连通的，但删除任何一条边，会使它不再连通</li><li>G是无环图，但添加任何一条边，都会产生一个环</li><li>G中任意一对顶点之间仅存在一条简单路径</li></ol><p>密度： 连接顶点对占所有可能别连接的顶点对的比例。 （稀疏图、稠密图）</p><p>二分图： 每条边连接的两个顶点都分别属于不同部分,</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/bipartitle_graph.png" alt="二分图"></p><h2 id="表示无向图的数据类型"><a href="#表示无向图的数据类型" class="headerlink" title="表示无向图的数据类型"></a>表示无向图的数据类型</h2><table><thead><tr><th>接口</th><th>说明</th></tr></thead><tbody><tr><td>V()-&gt;Int</td><td>顶点数</td></tr><tr><td>E()-&gt;Int</td><td>边数</td></tr><tr><td>addEdge(v: Int, w: Int)</td><td>向图中添加一个边v-w</td></tr><tr><td>adj(v: Int)-&gt;[Int]</td><td>和v相邻的所有顶点</td></tr></tbody></table><p>图的表示方法：</p><ol><li>邻接矩阵 ：V*V的矩阵，当顶点V和W之间有相邻的边时，V行和W列的元素值未true</li><li>邻接表数组</li></ol><p>下图是邻接表内存图：</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/Adjacency_lists_representation.png" alt="邻接表内存图"></p><p>图的定义：</p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">class Graph &#123;</span><br><span class="line">var vertex: <span class="built_in">Int</span></span><br><span class="line">var adj: [[<span class="built_in">Int</span>]]</span><br><span class="line">var edge: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">init(vertex: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    self.vertex = vertex</span><br><span class="line">    adj = [[<span class="built_in">Int</span>]](repeating: [<span class="built_in">Int</span>](), count: vertex)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">convenience init?(inStream: ReadFile) &#123;</span><br><span class="line">    <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">    <span class="keyword">if</span> v != nil &#123;</span><br><span class="line">        self.init(vertex: v!)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> edge = inStream.readInt()</span><br><span class="line">    <span class="keyword">if</span> edge != nil &#123;</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0.</span>.&lt;edge! &#123;</span><br><span class="line">            <span class="keyword">let</span> v = inStream.readInt()</span><br><span class="line">            <span class="keyword">let</span> w = inStream.readInt()</span><br><span class="line">            self.addEdge(v!, w!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nil</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func addEdge(_ v: <span class="built_in">Int</span>, _ w: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    self.adj[v].append(w)</span><br><span class="line">    self.adj[w].append(v)</span><br><span class="line">    self.edge += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func V() -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> vertex</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">func E() -&gt; <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> edge</span><br><span class="line">&#125;</span><br><span class="line">func toString() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    var result: <span class="built_in">String</span>  =</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    \(V) vertixes \(E) edges \n</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;vertex &#123;</span><br><span class="line">        result += <span class="string">"\(i) :"</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> adj[i] &#123;</span><br><span class="line">            result += <span class="string">"\(w) "</span></span><br><span class="line">        &#125;</span><br><span class="line">        result +=</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        \n</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p>图处理的一般策略：从一个顶点移动到另一个顶点</p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/dfs.png" alt="深度优先搜索轨迹图"></p><ol><li>因为顶点2是0的邻接表的第一个元素，且没有标记过，dfs()递归调用自己来标记并访问顶点2</li><li>现在，顶点0是2的邻接表的第一个元素，且已经被标记了，因此，dfs跳过了他，接下来，顶点1是2的邻接表的第二个元素，且没有标记过，dfs递归调用自己，来标记并访问顶点1</li><li>对顶点1的访问和前面有所不同：因为它的邻接表中的所有顶点（0，2）都已经被标记过了，因此，不需要再递归，方法从dfs（1）返回，下一条被检查的边是2-3，因此dfs递归调用自己，来标记并访问顶点3</li><li>顶点5是3的邻接表的第一个元素且没有被标记，因此dfs递归调用自己来标记并访问顶点5</li><li>顶点5邻接表中的所有顶点（3，0）都已经被标记过了，因此不需要再递归</li><li>顶点4是3的邻接表的下一个元素，且没有被标记过，因此dfs递归调用自己，来标记并访问顶点4，这是最后一个需要被标记的顶点</li></ol><p>深度优先能解决的问题： 单点路径，给定一个一副图和一个起点，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出这条路径”等类似问题。</p><p>下面是深度优先搜索的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]  <span class="comment">//描述标记过的顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> _count: <span class="type">Int</span> = <span class="number">0</span>  <span class="comment">//描述标记过的顶点个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="type">G</span>: <span class="type">Graph</span>, s: <span class="type">Int</span> ) &#123;</span><br><span class="line">        _marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: <span class="type">G</span>.<span class="type">V</span>() )</span><br><span class="line">        dfs(<span class="type">G</span>, s)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> G: Graph, <span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        _marked[v] = <span class="literal">true</span></span><br><span class="line">        _count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="type">G</span>.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> _marked[w] == <span class="literal">false</span> &#123;</span><br><span class="line">                dfs(<span class="type">G</span>, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">marked</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _marked[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="寻找路径"><a href="#寻找路径" class="headerlink" title="寻找路径"></a>寻找路径</h2><p>在由v-w第一次访问任意w时，将edgeTo[w]设为v来记住这条路径  。所以edgeTo的理解如下：</p><ol><li>索引是当前节点，终止节点</li><li>值是上一个节点 ，起始节点</li></ol><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/edgeTo.png" alt="edgeTo巧妙的用途-路径树"></p><p>树的特定： 以起点为根节点的树。</p><p>下面是实现代码:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>] <span class="comment">// 标记这个顶点调用过dfs了吗？</span></span><br><span class="line">    <span class="keyword">var</span> _edgeTo: [<span class="type">Int</span>] <span class="comment">//从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line">    <span class="keyword">let</span> _s: <span class="type">Int</span> <span class="comment">// 起点</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="type">G</span>: <span class="type">Graph</span>, s: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">G</span>.<span class="type">V</span>()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>._edgeTo = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>._s = s</span><br><span class="line">        dfs(<span class="type">G</span>, v: s)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> G: Graph, v: Int)</span></span>  &#123;</span><br><span class="line">        _marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="type">G</span>.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>._marked[w] == <span class="literal">false</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>._edgeTo[w] = v</span><br><span class="line">                dfs(<span class="type">G</span>, v: w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hasPathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._marked[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; [<span class="type">Int</span>]? &#123;</span><br><span class="line">        <span class="keyword">if</span> !hasPathTo(v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> path = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">var</span> x = v</span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            path.insert(x, at: <span class="number">0</span>)</span><br><span class="line">            x =  <span class="keyword">self</span>._edgeTo[x]</span><br><span class="line">        &#125; <span class="keyword">while</span> x != <span class="keyword">self</span>._s</span><br><span class="line">        </span><br><span class="line">        path.insert(<span class="keyword">self</span>._s, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命题A(续)：使用深度优先搜索得到从给定起点到任何标记顶点的路径所需的时间与路径的长度成正比。</p><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索能解决单点最短路径问题。</p><p>要找从s到v的最短路径，从s开始，在所有由一条边就可以到达的点多中寻找v，如果找不到，我们就继续在于s距离两条边的所有顶点中寻找v，如此一直继续。</p><p>思路，将起点假如队列中，然后重复下面的步骤：</p><ol><li>取出队列中的下一个顶点v，并标记它</li><li>将与v相邻的所有未被标记的顶点加入队列中</li></ol><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/bfs.png" alt="bfs的轨迹图"></p><p>轨迹说明：</p><ol><li>从队列中删除顶点0， 并标记相邻的顶点2，1，5，并加入队列中。并把他们的edgeTo[]设为0</li><li>从队列中删去顶点2，并检查它的相邻顶点0，1，发现两者都已经标记，将相邻的顶点3，4加入队列，标记他们，并将edgeTo[]设为2</li><li>从队列中删去顶点1，并检查他的相邻顶点0，2，发现他们都已经被标记了</li><li>从队列中删去顶点5，并检查他的相邻顶点3，0，发现他们都已经被标记了</li><li>从队列中删去顶点3，并检查他的相邻顶点5，4，2，发现他们都已经被标记了</li><li>从队列中删去顶点4，并检查他的相邻顶点3，2，发现他们都已经被标记了</li></ol><p>下面是广度优先级查找最短路径的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>] <span class="comment">// 标记这个顶点调用过dfs了吗？</span></span><br><span class="line">    <span class="keyword">var</span> _edgeTo: [<span class="type">Int</span>] <span class="comment">//从起点到一个顶点的已知路径上的最后一个顶点</span></span><br><span class="line">    <span class="keyword">let</span> _s: <span class="type">Int</span> <span class="comment">// 起点</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="type">G</span>: <span class="type">Graph</span>, s: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">count</span> = <span class="type">G</span>.<span class="type">V</span>()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>._edgeTo = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">self</span>._s = s</span><br><span class="line">        bfs(<span class="type">G</span>,s)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bfs</span><span class="params">(<span class="number">_</span> G: Graph, <span class="number">_</span> s: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">var</span> queue = [<span class="type">Int</span>]()</span><br><span class="line">        _marked[s] = <span class="literal">true</span></span><br><span class="line">        queue.append(s)</span><br><span class="line">        <span class="keyword">while</span> !queue.isEmpty &#123;</span><br><span class="line">            <span class="keyword">let</span> v = queue.removeFirst() <span class="comment">//取出一个顶点处理</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> <span class="type">G</span>.adj(v) &#123;</span><br><span class="line">                <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123; <span class="comment">//邻接顶点没有被标记过</span></span><br><span class="line">                    <span class="keyword">self</span>._marked[w] = <span class="literal">true</span></span><br><span class="line">                    <span class="keyword">self</span>._edgeTo[w] = v</span><br><span class="line">                    queue.append(w)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hasPathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._marked[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">pathTo</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; [<span class="type">Int</span>]? &#123;</span><br><span class="line">        <span class="keyword">if</span> !hasPathTo(v) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> path = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">var</span> x = v</span><br><span class="line">        <span class="keyword">repeat</span> &#123;</span><br><span class="line">            path.insert(x, at: <span class="number">0</span>)</span><br><span class="line">            x =  <span class="keyword">self</span>._edgeTo[x]</span><br><span class="line">        &#125; <span class="keyword">while</span> x != <span class="keyword">self</span>._s</span><br><span class="line">        </span><br><span class="line">        path.insert(<span class="keyword">self</span>._s, at: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> path</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命题B： 从s可达的任意顶点v，广度优先搜索都能找到一条从s到v的最短路径。</p><p>深度和广度的相同点：</p><ol><li>都是取出下一个顶点，并标记它</li><li>将v的所有相邻而又未被标记的顶点加入数据结构</li></ol><p>不同之处，在于从数据结构中读取下一个顶点的规则：</p><ol><li>对于广度优先级，是最早加入的节点(队列)</li><li>深度优先级搜索，最晚加入的节点(栈)</li></ol><h2 id="连通分量"><a href="#连通分量" class="headerlink" title="连通分量"></a>连通分量</h2><p>id数组的理解：</p><ol><li>索引，顶点</li><li>值： 所在的连通分量标识</li><li>连通分量标识的范围为0..count-1 </li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _marked: [<span class="type">Bool</span>]</span><br><span class="line">    <span class="keyword">var</span> _id: [<span class="type">Int</span>]</span><br><span class="line">    <span class="keyword">var</span> _count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="type">G</span>: <span class="type">Graph</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> vertexCount = <span class="type">G</span>.<span class="type">V</span>()</span><br><span class="line">        <span class="keyword">self</span>._marked = [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">self</span>._id = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: vertexCount)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="number">0</span>..&lt;vertexCount &#123;</span><br><span class="line">            <span class="keyword">if</span> !_marked[s] &#123;</span><br><span class="line">                dfs(<span class="type">G</span>, s)</span><br><span class="line">                <span class="keyword">self</span>._count += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(<span class="number">_</span> G: Graph, <span class="number">_</span> v: Int)</span></span>  &#123;</span><br><span class="line">        <span class="keyword">self</span>._marked[v] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">self</span>._id[v] = <span class="keyword">self</span>._count</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="type">G</span>.adj(v) &#123;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>._marked[w] &#123;</span><br><span class="line">                dfs(<span class="type">G</span>, w)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">connected</span><span class="params">(<span class="number">_</span> v: Int, <span class="number">_</span> w: Int)</span></span> -&gt; <span class="type">Bool</span> &#123; <span class="comment">//判断两个顶点是否连通</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._id[v] == <span class="keyword">self</span>._id[w]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">id</span><span class="params">(<span class="number">_</span> v: Int)</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回顶点属于的连通分量</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._id[v]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123; <span class="comment">//返回连通分量的个数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>._count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：图是否有环还没有理解</strong></p><p><img src="/wiki/数据结构与算法/算法4/第4章图/4.1 无向图/cc.png" alt="连通分量轨迹图"></p><p><a href="https://algs4.cs.princeton.edu/code/javadoc/" rel="external nofollow noopener noreferrer" target="_blank">算法4 官网地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图： 由一组顶点和一组能够将两个顶点相连的边组成的&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法4" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/"/>
    
      <category term="第4章图" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%954/%E7%AC%AC4%E7%AB%A0%E5%9B%BE/"/>
    
    
  </entry>
  
  <entry>
    <title>42_动态规划实战</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/42_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/42_动态规划实战/</id>
    <published>2019-07-19T01:07:12.000Z</published>
    <updated>2019-07-19T02:48:09.534Z</updated>
    
    <content type="html"><![CDATA[<p>记录动态规划思想</p><a id="more"></a><h2 id="量化两个字符串的相似度"><a href="#量化两个字符串的相似度" class="headerlink" title="量化两个字符串的相似度"></a>量化两个字符串的相似度</h2><ol><li>莱文斯坦距离</li><li>最长公共子串</li></ol><h2 id="如何计算"><a href="#如何计算" class="headerlink" title="如何计算"></a>如何计算</h2><ol><li>一个字符一个字符的比较，符合段阶段最优解</li><li>回溯（暴力破解）</li></ol><p>相等： 如果a[i]和 b[i] 匹配 ，我们递归的考察a[i+1] b[j+1]<br>如果不匹配： </p><ul><li>可以删除a[i] 比较a[i+1] ,b[j]</li><li>可以删除b[j] 比较a[i],b[j+1]</li><li>可以在a[i] 前面添加一个和b[j] 相等的字符，比较a[i],b[j+1]</li><li>可以在b[j] 前面添加一个a[i] 想的的字符，比较a[i+1] b[j] </li><li>可以将a[i] 替换成b[j] 或者b[j] 替换a[i] 然后递归的考察a[i+1] b[j+1] </li></ul><ol><li>递归树，查看是否有重复的问题</li><li>状态转移公式</li><li>状态表</li><li>代码填状态表  （一定考虑前一个状态到当前状态转化的方式）</li></ol><p>下面是莱文斯坦距离的两种计算方式，回缩法、动态规划：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringDistance</span> &#123;</span></span><br><span class="line">    let a = <span class="string">"mitcmu"</span></span><br><span class="line">    let b = <span class="string">"mtacnu"</span></span><br><span class="line">    let n = <span class="number">6</span></span><br><span class="line">    let m = <span class="number">6</span></span><br><span class="line">    var minDis = Int.max</span><br><span class="line">    func lwstBT(<span class="string">i:</span> Int, <span class="string">j:</span>Int , <span class="string">edist:</span> Int)  &#123;</span><br><span class="line">        <span class="keyword">if</span> i == n || j == m &#123;</span><br><span class="line">            var minEditDidtance = edist</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">                minEditDidtance += (n - i)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j &lt; m &#123;</span><br><span class="line">                minEditDidtance += (m-j)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> minEditDidtance &lt; minDis &#123;</span><br><span class="line">                minDis = minEditDidtance</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> a[a.ljIndex(i)] == b[b.ljIndex(j)] &#123;</span><br><span class="line">            lwstBT(<span class="string">i:</span> i + <span class="number">1</span>, <span class="string">j:</span> j+<span class="number">1</span>, <span class="string">edist:</span> edist)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//两个字符不匹配</span></span><br><span class="line">            lwstBT(<span class="string">i:</span> i, <span class="string">j:</span> j+<span class="number">1</span>, <span class="string">edist:</span> edist + <span class="number">1</span>) <span class="comment">// 删除 b[j] 或者 a[i] 前添加一个字符</span></span><br><span class="line">            lwstBT(<span class="string">i:</span> i+<span class="number">1</span>, <span class="string">j:</span> j, <span class="string">edist:</span> edist + <span class="number">1</span>) <span class="comment">// 删除 a[i] 或者 b[j] 前添加一个字符</span></span><br><span class="line">            lwstBT(<span class="string">i:</span> i+<span class="number">1</span>, <span class="string">j:</span> j+<span class="number">1</span>, <span class="string">edist:</span> edist + <span class="number">1</span>) <span class="comment">// 将 a[i] 和 b[j] 替换为相同字符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func lwstDP() -&gt; Int &#123;</span><br><span class="line">    <span class="comment">//初始化状态表</span></span><br><span class="line">    <span class="selector-tag">var</span> status = [[Int]](repeating: [Int](repeating: <span class="number">0</span>, count: m), count: n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123; <span class="comment">// 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(<span class="number">0</span>)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(j)] &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = j</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> j != <span class="number">0</span> &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = status[<span class="number">0</span>][j-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123; <span class="comment">// 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(i)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(<span class="number">0</span>)] &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = i</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="selector-tag">i</span> != <span class="number">0</span> &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = status[i-<span class="number">1</span>][<span class="number">0</span>]+<span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;n &#123; <span class="comment">// 按行填表</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(i)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(j)] &#123;</span><br><span class="line">                status[i][j] = min(status[i-<span class="number">1</span>][j],status[i][j-<span class="number">1</span>],status[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 status[i][j] = min(status[i-<span class="number">1</span>][j],status[i][j-<span class="number">1</span>],status[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return status[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是最长公共子串的动态规划代码：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">func lcs() -&gt; Int &#123;</span><br><span class="line">    <span class="comment">//初始化状态表</span></span><br><span class="line">    <span class="selector-tag">var</span> status = [[Int]](repeating: [Int](repeating: <span class="number">0</span>, count: m), count: n)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始状态</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123; <span class="comment">// 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(<span class="number">0</span>)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(j)] &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> j != <span class="number">0</span> &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = status[<span class="number">0</span>][j-<span class="number">1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123; <span class="comment">// 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(i)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(<span class="number">0</span>)] &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="selector-tag">i</span> != <span class="number">0</span> &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = status[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            status[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;n &#123; <span class="comment">// 按行填表</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="selector-tag">a</span>[<span class="selector-tag">a</span>.ljIndex(i)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.ljIndex(j)] &#123;</span><br><span class="line">                status[i][j] = max(status[i-<span class="number">1</span>][j],status[i][j-<span class="number">1</span>],status[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                status[i][j] = max(status[i-<span class="number">1</span>][j],status[i][j-<span class="number">1</span>],status[i-<span class="number">1</span>][j-<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return status[n-<span class="number">1</span>][m-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录动态规划思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>41_动态规划理论</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/41_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/41_动态规划理论/</id>
    <published>2019-07-18T03:07:12.000Z</published>
    <updated>2019-07-18T10:16:36.021Z</updated>
    
    <content type="html"><![CDATA[<p>记录动态规划思想</p><a id="more"></a><h2 id="一个模型、三个特征"><a href="#一个模型、三个特征" class="headerlink" title="一个模型、三个特征"></a>一个模型、三个特征</h2><p>一个模型：多阶段决策最优模型。解决最优问题，在解决的过程中，需要经历多个决策阶段，每个决策阶段对应一组状态，然后我们寻找一组决策序列，经过这组决策序列，产生最终期望的最优解。</p><p>最优子结构：问题的最优解包含子问题的最优解，反过来说，我们可以通过子问题的最优解，推导出问题的最优解。也就是后阶段的状态可以通过前阶段的状态推导出来。</p><p>无后效性：推导后面，只需要关心前面状态值，不关心状态怎么推导出来。某阶段的状态一旦确定，就不会受之后阶段的决策影响。</p><p>重复子问题：达到某个相同阶段时，可能产生重复的状态 </p><h2 id="两种动态规划的解决思路"><a href="#两种动态规划的解决思路" class="headerlink" title="两种动态规划的解决思路"></a>两种动态规划的解决思路</h2><ol><li>状态转移表法，：回溯算法实现- 定义状态 - 画递归树、找重复子问题、 话状态转移表- 将填表过程翻译为代码</li><li>状态转移方程法：找最优子结构- 写状态转移方程- 将状态转移方程翻译为代码。</li></ol><h2 id="思考题的答案"><a href="#思考题的答案" class="headerlink" title="思考题的答案"></a>思考题的答案</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Money</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">payMoney</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//定义输入数据</span></span><br><span class="line">        <span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>] <span class="comment">//钱币的种类</span></span><br><span class="line">        <span class="keyword">let</span> pm = <span class="number">9</span>  <span class="comment">//支付金额payMoney</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//定义自动变量</span></span><br><span class="line">        <span class="keyword">let</span> step = pm/values[<span class="number">0</span>] + <span class="number">1</span> <span class="comment">//定义最大步数</span></span><br><span class="line">        <span class="keyword">var</span> states = [[<span class="type">Int</span>]](repeating: [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>: pm+<span class="number">1</span>), <span class="built_in">count</span>: step) <span class="comment">//定义状态图</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化第一行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;values.<span class="built_in">count</span> &#123;</span><br><span class="line">            states[<span class="number">0</span>][values[i]] = values[i]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每步选择一种钱币，翻译状态图</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;step &#123;</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="number">0</span>..&lt;values.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...pm-values[k] &#123;  <span class="comment">//行</span></span><br><span class="line">                    <span class="keyword">if</span> states[i-<span class="number">1</span>][j] &gt; <span class="number">0</span> &#123;</span><br><span class="line">                        states[i][j+values[k]] = values[k]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;step &#123;</span><br><span class="line">            <span class="keyword">if</span> states[i][pm] &gt; <span class="number">0</span> &#123;  <span class="comment">//找到了</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"找到了一种方案： 使用的币的个数：<span class="subst">\(i+<span class="number">1</span>)</span>"</span>)</span><br><span class="line">                <span class="keyword">var</span> column  = pm</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">stride</span>(from: i, through: <span class="number">0</span>, by: -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">let</span> currentMoney = states[j][column]</span><br><span class="line">                    <span class="built_in">print</span>(currentMoney)  <span class="comment">//当前币的大小</span></span><br><span class="line">                    column -= currentMoney</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>  <span class="comment">//退出打印最少币种的方式，不退出打印所有方式。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">testPayMoney</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> ins = <span class="type">Money</span>()</span><br><span class="line">        ins.payMoney()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录动态规划思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>40_初识动态规划</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/40_%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/40_初识动态规划/</id>
    <published>2019-07-17T03:07:12.000Z</published>
    <updated>2019-07-18T06:57:03.484Z</updated>
    
    <content type="html"><![CDATA[<p>记录动态规划思想</p><a id="more"></a><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>在满足最大重量的限制前提下，背包中总重量的最大值是多少?</p><p>回溯方式解决代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem01_BackTrace</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxW = <span class="type">Int</span>.<span class="built_in">min</span>  <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line">    <span class="keyword">let</span> weight = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">5</span></span><br><span class="line">    <span class="keyword">var</span> w = <span class="number">9</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">maxWeight</span><span class="params">(i: Int,  cw: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> cw == w || i == n &#123; <span class="comment">//cw==w 表示装满了，i==n 表示物品都考察完了</span></span><br><span class="line">            <span class="keyword">if</span> cw &gt; maxW &#123;</span><br><span class="line">                maxW = cw  <span class="comment">//更新最大值</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        maxWeight(i: i + <span class="number">1</span>, cw: cw) ;<span class="comment">//选择不装i个物品</span></span><br><span class="line">        <span class="keyword">if</span> cw + weight[i] &lt;= w &#123;</span><br><span class="line">            maxWeight(i: i + <span class="number">1</span>, cw: weight[i] + cw)</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">testMaxWeight</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> problem01Instance = <span class="type">Problem01_BackTrace</span>()</span><br><span class="line">        problem01Instance.maxWeight(i: <span class="number">0</span>, cw: <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(problem01Instance.maxW)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是动态规划方式解决</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Problem0_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">knapsack</span><span class="params">(weight: [Int], n: Int, w: Int)</span></span> -&gt; <span class="type">Int</span> &#123;<span class="comment">//weight: 物品重量，n: 物品个数，w: 背包可承载重量</span></span><br><span class="line">        <span class="keyword">var</span> states = [[<span class="type">Bool</span>]](repeating: [<span class="type">Bool</span>](repeating: <span class="literal">false</span>, <span class="built_in">count</span>: w+<span class="number">1</span>), <span class="built_in">count</span>: n)</span><br><span class="line">        states[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> weight[<span class="number">0</span>] &lt; w &#123;</span><br><span class="line">            states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;n &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...w &#123;</span><br><span class="line">                <span class="keyword">if</span> states[i-<span class="number">1</span>][j] == <span class="literal">true</span> &#123;</span><br><span class="line">                    states[i][j] = states[i-<span class="number">1</span>][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>...w - weight[i] &#123;</span><br><span class="line">                <span class="keyword">if</span> states[i-<span class="number">1</span>][j] == <span class="literal">true</span> &#123;</span><br><span class="line">                    states[i][j+weight[i]] = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: w, through: <span class="number">0</span>, by: -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> states[n-<span class="number">1</span>][i] == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">testKnapsack</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> problem01 = <span class="type">Problem0_1</span>()</span><br><span class="line">        <span class="keyword">let</span> weight = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">3</span>]</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">5</span></span><br><span class="line">        <span class="keyword">let</span> w = <span class="number">9</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> result = problem01.knapsack(weight: weight, n: n, w: w)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把上一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。</p><p>下面是思考题杨辉三角的答案</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YangHuiTriangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> matrix = [[<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>]]</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">yanghuiTirangle</span><span class="params">(<span class="number">_</span> matrix: [[Int]])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> states = [[<span class="type">Int</span>]](repeating: [<span class="type">Int</span>](repeating: matrix.<span class="built_in">count</span>, <span class="built_in">count</span>: <span class="number">5</span>), <span class="built_in">count</span>: matrix.<span class="built_in">count</span>)</span><br><span class="line">        states[<span class="number">0</span>][<span class="number">0</span>] = matrix[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;matrix.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;matrix[i].<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span> &#123;</span><br><span class="line">                    states[i][j] = states[i-<span class="number">1</span>][j] + matrix[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> j == matrix[i].<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">                    states[i][j] = states[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i][j]</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> top1 = states[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">let</span> top2 = states[i-<span class="number">1</span>][j]</span><br><span class="line">                    states[i][j] = <span class="built_in">min</span>(top1, top2) + matrix[i][j]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> minDis = <span class="type">Int</span>.<span class="built_in">max</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;matrix[matrix.<span class="built_in">count</span>-<span class="number">1</span>].<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="built_in">distance</span> = states[matrix.<span class="built_in">count</span>-<span class="number">1</span>][i]</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">distance</span> &lt; minDis &#123;</span><br><span class="line">                minDis = <span class="built_in">distance</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minDis</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">testTirangle</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> triangle = <span class="type">YangHuiTriangle</span>()</span><br><span class="line">        <span class="keyword">let</span> result = triangle.yanghuiTirangle(triangle.matrix)</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>贪心：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边</li><li>回溯：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View)</li><li>动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录动态规划思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>39_回溯思想</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/39_%E5%9B%9E%E6%BA%AF%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/39_回溯思想/</id>
    <published>2019-07-17T03:07:12.000Z</published>
    <updated>2019-07-17T06:45:13.471Z</updated>
    
    <content type="html"><![CDATA[<p>记录回溯思想</p><a id="more"></a><h2 id="回溯思想"><a href="#回溯思想" class="headerlink" title="回溯思想"></a>回溯思想</h2><p>遇到分岔路口时， 随意选择一条路，当发现一条路不通时，回到上一个岔路口。</p><p>八皇后问题：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queen8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> result = <span class="type">Array</span>(repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="number">8</span>)</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cal8Queens</span><span class="params">(row:Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">8</span> &#123;</span><br><span class="line">            printQueens(result: result)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> column <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;  <span class="comment">//每一行都有8种方法</span></span><br><span class="line">            <span class="keyword">if</span> isOK(row: row, column: column) &#123;</span><br><span class="line">                result[row] = column</span><br><span class="line">                cal8Queens(row: row + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isOK</span><span class="params">(row: Int, column: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> leftUp = column - <span class="number">1</span></span><br><span class="line">        <span class="keyword">var</span> rightUp = column + <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">stride</span>(from: row-<span class="number">1</span>, through: <span class="number">0</span>, by: -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> result[i] == column &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> leftUp &gt;= <span class="number">0</span> &amp;&amp; result[i] == leftUp &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> rightUp &lt; <span class="number">8</span> &amp;&amp; result[i] == rightUp &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            leftUp -= <span class="number">1</span></span><br><span class="line">            rightUp += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">printQueens</span><span class="params">(result: [Int])</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">8</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> result[i] == j &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"Q "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">"* "</span>, terminator: <span class="string">""</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">" "</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"一种方案完成---------"</span>)</span><br><span class="line">        <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">testQueen8</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> queen = <span class="type">Queen8</span>()</span><br><span class="line">            </span><br><span class="line">        queen.cal8Queens(row: <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(queen.<span class="built_in">count</span>)  <span class="comment">//92种方案</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录回溯思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>分治思想</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/38_%E5%88%86%E6%B2%BB%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/38_分治思想/</id>
    <published>2019-07-17T03:07:12.000Z</published>
    <updated>2019-07-17T03:04:48.465Z</updated>
    
    <content type="html"><![CDATA[<p>记录分治思想</p><a id="more"></a><h2 id="分治思想"><a href="#分治思想" class="headerlink" title="分治思想"></a>分治思想</h2><p>分治，分而治之。分治是一种处理问题的思想，递归是一种编程技巧。</p><p>步骤：</p><ol><li>分解：将源问题分解成一系列子问题</li><li>解决：递归的求解各个子问题，若子问题足够小，直接求解</li><li>合并：将子问题的结果合并成源问题</li></ol><p>满足的条件：</p><ol><li>原问题与分解的小问题具有相同的模式</li><li>原问题分解的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法和动态规划的明显区别</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解</li><li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高</li></ol><p>下面是分治求解逆序度的源码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">class Division &#123;</span><br><span class="line">    <span class="selector-tag">var</span> num = <span class="number">0</span></span><br><span class="line">    func count(<span class="selector-tag">a</span>: inout [Int], count: Int) -&gt; Int &#123;</span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        mergeSortCounting(<span class="selector-tag">a</span>: &amp;<span class="selector-tag">a</span>, <span class="selector-tag">p</span>: <span class="number">0</span>, r: count - <span class="number">1</span> )</span><br><span class="line">        return num</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func mergeSortCounting(<span class="selector-tag">a</span>: inout [Int], <span class="selector-tag">p</span>: Int, r: Int) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">p</span> &gt;= r &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let <span class="selector-tag">q</span> = (<span class="selector-tag">p</span> + r) / <span class="number">2</span></span><br><span class="line">        mergeSortCounting(<span class="selector-tag">a</span>: &amp;<span class="selector-tag">a</span>, <span class="selector-tag">p</span>: <span class="selector-tag">p</span>, r: q)</span><br><span class="line">        mergeSortCounting(<span class="selector-tag">a</span>: &amp;<span class="selector-tag">a</span>, <span class="selector-tag">p</span>: q+<span class="number">1</span>, r: r)</span><br><span class="line">        merge(<span class="selector-tag">a</span>: &amp;<span class="selector-tag">a</span>, <span class="selector-tag">p</span>: <span class="selector-tag">p</span>, <span class="selector-tag">q</span>: <span class="selector-tag">q</span>, r: r)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func merge(<span class="selector-tag">a</span>: inout [Int], <span class="selector-tag">p</span>: Int, <span class="selector-tag">q</span>: Int, r: Int) &#123;</span><br><span class="line">        <span class="selector-tag">var</span> <span class="selector-tag">i</span> = p</span><br><span class="line">        <span class="selector-tag">var</span> j = <span class="selector-tag">q</span> + <span class="number">1</span></span><br><span class="line">        <span class="selector-tag">var</span> k = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="selector-tag">var</span> temp: [Int] = Array(repeating: <span class="number">0</span>, count: r-p+<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        while <span class="selector-tag">i</span> &lt;= <span class="selector-tag">q</span> &amp;&amp; j &lt;= r &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="selector-tag">a</span>[i] &lt;= <span class="selector-tag">a</span>[j] &#123;</span><br><span class="line">                temp[k] = <span class="selector-tag">a</span>[i]</span><br><span class="line">                <span class="selector-tag">i</span> += <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num += (<span class="selector-tag">q</span> - <span class="selector-tag">i</span> + <span class="number">1</span>)</span><br><span class="line">                temp[k] = <span class="selector-tag">a</span>[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while <span class="selector-tag">i</span> &lt;= <span class="selector-tag">q</span> &#123;</span><br><span class="line">            temp[k] = <span class="selector-tag">a</span>[i]</span><br><span class="line">            <span class="selector-tag">i</span> += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while j &lt;= r &#123;</span><br><span class="line">            temp[k] = <span class="selector-tag">a</span>[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span> ... r-<span class="selector-tag">p</span> &#123;</span><br><span class="line">            <span class="selector-tag">a</span>[p+i] = temp[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static func testDivision() &#123;</span><br><span class="line">        <span class="selector-tag">var</span> <span class="selector-tag">a</span> = [<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">        let division = Division()</span><br><span class="line">        print(division.count(<span class="selector-tag">a</span>: &amp;<span class="selector-tag">a</span>, count: <span class="number">6</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可以解决的问题"><a href="#可以解决的问题" class="headerlink" title="可以解决的问题"></a>可以解决的问题</h2><p>分治可以解决耗时问题、大内存问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录分治思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>swift 使用经验</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/swift%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/swift使用经验/</id>
    <published>2019-07-17T01:07:12.000Z</published>
    <updated>2019-07-17T03:45:31.893Z</updated>
    
    <content type="html"><![CDATA[<p>列举swift使用经验</p><a id="more"></a><h2 id="Swift-数组Array作为函数参数时如何在函数内部改变其值？"><a href="#Swift-数组Array作为函数参数时如何在函数内部改变其值？" class="headerlink" title="Swift 数组Array作为函数参数时如何在函数内部改变其值？"></a>Swift 数组Array作为函数参数时如何在函数内部改变其值？</h2><p>Swift中我们可以在参数类型的前面加上一个 inout 关键字，并在调用函数时在参数前加个取地址符 &amp;，如下所示：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func doSomething(numArr: inout [String])&#123;</span><br><span class="line">    numArr.append(<span class="string">"4"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">var</span> numbers = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line"><span class="function"><span class="title">doSomething</span><span class="params">(numArr: &amp;numbers)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(numbers)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意，inout 修饰参数时采用的是拷入拷出模式，即在函数内部使用的是参数的copy，函数结束后，又对参数重新赋值。</p><p>由此，可以延伸一下，当一个类的属性被设置了 willSet 和 didSet 观察器时，如果该属性被作为函数参数，同时被 inout 修饰，那么当调用此函数时，会触发 willSet 和 didSet 观察器。</p></blockquote><h2 id="for循环倒序"><a href="#for循环倒序" class="headerlink" title="for循环倒序"></a>for循环倒序</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (0<span class="built_in">..</span>.10).reversed() &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> stride(<span class="keyword">from</span>:3,through:0,by: -1) &#123;</span><br><span class="line">    <span class="builtin-name">print</span>(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift的stride函数返回一个任意可变步长类型值的序列。可变步长类型是可以设置偏移量的一维标量。他有两个变种:</p><ol><li>from，to，最后一个值将会严格小(大)于to的值stride(from:3, to:0, by:-1) 表示3，2，1</li><li>from，through，最后一个值将会小(大)于等于through的值stride(from:3, through:0, by:-1) 表示3，2，1，0</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;列举swift使用经验&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
    
  </entry>
  
  <entry>
    <title>AC自动机多模式匹配</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/36_AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/36_AC自动机/</id>
    <published>2019-07-16T04:07:12.000Z</published>
    <updated>2019-07-16T09:35:56.575Z</updated>
    
    <content type="html"><![CDATA[<p>记录AC算法的主要思想</p><a id="more"></a><h2 id="失效指针计算"><a href="#失效指针计算" class="headerlink" title="失效指针计算"></a>失效指针计算</h2><p>计算失效指针的过程，看起来复杂，其实，如果我们把树中深度相同的节点放到同一层，那么某个节点的失败指针只能出现在上一层。</p><p>说白了，当前点相同， 找后缀的最长前缀 </p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/36_AC自动机/AC_failed.png" alt="失败指针的示意图"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildFailurePoint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> queue:[<span class="type">ACNode</span>] = <span class="type">Array</span>()</span><br><span class="line">    root.fail = <span class="literal">nil</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> !queue.isEmpty &#123;</span><br><span class="line">        <span class="keyword">let</span> p = queue.removeFirst()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">26</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pc = p.children[i]  <span class="comment">//p的子节点</span></span><br><span class="line">            <span class="keyword">if</span> pc == <span class="literal">nil</span> &#123; <span class="comment">//如果当前节点没有值，当然没有必要求失败指针了</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> p == root &#123; <span class="comment">//如果父节点，第二层，没必要循环了，直接设置为root</span></span><br><span class="line">                pc!.fail = root</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> q:<span class="type">ACNode</span>? = p.fail</span><br><span class="line">                <span class="keyword">while</span> q != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> qc = q?.children[pc!.data.toInt() - <span class="type">Character</span>(<span class="string">"a"</span>).toInt()]</span><br><span class="line">                    <span class="keyword">if</span> qc != <span class="literal">nil</span> &#123; <span class="comment">//处理相等的情况，最长后缀加长</span></span><br><span class="line">                        pc?.fail = qc</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    q = q!.fail  <span class="comment">//循环的根节点吧 ，退而求其，找个短的  </span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> q == <span class="literal">nil</span> &#123;</span><br><span class="line">                    pc?.fail = root</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.append(pc!)</span><br><span class="line">        &#125; <span class="comment">//end for</span></span><br><span class="line">    &#125;<span class="comment">//end while</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中ACNode定义如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ACNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data: <span class="type">Character</span>  <span class="comment">//节点的key</span></span><br><span class="line">    <span class="keyword">var</span> children : [<span class="type">ACNode</span>?]  <span class="comment">// 指向子节点的数组，字符集只包含 a~z 这 26 个字符</span></span><br><span class="line">    <span class="keyword">var</span> isEndingChar = <span class="literal">false</span> <span class="comment">//结尾字符为true</span></span><br><span class="line">    <span class="keyword">var</span> length = -<span class="number">1</span>  <span class="comment">//当isEndingChar= true时，记录模式串的长度</span></span><br><span class="line">    <span class="keyword">var</span> fail:<span class="type">ACNode</span>? <span class="comment">// 失败指针</span></span><br><span class="line">    <span class="keyword">init</span>(data:<span class="type">Character</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.data = data</span><br><span class="line">        <span class="keyword">self</span>.children = <span class="type">Array</span>(repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: childrenCount)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: ACNode, rhs: ACNode)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> lhs.data == rhs.data &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func insert(<span class="built_in">text</span>: String) &#123;</span><br><span class="line">    var p = root</span><br><span class="line">    <span class="keyword">for</span> i in <span class="number">0</span>..&lt;<span class="built_in">text</span>.count &#123;</span><br><span class="line">        <span class="built_in">let</span> index:Int = <span class="built_in">text</span>[<span class="built_in">text</span>.index(<span class="built_in">text</span>.startIndex, offsetBy: i)].toInt() - Character(<span class="string">"a"</span>).toInt()</span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">children</span>[index] == nil &#123;</span><br><span class="line">            <span class="built_in">let</span> newNode = ACNode(data: <span class="built_in">text</span>[<span class="built_in">text</span>.index(<span class="built_in">text</span>.startIndex, offsetBy: i)])</span><br><span class="line">            p.<span class="built_in">children</span>[index] = newNode</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.<span class="built_in">children</span>[index]!</span><br><span class="line">    &#125;</span><br><span class="line">    p.isEndingChar = <span class="literal">true</span>;</span><br><span class="line">    p.length = <span class="built_in">text</span>.count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mach</span><span class="params">(text: String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = text.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">var</span> p: <span class="type">ACNode</span>? = root</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123; <span class="comment">//for里面p不可能为nil</span></span><br><span class="line">        <span class="keyword">let</span> index = text[text.index(text.startIndex, offsetBy: i)].toInt() - <span class="type">Character</span>(<span class="string">"a"</span>).toInt()</span><br><span class="line">        <span class="keyword">while</span> p?.children[index] == <span class="literal">nil</span> &amp;&amp; p !== root &#123;  <span class="comment">//向树根节点移动，找最长后缀</span></span><br><span class="line">            p = p?.fail!  <span class="comment">// 失败指针发挥作用的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下面逻辑处理匹配情况， p增加</span></span><br><span class="line">        p = p?.children[index]</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">            p = root <span class="comment">// 如果没有匹配的，从 root 开始重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> tmp = p!</span><br><span class="line">        <span class="keyword">while</span> tmp !== root &#123;</span><br><span class="line">            <span class="keyword">if</span> tmp.isEndingChar == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> pos = i - tmp.length + <span class="number">1</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"匹配的起始下标 <span class="subst">\(pos)</span> length=<span class="subst">\(tmp.length)</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.fail!;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录AC算法的主要思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP字符串查找</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/34_KMP/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/数据结构和算法之美/34_KMP/</id>
    <published>2019-07-12T10:07:12.000Z</published>
    <updated>2019-07-16T01:27:41.925Z</updated>
    
    <content type="html"><![CDATA[<p>记录KMP算法的主要思想</p><a id="more"></a><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>模式串和主串匹配的过程，当遇到不匹配的字符的时候，我们希望找到一种规律，可以往后多滑动几位。</p><p>模式串和主串匹配的过程中，存在相等和不相等的可能。</p><p>不相等的处理：拿好前缀本身，在它的后缀子串中，查找最长的那个可以和好前缀的前缀子串匹配。</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_多滑动几位.png" alt="匹配过程中，不相等处理"></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func kmp(<span class="string">a:</span> String, <span class="string">n:</span> Int, <span class="string">b:</span> String, <span class="string">m:</span>Int) -&gt; Int &#123;</span><br><span class="line">    let next = getNexts(<span class="string">b:</span> b, <span class="string">m:</span> m)</span><br><span class="line">    var j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0.</span>.&lt;n &#123;</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; a[a.index(a.startIndex, <span class="string">offsetBy:</span> i)] != b[b.index(b.startIndex, <span class="string">offsetBy:</span> j)] &#123; <span class="comment">//处理不等于的情况，i不动，j尽量移动多位</span></span><br><span class="line">            j = next[j<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//相等，继续往后比较</span></span><br><span class="line">        <span class="keyword">if</span> a[a.index(a.startIndex, <span class="string">offsetBy:</span> i)] == b[b.index(b.startIndex, <span class="string">offsetBy:</span> j)] &#123;</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//查找到了结果</span></span><br><span class="line">        <span class="keyword">if</span> j == m &#123;</span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h2><p>next说明：</p><ol><li>下标：每个前缀结尾的下标</li><li>值： 这个前缀的最长可以匹配的前缀子串的结尾下标</li></ol><p>next[i-1] = k-1,则next[i] = k</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_Next求解中，相等处理.png" alt="KMP_Next求解中，相等处理"></p><p>查找b[0,i-1]的次长可匹配后缀子串，这个问题变成， 查找b[0,y]的最长匹配后缀子串的问题</p><p><img src="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/KMP_next求解中，不相等.png" alt="KMP_Next求解中，相等处理"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*失效函数：  b 表示模式串，m表示模式串的长度*/</span></span><br><span class="line">func getNexts(<span class="selector-tag">b</span>: String, m: Int) -&gt; [Int] &#123;</span><br><span class="line">    <span class="selector-tag">var</span> next:[Int] = Array(repeating: -<span class="number">1</span>, count: m)  <span class="comment">//定义失效函数</span></span><br><span class="line">    <span class="selector-tag">var</span> k = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;m &#123;</span><br><span class="line">        while k != -<span class="number">1</span> &amp;&amp; <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: k+<span class="number">1</span>)] != <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: i)] &#123;</span><br><span class="line">            k = next[k]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: k+<span class="number">1</span>)] == <span class="selector-tag">b</span>[<span class="selector-tag">b</span>.index(<span class="selector-tag">b</span><span class="selector-class">.startIndex</span>, offsetBy: i)] &#123;</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[k] = k</span><br><span class="line">    &#125;</span><br><span class="line">    return next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录KMP算法的主要思想&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构和算法之美" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>理解OAuth</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/OAuth%202.0/OAuth/"/>
    <id>http://yoursite.com/wiki/编程理论/OAuth 2.0/OAuth/</id>
    <published>2019-07-11T04:11:35.000Z</published>
    <updated>2019-07-16T01:23:34.166Z</updated>
    
    <content type="html"><![CDATA[<p>理解OAuth</p><a id="more"></a><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p><img src="/wiki/编程理论/OAuth 2.0/OAuth/auth.png" alt="OAuth"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" rel="external nofollow noopener noreferrer" target="_blank">理解OAuth 2.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;理解OAuth&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
      <category term="OAuth 2.0" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/OAuth-2-0/"/>
    
    
  </entry>
  
  <entry>
    <title>Swift新特性</title>
    <link href="http://yoursite.com/wiki/IOS/swiftUI/swiftUI/"/>
    <id>http://yoursite.com/wiki/IOS/swiftUI/swiftUI/</id>
    <published>2019-07-02T04:07:12.000Z</published>
    <updated>2019-07-04T11:00:51.440Z</updated>
    
    <content type="html"><![CDATA[<p>本文按照自己的思路理解swift的新特性</p><a id="more"></a><h2 id="function-Builder-新特性"><a href="#function-Builder-新特性" class="headerlink" title="function Builder  新特性"></a>function Builder  新特性</h2><h2 id="单表达式隐式返回"><a href="#单表达式隐式返回" class="headerlink" title="单表达式隐式返回"></a>单表达式隐式返回</h2><p>计算属性、函数语句、闭包表达式，如果只有一个表达式，可以省略return关键字</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Rectangle &#123;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">width</span> = <span class="number">0.0</span>, <span class="built_in">height</span> = <span class="number">0.0</span></span><br><span class="line">    <span class="built_in">var</span> area1: Double &#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;</span><br><span class="line">    </span><br><span class="line">    func area2() -&gt; Double &#123; <span class="built_in">width</span> * <span class="built_in">height</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="根据结构体默认成员合成默认初始化器"><a href="#根据结构体默认成员合成默认初始化器" class="headerlink" title="根据结构体默认成员合成默认初始化器"></a>根据结构体默认成员合成默认初始化器</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct Dog &#123;</span><br><span class="line">    var <span class="attr">name</span> = <span class="string">"Generic dog name"</span></span><br><span class="line">    var <span class="attr">age</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">boltNewborn</span> = Dog()</span><br><span class="line"><span class="keyword">let</span> <span class="attr">daisyNewborn</span> = Dog(name: <span class="string">"Daisy"</span>, age: <span class="number">0</span>)</span><br><span class="line">// before swift <span class="number">5.0</span> ❎</span><br><span class="line"><span class="keyword">let</span> <span class="attr">benjiNewborn</span> = Dog(name: <span class="string">"Benji"</span>)</span><br><span class="line">// after switft <span class="number">5.1</span> ✅</span><br><span class="line"><span class="keyword">let</span> <span class="attr">benjiNewborn</span> = Dog(name: <span class="string">"Benji"</span>)</span><br></pre></td></tr></table></figure><h2 id="属性包装器"><a href="#属性包装器" class="headerlink" title="属性包装器"></a>属性包装器</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/propertyWarpper.png" alt="属性包装器"></p><h2 id="不透明返回类型"><a href="#不透明返回类型" class="headerlink" title="不透明返回类型"></a>不透明返回类型</h2><p>协议中有关联类型，不是一个完全类型，编译时，无法推断类型，使用some 修饰协议返回值，就是不透明返回类型，使用者不知道类型， 编译器知道具体的类型。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after switft 5.1 ✅</span></span><br><span class="line">struct ContentView: View &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">body</span>: some View &#123;</span><br><span class="line">        Text(<span class="string">""</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift-Style-DSL-Function-Builder"><a href="#Swift-Style-DSL-Function-Builder" class="headerlink" title="Swift Style DSL / Function Builder"></a>Swift Style DSL / Function Builder</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/viewBuildrer.png" alt="function Builder  新特性"></p><h2 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h2><p>优先使用值类型，在栈上分配，COW </p><h2 id="协议还是泛型"><a href="#协议还是泛型" class="headerlink" title="协议还是泛型"></a>协议还是泛型</h2><p>使用协议时，尽量优先抽取功能，使用组合协议</p><h2 id="抽象数据访问"><a href="#抽象数据访问" class="headerlink" title="抽象数据访问"></a>抽象数据访问</h2><p>@Binding @State @EnviromentObject @Enviroment。</p><h2 id="View链式调用的理解"><a href="#View链式调用的理解" class="headerlink" title="View链式调用的理解"></a>View链式调用的理解</h2><p><img src="/wiki/IOS/swiftUI/swiftUI/VIewModifier.png" alt="View链式调用的理解"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook/" rel="external nofollow noopener noreferrer" target="_blank">SwiftUI 的一些初步探索 (一)</a></li><li><a href="https://mp.weixin.qq.com/s/ciiauLB__o-cXXfKn7lL1Q" rel="external nofollow noopener noreferrer" target="_blank">系列文章深度解读|SwiftUI 背后那些事儿</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文按照自己的思路理解swift的新特性&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swiftUI" scheme="http://yoursite.com/categories/IOS/swiftUI/"/>
    
    
      <category term="SwiftUI" scheme="http://yoursite.com/tags/SwiftUI/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 分享内容</title>
    <link href="http://yoursite.com/wiki/IOS/swiftUI/swiftUI_Share/"/>
    <id>http://yoursite.com/wiki/IOS/swiftUI/swiftUI_Share/</id>
    <published>2019-07-02T04:07:12.000Z</published>
    <updated>2019-07-10T11:58:19.510Z</updated>
    
    <content type="html"><![CDATA[<p>介绍SwiftUI</p><a id="more"></a><h2 id="跨平台技术演变史"><a href="#跨平台技术演变史" class="headerlink" title="跨平台技术演变史"></a>跨平台技术演变史</h2><ol><li>H5+原生（Cordova）</li><li>JavaScript开发+原生渲染 （React Native、Weex）</li><li>自绘UI+原生功能(Flutter、SwiftUI)</li></ol><h3 id="H5-原生"><a href="#H5-原生" class="headerlink" title="H5+原生"></a>H5+原生</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_H5.png" alt="混合APP的原理"></p><p>缺点：</p><ol><li>webview渲染存在性能瓶颈、复杂任务无法胜任</li><li>调用原生功能需要封装插件，麻烦</li></ol><h3 id="JavaScript开发-原生渲染"><a href="#JavaScript开发-原生渲染" class="headerlink" title="JavaScript开发+原生渲染"></a>JavaScript开发+原生渲染</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Weex.png" alt="JavaScript开发+原生渲染"></p><p>分析： </p><ol><li>解决了Webview渲染性能问题，相比较于原生，多了从Vue到原始的翻译过程。</li><li>调用原生功能需要封装插件，也比较麻烦</li></ol><h3 id="自绘UI-原生功能"><a href="#自绘UI-原生功能" class="headerlink" title="自绘UI+原生功能"></a>自绘UI+原生功能</h3><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_flutter.png" alt="flutter"></p><p>flutter Dart语言开发, Skia渲染。Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API</p><p>分析： </p><ol><li>解决了JS到Native的翻译过程，自渲染。</li><li>调用原生功能需要封装插件，也比较麻烦</li></ol><h2 id="SwiftUI简介"><a href="#SwiftUI简介" class="headerlink" title="SwiftUI简介"></a>SwiftUI简介</h2><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_SwiftUI.png" alt="SwiftUI"></p><ol><li>声明式语法（SwiftUI），内部黑盒完成渲染</li><li>响应式编程，数据变化，监控、通知SwiftUI刷新数据</li><li>无缝调用原始功能</li></ol><h2 id="一个例子—体验SwiftUI现代编程语言的魅力"><a href="#一个例子—体验SwiftUI现代编程语言的魅力" class="headerlink" title="一个例子—体验SwiftUI现代编程语言的魅力"></a>一个例子—体验SwiftUI现代编程语言的魅力</h2><p>代码</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span>  <span class="selector-tag">LandmarkList</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="variable">@EnvironmentObject</span> var <span class="attribute">userData</span>: UserData</span><br><span class="line">    </span><br><span class="line">    var <span class="attribute">body</span>: some View &#123;</span><br><span class="line">        <span class="selector-tag">NavigationView</span> &#123;</span><br><span class="line">            <span class="selector-tag">List</span> &#123;</span><br><span class="line">                <span class="selector-tag">Toggle</span>(<span class="attribute">isOn</span>: $userData.showFavoritesOnly) &#123;</span><br><span class="line">                    <span class="selector-tag">Text</span>(<span class="string">"Show Favorites Only"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="selector-tag">ForEach</span>(userData.landmarks) &#123; <span class="selector-tag">landmark</span> <span class="selector-tag">in</span></span><br><span class="line">                    <span class="selector-tag">if</span> !<span class="selector-tag">self</span><span class="selector-class">.userData</span><span class="selector-class">.showFavoritesOnly</span> || <span class="selector-tag">landmark</span><span class="selector-class">.isFavorite</span> &#123;</span><br><span class="line">                        <span class="selector-tag">NavigationButton</span>(</span><br><span class="line">                            <span class="attribute">destination</span>: LandmarkDetail(<span class="attribute">landmark</span>: landmark)</span><br><span class="line">                                .environmentObject(self.userData)</span><br><span class="line">                        ) &#123;</span><br><span class="line">                            <span class="selector-tag">LandmarkRow</span>(<span class="attribute">landmark</span>: landmark)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="selector-class">.navigationBarTitle</span>(Text(<span class="string">"Landmarks"</span>), <span class="attribute">displayMode</span>: .large)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">struct</span> <span class="selector-tag">LandmarkRow</span>: <span class="selector-tag">View</span> &#123;</span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">landmark</span>: <span class="selector-tag">Landmark</span></span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">var</span> <span class="selector-tag">body</span>: <span class="selector-tag">some</span> <span class="selector-tag">View</span> &#123;</span><br><span class="line">        <span class="selector-tag">HStack</span> &#123;</span><br><span class="line">            <span class="selector-tag">landmark</span><span class="selector-class">.image</span>(<span class="attribute">forSize</span>: <span class="number">50</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">Text</span>(<span class="attribute">verbatim</span>: landmark.name)</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">Spacer</span>()</span><br><span class="line">            </span><br><span class="line">            <span class="selector-tag">if</span> <span class="selector-tag">landmark</span><span class="selector-class">.isFavorite</span> &#123;</span><br><span class="line">                <span class="selector-tag">VStack</span> &#123;</span><br><span class="line">                    <span class="selector-tag">Image</span>(<span class="attribute">systemName</span>: <span class="string">"star.fill"</span>)</span><br><span class="line">                        <span class="selector-class">.imageScale</span>(.medium)</span><br><span class="line">                        <span class="selector-class">.foregroundColor</span>(.yellow)</span><br><span class="line">                    <span class="selector-tag">Text</span>(<span class="string">"sdfsdf"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Sample.png" alt="例子"></p><h2 id="SwiftUI原理浅析"><a href="#SwiftUI原理浅析" class="headerlink" title="SwiftUI原理浅析"></a>SwiftUI原理浅析</h2><h3 id="View的运作原理"><a href="#View的运作原理" class="headerlink" title="View的运作原理"></a>View的运作原理</h3><p>体会了SwiftUI的简洁用法，强大的功能后，分析下背后的原理：</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_modifer.png" alt="声明式原理"></p><p>定义了View的协议，所有的控件都准守View协议，View协议只定义了一个属性body，由于有了body属性，所以可以对body做对应的操作，这些操作封装在View的扩展中。这些扩展称为modifier。modifer作用于一个元素后，返回一个modified对象，这个对象也准守View协议，可以链式调用。</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_VIew_protocal.png" alt="view协议定义"></p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_chain.png" alt="链式调用的分析"></p><ol><li>声明了控件的样式（内存看是链式结构）， 传入渲染引擎渲染。开发者只声明，不用管复杂的渲染机制，大大简化了开发难度</li><li>按需添加modifer，避免子类内存暴涨（性能）</li><li>基于协议式，底层可以任意修改，底层预留可非常大的扩展空间</li></ol><h3 id="HStack-ZStack"><a href="#HStack-ZStack" class="headerlink" title="HStack/ZStack"></a>HStack/ZStack</h3><p>HStack 和 ZStack 的非常类似安卓的 LinerLayout，算法也同 Flex 布局比较相似。 对于如下的布局, 苹果都会在控件之间添加上符合苹果人机交互指南的间距，保证 UI 的优雅和一致性。</p><p><img src="/wiki/IOS/swiftUI/swiftUI_Share/SwiftUI_Stack.png" alt="Stack"></p><p>对于如上的 Stack 是怎么计算的？设 Stack 主轴方向长度为 W1。</p><ol><li>根据人机交互指南的预留出边距 S, 边距根据元素的排列可能有多个</li><li>得到剩余的主轴宽度 W2= W1 - N * S</li><li>平均分配一个预估宽度</li><li>计算一些具备明确宽高的元素 如 Image 设置了 Frame的元素的等。</li><li>沿主轴方向从前到后计算，，如果计算出来的宽度小于预估宽度则正常显示，不够则截断。</li><li>最后的元素为剩余宽度，如果不够显示则阶段</li><li>默认的交叉轴对齐方式为 Center，Stack 占据包括最大元素的边界。</li></ol><p>默认的计算是顺序计算布局，如果某些元素比较重要，可以使用 LayoutPriority Modifier 提高布局优先级避免出现视图截断。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>基于声明式，底层做了大量工作，上层开发者开发更简单</li><li>响应式也简化了内部状态的维护</li><li>苹果生态系统的无缝衔接，无缝调用原生功能</li><li>内部人性化精细的设计，苹果的大力推广，不久的几年后，苹果开发的主要方式？</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li><li><a href="https://onevcat.com/2019/06/swift-ui-firstlook/" rel="external nofollow noopener noreferrer" target="_blank">SwiftUI 的一些初步探索 (一)</a></li><li><a href="https://mp.weixin.qq.com/s/ciiauLB__o-cXXfKn7lL1Q" rel="external nofollow noopener noreferrer" target="_blank">系列文章深度解读|SwiftUI 背后那些事儿</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍SwiftUI&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swiftUI" scheme="http://yoursite.com/categories/IOS/swiftUI/"/>
    
    
      <category term="SwiftUI" scheme="http://yoursite.com/tags/SwiftUI/"/>
    
  </entry>
  
</feed>
