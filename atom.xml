<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-21T10:22:03.805Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协议</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11%20%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/11 协议/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:22:03.805Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>协议中的变量： 属性一律var</li><li>协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类的必要初始化器， 子类实现的时候，可以省略override。</li><li>非可失败的初始化器 ：  非可失败、 ！</li><li>可失败： 三种可以</li><li>协议组合 &amp;</li><li>类型属性必须是static</li><li>遍历枚举  CaseIterable   allcases</li><li>CustomStringConvertible description</li><li>any anyObject 只能被类准守</li><li>is 判断是否是某种类型 as ？ Student 可选项 as Any</li><li>metadata 元类型</li><li>Persion.self 和堆空间的前8个字节存储一样的内容  就是元类型</li><li>Persion.Type</li><li><p>AnyClass = AnyObject.type</p></li><li><p>类名和X.self有很多相同点，可以调用方法，不同点：X.self能赋值给变量，类名不能复制给变量。</p></li></ul><ol><li>使用元类型调用的初始化方法一定是requied的，因为你可以给元类型传递一个子类的对象，如果子类没有该初始化方法，那么就失败。为了不失败，所以标记为requied</li><li>Self  应用于返回值，如果协议中定义的方法返回当前对象，在子类中就需要返回子类对象，所以使用Self</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;协议中的变量： 属性一律var&lt;/li&gt;
&lt;li&gt;协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%20/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/12 错误处理 /</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:24:12.017Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>常见的错误</strong>：</p><ol><li>语法</li><li>逻辑</li><li>运行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;常见的错误&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>14 枚举的本质、溢出运算符</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14%20%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%81%E6%BA%A2%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/14 枚举的本质、溢出运算符/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-25T05:52:49.910Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>运算符重载</p><p>运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能</p><p>运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法</p><p>static prefix func -(Int)-&gt; Int  {</p><p>}</p><p>Equatable协议<br>如果一个类已经有相等的方法，也要声明为准守Equatable协议，好处</p><p>明确告诉别人，我有比较功能<br>很多有要求Equatable协议的地方，都可以使用了<br>也能使用!= 运算符</p><p>对于引用类型，比较存储的地址值是否相等使用 ===       !==</p><p>Comparable 协议</p><p>比较的结果三种情况</p><p>自定义运算符<br>prefix operator<br>postfix operator<br>infix operator : 优先级组</p><p>结合性 ： 多个运算符，描述先从左边开始，还是先从右边开始 ，如果没有结合性，表示不允许连续出现多个运算符<br>优先级 ： 高于什么，低于什么<br>assignment ： 在可选链拥有和赋值运算符有一样的优先级</p><p>扩展</p><p>不能添加存储属性： 不能改变内存结构<br>扩展可以给协议提供默认实现，也间接的实现了可选协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;运算符重载&lt;/p&gt;
&lt;p&gt;运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能&lt;/p&gt;
&lt;p&gt;运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法&lt;/p&gt;
&lt;p&gt;static prefix func -(Int)
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>18 swift OC 混合编程</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/18%20swift%20OC/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/18 swift OC/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-26T10:45:33.885Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用</p><p>补存内容 ： catch默认存在error</p><p>#warning()<br>// TODO:  </p><p>编码习惯： xcode自己生成的类冒号跟着前面        </p><p>@UIApplicationMain  就是新的入口 </p><p>Swift调用OC写的东西 </p><p>1 新建桥接文件 ： targetName-Bridging-Header.h  就是OC暴露给swift的东西<br>@_silgen_name(“sum”) func malloc(v1: Int32, v2: Int) -&gt; Int32</p><p>swift 暴露给OC的条件</p><ol><li>继承NSObject</li><li>objcMembers    或使用@objc 修饰需要暴露的成员 </li></ol><p>@objc  还能修改暴露给OC的类名的名称， 方法名 </p><p>字符串处理 ：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用&lt;/p&gt;
&lt;p&gt;补存内容 ： catch默认存在error&lt;/p&gt;
&lt;p&gt;#warning()&lt;br&gt;// TODO:  &lt;/p&gt;
&lt;p&gt;编码习惯： xcode自己生成的类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>13 汇编分析String、Array的结构</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13%20%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90String%E3%80%81Array%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/13 汇编分析String、Array的结构/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-22T06:52:10.463Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>0x30是数字0的ascii码</li><li>tag pointer 干嘛用的？直接将内容放在变量的地址中</li><li>rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验证。</li></ul><p>长度大于0xf 的存储情况：</p><ol><li>rax 长度   </li><li>rdx 地址，地址-0x7ffffffffffffe0=真实存储地址</li></ol><p>内存分布情况：</p><ol><li>代码区</li><li>常量区</li><li>全局区</li><li>堆区</li><li>栈区</li></ol><p>内存布局图：</p><ol><li>mach-o</li><li>运行内存</li><li>动态库</li></ol><blockquote><p>小技巧： 字符串的真实地址 ： 后面的地址+0x20</p><p>小技巧：1后面跟着4个0 一般是全局区，如果不是那么一般是堆区</p></blockquote><p>append干了什么事情： 变为堆空间， 跳过32字节，后面就是内容是存储的真实字符串</p><p><strong>小小总结：</strong></p><ol><li>字符串长度&lt;=0xf  字符串内容直接存储在变量的内存中</li><li>字符串的长度&gt;0xf,字符串存放在常量区（__TEXT.cstring）,地址信息存储在在变量的后8自己中，真实地址= 后面的地址+0x20</li><li>append 后有大于0xf，会开辟空间</li></ol><p><strong>dyld_stub_binder</strong></p><ol><li>stub 翻译为符号</li><li>动态库中的函数，加载完动态库才能知道（也就是运行的时候才知道），那么编译的时候怎么办？ 放置一个占位地址，这个函数就是一个占位地址</li></ol><p><strong>数组的内存结构</strong></p><p> arr占用8字节，这8字节存储着堆空间地址，堆空间结构：</p><ol><li>？</li><li>引用计数</li><li>元素数量</li><li>数组容量</li><li>元素1</li><li>元素2</li><li>元素3</li><li>元素n</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;0x30是数字0的ascii码&lt;/li&gt;
&lt;li&gt;tag pointer 干嘛用的？直接将内容放在变量的地址中&lt;/li&gt;
&lt;li&gt;rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Block的本质</title>
    <link href="http://yoursite.com/wiki/IOS/Block/block/"/>
    <id>http://yoursite.com/wiki/IOS/Block/block/</id>
    <published>2019-09-27T04:07:12.000Z</published>
    <updated>2019-09-29T02:28:33.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解block的本质</p><a id="more"></a><h2 id="block的底层实现"><a href="#block的底层实现" class="headerlink" title="block的底层实现"></a>block的底层实现</h2><p>源码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (^<span class="keyword">block)(void) </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="name">*block</span>)(<span class="name">void</span>) = &amp;__main_block_impl_0(<span class="name">__main_block_func_0</span>, <span class="symbol">&amp;__main_block_desc_0_DATA</span>)<span class="comment">;</span></span><br><span class="line">block-&gt;FuncPtr(<span class="name">block</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>所以，block 的本质是<code>__main_block_impl_0</code>结构体，构造一个<code>__main_block_impl_0</code>结构，将<code>__main_block_impl_0</code>的地址赋值给block,执行block的过程是通过block找到函数指针FuncPtr，调用。  <code>__main_block_impl_0</code>的结构如下（这几个结构体名字不好记，牢记impl是整体实现，实现里面有函数指针func）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>包含两个成员，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;   <span class="comment">//isa，说明是OC对象</span></span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;  <span class="comment">//block内的代码封装为函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>其中，函数指针 <code>__main_block_func_0</code>的定义</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量字符串定义在数据区</span></span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>整体捋下思路，block的结构简单理解为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Block是一个<span class="keyword">impl</span>结构  -&gt;__block_impl     -&gt; isa，表明是OC对象</span><br><span class="line">                   |                  -&gt; func函数指针,封装block的代码</span><br><span class="line">                   |</span><br><span class="line">                   -&gt; 描述</span><br></pre></td></tr></table></figure><blockquote><p>总结: block的本质就是封装了函数调用以及函数调用环境的OC对象</p></blockquote><h2 id="带参数的block"><a href="#带参数的block" class="headerlink" title="带参数的block"></a>带参数的block</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) = ^(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d,%d"</span>,a,b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">block</span>(c, d);</span><br></pre></td></tr></table></figure><p>翻译为CPP代码:</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化<span class="keyword">block</span>对象</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) =</span><br><span class="line">&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line">//执行<span class="keyword">block</span></span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>, c, d);</span><br></pre></td></tr></table></figure><p>各个结构的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block的底层结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//block内的函数指针</span></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself, int a, int b) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_3e8a17_mi_0,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><h2 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h2><ol><li>在OC中变量的类型主要使用三种, 分别是auto、static、全局变量, 其中auto和static修饰的是局部变量</li><li>对这三种类型的变量, block在使用使用时, 会有不同的捕获方式</li></ol><h3 id="auto变量捕获-值捕获"><a href="#auto变量捕获-值捕获" class="headerlink" title="auto变量捕获(值捕获)"></a>auto变量捕获(值捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    int age;  <span class="comment">//多了一个成员变量</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int _age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//age的赋值是通过构造函数初始化列表完成的</span></span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">    int age = __cself-&gt;age; <span class="comment">// bound by copy 取出block结构内的age</span></span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_82fbf9_mi_0,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，block对于auto变量会值不会，通过在block底层结构中增加捕获的变量定义。</p><h3 id="static变量捕获-指针捕获"><a href="#static变量捕获-指针捕获" class="headerlink" title="static变量捕获(指针捕获)"></a>static变量捕获(指针捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);  //输出<span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//将age的地址传入block的构造函数中</span></span><br><span class="line">void <span class="comment">(*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age);</span></span><br><span class="line"><span class="comment">age = 25;</span></span><br><span class="line"><span class="comment">block-&gt;FuncPtr(__block_impl *)</span><span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  int *age;   <span class="comment">//定义为指针类型</span></span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//构造列表是初始化age指针</span></span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">  int *age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_1d503d_mi_0,(*age));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="block中使用全局变量-不会捕获"><a href="#block中使用全局变量-不会捕获" class="headerlink" title="block中使用全局变量(不会捕获)"></a>block中使用全局变量(不会捕获)</h3><p>全局变量不捕获</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/wiki/IOS/Block/block/block1.png" alt="block总结"></p><h2 id="点点滴滴"><a href="#点点滴滴" class="headerlink" title="点点滴滴"></a>点点滴滴</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="keyword">arch</span> arm64 -rewrite-objc main.<span class="built_in">m</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解block的本质&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/categories/IOS/Block/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>学习runtime的参考文档</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/reffer/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/reffer/</id>
    <published>2019-09-19T03:38:11.000Z</published>
    <updated>2019-09-19T07:15:43.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录学习runtime过程中，有用的文档。</p><a id="more"></a><h2 id="学习过的文档"><a href="#学习过的文档" class="headerlink" title="学习过的文档"></a>学习过的文档</h2><ol><li><a href="https://juejin.im/user/5a329c1351882529707931f0/posts" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记</a></li><li><a href="https://juejin.im/post/5b248ad151882574e808d3c9" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第一天: Objective-C的本质</a></li><li><a href="https://juejin.im/post/5b646f44f265da0fae4f3e6c" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第二天: OC对象的分类</a></li><li></li></ol><h2 id="通用文档"><a href="#通用文档" class="headerlink" title="通用文档"></a>通用文档</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录学习runtime过程中，有用的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>GCD源码理解</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD_Source/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/GCD_Source/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T11:57:53.764Z</updated>
    
    <content type="html"><![CDATA[<p>GCD源码理解</p><a id="more"></a><h2 id="GCD理解"><a href="#GCD理解" class="headerlink" title="GCD理解"></a>GCD理解</h2><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_sync.png" alt="同步"></p><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_async.png" alt="异步"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCD源码理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/referr/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/referr/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-18T10:39:43.475Z</updated>
    
    <content type="html"><![CDATA[<p>记录读过的文章</p><a id="more"></a><h2 id="读过的文章"><a href="#读过的文章" class="headerlink" title="读过的文章"></a>读过的文章</h2><ol><li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></li><li><a href="https://objccn.io/issue-2-1/#challenges" rel="external nofollow noopener noreferrer" target="_blank">并发编程：API 及挑战</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" rel="external nofollow noopener noreferrer" target="_blank">深入理解RunLoop</a>    </li><li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『RunLoop』详尽总结</a></li></ol><h2 id="需要读的"><a href="#需要读的" class="headerlink" title="需要读的"></a>需要读的</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrency Programming Guide</a></li><li><a href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/" rel="external nofollow noopener noreferrer" target="_blank">浅谈iOS多线程(源码)</a></li><li><a href="https://objccn.io/issue-2-3/" rel="external nofollow noopener noreferrer" target="_blank">底层并发 API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录读过的文章&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperation/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperation/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T09:45:48.872Z</updated>
    
    <content type="html"><![CDATA[<p>NSOperation类文档学习记录</p><a id="more"></a><h2 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h2><p>依赖可以控制操作执行的顺序，相关函数：</p><ol><li>addDependency</li><li>removeDependency</li></ol><p>当依赖的operation全部为完成状态时，operation才能为ready的状态。当最后一个依赖完成后，operation的状态变为ready状态。</p><p>依赖不区分operation是完成了还是取消了。</p><h2 id="KVO属性"><a href="#KVO属性" class="headerlink" title="KVO属性"></a>KVO属性</h2><p>KVO属性包括：</p><ol><li>isCancelled</li><li>isAsynchronous</li><li>isExecuting</li><li>isFinished</li><li>isReady</li><li>dependencies</li><li>queuePriority</li><li>completionBlock</li></ol><h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>多线程调用NSOperation的方法时安全的，不需要加锁。<br>子类的自定义方法需要考虑多线程问题。</p><h2 id="异步VS同步"><a href="#异步VS同步" class="headerlink" title="异步VS同步"></a>异步VS同步</h2><p>操作可以手动执行、也可以添加到queue中执行。</p><p>手动执行（直接调用start方法），分为同步operation和异步operation ，同步在当前线程立即执行。异步在新的线程执行任务。</p><p>如果操作在队列中执行，一般定义为同步的，队列不关注asynchronous属性，总是在一个单独的线程中调用start方法。所有没有理由设计为异步的。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>非并发队列：重写 main方法。<br>并发队列：需要重写start、 asynchronous、executing、finished方法。</p><p><strong>注意是否重写main决定了是否是并发操作。</strong></p><p>下面是子类化的要点：</p><ol><li>在并发队列中，start方法负责异步开始操作。</li><li>start方法中需要通过KVO更新operation的executing状态为YES。</li><li>operation完成或取消后，并发队列必须通过KVO更新isExecuting为NO 和 isFinished为YES。如果是取消，也需要更新isFinished状态为YES。</li><li>operation 只有完成了，才能从queue中移除。</li><li>同时需要重写 executing、finished属性（KVC）。</li><li>start方法需要检查是否operation被取消了。</li><li>如果定制了依赖，需要KVO isReady属性。</li></ol><p><strong>状态管理</strong>：</p><ol><li>isReady，一般不用管理，依赖的时候处理。</li><li>isExecuting，替换了start方法，一定要替换isExecuting方法，并在start开始的时候发出KVO</li><li>isFinished，替换了start方法，一定要替换isFinished方法。operation完成或取消，发出KVO</li><li>isCancelled，不需要发出KVO</li></ol><p><strong>响应取消</strong></p><p>一旦将operation添加到queue中，queue就掌管了operation。你可以通过调用operation的cancell方法取消，或者通过queue的cancelAllOperations取消。</p><p>执行中的任务并不会立马取消， 你必须显式的检测状态，需要的时候取消。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSOperation类文档学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperaionQueue 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperaionQueue/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperaionQueue/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-18T03:56:35.505Z</updated>
    
    <content type="html"><![CDATA[<p>记录NSOperaionQueue的理解</p><a id="more"></a><p><img src="/wiki/IOS/多线程/NSOperaionQueue/operaionQueue.png" alt="Queue执行operaion的流程"><br><img src="/wiki/IOS/多线程/NSOperaionQueue/2.png" alt="是否并发文档"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录NSOperaionQueue的理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/定积分/</id>
    <published>2019-09-10T01:07:12.000Z</published>
    <updated>2019-10-26T09:59:19.211Z</updated>
    
    <content type="html"><![CDATA[<p>记录定积分的学习记录，方便以后复习</p><a id="more"></a><h2 id="定积分的概念和性质"><a href="#定积分的概念和性质" class="headerlink" title="定积分的概念和性质"></a>定积分的概念和性质</h2><p><strong>一、 定积分问题举例</strong></p><ol><li><p>曲边梯形的面积 $A=\lim \limits_{\lambda \to 0} {\sum_{i=1}^n{f(\xi) \Delta x}}$</p></li><li><p>变速直线运动的路程 $s = \lim_{\lambda \to 0}{\sum_{i = 1}^{n}{\nu}({\tau}_i)} \Delta t_i$</p></li></ol><blockquote><p>相同点： 特定和的极限</p></blockquote><p>定义： 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点</p><p>$$a=x_0 &lt; x_1&lt;x_2…&lt;x_{n-1}&lt;x_n = b$$</p><p>把区间[a,b]分成n个小区间<br>$$[x_0,x_1],[x_1,x_2],…,[x_{n-1}]$$<br>各个小区间的长度依次为<br>$$\Delta x_1 = x_1-x_0,\Delta x_2 = x_2-x_1 … \Delta x_n = x_n - x_{n-1}$$<br>在每个小区间上任意去一点$\xi$,作为函数值$f(\xi)$与小区间长度$\Delta x_i$的乘积 $f(\xi_i) \cdot \Delta x_i$，并作出和<br>$$S = \sum_{i=1}^n{f(\xi_i) \cdot \Delta x_i}$$<br>如果和的极限存在，且闭区间[a,b]的分法及点$\xi_i$的取法无关，那么这个极限I为函数f(x)在区间[a,b]上的定积分，记作$\int_a^b{f(x)dx}$，即<br>$$\int_a^b{f(x)dx} = I = \lim_{\lambda \to 0}{\sum_{i=1}^n{f(\xi_i) \Delta x_i}}$$<br>其中[a,b]叫做积分区间。a叫做积分下限，b叫做积分上限</p><p>定积分的值只与被积函数和积分区间有关，而与积分变量和记法无关。</p><p>那么，对于定积分，函数$f(x)$在[a,b]上满足怎样的条件，f(x)一定可积呢？下面两个定理回答这个问题。</p><p><strong>定理1</strong> 设f(x)在区间[a,b]上连续，则f(x)在[a,b]上可积<br><strong>定理2</strong> 设f(x)在区间[a,b]上有界，且只有有限个间断点，则f(x)在[a,b]上可积</p><p>利用积分的性质，解决开篇的两个问题 :</p><ol><li>$A = \int^b_a{f(x)dx}$</li><li>$s = \int^{T_2}_{T_1}{\nu}(t)dt$</li></ol><p><strong>三、 定积分的近似计算</strong></p><ol><li>矩形法</li><li>抛物线法</li></ol><p><strong>四、 定积分的性质 </strong></p><p><strong>性质1</strong>： 设$\alpha$与$\beta$为常数，则：</p><p>$$\int^b_a{[{\alpha}f(x)+{\beta}g(x)]dx} = {\alpha} \int^b_a{f(x)dx}+{\beta}\int^b_a{g(x)dx}$$</p><p><strong>性质2(积分区间可加性)</strong>：设a&lt;c&lt;b，则<br>$$\int^b_a{f(x)dx} = \int^c_a{f(x)dx} + \int^b_c{f(x)dx}$$</p><p><strong>性质三</strong>： 如果在区间[a,b]上f(x)=1,那么<br>$$\int^b_a 1dx = \int^b_a dx = b-a$$</p><p><strong>性质四</strong> 如果在区间[a,b]上f(x)$\ge 0$，那么</p><p>$$\int^b_a{f(x)dx} \ge 0$$</p><p><strong>性质五</strong> 如果M及m分别是函数f(x)在区间【a,b】上的最大值及最小值，则<br>$$ m(b-a) \le \int^b_a{f(x)dx} \le M(b-a)$$</p><blockquote><p>积分就是宽、高的和</p></blockquote><p><strong>性质六</strong>（定积分中值定理） 如果函数f(x)在积分区间[a,b]上连续，那么在[a,b]上至少存在一点$\xi$，使下式成立：<br>$$\int^b_a{f(x)dx} = f(\xi)(b-a)$$</p><h2 id="第二节-微分基本公式"><a href="#第二节-微分基本公式" class="headerlink" title="第二节 微分基本公式"></a>第二节 微分基本公式</h2><p><strong>一、 变速直线运动中，位置函数与速度函数之间的联系</strong></p><p>位置函数与速度函数有如下关系：</p><p>$$\int^{T_2}_{T_1}{\nu}(t)dt = s(T_2) - s(T_1) \text{，位置函数是速度函数的原函数，定积分是原函数的增量}$$</p><p><strong>二、积分上限的函数及其导数</strong> </p><p><strong>定理一</strong> 如果函数f(x)在区间[a,b]上连续，那么积分上限函数：<br>$$ \Phi (x) = \int^x_a{f(t)}dt$$<br>在[a,b]上可导，并且它的导数:</p><p>$$ {\Phi}’ (x) = \frac{d}{dx} \int^x_a{f(t)}dt = f(x)$$</p><p>这个定理指出了一个重要结论： 连续函数f(x)取边上限x的定积分，然后求导，其结果还原为f(x)本身。所以${\Phi} (x)$是连续函数 f(x)的一个原函数。</p><p><strong>定理二</strong> 如果函数f(x)在区间[a,b]上连续，那么函数</p><p>$$\Phi (x) = \int^x_a{f(t)}dt$$<br>就是f(x)在[a,b]上的一个原函数。</p><p>这个定理的意义：定积分和原函数的联系，因此我们就有可能通过原函数计算定积分。</p><p><strong>三、 牛顿-莱布尼茨公式</strong></p><p>这个定理的意义： 给出了用原函数计算定积分的公式。</p><p><strong>定理三：微积分基本定理</strong>：如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，那么<br>$$\int_a^b{f(x)dx}=F(b)-F(a)$$</p><p>这个函数进一步揭秘了原函数和不定积分之间的关系。</p><h2 id="第三节-定积分的换元法和分部积分法"><a href="#第三节-定积分的换元法和分部积分法" class="headerlink" title="第三节 定积分的换元法和分部积分法"></a>第三节 定积分的换元法和分部积分法</h2><p>定积分的分部积分法：</p><p>$$\int^b_a{\mu}d{\nu}= [{\mu}{\nu}]^b_a - \int^b_a{\nu} \mu d \mu$$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><ol><li>$1^2+2^2+..+n^2= \frac{1}{6}n(n+1)(2n+1)$</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录定积分的学习记录，方便以后复习&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷脸登录调研</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/faceLogin/"/>
    <id>http://yoursite.com/wiki/编程理论/人脸登录/faceLogin/</id>
    <published>2019-09-03T04:11:35.000Z</published>
    <updated>2019-09-03T08:57:01.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文调研人脸登录的实现思路。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>人脸登录包括两个流程：人脸注册、人脸查找。</p><h2 id="人脸注册"><a href="#人脸注册" class="headerlink" title="人脸注册"></a>人脸注册</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/register.png" alt="人脸注册流程"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data1.png" alt="图片组织结构"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data2.png" alt="facetoken和profileid对应关系"></p><h2 id="刷脸登录（查找人脸的过程）"><a href="#刷脸登录（查找人脸的过程）" class="headerlink" title="刷脸登录（查找人脸的过程）"></a>刷脸登录（查找人脸的过程）</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/login.png" alt="刷脸登录"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>非常像的双胞胎能识别出来吗？</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/zzqaaasss/article/details/89194437" rel="external nofollow noopener noreferrer" target="_blank">微信小程序使用face++实现人脸识别登录注册</a></li><li><a href="https://console.faceplusplus.com.cn/documents/4888373" rel="external nofollow noopener noreferrer" target="_blank">face++文档中心</a></li><li><a href="https://blog.csdn.net/qq_23412263/article/details/86232682" rel="external nofollow noopener noreferrer" target="_blank">使用 face++ API 实现人脸识别，刷脸登陆和活体检测（张张嘴，眨眨眼）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文调研人脸登录的实现思路。&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
      <category term="人脸登录" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章 不定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/four_indefinite_integral/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/four_indefinite_integral/</id>
    <published>2019-08-29T01:07:12.000Z</published>
    <updated>2019-10-26T07:32:33.631Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点，</p><a id="more"></a><h2 id="第一节-不定积分的概念和性质"><a href="#第一节-不定积分的概念和性质" class="headerlink" title="第一节 不定积分的概念和性质"></a>第一节 不定积分的概念和性质</h2><p>一、 原函数和不定积分的概念 </p><p>定义1：如果在区间I上，可导函数F(x)的导函数为f(x),即对任意x属于I都有：<br>$$F’(x)=f(x) 或dF(x)=f(x)dx$$<br>那么函数F(x)就称为f(x)（或f(x)dx）在区间I上的一个<strong>原函数</strong>。</p><p>什么样的函数才存在原函数？</p><p><strong>原函数存在定理</strong>：如果函数f(x)在区间I上连续，那么在区间I上存在可导函数F(x),使对任一x属于I，都有：</p><p>$$F’(x)=f(x)$$</p><p>简单的说，连续函数一定有原函数。</p><p>一个函数的原函数有怎样的特点呢：</p><ol><li>如果函数$f(x)$有一个原函数，那么$f(x)$有无限多个原函数</li><li>无限多个原函数相差一个常数，表达式 $F(x) + C $可以表示f(x)的任意一个原函数。</li></ol><p>所以，使用下面的定义表示无限多个原函数：</p><p><strong>定义2</strong> 在区间I上，函数$f(x)$的带有任意常数项的原函数称为$f(x)$(或$f(x)dx$)在区间I上的不定积分，记作：<br>$$\int{f(x)dx}$$<br>其中记号$\int$称为积分号，$f(x)$称为被积函数，$f(x)dx$<br>称为被积表达式，x称为积分变量。</p><p>结论：因而<strong>不定积分</strong>$\int{f(x)dx}$<strong>可以表达$f(x)$的任意一个原函数</strong>。</p><p>函数f(x)的原函数的图形称为函数f(x)的积分曲线。</p><p><strong>微分和积分的关系</strong> ：</p><p>由于$\int {f(x)dx}$ 是$f(x)$的原函数，所以：</p><p>$$\frac{d}{dx} \left[\int{f(x) dx} \right] = f(x)$$</p><p>又由于$F(x)$是$F’(x)$的原函数所以 ： $$\int F’(x)dx = F(x) + C$$</p><p>或者记作：</p><p>$$\int dF(x) = F(x) + C$$</p><p>由此可见，微分运算（以符号d表示）与不定积分运算（以记号$\int$表示）是互逆的，当$\int$和d连在一起的时候，或者可以抵消，或者抵消后差一个常数。</p><p><strong>基本积分表</strong></p><ol><li>$\int k dx = kx +C$</li><li>$\int x^{\mu} dx= \frac{x^{\mu + 1}}{\mu + 1} + C  \text  (\mu \ne -1) $</li><li>$\int \frac{dx}{x} = \ln |x| + C$</li><li>$\int \cos x dx = \sin x +C $</li><li>$\int \sin x dx$ = - cos x +C</li><li>$\int \frac{dx}{\sqrt{1-x^2}} = \arcsin x + C$</li><li>$\int \frac{dx}{\cos^2 x} = \int \sec^2 dx= \tan x + C $</li><li>$ \int \frac{dx}{\sin^2 x} = \int \csc^2 x dx = -\cot x + C$</li><li>$\int \frac{dx}{1+x^2} = \arctan x + C$</li><li>$\int \sec x \tan x dx = \sec x + C$</li><li>$\int \csc x \cot x dx = -\csc x +C$</li><li>$\int e^x dx = e^x + C$</li><li>$\int a^x dx = \frac{a^x}{\ln a} + C$</li></ol><p><strong>不定积分的性质</strong></p><p><strong>性质1(不定积分加法性质)</strong> 设函数f(x)及 g(x)<strong>的原函数存在</strong>，则</p><p>$$\int{[f(x)+g(x)]dx} = \int{f(x)dx} + \int{g(x)dx}$$</p><p><strong>性质2（不定积分系数性质）</strong> 设函数f(x)的原函数存在，k为非零常数，则 </p><p>$$\int{kf(x)dx}=k\int{f(x)dx}$$</p><h2 id="第二节-换元积分法"><a href="#第二节-换元积分法" class="headerlink" title="第二节 换元积分法"></a>第二节 换元积分法</h2><p>把复合函数的微分法反过来，用于求不定积分，利用中间变量的代换，得到复合函数的积分，称为<strong>积分换元法</strong>。</p><p>一、 第一类换元法 </p><p>定理1 设f(u)具有原函数，u=$\psi$(x)可导，则有换元公式<br>$$\int{f[\psi (x)]\psi ‘(x)dx} = [\int{f(u)du}]_{u=\psi (x)}$$</p><p>如果应用换元法求不定积分呢？设要求$\int{g(x)dx}$，如果g(x)可以化为g(x)= $f[\psi (x)]\psi ‘(x)$的形式，那么<br>$$\int {g(x)dx}= \int{f[\psi (x)]\psi ‘(x)dx}=\int{f(u)du}$$</p><blockquote><p>其中$\psi ‘(x)dx 转化为du$ 是将自变量微分形式 转化为整个因变量的微分形式。这需要理解。</p></blockquote><p>这样，就将函数$g(x)$的积分转化为函数$f(u)$的积分，如果能求出$f(u)$的原函数，那么就得到了$g(x)$的原函数。</p><p><strong>具体求解的步骤</strong>：</p><ol><li>选取$u = \psi (x)$</li><li>转化为这个$\int{f[\psi (x)]\psi ‘(x)dx} = \int{f(u)du}$  的形式</li><li>计算$f(u)$的积分</li><li>使用$u = \psi (x)$ 积分中的$u$替换为$x$。</li></ol><p><strong>示例</strong>： 计算$\int 2 \cos 2x dx$</p><ol><li>选取$u = 2x$</li><li>转化形式：$\int 2 \cos 2x dx = \int \cos 2x \cdot (2x)’ dx = \int \cos u du $</li><li>计算积分： $\int 2 \cos 2x dx = \sin u + C$</li><li>将$u$代换为$x$： $\int 2 \cos 2x dx = \sin 2x + C$</li></ol><p>二、 第二类换元法 </p><p>适当的选择变量代换，$x=\psi (t)$，将积分$\int f(x)dx$化为积分$\int f[\psi (t)] {\psi}’(t) dt $，这是另一种形式的变量代换，还原公式可以表达为 :</p><p>$$\int f(x)dx = \int f[\psi (t)] {\psi}’(t) dt$$</p><p>定理2 设$x=\psi (t)$是单调的可导函数，并且${\psi}’(t) \ne 0$ 又设$f[{\psi}(t)]{\psi}’(t)$具有原函数，则有还原公式 ：</p><p>$$\int{f(x)dx} = \left [{\int{f[{\psi(t)}]{\psi}’(t)dt}}\right ]_{t={\psi}^{-1}{(x)}}$$</p><h2 id="第三节-分部积分法"><a href="#第三节-分部积分法" class="headerlink" title="第三节 分部积分法"></a>第三节 分部积分法</h2><p>积分换元法基于的原理是复合函数求导法则， 现在我们利用两个函数乘积的求导法则，来推得另一个求积分的基本方法–分部积分法。</p><p>设$\mu = {\mu}(x)$及$\nu={\nu}(x)$具有连续的导函数，则两个函数乘积的导数公式为：<br>$$({\mu}{\nu})’ = {\mu}’{\nu}+{\mu}{\nu}’$$,<br>移项，得：<br>$${\mu}’{\nu}  = ({\mu}{\nu})’ - {\mu}{\nu}’$$<br>两边求不定积分，得<br>$$\int {\mu}’{\nu}dx  = ({\mu}{\nu}) - \int {\mu}{\nu}’dx$$</p><p>这个公式称为分部积分公式。如果求$\int {\mu}’{\nu}dx$有困难，而求$ \int {\mu}{\nu}’dx$比较容易时，分部积分公式就可以发挥作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点，&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="不定积分" scheme="http://yoursite.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>第二章导数与微分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/导数与微分/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-10-26T02:49:05.262Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点</p><a id="more"></a><h2 id="第一节、导数的概念"><a href="#第一节、导数的概念" class="headerlink" title="第一节、导数的概念"></a>第一节、导数的概念</h2><h3 id="导数的引例"><a href="#导数的引例" class="headerlink" title="导数的引例"></a>导数的引例</h3><ul><li><p>速度问题<br>  $$\nu = \lim_{t \to t_0}\frac{f(t) - f(t_0)}{t-t_0}$$</p><p>  这时就把极限值$\nu$称为质点在时刻$t_0$的<strong>瞬时速度</strong></p></li><li><p>切线问题<br>  $$k = \lim_{t \to x_0}\frac{f(x) - f(x_0)}{x-x_0}$$</p><p>  那么k就是切线的斜率 。下面是切线的示意图：</p><p>  <img src="/wiki/数学知识/高数/导数与微分/12.png" alt="切线示意图"></p></li></ul><p>定义： 设函数y=f(x)在点$x_0$的某个领域内有定义，当自变量x在$x_0$处取得增量$\Delta x$(点$x_0 + \Delta x$ 仍在该领域内)时，相应的，因变量取得增量$\Delta y = f(x_0 + \Delta x) - f(x_0)$；如果 $\Delta y$ 与  $\Delta x$之比（当 $\Delta x \to 0$ 时）的极限存在，那么称函数 y= f(x)在点$x_0$处可导，并称这个极限为函数y=f(x)在点$x_0$处的导数，即为f’($x_0$) ,即</p><p>$$f’(x_0) = \lim_{\Delta x \to 0}{\frac{\Delta y}{\Delta x} } = \lim_{\Delta x \to 0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}, 也可以记作 y’, \frac{dy}{dx} 或\frac{df(x)}{dx}$$</p><p>也可以写作 ：</p><p>$$f’(x_0) = \lim_{h \to 0}{\frac{f(x_0+h)-f(x_0)}{h} }$$<br>或<br>$$f’(x_0)=\lim_{x \to x_0} \frac{f(x)- f(x_0)}{x-x_0}$$</p><p><strong>导数的意义</strong>： 导数的概念就是<strong>函数变化</strong>率这一概念的精确描述。<strong>因变量增量</strong>与<strong>自变量增量</strong>之比$\frac{\Delta y}{\Delta x}$ 是因变量y再以$x_0$和$x_0+\Delta x$为端点的区间上的平均变化率，而导数$f’(x_0)$则是因变量y在点$x_0$处的变化率。<strong>他反应了因变量随自变量的变化而变化的快慢程度。</strong></p><p><strong>下面是求导的示例：</strong></p><ul><li><p><strong>常数的导数</strong>： $C’ = 0$  ， 常数的导数为0</p></li><li><p><strong>幂函数的导数</strong> ：<br>$<br>(x^n)’=<br>\begin{cases}<br>0, &amp; \text{n=1} \\<br>n x^{n-1}, &amp; n&gt;1<br>\end{cases}<br>$</p></li><li><p><strong>sinx的导数</strong> $(\sin x)’=\cos x$、 $(\cos x)’ = - \sin x$</p></li><li><p><strong>指数函数的导数</strong>： $(a^x)’ = \lim_{h \to 0} {\frac{ {\alpha}^{x+h} - {\alpha}^x}{h} } = {\alpha}^x \lim_{h \to 0} \frac{ {\alpha}^h - 1}{h} = a^{x} \ln{a} $</p></li><li><p><strong>对数函数的导数</strong>：$(\log_ x)’ = \frac{1}{x \ln a}$<br>$\begin{equation} \begin{split}<br>f’(x)&amp;=\lim_{h \to 0} \frac{\log_{\alpha}{(x+h)} - \log_{\alpha}{x} }{h}\\<br>&amp;=\lim_{h \to 0}{\frac{1}{h} } \log_{\alpha}{\frac{x+h}{x} } = \lim_{h \to 0}{\frac{1}{x} } \cdot \frac{x}{h} \log_{\alpha}{(1+\frac{h}{x})}\\<br>&amp;=\frac{1}{x} \lim_{h \to 0}{\frac{\log_{\alpha}{(1+\frac{h}{x})} }{\frac{h}{x} } }\\<br>&amp;=\frac{1}{x \cdot \ln{\alpha} }<br>\end{split}\end{equation}$</p></li></ul><p><strong>导数的几何意义</strong>：函数y=f(x)在$x_0$处的导数表示曲线y=f(x）在点M处的切线的斜率。</p><ol><li>切线方程： $y-y_0 = f’(x_0)(x-x_0)$</li><li>法线方程： $y-y_0 = - \frac{1}{f’(x_0)}(x-x_0)$ </li></ol><p><img src="/wiki/数学知识/高数/导数与微分/13.png" alt="切线示意图"></p><p>函数的可导性和可连续性的关系：</p><ol><li>如果y=f(x)在点x处可导，那么函数在该点x处必连续。 $\frac{\Delta y}{\Delta y} = f’(x)+\alpha \Rightarrow \Delta y = f’(x) \Delta x +\alpha \Delta x$</li><li>连续不一定可导</li></ol><h2 id="第二节、函数的求导法则"><a href="#第二节、函数的求导法则" class="headerlink" title="第二节、函数的求导法则"></a>第二节、函数的求导法则</h2><p>一、 函数的和、差、积、商的求导法则</p><p><strong>定理1</strong> 如果函数$\mu$=$\mu(x)$及$\nu(x)$=$\nu(x)$都在点x具有导数，那么它们的和、差、积、商（除分母为零的点外）都在点x具有导数，且 </p><ol><li>[ $\mu(x)$ + $\nu(x)]’ = \mu(x)’ + \nu(x)’ $</li><li>$[\mu(x)\nu(x)]’ = \mu(x)’\nu(x) + \mu(x)\nu(x)’$</li><li>$[\frac{\mu(x)}{\nu(x)}]’ = \frac{\mu(x)’\nu(x)- \mu(x)\nu(x)’}{\nu^2(x)}$ 其中$\nu(x)$!=0</li></ol><p><strong>定理2（反函数求导法则）</strong>:如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：<br>$$[f^{-1}(x)]’ = \frac{1}{f’(y)}或 \frac{dy}{dx}=\frac{1}{\frac{dx}{dy} }$$ </p><blockquote><p>简单的说：反函数的导数等于直接函数导数的倒数。</p></blockquote><p><strong>示例：</strong></p><p>设x = sin y 为直接函数，则 y = arcsin x 是它的反函数。计算过程如下：</p><p>$<br>\begin{equation}\begin{split}<br>(arcsin x)’&amp; =\frac{1}{(sin y)’} = \frac{1}{cos y}\\<br>&amp;又:cos y = \sqrt {1- sin^2y} = \sqrt{1-x^2}\\<br>&amp;所以:(arcsin x)’ = \frac{1}{\sqrt{1- x^2} }\\<br>\end{split}\end{equation}<br>$<br>​    </p><p><strong>定理3（复合函数求导法则</strong>）如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：<br>$$\frac{dy}{dx}=f’(u) \cdot g’(x) 或 \frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$$</p><h2 id="第二节求导法则总结"><a href="#第二节求导法则总结" class="headerlink" title="第二节求导法则总结"></a>第二节求导法则总结</h2><p>一、 导数公式和基本求导法则 </p><table><thead><tr><th style="text-align:left">常用导数公式</th><th style="text-align:left">常用导数公式</th></tr></thead><tbody><tr><td style="text-align:left">(1). $(C)’ = 0 $</td><td style="text-align:left">(2). $(x^{\mu})’ = {\mu}x^{\mu -1} \text {幂函数}$</td></tr><tr><td style="text-align:left">(3). $(\sin x)’ = \cos x $</td><td style="text-align:left">(4). $(\cos x)’ = - \sin x $</td></tr><tr><td style="text-align:left">(5). $(\tan x)’ = \sec^{2} x $</td><td style="text-align:left">(6). $(\cot x)’ = - \csc^{2} x $</td></tr><tr><td style="text-align:left">(7). $(\sec x)’ = \sec{x} \tan{x} $</td><td style="text-align:left">(8). $(\csc x)’ = - \csc{x} \cot{x} $</td></tr><tr><td style="text-align:left">(9). $({\alpha}^x)’ = {\alpha}^x \ln{\alpha} $</td><td style="text-align:left">(10). $({e}^x)’ = e^x  $</td></tr><tr><td style="text-align:left">(11). $(\log_{\alpha}{x})’ = \frac{1}{x \ln{\alpha} } $</td><td style="text-align:left">(12). $(\ln{x})’ = \frac{1}{x } $</td></tr><tr><td style="text-align:left">(13). $(\arcsin x)’ = \frac{1}{\sqrt{1-x^2} } $</td><td style="text-align:left">(14). $(\arccos x)’ = - \frac{1}{\sqrt{1-x^2} } $</td></tr><tr><td style="text-align:left">(15). $(\arctan x)’ =  \frac{1}{1 + x^2} $</td><td style="text-align:left">(16). $(arccot x)’ = - \frac{1}{1 + x^2} $</td></tr></tbody></table><p>二、 函数的和、差、积、商的求导法则</p><p>设$\mu = \mu (x)$，$\nu = \nu (x)$ 都可导，则</p><table><thead><tr><th style="text-align:left">函数的和、差、积、商的求导法则</th><th style="text-align:left">函数的和、差、积、商的求导法则</th></tr></thead><tbody><tr><td style="text-align:left">(1). $ (\mu + \nu)’ = {\mu}’ + {\nu}’ $</td><td style="text-align:left">(2). $ (C \mu)’ = C{\mu}’ $</td></tr><tr><td style="text-align:left">(3). $ (\mu \nu)’ = {\mu}’ \nu + \mu {\nu}’ $</td><td style="text-align:left">(4). $ (\frac{\mu}{\nu})’ = \frac{ {\mu}’ \nu + \mu {\nu}’} { {\nu}^2} $</td></tr></tbody></table><p>三、 反函数求导法则 </p><p>如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：<br>$$[f^{-1}(x)]’ = \frac{1}{f’(y)}或 \frac{dy}{dx}=\frac{1}{\frac{dx}{dy} }$$ </p><p>四、 复合函数求导法则  </p><p>如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：<br>$$\frac{dy}{dx}=f’(u) \cdot g’(x) 或 \frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$$</p><h2 id="第三节、高阶导数"><a href="#第三节、高阶导数" class="headerlink" title="第三节、高阶导数"></a>第三节、高阶导数</h2><p>没有学习</p><h2 id="第五节、函数的微分"><a href="#第五节、函数的微分" class="headerlink" title="第五节、函数的微分"></a>第五节、函数的微分</h2><p>定义： 设函数 y= f(x)在某区间内有定义，$x_0$及$x_0 + \Delta x$在这区间内，如果函数的增量：</p><p>$$\Delta y = f(x_0 + \Delta x) - f(x_0)$$</p><p>可表示为：</p><p>$$\Delta y = A \Delta x + o(\Delta x)$$</p><p>其中A是不依赖于$\Delta x$的常数，那么称函数 y = f(x)在点 $x_0$处是可微的，而$A \Delta x$叫做函数 y = f(x)在点$x_0$相应于自变量增量$\Delta x$的微分，记作 dy 即</p><p>$$dy = A \Delta x$$</p><p>$$dy = f’(x_)) \Delta x$$</p><blockquote><p>微分的理解：相对于自变量的增量，因变量的变化，这个变化时微小的，理解为微分。</p></blockquote><p>微分和$\Delta y$的关系：<br>$$ \Delta y = dy + o(dy) $$</p><p><strong>微分可以近视代替因变量的增量 。微分是 $\Delta y$的主部。</strong></p><p>通常把自变量x的增量$\Delta x$称为自变量微分（微小的数），记作dx，于是函数y=f(x)的微分又可记作<br>$$dy = f’(x)dx$$</p><p><strong>微分的几何意义</strong>： dy 是曲线的切线上点的众坐标的相应增量。非线性函数的局部线性化。</p><p><img src="/wiki/数学知识/高数/导数与微分/14.png" alt="微分的几何意义"></p><p>从图中可以看出，dy = QP。当$\Delta y$是曲线y = f（x） 上的点的众坐标的增量， dy是曲线的切线上点的众坐标的相应的增量。当$\Delta x$很小时，$\Delta y - dy$比 $\Delta x$小的多，因此在点M的邻近，我们可以使用切线段来近视代替曲线段。 这就是<strong>非线性函数的局部线性化</strong>。</p><h2 id="微分公式总结"><a href="#微分公式总结" class="headerlink" title="微分公式总结"></a>微分公式总结</h2><p>暂无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第一章 函数与极限</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/函数与极限/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-10-23T06:23:22.129Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录《函数与极限》章节中，比较重要的内容，以便以后复习。</p><a id="more"></a><h2 id="第二节-数列的极限"><a href="#第二节-数列的极限" class="headerlink" title="第二节 数列的极限"></a>第二节 数列的极限</h2><p><strong>定义</strong>： 设{$x_n$}为一数列，如果存在常数a，对于任意给定的正数$\epsilon$ (不论它多么小)，总存在正整数N，使得，当n&gt;N时，不等式<br>$$|x_n-a|&lt;\epsilon$$<br>都成立，那么就称常数a是数列{$x_n$}的<strong>极限</strong>，或者称数列{$x_n$}<strong>收敛</strong>于a，记为：<br>$$\lim \limits_{n \to \infty} {x_n} = a$$</p><p>如果不存在这样的常数a，就说数列没有极限，或者说数列是<strong>发散</strong>的。</p><blockquote><p>等式中的绝对值表达了两数之差，说明$x_n$无限趋近a含义,也就是两项非常的接近。</p></blockquote><p><strong>收敛数列的性质 </strong></p><p><strong>定理一（极限的唯一性）</strong> 如果数列{$x_n$}收敛，那么他的极限唯一</p><p><strong>定理二（收敛数列的有界性）</strong>如果数列{$x_n$}收敛，那么数列{$x_n$}一定有界。</p><p><strong>定理三（收敛数列的保号性）</strong>如果$\lim \limits_{n \to \infty} {x_n} = a$，且a&gt;0，那么存在正整数N，当n&gt;N时，都有$x_n$&gt;0</p><p><strong>定理四（收敛数列与其子数列间的关系）</strong>如果数列{$x_n$}收敛于a，那么他的任一子数列也收敛，且极限也是a。</p><h2 id="第三节-函数的极限"><a href="#第三节-函数的极限" class="headerlink" title="第三节 函数的极限"></a>第三节 函数的极限</h2><p>讨论函数极限时，自变量变化的情形有两种情况：</p><ol><li>自变量x任意的接近于有限值$x_0$ ，$x \to x_0$</li><li>自变量x的绝对值无限大，$x \to \infty$</li></ol><p><strong>函数极限定义1</strong> 设函数f(x)在点$x_0$的去心领域内有定义，如果存在常数A，对于任意给定的正数$\epsilon$(不论多么小)，总存在正数$\delta$,使得当x满足不等式0&lt;|x-$x_0$|&lt;$\delta$时，对应的函数值f(x)都满足不等式<br>$$|f(x)-A|&lt;\epsilon$$<br>那么常数A就叫做函数f(x)当x-&gt;$x_0$时的极限记作：<br>$$\lim_{x-&gt;x_0}f(x)=A$$</p><blockquote><p>函数极限的定义就是规定了定义域，得出值域的满足的条件 。</p></blockquote><p>函数极限的性质：</p><ol><li>极限的唯一性</li><li>局部有界性  </li><li>局部保号性</li><li>函数极限和数列极限的关系（函数有极限，数列也有极限）</li></ol><h2 id="第四节-无穷小和无穷大"><a href="#第四节-无穷小和无穷大" class="headerlink" title="第四节 无穷小和无穷大"></a>第四节 无穷小和无穷大</h2><p><strong>定义</strong>： 极限为零，那么称函数为当x-&gt;$x_0$时的无穷小</p><p>下面的定理说明无穷小与函数极限的关系：</p><p><strong>定理1</strong> ： 在自变量的同一变化过程$x-&gt;x_0$中，函数f(x)具有极限的充分必要条件是f(x) = A + $\alpha$,其中 $\alpha$是无穷小。</p><p>下面是无穷大和无穷小的关系：</p><p><strong>定理2</strong>： 在自变量的同一变化过程中，如果f(x)为无穷大，那么$\frac{1}{f(x)}$为无穷小，如果f(x)为无穷小，且f(x)!=0 .那么$\frac{1}{f(x)}$为无穷大。</p><blockquote><ol><li>充分性：由条件推断出命题成立。</li><li>必要性： 由命题成立推断出条件的成立。</li></ol></blockquote><h2 id="第五节极限运算法则"><a href="#第五节极限运算法则" class="headerlink" title="第五节极限运算法则"></a>第五节极限运算法则</h2><p><strong>定理1</strong> 两个无穷小的和是无穷小</p><p><strong>定理2</strong> 有界函数与无穷小的乘积是无穷小</p><p><strong>推论1</strong> 常数与无穷小的乘积是无穷小</p><p><strong>推论2</strong> 有限个无穷小的乘积是无穷小</p><p><strong>定理3</strong> 当$x \to x_0 （或 x \to \infty）$ 如果limf(x)=A,limg(x)=B,那么</p><ol><li>lim[f(x)+g(x)]=limf(x)+limg(x)=A+B</li><li>lim[f(x)g(x)]=limf(x)limg(x)=AB</li><li>lim$\frac{f(x)}{g(x)}$=$\frac{limf(x)}{limg(x)}=\frac{A}{B}$，其中B不等于0</li></ol><p><strong>定理4</strong> 数列和函数有类似定理3的性质</p><p><strong>定理5</strong> $\upsilon(x)&gt;=\psi$(x),而lim$\upsilon(x)$=A,lim$\psi(x)$=B,那么A&gt;=B</p><blockquote><p>注意： 求极限时，如果分母为0，需要化为不为0</p></blockquote><p><strong>定理6</strong> 复合函数的极限运算法则，设函数y=f[g(x)]是由函数u=g(x)与函数y=f(u)复合而成，f[g(x)]在点$x_0$的某个去心领域内有定义，$\lim \limits_{x \to x_0}{g(x)}=u_0$ , $\lim \limits_{u \to u_0} {f(u)}=A$,且存在$\delta_0&gt;0$，当x属于（$x_0,\delta_0$）时，有g(x)!=$u_0$,则<br>$$\lim \limits_{x \to x_0} {f[g(x)]} = \lim \limits_{u \to u_0} {f(u)}=A $$</p><h2 id="第六节-极限存在准则、两个重要极限"><a href="#第六节-极限存在准则、两个重要极限" class="headerlink" title="第六节 极限存在准则、两个重要极限"></a>第六节 极限存在准则、两个重要极限</h2><p><strong>准则1</strong> ，如果数列{$x_n$}、{$y_n$}、{$z_n$}满足下面条件：</p><p>$$y_n&lt;=x_n&lt;=$z_n$$</p><p>且$\lim_ \limits{n-&gt;\infty}y_n=a,\lim_ \limits{n-&gt;\infty}z_n=a$</p><p>那么数列{$x_n$}的极限存在，且$\lim \limits_{n-&gt;\infty}x_n=a$</p><p>这个准则称为<strong>夹逼准则</strong>。</p><p><strong>使用夹逼准则计算第一个重要的极限</strong>: $\lim_{x \to 0}{\frac{\sin x}{x} }=1$</p><p><strong>准则2 单调有界必有极限。</strong></p><p>一对重要的极限公式：$$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e$$</p><p>$$\lim \limits_{n-&gt;\infty}(1-\frac{1}{n})^n= \frac{1}{e}$$</p><p><strong>柯西极限存在准则</strong>  数列{$x_n$} 收敛的充分必要条件是：对于任意给定的正数$\epsilon$,存在正整数N，使得m&gt;N, n&gt;N时，有：</p><p>$$|x_n-x_m|&lt;\epsilon$$</p><p>上面公式说明两项的差趋于无穷小。</p><h2 id="第七节：无穷小的比较"><a href="#第七节：无穷小的比较" class="headerlink" title="第七节：无穷小的比较"></a>第七节：无穷小的比较</h2><p>上面的章节说明两个无穷小的和、差、商仍旧是无穷小，但是两个无穷小的商，确出现不同的结果。</p><p>无穷小定义： 如果函数f(x)当$x \to x_0 （或 x \to \infty）$时极限为零，那么称函数f(x)为当$x \to x_0 （或 x \to \infty）$时的无穷小。</p><p>定理1 在自变量的同一变化过程$x \to x_0 （或 x \to \infty）$中，函数f(x)具有极限A的充分必要条件是f(x)=A+a,其中a是无穷小。</p><p>定义(<strong>更小的阶数更高</strong>) ：</p><ol><li>如果$lim \frac{\beta}{\alpha}$ = 0，那么就说$\beta$是比$\alpha$高阶的无穷小，记作$\beta$=o($\alpha$)</li><li>如果$lim \frac{\beta}{\alpha}$ = $\infty$，那么就说$\beta$是比$\alpha$低阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = c，那么就说$\beta$,$\alpha$同阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha^k}$ =c，那么就说$\beta$是$\alpha$的k阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = 1，那么就说$\beta$、$\alpha$时等阶无穷小 记作$\alpha \sim \beta$</li></ol><h2 id="第八节-函数的连续性和间断性"><a href="#第八节-函数的连续性和间断性" class="headerlink" title="第八节 函数的连续性和间断性"></a>第八节 函数的连续性和间断性</h2><p>定义： 设函数y=f(x)在点$x_0$的某一领域内有定义，如果：</p><p>$$\lim \limits_{\bigtriangleup x \to 0}\bigtriangleup y = \lim_{\Delta x \to 0}{[f(x_{x0})]}0$$</p><p>那么就称函数y=f(x)在点$x_0$连续。</p><p>下面是连续性定义中增量的示意图：<br><img src="/wiki/数学知识/高数/函数与极限/1.png" alt="增量示意图"></p><p>连续性的也可以描述为：</p><p>设函数y=f(x)在点$x_0$的某一领域内有定义，如果<br>$$lim_{x \to x_0} {f(x)} = f(x_0)$$<br>那么就称函数f(x)在点$x_0$连续。</p><p>函数的间断点：</p><p>设函数f(x)在点$x_0$的某个去心领域内有定义，在此前提下，如果函数f(x)有下列三种情形之一：</p><ol><li>在$x=x_0$没有定义</li><li>虽在$x=x_0$有定义，但$\lim_{x \to x_0}{f(x)}$不存在</li><li>虽在$x=x_0$有定义，且$\lim_{x \to x_0}{f(x)}$存在，但是不等于$f(x_0)$</li></ol><p>那么函数f(x)在点$x_0$w为不连续，且点$x_0$称为函数f(x)的<strong>不连续点</strong>或<strong>间断点</strong>。</p><h2 id="第九节-连续函数的运算与初等函数的连续性"><a href="#第九节-连续函数的运算与初等函数的连续性" class="headerlink" title="第九节 连续函数的运算与初等函数的连续性"></a>第九节 连续函数的运算与初等函数的连续性</h2><p>一. 连续函数的和、差、积、商的连续性 </p><p>连续函数的和、差、积、商的连续性  连续函数的和、差、积、商（分母不为0）是连续的</p><p>二 反函数和复合函数的连续性 </p><p><strong>定理二</strong> 如果函数f(x) 是单调增加且连续，那么反函数也单调增加且连续</p><p><strong>定理三</strong> 复合函数的两个函数连续，复合后也连续。</p><p>三 初等函数的连续性</p><p><strong>定理四</strong> 所有初等函数都是连续的。</p><p>一组重要的公式</p><ul><li>$\lim_{x \to 0}{\frac{\log_\alpha{(1+x)} }{x{ { = \lim_{x \to 0}{\log_{\alpha}{(1+x)}^{\frac{1}{x} }} = \log_{\alpha}e = \frac{1}{\ln{\alpha} }$ </li><li><p>$\lim_{x \to 0}{\frac{\alpha^x - 1}{x} }$  </p><p> 令 $\alpha^x - 1 = t$，则 $x=\log_{\alpha}{(1+t)}$,当x $\to$0， t $\to$0， 于是：</p><p> $\lim_{x \to 0}{\frac{\alpha^x - 1}{x} }$   = $\lim_{t \to 0}{\frac{t}{\log_{\alpha}{(1+t)} }} = \log_{\alpha}{e} = \frac{1}{\ln{\alpha} }$</p></li><li><p>$\lim_{x \to 0}{\frac{(1+x)^{\alpha}-1}{x} } = \alpha$</p></li></ul><h2 id="第十节-闭区间上连续函数的性质"><a href="#第十节-闭区间上连续函数的性质" class="headerlink" title="第十节 闭区间上连续函数的性质"></a>第十节 闭区间上连续函数的性质</h2><p><strong>定理1</strong> 有界性与最大值最小值定理，在闭区间上连续的函数在该区间上有界，且一定能取得他的最大值和最小值。</p><p><strong>零点定理</strong>： 设函数f(x)在闭区间【a,b】上连续，且f(a)与f(b)异号，则在开区间(a,b)内至少有一点$\epsilon$， 使 $$f(\epsilon) = 0$$</p><p><strong>定理2（介值定理）</strong> 设函数f(x)在闭区间【a,b】上连续，且在这区间的端点取不同的函数值，$$f(a)=A,f(b)=B$$<br>则对于A于B之间的任意一个数C，在开区间（a,b）内至少有一点$\epsilon$,使得</p><p>$$f(\epsilon) = C $$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><ol><li>$x^2-9=(x+3)(x-3)$</li><li>$1+\frac{1}{2}+\frac{1}{2^2}+…+\frac{1}{2^{n-1} }=\frac{1-\frac{1}{2^n} }{1-\frac{1}{2} }$</li><li>二项式定理 $(x+y)^n = \binom {n}{0}x^ny^0 + \binom {n}{1}x^{n-1}y^1 +\binom {n}{2}x^{n-2}y^2 + …+ \binom {n}{n-1}x^1y^{n-1} + \binom {n}{n}x^0y^n$,其中$\binom {n}{k}$为二项系数，等于$\frac{n!}{k!(n-k)!}$.</li><li>$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e=2.718281$ （二项式展开可证明）</li><li>$\lim \limits_{x \to \infty}(1-\frac{1}{x})^x = \frac{1}{e}$ </li><li>$\lim_{x \to 0} {\frac{\log_a(1+x)}{x} }=\frac{1}{\ln a}$  （将 $\frac{1}{x}提到指数位置，$利用公式4、换底公式 可以证明）</li><li>$\lim \limits_{x \to 0}{\frac{a^x -1}{x} } = \ln a$     (替换 $a^x -1 =t $，利用公式5可证明)</li><li>$\lim \limits_{x \to 0}{\frac{(1+x)^a -1 }{x} } = a$</li><li>$\ln{(1+x)} \sim x (x \to 0)$(等价无穷小)</li><li>$e^x-1 \sim x  (x \to 0)$(等价无穷小)</li><li>$(1+x)^a-1 \sim ax  (x \to 0)$ (等价无穷小)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录《函数与极限》章节中，比较重要的内容，以便以后复习。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章 随机变量及其分布</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"/>
    <id>http://yoursite.com/wiki/数学知识/概率论和数理统计/第二章 随机变量及其分布/</id>
    <published>2019-08-22T02:07:12.000Z</published>
    <updated>2019-08-22T07:52:53.715Z</updated>
    
    <content type="html"><![CDATA[<p>第二章学习记录。</p><a id="more"></a><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>定义： 设随机实验的样本空间为S={e},X=X(e)是定义在样本空间S上的实值单值函数，成X=X(e)为随机变量。</p><h2 id="离散型随机变量及其分布规律"><a href="#离散型随机变量及其分布规律" class="headerlink" title="离散型随机变量及其分布规律"></a>离散型随机变量及其分布规律</h2><p>有些随机变量，它全部可能取到的值是有限个或可列无限多个，这种随机变量称为离散型随机变量。</p><p>设离散型随机变量X多有可能的取值为$x_k$(k=1,2,…),X取各个可能值的概率，即事件{X=$x_k$}的概率，为<br>$$P\{X=x_k\} = p_k,k=1,2,….$$</p><h3 id="0-1分布"><a href="#0-1分布" class="headerlink" title="0-1分布"></a>0-1分布</h3><p>设随机变量X只可能取0与1两个值，它的分布律是：<br>$$P\{X=k\}=p^k(1-p)^{(1-k)}. k=0,1 (0&lt;p&lt;1)$$<br>则称X服从以p为参数的0-1分布或两点分布。</p><h3 id="伯努利实验、二项分布"><a href="#伯努利实验、二项分布" class="headerlink" title="伯努利实验、二项分布"></a>伯努利实验、二项分布</h3><p>设实验E只有两种可能，A 即 $\overline A$,则称E为伯努利实验，此时P(A)= p,$P(\overline A)=1-p$,将E独立重复的进行n次，则称这一串重复的独立实验为n重伯努利实验。</p><p>以X表示n重伯努利实验中事件A发生的次数，X是一个随机变量，我们求它的分布规律。X所有可能的取值为 0，1，2，…,n 。由于各次实验是相互独立的，因此事件A在指定的k次实验中发生，在其他n-k次实验中A不发生的概率为</p><p>$$pppp….pp(1-p)(1-p)….(1-p)=p^k(1-p)^{n-k}$$</p><p>这种指定的方式共有$\binom {n}{k}$种，他们是两两互不相容的，故在n次实验中A发生k次的概率为$\binom {n}{k}p^k(1-p)^{n-k}$,记q = 1-p，即有：</p><p>$$P\{X=k\}=\binom{n}{k}p^kq^{n-k},k=0,1,2,…,n\tag{2.6}$$</p><p>显然：</p><p>$$\sum_{k=0}^{n}P\{X=k\}=\sum_{k=0}^{n}\binom{n}{k}p^kq^{n-k}=(p+q)^n=1$$</p><p>注意到$\binom{n}{k}p^kq^{n-k}$刚好是二项式$(p+q)^n$的展开式中出现$p^k$的那一项，我们称随机变量X服从参数n，p的二项分布，并记为$X\sim b(n,p)$</p><p>特别的，当n=1时，二项分布化为：</p><p>$$P\{X=k\}=p^kq^{1-k},k=0,1$$</p><p>就是0-1分布。</p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>设随机变量X所有可能的取值为0，1，2…，取而代之的概率为：<br>$$P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,2….$$<br>其中$\lambda$&gt;0是常数，则称X服从参数为$\lambda$的泊松分布，记为X$\sim\pi(\lambda)$</p><p><strong>泊松定理</strong>：设$\lambda$&gt;0是一个常数，n是任意正整数，设$np_n=\lambda$，则对于人一个固定的非负整数k，有：</p><p>$$\lim_{n\to \infty}\binom{n}{k}p_n^k(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}$$</p><h2 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h2><p><strong>分布函数</strong>：设X是一个随机变量，x是任意实数，函数：</p><p>$$F(x)=P{X&lt;=x}$$<br>称为X的分布函数。</p><p>如果将X看成是数轴上的随机点左边，那么，分布函数F（x）在x出的函数值就表示X落在区间$(-\infty,x)$上的概率。</p><p>分布函数F（x）满足的基本性质：</p><ol><li>不减函数</li><li>0-1</li></ol><h2 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h2><p>如果对于随机变量X的分布函数F(x)，存在非负函数f(x),对于任意实数x有</p><p>$$F(x)=\int_{-\infty}^xf(t)dt\tag{4.1}$$<br>则称x为连续型随机变量，其中函数f(x)称为X的<strong>概率密度函数</strong>，简称<strong>概率密度</strong></p><p>三种重要的连续型随机变量</p><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><ol><li>指数分布</li><li>正态分布</li></ol><h2 id="随机变量的函数分布"><a href="#随机变量的函数分布" class="headerlink" title="随机变量的函数分布"></a>随机变量的函数分布</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="概率论和数理统计" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Choosing a Specific Interface Style for Your iOS App（选择明确的界面样式）</title>
    <link href="http://yoursite.com/wiki/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/%E9%80%89%E6%8B%A9%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS/黑夜模式/选择明确的样式/</id>
    <published>2019-08-19T02:07:12.000Z</published>
    <updated>2019-08-19T03:17:22.005Z</updated>
    
    <content type="html"><![CDATA[<p>Adopt a specific interface style for your views, view controllers, or app when it is inappropriate to support both light and dark variants.</p><p>当你的APP不适合light、dark模式时，为你的view，controller选择一个明确的样式。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>系统假设在ios13或者以后， app默认支持light、dark样式。在IOS中，你可以为window、view、controller指定明确的样式。也可以在plist中静止黑夜模式。</p><h2 id="Override-the-Interface-Style-for-a-Window-View-or-View-Controller重写界面样式"><a href="#Override-the-Interface-Style-for-a-Window-View-or-View-Controller重写界面样式" class="headerlink" title="Override the Interface Style for a Window, View, or View Controller重写界面样式"></a>Override the Interface Style for a Window, View, or View Controller重写界面样式</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always adopt a light interface style.    </span></span><br><span class="line">    overrideUserInterfaceStyle = .light</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Override-the-Interface-Style-for-Child-View-Controllers重写子控制器的样式"><a href="#Override-the-Interface-Style-for-Child-View-Controllers重写子控制器的样式" class="headerlink" title="Override the Interface Style for Child View Controllers重写子控制器的样式"></a>Override the Interface Style for Child View Controllers重写子控制器的样式</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var overrideTraitCollection: UITraitCollection? &#123; <span class="builtin-name">get</span> <span class="builtin-name">set</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Opt-Out-of-Dark-Mode-Entirely-全部退出黑夜模式"><a href="#Opt-Out-of-Dark-Mode-Entirely-全部退出黑夜模式" class="headerlink" title="Opt Out of Dark Mode Entirely 全部退出黑夜模式"></a>Opt Out of Dark Mode Entirely 全部退出黑夜模式</h2><p>在plist中设置 UIUserInterfaceStyle的值为Light。</p><blockquote><p>Supporting Dark Mode is strongly encouraged. Use the UIUserInterfaceStyle key to opt out only temporarily while you work on improvements to your app’s Dark Mode support.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/documentation/appkit/supporting_dark_mode_in_your_interface/choosing_a_specific_interface_style_for_your_ios_app" rel="external nofollow noopener noreferrer" target="_blank">Choosing a Specific Interface Style for Your iOS App</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Adopt a specific interface style for your views, view controllers, or app when it is inappropriate to support both light and dark variants.&lt;/p&gt;
&lt;p&gt;当你的APP不适合light、dark模式时，为你的view，controller选择一个明确的样式。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="黑夜模式" scheme="http://yoursite.com/categories/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="dark" scheme="http://yoursite.com/tags/dark/"/>
    
  </entry>
  
  <entry>
    <title>Supporting Dark Mode in Your Interface（支持黑夜模式）</title>
    <link href="http://yoursite.com/wiki/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/%E6%94%AF%E6%8C%81%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS/黑夜模式/支持黑夜模式/</id>
    <published>2019-08-19T02:07:12.000Z</published>
    <updated>2019-08-19T03:17:29.905Z</updated>
    
    <content type="html"><![CDATA[<p>Update colors, images, and behaviors so that your app adapts automatically when Dark Mode is active.</p><p>当黑夜模式激活后，更新颜色、图片、行为，使app自动适应黑夜模式。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Standard views and controls automatically update their appearance to match the current interface style，If you already use color and image assets, you can add dark variants without changing your code.</p><p>标准view、controls自动更新界面去匹配当前界面模式。如果你使用了<strong>color and image assets</strong>你可以不修改代码，从而添加黑夜模式的支持。</p><h2 id="Choose-Adaptive-Colors-for-Your-UI-为你的UI选择适合的颜色"><a href="#Choose-Adaptive-Colors-for-Your-UI-为你的UI选择适合的颜色" class="headerlink" title="Choose Adaptive Colors for Your UI 为你的UI选择适合的颜色"></a>Choose Adaptive Colors for Your UI 为你的UI选择适合的颜色</h2><p>There are two ways to create adaptive color objects:</p><ol><li>Choose semantic colors instead of fixed color values. When configuring UI elements, choose colors with names like labelColor. These semantic colors convey the intended use of the color, rather than specific color values. When you use them for their intended purpose, they render with color values appropriate for the current settings. For a complete list of semantic color names, see NSColor and UIColor.</li><li>Define custom colors in your asset catalog. When you need a specific color, create it as a color asset. In your asset, specify different color values for both light and dark appearances. You can also specify high-contrast versions of your colors.</li></ol><ol><li>选择UIColor类中定义的<strong>语义color</strong>,而不是固定的颜色</li><li>将自定义color定义在asset catalog中，指定dark、light中颜色。代码中使用<strong>UIColor(named: “customControlColor”)</strong> 加载颜色。</li></ol><p>定义在asset catalog中的颜色自动适配dark、light模式。模式的变化，不需要重新加载。</p><h2 id="Create-Images-for-All-Appearances"><a href="#Create-Images-for-All-Appearances" class="headerlink" title="Create Images for All Appearances"></a>Create Images for All Appearances</h2><p>If an image is difficult to see when changing appearances, provide a new image asset that looks good in the other appearance.</p><p>提供image asset 支持两种模式。</p><h2 id="Update-Custom-Views-Using-Specific-Methods-使用特定方法更新自定义view。"><a href="#Update-Custom-Views-Using-Specific-Methods-使用特定方法更新自定义view。" class="headerlink" title="Update Custom Views Using Specific Methods 使用特定方法更新自定义view。"></a>Update Custom Views Using Specific Methods 使用特定方法更新自定义view。</h2><p><img src="/wiki/IOS/黑夜模式/支持黑夜模式/1.png" alt=""></p><p>模式敏感的操作全部放在上面的方法里面。如果不在上面的方法里面，可能不能正常响应当前的模式变化。</p><h2 id="Avoid-Expensive-Tasks-During-Appearance-Transitions"><a href="#Avoid-Expensive-Tasks-During-Appearance-Transitions" class="headerlink" title="Avoid Expensive Tasks During Appearance Transitions"></a>Avoid Expensive Tasks During Appearance Transitions</h2><p>避免模式过渡时完成复杂任务。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/documentation/appkit/supporting_dark_mode_in_your_interface" rel="external nofollow noopener noreferrer" target="_blank">Supporting Dark Mode in Your Interface</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Update colors, images, and behaviors so that your app adapts automatically when Dark Mode is active.&lt;/p&gt;
&lt;p&gt;当黑夜模式激活后，更新颜色、图片、行为，使app自动适应黑夜模式。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="黑夜模式" scheme="http://yoursite.com/categories/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="dark" scheme="http://yoursite.com/tags/dark/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基本知识</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/wiki/数学知识/概率论和数理统计/第一章 概率论的基本概念/</id>
    <published>2019-08-13T02:07:12.000Z</published>
    <updated>2019-08-22T02:19:08.698Z</updated>
    
    <content type="html"><![CDATA[<p>随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象</p><a id="more"></a><h2 id="随机实验"><a href="#随机实验" class="headerlink" title="随机实验"></a>随机实验</h2><ol><li>可以在相同的条件下重复地进行</li><li>每次实验的可能结果不止一个，并且能事先明确实验的所有可能结果</li><li>进行一次实验前不能确定哪一个结果会出现 </li></ol><p>我们将具有上面三个特点的实验称为随机实验</p><h2 id="样本空间、-随机事件"><a href="#样本空间、-随机事件" class="headerlink" title="样本空间、 随机事件"></a>样本空间、 随机事件</h2><h3 id="一-样本空间"><a href="#一-样本空间" class="headerlink" title="一 样本空间"></a>一 样本空间</h3><p>我们将随机实验E的所有可能结果组成的集合称为E的<strong>样本空间</strong>。记作S 样本空间的每个结果称为<strong>样本点</strong></p><h3 id="二-随机事件"><a href="#二-随机事件" class="headerlink" title="二 随机事件"></a>二 随机事件</h3><p>一般，我们称实验E的样本空间S的子集为E 的<strong>随机事件</strong>，当且仅当这一子集中的样本点出现时，称这一事件发生。</p><p>由一个样本点组成的单点集，称为<strong>基本事件</strong>  </p><p>每个实验中它总是发生的，S称为<strong>必然事件</strong> 。空集是<strong>不可能事件</strong></p><h3 id="事件间的关系和运算"><a href="#事件间的关系和运算" class="headerlink" title="事件间的关系和运算"></a>事件间的关系和运算</h3><ol><li>若$A\subset{B}$ 事件A发生必然导致事件B发生。</li><li>$A\cup{B}$ 和事件，当且仅当A、B至少有衣蛾发生时，事件A\cup{B}$ 发生</li><li>事件$A\cap{B}$积事件，当且仅当A、B同时发生时，事件$A\cap{B}$发生。</li><li>差事件，A-B 当且仅当A发生，B不发生时，事件A-B发生。</li><li>若$A\cap{B}=\emptyset$ ,则称事件A与时间B互不相容或互斥。事件A、B不能同时发生。</li><li>若$A\cup{B}=s$ 且$A\cap{B}=\emptyset$则称事件A与时间B互为逆事件。或对立事件</li></ol><h2 id="频率和概率"><a href="#频率和概率" class="headerlink" title="频率和概率"></a>频率和概率</h2><p>定义： 在相同条件下，进行n次试验，在这n次试验中，事件A发生的次数称为事件A的频数，比值$n_a/n$称为事件A发生的频率。并记作$f_n（A）$</p><p>概率的性质：</p><ol><li>P($\emptyset$)=0</li><li>有限可加性 ，$若A_1，A_2,… A_n$是两两互不相容的事件，则有P（$A_1\cup{A_2}…\cap{A_n}$） = $P(A_1)+P(A_2)+…+P(A_n)$</li><li>设A、B是两个事件，若$A\subset{B}$,则：$$P(B-A)=P(B)-P(A)$$</li><li>对任一事件A P(A)&lt;=1</li><li>逆事件概率，对于任一事件A有$ P(\overline A) $= 1- P(A)</li><li>加法公式： 对任意两事件 A、B 有，$ P(A\cup B) = P(A)+P(B)-P(AB)$</li></ol><h2 id="等可能概型（古典概型）"><a href="#等可能概型（古典概型）" class="headerlink" title="等可能概型（古典概型）"></a>等可能概型（古典概型）</h2><p>若事件A包含k个基本事件 ，则<br>$$P(A)=\frac {k} {n} = \frac {A包含的基本事件数} {S中基本事件的总数}$$</p><p>$$\left ( \frac {N}{n} \right ) = \frac {N(N-1)…(N-n+1)} {n!} \text N<br>中取n个的总数$$</p><p>$$A_N^n = N(N-1)…(N-n+1) \text 也是N中取n个的总数 $$</p><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>设A，B是两个事件，且P（A） &gt; 0 称 </p><p>$$ P(B|A)=\frac{P(AB)}{P(A)}$$<br>为在事件A发生的条件下，事件B发生的条件概率。</p><p><strong>乘法定理</strong>： $P(AB)=P(B|A)P(A)$</p><p><strong>全概率公式</strong>： 设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，且$P(B_i)$&gt;0,则<br>$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+…+P(A|B_n)P(B_n)$$<br>称为全概率公式。</p><p><strong>个人理解</strong>：A和每个划分的积事件之和。</p><p><strong>贝叶斯公式</strong>：设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，则<br>$$P(B_i|A)=\frac{P(A|B_i)P(B)}{\sum_{j=1}^{n}{P(A|B_j)P(B_j)}}$$<br>称为贝叶斯公式</p><p>当n=2时，全概率公式和贝叶斯公式分别为：</p><p>$$P(A)=P(A|B)P(B)+P(A|\overline B)P(\overline B)$$</p><p>$$P(B|A)=\frac{P(AB)}{P(A)}=\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\overline B)P(\overline B)}$$</p><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><p>定义： 设A，B是两个事件，如果满足等式：<br>$$P(AB)=P(A)P(B)$$<br>则称事件AB是相互独立，简称A，B独立</p><p>定理1： 设A，B是两个事件，若A，B相互独立，则P(B|A) = P(B),反之亦然。</p><p>定理2：如事件A与B相互独立，则下列各事件也相互独立：<br>$$A \text{与} \overline{B} , \overline A 与B，\overline A与\overline B$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="概率论和数理统计" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
</feed>
