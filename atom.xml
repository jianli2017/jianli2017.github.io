<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-02T08:48:01.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cocoapod-private-repo</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-private-repo/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-private-repo/</id>
    <published>2018-03-01T06:50:54.000Z</published>
    <updated>2018-03-02T08:48:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 [Git仓库1]、[Git仓库2]。</p><ol><li><a href="https://github.com/CocoaPods/Specs.git" rel="external nofollow noopener noreferrer" target="_blank">Git仓库1</a>的作用代表CocoaPods的官方spec repo专门存放podspec 具体可以参考:<a href="https://github.com/CocoaPods/Specs" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods官方源</a>、<a href="http://guides.cocoapods.org/making/specs-and-specs-repo.html" rel="external nofollow noopener noreferrer" target="_blank">Specs</a>; </li><li><a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">Git仓库2</a>的是私有库Git版本控制地址。</li></ol><a id="more"></a><h3 id="一、创建私有的Spec-Repo–LJRepo"><a href="#一、创建私有的Spec-Repo–LJRepo" class="headerlink" title="一、创建私有的Spec Repo–LJRepo"></a>一、创建私有的Spec Repo–<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a></h3><p>Spec Repo 是所有的Pods的一个索引，是所有公开的Pods 的podspec 文件的一个仓库，其实就是一个部署在服务器的Git仓库，当你使用CocoaPods 后它会被Clone到本地的 ~/.cocoapods/repos 目录下。</p><p>首先在git上创建一个私有远端仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，步骤如下：</p><ol><li><p>在GitHub上创建私有远端仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>，空的就可以。</p></li><li><p>将远端私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a>添加到cocoapod中，远端私有仓库<a href="https://github.com/jianli2017/LJRepo.git" rel="external nofollow noopener noreferrer" target="_blank">LJRepo</a> 在cocoapod中的别名是MyPrivateRepo， 命令如下：</p></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod repo <span class="keyword">add</span><span class="bash"> <span class="string">'MyPrivateRepo'</span> <span class="string">'git@github.com:jianli2017/LJRepo.git'</span></span></span><br></pre></td></tr></table></figure><p>MyPrivateRepo是CocoaPod中的repo名称，git@github.com:jianli2017/LJRepo.git 是远端私有仓库地址。</p><blockquote><p>注意：这个Git 仓库地址要换成你自己的创建的 Specs git 地址！！！ 成功后会在~/.cocoapods/repos目录下就能看到MyPrivateRepo了，至此，第一步创建私有 Spec Repo就完成了。</p></blockquote><p>创建完成后，查看~/.cocoapods/repos 目录的变化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">cd</span> 到~/.cocoapods/repos 目录</span></span><br><span class="line">cd ~/.cocoapods/repos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看目录结构</span></span><br><span class="line">tree -L 3</span><br></pre></td></tr></table></figure><p>大概的文件目录如下:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── MyPrivateRepo</span><br><span class="line">│   └── LJMenu</span><br><span class="line">│       └── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">└── master</span><br><span class="line">    ├── CocoaPods-version.yml</span><br><span class="line">    ├── README.md</span><br><span class="line">    └── Specs</span><br><span class="line">        ├── <span class="number">0</span></span><br><span class="line">        ├── <span class="number">1</span></span><br><span class="line">        ├── <span class="number">2</span></span><br></pre></td></tr></table></figure><p>其中master就是官方的Sepc Repo,跟master同目录级别的MyPrivateRepo目录就是我自己创建的私有Sepc Repo。</p><p>也可以使用’pod repo list ‘ 命令查看仓库信息，结果如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">master</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  <span class="string">https:</span><span class="comment">//github.com/CocoaPods/Specs.git</span></span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/master</span><br><span class="line"></span><br><span class="line">MyPrivateRepo</span><br><span class="line">- <span class="string">Type:</span> git (master)</span><br><span class="line">- <span class="string">URL:</span>  git<span class="meta">@github</span>.<span class="string">com:</span>jianli2017/LJRepo.git</span><br><span class="line">- <span class="string">Path:</span> <span class="regexp">/Users/</span>lijian<span class="regexp">/.cocoapods/</span>repos/MyPrivateRepo</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> repos</span><br></pre></td></tr></table></figure><p>上面对私有仓库从文件目录和pod命令两个角度去说明私有仓库。</p><h3 id="二、创建Pod项目工程"><a href="#二、创建Pod项目工程" class="headerlink" title="二、创建Pod项目工程"></a>二、创建<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">Pod项目工程</a></h3><p>1.创建Pod项目工程 首先，在Git上创建一个<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">LJMenu项目</a>,当然你也是可以在公司内网创建的。 然后，使用Cocoapods提供的一个<a href="http://guides.cocoapods.org/making/using-pod-lib-create" rel="external nofollow noopener noreferrer" target="_blank">Using Pod Lib Create</a> 工具创建一个工程。</p><p>在Terminal中执行cd进入要创建项目的目录然后 执行以下命令：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pod lib create [项目名]</span></span><br><span class="line">pod <span class="class"><span class="keyword">lib</span> <span class="title">create</span> <span class="title">LJMenu</span></span></span><br></pre></td></tr></table></figure><p>上面的命令会在当前目录创建LJMenu的项目，接着在Terminal控制台会输出：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Cloning `<span class="keyword">https</span>://github.com/CocoaPods/pod-template.git` <span class="keyword">into</span> `LJMenu`.</span><br><span class="line">Configuring LJMenu template.</span><br><span class="line">Ignoring ffi<span class="number">-1.9</span><span class="number">.14</span> because its extensions are <span class="keyword">not</span> built.  Try: gem pristine ffi <span class="comment">--version 1.9.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">------------------------------</span></span><br><span class="line"></span><br><span class="line">To <span class="built_in">get</span> you started we need <span class="built_in">to</span> ask <span class="keyword">a</span> few questions, this should only take <span class="keyword">a</span> minute.</span><br><span class="line"></span><br><span class="line"><span class="number">2018</span><span class="number">-03</span><span class="number">-02</span> <span class="number">13</span>:<span class="number">55</span>:<span class="number">04.386</span> defaults[<span class="number">30912</span>:<span class="number">784564</span>] </span><br><span class="line">The domain/default pair <span class="keyword">of</span> (org.cocoapods.pod-template, HasRunbefore) does <span class="keyword">not</span> exist</span><br><span class="line">If this is your <span class="keyword">first</span> <span class="built_in">time</span> we recommend running through <span class="keyword">with</span> <span class="keyword">the</span> guide: </span><br><span class="line"> - <span class="keyword">http</span>://guides.cocoapods.org/making/<span class="keyword">using</span>-pod-lib-<span class="built_in">create</span>.html</span><br><span class="line"> ( hold cmd <span class="keyword">and</span> double click links <span class="built_in">to</span> <span class="built_in">open</span> <span class="keyword">in</span> <span class="keyword">a</span> browser. )</span><br><span class="line"></span><br><span class="line"> Press <span class="literal">return</span> <span class="built_in">to</span> continue.</span><br></pre></td></tr></table></figure><p>选择回车按钮，接着会出现一系列的问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">What platform <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ iOS / macOS ]</span><br><span class="line"> &gt; ios</span><br><span class="line"></span><br><span class="line">What <span class="keyword">language</span> <span class="keyword">do</span> you want <span class="keyword">to</span> <span class="keyword">use</span>?? [ Swift / ObjC ]</span><br><span class="line"> &gt; objc</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">include</span> a demo application <span class="keyword">with</span> your <span class="keyword">library</span>? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">Which testing frameworks will you <span class="keyword">use</span>? [ Specta / Kiwi / <span class="keyword">None</span> ]</span><br><span class="line"> &gt; specta</span><br><span class="line"></span><br><span class="line">Would you <span class="keyword">like</span> <span class="keyword">to</span> <span class="keyword">do</span> <span class="keyword">view</span> based testing? [ Yes / <span class="keyword">No</span> ]</span><br><span class="line"> &gt; yes</span><br><span class="line"></span><br><span class="line">What <span class="keyword">is</span> your <span class="keyword">class</span> prefix?</span><br><span class="line"> &gt; LJ</span><br></pre></td></tr></table></figure><p>回答完问题后，会创建出LJMenu项目。结构如下：</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── <span class="keyword">Example</span></span><br><span class="line">│   ├── LJMenu</span><br><span class="line">│   ├── LJMenu.xcodeproj</span><br><span class="line">│   ├── LJMenu.xcworkspace</span><br><span class="line">│   ├── Podfile</span><br><span class="line">│   ├── Podfile.lock</span><br><span class="line">│   ├── Pods</span><br><span class="line">│   └── Tests</span><br><span class="line">├── LICENSE</span><br><span class="line">├── LJMenu     **这个是创建的LJMenu项目**</span><br><span class="line">│   ├── Assets</span><br><span class="line">│   └── <span class="keyword">Classes</span></span><br><span class="line">├── LJMenu.podspec  </span><br><span class="line">├── README.md</span><br><span class="line">└── _Pods.xcodeproj -&gt; <span class="keyword">Example</span>/Pods/Pods.xcodeproj</span><br></pre></td></tr></table></figure><p>2、添加实现代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LJMenu</span><br><span class="line">├── Assets</span><br><span class="line">└── Classes</span><br><span class="line">    ├── LJMenu</span><br><span class="line">    │   ├── IFMMenu.h</span><br><span class="line">    │   ├── IFMMenu.m</span><br><span class="line">    │   ├── IFMMenuContainerView.h</span><br><span class="line">    │   ├── IFMMenuContainerView.m</span><br><span class="line">    │   ├── IFMMenuItem.h</span><br><span class="line">    │   ├── IFMMenuItem.m</span><br><span class="line">    │   ├── IFMMenuView.h</span><br><span class="line">    │   └── IFMMenuView.m</span><br><span class="line">    └── ReplaceMe.m</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">9</span> files</span><br></pre></td></tr></table></figure><p>在本教程中我在上面的Classes文件目录添加了 IFMMenu*.[h、m]八个文件。<br>3.开发模式下测试pod库的代码 打开Example工程目录Podfile文件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">#pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../MyLib.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行 pod update命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了 不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/MyLib中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。测试库文件没有问题,接着我们需要执行第4步</p><p>4.提交Pod库到<a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">Git仓库2</a> 在Terminal中执行 cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">'1.0.2'</span></span></span><br><span class="line"><span class="bash">git remote add origin git@github.com:jianli2017/LJMenu.git</span></span><br><span class="line"><span class="bash">git push origin master     <span class="comment">#提交到远端仓库</span></span></span><br><span class="line"><span class="bash">git tag -m <span class="string">"v1.0.2"</span> <span class="string">"v1.0.2"</span> <span class="comment">#打上标签，这个很重要</span></span></span><br><span class="line"><span class="bash">git push --tags     <span class="comment">#推送tag到远端仓库</span></span></span><br></pre></td></tr></table></figure><p>到这里，成功提交到远程 <a href="https://github.com/jianli2017/LJMenu.git" rel="external nofollow noopener noreferrer" target="_blank">Git仓库2</a>，LJMenu Pod 库就初步完成了代码实现</p><h3 id="三、创建并提交LJMenu库的podspec文件到私有Spec-Repo仓库MyPrivateRepo"><a href="#三、创建并提交LJMenu库的podspec文件到私有Spec-Repo仓库MyPrivateRepo" class="headerlink" title="三、创建并提交LJMenu库的podspec文件到私有Spec Repo仓库MyPrivateRepo"></a>三、创建并提交LJMenu库的podspec文件到私有Spec Repo仓库MyPrivateRepo</h3><p>1.配置LJMenu库的podspec 文件</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Be sure to run `pod lib lint LJMenu.podspec' to ensure this is a</span></span><br><span class="line"><span class="comment"># valid spec before submitting.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Any lines starting with a # are optional, but their use is encouraged</span></span><br><span class="line"><span class="comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name             = <span class="string">'LJMenu'</span></span><br><span class="line">  s.version          = <span class="string">'1.0.2'</span></span><br><span class="line">  s.summary          = <span class="string">'A short description of LJMenu.'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This description is used to generate tags and improve search results.</span></span><br><span class="line"><span class="comment">#   * Think: What does it do? Why did you write it? What is the focus?</span></span><br><span class="line"><span class="comment">#   * Try to keep it short, snappy and to the point.</span></span><br><span class="line"><span class="comment">#   * Write the description between the DESC delimiters below.</span></span><br><span class="line"><span class="comment">#   * Finally, don't worry about the indent, CocoaPods strips it!</span></span><br><span class="line"></span><br><span class="line">  s.description      = <span class="string">&lt;&lt;-DESC</span></span><br><span class="line"><span class="string">TODO: Add long description of the pod here.</span></span><br><span class="line"><span class="string">                       DESC</span></span><br><span class="line"></span><br><span class="line">  s.homepage         = <span class="string">'https://github.com/jianli2017/LJMenu'</span></span><br><span class="line">  <span class="comment"># s.screenshots     = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2'</span></span><br><span class="line">  s.license          = &#123; <span class="symbol">:type</span> =&gt; <span class="string">'MIT'</span>, <span class="symbol">:file</span> =&gt; <span class="string">'LICENSE'</span> &#125;</span><br><span class="line">  s.author           = &#123; <span class="string">'jianli2017'</span> =&gt; <span class="string">'lijian-ds1@gomeplus.com'</span> &#125;</span><br><span class="line">  s.source           = &#123; <span class="symbol">:git</span> =&gt; <span class="string">'https://github.com/jianli2017/LJMenu.git'</span>, <span class="symbol">:tag</span> =&gt; <span class="string">'v1.0.2'</span>&#125;</span><br><span class="line">  <span class="comment"># s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;'</span></span><br><span class="line"></span><br><span class="line">  s.ios.deployment_target = <span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">  s.source_files = <span class="string">'LJMenu/Classes/**/*'</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># s.resource_bundles = &#123;</span></span><br><span class="line">  <span class="comment">#   'LJMenu' =&gt; ['LJMenu/Assets/*.png']</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># s.public_header_files = 'Pod/Classes/**/*.h'</span></span><br><span class="line">  <span class="comment"># s.frameworks = 'UIKit', 'MapKit'</span></span><br><span class="line">  <span class="comment"># s.dependency 'AFNetworking', '~&gt; 2.3'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>打开MyLib工程目录下的MyLib.podspec 文件并参考上面的说明配置好相关选项。podspec更多配置请参考:<a href="http://guides.cocoapods.org/syntax/podspec.html" rel="external nofollow noopener noreferrer" target="_blank">官方文档</a></p><p>2.编辑完LJMenu.podspec文件后，需要验证一下这个MyLib.podspec文件是否可用</p><p>在Terminal中执行cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint  <span class="comment">--allow-warnings</span></span><br></pre></td></tr></table></figure><p>当你看到 Terminal 中输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Analyzed <span class="number">1</span> podspec.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">LJMenu.podspec passed validation.</span></span><br></pre></td></tr></table></figure><p>表示这个LJMenu.podspec 验证通过，是一个符合CocoaPods规则的配置文件。</p><p>3.本地测试LJMenu.podspec文件 打开Example工程目录Podfile文件修改下pod 的引用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">path</span> =&gt;</span> <span class="string">'../'</span> # 指定路径</span><br><span class="line">pod <span class="string">'MyLib'</span>, :<span class="function"><span class="params">podspec</span> =&gt;</span> <span class="string">'../LJMenu.podspec'</span>  # 指定podspec文件</span><br></pre></td></tr></table></figure><p>然后在Example工程目录下执行pod update命令安装依赖，打开项目工程，现在可以看到库文件都被加载到Pods子项目中了</p><p>4.向Spec Repo提交podspec 测试库文件没有问题我们就把MyLib.podspec提交到远程Spec Repo仓库中，就是本文开头说的[Git仓库1][13] 在Terminal中执行 cd进入MyLib项目根目录然后，执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pod repo push [Repo名] [podspec 文件名字]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pod repo push MyPrivateRepo ./LJMenu.podspec --allow-warnings</span></span><br></pre></td></tr></table></figure><p>如果提交成功，在Terminal会输出：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Validating spec</span><br><span class="line"> -<span class="ruby">&gt; LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| summary: The summary is <span class="keyword">not</span> meaningful.</span></span></span><br><span class="line"><span class="ruby">    - WARN  <span class="params">| url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Updating the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Already up-to-date.</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Adding the spec to the <span class="string">`MyPrivateRepo' repo</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby"> - [Update] LJMenu (<span class="number">1.0</span>.<span class="number">2</span>)</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">Pushing the <span class="string">`MyPrivateRepo' repo</span></span></span><br></pre></td></tr></table></figure><p>表示提交成功了！这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/MySpecs目录下查看</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~<span class="regexp">/.cocoapods/repos</span><span class="regexp">/</span></span><br><span class="line"><span class="regexp">tree -L 3 MyPrivateRepo/</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyPrivateRepo/</span><br><span class="line">└── LJMenu</span><br><span class="line">    ├── <span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">    │   └── LJMenu.podspec</span><br><span class="line">    └── <span class="number">1.0</span><span class="number">.2</span></span><br><span class="line">        └── LJMenu.podspec</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> directories, <span class="number">2</span> files</span><br></pre></td></tr></table></figure><p>再去看我们的Spec Repo远端仓库 也就是[Git仓库1][14]，也有了一次提交，这个podspec也已经被Push上去了。</p><p>至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了. 在Terminal中执行 pod search MyLib</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-&gt; LJMenu (<span class="number">1.0</span><span class="number">.2</span>)</span><br><span class="line">   A <span class="keyword">short</span> description of LJMenu.</span><br><span class="line">   pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br><span class="line">   - <span class="string">Homepage:</span> <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu</span></span><br><span class="line">   - <span class="string">Source:</span>   <span class="string">https:</span><span class="comment">//github.com/jianli2017/LJMenu.git</span></span><br><span class="line">   - <span class="string">Versions:</span> <span class="number">1.0</span><span class="number">.2</span>, <span class="number">1.0</span><span class="number">.1</span> [MyPrivateRepo repo]</span><br></pre></td></tr></table></figure><h4 id="四、使用制作好的Pod"><a href="#四、使用制作好的Pod" class="headerlink" title="四、使用制作好的Pod"></a>四、使用制作好的Pod</h4><p>在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可, 在正式项目的Podfile 里添加私有Spec Repo</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#私有Spec Repo</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">source</span> <span class="string">'git<span class="variable">@github</span>.com:jianli2017/LJRepo.git'</span> </span><br><span class="line">source <span class="string">'git<span class="variable">@github</span>.com:CocoaPods/Specs.git'</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'LJMenu'</span>, <span class="string">'~&gt; 1.0.2'</span></span><br></pre></td></tr></table></figure><p>然后执行pod update，更新库依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://www.jianshu.com/p/107cc74847ab" rel="external nofollow noopener noreferrer" target="_blank">利用CocoaPods创建私有库</a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 [Git仓库1]、[Git仓库2]。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/CocoaPods/Specs.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git仓库1&lt;/a&gt;的作用代表CocoaPods的官方spec repo专门存放podspec 具体可以参考:&lt;a href=&quot;https://github.com/CocoaPods/Specs&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods官方源&lt;/a&gt;、&lt;a href=&quot;http://guides.cocoapods.org/making/specs-and-specs-repo.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Specs&lt;/a&gt;; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/jianli2017/LJRepo.git&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git仓库2&lt;/a&gt;的是私有库Git版本控制地址。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>图解SSH原理</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/SSH/ssh-theory/"/>
    <id>http://yoursite.com/wiki/工具/SSH/ssh-theory/</id>
    <published>2018-02-27T10:11:35.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于<a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></p><a id="more"></a><h2 id="初见SSH"><a href="#初见SSH" class="headerlink" title="初见SSH"></a>初见SSH</h2><blockquote><p>SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。</p></blockquote><h2 id="SSH工作原理"><a href="#SSH工作原理" class="headerlink" title="SSH工作原理"></a>SSH工作原理</h2><p>在讨论SSH的原理和使用前，我们需要分析一个问题：为什么需要SSH？</p><p>从第一节SSH的定义中可以看出，SSH和telnet、ftp等协议主要的区别在于安全性。这就引出下一个问题：如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种：</p><ol><li><p>对称加密（也称为秘钥加密）</p></li><li><p>非对称加密（也称公钥加密）</p></li></ol><p>所谓对称加密，指加密解密使用同一套秘钥。如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareEncrypt.png" alt="对称加密-Client端"></p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/shareDecrypt.png" alt="对称加密-Server端"></p><p>对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：如何安全的传输密钥、保存秘钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。</p><blockquote><p>两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。</p></blockquote><p>下面看下使用非对称加密方案的登录流程：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicEncrypt.png" alt="非对称加密登录流程"></p><ol><li><p>远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。</p></li><li><p>Client使用这个公钥，将密码进行加密。</p></li><li><p>Client将加密的密码发送给Server端。</p></li><li><p>远程Server用自己的私钥，解密登录密码，然后验证其合法性。</p></li><li><p>若验证结果，给Client相应的响应。</p></li></ol><blockquote><p>私钥是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。</p></blockquote><h4 id="这样就一定安全了吗？"><a href="#这样就一定安全了吗？" class="headerlink" title="这样就一定安全了吗？"></a>这样就一定安全了吗？</h4><p>上述流程会有一个问题：Client端如何保证接受到的公钥就是目标Server端的？，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？这就是所谓的[中间人攻击][2]</p><p><img src="//upload-images.jianshu.io/upload_images/2599999-da9359eb5fe05c32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/623" alt=""></p><p>图1-4：中间人攻击</p><h4 id="SSH中是如何解决这个问题的？"><a href="#SSH中是如何解决这个问题的？" class="headerlink" title="SSH中是如何解决这个问题的？"></a>SSH中是如何解决这个问题的？</h4><h5 id="基于口令的认证"><a href="#基于口令的认证" class="headerlink" title="基于口令的认证"></a>基于口令的认证</h5><p>从上面的描述可以看出，问题就在于如何对Server的公钥进行认证？在https中可以通过CA来进行公证，可是SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'ssh-server.example.com (12.18.429.21)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">98</span>:<span class="number">2</span>e:d7:e0:de:<span class="number">9</span>f:ac:<span class="number">67</span>:<span class="number">28</span>:c2:<span class="number">42</span>:<span class="number">2</span>d:<span class="number">37</span>:<span class="number">16</span>:<span class="number">58</span>:<span class="number">4</span>d.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><blockquote><p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p></blockquote><p>如果输入yes后，会出现下面信息：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">'ssh-server.example.com,12.18.429.21'</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts. </span><br><span class="line">Password: (enter password)</span><br></pre></td></tr></table></figure><p>该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码，之后的流程就按照图1-3进行。</p><h5 id="2-基于公钥认证"><a href="#2-基于公钥认证" class="headerlink" title="2.基于公钥认证"></a>2.基于公钥认证</h5><p>在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/publicKeyAuthentication.png" alt="公钥认证流程"></p><ol><li><p>Client端用户TopGun将自己的公钥存放在Server上，追加在文件authorized_keys中。</p></li><li><p>Server收到登录请求后，随机生成一个字符串str1，并发送给Client。</p></li><li><p>Client用自己的私钥对字符串str1进行加密。</p></li><li><p>将加密后字符串发送给Server。</p></li><li><p>Server用之前存储的公钥进行解密，比较解密后的str2和str1。</p></li><li><p>根据比较结果，返回客户端登陆结果。</p></li></ol><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p></blockquote><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/GitHub-SSHKeys.png" alt="GitHub中SSH keys设置"></p><h2 id="SSH实践"><a href="#SSH实践" class="headerlink" title="SSH实践"></a>SSH实践</h2><h4 id="生成密钥操作"><a href="#生成密钥操作" class="headerlink" title="生成密钥操作"></a>生成密钥操作</h4><p>经过上面的原理分析，下面三行命令的含义应该很容易理解了：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -P <span class="string">''</span> -f ~<span class="regexp">/.ssh/id</span>_rsa</span><br><span class="line">$ cat ~<span class="regexp">/.ssh/id</span>_rsa.pub <span class="meta">&gt;&gt; </span>~<span class="regexp">/.ssh/authorized</span>_keys</span><br><span class="line">$ chmod <span class="number">0600</span> ~<span class="regexp">/.ssh/authorized</span>_keys</span><br></pre></td></tr></table></figure><p>ssh-keygen是用于生产密钥的工具。</p><ul><li><p>-t：指定生成密钥类型（rsa、dsa、ecdsa等）</p></li><li><p>-P：指定passphrase，用于确保私钥的安全</p></li><li><p>-f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）</p></li></ul><p>首先看下面~/.ssh中的四个文件：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/SHH-config.png" alt="SSH-涉及文件"></p><ol><li><p>id_rsa：保存私钥</p></li><li><p>id_rsa.pub：保存公钥</p></li><li><p>authorized_keys：保存已授权的客户端公钥</p></li><li><p>known_hosts：保存已认证的远程主机公钥</p></li></ol><p>四个角色的关系如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/ssh/theory/ssh-struct.png" alt="SSH 结构简图"></p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h6 id="登录操作"><a href="#登录操作" class="headerlink" title="登录操作"></a>登录操作</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以用户名user，登录远程主机host</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh user@host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地用户和远程用户相同，则用户名可省去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh host</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> SSH默认端口22，可以用参数p修改端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh -p 2017 user@host</span></span><br></pre></td></tr></table></figure><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>本文以图文方式对SSH原理进行解析（主要指远程登录，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/33461b619d53" rel="external nofollow noopener noreferrer" target="_blank">图解SSH原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于&lt;a href=&quot;https://www.jianshu.com/p/33461b619d53&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;图解SSH原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="SSH" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/SSH/"/>
    
    
  </entry>
  
  <entry>
    <title>Cocoapods-new-spec</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/Cocoapods-new-spec/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/Cocoapods-new-spec/</id>
    <published>2018-02-27T07:06:13.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;&lt;/l
      
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>cocoapod学习 安装和使用（1）</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/Cocoapods/cocoapod-learn-install/"/>
    <id>http://yoursite.com/wiki/工具/Cocoapods/cocoapod-learn-install/</id>
    <published>2018-02-27T02:29:06.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a> Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在<a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a>的基础上稍微修改而来。<br><a id="more"></a></p><h2 id="什么是CocoaPods？"><a href="#什么是CocoaPods？" class="headerlink" title="什么是CocoaPods？"></a>什么是CocoaPods？</h2><p><a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods</a>是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要我们做太多的配置。直观、集中和自动化地管理项目的第三方库。</p><p>我们都有这样的经历，当添加第三方库的时候，需要导入一堆相关依赖库。当需要更新某个第三方库的时候，又需要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。</p><p>使用CocoaPods管理第三方库后，只需要相当少的配置，就可将第三方库集成到工程中，其它的一切都交由CocoaPods来管理即可，我们使用起来就更省心了。</p><h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>1.首先更新gem到最新版本，在终端中输入：sudo gem update –system更新gem</p><blockquote><p>Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 <a href="http://rubygems.org/" rel="external nofollow noopener noreferrer" target="_blank">http://rubygems.org/</a> ）源来查找、安装、升级和卸载软件包，非常的便捷。</p></blockquote><p>2.删除自带的ruby镜像，终端输入：<code>gem sources --remove https://rubygems.org/</code>。 </p><p>3.添加淘宝的镜像，终端输入：<code>gem sources -a https://gems.ruby-china.org/</code>(原来的淘宝镜像 <a href="https://ruby.taobao.org/已经不能用了)。" rel="external nofollow noopener noreferrer" target="_blank">https://ruby.taobao.org/已经不能用了)。</a> </p><p>4.可以用<code>gem sources -l</code>来检查使用替换镜像位置成功，结果应该只有 <code>https://gems.ruby-china.org/</code> 才对。</p><p>5.安装CocoaPods，终端输入：sudo gem install cocoapods。 </p><blockquote><p>如果提示Operation not permitted，执行sudo gem install -n /usr/local/bin cocoapods命令安装，原因请参考<a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">系统集成保护</a>。</p></blockquote><p>6.然后配置下CocoaPods，终端输入：pod setup。</p><p>到这里CocoaPods就安装好了。</p><h2 id="查找第三方库"><a href="#查找第三方库" class="headerlink" title="查找第三方库"></a>查找第三方库</h2><p>比如查找MJExtension，终端输入：<code>pod search MJExtension</code>，第一次搜索他需要建索引，等待一会儿就可以了。</p><p>输出结果如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-&gt; MJExtension (<span class="number">3.0</span><span class="meta">.13</span>)</span><br><span class="line">   A fast <span class="keyword">and</span> convenient conversion between JSON <span class="keyword">and</span> model</span><br><span class="line">   pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line">   - Homepage: https://github.com/CoderMJLee/MJExtension</span><br><span class="line">   - Source:   https://github.com/CoderMJLee/MJExtension.git</span><br><span class="line">   - Versions: <span class="number">3.0</span><span class="meta">.13</span>, <span class="number">3.0</span><span class="meta">.12</span>, <span class="number">3.0</span><span class="meta">.11</span>, <span class="number">3.0</span><span class="meta">.10</span>, <span class="number">3.0</span><span class="meta">.9</span>, <span class="number">3.0</span><span class="meta">.8</span>, <span class="number">3.0</span><span class="meta">.7</span>, <span class="number">3.0</span><span class="meta">.6</span>,</span><br><span class="line">   <span class="number">3.0</span><span class="meta">.5</span>, <span class="number">3.0</span><span class="meta">.4</span>, <span class="number">3.0</span><span class="meta">.3</span>, <span class="number">3.0</span><span class="meta">.2</span>, <span class="number">3.0</span><span class="meta">.0</span>, <span class="number">2.5</span><span class="meta">.16</span>, <span class="number">2.5</span><span class="meta">.15</span>, <span class="number">2.5</span><span class="meta">.14</span>, <span class="number">2.5</span><span class="meta">.13</span>, <span class="number">2.5</span><span class="meta">.12</span>,</span><br><span class="line">   <span class="number">2.5</span><span class="meta">.10</span>, <span class="number">2.5</span><span class="meta">.9</span>, <span class="number">2.5</span><span class="meta">.8</span>, <span class="number">2.5</span><span class="meta">.7</span>, <span class="number">2.5</span><span class="meta">.6</span>, <span class="number">2.5</span><span class="meta">.5</span>, <span class="number">2.5</span><span class="meta">.3</span>, <span class="number">2.5</span><span class="meta">.2</span>, <span class="number">2.5</span><span class="meta">.1</span>, <span class="number">2.5</span><span class="meta">.0</span>, <span class="number">2.4</span><span class="meta">.4</span>,</span><br><span class="line">   <span class="number">2.4</span><span class="meta">.2</span>, <span class="number">2.4</span><span class="meta">.1</span>, <span class="number">2.4</span><span class="meta">.0</span>, <span class="number">2.3</span><span class="meta">.8</span>, <span class="number">2.3</span><span class="meta">.7</span>, <span class="number">2.3</span><span class="meta">.6</span>, <span class="number">2.3</span><span class="meta">.5</span>, <span class="number">2.3</span><span class="meta">.4</span>, <span class="number">2.3</span><span class="meta">.3</span>, <span class="number">2.3</span><span class="meta">.2</span>, <span class="number">2.3</span><span class="meta">.1</span>,</span><br><span class="line">   <span class="number">2.3</span><span class="meta">.0</span>, <span class="number">2.2</span><span class="meta">.0</span>, <span class="number">2.1</span><span class="meta">.1</span>, <span class="number">2.1</span><span class="meta">.0</span>, <span class="number">2.0</span><span class="meta">.4</span>, <span class="number">2.0</span><span class="meta">.3</span>, <span class="number">2.0</span><span class="meta">.2</span>, <span class="number">2.0</span><span class="meta">.1</span>, <span class="number">2.0</span><span class="meta">.0</span>, <span class="number">1.2</span><span class="meta">.1</span>, <span class="number">1.2</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">1.1</span><span class="meta">.0</span>, <span class="number">1.0</span><span class="meta">.1</span>, <span class="number">1.0</span><span class="meta">.0</span>, <span class="number">0.3</span><span class="meta">.2</span>, <span class="number">0.3</span><span class="meta">.1</span>, <span class="number">0.3</span><span class="meta">.0</span>, <span class="number">0.2</span><span class="meta">.0</span>, <span class="number">0.1</span><span class="meta">.3</span>, <span class="number">0.1</span><span class="meta">.2</span>, <span class="number">0.1</span><span class="meta">.1</span>, <span class="number">0.1</span><span class="meta">.0</span>,</span><br><span class="line">   <span class="number">0.0</span><span class="meta">.3</span>, <span class="number">0.0</span><span class="meta">.2</span>, <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br><span class="line"></span><br><span class="line">-&gt; MJExtension_HPTest (<span class="number">0.0</span><span class="meta">.1</span>)</span><br><span class="line">   花圃测试项目</span><br><span class="line">   pod <span class="string">'MJExtension_HPTest'</span>, <span class="string">'~&gt; 0.0.1'</span></span><br><span class="line">   - Homepage: https://github.com/LetMeCrazy/testPods</span><br><span class="line">   - Source:   https://github.com/LetMeCrazy/testPods.git</span><br><span class="line">   - Versions: <span class="number">0.0</span><span class="meta">.1</span> [master repo]</span><br></pre></td></tr></table></figure><h2 id="引入第三方库到项目中"><a href="#引入第三方库到项目中" class="headerlink" title="引入第三方库到项目中"></a>引入第三方库到项目中</h2><p>我先在桌面上新建一个cocoapodUse项目，然后演示把MJExtension导进去。</p><p>2.然后生成并编辑一个<code>Podfile</code>文件，命令为:</p><p><code>vim Podfile</code></p><p>要导入的第三方都要写在Podfile中。进去后需要先按</p><p><code>I</code> 键进入编辑状态，写完后按<code>esc</code>，然后按<code>shift+zz</code>(或者先按<code>shift+:</code>,再按<code>wq</code>)就可以保存退出了。</p><p>Podfile的格式如下，其中’cocoapodUse’为你的target的名字。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios,<span class="string">'8.0'</span></span><br><span class="line"></span><br><span class="line">target <span class="string">'cocoapodUse'</span> <span class="keyword">do</span></span><br><span class="line"></span><br><span class="line">pod <span class="string">'MJExtension'</span>, <span class="string">'~&gt; 3.0.13'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>3.安装，命令为：</p><p><code>pod install</code></p><p>安装成功之后，第三方库就被包含到项目中了。</p><p>之前我们一直是双击Test.xcodeproj打开项目，以后我们就要双击Test.xcworkspace打开了，可以看到MJExtension已经被引入了。</p><h2 id="项目引入MJExtension"><a href="#项目引入MJExtension" class="headerlink" title="项目引入MJExtension"></a>项目引入MJExtension</h2><p>你会发现当引入MJExtension的头文件时，可以 <code>#import &lt;MJExtension.h&gt;</code>或者<code>#import &lt;MJExtension/MJExtension.h&gt;</code>，但是却不能在输入<code>#import &quot;MJExtension.h&quot;</code>的时候出现提示。虽然强制输入也可以编译通过，但是感觉很不爽。 解决这个问题的办法是在工程的Build Settings搜索Search，然后在User header search paths中添加$(SRCROOT)并选择recursive。</p><p>现在就可以提示#import “MJExtension.h”啦。</p><h2 id="增加新的第三方"><a href="#增加新的第三方" class="headerlink" title="增加新的第三方"></a>增加新的第三方</h2><p>如果使用过程中我还想添加其他的第三方怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。</p><h2 id="更新CocoaPods中的第三方库"><a href="#更新CocoaPods中的第三方库" class="headerlink" title="更新CocoaPods中的第三方库"></a>更新CocoaPods中的第三方库</h2><p>第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。</p><p>如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： pod install –verbose –no-repo-update </p><h2 id="删除CocoaPods中的某些第三方库。"><a href="#删除CocoaPods中的某些第三方库。" class="headerlink" title="删除CocoaPods中的某些第三方库。"></a>删除CocoaPods中的某些第三方库。</h2><p>当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。</p><h2 id="升级CocoaPods"><a href="#升级CocoaPods" class="headerlink" title="升级CocoaPods"></a>升级CocoaPods</h2><p>升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令sudo gem install -n /usr/local/bin cocoapods –pre就可以了。</p><h2 id="卸载CocoaPods"><a href="#卸载CocoaPods" class="headerlink" title="卸载CocoaPods"></a>卸载CocoaPods</h2><p>卸载CocoaPods的命令是sudo gem uninstall cocoapods</p><p>执行完命令后，最下面打印Successfully uninstalled cocoapods字样就代表已经成功卸载了。</p><h2 id="CocoaPods-Mac-App的安装和使用"><a href="#CocoaPods-Mac-App的安装和使用" class="headerlink" title="CocoaPods Mac App的安装和使用"></a>CocoaPods Mac App的安装和使用</h2><p>CocoaPods桌面应用版下载地址：[<a href="https://cocoapods.org/app][1" rel="external nofollow noopener noreferrer" target="_blank">https://cocoapods.org/app][1</a>] 打开应用会提示你是否安装命令行工具，选择install就也可以在命令行使用Pod了。省去了上面的步骤们，方便快捷的使用CocoaPods。</p><p>现在假如要给一个Test项目加入第三方库 1.选择File-New Podfile from Xcode Project，去选择项目的Project文件。</p><p>2.填写自动生成的Podfile，并且安装。</p><p>然后就可以去打开工程了，是不是比命令行简单多了。 </p><blockquote><p>注意：Cocoapods.app 删掉并执行命令可能会报错：Unable to locate the CocoaPods.app application bundle. Please ensure the application is available and launch it at least once<br>这时候只要执行sudo gem install -n /usr/local/bin cocoapods命令就可以了。</p></blockquote><h2 id="CocoaPods官方使用指南"><a href="#CocoaPods官方使用指南" class="headerlink" title="CocoaPods官方使用指南"></a>CocoaPods官方使用指南</h2><p>链接：<a href="https://guides.cocoapods.org/" rel="external nofollow noopener noreferrer" target="_blank">CocoaPods 官方使用指南</a>有什么不了解的或者遇到错误可以去这里查看一下。</p><h2 id="XCode的CocoaPods插件"><a href="#XCode的CocoaPods插件" class="headerlink" title="XCode的CocoaPods插件"></a>XCode的CocoaPods插件</h2><p>[CocoaPods-xcode-plugin]是一个XCode的插件，可以很方便的在Xcode通过pods安装各种第三方库。前提是终端已经安装好CocoaPods。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/1711e131987d" rel="external nofollow noopener noreferrer" target="_blank">看一遍就会的CocoaPods的安装和使用教程</a></li><li><a href="https://www.jianshu.com/p/23c01067cf7e" rel="external nofollow noopener noreferrer" target="_blank">升级 OS X 10.11 cocoapods 使用不正常的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://guides.cocoapods.org/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;CocoaPods&lt;/a&gt; Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在&lt;a href=&quot;https://www.jianshu.com/p/1711e131987d&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;看一遍就会的CocoaPods的安装和使用教程&lt;/a&gt;的基础上稍微修改而来。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Cocoapods" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/Cocoapods/"/>
    
    
  </entry>
  
  <entry>
    <title>自己搭建博客的经历</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/hexo/%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/wiki/工具/hexo/自己搭建博客的经历/</id>
    <published>2018-02-13T07:33:17.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。</p><a id="more"></a><h2 id="初始化hexo环境"><a href="#初始化hexo环境" class="headerlink" title="初始化hexo环境"></a>初始化hexo环境</h2><ul><li>新建博客的文件夹</li></ul><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~<span class="string">/Desktop/jiangli2017</span> </span><br><span class="line"><span class="keyword">cd</span> ~<span class="string">/Desktop/jianli2017</span></span><br></pre></td></tr></table></figure><ul><li>初始化hexo</li></ul><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hexo init</span></span><br></pre></td></tr></table></figure><h2 id="Wikitten主题配置"><a href="#Wikitten主题配置" class="headerlink" title="Wikitten主题配置"></a>Wikitten主题配置</h2><p>本博客根据自己的喜好，选择的<a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">Wikitten</a>主题，这个主题类似wiki，具有文章的目录结构。</p><ul><li>进入你的 hexo 站点文件夹，克隆 <code>Wikitten</code> 主题到 <code>themes/</code> 路径下</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop/jiangli2017 </span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten</span><br></pre></td></tr></table></figure><ul><li>覆盖站点目录中一些默认页面模板</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -rf themes/Wikitten/_source/* <span class="built_in">source</span>/</span><br><span class="line">cp -rf themes/Wikitten/_scaffolds/* scaffolds/</span><br></pre></td></tr></table></figure><ul><li>重命名主题中的 <code>_config.yml.example</code> 到 <code>_config.yml</code>，然后可以使用配置文件配置主题</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml</span><br><span class="line"><span class="comment"># 编辑配置文件，定制你的配置项</span></span><br><span class="line">vim themes/Wikitten/_config.yml</span><br></pre></td></tr></table></figure><p>大部分的配置项都和 <a href="https://github.com/ppoffice/hexo-theme-icarus" rel="external nofollow noopener noreferrer" target="_blank">icarus</a> 主题中的配置项一样，你可以首先去阅读一下 <a href="https://github.com/ppoffice/hexo-theme-icarus/wiki" rel="external nofollow noopener noreferrer" target="_blank">icraus 的文档</a>。</p><ul><li>需要安装的插件写在主题的 <a href="./package.json"><code>package.json</code></a> 文件中</li></ul><p>这里列出了这些插件的功能作用：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo-autonofollow    // 打开非本站链接时自动开启新标签页</span><br><span class="line">hexo-directory-category // 根据文章文件目录自动为文章添加分类</span><br><span class="line">hexo-generator-feed    // 生成 RSS 源</span><br><span class="line">hexo-generator-json-content// 生成全站文章 json 内容，用于全文搜索</span><br><span class="line">hexo-generator-sitemap// 生成全站站点地图 sitemap</span><br></pre></td></tr></table></figure><p>你可以将这些插件合并到<strong>站点</strong>的 <code>package.json</code> 文件中通过 <code>npm install</code> 一次安装，</p><p>或者在<strong>站点目录</strong>下，你可以通过以下命令安装他们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h4 id="站点配置"><a href="#站点配置" class="headerlink" title="站点配置"></a>站点配置</h4><p>下面是站点推荐配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yaml</span></span><br><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">wiki/:title/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">theme:</span> <span class="string">Wikitten</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">README.md</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">'_posts/**/embed_page/**'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span> <span class="comment"># File name of new posts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Markdown</span></span><br><span class="line"><span class="comment">## https://github.com/hexojs/hexo-renderer-marked</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line"><span class="attr">  gfm:</span> <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">### JsonContent</span></span><br><span class="line"><span class="attr">jsonContent:</span></span><br><span class="line"><span class="attr">  meta:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  pages:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  posts:</span></span><br><span class="line"><span class="attr">    title:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    date:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    path:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    text:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    categories:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  ignore:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="number">404.</span><span class="string">html</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">### Creat sitemap</span></span><br><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### Adds nofollow attribute to all external links in your hexo blog posts automatically.</span></span><br><span class="line"><span class="attr">nofollow:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  exclude:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">&lt;your</span> <span class="string">site</span> <span class="string">url</span> <span class="string">domain&gt;</span> <span class="comment"># eg: zthxxx.me</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment（发布git）</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 多级目录结构</span></span><br><span class="line"><span class="attr">auto_dir_categorize:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span>  <span class="comment"># options:true, false; default is true</span></span><br><span class="line"><span class="attr">  force:</span> <span class="literal">true</span> <span class="comment"># options:true, false; default is false</span></span><br></pre></td></tr></table></figure><p>多级目录结构可以需要安装插件：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --<span class="built_in">save</span> hexo-<span class="built_in">directory</span>-category</span><br></pre></td></tr></table></figure><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li>不能发布到git上面</li></ul><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br><span class="line"><span class="keyword">ERROR </span>Deployer not found: git</span><br></pre></td></tr></table></figure><p>解决办法：hexo目录下安装：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span>  <span class="comment">--save hexo-deployer-git</span></span><br></pre></td></tr></table></figure><ul><li>hexo d 没有反应</li></ul><p>需要在站点目录下的_config.yml 中添加如下配置：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/jianli2017/jianli2017.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><ul><li>图床</li></ul><p>我的博客中用相对目录显示图片，无法显示，需要用图床，我选择的是<a href="https://portal.qiniu.com" rel="external nofollow noopener noreferrer" target="_blank">七牛云</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href=""></a></li><li><a href=""></a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
  </entry>
  
  <entry>
    <title>git时光穿梭(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%B7%A5%E4%BD%9C%E5%8C%BA/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git工作区/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个Git仓库，使用git init命令。</p><p>添加文件到Git仓库，分两步：</p><ul><li>使用命令git add <file>，注意，可反复多次使用，添加多个文件；</file></li><li>第二步，使用命令git commit，完成。</li></ul><h2 id="工作区的状态"><a href="#工作区的状态" class="headerlink" title="工作区的状态"></a>工作区的状态</h2><ul><li>要随时掌握工作区的状态，使用git status命令。</li><li>如果git status告诉你有文件被修改过，用git diff可以查看修改内容。</li></ul><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向append GPL：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-head.jpg" alt="git-head"></p><p>改为指向add distributed：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-header-move.jpg" alt="git-head-move"></p><p>然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。</p><ol><li>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</li><li>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</li></ol><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p><h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p><p><img src="http://of685p9vy.bkt.clouddn.com/git-repo.jpg" alt="git-repo"></p><p>分支和HEAD的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br></pre></td></tr></table></figure><p>先用git status查看一下状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Untracked files:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       LICENSE</span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   LICENSE</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage.jpg" alt="git-stage"></p><p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"understand how stage works"</span></span><br><span class="line">[master <span class="number">27</span>c9860] understand how stage works</span><br><span class="line"> <span class="number">2</span> files <span class="section">changed</span>, <span class="number">675</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> LICENSE</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git-stage-after-commit.jpg" alt="git-stage-after-commit"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><strong>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</strong></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span>.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt </span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"git tracks changes"</span></span><br><span class="line">[<span class="keyword">master</span> d4f25b6] git tracks changes</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit</p><p>你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- readme<span class="selector-class">.txt</span> </span><br><span class="line">diff --git a/readme<span class="selector-class">.txt</span> b/readme.txt</span><br><span class="line">index <span class="number">76</span>d770f.<span class="selector-class">.a9c5755</span> <span class="number">100644</span></span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -<span class="number">1</span>,<span class="number">4</span> +<span class="number">1</span>,<span class="number">4</span> @@</span><br><span class="line"> Git is <span class="selector-tag">a</span> distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has <span class="selector-tag">a</span> mutable index called stage.</span><br><span class="line">-Git tracks changes.</span><br><span class="line">+Git tracks changes of files.</span><br></pre></td></tr></table></figure><p>那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit</p><p>好，现在，把第二次修改提交了，然后开始小结。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。</p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br></pre></td></tr></table></figure><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>现在，看看readme.txt的文件内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure><p>git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">add</span> readme.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="keyword">HEAD</span> readme.txt</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">M       readme.txt</span><br></pre></td></tr></table></figure><p>再用git status查看一下，现在暂存区是干净的，工作区有修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- readme.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退][1]一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了……</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>又到了小结时间。</p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退][2]一节，不过前提是没有推送到远程库。</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git add test.txt</span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add test.txt"</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">94</span>cdc44] <span class="keyword">add</span> test.txt</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">mode</span> <span class="number">100644</span> test.txt</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm test.txt</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       deleted:    test.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line"><span class="keyword">rm</span> '<span class="keyword">test</span>.txt'</span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">"remove test.txt"</span></span><br><span class="line">[master d17efd8] remove <span class="keyword">test</span>.txt</span><br><span class="line"> 1 <span class="keyword">file</span> changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- test.txt</span></span><br></pre></td></tr></table></figure><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E4%BB%93%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git仓库/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:49:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。</p><a id="more"></a><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；</p><p>关联后，使用命令git push -u origin master第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；</p><p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p><h2 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>@github.com:michaelliao/gitskills.git</span><br></pre></td></tr></table></figure><h2 id="使用码云"><a href="#使用码云" class="headerlink" title="使用码云"></a>使用码云</h2><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p><p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——[码云](<a href="https://gitee.com/）。" rel="external nofollow noopener noreferrer" target="_blank">https://gitee.com/）。</a></p><p>和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p><p>码云的免费版本也提供私有库功能，只是有5人的成员上限。</p><p>使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-add-ssh-key.jpg" alt="gitee-add-ssh-key"></p><p>点击“确定”即可完成并看到刚才添加的Key：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-key.jpg" alt="gitee-key"></p><p>如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？</p><p>首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorygitee-new-repo.jpg" alt="gitee-new-repo"></p><p>项目名称最好与本地库保持一致：</p><p>然后，我们在本地库上使用命令git remote add把它和码云的远程库关联：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><blockquote><p>小提示 ： origin 远程仓库也就是url对应的仓库 在本地的别名。</p></blockquote><p>如果在使用命令git remote add时报错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit.git</span><br><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>我们可以删除已有的GitHub远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><p>有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？</p><p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p><p>使用多个远程库时，我们要注意，<font color="red">git给远程库起的默认名称是origin</font>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p><p>仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git remote rm origin</span></span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> github git@github.com:michaelliao/learngit.git</span></span><br></pre></td></tr></table></figure><p>接着，再关联码云的远程库：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> gitee git@gitee.com:liaoxuefeng/learngit.git</span></span><br></pre></td></tr></table></figure><p>现在，我们用git remote -v查看远程库信息，可以看到两个远程库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">gitee    git@gitee<span class="selector-class">.com</span>:liaoxuefeng/learngit<span class="selector-class">.git</span> (push)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">github    git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>github master</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">push </span>gitee master</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/repositorymulti-remote.jpg" alt="multi-remote"></p><p>码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。</p><blockquote><p>小贴士 ：git fetch 和git pull的区别</p><ul><li>fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支</li><li>pull 若某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支</li></ul></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://git-scm.com/book/zh/v1/Git-基础-远程仓库的使用" rel="external nofollow noopener noreferrer" target="_blank">Git-基础-远程仓库的使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git分支管理(转载)</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/wiki/工具/git/git详细记录/git分支管理/</id>
    <published>2018-02-12T04:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文全部复制<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" rel="external nofollow noopener noreferrer" target="_blank">Git教程</a>,自己理解的就简单复制，没有理解的就全部粘贴。</p><a id="more"></a><h2 id="创建和合并分支"><a href="#创建和合并分支" class="headerlink" title="创建和合并分支"></a>创建和合并分支</h2><p>在[版本回退][1]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。<strong>HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</strong></p><p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-initial.png" alt="git-br-initial"></p><p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长：</p><p><strong>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</strong></p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-create.png" alt="git-br-create"></p><p>你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-fd.png" alt="git-br-dev-fd"></p><p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-ff-merge.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-remove.png" alt="git-br-rm"></p><p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p><p>下面开始实战。</p><p><strong>首先，我们创建dev分支，然后切换到dev分支：</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> dev</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'dev'</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* dev</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"branch test"</span></span></span><br><span class="line">[dev fec145a] branch test</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-on-master.png" alt="git-br-on-master"></p><p>现在，我们把dev分支的工作成果合并到master分支上：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge dev</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure><p>注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>dev (was fec145a).</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Git鼓励大量使用分支：</p><p>查看分支：git branch</p><p>创建分支：git branch dev</p><p>切换分支：git checkout </p><p>创建+切换分支：git checkout -b </p><p>合并某分支到当前分支：git merge </p><p>删除分支：git branch -d </p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的feature1分支，继续我们的新分支开发：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -<span class="selector-tag">b</span> feature1</span><br><span class="line">Switched to <span class="selector-tag">a</span> new branch <span class="string">'feature1'</span></span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">AND</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"AND simple"</span></span><br><span class="line">[feature1 75a857c] <span class="keyword">AND</span> simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="keyword">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">1</span> commit.</span><br></pre></td></tr></table></figure><p>在master分支上把readme.txt文件的最后一行改为：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="builtin-name">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">"&amp; simple"</span></span><br><span class="line">[master 400b400] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-feature1.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">merge</span> feature1</span><br><span class="line"><span class="keyword">Auto</span>-merging readme.txt</span><br><span class="line">CONFLICT (<span class="keyword">content</span>): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> readme.txt</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Your branch is ahead of <span class="string">'origin/master'</span> by 2 commits.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unmerged paths:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add/rm ..."</span> as appropriate to mark resolution)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       both modified:      readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick <span class="keyword">and</span> simple.</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"conflict fixed"</span></span></span><br><span class="line">[master 59bc1cb] conflict fixed</span><br></pre></td></tr></table></figure><p><img src="http://of685p9vy.bkt.clouddn.com/git/branchgit-br-conflict-merged.png" alt="git-br-conflict-merged"></p><p>用带参数的git log也可以看到分支的合并情况：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git log --graph <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">*   59bc1cb conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * 75a857c <span class="keyword">AND</span> simple</span><br><span class="line">* | 400b400 &amp; simple</span><br><span class="line">|/</span><br><span class="line">* fec145a branch test</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d feature1</span><br><span class="line"><span class="symbol">Deleted</span> <span class="keyword">branch </span>feature1 (was <span class="number">75</span>a857c).</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>用git log –graph命令可以看到分支合并图。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</p><h2 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working <span class="built_in">directory</span> <span class="keyword">and</span> index state WIP <span class="keyword">on</span> <span class="title">dev</span>: <span class="title">6224937</span> <span class="title">add</span> <span class="title">merge</span></span><br><span class="line">HEAD is now <span class="keyword">at</span> <span class="number">6224937</span> <span class="built_in">add</span> <span class="built_in">merge</span></span><br></pre></td></tr></table></figure><p>首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">6</span> commits.</span><br><span class="line">$ git checkout -b issue<span class="number">-101</span></span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">'issue-101'</span></span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m <span class="string">"fix bug 101"</span></span><br><span class="line">[issue<span class="number">-101</span> cc17032] fix bug <span class="number">101</span></span><br><span class="line"> <span class="number">1</span> file <span class="section">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched <span class="built_in">to</span> branch <span class="string">'master'</span></span><br><span class="line">Your branch is ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">2</span> commits.</span><br><span class="line">$ git <span class="built_in">merge</span> <span class="comment">--no-ff -m "merged bug fix 101" issue-101</span></span><br><span class="line">Merge made <span class="keyword">by</span> <span class="keyword">the</span> <span class="string">'recursive'</span> strategy.</span><br><span class="line"> readme.txt |    <span class="number">2</span> +-</span><br><span class="line"> <span class="number">1</span> <span class="built_in">file</span> changed, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br><span class="line">$ git branch -d issue<span class="number">-101</span></span><br><span class="line">Deleted branch issue<span class="number">-101</span> (was cc17032).</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch 'dev'</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash <span class="keyword">list</span></span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP <span class="keyword">on</span> de<span class="variable">v:</span> <span class="number">6224937</span> <span class="built_in">add</span> merge</span><br></pre></td></tr></table></figure><p>一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；</p><p>另一种方式是用git stash pop，恢复的同时把stash内容也删了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch dev</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes to be committed:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git reset HEAD ..."</span> to unstage)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       new file:   hello.py</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Changes not staged <span class="keyword">for</span> commit:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git add ..."</span> to update what will be committed)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">"git checkout -- ..."</span> to discard changes <span class="keyword">in</span> working directory)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line">Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40)</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git stash apply stash@&#123;0&#125;</span></span><br></pre></td></tr></table></figure><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。</p><h2 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h2><p>开发一个新feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过git branch -D <name>强行删除。</name></p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。</p><p>要查看远程库的信息，用git remote：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learngit<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> dev</span><br></pre></td></tr></table></figure><ul><li><p>master分支是主分支，因此要时刻与远程同步；</p></li><li><p>dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往master和dev分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.<span class="string">com:</span>michaelliao/learngit.git</span><br><span class="line">Cloning into <span class="string">'learngit'</span>...</span><br><span class="line"><span class="string">remote:</span> Counting <span class="string">objects:</span> <span class="number">46</span>, done.</span><br><span class="line"><span class="string">remote:</span> Compressing <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">26</span>/<span class="number">26</span>), done.</span><br><span class="line"><span class="string">remote:</span> Total <span class="number">46</span> (delta <span class="number">16</span>), reused <span class="number">45</span> (delta <span class="number">15</span>)</span><br><span class="line">Receiving <span class="string">objects:</span> <span class="number">100</span>% (<span class="number">46</span><span class="regexp">/46), 15.69 KiB | 6 KiB/</span>s, done.</span><br><span class="line">Resolving <span class="string">deltas:</span> <span class="number">100</span>% (<span class="number">16</span>/<span class="number">16</span>), done.</span><br></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add /usr/bin/env"</span></span><br><span class="line">[dev <span class="number">291</span>bea8] <span class="keyword">add</span> /usr/<span class="keyword">bin</span>/env</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">5</span>, done.</span><br><span class="line">Delta compression <span class="keyword">using</span> up <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100</span>% (<span class="number">2</span>/<span class="number">2</span>), done.</span><br><span class="line">Writing objects: <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), <span class="number">349</span> <span class="keyword">bytes</span>, done.</span><br><span class="line">Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line">   fc38031.<span class="number">.291</span>bea8  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git add hello.py </span><br><span class="line">$ git <span class="keyword">commit</span> -m <span class="string">"add coding: utf-8"</span></span><br><span class="line">[dev bd6ae48] <span class="keyword">add</span> coding: utf<span class="number">-8</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+)</span><br><span class="line">$ git push origin dev</span><br><span class="line"><span class="keyword">To</span> git@github.com:michaelliao/learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-<span class="keyword">fast</span>-forward)</span><br><span class="line"><span class="keyword">error</span>: <span class="keyword">failed</span> <span class="keyword">to</span> push <span class="keyword">some</span> refs <span class="keyword">to</span> <span class="string">'git@github.com:michaelliao/learngit.git'</span></span><br><span class="line">hint: Updates were rejected because the tip <span class="keyword">of</span> your <span class="keyword">current</span> branch <span class="keyword">is</span> behind</span><br><span class="line">hint: its remote counterpart. <span class="keyword">Merge</span> the remote changes (e.g. <span class="string">'git pull'</span>)</span><br><span class="line">hint: <span class="keyword">before</span> pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 5, done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 3 (delta 0)</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line"><span class="keyword">From</span> github.com:michaelliao/learngit</span><br><span class="line">   fc38031<span class="built_in">..</span>291bea8  dev        -&gt; origin/dev</span><br><span class="line">There is <span class="literal">no</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify which branch you want <span class="keyword">to</span> merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details</span><br><span class="line"></span><br><span class="line">    git pull  </span><br><span class="line"></span><br><span class="line"><span class="keyword">If</span> you wish <span class="keyword">to</span> <span class="builtin-name">set</span><span class="built_in"> tracking </span>information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream dev origin/</span><br></pre></td></tr></table></figure><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream <span class="built_in">dev</span> origin/<span class="built_in">dev</span></span><br><span class="line">Branch <span class="built_in">dev</span> <span class="built_in">set</span> up to track remote branch <span class="built_in">dev</span> <span class="keyword">from</span> origin.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">CONFLICT (content): <span class="keyword">Merge</span> conflict <span class="keyword">in</span> hello.py</span><br><span class="line"><span class="keyword">Automatic</span> <span class="keyword">merge</span> <span class="keyword">failed</span>; fix conflicts and then <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">"merge &amp; fix hello.py"</span></span><br><span class="line">[dev adca45d] merge &amp; fix hello.py</span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: <span class="number">10</span>, done.</span><br><span class="line">Delta compression using up to <span class="number">4</span> threads.</span><br><span class="line">Compressing objects: <span class="number">100%</span> (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">Writing objects: <span class="number">100%</span> (<span class="number">6</span>/<span class="number">6</span>), <span class="number">747</span> bytes, done.</span><br><span class="line">Total <span class="number">6</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">To git@github<span class="selector-class">.com</span>:michaelliao/learngit.git</span><br><span class="line">   <span class="number">291</span>bea8.<span class="selector-class">.adca45d</span>  dev -&gt; dev</span><br></pre></td></tr></table></figure><p>因此，多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用git push origin branch-name推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！</p></li></ol><p>如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><ul><li><p>查看远程库信息，使用git remote -v；</p></li><li><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p></li><li><p>从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交；</p></li><li><p>在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致；</p></li><li><p>建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name；</p></li><li><p>从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。</p></li></ul><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  <span class="literal">master</span></span><br><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch '<span class="literal">master</span>'</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v1</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>方法是找到历史提交的commit id，然后打上就可以了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git log <span class="attribute">--pretty</span>=oneline --abbrev-commit</span><br><span class="line">6a5819e merged bug fix 101</span><br><span class="line">cc17032 fix bug 101</span><br><span class="line">7825a50 merge with no-ff</span><br><span class="line">6224937 <span class="builtin-name">add</span> merge</span><br><span class="line">59bc1cb conflict fixed</span><br><span class="line">400b400 &amp; simple</span><br><span class="line">75a857c <span class="keyword">AND</span> simple</span><br><span class="line">fec145a branch test</span><br><span class="line">d17efd8 <span class="builtin-name">remove</span> test.txt</span><br><span class="line"><span class="built_in">..</span>.</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">9</span> <span class="number">6224937</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span></span><br><span class="line">v0.<span class="number">9</span></span><br><span class="line">v1.<span class="number">0</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.9</span></span><br><span class="line"><span class="keyword">commit</span> <span class="number">622493706</span>ab447b6bb37e4e2a2f276a20fed2ab4</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">11</span>:<span class="number">22</span>:<span class="number">08</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> <span class="keyword">merge</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-a</span> v0.<span class="number">1</span> -m <span class="string">"version 0.1 released"</span> <span class="number">3628164</span></span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git show v0.<span class="number">1</span></span><br><span class="line"><span class="keyword">tag</span> <span class="title">v0</span>.<span class="number">1</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">11</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">version</span> <span class="number">0.1</span> released</span><br><span class="line"></span><br><span class="line">commit <span class="number">3628164</span>fb26d48395383f8f31179f24e0882e1e0</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="keyword">Date</span>:   Tue Aug <span class="number">20</span> <span class="number">15</span>:<span class="number">11</span>:<span class="number">49</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br></pre></td></tr></table></figure><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">tag</span> <span class="title">-s</span> v0.<span class="number">2</span> -m <span class="string">"signed version 0.2 released"</span> fec145a</span><br></pre></td></tr></table></figure><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gpg: signing failed: secret key not available</span><br><span class="line"><span class="keyword">error: </span>gpg failed to sign the data</span><br><span class="line"><span class="keyword">error: </span>unable to sign the tag</span><br></pre></td></tr></table></figure><p>用命令git show 可以看到PGP签名信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">show</span> v0<span class="number">.2</span></span><br><span class="line">tag v0<span class="number">.2</span></span><br><span class="line">Tagger: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Mon Aug <span class="number">26</span> <span class="number">07</span>:<span class="number">28</span>:<span class="number">33</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">signed <span class="keyword">version</span> <span class="number">0.2</span> released</span><br><span class="line"><span class="comment">-----BEGIN PGP SIGNATURE-----</span></span><br><span class="line"><span class="keyword">Version</span>: GnuPG v1<span class="number">.4</span><span class="number">.12</span> (Darwin)</span><br><span class="line"></span><br><span class="line">iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...</span><br><span class="line"><span class="comment">-----END PGP SIGNATURE-----</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span> fec145accd63cdc9ed95a2f557ea0658a2a6537f</span><br><span class="line">Author: Michael Liao </span><br><span class="line"><span class="built_in">Date</span>:   Thu Aug <span class="number">22</span> <span class="number">10</span>:<span class="number">37</span>:<span class="number">30</span> <span class="number">2013</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    branch <span class="keyword">test</span></span><br></pre></td></tr></table></figure><h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><ul><li><p>命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id；</p></li><li><p>git tag -a  -m “blablabla…”可以指定标签信息；</p></li><li><p>git tag -s  -m “blablabla…”可以用PGP签名标签；</p></li><li><p>命令git tag可以查看所有标签。</p></li></ul><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><ul><li>命令git push origin <tagname>可以推送一个本地标签；</tagname></li><li>命令git push origin –tags可以推送全部未推送过的本地标签；</li><li>命令git tag -d <tagname>可以删除一个本地标签；</tagname></li><li>命令git push origin :refs/tags/<tagname>可以删除一个远程标签。</tagname></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文全部复制&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;,自己理解的就简单复制，没有理解的就全部粘贴。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git详细记录" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E8%AF%A6%E7%BB%86%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>hexo使用指南</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/hexo/hexo-use/"/>
    <id>http://yoursite.com/wiki/工具/hexo/hexo-use/</id>
    <published>2018-02-07T07:57:29.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC）</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo n #写文章</span><br><span class="line">hexo g #生成</span><br><span class="line">hexo d #部署 # 可与hexo g合并为 hexo d -g</span><br></pre></td></tr></table></figure><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ul><li>安装Node.js</li><li>安装git（Xcode自带）</li><li>安装hexo</li></ul><p>hexo 是基于Node.js的静态博客程序，使用npm 安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g hexo</span><br></pre></td></tr></table></figure><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><ul><li>首先注册一个『GitHub』帐号</li><li>建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』</li><li>添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』</li></ul><p>说明 git使用两种协议传输：https、git，如我的blog 的两种协议git地址如下：</p><p>git@github.com:jianli2017/jianli2017.github.io.git<br><a href="https://github.com/jianli2017/jianli2017.github.io.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/jianli2017/jianli2017.github.io.git</a></p><p>SSH 作用于git协议，使用SSH 后，git协议的push、pull操作不需要输入密码。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>使用hexo init 命令在当前目录下初始化一个hexo项目</p><h1 id="生成静态页面"><a href="#生成静态页面" class="headerlink" title="生成静态页面"></a>生成静态页面</h1><p>cd 到你的init目录，执行如下命令，生成静态页面到 ./public/目录。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure><h1 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h1><p>执行如下命令，启动本地服务，进行文章预览调试。</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>执行new命令，生成指定名称的文章至hexo/source/_posts/postName.md。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> [lay“<span class="keyword">out</span>] <span class="string">"postName"</span> <span class="meta">#新建文章</span></span><br></pre></td></tr></table></figure><p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line"><span class="keyword">tags:</span></span><br></pre></td></tr></table></figure><p>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。</p><p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">categories: </span><br><span class="line"><span class="keyword">tags:</span></span><br></pre></td></tr></table></figure><p>postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。</p><p>注意，所有文件：后面都必须有个空格，不然会报错。</p><p>看一下刚才生成的文件hexo/source/_posts/postName.md，内容如下：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中</span><br><span class="line">date: 2013<span class="string">-12</span><span class="string">-02</span> 15:30:16 #文章生成时间，一般不改，当然也可以任意修改</span><br><span class="line">categories: #文章分类目录，可以为空，注意:后面有个空格</span><br><span class="line"><span class="keyword">tags:</span> #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格</span><br></pre></td></tr></table></figure><h1 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h1><p>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layout: photo</span><br><span class="line">title: 我的阅历</span><br><span class="line">date: 2085<span class="string">-01</span><span class="string">-16</span> 07:33:44</span><br><span class="line"><span class="keyword">tags:</span> [hexo]</span><br><span class="line">photos:</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos<span class="string">-0</span>.jpg</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos<span class="string">-1</span>.jpg</span><br></pre></td></tr></table></figure><p>经过测试，文件头上的layout: photo可以省略。</p><p>不想每次都手动添加怎么办？同样的，打开您的hexo\scaffolds\photo.md</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layout: &#123; &#123; layout &#125; &#125;</span><br><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line"><span class="keyword">tags:</span> </span><br><span class="line">photos:</span><br></pre></td></tr></table></figure><p>然后每次可以执行带layout的new命令生成照片文章：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="type">photo</span> <span class="string">"photoPostName"</span> <span class="meta">#新建照片文章</span></span><br></pre></td></tr></table></figure><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>markdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: hexo你的博客</span><br><span class="line">date: 2013<span class="string">-11</span><span class="string">-22</span> 17:11:54</span><br><span class="line">categories: default</span><br><span class="line"><span class="keyword">tags:</span> [hexo]</span><br><span class="line">description: 你对本页的描述</span><br></pre></td></tr></table></figure><p>hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。</p><h1 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h1><p>在需要显示摘要的地方添加如下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以上是摘要</span><br><span class="line"><span class="comment">&lt;!--more--&gt;</span></span><br><span class="line">以下是余下全文</span><br></pre></td></tr></table></figure><p>more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。</p><p>hexo中所有文件的编码格式均是UTF-8。</p><h1 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h1><p>安装主题的方法就是一句git命令：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/heroicyang/hexo-theme-modernist.git themes/modernist</span><br></pre></td></tr></table></figure><p>目录是否是modernist无所谓，只要与_config.yml文件一致即可。</p><p>安装完成后，打开hexo/_config.yml，修改主题为modernist</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">theme:</span> modernist</span><br></pre></td></tr></table></figure><p>打开hexo/themes/modernist目录，编辑主题配置文件_config.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span> <span class="comment">#配置页头显示哪些菜单</span></span><br><span class="line"><span class="comment">#  Home: /</span></span><br><span class="line"><span class="attr">  Archives:</span> <span class="string">/archives</span></span><br><span class="line"><span class="attr">  Reading:</span> <span class="string">/reading</span></span><br><span class="line"><span class="attr">  About:</span> <span class="string">/about</span></span><br><span class="line"><span class="comment">#  Guestbook: /about</span></span><br><span class="line"><span class="attr">excerpt_link:</span> <span class="string">Read</span> <span class="string">More</span> <span class="comment">#摘要链接文字</span></span><br><span class="line"><span class="attr">archive_yearly:</span> <span class="literal">false</span> <span class="comment">#按年存档</span></span><br><span class="line"><span class="attr">widgets:</span> <span class="comment">#配置页脚显示哪些小挂件</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">category</span></span><br><span class="line"><span class="comment">#  - tag</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">tagcloud</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">recent_posts</span></span><br><span class="line"><span class="comment">#  - blogroll</span></span><br><span class="line"><span class="attr">blogrolls:</span> <span class="comment">#友情链接</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">duapp</span> <span class="attr">wordpress:</span> <span class="attr">http://ibruce.duapp.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="attr">javaeye:</span> <span class="attr">http://buru.iteye.com</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">oschina</span> <span class="attr">blog:</span> <span class="attr">http://my.oschina.net/buru</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">bruce</span> <span class="string">sha's</span> <span class="string">baidu</span> <span class="attr">space:</span> <span class="attr">http://hi.baidu.com/iburu</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span> <span class="comment">#是否开启fancybox效果</span></span><br><span class="line"><span class="attr">duoshuo_shortname:</span> <span class="string">buru</span> <span class="comment">#多说账号</span></span><br><span class="line"><span class="attr">google_analytics:</span></span><br><span class="line"><span class="attr">rss:</span></span><br></pre></td></tr></table></figure><p>#更新</p><p>更新hexo：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> update -g hexo</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://ibruce.info/2013/11/22/hexo-your-blog/?utm_source=tuicool" rel="external nofollow noopener noreferrer" target="_blank">hexo你的博客</a></li><li><a href="http://blog.csdn.net/lemonxq/article/details/72676005" rel="external nofollow noopener noreferrer" target="_blank">Hexo静态博客搭建+个人定制</a></li><li><a href="https://www.jianshu.com/p/cea41e5c9b2a?open_source=weibo_search" rel="external nofollow noopener noreferrer" target="_blank">hexo搭建的Github博客绑定域名</a></li><li><a href="https://www.cnblogs.com/superGG1990/p/6844952.html" rel="external nofollow noopener noreferrer" target="_blank">初次安装git配置用户名和邮箱</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC）&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>dispatch_semaphore 的使用方法</title>
    <link href="http://yoursite.com/wiki/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GCD/use-dispatch-semaphore/"/>
    <id>http://yoursite.com/wiki/IOS基础知识/GCD/use-dispatch-semaphore/</id>
    <published>2017-02-11T07:35:49.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载请注明出处 <a href="http://www.cnblogs.com/snailHL/p/3906112.html" rel="external nofollow noopener noreferrer" target="_blank">关于dispatch_semaphore的使用</a>。<br>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。<br><a id="more"></a></p><p>下面我们逐一介绍三个函数：</p><h1 id="dispatch-semaphore-create"><a href="#dispatch-semaphore-create" class="headerlink" title="dispatch_semaphore_create"></a>dispatch_semaphore_create</h1><p>dispatch_semaphore_create的声明为：</p><pre><code>dispatch_semaphore_t  dispatch_semaphore_create(long value);</code></pre><p>传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</p><h1 id="dispatch-semaphore-signal"><a href="#dispatch-semaphore-signal" class="headerlink" title="dispatch_semaphore_signal"></a>dispatch_semaphore_signal</h1><p>dispatch_semaphore_signal的声明为：</p><pre><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema)</code></pre><p>这个函数会使传入的信号量dsema的值加1；</p><h1 id="dispatch-semaphore-wait"><a href="#dispatch-semaphore-wait" class="headerlink" title="dispatch_semaphore_wait"></a>dispatch_semaphore_wait</h1><p>dispatch_semaphore_wait的声明为：</p><pre><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；</code></pre><p>这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。</p><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>dispatch_semaphore_signal的返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。<br>dispatch_semaphore_wait的返回值也为long型。当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。当其返回不为0时，表示timeout发生。　　</p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><p>在设置timeout时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。</p><pre><code>DISPATCH_TIME_NOW　　表示当前；DISPATCH_TIME_FOREVER　　表示遥远的未来；</code></pre><p>一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。利用创建dispatch_time创建dispatch_time_t类型变量的时候一般也会用到这两个变量。</p><p>dispatch_time的声明如下：</p><pre><code>dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)；</code></pre><p>其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。例如：</p><pre><code>dispatch_time_t  t = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000);</code></pre><p>表示当前时间向后延时一秒为timeout的时间。</p><h1 id="关于信号量，一般可以用停车来比喻。"><a href="#关于信号量，一般可以用停车来比喻。" class="headerlink" title="关于信号量，一般可以用停车来比喻。"></a>关于信号量，一般可以用停车来比喻。</h1><p>停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），<br>调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>代码举简单示例如下：</p><pre><code>dispatch_semaphore_t signal;signal = dispatch_semaphore_create(1);__block long x = 0;NSLog(@&quot;0_x:%ld&quot;,x);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{sleep(1);NSLog(@&quot;waiting&quot;);x = dispatch_semaphore_signal(signal);NSLog(@&quot;1_x:%ld&quot;,x);sleep(2);NSLog(@&quot;waking&quot;);x = dispatch_semaphore_signal(signal);NSLog(@&quot;2_x:%ld&quot;,x);});//    dispatch_time_t duration = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); //超时1秒//    dispatch_semaphore_wait(signal, duration);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;3_x:%ld&quot;,x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;wait 2&quot;);NSLog(@&quot;4_x:%ld&quot;,x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@&quot;wait 3&quot;);NSLog(@&quot;5_x:%ld&quot;,x);</code></pre><p>最终打印的结果为：</p><pre><code>2014-08-11 22:51:54.734 LHTest[15700:70b] 0_x:02014-08-11 22:51:54.737 LHTest[15700:70b] 3_x:02014-08-11 22:51:55.738 LHTest[15700:f03] waiting2014-08-11 22:51:55.739 LHTest[15700:70b] wait 22014-08-11 22:51:55.739 LHTest[15700:f03] 1_x:12014-08-11 22:51:55.739 LHTest[15700:70b] 4_x:02014-08-11 22:51:57.741 LHTest[15700:f03] waking2014-08-11 22:51:57.742 LHTest[15700:f03] 2_x:12014-08-11 22:51:57.742 LHTest[15700:70b] wait 32014-08-11 22:51:57.742 LHTest[15700:70b] 5_x:0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载请注明出处 &lt;a href=&quot;http://www.cnblogs.com/snailHL/p/3906112.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;关于dispatch_semaphore的使用&lt;/a&gt;。&lt;br&gt;dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。&lt;br&gt;
    
    </summary>
    
      <category term="IOS基础知识" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="GCD" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/GCD/"/>
    
    
      <category term="dispatch_semaphore GCD" scheme="http://yoursite.com/tags/dispatch-semaphore-GCD/"/>
    
  </entry>
  
  <entry>
    <title>搭建weex断点调试环境</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/weex-debug/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/weex-debug/</id>
    <published>2016-12-28T01:48:40.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。</p><a id="more"></a><p>Weex Devtools 基于 Chrome devtools 实现了 Chrome Debugging Protocol，能够使用Chrome devtools调试 Weex 项目，其主要功能分为两大部分—— Debugger 和 Inspector。若使用Devtools调试weex项目，需要搭建调试环境，包括两部分：安装weex-devtool模块、App项目中集成weex-devtool SDK。</p><h1 id="安装weex-devtool-模块"><a href="#安装weex-devtool-模块" class="headerlink" title="安装weex-devtool 模块"></a>安装weex-devtool 模块</h1><p>weex-devtool是node.js的一个模块，用来启动服务器和Chrome页面，安装weex-devtool需要使用npm安装，由于使用npm安装特别慢，有时候一点速度都没有，这里使用淘宝的镜像源，切换方法：</p><pre><code>npm install cnpm -g --registry=https://registry.npm.taobao.org</code></pre><p>切换完后，使用cnpm安装weex-devtool：</p><pre><code>cnpm install -g weex-devtool</code></pre><p>weex-devtool 的用法：</p><pre><code>weex debug [options] [we_file|bundles_dir]</code></pre><p>选项有下面几种：</p><pre><code>-h, --help           显示帮助-V, --verbose        显示debug服务器运行时的各种log-v, --version        显示版本-p, --port [port]    设置debug服务器端口号 默认为8088-e, --entry [entry]  debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码)-m, --mode [mode]    设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer</code></pre><p>启动服务和chrome页面：</p><pre><code>weex debug  </code></pre><p>输出如下：</p><pre><code>bogon:~ lijian$ weex debugstart debugger server at http://10.144.36.206:8088The websocket address for native is ws://10.144.36.206:8088/debugProxy/nativeLaunching Dev Tools...</code></pre><p>输出上面的内容，表示weex-devtool已经并启动。其中ws://10.144.36.206:8088/debugProxy/native是APP连接到Chrome的调试的地址。App集成weex-devtool-iOS后，需要使用这个地址。</p><h1 id="APP集成weex-devtool-iOS-SDK"><a href="#APP集成weex-devtool-iOS-SDK" class="headerlink" title="APP集成weex-devtool-iOS SDK"></a>APP集成weex-devtool-iOS SDK</h1><p>集成weex-devtool-iOS SDK，可以参考<a href="https://github.com/weexteam/weex-devtool-iOS/blob/master/README-zh.md" rel="external nofollow noopener noreferrer" target="_blank">weex-devtool-iOS</a>将 weex-devtool-iOS 集成到项目中。这篇文章中介绍了pod集成方法和源码集成方法。这里假设已经集成完成。直接到使用SDK的步骤。<br>在AppDelegate中添加下面的代码，就可以使APP链接到Chrome的调试环境：</p><pre><code>#import &lt;WXDevtool.h&gt;[WXDevTool setDebug:YES];[WXDevTool launchDevToolDebugWithUrl:@&quot;ws://10.144.36.206:8088/debugProxy/native&quot;];</code></pre><p>setDebug:参数为YES时，直接开启debug模式，反之关闭。launchDevToolDebugWithUrl 中的url就是在控制台启动Chrome时输出的地址。</p><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>到目前为止，环境已配置完成，可以体验下调试过程。启动App，App会连接到chrome，Chrome中会显示出连接上的APP，如下：<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome.png" alt="weex-debug-chrome"></p><p>如图所示，有两个功能debug（调试）、inspector（元素省察）。其中debug可以调试JS的代码；inspector 可以审查界面的元素。点击debuger，进入调试提示页面，界面如下：<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome1.png" alt="weex-debug-chrome"><br>界面提示：使用option+commond+j进入调试JS代码界面，点击Sources标签，左边的导航栏显示源码列表，可以切换源码。调试面板包括设置断点、单步执行、查看运行时变量值等功能。<br><img src="http://of685p9vy.bkt.clouddn.com/weex-debug-chrome2.png" alt="weex-debug-chrome"></p><p>具体详细的调试方法请参考<a href="http://weex-project.io/cn/doc/how-to/debug-with-devtools.html" rel="external nofollow noopener noreferrer" target="_blank">如何使用 Devtools 调试 Weex 页面</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。&lt;/p&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex断点调试" scheme="http://yoursite.com/tags/weex%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>weex 事件原理分析</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/event-analize/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/event-analize/</id>
    <published>2016-12-16T09:46:54.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。<br><a id="more"></a></p><h1 id="事件传递过程分析"><a href="#事件传递过程分析" class="headerlink" title="事件传递过程分析"></a>事件传递过程分析</h1><p>本节通过一段示例代码，分析事件的传递过程。如果要实现一个点击事件，只需要在模板的某个标签下添加类似的代码onclick=”clickTest”， 例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">"btn"</span> <span class="attr">onclick</span>=<span class="string">"clickTest"</span>&gt;</span>测试点击事件<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">module</span>.exports = &#123;</span></span><br><span class="line"><span class="undefined">    data: </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    methods: </span></span><br><span class="line"><span class="undefined">    &#123;</span></span><br><span class="line"><span class="actionscript">      clickTest: <span class="function"><span class="keyword">function</span> <span class="params">(e)</span> </span></span></span><br><span class="line"><span class="undefined">      &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'$event.type + $event.detail'</span>);</span></span><br><span class="line"><span class="undefined">      &#125;,</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这段代码就是给text标签添加点击事件，事件的响应函数为clickTest。weex引擎渲染上面的代码，会将text标签转化为Native的WXText组件，转化过程中会调用WXText的初始化函数，定义如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span>*)type</span><br><span class="line">                     styles:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance;</span><br></pre></td></tr></table></figure><p>定义中，参数events会传入组件包含的事件列表，也就是说，weex将text标签中的on开头的属性都当做事件，渲染JS时，传递到Native中，本例中，events的值为click，接下来继续看initWithRef:type:styles:attributes:events:weexInstance中怎么处理events的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *events;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *view;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                     styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    _events = events ? [<span class="built_in">NSMutableArray</span> arrayWithArray:events] : [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    ....     </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)view</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    [<span class="keyword">self</span> _initEvents:<span class="keyword">self</span>.events];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，在初始化文本组件WXText（WXComponent的子类）时，将事件列表保存到events属性中。当将组件添加到父视图的时候，会调用属性view的get方法，在get方法中初始化所有的事件。下面是初始化事件的代码。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (void)_initEvents:(NSArray *)events</span><br><span class="line">&#123;</span><br><span class="line">    NSArray *eventsCopy = [events copy]<span class="comment">;</span></span><br><span class="line">    for (NSString *<span class="keyword">addEventName </span>in eventsCopy) &#123;</span><br><span class="line">        [<span class="keyword">self </span>_addEventOnMainThread:<span class="keyword">addEventName];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)_addEventOnMainThread:(NSString *)<span class="keyword">addEventName</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(appear, <span class="keyword">addAppearEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(disappear, <span class="keyword">addDisappearEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(click, <span class="keyword">addClickEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(<span class="keyword">swipe, </span><span class="keyword">addSwipeEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(longpress, <span class="keyword">addLongPressEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(panstart, <span class="keyword">addPanStartEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(panmove, <span class="keyword">addPanMoveEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(panend, <span class="keyword">addPanEndEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    WX_ADD_EVENT(touchstart, <span class="keyword">addTouchStartEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchmove, <span class="keyword">addTouchMoveEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchend, <span class="keyword">addTouchEndEvent)</span></span><br><span class="line"><span class="keyword"> </span>   WX_ADD_EVENT(touchcancel, <span class="keyword">addTouchCancelEvent)</span></span><br><span class="line"><span class="keyword"> </span>   </span><br><span class="line">    [<span class="keyword">self </span><span class="keyword">addEvent:addEventName];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">#define </span>WX_ADD_EVENT(eventName, <span class="keyword">addSelector) </span>\</span><br><span class="line"><span class="symbol">if</span> ([<span class="keyword">addEventName </span>isEqualToString:<span class="comment">@#eventName]) &#123;\</span></span><br><span class="line">    [<span class="keyword">self </span><span class="keyword">addSelector];\</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">- </span>(void)<span class="keyword">addClickEvent</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="meta">if</span> (!_tapGesture) &#123;</span><br><span class="line">        _tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:<span class="keyword">self </span>action:<span class="comment">@selector(onClick:)];</span></span><br><span class="line">        _tapGesture.delegate = <span class="keyword">self;</span></span><br><span class="line"><span class="keyword"> </span>       [<span class="keyword">self.view </span><span class="keyword">addGestureRecognizer:_tapGesture];</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明初始化事件就是给文本组件的view属性添加一个点击手势tapGesture， 手势的响应函数为onClick。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onClick:(__unused <span class="built_in">UITapGestureRecognizer</span> *)recognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *position = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGRectEqualToRect</span>(<span class="keyword">self</span>.calculatedFrame, <span class="built_in">CGRectZero</span>)) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> frame = [<span class="keyword">self</span>.view.superview convertRect:<span class="keyword">self</span>.calculatedFrame toView:<span class="keyword">self</span>.view.window];</span><br><span class="line">        position[<span class="string">@"x"</span>] = @(frame.origin.x);</span><br><span class="line">        position[<span class="string">@"y"</span>] = @(frame.origin.y);</span><br><span class="line">        position[<span class="string">@"width"</span>] = @(frame.size.width);</span><br><span class="line">        position[<span class="string">@"height"</span>] = @(frame.size.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> fireEvent:<span class="string">@"click"</span> params:@&#123;<span class="string">@"position"</span>:position&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> fireEvent:eventName params:params domChanges:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)fireEvent:(<span class="built_in">NSString</span> *)eventName params:(<span class="built_in">NSDictionary</span> *)params domChanges:(<span class="built_in">NSDictionary</span> *)domChanges</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> timeSp = [[<span class="built_in">NSDate</span> date] timeIntervalSince1970] * <span class="number">1000</span>;</span><br><span class="line">    [dict setObject:@(timeSp) forKey:<span class="string">@"timestamp"</span>];</span><br><span class="line">    <span class="keyword">if</span> (params) &#123;</span><br><span class="line">        [dict addEntriesFromDictionary:params];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [[WXSDKManager bridgeMgr] fireEvent:<span class="keyword">self</span>.weexInstance.instanceId ref:<span class="keyword">self</span>.ref type:eventName params:dict domChanges:domChanges];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明：在手势响应函数中，最后调用weex的WXBridgeManager中的fireEvent函数。代码如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)fireEvent:(<span class="type">NSString</span> *)instanceId ref:(<span class="type">NSString</span> *)ref <span class="class"><span class="keyword">type</span>:(<span class="type">NSString</span> *)<span class="keyword">type</span> params:(<span class="type">NSDictionary</span> *)params domChanges:(<span class="type">NSDictionary</span> *)domChanges</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="class"><span class="keyword">type</span> || !ref) &#123;</span></span><br><span class="line"><span class="class">        <span class="type">WXLogError</span>(@"<span class="type">Event</span> <span class="title">type</span> <span class="title">and</span> <span class="title">component</span> <span class="title">ref</span> <span class="title">should</span> <span class="title">not</span> <span class="title">be</span> <span class="title">nil</span>");</span></span><br><span class="line"><span class="class">        <span class="title">return</span>;</span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">NSArray</span> *args = @[ref, <span class="class"><span class="keyword">type</span>, params?:@&#123;&#125;, domChanges?:@&#123;&#125;];</span></span><br><span class="line">    <span class="type">NSMutableDictionary</span> *methodDict = [<span class="type">NSMutableDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                                       @<span class="string">"fireEvent"</span>, @<span class="string">"method"</span>,</span><br><span class="line">                                       args, @<span class="string">"args"</span>, nil];</span><br><span class="line">    <span class="type">WXBridgeMethod</span> *method = [[<span class="type">WXBridgeMethod</span> alloc] initWithInstance:instanceId <span class="class"><span class="keyword">data</span>:methodDict];</span></span><br><span class="line">    [self executeJsMethod:method];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)executeJsMethod:(<span class="type">WXBridgeMethod</span> *)method</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!method) return;</span><br><span class="line">    </span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    <span class="type">WXPerformBlockOnBridgeThread</span>(^()&#123;</span><br><span class="line">        [weakSelf.bridgeCtx executeJsMethod:method];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码说明： fireEvent实际上就是执行JS的fireEvent函数，JS的fireEvent函数会根据传递的参数找到组件、组件的事件、事件响应函数，最后执行事件。本例中就是第一段JS代码的clickTest函数。其中传递的参数本例如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    args =(</span><br><span class="line">    <span class="comment">///ref（组件的标记）</span></span><br><span class="line">        <span class="number">5</span>, </span><br><span class="line">        <span class="comment">///type（事件类型）</span></span><br><span class="line">        <span class="built_in">click</span>, </span><br><span class="line">        <span class="comment">///params   </span></span><br><span class="line">        &#123;   <span class="comment">///事件触发的位置</span></span><br><span class="line">            <span class="built_in">position</span> =&#123;</span><br><span class="line">                <span class="built_in">height</span> = <span class="string">"39.5"</span>;</span><br><span class="line">                <span class="built_in">width</span> = <span class="number">768</span>;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">                y = <span class="number">64</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            timestamp = <span class="string">"1481882724298.018"</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">///domChanges（是否更新界面）</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">///JS的方法</span></span><br><span class="line">    method = fireEvent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，weex的事件传递机制讲完了，下面做个简单的总结。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>weex的事件处理机制是： 在JS中定义标签的事件类型、事件的处理函数，在Native实现事件。原理是：将标签初始化为组件的时候，初始化标签的事件。其中click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel初始化为手势事件，appear、disappear初始化为滑动视图的出现事件和消息事件。当事件触发时，通过WXBridgeManager调用JS的fireEvent函数，在JS中调用标签的事件处理函数。下面是做了一张大概的原理图。<br><img src="http://of685p9vy.bkt.clouddn.com/weex-event-detail1.png" alt="weex-event-detail1"><br>图中红色部分是JS逻辑，黑色部分是组件的逻辑，蓝色部分是WXBridgeManager逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。&lt;br&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>weex 通信原理分析</title>
    <link href="http://yoursite.com/wiki/Hybird/weex/weex-conmunication/"/>
    <id>http://yoursite.com/wiki/Hybird/weex/weex-conmunication/</id>
    <published>2016-12-13T10:01:31.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文首先简单阐述了JavaScriptCore中JS和Native的通信机制，在此基础上，分析了weex中的JS和Native的通信机制。<br><a id="more"></a></p><h2 id="万物之源-JavaScriptCore"><a href="#万物之源-JavaScriptCore" class="headerlink" title="万物之源 -JavaScriptCore"></a>万物之源 -JavaScriptCore</h2><p>不论是RN、weex、JSPatch，他们的核心交互机制都使用JavaScriptCore，通过它完成JS和Native的通信。关于JavaScriptCore的简单介绍可以参考<br><a href="http://blog.csdn.net/lizhongfu2013/article/details/9232129" rel="external nofollow noopener noreferrer" target="_blank">IOS7开发～JavaScriptCore （一）</a>，这里只简单提及下。</p><h3 id="关键类-JSContext、JSValue"><a href="#关键类-JSContext、JSValue" class="headerlink" title="关键类-JSContext、JSValue"></a>关键类-JSContext、JSValue</h3><p>JavaScriptCore中的两个关键类：</p><ol><li>JSContext(JS脚本的执行环境)</li><li>JSValue（JS 和Native传值的载体）</li></ol><p>JSContext 的核心方法- (JSValue <em>)evaluateScript:(NSString </em>)script;，功能是执行JS脚本代码，执行完后，会将JS中的对象、方法添加到JSContext上下文中的全局对象中。这样就可以通过JSContext引用到JS代码中的对象、方法。</p><p>JSValue是用来呈现JS的对象，它可以将JS中的对象、方法转化为Native的对象、函数，反之亦然。下面是JSValue的两个核心方法：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (JSValue *)callWithArguments:(NSArray *)arguments; </span><br><span class="line">- (JSValue *)invokeMethod:(NSString *)<span class="function"><span class="keyword">method</span> </span></span><br><span class="line"><span class="function">            <span class="title">withArguments</span>:</span>(NSArray *)arguments;</span><br></pre></td></tr></table></figure><p>如果JSValue实例代表JS中一个函数变量（变量中存储的是函数），用callWithArguments调用JS的函数。如果拿到了JS代码的执行环境的全局对象，可以向全局对象发送invokeMethod消息调用JS中的函数。参数包括JS的函数名称、调用参数。</p><h3 id="Native调用JS机制"><a href="#Native调用JS机制" class="headerlink" title="Native调用JS机制"></a>Native调用JS机制</h3><p>可以使用JSValue 的callWithArguments 和 invokeMethod方法 单独调用JS中的某个函数 。<br>也可以使用JSContext 的evaluateScript方法执行整个JS代码。下面给出一个例子，其中，test.js的内容如下 </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///匿名函数</span></span><br><span class="line"><span class="keyword">var</span> functionVar = <span class="function"><span class="keyword">function</span><span class="params">(num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsFucton</span><span class="params">(num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsFucton(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>测试代码如下： </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-(void) nativeCallJS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="symbol">NSString</span> *path = [[<span class="symbol">NSBundle</span> mainBundle]pathForResource:@<span class="string">"test"</span>ofType:@<span class="string">"js"</span>];</span><br><span class="line">    <span class="symbol">NSString</span> *testScript = [<span class="symbol">NSString</span> stringWithContentsOfFile:path encoding:<span class="symbol">NSUTF8StringEncoding</span> error:nil];</span><br><span class="line">    <span class="symbol">JSContext</span> *jsContext = [[<span class="symbol">JSContext</span> alloc] init];</span><br><span class="line">    ///<span class="number">1.</span>执行整个<span class="symbol">JS</span>代码</span><br><span class="line">    <span class="symbol">JSValue</span> *resultEvaluate =[jsContext evaluateScript:testScript];</span><br><span class="line">    <span class="symbol">NSLog</span>(@<span class="string">"resultEvaluate = %@"</span>,[resultEvaluate toObject]);</span><br><span class="line">    </span><br><span class="line">    ///<span class="number">2.</span> callWithArguments 调用方式</span><br><span class="line">    <span class="symbol">JSValue</span> *fuctionVar =  jsContext[@<span class="string">"functionVar"</span>];</span><br><span class="line">    <span class="symbol">JSValue</span> *resultVar = [fuctionVar callWithArguments:@[@(<span class="number">4</span>)]];</span><br><span class="line">    <span class="symbol">NSLog</span>(@<span class="string">"resultVar = %@"</span>,[resultVar toObject]);</span><br><span class="line">    </span><br><span class="line">    ///<span class="number">3.</span> invokeMethod 调用方式</span><br><span class="line">    <span class="symbol">JSValue</span> *resultFuction = [[jsContext globalObject] invokeMethod:@<span class="string">"jsFucton"</span> withArguments:@[@(<span class="number">6</span>)]];</span><br><span class="line">    <span class="symbol">NSLog</span>(@<span class="string">"resultFuction = %@"</span>,[resultFuction toObject]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2016-12-14</span> <span class="number">13:36:27.237</span> Test<span class="number">2222[15246</span>:<span class="number">172495</span>] resultEvaluate = <span class="number">3</span></span><br><span class="line"><span class="number">2016-12-14</span> <span class="number">13:36:27.238</span> Test<span class="number">2222[15246</span>:<span class="number">172495</span>] resultVar = <span class="number">5</span></span><br><span class="line"><span class="number">2016-12-14</span> <span class="number">13:36:30.166</span> Test<span class="number">2222[15246</span>:<span class="number">172495</span>] resultFuction = <span class="number">7</span></span><br></pre></td></tr></table></figure><p>例子中展示了使用JSContext的evaluateScript:方法执行整个JS代码，调用完evaluateScript之后，会将JS代码中的变量、方法添加到jsContext的全局对象中，这样可以使用jsContext[@”functionVar”]访问到JS中的functionVar对象。在JS中，functionVar是一个函数对象，可以向fuctionVar发送callWithArguments消息，执行JS中的functionVar变量中存储的函数。同时也可以使用[[jsContext globalObject] invokeMethod:@”jsFucton” withArguments:@[@(6)]]调用到JS中的jsFucton函数。 上面是Native调用JS的三种方式。每种方式使用的场景不同。</p><h3 id="JS调用Native机制"><a href="#JS调用Native机制" class="headerlink" title="JS调用Native机制"></a>JS调用Native机制</h3><p>JS调用Native有两种方式：</p><ol><li>block</li><li>JSExport</li></ol><p>主要介绍Block方式，因为weex中使用的是Block方式，直接以代码为例：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">NSString</span> *) nativeFuction:(<span class="built_in">NSString</span> *) strParam1 param2:(<span class="built_in">NSString</span> *)strParam2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@_%@"</span>,strParam1,strParam2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>) JSCallNative</span><br><span class="line">&#123;</span><br><span class="line">    JSContext *jsContext = [[JSContext alloc] init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///给JS添加一个方法，JS就能调用到Native的方法</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    jsContext[<span class="string">@"jsMethod"</span>] = ^(<span class="built_in">NSString</span> * strParam1, <span class="built_in">NSString</span> *strParam2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span> * strResult =  [weakSelf nativeFuction:strParam1 param2:strParam2];</span><br><span class="line">        <span class="keyword">return</span> strResult;</span><br><span class="line">    &#125;;</span><br><span class="line">    JSValue *strResult = [jsContext evaluateScript:<span class="string">@"jsMethod('这是第一个参数','这是第二个参数')"</span>];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"strResult = %@"</span>,[strResult toObject]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： strResult = 这是第一个参数_这是第二个参数</p><p>在Native中block相当于JS中的function，jsContext[@”jsMethod”]=…相当于给JS添加一个名为jsMethod的function，不过，这个jsMethod的实现是Native的代码。在JS中执行jsMethod方法，就会调用到Native的代码。 </p><h3 id="小小结"><a href="#小小结" class="headerlink" title="小小结"></a>小小结</h3><p>了解了JSContext、JSValue、Native和JS的交互机制，是看懂weex的前提。不论weex如何封装，都离不开上面的基本原理。<br>Native调用JS有三种方式：</p><ol><li>JSValue 的callWithArguments</li><li>JSValue的invokeMethod</li><li>JSContext的evaluateScript</li></ol><p>JS调用Native有两种方式</p><ol><li>block</li><li><p>JSExport</p><h2 id="刨根问底-weex的交互机制"><a href="#刨根问底-weex的交互机制" class="headerlink" title="刨根问底-weex的交互机制"></a>刨根问底-weex的交互机制</h2><p>这一节我一步步的分析weex的通信原理，目标两个：</p></li><li>了解weex通信原理</li><li>了解通信原理相关的两个重要部分Module、Bridge。</li></ol><p>具体的思路是找到SDK初始化的入口，顺着入口逐渐深入分析。直到了解weex的通信机制为止。</p><h3 id="寻踪觅迹-分析初始化"><a href="#寻踪觅迹-分析初始化" class="headerlink" title="寻踪觅迹- 分析初始化"></a>寻踪觅迹- 分析初始化</h3><p>weex SDK的入口是WXSDKEngine类，WXSDKEngine 是一个全局类。其中，initSDKEnviroment:完成sdk的初始化工作：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (void)initSDKEnviroment:(NSString *)<span class="keyword">script</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span>   [self _registerDefaultComponents]<span class="comment">;</span></span><br><span class="line">    [self _registerDefaultModules]<span class="comment">;</span></span><br><span class="line">    [self _registerDefaultHandlers]<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">    [[WXSDKManager <span class="keyword">bridgeMgr] </span>executeJsFramework:<span class="keyword">script];</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>weex有中有三个重要的部分：Components、Modules、Handlers。<br>Components 是布局Native界面的元素，例如UILabel对应的组件是WXTextComponent，他和html元素text对应。<br>Modules是Native的功能模块，是JS可以访问的Native类。应该封装了必须有Native完成的功能。<br>我们主要关注Modules模块，他是weex中Native和JS通信的核心部分。_registerDefaultModules是注册默认的Module：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)_registerDefaultModules</span><br><span class="line">&#123;</span><br><span class="line">    [self <span class="string">registerModule:</span>@<span class="string">"dom"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXDomModule"</span>)];</span><br><span class="line">    [self <span class="string">registerModule:</span>@<span class="string">"navigator"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXNavigatorModule"</span>)];</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是注册weex提供给开发者的默认模块。每个模块都实现某种功能，<font color="red" size="4" face="黑体">它是JS可以调用的Native类</font>。接着分析registerModule函数： </p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)<span class="string">registerModule:</span>(NSString *)name <span class="string">withClass:</span>(Class)clazz</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">///注册native的module</span></span><br><span class="line">    NSString *moduleName = [WXModuleFactory <span class="string">registerModule:</span>name <span class="string">withClass:</span>clazz];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///组成JS的module</span></span><br><span class="line">    NSDictionary *dict = [WXModuleFactory <span class="string">moduleMethodMapsWithName:</span>moduleName];</span><br><span class="line">    [[WXSDKManager bridgeMgr] <span class="string">registerModules:</span>dict];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码完成两个功能，初始化Native端Module的配置信息、初始化JS端Module的配置信息。到目前为止，我们已经找到了weex的入口，后续部分需要分两个单独的模块分析讲解。一个是Module，一个是通信机制。</p><h3 id="刨根问底-配置信息和Module"><a href="#刨根问底-配置信息和Module" class="headerlink" title="刨根问底-配置信息和Module"></a>刨根问底-配置信息和Module</h3><p>Module 相关的类有WXModuleFactory、WXModuleManager、WXModuleProtocol。三个类的类图如下：<br><img src="http://of685p9vy.bkt.clouddn.com/weex_Module.png" alt="weex-module"><br>WXModuleManager只有一个方法，-dispatchMethod:(WXBridgeMethod *)method，根据传入的method在配置文件中找到方法并执行。<br>WXModuleFactory是Module的工厂类，存储着所有Module的配置信息。<br>WXModuleProtocol是Module需要遵守的协议。只有遵守了WXModuleProtocol协议的Native类才叫做Module，他才会被添加到Native和JS的配置信息中，这样JS就可以调用到这个类中的方法。这里贴出WXModuleProtocol的代码如下：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///1. 定义了module JS 回调native的方法  </span></span><br><span class="line"><span class="selector-tag">typedef</span> <span class="selector-tag">void</span> (^WXModuleCallback)(id result);</span><br><span class="line"><span class="selector-tag">typedef</span> <span class="selector-tag">void</span> (^WXModuleKeepAliveCallback)(id result, BOOL keepAlive);</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">WX_EXPORT_METHOD</span>(method) \</span><br><span class="line">+ (NSString *)<span class="selector-tag">WX_CONCAT_WRAPPER</span>(wx_export_method_, __LINE__) &#123; \</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">NSStringFromSelector</span>(method); \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///2. 导出类</span></span><br><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">WX_EXPORT_MODULE</span>(module)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///3. 导出方法 (其实是定义了一个类方法 )</span></span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">getNetUrl</span>:<span class="attribute">page</span>:<span class="attribute">sucCallBack</span>:<span class="attribute">failCallBack</span>:)) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">///4. 执行方法的线程</span></span><br><span class="line"><span class="selector-tag">-</span> (NSThread *)<span class="selector-tag">targetExecuteThread</span>;</span><br><span class="line"></span><br><span class="line">@<span class="selector-tag">property</span> (nonatomic, weak) <span class="selector-tag">WXSDKInstance</span> *<span class="selector-tag">weexInstance</span>;</span><br></pre></td></tr></table></figure><p>主要有三部分：</p><ol><li>定义回调</li><li>定义导出Native方法的方法</li><li>定义Native方法的执行线程。</li></ol><p>回调就是JS执行完Native代码后，可以回调的JS的代码。定义导出方法就是：给每个导出方法定义一个类方法，类方法的名字大概就是wx_export_method_100这种样式，返回导出的方法名称。这样做的目的就是不用初始化Module类，就能获取到Module的导出方法信息，并加入到两端的配置信息中。<br>targetExecuteThread是定义了所有的导出方法执行的线程。如果没有实现，默认在主线程执行方法。如果实现，返回对应的线程，就在该线程中执行方法。<br>到目前为止，Native端的Module配置信息都讲完了。总结为：配置信息中包括了所有Module的导出方法、Module的名称、对应的类。<br>接下来简单分析下JS端的配置信息。注册Module的信息到JS，调用的是WXBridgeManager的registerModules 方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerModules:(<span class="built_in">NSDictionary</span> *)modules</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!modules) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    WXPerformBlockOnBridgeThread(^()&#123;</span><br><span class="line">        [weakSelf.bridgeCtx registerModules:modules];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerModules: 调用了WXBridgeContext中的registerModules:方法，代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">registerModules:</span>(NSDictionary *)modules</span><br><span class="line">&#123;</span><br><span class="line">    [self <span class="string">callJSMethod:</span>@<span class="string">"registerModules"</span> <span class="string">args:</span>@[modules]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部调用了JS中的方法registerModules，下面转入到main.js，registerModules代码如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerModules</span>(</span>modules)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((typeof modules===<span class="string">"undefined"</span>?<span class="string">"undefined"</span>:_typeof(modules))===<span class="string">"object"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        (<span class="number">0</span>,_register.initModules)(modules)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initModules</span>(</span>modules,ifReplace)</span><br><span class="line">&#123;</span><br><span class="line">    var _loop=<span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(</span>moduleName)</span><br><span class="line">    &#123;</span><br><span class="line">        var methods=nativeModules[moduleName];</span><br><span class="line">        <span class="keyword">if</span>(!methods)</span><br><span class="line">        &#123;</span><br><span class="line">            methods=&#123;&#125;;</span><br><span class="line">            nativeModules[moduleName]=methods</span><br><span class="line">        &#125;</span><br><span class="line">        modules[moduleName].forEach(</span><br><span class="line">                                    <span class="function"><span class="keyword">function</span>(</span><span class="function"><span class="keyword">method</span>)</span></span><br><span class="line">                                    &#123;</span><br><span class="line">                                        <span class="keyword">if</span>(typeof <span class="function"><span class="keyword">method</span>=</span>==<span class="string">"string"</span>)</span><br><span class="line">                                        &#123;</span><br><span class="line">                                            <span class="function"><span class="keyword">method</span>=</span>&#123;name:<span class="function"><span class="keyword">method</span>&#125;</span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">if</span>(!methods[<span class="function"><span class="keyword">method</span>.<span class="title">name</span>]||<span class="title">ifReplace</span>)</span></span><br><span class="line">                                        &#123;</span><br><span class="line">                                            methods[<span class="function"><span class="keyword">method</span>.<span class="title">name</span>]=</span><span class="function"><span class="keyword">method</span></span></span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(var moduleName in modules)</span><br><span class="line">    &#123;</span><br><span class="line">        _loop(moduleName)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概可以理解为：JS中有个nativeModules变量，这个对象保存着module名称和对应的方法列表。注册就是向nativeModules中添加Module的信息。</p><h3 id="终极目标-Bridge-通信机制"><a href="#终极目标-Bridge-通信机制" class="headerlink" title="终极目标-Bridge(通信机制)"></a>终极目标-Bridge(通信机制)</h3><p>接下来了解如何利用这些配置信息完成JS和Native之间的交互。交互就需要一个桥梁，在weex中用Bridge表示。Bridge封装了交互的规则，主要有几个类WXBridgeManager、WXBridgeProtocol、WXBridgeMethod、WXJSCoreBridge、WXBridgeContext。<br>首先将这几个类的类图贴出来：<br><img src="http://of685p9vy.bkt.clouddn.com/weex-bridge.png" alt="bridge类图"><br>WXBridgeManager是Brider的管理类，承接着Native和JS的交互、调试管理、界面更新、事件传递等任务。具体干活的类是WXBridgeContext和WXJSCoreBridge，其中WXJSCoreBridge是遵守了WXBridgeProtocol协议的类。</p><p>图中红色的代码完成Native和JS交互功能的代码。交互分为两部分：JS到Native、Native到JS。首先分析Native到JS这个路径。<br>executeJsMethod: 是Native调用JS的入口方法。内部调用了WXJSCoreBridge的callJSMethod方法，传递的JS方法名是callJS。具体的代码如下：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (void)executeJsMethod:(WXBridgeMethod *)<span class="function"><span class="keyword">method</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ....</span></span></span><br><span class="line"><span class="function"><span class="comment">    [sendQueue addObject:method];</span></span></span><br><span class="line"><span class="function"><span class="comment">    [self performSelector:@selector(_sendQueueLoop) withObject:nil];</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">- <span class="params">(void)</span>_<span class="title">sendQueueLoop</span></span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    ///构造方法的相关参数</span></span></span><br><span class="line"><span class="function"><span class="comment">    ....</span></span></span><br><span class="line"><span class="function"><span class="comment">    </span></span></span><br><span class="line"><span class="function"><span class="comment">    ///调用方法</span></span></span><br><span class="line"><span class="function"><span class="comment">    if ([methods count] &gt; 0 &amp;&amp; execIns) &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        [self callJSMethod:@"callJS" args:@[execIns, methods]];</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(hasTask)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">        [self performSelector:@selector(_sendQueueLoop) withObject:nil];</span></span></span><br><span class="line"><span class="function"><span class="comment">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">- <span class="params">(void)</span><span class="title">callJSMethod</span>:</span>(NSString *)<span class="function"><span class="keyword">method</span> <span class="title">args</span>:</span>(NSArray *)args</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    if (self.frameworkLoadFinished) &#123;</span></span><br><span class="line"><span class="comment">        [self.jsBridge callJSMethod:method args:args];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">        [_methodQueue addObject:@&#123;@"method":method, @"args":args&#125;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///WXJSCoreBridge  的callJSMethod方法</span></span><br><span class="line">- (JSValue *)callJSMethod:(NSString *)<span class="function"><span class="keyword">method</span> <span class="title">args</span>:</span>(NSArray *)args</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    WXLogDebug(@"Calling JS... method:%@, args:%@", method, args);</span></span><br><span class="line"><span class="comment">    return [[_jsContext globalObject] invokeMethod:method withArguments:args];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><p>上面是Native调用JS的原理 ，下面分析JS调用Native的原理。</p><p>当首次调用- (id<wxbridgeprotocol>)jsBridge方法创建Bridge时，会调用Bridge的registerCallNativeJS设置JS调用Native的入口。入口名称为callNative，即JS代码中调用callNative函数，就能调用到Native的代码。当进入Native后，会调用WXBridgeContext的invokeNative方法，内部会查找配置信息，然后invoke相应的方法。代码如下：</wxbridgeprotocol></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>&lt;WXBridgeProtocol&gt;)jsBridge</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    _jsBridge = _debugJS ? [<span class="built_in">NSClassFromString</span>(<span class="string">@"WXDebugger"</span>) alloc] : [[WXJSCoreBridge alloc] init];</span><br><span class="line">     __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    [_jsBridge registerCallNative:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback) &#123;</span><br><span class="line">        <span class="keyword">return</span> [weakSelf invokeNative:instance tasks:tasks callback:callback];</span><br><span class="line">    &#125;];</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">return</span> _jsBridge;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^(JSValue *instance, JSValue *tasks, JSValue *callback)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceId = [instance toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *tasksArray = [tasks toArray];</span><br><span class="line">        <span class="built_in">NSString</span> *callbackId = [callback toString];</span><br><span class="line">        <span class="keyword">return</span> callNative(instanceId, tasksArray, callbackId);</span><br><span class="line">    &#125;;</span><br><span class="line">    _jsContext[<span class="string">@"callNative"</span>] = callNativeBlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)invokeNative:(<span class="built_in">NSString</span> *)instance tasks:(<span class="built_in">NSArray</span> *)tasks callback:(<span class="built_in">NSString</span> *)callback</span><br><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">    <span class="comment">///批量调用方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        WXBridgeMethod *method = [[WXBridgeMethod alloc] initWihData:task];</span><br><span class="line">        method.instance = instance;</span><br><span class="line">        [[WXSDKManager moduleMgr] dispatchMethod:method];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///下面是处理回调的</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *sendQueue = [<span class="keyword">self</span>.sendQueue valueForKey:instance];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![callback isEqualToString:<span class="string">@"undefined"</span>] &amp;&amp; ![callback isEqualToString:<span class="string">@"-1"</span>] &amp;&amp; callback) &#123;</span><br><span class="line">        WXBridgeMethod *method = [<span class="keyword">self</span> _methodWithCallback:callback];</span><br><span class="line">        method.instance = instance;</span><br><span class="line">        [sendQueue addObject:method];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_sendQueueLoop) withObject:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图中蓝色代码是Native直接调用JS的函数，分别为： createInstance、destroyInstance、refreshInstance、registerModules、registerComponents。具体的功能在JS那边。这里不做了解。</p><h2 id="归纳总结"><a href="#归纳总结" class="headerlink" title="归纳总结"></a>归纳总结</h2><p>weex的JS和Native通信原理可以使用下面图简单描述：<br><img src="http://of685p9vy.bkt.clouddn.com/weex_JS_Native.png" alt="JS_Native"><br>在weexSDK初始化的时候，完成JS端和Native端的配置信息。JS端的配置信息的作用应该是确保什么样的Native方法可以在JS中调用；Native配置信息的作用是：当JS调用到Native的方法，需要查找调用的Module、方法、方法的SEL等信息，这样才能invoke到相应的方法。weex这样设计的原因大概是为了统一管理JS和Native的通信机制，假如，有许多Native的方法可以被JS调用，那么就需要配置很多的入口，这样随着代码的增加，无法有效维护，weex借助配置信息，巧妙的将入口控制为两个，一个是JS到Native的入口为callNative，一个是Native到JS的入口为callJS。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文首先简单阐述了JavaScriptCore中JS和Native的通信机制，在此基础上，分析了weex中的JS和Native的通信机制。&lt;br&gt;
    
    </summary>
    
      <category term="Hybird" scheme="http://yoursite.com/categories/Hybird/"/>
    
      <category term="weex" scheme="http://yoursite.com/categories/Hybird/weex/"/>
    
    
      <category term="weex" scheme="http://yoursite.com/tags/weex/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://yoursite.com/wiki/%E5%B7%A5%E5%85%B7/git/git%E7%AE%80%E7%95%A5%E7%89%88/git%E7%AE%80%E7%95%A5%E7%89%88/"/>
    <id>http://yoursite.com/wiki/工具/git/git简略版/git简略版/</id>
    <published>2016-12-13T10:01:31.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>git 简略笔记<br><a id="more"></a></p><h1 id="Git笔记"><a href="#Git笔记" class="headerlink" title=" Git笔记 "></a><p align="center"> Git笔记 </p></h1><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><ul><li>Git是分布式版本控制系统</li><li>集中式VS分布式，SVN VS Git<ol><li>SVN和Git主要的区别在于历史版本维护的位置</li><li>Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。</li><li>这样的好处在于：<ul><li>自己可以在脱机环境查看开发的版本历史。</li><li>多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。<h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git config --global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li></ul><p><code>git config</code>命令的<code>--global</code>参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。</p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><h4 id="初始化一个Git仓库"><a href="#初始化一个Git仓库" class="headerlink" title="初始化一个Git仓库"></a>初始化一个Git仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="添加文件到Git仓库"><a href="#添加文件到Git仓库" class="headerlink" title="添加文件到Git仓库"></a>添加文件到Git仓库</h4><p>包括两步：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add &lt;file&gt;</span><br><span class="line">$ git commit -m <span class="string">"description"</span></span><br></pre></td></tr></table></figure></p><p><code>git add</code>可以反复多次使用，添加多个文件，<code>git commit</code>可以一次提交很多文件，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容。</p><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h3 id="查看修改内容"><a href="#查看修改内容" class="headerlink" title="查看修改内容"></a>查看修改内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff --cached</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git diff HEAD -- &lt;file&gt;</span><br></pre></td></tr></table></figure><ul><li><code>git diff</code> 可以查看工作区(work dict)和暂存区(stage)的区别</li><li><code>git diff --cached</code> 可以查看暂存区(stage)和分支(master)的区别</li><li><code>git diff HEAD -- &lt;file&gt;</code> 可以查看工作区和版本库里面最新版本的区别<h3 id="查看提交日志"><a href="#查看提交日志" class="headerlink" title="查看提交日志"></a>查看提交日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure></li></ul><p>简化日志输出信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br></pre></td></tr></table></figure></p><h3 id="查看命令历史"><a href="#查看命令历史" class="headerlink" title="查看命令历史"></a>查看命令历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>以上命令是返回上一个版本，在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本是<code>HEAD^^</code>，往上100个版本写成<code>HEAD~100</code>。</p><h3 id="回退指定版本号"><a href="#回退指定版本号" class="headerlink" title="回退指定版本号"></a>回退指定版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard commit_id</span><br></pre></td></tr></table></figure><p>commit_id是版本号，是一个用SHA1计算出的序列</p><h3 id="工作区、暂存区和版本库"><a href="#工作区、暂存区和版本库" class="headerlink" title="工作区、暂存区和版本库"></a>工作区、暂存区和版本库</h3><p>工作区：在电脑里能看到的目录；<br>版本库：在工作区有一个隐藏目录<code>.git</code>，是Git的版本库。<br>Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的<code>master</code>，以及指向<code>master</code>的指针<code>HEAD</code>。</p><p><img src="./git-simple/0.jpg" alt="理解"></p><p>进一步解释一些命令：</p><ul><li><code>git add</code>实际上是把文件添加到暂存区</li><li><code>git commit</code>实际上是把暂存区的所有内容提交到当前分支<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="丢弃工作区的修改"><a href="#丢弃工作区的修改" class="headerlink" title="丢弃工作区的修改"></a>丢弃工作区的修改</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li></ul><p>该命令是指将文件在工作区的修改全部撤销，这里有两种情况：</p><ol><li>一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li><li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li></ol><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h4 id="丢弃暂存区的修改"><a href="#丢弃暂存区的修改" class="headerlink" title="丢弃暂存区的修改"></a>丢弃暂存区的修改</h4><p>分两步：<br>第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>第二步，撤销工作区的修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- &lt;file&gt;</span><br></pre></td></tr></table></figure></p><p>小结：</p><ol><li>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- &lt;file&gt;</code>。</li><li><p>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了第一步，第二步按第一步操作。</p></li><li><p>已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。</p></li></ol><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p><code>git rm &lt;file&gt;</code>相当于执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ rm &lt;file&gt;</span><br><span class="line">$ git add &lt;file&gt;</span><br></pre></td></tr></table></figure></p><h4 id="进一步的解释"><a href="#进一步的解释" class="headerlink" title="进一步的解释"></a>进一步的解释</h4><p>Q：比如执行了<code>rm text.txt</code> 误删了怎么恢复？<br>A：执行<code>git checkout -- text.txt</code> 把版本库的东西重新写回工作区就行了<br>Q：如果执行了<code>git rm text.txt</code>我们会发现工作区的text.txt也删除了，怎么恢复？<br>A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset head text.txt</span><br><span class="line">$ git checkout -- text.txt</span><br></pre></td></tr></table></figure></p><p>Q：如果真的想从版本库里面删除文件怎么做？<br>A：执行<code>git commit -m &quot;delete text.txt&quot;</code>，提交后最新的版本库将不包含这个文件</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="创建SSH-Key"><a href="#创建SSH-Key" class="headerlink" title="创建SSH Key"></a>创建SSH Key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span><br></pre></td></tr></table></figure><h4 id="关联远程仓库"><a href="#关联远程仓库" class="headerlink" title="关联远程仓库"></a>关联远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/username/repositoryname.git</span><br></pre></td></tr></table></figure><h4 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><code>-u</code> 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改。</p><h4 id="从远程克隆"><a href="#从远程克隆" class="headerlink" title="从远程克隆"></a>从远程克隆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/usern/repositoryname.git</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个*号。</p><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="创建-切换分支"><a href="#创建-切换分支" class="headerlink" title="创建+切换分支"></a>创建+切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="合并某分支到当前分支"><a href="#合并某分支到当前分支" class="headerlink" title="合并某分支到当前分支"></a>合并某分支到当前分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用<code>git log --graph</code>命令可以看到分支合并图。</p><h4 id="普通模式合并分支"><a href="#普通模式合并分支" class="headerlink" title="普通模式合并分支"></a>普通模式合并分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge --no-ff -m <span class="string">"description"</span> &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。</p><h4 id="保存工作现场"><a href="#保存工作现场" class="headerlink" title="保存工作现场"></a>保存工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure><h4 id="查看工作现场"><a href="#查看工作现场" class="headerlink" title="查看工作现场"></a>查看工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure><h4 id="恢复工作现场"><a href="#恢复工作现场" class="headerlink" title="恢复工作现场"></a>恢复工作现场</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h4 id="丢弃一个没有合并过的分支"><a href="#丢弃一个没有合并过的分支" class="headerlink" title="丢弃一个没有合并过的分支"></a>丢弃一个没有合并过的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -D &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h4 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><h4 id="在本地创建和远程分支对应的分支"><a href="#在本地创建和远程分支对应的分支" class="headerlink" title="在本地创建和远程分支对应的分支"></a>在本地创建和远程分支对应的分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b branch-name origin/branch-name，</span><br></pre></td></tr></table></figure><p>本地和远程分支的名称最好一致；</p><h4 id="建立本地分支和远程分支的关联"><a href="#建立本地分支和远程分支的关联" class="headerlink" title="建立本地分支和远程分支的关联"></a>建立本地分支和远程分支的关联</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream branch-name origin/branch-name；</span><br></pre></td></tr></table></figure><h4 id="从本地推送分支"><a href="#从本地推送分支" class="headerlink" title="从本地推送分支"></a>从本地推送分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin branch-name</span><br></pre></td></tr></table></figure><p>如果推送失败，先用git pull抓取远程的新提交；</p><h4 id="从远程抓取分支"><a href="#从远程抓取分支" class="headerlink" title="从远程抓取分支"></a>从远程抓取分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p>如果有冲突，要先处理冲突。</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="新建一个标签"><a href="#新建一个标签" class="headerlink" title="新建一个标签"></a>新建一个标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为HEAD，也可以指定一个commit id。</p><h4 id="指定标签信息"><a href="#指定标签信息" class="headerlink" title="指定标签信息"></a>指定标签信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息。</p><h4 id="PGP签名标签"><a href="#PGP签名标签" class="headerlink" title="PGP签名标签"></a>PGP签名标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id</span><br></pre></td></tr></table></figure><p><code>git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以用PGP签名标签。</p><h4 id="查看所有标签"><a href="#查看所有标签" class="headerlink" title="查看所有标签"></a>查看所有标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><h4 id="推送一个本地标签"><a href="#推送一个本地标签" class="headerlink" title="推送一个本地标签"></a>推送一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="推送全部未推送过的本地标签"><a href="#推送全部未推送过的本地标签" class="headerlink" title="推送全部未推送过的本地标签"></a>推送全部未推送过的本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin --tags</span><br></pre></td></tr></table></figure><h4 id="删除一个本地标签"><a href="#删除一个本地标签" class="headerlink" title="删除一个本地标签"></a>删除一个本地标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h4 id="删除一个远程标签"><a href="#删除一个远程标签" class="headerlink" title="删除一个远程标签"></a>删除一个远程标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin :refs/tags/&lt;tagname&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;git 简略笔记&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="git" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/"/>
    
      <category term="git简略版" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/git/git%E7%AE%80%E7%95%A5%E7%89%88/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>CSS笔记</title>
    <link href="http://yoursite.com/wiki/JS/CSS%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/wiki/JS/CSS笔记/</id>
    <published>2016-12-02T09:58:40.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
  </entry>
  
  <entry>
    <title>flexBox 伸缩盒子模型</title>
    <link href="http://yoursite.com/wiki/JS/flexBox/"/>
    <id>http://yoursite.com/wiki/JS/flexBox/</id>
    <published>2016-12-02T08:18:26.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要说明下flexBox的各个效果<br><a id="more"></a></p><h1 id="一、盒子模型"><a href="#一、盒子模型" class="headerlink" title="一、盒子模型"></a>一、盒子模型</h1><h2 id="1-1-标准盒子模型"><a href="#1-1-标准盒子模型" class="headerlink" title="1.1 标准盒子模型"></a>1.1 标准盒子模型</h2><p>标准的盒子模型如下图所示：</p><p><img src="http://of685p9vy.bkt.clouddn.com/17.png" alt="17"></p><h2 id="1-2-伸缩盒子模型"><a href="#1-2-伸缩盒子模型" class="headerlink" title="1.2 伸缩盒子模型"></a>1.2 伸缩盒子模型</h2><p>任何一个元素都可以指定为flexbox 布局，设置为display:flex或display:inline-flex的元素称为伸缩容器，伸缩容器的子元素称为伸缩项目，下面是伸缩的模型：<br><img src="http://of685p9vy.bkt.clouddn.com/1.1.png" alt="1.1"></p><h1 id="二、React-Native中使用flexBox"><a href="#二、React-Native中使用flexBox" class="headerlink" title="二、React Native中使用flexBox"></a>二、React Native中使用flexBox</h1><ol><li><p>flexDirection（伸缩容器）</p></li><li><p>alignItems（伸缩容器）</p></li><li><p>flexWrap（伸缩容器）</p></li><li>justifyContent（伸缩容器）</li><li>alignSelf（伸缩项目）</li><li>flex （伸缩项目）</li></ol><h2 id="2-1-flexDirection-指定主轴方向"><a href="#2-1-flexDirection-指定主轴方向" class="headerlink" title="2.1 flexDirection 指定主轴方向"></a>2.1 flexDirection 指定主轴方向</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flexDirection:row<span class="string">|column</span></span><br></pre></td></tr></table></figure><p>row、column的效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/1.png" alt="1"></p><p><img src="http://of685p9vy.bkt.clouddn.com/1.png" alt="2"></p><h2 id="2-2-alignItems-该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式"><a href="#2-2-alignItems-该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式" class="headerlink" title="2.2 alignItems 该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式"></a>2.2 alignItems 该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignSelf:<span class="built_in">auto</span>|<span class="type">flex</span>-start|<span class="type">flex</span>-<span class="keyword">end</span>|<span class="type">center</span>|<span class="type">stretch</span></span><br></pre></td></tr></table></figure><p>flex-start、flex-end、center的效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/3.png" alt="3"></p><p><img src="http://of685p9vy.bkt.clouddn.com/4.png" alt="4"></p><p><img src="http://of685p9vy.bkt.clouddn.com/5.png" alt="5"></p><h2 id="2-3-flexWrap-指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行"><a href="#2-3-flexWrap-指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行" class="headerlink" title="2.3 flexWrap 指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行"></a>2.3 flexWrap 指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flexWrap:wrap<span class="string">|nowrap</span></span><br></pre></td></tr></table></figure><p>wrap、nowrap的效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/6.png" alt="6"></p><p><img src="http://of685p9vy.bkt.clouddn.com/7.png" alt="7"></p><h2 id="2-4-justifyContent指定伸缩项目沿主轴线的对齐方式"><a href="#2-4-justifyContent指定伸缩项目沿主轴线的对齐方式" class="headerlink" title="2.4 justifyContent指定伸缩项目沿主轴线的对齐方式"></a>2.4 justifyContent指定伸缩项目沿主轴线的对齐方式</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justifyContent:flex-start|flex-<span class="keyword">end</span>|center|<span class="literal">space</span>-<span class="keyword">between</span>|<span class="literal">space</span>-<span class="keyword">around</span></span><br></pre></td></tr></table></figure><p>flex-start、flex-end、center、space-between、space-around的效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/8.png" alt="8"></p><p><img src="http://of685p9vy.bkt.clouddn.com/9.png" alt="9"></p><p><img src="http://of685p9vy.bkt.clouddn.com/10.png" alt="10"></p><p><img src="http://of685p9vy.bkt.clouddn.com/11.png" alt="11"></p><p><img src="http://of685p9vy.bkt.clouddn.com/12.png" alt="12"></p><h2 id="2-5-alignSelf-设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式"><a href="#2-5-alignSelf-设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式" class="headerlink" title="2.5  alignSelf 设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式"></a>2.5  alignSelf 设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alignSelf:<span class="built_in">auto</span>|<span class="type">flex</span>-start|<span class="type">flex</span>-<span class="keyword">end</span>|<span class="type">center</span>|<span class="type">stretch</span></span><br></pre></td></tr></table></figure><p>lex-start、flex-end、center 的效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/13.png" alt="13"></p><p><img src="http://of685p9vy.bkt.clouddn.com/14.png" alt="14"></p><p><img src="http://of685p9vy.bkt.clouddn.com/15.png" alt="15"></p><h2 id="2-6-flex"><a href="#2-6-flex" class="headerlink" title="2.6 flex"></a>2.6 flex</h2><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex:<span class="built_in">number</span></span><br></pre></td></tr></table></figure><p>分别设置四个伸缩项目的 flex为3、2、1、4，效果图如下：</p><p><img src="http://of685p9vy.bkt.clouddn.com/16.png" alt="16"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要说明下flexBox的各个效果&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://yoursite.com/categories/JS/"/>
    
    
      <category term="flexBox" scheme="http://yoursite.com/tags/flexBox/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C 消息发送与转发机制原理</title>
    <link href="http://yoursite.com/wiki/IOS_Runtime/Objective-C-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E4%B8%8E%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/wiki/IOS_Runtime/Objective-C-消息发送与转发机制原理/</id>
    <published>2016-12-02T06:42:23.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>消息发送和转发流程可以概括为：<font color="red" size="4" face="黑体">  消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；消息转发（Message Forwarding）是在查找 IMP 失败后执行的一系列转发流程，如果不作转发处理，则会打日志和抛出异常。 </font><br><a id="more"></a><br>本文不讲述开发者在消息发送和转发流程中需要做的事，而是讲述原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-680 和 CF-1153.18，逆向 CoreFoundation.framework 的系统版本为 macOS 10.11.5，汇编语言架构为 x86_64。</p><h1 id="八面玲珑的-objc-msgSend"><a href="#八面玲珑的-objc-msgSend" class="headerlink" title="八面玲珑的 objc_msgSend"></a>八面玲珑的 objc_msgSend</h1><p>此函数是消息发送必经之路，但只要一提 objc_msgSend，都会说它的伪代码如下或类似的逻辑，反正就是获取 IMP 并调用：</p><pre><code>id objc_msgSend(id self, SEL _cmd, ...) {  Class class = object_getClass(self);  IMP imp = class_getMethodImplementation(class, _cmd);  return imp ? imp(self, _cmd, ...) : 0;}</code></pre><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p>为啥老用伪代码？因为 objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。如下为 x86_64 架构下的源码，可以在 objc-msg-x86_64.s 文件中找到，关键代码如下：</p><pre><code>ENTRY    _objc_msgSendMESSENGER_STARTNilTest    NORMALGetIsaFast NORMAL        // r11 = self-&gt;isaCacheLookup NORMAL        // calls IMP on successNilTestSupport    NORMALGetIsaSupport       NORMAL// cache miss: go search the method listsLCacheMiss:// isa still in r11MethodTableLookup %a1, %a2    // r11 = IMPcmp    %r11, %r11        // set eq (nonstret) for forwardingjmp    *%r11            // goto *impEND_ENTRY    _objc_msgSend</code></pre><p>这里面包含一些有意义的宏：</p><ol><li>NilTest 宏，判断被发送消息的对象是否为 nil 的。如果为 nil，那就直接返回 nil。这就是为啥也可以对 nil 发消息。</li><li>GetIsaFast 宏可以『快速地』获取到对象的 isa 指针地址（放到 r11 寄存器，r10 会被重写；在 arm 架构上是直接赋值到 r9）</li><li>CacheLookup 这个宏是在类的缓存中查找 selector 对应的 IMP（放到 r10）并执行。如果缓存没中，那就得到 Class 的方法表中查找了。</li><li>MethodTableLookup 宏是重点，负责在缓存没命中时在方法表中负责查找 IMP：</li></ol><pre><code>.macro MethodTableLookup    MESSENGER_END_SLOW    SaveRegisters    // _class_lookupMethodAndLoadCache3(receiver, selector, class)    movq    $0, %a1    movq    $1, %a2    movq    %r11, %a3    call    __class_lookupMethodAndLoadCache3    // IMP is now in %rax    movq    %rax, %r11    RestoreRegisters.endmacro</code></pre><p>从上面的代码可以看出方法查找 IMP 的工作交给了 OC 中的 _class_lookupMethodAndLoadCache3 函数，并将 IMP 返回（从 r11 挪到 rax）。最后在 objc_msgSend 中调用 IMP。</p><h2 id="为什么使用汇编语言"><a href="#为什么使用汇编语言" class="headerlink" title="为什么使用汇编语言"></a>为什么使用汇编语言</h2><p>其实在 objc-msg-x86_64.s 中包含了多个版本的 objc_msgSend 方法，它们是根据返回值的类型和调用者的类型分别处理的：</p><ol><li>objc_msgSendSuper:向父类发消息，返回值类型为 id</li><li>objc_msgSend_fpret:返回值类型为 floating-point，其中包含 objc_msgSend_fp2ret 入口处理返回值类型为 long double 的情况</li><li>objc_msgSend_stret:返回值为结构体</li><li>objc_msgSendSuper_stret:向父类发消息，返回值类型为结构体</li></ol><p>当需要发送消息时，编译器会生成中间代码，根据情况分别调用 objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret 其中之一。<br>这也是为什么 objc_msgSend 要用汇编语言而不是 OC、C 或 C++ 语言来实现，因为单独一个方法定义满足不了多种类型返回值，有的方法返回 id，有的返回 int。考虑到不同类型参数返回值排列组合映射不同方法签名（method signature）的问题，那 switch 语句得老长了。。。这些原因可以总结为 Calling Convention，也就是说函数调用者与被调用者必须约定好参数与返回值在不同架构处理器上的存取规则，比如参数是以何种顺序存储在栈上，或是存储在哪些寄存器上。除此之外还有其他原因，比如其可变参数用汇编处理起来最方便，因为找到 IMP 地址后参数都在栈上。要是用 C++ 传递可变参数那就悲剧了，prologue 机制会弄乱地址（比如 i386 上为了存储 ebp 向后移位 4byte），最后还要用 epilogue 打扫战场。而且汇编程序执行效率高，在 Objective-C Runtime 中调用频率较高的函数好多都用汇编写的。</p><h2 id="使用-lookUpImpOrForward-快速查找-IMP"><a href="#使用-lookUpImpOrForward-快速查找-IMP" class="headerlink" title="使用 lookUpImpOrForward 快速查找 IMP"></a>使用 lookUpImpOrForward 快速查找 IMP</h2><p>上一节中说到的 _class_lookupMethodAndLoadCache3 函数其实只是简单的调用了 lookUpImpOrForward 函数：</p><pre><code>IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls){    return lookUpImpOrForward(cls, sel, obj,                               YES/*initialize*/, NO/*cache*/, YES/*resolver*/);}</code></pre><p>注意 lookUpImpOrForward 调用时使用缓存参数传入为 NO，因为之前已经尝试过查找缓存了。IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver) 实现了一套查找 IMP 的标准路径，也就是在消息转发（Forward）之前的逻辑。</p><h3 id="优化缓存查找-amp-类的初始化"><a href="#优化缓存查找-amp-类的初始化" class="headerlink" title="优化缓存查找&amp;类的初始化"></a>优化缓存查找&amp;类的初始化</h3><p>先对 debug 模式下的 assert 进行 unlock：</p><pre><code>runtimeLock.assertUnlocked();</code></pre><p>runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。<br>lookUpImpOrForward 接着做了如下两件事：</p><ol><li>如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-x86_64.s 找到，其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。</li><li>如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 写操作加锁，然后调用 cls 的 initialize 方法。如果 sel == initialize 也没关系，虽然 initialize 还会被调用一次，但不会起作用啦，因为 cls-&gt;isInitialized() 已经是 YES 啦。</li></ol><h3 id="继续在类的继承体系中查找"><a href="#继续在类的继承体系中查找" class="headerlink" title="继续在类的继承体系中查找"></a>继续在类的继承体系中查找</h3><p>考虑到运行时类中的方法可能会增加，需要先做读操作加锁，使得方法查找和缓存填充成为原子操作。添加 category 会刷新缓存，之后如果旧数据又被重填到缓存中，category 添加操作就会被忽略掉。</p><pre><code>runtimeLock.read();</code></pre><p>之后的逻辑整理如下：</p><ol><li>如果 selector 是需要被忽略的垃圾回收用到的方法，则将 IMP 结果设为 _objc_ignored_method，这是个汇编程序入口，可以理解为一个标记。对此种情况进行缓存填充操作后，跳到第 7 步；否则执行下一步。</li><li>查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 7 步；否则执行下一步。</li><li>在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程比较复杂，会针对已经排序的列表使用二分法查找，未排序的列表则是线性遍历。如果成功查找到 Method 对象，就直接跳到第 7 步；否则执行下一步。</li><li>在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。</li><li>当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlockRead()），接着间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。这相当于告诉程序员『赶紧用 Runtime 给类里这个 selector 弄个对应的 IMP 吧』，因为此时锁已经 unlock 了所以不会缓存结果，甚至还需要软性地处理缓存过期问题可能带来的错误。这里的业务逻辑稍微复杂些，后面会总结。因为这些工作都是在非线程安全下进行的，完成后需要回到第 1 步再次查找 IMP。</li><li>此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 4 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。</li><li>读操作解锁，并将之前找到的 IMP 返回。（无论是正经 IMP 还是不正经的 _objc_msgForward_impcache）这步还偏执地做了一些脑洞略大的 assert，很有趣。</li></ol><p>对于第 5 步，其实是直接调用 _class_resolveMethod 函数，在这个函数中实现了复杂的方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/<em>initialize</em>/, YES/<em>cache</em>/, NO/<em>resolver</em>/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/<em>initialize</em>/, YES/<em>cache</em>/, NO/<em>resolver</em>/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。<br>最后 lookUpImpOrForward 方法也会把真正的 IMP 或者需要消息转发的 _objc_msgForward_impcache 返回，并最终专递到 objc_msgSend 中。而 _objc_msgForward_impcache 会在转化成 _objc_msgForward 或 _objc_msgForward_stret。这个后面会讲解原理。</p><h2 id="回顾-objc-msgSend-伪代码"><a href="#回顾-objc-msgSend-伪代码" class="headerlink" title="回顾 objc_msgSend 伪代码"></a>回顾 objc_msgSend 伪代码</h2><p>回过头来会发现 objc_msgSend 的伪代码描述得很传神啊，因为class_getMethodImplementation 的实现如下：</p><pre><code>IMP class_getMethodImplementation(Class cls, SEL sel){    IMP imp;    if (!cls  ||  !sel) return nil;    imp = lookUpImpOrNil(cls, sel, nil, YES/*initialize*/, YES/*cache*/, YES/*resolver*/);    // Translate forwarding function to C-callable external version    if (!imp) {        return _objc_msgForward;    }    return imp;}</code></pre><p>lookUpImpOrNil 函数获取不到 IMP 时就返回 _objc_msgForward，后面会讲到它。lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil:</p><pre><code>IMP lookUpImpOrNil(Class cls, SEL sel, id inst,                    bool initialize, bool cache, bool resolver){    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);    if (imp == _objc_msgForward_impcache) return nil;    else return imp;}</code></pre><p>lookUpImpOrNil 方法可以查找到 selector 对应的 IMP 或是 nil，所以如果不考虑返回值类型为结构体的情况，用那几行伪代码来表示复杂的汇编实现还是挺恰当的。</p><h1 id="forwarding-转发消息"><a href="#forwarding-转发消息" class="headerlink" title="forwarding 转发消息"></a>forwarding 转发消息</h1><h2 id="objc-msgForward-impcache-的转换"><a href="#objc-msgForward-impcache-的转换" class="headerlink" title="objc_msgForward_impcache 的转换"></a>objc_msgForward_impcache 的转换</h2><p>_objc_msgForward_impcache 只是个内部的函数指针，只存储于上节提到的类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。但在 Mac OS X macOS 10.6 及更早版本的 libobjc.A.dylib 中是不能直接调用的，况且我们根本不会直接用到它。带 stret 后缀的函数依旧是返回值为结构体的版本。<br>上一节最后讲到如果没找到 IMP，就会将 _objc_msgForward_impcache 返回到 objc_msgSend 函数，而正是因为它是用汇编语言写的，所以将内部使用的 _objc_msgForward_impcache 转化成外部可调用的 _objc_msgForward 或 _objc_msgForward_stret 也是由汇编代码来完成。实现原理很简单，就是增加个静态入口 __objc_msgForward_impcache，然后根据此时 CPU 的状态寄存器的内容来决定转换成哪个。如果是 NE(Not Equal) 则转换成 _objc_msgForward_stret，反之是 EQ(Equal) 则转换成 _objc_msgForward:</p><pre><code>jne    __objc_msgForward_stretjmp    __objc_msgForward</code></pre><p>为何根据状态寄存器的值来判断转换成哪个函数指针呢？回过头来看看 objc_msgSend 中调用完 MethodTableLookup 之后干了什么：</p><pre><code>MethodTableLookup %a1, %a2    // r11 = IMPcmp    %r11, %r11        // set eq (nonstret) for forwardingjmp    *%r11            // goto *imp</code></pre><p>再看看返回值为结构体的 objc_msgSend_stret 这里的逻辑：</p><pre><code>MethodTableLookup %a2, %a3    // r11 = IMPtest    %r11, %r11        // set ne (stret) for forward; r11!=0jmp    *%r11            // goto *imp</code></pre><p>稍微懂汇编的人一眼就看明白了，不懂的看注释也懂了，我就不墨迹了。现在总算是把消息转发前的逻辑绕回来构成闭环了。<br>上一节中提到 class_getMethodImplementation 函数的实现，在查找不到 IMP 时返回 _objc_msgForward，而 _objc_msgForward_stret 正好对应着 class_getMethodImplementation_stret:</p><pre><code>IMP class_getMethodImplementation_stret(Class cls, SEL sel){    IMP imp = class_getMethodImplementation(cls, sel);    // Translate forwarding function to struct-returning version    if (imp == (IMP)&amp;_objc_msgForward /* not _internal! */) {        return (IMP)&amp;_objc_msgForward_stret;    }    return imp;}</code></pre><p>也就是说 _objc_msgForward* 系列本质都是函数指针，都用汇编语言实现，都可以与 IMP 类型的值作比较。_objc_msgForward 和 _objc_msgForward_stret 声明在 message.h 文件中。_objc_msgForward_impcache 在早期版本的 Runtime 中叫做 _objc_msgForward_internal。</p><h2 id="objc-msgForward-也只是个入口"><a href="#objc-msgForward-也只是个入口" class="headerlink" title="objc_msgForward 也只是个入口"></a>objc_msgForward 也只是个入口</h2><p>从汇编源码可以很容易看出 _objc_msgForward 和 _objc_msgForward_stret 会分别调用 _objc_forward_handler 和 _objc_forward_handler_stret：</p><pre><code>ENTRY    __objc_msgForward// Non-stret versionmovq    __objc_forward_handler(%rip), %r11jmp    *%r11END_ENTRY    __objc_msgForwardENTRY    __objc_msgForward_stret// Struct-return versionmovq    __objc_forward_stret_handler(%rip), %r11jmp    *%r11END_ENTRY    __objc_msgForward_stret</code></pre><p>这两个 handler 函数的区别从字面上就能看出来，不再赘述。<br>也就是说，消息转发过程是现将 _objc_msgForward_impcache 强转成 _objc_msgForward 或 _objc_msgForward_stret，再分别调用 _objc_forward_handler 或 _objc_forward_handler_stret。</p><h2 id="objc-setForwardHandler-设置了消息转发的回调"><a href="#objc-setForwardHandler-设置了消息转发的回调" class="headerlink" title="objc_setForwardHandler 设置了消息转发的回调"></a>objc_setForwardHandler 设置了消息转发的回调</h2><p>在 Objective-C 2.0 之前，默认的 _objc_forward_handler 或 _objc_forward_handler_stret 都是 nil，而新版本的默认实现是这样的：</p><pre><code>// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel){    _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot;                &quot;(no message forward handler is installed)&quot;,                 class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;,                 object_getClassName(self), sel_getName(sel), self);}void *_objc_forward_handler = (void*)objc_defaultForwardHandler;#if SUPPORT_STRETstruct stret { int i[100]; };__attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel){    objc_defaultForwardHandler(self, sel);}void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler;#endif</code></pre><p>objc_defaultForwardHandler 中的 _objc_fatal 作用就是打日志并调用 <strong>builtin_trap() 触发 crash，可以看到我们最熟悉的那句 “unrecognized selector sent to instance” 日志。</strong>builtin_trap() 在杀掉进程的同时还能生成日志，比调用 exit() 更好。objc_defaultForwardStretHandler 就是装模作样搞个形式主义，把 objc_defaultForwardHandler 包了一层。<strong>attribute</strong>((noreturn)) 属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。这里正适合此属性，因为要求返回结构体哒。<br>因为默认的 Handler 干的事儿就是打日志触发 crash，我们想要实现消息转发，就需要替换掉 Handler 并赋值给 _objc_forward_handler 或 _objc_forward_handler_stret，赋值的过程就需要用到 objc_setForwardHandler 函数，实现也是简单粗暴，就是赋值啊：</p><pre><code>void objc_setForwardHandler(void *fwd, void *fwd_stret){    _objc_forward_handler = fwd;#if SUPPORT_STRET    _objc_forward_stret_handler = fwd_stret;#endif}</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我将整个实现流程绘制出来，过滤了一些不会进入的分支路径和跟主题无关的细节：</p><p><img src="http://of685p9vy.bkt.clouddn.com/runtime22.jpg" alt="runtime22"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;消息发送和转发流程可以概括为：&lt;font color=&quot;red&quot; size=&quot;4&quot; face=&quot;黑体&quot;&gt;  消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；消息转发（Message Forwarding）是在查找 IMP 失败后执行的一系列转发流程，如果不作转发处理，则会打日志和抛出异常。 &lt;/font&gt;&lt;br&gt;
    
    </summary>
    
      <category term="IOS_Runtime" scheme="http://yoursite.com/categories/IOS-Runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Objective-C：Category(转载)</title>
    <link href="http://yoursite.com/wiki/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Category/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Objective-C%EF%BC%9ACategory/"/>
    <id>http://yoursite.com/wiki/IOS基础知识/Category/深入理解Objective-C：Category/</id>
    <published>2016-12-02T02:47:02.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。<br><a id="more"></a></p><h1 id="初入宝地-category简介"><a href="#初入宝地-category简介" class="headerlink" title="初入宝地-category简介"></a>初入宝地-category简介</h1><p>category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景</p><ol><li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。</li><li>声明私有方法</li></ol><p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p><ol><li>模拟多继承</li><li>把framework的私有方法公开</li></ol><p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p><h1 id="连类比事-category和extension"><a href="#连类比事-category和extension" class="headerlink" title="连类比事-category和extension"></a>连类比事-category和extension</h1><p><font color="red" size="4" face="黑体">extension看起来很像一个匿名的category</font>，但是extension和有名字的category几乎完全是两个东西。 <font color="red" size="4" face="黑体">extension在编译期决议，它就是类的一部分</font>，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，<font color="red" size="4" face="黑体">你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension</font>。</p><p><font color="red" size="4" face="黑体">但是category则完全不一样，它是在运行期决议的</font>。<br>就category和extension的区别来看，我们可以推导出一个明显的事实，<font color="red" size="4" face="黑体">extension可以添加实例变量，而category是无法添加实例变量的</font>。（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p><h1 id="挑灯细览-category真面目"><a href="#挑灯细览-category真面目" class="headerlink" title="挑灯细览-category真面目"></a>挑灯细览-category真面目</h1><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了<br>1)、类的名字（name）<br>2)、类（cls）<br>3)、category中所有给类添加的实例方法的列表（instanceMethods）<br>4)、category中所有添加的类方法的列表（classMethods）<br>5)、category实现的所有协议的列表（protocols）<br>6)、category中添加的所有属性（instanceProperties）</p><pre><code>typedef struct category_t {    const char *name;    classref_t cls;    struct method_list_t *instanceMethods;    struct method_list_t *classMethods;    struct protocol_list_t *protocols;    struct property_list_t *instanceProperties;} category_t;</code></pre><p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>ok，我们先去写一个category看一下category到底为何物：<br>MyClass.h：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject- (void)printName;@end@interface MyClass(MyAddition)@property(nonatomic, copy) NSString *name;- (void)printName;@end</code></pre><p>MyClass.m：</p><pre><code>#import &quot;MyClass.h&quot;@implementation MyClass- (void)printName{    NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);}@end@implementation MyClass(MyAddition)- (void)printName{    NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);}@end</code></pre><p>我们使用clang的命令去看看category到底会变成什么：</p><pre><code>clang -rewrite-objc MyClass.m</code></pre><p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p><pre><code>///实例方法列表static struct /*_method_list_t*/ {        unsigned int entsize;  // sizeof(struct _objc_method)        unsigned int method_count;        struct _objc_method method_list[1];} _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {        sizeof(_objc_method),        1,        {{(struct objc_selector *)"printName", "v16@0:8", (void *)_I_MyClass_MyAddition_printName}}};///实例属性列表static struct /*_prop_list_t*/ {        unsigned int entsize;  // sizeof(struct _prop_t)        unsigned int count_of_properties;        struct _prop_t prop_list[1];} _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = {        sizeof(_prop_t),        1,        {{"name","T@\"NSString\",C,N"}}};extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;///category 本身static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) ={        &quot;MyClass&quot;,        0, // &amp;OBJC_CLASS_$_MyClass,        (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,        0,        0,        (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,};static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) {        _OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;}#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = {        (void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,};///DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= {        &amp;OBJC_CLASS_$_MyClass,};static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = {        &amp;OBJC_CLASS_$_MyClass,};static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= {        &amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,};</code></pre><p>我们可以看到:</p><ol><li>首先编译器生成了实例方法列表OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition和属性列表OBJC$_PROP_LISTMyClass$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</li><li>其次，编译器生成了category本身OBJC$_CATEGORYMyClass$_MyAddition，并用前面生成的列表来初始化category本身。</li><li>最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC<em>LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^</em>^），用于运行期category的加载。<br>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。</li></ol><h1 id="追本溯源-category如何加载"><a href="#追本溯源-category如何加载" class="headerlink" title="追本溯源-category如何加载"></a>追本溯源-category如何加载</h1><p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。<br>想了解更多dyld地同学可以移步这里。<br>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p><pre><code>void _objc_init(void){    static bool initialized = false;    if (initialized) return;    initialized = true;    // fixme defer initialization until an objc-using image is found?    environ_init();    tls_init();    lock_init();    exception_init();    // Register for unmap first, in case some +load unmaps something    _dyld_register_func_for_remove_image(&amp;unmap_image);    dyld_register_image_state_change_handler(dyld_image_state_bound,                                             1/*batch*/, &amp;map_images);    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);}</code></pre><p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p><pre><code>// Discover categories. </code></pre><p>  for (EACH_HEADER)<br>  {<br>      category_t <em>*catlist =<br>          _getObjc2CategoryList(hi, &amp;count);<br>      for (i = 0; i &lt; count; i++) {<br>          category_t </em>cat = catlist[i];<br>          class_t *cls = remapClass(cat-&gt;cls);</p><pre><code>    if (!cls) {        // Category&apos;s target class is missing (probably weak-linked).        // Disavow any knowledge of this category.        catlist[i] = NULL;        if (PrintConnecting) {            _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;                         &quot;missing weak-linked target class&quot;,                         cat-&gt;name, cat);        }        continue;    }    // Process this category.     // First, register the category with its target class.     // Then, rebuild the class&apos;s method lists (etc) if     // the class is realized.     BOOL classExists = NO;    if (cat-&gt;instanceMethods ||  cat-&gt;protocols         ||  cat-&gt;instanceProperties)    {        addUnattachedCategoryForClass(cat, cls, hi);        if (isRealized(cls)) {            remethodizeClass(cls);            classExists = YES;        }        if (PrintConnecting) {            _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,                         getName(cls), cat-&gt;name,                         classExists ? &quot;on existing class&quot; : &quot;&quot;);        }    }    if (cat-&gt;classMethods  ||  cat-&gt;protocols         /* ||  cat-&gt;classProperties */)    {        addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);        if (isRealized(cls-&gt;isa)) {            remethodizeClass(cls-&gt;isa);        }        if (PrintConnecting) {            _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,                         getName(cls), cat-&gt;name);        }    }}</code></pre><p>  }<br>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。<br>略去PrintConnecting这个用于log的东西，这段代码很容易理解：</p><ol><li>把category的实例方法、协议以及属性添加到类上</li><li>把category的类方法和协议添加到类的metaclass上</li></ol><p>值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。</p><pre><code>static void remethodizeClass(class_t *cls){    category_list *cats;    BOOL isMeta;    rwlock_assert_writing(&amp;runtimeLock);    isMeta = isMetaClass(cls);    // Re-methodizing: check for more categories    if ((cats = unattachedCategoriesForClass(cls))) {        chained_property_list *newproperties;        const protocol_list_t **newprotos;        if (PrintConnecting) {            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,                         getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);        }        // Update methods, properties, protocols                ///添加方法        BOOL vtableAffected = NO;        attachCategoryMethods(cls, cats, &amp;vtableAffected);                ///添加属性        newproperties = buildPropertyList(NULL, cats, isMeta);        if (newproperties) {            newproperties-&gt;next = cls-&gt;data()-&gt;properties;            cls-&gt;data()-&gt;properties = newproperties;        }                ///添加协议        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) {            _free_internal(cls-&gt;data()-&gt;protocols);        }        cls-&gt;data()-&gt;protocols = newprotos;        _free_internal(cats);        // Update method caches and vtables        flushCaches(cls);        if (vtableAffected) flushVtables(cls);    }}</code></pre><p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：</p><pre><code>static void attachCategoryMethods(class_t *cls, category_list *cats,                      BOOL *inoutVtablesAffected){    if (!cats) return;    if (PrintReplacedMethods) printReplacements(cls, cats);    BOOL isMeta = isMetaClass(cls);    method_list_t **mlists = (method_list_t **)        _malloc_internal(cats-&gt;count * sizeof(*mlists));    // Count backwards through cats to get newest categories first    int mcount = 0;    int i = cats-&gt;count;    BOOL fromBundle = NO;    while (i--) {        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);        if (mlist) {            mlists[mcount++] = mlist;            fromBundle |= cats-&gt;list[i].fromBundle;        }    }    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);    _free_internal(mlists);}</code></pre><p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p><pre><code>for (uint32_t m = 0;             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;             m++)        {            SEL sel = method_list_nth(mlist, m)-&gt;name;            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) {                cls-&gt;setHasCustomRR();                scanForCustomRR = false;            } else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) {                cls-&gt;setHasCustomAWZ();                scanForCustomAWZ = false;            }        }        // Fill method list array        newLists[newCount++] = mlist;    .    .    .    // Copy old methods to the method list array    for (i = 0; i &lt; oldCount; i++) {        newLists[newCount++] = oldLists[i];    }</code></pre><p>需要注意的有两点：</p><ol><li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</li><li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</li></ol><h1 id="旁枝末叶-category和-load方法"><a href="#旁枝末叶-category和-load方法" class="headerlink" title="旁枝末叶-category和+load方法"></a>旁枝末叶-category和+load方法</h1><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：<br>1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？<br>2)、这么些个+load方法，调用顺序是咋样的呢？<br>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：<br>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:<br><img src="http://of685p9vy.bkt.clouddn.com/catogery1.png" alt="catorgery"><br>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：</p><pre><code>objc[1187]: REPLACED: -[MyClass printName] by category Category1objc[1187]: REPLACED: -[MyClass printName] by category Category2...objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +loadobjc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +loadobjc[1187]: LOAD: +[MyClass load]...objc[1187]: LOAD: +[MyClass(Category1) load]...objc[1187]: LOAD: +[MyClass(Category2) load]</code></pre><p>所以，对于上面两个问题，答案是很明显的：</p><ol><li>可以调用，因为附加category到类的工作会先于+load方法的执行</li><li>+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。</li></ol><p>目前的编译顺序是这样的：<br><img src="http://of685p9vy.bkt.clouddn.com/catogery2.png" alt="catorgery"><br>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。<br>这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p><h1 id="触类旁通-category和方法覆盖"><a href="#触类旁通-category和方法覆盖" class="headerlink" title="触类旁通-category和方法覆盖"></a>触类旁通-category和方法覆盖</h1><p>鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:<br>怎么调用到原来类中被category覆盖掉的方法？<br>对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p><pre><code>Class currentClass = [MyClass class];MyClass *my = [[MyClass alloc] init];if (currentClass) {    unsigned int methodCount;    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);    IMP lastImp = NULL;    SEL lastSel = NULL;    for (NSInteger i = 0; i &lt; methodCount; i++) {        Method method = methodList[i];        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method))                                         encoding:NSUTF8StringEncoding];        if ([@&quot;printName&quot; isEqualToString:methodName]) {            lastImp = method_getImplementation(method);            lastSel = method_getName(method);        }    }    typedef void (*fn)(id,SEL);    if (lastImp != NULL) {        fn f = (fn)lastImp;        f(my,lastSel);    }    free(methodList);}</code></pre><h1 id="更上一层-category和关联对象"><a href="#更上一层-category和关联对象" class="headerlink" title="更上一层-category和关联对象"></a>更上一层-category和关联对象</h1><p>如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。</p><p>MyClass+Category1.h:</p><pre><code>#import &quot;MyClass.h&quot;@interface MyClass (Category1)@property(nonatomic,copy) NSString *name;@end</code></pre><p>MyClass+Category1.m:</p><pre><code>#import &quot;MyClass+Category1.h&quot;#import &lt;objc/runtime.h&gt;@implementation MyClass (Category1)+ (void)load{    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);}- (void)setName:(NSString *)name{    objc_setAssociatedObject(self,                             &quot;name&quot;,                             name,                             OBJC_ASSOCIATION_COPY);}- (NSString*)name{    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);    return nameObject;}@end</code></pre><p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：</p><pre><code>void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {    // retain the new value (if any) outside the lock.    ObjcAssociation old_association(0, nil);    id new_value = value ? acquireValue(value, policy) : nil;    {        AssociationsManager manager;        AssociationsHashMap &amp;associations(manager.associations());        disguised_ptr_t disguised_object = DISGUISE(object);        if (new_value) {            // break any existing association.            AssociationsHashMap::iterator i = associations.find(disguised_object);            if (i != associations.end()) {                // secondary table exists                ObjectAssociationMap *refs = i-&gt;second;                ObjectAssociationMap::iterator j = refs-&gt;find(key);                if (j != refs-&gt;end()) {                    old_association = j-&gt;second;                    j-&gt;second = ObjcAssociation(policy, new_value);                } else {                    (*refs)[key] = ObjcAssociation(policy, new_value);                }            } else {                // create the new association (first time).                ObjectAssociationMap *refs = new ObjectAssociationMap;                associations[disguised_object] = refs;                (*refs)[key] = ObjcAssociation(policy, new_value);                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));            }        } else {            // setting the association to nil breaks the association.            AssociationsHashMap::iterator i = associations.find(disguised_object);            if (i !=  associations.end()) {                ObjectAssociationMap *refs = i-&gt;second;                ObjectAssociationMap::iterator j = refs-&gt;find(key);                if (j != refs-&gt;end()) {                    old_association = j-&gt;second;                    refs-&gt;erase(j);                }            }        }    }    // release the old value (outside of the lock).    if (old_association.hasValue()) ReleaseValue()(old_association);}</code></pre><p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：</p><pre><code>class AssociationsManager {    static OSSpinLock _lock;    static AssociationsHashMap *_map;               // associative references:  object pointer -&gt; PtrPtrHashMap.public:    AssociationsManager()   { OSSpinLockLock(&amp;_lock); }    ~AssociationsManager()  { OSSpinLockUnlock(&amp;_lock); }    AssociationsHashMap &amp;associations() {        if (_map == NULL)            _map = new AssociationsHashMap();        return *_map;    }};</code></pre><p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p><pre><code>void *objc_destructInstance(id obj) {    if (obj) {        Class isa_gen = _object_getClass(obj);        class_t *isa = newcls(isa_gen);        // Read all of the flags at once for performance.        bool cxx = hasCxxStructors(isa);        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);        // This order is important.        if (cxx) object_cxxDestruct(obj);        if (assoc) _object_remove_assocations(obj);        if (!UseGC) objc_clear_deallocating(obj);    }    return obj;}</code></pre><p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。&lt;br&gt;
    
    </summary>
    
      <category term="IOS基础知识" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Category" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Category/"/>
    
    
      <category term="category" scheme="http://yoursite.com/tags/category/"/>
    
  </entry>
  
  <entry>
    <title>神经病院Objective-C Runtime出院第三天——如何正确使用Runtime(转载)</title>
    <link href="http://yoursite.com/wiki/IOS_Runtime/%E7%A5%9E%E7%BB%8F%E7%97%85%E9%99%A2Objective-C-Runtime%E5%87%BA%E9%99%A2%E7%AC%AC%E4%B8%89%E5%A4%A9%E2%80%94%E2%80%94%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8Runtime-%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/wiki/IOS_Runtime/神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime-转载/</id>
    <published>2016-11-29T06:25:09.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。<br><a id="more"></a></p><h1 id="实现多继承Multiple-Inheritance"><a href="#实现多继承Multiple-Inheritance" class="headerlink" title="实现多继承Multiple Inheritance"></a>实现多继承Multiple Inheritance</h1><p>在上一篇文章里面讲到的forwardingTargetForSelector:方法就能知道，一个类可以做到继承多个类的效果，只需要在这一步将消息转发给正确的类对象就可以模拟多继承的效果。</p><p>在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a>上记录了这样一段例子。<br><img src="http://of685p9vy.bkt.clouddn.com/runtime15.gif" alt="runtime15"><br>在OC程序中可以借用消息转发机制来实现多继承的功能。 在上图中，一个对象对一个消息做出回应，类似于另一个对象中的方法借过来或是“继承”过来一样。 在图中，warrior实例转发了一个negotiate消息到Diplomat实例中，执行Diplomat中的negotiate方法，结果看起来像是warrior实例执行了一个和Diplomat实例一样的negotiate方法，其实执行者还是Diplomat实例。<br>这使得不同继承体系分支下的两个类可以“继承”对方的方法，这样一个类可以响应自己继承分支里面的方法，同时也能响应其他不相干类发过来的消息。在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。<br>消息转发提供了许多类似于多继承的特性，但是他们之间有一个很大的不同：</p><ol><li>多继承：合并了不同的行为特征在一个单独的对象中，会得到一个重量级多层面的对象。</li><li>消息转发：将各个功能分散到不同的对象中，得到的一些轻量级的对象，这些对象通过消息转发联合起来。</li></ol><p>这里值得说明的一点是，即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开。像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个Warrior对象如果被问到是否能响应negotiate消息：</p><pre><code>if ( [aWarrior respondsToSelector:@selector(negotiate)] )</code></pre><p>结果是NO，虽然它能够响应negotiate消息而不报错，但是它是靠转发消息给Diplomat类来响应消息的。<br>如果非要制造假象，反应出这种“假”的继承关系，那么需要重新实现 respondsToSelector:和 isKindOfClass:来加入你的转发算法：</p><pre><code>- (BOOL)respondsToSelector:(SEL)aSelector{    if ( [super respondsToSelector:aSelector] )        return YES;    else {        /* Here, test whether the aSelector message can     *         * be forwarded to another object and whether that  *         * object can respond to it. Return YES if it can.  */    }    return NO;}</code></pre><p>除了respondsToSelector:和 isKindOfClass:之外，instancesRespondToSelector:中也应该写一份转发算法。如果使用了协议，conformsToProtocol:也一样需要重写。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个methodSignatureForSelector:来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现methodSignatureForSelector:</p><pre><code>- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector{    NSMethodSignature* signature = [super methodSignatureForSelector:selector];    if (!signature) {        signature = [surrogate methodSignatureForSelector:selector];    }    return signature;}</code></pre><p>Note:  This is an advanced technique, suitable only for situations where no other solution is possible. It is not intended as a replacement for inheritance. If you must make use of this technique, make sure you fully understand the behavior of the class doing the forwarding and the class you’re forwarding to.<br>需要引起注意的一点，实现methodSignatureForSelector方法是一种先进的技术，只适用于没有其他解决方案的情况下。它不会作为继承的替代。如果您必须使用这种技术，请确保您完全理解类做的转发和您转发的类的行为。请勿滥用！</p><h1 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h1><p>提到Objective-C 中的 Runtime，大多数人第一个想到的可能就是黑魔法Method Swizzling。毕竟这是Runtime里面很强大的一部分，它可以通过Runtime的API实现更改任意的方法，理论上可以在运行时通过类名/方法名hook到任何 OC 方法，替换任何类的实现以及新增任意类。<br>举的最多的例子应该就是埋点统计用户信息的例子。<br>假设我们需要在页面上不同的地方统计用户信息，常见做法有两种： </p><ol><li>傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。 </li><li>把统计的代码写入基类中，比如说BaseViewController。这样虽然代码只需要写一次，但是UITableViewController，UICollectionViewcontroller都需要写一遍，这样重复的代码依旧不少。</li></ol><p>基于这两点，我们这时候选用Method Swizzling来解决这个事情最优雅。</p><h2 id="Method-Swizzling原理"><a href="#Method-Swizzling原理" class="headerlink" title="Method Swizzling原理"></a>Method Swizzling原理</h2><p>Method Swizzing是发生在运行时的，主要用于在运行时将两个Method进行交换，我们可以将Method Swizzling代码写到任何地方，但是只有在这段Method Swilzzling代码执行完毕之后互换才起作用。而且Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式，我们可以利用苹果这一特性来实现AOP编程。<br>Method Swizzling本质上就是对IMP和SEL进行交换。</p><h2 id="Method-Swizzling使用"><a href="#Method-Swizzling使用" class="headerlink" title="Method Swizzling使用"></a>Method Swizzling使用</h2><p>一般我们使用都是新建一个分类，在分类中进行Method Swizzling方法的交换。交换的代码模板如下：</p><pre><code>#import &lt;objc/runtime.h&gt;@implementation UIViewController (Swizzling)+ (void)load {    static dispatch_once_t onceToken;    dispatch_once(&amp;onceToken, ^{        Class class = [self class];        // When swizzling a class method, use the following:        // Class class = object_getClass((id)self);        SEL originalSelector = @selector(viewWillAppear:);        SEL swizzledSelector = @selector(xxx_viewWillAppear:);        Method originalMethod = class_getInstanceMethod(class, originalSelector);        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);        BOOL didAddMethod = class_addMethod(class,                                            originalSelector,                                            method_getImplementation(swizzledMethod),                                            method_getTypeEncoding(swizzledMethod));        if (didAddMethod) {            class_replaceMethod(class,                                swizzledSelector,                                method_getImplementation(originalMethod),                                method_getTypeEncoding(originalMethod));        } else {            method_exchangeImplementations(originalMethod, swizzledMethod);        }    });}#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated {    [self xxx_viewWillAppear:animated];    NSLog(@&quot;viewWillAppear: %@&quot;, self);}@end</code></pre><p>Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在category中添加一个方法。</p><h2 id="Method-Swizzling注意点"><a href="#Method-Swizzling注意点" class="headerlink" title="Method Swizzling注意点"></a>Method Swizzling注意点</h2><h3 id="Swizzling应该总在-load中执行"><a href="#Swizzling应该总在-load中执行" class="headerlink" title="Swizzling应该总在+load中执行"></a>Swizzling应该总在+load中执行</h3><p>Objective-C在运行时会自动调用类的两个方法+load和+initialize。<font color="red" size="4" face="黑体">+load会在类初始加载时调用， +initialize方法是以懒加载的方式被调用的，</font>如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize方法是永远不会被调用的。所以Swizzling要是写在+initialize方法中，是有可能永远都不被执行。<br>和+initialize比较+load能保证在类的初始化过程中被加载。<br>关于+load和+initialize的比较可以参看这篇文章<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" rel="external nofollow noopener noreferrer" target="_blank">《Objective-C +load vs +initialize》</a></p><h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为Method Swizzling的最佳实践。<br>这里有一个很容易犯的错误，那就是继承中用了Swizzling。如果不写dispatch_once就会导致Swizzling失效！<br>举个例子，比如同时对NSArray和NSMutableArray中的objectAtIndex:方法都进行了Swizzling，这样可能会导致NSArray中的Swizzling失效的。<br>可是为什么会这样呢？ 原因是，我们没有用dispatch_once控制Swizzling只执行一次。如果这段Swizzling被执行多次，经过多次的交换IMP和SEL之后，结果可能就是未交换之前的状态。<br>比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的IMP，子类C持有B方法的IMP，但是再次交换一次，就又还原了。父类A还是持有B方法的IMP，子类C还是持有D方法的IMP，这样就相当于咩有交换。可以看出，如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！</p><h3 id="Swizzling在-load中执行时，不要调用-super-load"><a href="#Swizzling在-load中执行时，不要调用-super-load" class="headerlink" title="Swizzling在+load中执行时，不要调用[super load]"></a>Swizzling在+load中执行时，不要调用[super load]</h3><p>原因同注意点二，如果是多继承，并且对同一个方法都进行了Swizzling，那么调用[super load]以后，父类的Swizzling就失效了。</p><h3 id="上述模板中没有错误"><a href="#上述模板中没有错误" class="headerlink" title="上述模板中没有错误"></a>上述模板中没有错误</h3><p>有些人怀疑我上述给的模板可能有错误。在这里需要讲解一下。<br>在进行Swizzling的时候，我们需要用class_addMethod先进行判断一下原有类中是否有要替换的方法的实现。<br>如果class_addMethod返回NO，说明当前类中有要替换方法的实现，所以可以直接进行替换，调用method_exchangeImplementations即可实现Swizzling。<br>如果class_addMethod返回YES，说明当前类中没有要替换方法的实现，我们需要在父类中去寻找。这个时候就需要用到method_getImplementation去获取class_getInstanceMethod里面的方法实现。然后再进行class_replaceMethod来实现Swizzling。<br>这是Swizzling需要判断的一点。<br>还有一点需要注意的是，在我们替换的方法- (void)xxx_viewWillAppear:(BOOL)animated中，调用了[self xxx_viewWillAppear:animated];这不是死循环了么？<br>其实这里并不会死循环。 由于我们进行了Swizzling，所以其实在原来的- (void)viewWillAppear:(BOOL)animated方法中，调用的是- (void)xxx_viewWillAppear:(BOOL)animated方法的实现。所以不会造成死循环。相反的，如果这里把[self xxx_viewWillAppear:animated];改成[self viewWillAppear:animated];就会造成死循环。因为外面调用[self viewWillAppear:animated];的时候，会交换方法走到[self xxx_viewWillAppear:animated];这个方法实现中来，然后这里又去调用[self viewWillAppear:animated]，就会造成死循环了。<br>所以按照上述Swizzling的模板来写，就不会遇到这4点需要注意的问题啦。</p><h2 id="Method-Swizzling使用场景"><a href="#Method-Swizzling使用场景" class="headerlink" title="Method Swizzling使用场景"></a>Method Swizzling使用场景</h2><p>Method Swizzling使用场景其实有很多很多，在一些特殊的开发需求中适时的使用黑魔法，可以做法神来之笔的效果。这里就举3种常见的场景。</p><h3 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h3><p>AOP的例子在上一篇文章中举了一个例子，在下一章中也打算详细分析一下其实现原理，这里就一笔带过。</p><h3 id="实现埋点统计"><a href="#实现埋点统计" class="headerlink" title="实现埋点统计"></a>实现埋点统计</h3><p>如果app有埋点需求，并且要自己实现一套埋点逻辑，那么这里用到Swizzling是很合适的选择。优点在开头已经分析了，这里不再赘述。看到一篇分析的挺精彩的埋点的文章，推荐大家阅读。 <a href="http://www.jianshu.com/p/0497afdad36d" rel="external nofollow noopener noreferrer" target="_blank">iOS动态性(二)可复用而且高度解耦的用户统计埋点实现</a></p><h3 id="实现异常保护"><a href="#实现异常保护" class="headerlink" title="实现异常保护"></a>实现异常保护</h3><p>日常开发我们经常会遇到NSArray数组越界的情况，苹果的API也没有对异常保护，所以需要我们开发者开发时候多多留意。关于Index有好多方法，objectAtIndex，removeObjectAtIndex，replaceObjectAtIndex，exchangeObjectAtIndex等等，这些设计到Index都需要判断是否越界。</p><p>常见做法是给NSArray，NSMutableArray增加分类，增加这些异常保护的方法，不过如果原有工程里面已经写了大量的AtIndex系列的方法，去替换成新的分类的方法，效率会比较低。这里可以考虑用Swizzling做。</p><pre><code>#import &quot;NSArray+ Swizzling.h&quot;#import &quot;objc/runtime.h&quot;@implementation NSArray (Swizzling)+ (void)load {    Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:));    Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(swizzling_objectAtIndex:));    method_exchangeImplementations(fromMethod, toMethod);}- (id)swizzling_objectAtIndex:(NSUInteger)index {    if (self.count-1 &lt; index) {        // 异常处理        @try {            return [self swizzling_objectAtIndex:index];        }        @catch (NSException *exception) {            // 打印崩溃信息            NSLog(@&quot;---------- %s Crash Because Method %s  ----------\n&quot;, class_getName(self.class), __func__);            NSLog(@&quot;%@&quot;, [exception callStackSymbols]);            return nil;        }        @finally {}    } else {        return [self swizzling_objectAtIndex:index];    }}@end</code></pre><p>注意，调用这个objc_getClass方法的时候，要先知道类对应的真实的类名才行，NSArray其实在Runtime中对应着<strong>NSArrayI，NSMutableArray对应着</strong>NSArrayM，NSDictionary对应着<strong>NSDictionaryI，NSMutableDictionary对应着</strong>NSDictionaryM。</p><h1 id="Aspect-Oriented-Programming"><a href="#Aspect-Oriented-Programming" class="headerlink" title="Aspect Oriented Programming"></a>Aspect Oriented Programming</h1><p>Wikipedia 里对 AOP 是这么介绍的:<br>An aspect can alter the behavior of the base code by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches).<br>类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(Cross-cutting concern)，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="external nofollow noopener noreferrer" target="_blank">AOP</a>作用就是分离横向关注点(Cross-cutting concern)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。</p><p>接下来分析分析AOP的工作原理。<br>在上一篇中我们分析过了，在objc_msgSend函数查找IMP的过程中，如果在父类也没有找到相应的IMP，那么就会开始执行_class_resolveMethod方法，如果不是元类，就执行_class_resolveInstanceMethod，如果是元类，执行_class_resolveClassMethod。在这个方法中，允许开发者动态增加方法实现。这个阶段一般是给@dynamic属性变量提供动态方法的。<br>如果_class_resolveMethod无法处理，会开始选择备援接受者接受消息，这个时候就到了forwardingTargetForSelector方法。如果该方法返回非nil的对象，则使用该对象作为新的消息接收者。</p><pre><code>- (id)forwardingTargetForSelector:(SEL)aSelector{    if(aSelector == @selector(Method:)){        return otherObject;    }    return [super forwardingTargetForSelector:aSelector];}</code></pre><p>同样也可以替换类方法</p><pre><code>+ (id)forwardingTargetForSelector:(SEL)aSelector {    if(aSelector == @selector(xxx)) {        return NSClassFromString(@&quot;Class name&quot;);    }    return [super forwardingTargetForSelector:aSelector];}</code></pre><p>替换类方法返回值就是一个类对象。</p><p><font color="red" size="4" face="黑体">forwardingTargetForSelector这种方法属于单纯的转发，无法对消息的参数和返回值进行处理。 </font><br>最后到了完整转发阶段。<br>Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。</p><pre><code>// 为目标对象中被调用的方法返回一个NSMethodSignature实例#warning 运行时系统要求在执行标准转发时实现这个方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{    return [self.proxyTarget methodSignatureForSelector:sel];}</code></pre><p><font color="red" size="4" face="黑体"> 对象需要创建一个NSInvocation对象，把消息调用的全部细节封装进去，包括selector, target, arguments 等参数，还能够对返回结果进行处理。</font><br>AOP的多数操作就是在forwardInvocation中完成的。一般会分为2个阶段，一个是Intercepter注册阶段，一个是Intercepter执行阶段。</p><h2 id="Intercepter注册"><a href="#Intercepter注册" class="headerlink" title="Intercepter注册"></a>Intercepter注册</h2><p><img src="http://of685p9vy.bkt.clouddn.com/runtime16.jpg" alt="runtime16"><br>首先会把类里面的某个要切片的方法的IMP加入到Aspect中，类方法里面如果有forwardingTargetForSelector:的IMP，也要加入到Aspect中。<br><img src="http://of685p9vy.bkt.clouddn.com/runtime17.jpg" alt="runtime17"><br>然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换。两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:。这样主要的Intercepter注册就完成了。</p><h2 id="Intercepter执行"><a href="#Intercepter执行" class="headerlink" title="Intercepter执行"></a>Intercepter执行</h2><p><img src="http://of685p9vy.bkt.clouddn.com/runtime18.jpg" alt="runtime18"><br>当执行func()方法的时候，会去查找它的IMP，现在它的IMP已经被我们替换为了objc_msgForward()方法，于是开始查找备援转发对象。</p><p>查找备援接受者调用forwardingTargetForSelector:这个方法，由于这里是被我们hook过的，所以IMP指向的是hook过的forwardingTargetForSelector:方法。这里我们会返回Aspect的target，即选取Aspect作为备援接受者。<br>有了备援接受者之后，就会重新objc_msgSend，从消息发送阶段重头开始。<br>objc_msgSend找不到指定的IMP，再进行_class_resolveMethod，这里也没有找到，forwardingTargetForSelector:这里也不做处理，接着就会methodSignatureForSelector。在methodSignatureForSelector方法中创建一个NSInvocation对象，传递给最终的forwardInvocation方法。<br>Aspect里面的forwardInvocation方法会干所有切面的事情。这里转发逻辑就完全由我们自定义了。Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP，这里我们可以在forwardInvocation方法中去执行这些IMP。在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的。</p><h1 id="Isa-Swizzling"><a href="#Isa-Swizzling" class="headerlink" title="Isa Swizzling"></a>Isa Swizzling</h1><p>前面第二点谈到了黑魔法Method Swizzling，本质上就是对IMP和SEL进行交换。其实接下来要说的Isa Swizzling，和它类似，本质上也是交换，不过交换的是Isa。<br>在苹果的官方库里面有一个很有名的技术就用到了这个Isa Swizzling，那就是KVO——Key-Value Observing。<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" rel="external nofollow noopener noreferrer" target="_blank">Key-Value Observing Programming Guide</a>官方文档上对于KVO的定义是这样的:</p><p>Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p><p>官方给的就这么多，具体实现也没有说的很清楚。那只能我们自己来实验一下。<br>KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。<font color="red" size="4" face="黑体">所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。</font>具体实现应该是重写其setter方法即可。<br>官方是如何优雅的实现重写监听类的setter方法的呢？实验代码如下：</p><pre><code>Student *stu = [[Student alloc]init];[stu addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];</code></pre><p>我们可以打印观察isa指针的指向</p><pre><code>Printing description of stu-&gt;isa:  Student  Printing description of stu-&gt;isa:  NSKVONotifying_Student</code></pre><p>通过打印，我们可以很明显的看到，被观察的对象的isa变了，变成了NSKVONotifying_Student这个类了。</p><p>在@interface NSObject(NSKeyValueObserverRegistration) 这个分类里面，苹果定义了KVO的方法。</p><pre><code>- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0);- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath;</code></pre><p>KVO在调用addObserver方法之后，苹果的做法是在执行完addObserver: forKeyPath: options: context: 方法之后，把isa指向到另外一个类去。<br>在这个新类里面重写被观察的对象四个方法。class，setter，dealloc，_isKVOA。</p><h2 id="重写class方法"><a href="#重写class方法" class="headerlink" title="重写class方法"></a>重写class方法</h2><p>重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。</p><pre><code>static NSArray * ClassMethodNames(Class c)  {    NSMutableArray * array = [NSMutableArray array];    unsigned int methodCount = 0;    Method * methodList = class_copyMethodList(c, &amp;methodCount);    unsigned int i;    for(i = 0; i &lt; methodCount; i++) {        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];    }    free(methodList);    return array;}int main(int argc, char * argv[]) {      Student *stu = [[Student alloc]init];    NSLog(@&quot;self-&gt;isa:%@&quot;,object_getClass(stu));    NSLog(@&quot;self class:%@&quot;,[stu class]);    NSLog(@&quot;ClassMethodNames = %@&quot;,ClassMethodNames(object_getClass(stu)));    [stu addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil];    NSLog(@&quot;self-&gt;isa:%@&quot;,object_getClass(stu));    NSLog(@&quot;self class:%@&quot;,[stu class]);    NSLog(@&quot;ClassMethodNames = %@&quot;,ClassMethodNames(object_getClass(stu)));}</code></pre><p>打印结果</p><pre><code>self-&gt;isa:Student  self class:Student  ClassMethodNames = (  &quot;.cxx_destruct&quot;,name,  &quot;setName:&quot;)self-&gt;isa:NSKVONotifying_Student  self class:Student  ClassMethodNames = (  &quot;setName:&quot;,class,  dealloc,  &quot;_isKVOA&quot;)</code></pre><p>这里也可以看出，这是object_getClass方法和class方法的区别。</p><h2 id="重写setter方法"><a href="#重写setter方法" class="headerlink" title="重写setter方法"></a>重写setter方法</h2><p>在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用：</p><pre><code>- (void)willChangeValueForKey:(NSString *)key- (void)didChangeValueForKey:(NSString *)key</code></pre><p>在didChangeValueForKey:方法再调用</p><pre><code>- (void)observeValueForKeyPath:(NSString *)keyPath                      ofObject:(id)object                        change:(NSDictionary *)change                       context:(void *)context</code></pre><p>这里有几种情况需要说明一下：</p><ol><li>如果使用了KVC<br>如果有访问器方法，则运行时会在setter方法中调用will/didChangeValueForKey:方法；<br>如果没用访问器方法，运行时会在setValue:forKey方法中调用will/didChangeValueForKey:方法。<br>所以这种情况下，KVO是奏效的。</li><li>有访问器方法<br>运行时会重写访问器方法调用will/didChangeValueForKey:方法。 因此，直接调用访问器方法改变属性值时，KVO也能监听到。</li><li>直接调用will/didChangeValueForKey:方法。</li></ol><p>综上所述，只要setter中重写will/didChangeValueForKey:方法就可以使用KVO了。</p><h2 id="重写dealloc方法"><a href="#重写dealloc方法" class="headerlink" title="重写dealloc方法"></a>重写dealloc方法</h2><p>销毁新生成的NSKVONotifying_类。</p><h2 id="重写-isKVOA方法"><a href="#重写-isKVOA方法" class="headerlink" title="重写_isKVOA方法"></a>重写_isKVOA方法</h2><p>这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。</p><p>Foundation 到底为我们提供了哪些用于 KVO 的辅助函数。打开 terminal，使用 nm -a 命令查看 Foundation 中的信息：</p><pre><code>nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation</code></pre><p>里面包含了以下这些KVO中可能用到的函数</p><pre><code>00000000000233e7 t __NSSetDoubleValueAndNotify  00000000000f32ba t __NSSetFloatValueAndNotify  0000000000025025 t __NSSetIntValueAndNotify  000000000007fbb5 t __NSSetLongLongValueAndNotify  00000000000f33e8 t __NSSetLongValueAndNotify  000000000002d36c t __NSSetObjectValueAndNotify  0000000000024dc5 t __NSSetPointValueAndNotify  00000000000f39ba t __NSSetRangeValueAndNotify  00000000000f3aeb t __NSSetRectValueAndNotify  00000000000f3512 t __NSSetShortValueAndNotify  00000000000f3c2f t __NSSetSizeValueAndNotify  00000000000f363b t __NSSetUnsignedCharValueAndNotify  000000000006e91f t __NSSetUnsignedIntValueAndNotify  0000000000034b5b t __NSSetUnsignedLongLongValueAndNotify  00000000000f3766 t __NSSetUnsignedLongValueAndNotify  00000000000f3890 t __NSSetUnsignedShortValueAndNotify  00000000000f3060 t __NSSetValueAndNotifyForKeyInIvar  00000000000f30d7 t __NSSetValueAndNotifyForUndefinedKey</code></pre><p>Foundation 提供了大部分基础数据类型的辅助函数（Objective C中的 Boolean 只是 unsigned char 的 typedef，所以包括了，但没有 C++中的 bool），此外还包括一些常见的结构体如 Point, Range, Rect, Size，这表明这些结构体也可以用于自动键值观察，但要注意除此之外的结构体就不能用于自动键值观察了。对于所有 Objective C 对象对应的是 __NSSetObjectValueAndNotify 方法。</p><p>KVO即使是苹果官方的实现，也是有缺陷的，这里有一篇文章详细了分析了<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" rel="external nofollow noopener noreferrer" target="_blank">KVO中的缺陷</a>，主要问题在KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-addObserver:forKeyPath:options:context:方法所引发的一系列问题。而且只监听一两个属性值还好，如果监听的属性多了, 或者监听了多个对象的属性, 那有点麻烦，需要在方法里面写很多的if-else的判断。<br>最后，官方文档上对于KVO的实现的最后，给出了需要我们注意的一点是，永远不要用用isa来判断一个类的继承关系，而是应该用class方法来判断类的实例。</p><h1 id="Associated-Object-关联对象"><a href="#Associated-Object-关联对象" class="headerlink" title="Associated Object 关联对象"></a>Associated Object 关联对象</h1><p>Associated Objects是Objective-C 2.0中Runtime的特性之一。众所周知，在 Category 中，我们无法添加@property，因为添加了@property之后并不会自动帮我们生成实例变量以及存取方法。那么，我们现在就可以通过关联对象来实现在 Category 中添加属性的功能了。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>借用这篇经典文章<a href="http://nshipster.com/associated-objects/" rel="external nofollow noopener noreferrer" target="_blank">Associated Objects</a>里面的例子来说明一下用法。</p><pre><code>// NSObject+AssociatedObject.h@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end// NSObject+AssociatedObject.m@implementation NSObject (AssociatedObject)@dynamic associatedObject;- (void)setAssociatedObject:(id)object {    objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (id)associatedObject {    return objc_getAssociatedObject(self, @selector(associatedObject));}</code></pre><p>这里涉及到了3个函数：</p><pre><code>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)      __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)      __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);OBJC_EXPORT void objc_removeAssociatedObjects(id object)      __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1);</code></pre><p>来说明一下这些参数的意义：</p><ol><li>id object 设置关联对象的实例对象</li><li>const void <em>key 区分不同的关联对象的 key。这里会有3种写法。<br>使用 &amp;AssociatedObjectKey 作为key值<br>static char AssociatedObjectKey = “AssociatedKey”;<br>使用AssociatedKey 作为key值<br>static const void </em>AssociatedKey = “AssociatedKey”;<br>使用@selector<br>@selector(associatedKey)<br>3种方法都可以，不过推荐使用更加简洁的第三种方式。</li><li>id value 关联的对象</li><li>objc_AssociationPolicy policy 关联对象的存储策略，它是一个枚举，与property的attribute 相对应。</li></ol><p><img src="http://of685p9vy.bkt.clouddn.com/runtime20.jpg" alt="runtime20"><br>这里需要注意的是标记成OBJC_ASSOCIATION_ASSIGN的关联对象和 @property (weak) 是不一样的，上面表格中等价定义写的是 @property (unsafe_unretained)，对象被销毁时，属性值仍然还在。如果之后再次使用该对象就会导致程序闪退。所以我们在使用OBJC_ASSOCIATION_ASSIGN时，要格外注意。</p><p>According to the Deallocation Timeline described in WWDC 2011, Session 322(~36:00), associated objects are erased surprisingly late in the object lifecycle, inobject_dispose(), which is invoked by NSObject -dealloc.</p><p>关于关联对象还有一点需要说明的是objc_removeAssociatedObjects。这个方法是移除源对象中所有的关联对象，并不是其中之一。所以其方法参数中也没有传入指定的key。要删除指定的关联对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可。</p><pre><code>objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);</code></pre><p>关联对象3种使用场景</p><ol><li>为现有的类添加私有变量 </li><li>为现有的类添加公有属性 </li><li>为KVO创建一个关联的观察者。</li></ol><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="objc-setAssociatedObject方法"><a href="#objc-setAssociatedObject方法" class="headerlink" title="objc_setAssociatedObject方法"></a>objc_setAssociatedObject方法</h3><pre><code>void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) {      // retain the new value (if any) outside the lock.    ObjcAssociation old_association(0, nil);    id new_value = value ? acquireValue(value, policy) : nil;    {        AssociationsManager manager;        AssociationsHashMap &amp;associations(manager.associations());        disguised_ptr_t disguised_object = DISGUISE(object);        if (new_value) {            // break any existing association.            AssociationsHashMap::iterator i = associations.find(disguised_object);            if (i != associations.end()) {                // secondary table exists                ObjectAssociationMap *refs = i-&gt;second;                ObjectAssociationMap::iterator j = refs-&gt;find(key);                if (j != refs-&gt;end()) {                    old_association = j-&gt;second;                    j-&gt;second = ObjcAssociation(policy, new_value);                } else {                    (*refs)[key] = ObjcAssociation(policy, new_value);                }            } else {                // create the new association (first time).                ObjectAssociationMap *refs = new ObjectAssociationMap;                associations[disguised_object] = refs;                (*refs)[key] = ObjcAssociation(policy, new_value);                object-&gt;setHasAssociatedObjects();            }        } else {            // setting the association to nil breaks the association.            AssociationsHashMap::iterator i = associations.find(disguised_object);            if (i !=  associations.end()) {                ObjectAssociationMap *refs = i-&gt;second;                ObjectAssociationMap::iterator j = refs-&gt;find(key);                if (j != refs-&gt;end()) {                    old_association = j-&gt;second;                    refs-&gt;erase(j);                }            }        }    }    // release the old value (outside of the lock).    if (old_association.hasValue()) ReleaseValue()(old_association);}</code></pre><p>这个函数里面主要分为2部分，一部分是if里面对应的new_value不为nil的时候，另一部分是else里面对应的new_value为nil的情况。<br>当new_value不为nil的时候，查找时候，流程如下：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime21.png" alt="runtime21"><br>首先在AssociationsManager的结构如下</p><pre><code>class AssociationsManager {      static spinlock_t _lock;    static AssociationsHashMap *_map;public:      AssociationsManager()   { _lock.lock(); }    ~AssociationsManager()  { _lock.unlock(); }    AssociationsHashMap &amp;associations() {        if (_map == NULL)            _map = new AssociationsHashMap();        return *_map;    }};</code></pre><p>在AssociationsManager中有一个spinlock类型的自旋锁lock。保证每次只有一个线程对AssociationsManager进行操作，保证线程安全。AssociationsHashMap对应的是一张哈希表。</p><p>AssociationsHashMap哈希表里面key是disguised_ptr_t。</p><pre><code>disguised_ptr_t disguised_object = DISGUISE(object);</code></pre><p>通过调用DISGUISE( )方法获取object地址的指针。拿到disguised_object后，通过这个key值，在AssociationsHashMap哈希表里面找到对应的value值。而这个value值ObjcAssociationMap表的首地址。</p><p>在ObjcAssociationMap表中，key值是set方法里面传过来的形参const void *key，value值是ObjcAssociation对象。</p><p>ObjcAssociation对象中存储了set方法最后两个参数，policy和value。</p><p>所以objc_setAssociatedObject方法中传的4个形参在上图中已经标出。</p><p>现在弄清楚结构之后再来看源码，就很容易了。objc_setAssociatedObject方法的目的就是在这2张哈希表中存储对应的键值对。</p><p>先初始化一个 AssociationsManager，获取唯一的保存关联对象的哈希表 AssociationsHashMap，然后在AssociationsHashMap里面去查找object地址的指针。</p><p>如果找到，就找到了第二张表ObjectAssociationMap。在这张表里继续查找object的key。</p><pre><code>if (i != associations.end()) {      // secondary table exists    ObjectAssociationMap *refs = i-&gt;second;    ObjectAssociationMap::iterator j = refs-&gt;find(key);    if (j != refs-&gt;end()) {        old_association = j-&gt;second;        j-&gt;second = ObjcAssociation(policy, new_value);    } else {        (*refs)[key] = ObjcAssociation(policy, new_value);    }}</code></pre><p>如果在第二张表ObjectAssociationMap找到对应的ObjcAssociation对象，那就更新它的值。如果没有找到，就新建一个ObjcAssociation对象，放入第二张表ObjectAssociationMap中。</p><p>再回到第一张表AssociationsHashMap中，如果没有找到对应的键值</p><pre><code>ObjectAssociationMap *refs = new ObjectAssociationMap;  associations[disguised_object] = refs;  (*refs)[key] = ObjcAssociation(policy, new_value);object-&gt;setHasAssociatedObjects();</code></pre><p>此时就不存在第二张表ObjectAssociationMap了，这时就需要新建第二张ObjectAssociationMap表，来维护对象的所有新增属性。新建完第二张ObjectAssociationMap表之后，还需要再实例化 ObjcAssociation对象添加到 Map 中，调用setHasAssociatedObjects方法，表明当前对象含有关联对象。这里的setHasAssociatedObjects方法，改变的是isa_t结构体中的第二个标志位has_assoc的值。(关于isa_t结构体的结构，详情请看第一天的解析)</p><pre><code>// release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);</code></pre><p>最后如果老的association对象有值，此时还会释放它。</p><p>以上是new_value不为nil的情况。其实只要记住上面那2张表的结构，这个objc_setAssociatedObject的过程就是更新 / 新建 表中键值对的过程。</p><p>再来看看new_value为nil的情况</p><pre><code>// setting the association to nil breaks the association.AssociationsHashMap::iterator i = associations.find(disguised_object);  if (i !=  associations.end()) {      ObjectAssociationMap *refs = i-&gt;second;    ObjectAssociationMap::iterator j = refs-&gt;find(key);    if (j != refs-&gt;end()) {        old_association = j-&gt;second;        refs-&gt;erase(j);    }}</code></pre><p>当new_value为nil的时候，就是我们要移除关联对象的时候。这个时候就是在两张表中找到对应的键值，并调用erase( )方法，即可删除对应的关联对象。</p><h3 id="objc-getAssociatedObject方法"><a href="#objc-getAssociatedObject方法" class="headerlink" title="objc_getAssociatedObject方法"></a>objc_getAssociatedObject方法</h3><pre><code>id _object_get_associative_reference(id object, void *key) {      id value = nil;    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;    {        AssociationsManager manager;        AssociationsHashMap &amp;associations(manager.associations());        disguised_ptr_t disguised_object = DISGUISE(object);        AssociationsHashMap::iterator i = associations.find(disguised_object);        if (i != associations.end()) {            ObjectAssociationMap *refs = i-&gt;second;            ObjectAssociationMap::iterator j = refs-&gt;find(key);            if (j != refs-&gt;end()) {                ObjcAssociation &amp;entry = j-&gt;second;                value = entry.value();                policy = entry.policy();                if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);            }        }    }    if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {        ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);    }    return value;}</code></pre><p>objc_getAssociatedObject方法 很简单。就是通过遍历AssociationsHashMap哈希表 和 ObjcAssociationMap表的所有键值找到对应的ObjcAssociation对象，找到了就返回ObjcAssociation对象，没有找到就返回nil。</p><h3 id="objc-removeAssociatedObjects方法"><a href="#objc-removeAssociatedObjects方法" class="headerlink" title="objc_removeAssociatedObjects方法"></a>objc_removeAssociatedObjects方法</h3><pre><code>void objc_removeAssociatedObjects(id object) {      if (object &amp;&amp; object-&gt;hasAssociatedObjects()) {        _object_remove_assocations(object);    }}void _object_remove_assocations(id object) {      vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;    {        AssociationsManager manager;        AssociationsHashMap &amp;associations(manager.associations());        if (associations.size() == 0) return;        disguised_ptr_t disguised_object = DISGUISE(object);        AssociationsHashMap::iterator i = associations.find(disguised_object);        if (i != associations.end()) {            // copy all of the associations that need to be removed.            ObjectAssociationMap *refs = i-&gt;second;            for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) {                elements.push_back(j-&gt;second);            }            // remove the secondary table.            delete refs;            associations.erase(i);        }    }    // the calls to releaseValue() happen outside of the lock.    for_each(elements.begin(), elements.end(), ReleaseValue());}</code></pre><p>在移除关联对象object的时候，会先去判断object的isa_t中的第二位has_assoc的值，当object 存在并且object-&gt;hasAssociatedObjects( )值为1的时候，才会去调用_object_remove_assocations方法。</p><p>_object_remove_assocations方法的目的是删除第二张ObjcAssociationMap表，即删除所有的关联对象。删除第二张表，就需要在第一张AssociationsHashMap表中遍历查找。这里会把第二张ObjcAssociationMap表中所有的ObjcAssociation对象都存到一个数组elements里面，然后调用associations.erase( )删除第二张表。最后再遍历elements数组，把ObjcAssociation对象依次释放。</p><p>以上就是Associated Object关联对象3个函数的源码分析。</p><h1 id="动态的增加方法"><a href="#动态的增加方法" class="headerlink" title="动态的增加方法"></a>动态的增加方法</h1><p>在消息发送阶段，如果在父类中也没有找到相应的IMP，就会执行resolveInstanceMethod方法。在这个方法里面，我们可以动态的给类对象或者实例对象动态的增加方法。</p><pre><code>+ (BOOL)resolveInstanceMethod:(SEL)sel {    NSString *selectorString = NSStringFromSelector(sel);    if ([selectorString isEqualToString:@&quot;method1&quot;]) {        class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;);    }    return [super resolveInstanceMethod:sel];}</code></pre><p>关于方法操作方面的函数还有以下这些</p><pre><code>// 调用指定方法的实现id method_invoke ( id receiver, Method m, ... );  // 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... );  // 获取方法名SEL method_getName ( Method m );  // 返回方法的实现IMP method_getImplementation ( Method m );  // 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m );  // 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m );  // 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index );  // 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len );  // 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m );  // 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );  // 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m );  // 设置方法的实现IMP method_setImplementation ( Method m, IMP imp );  // 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 );</code></pre><p>这些方法其实平时不需要死记硬背，使用的时候只要先打出method开头，后面就会有补全信息，找到相应的方法，传入对应的方法即可。</p><h1 id="NSCoding的自动归档和自动解档"><a href="#NSCoding的自动归档和自动解档" class="headerlink" title="NSCoding的自动归档和自动解档"></a>NSCoding的自动归档和自动解档</h1><p>现在虽然手写归档和解档的时候不多了，但是自动操作还是用Runtime来实现的。</p><pre><code>- (void)encodeWithCoder:(NSCoder *)aCoder{    [aCoder encodeObject:self.name forKey:@&quot;name&quot;];}- (id)initWithCoder:(NSCoder *)aDecoder{    if (self = [super init]) {        self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;];    }    return self;}</code></pre><p>手动的有一个缺陷，如果属性多起来，要写好多行相似的代码，虽然功能是可以完美实现，但是看上去不是很优雅。<br>用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。</p><pre><code>#import &quot;Student.h&quot;#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt;@implementation Student- (void)encodeWithCoder:(NSCoder *)aCoder{    unsigned int outCount = 0;    Ivar *vars = class_copyIvarList([self class], &amp;outCount);    for (int i = 0; i &lt; outCount; i ++) {        Ivar var = vars[i];        const char *name = ivar_getName(var);        NSString *key = [NSString stringWithUTF8String:name];        id value = [self valueForKey:key];        [aCoder encodeObject:value forKey:key];    }}- (nullable __kindof)initWithCoder:(NSCoder *)aDecoder{    if (self = [super init]) {        unsigned int outCount = 0;        Ivar *vars = class_copyIvarList([self class], &amp;outCount);        for (int i = 0; i &lt; outCount; i ++) {            Ivar var = vars[i];            const char *name = ivar_getName(var);            NSString *key = [NSString stringWithUTF8String:name];            id value = [aDecoder decodeObjectForKey:key];            [self setValue:value forKey:key];        }    }    return self;}@end</code></pre><p>class_copyIvarList方法用来获取当前 Model 的所有成员变量，ivar_getName方法用来获取每个成员变量的名称。</p><h1 id="字典和模型互相转换"><a href="#字典和模型互相转换" class="headerlink" title="字典和模型互相转换"></a>字典和模型互相转换</h1><h2 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h2><p>1 调用 class_getProperty 方法获取当前 Model 的所有属性。<br>2 调用 property_copyAttributeList 获取属性列表。<br>3 根据属性名称生成 setter 方法。<br>4 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）</p><pre><code>+(id)objectWithKeyValues:(NSDictionary *)aDictionary{    id objc = [[self alloc] init];    for (NSString *key in aDictionary.allKeys) {        id value = aDictionary[key];        /*判断当前属性是不是Model*/        objc_property_t property = class_getProperty(self, key.UTF8String);        unsigned int outCount = 0;        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);        objc_property_attribute_t attribute = attributeList[0];        NSString *typeString = [NSString stringWithUTF8String:attribute.value];        if ([typeString isEqualToString:@&quot;@\&quot;Student\&quot;&quot;]) {            value = [self objectWithKeyValues:value];        }        //生成setter方法，并用objc_msgSend调用        NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];        SEL setter = sel_registerName(methodName.UTF8String);        if ([objc respondsToSelector:setter]) {            ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value);        }        free(attributeList);    }    return objc;}</code></pre><p>这段代码里面有一处判断typeString的，这里判断是防止model嵌套，比如说Student里面还有一层Student，那么这里就需要再次转换一次，当然这里有几层就需要转换几次。</p><p>几个出名的开源库JSONModel、MJExtension等都是通过这种方式实现的(利用runtime的class_copyIvarList获取属性数组，遍历模型对象的所有成员属性，根据属性名找到字典中key值进行赋值，当然这种方法只能解决NSString、NSNumber等，如果含有NSArray或NSDictionary，还要进行第二步转换，如果是字典数组，需要遍历数组中的字典，利用objectWithDict方法将字典转化为模型，在将模型放到数组中，最后把这个模型数组赋值给之前的字典数组)</p><h2 id="模型转字典"><a href="#模型转字典" class="headerlink" title="模型转字典"></a>模型转字典</h2><p>这里是上一部分字典转模型的逆步骤：<br>1 调用 class_copyPropertyList 方法获取当前 Model 的所有属性。<br>2 调用 property_getName 获取属性名称。<br>3 根据属性名称生成 getter 方法。<br>4 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）</p><pre><code>//模型转字典-(NSDictionary *)keyValuesWithObject{    unsigned int outCount = 0;    objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount);    NSMutableDictionary *dict = [NSMutableDictionary dictionary];    for (int i = 0; i &lt; outCount; i ++) {        objc_property_t property = propertyList[i];        //生成getter方法，并用objc_msgSend调用        const char *propertyName = property_getName(property);        SEL getter = sel_registerName(propertyName);        if ([self respondsToSelector:getter]) {            id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter);            /*判断当前属性是不是Model*/            if ([value isKindOfClass:[self class]] &amp;&amp; value) {                value = [value keyValuesWithObject];            }            if (value) {                NSString *key = [NSString stringWithUTF8String:propertyName];                [dict setObject:value forKey:key];            }        }    }    free(propertyList);    return dict;}</code></pre><p>中间注释那里的判断也是防止model嵌套，如果model里面还有一层model，那么model转字典的时候还需要再次转换，同样，有几层就需要转换几次。<br>不过上述的做法是假设字典里面不再包含二级字典，如果还包含数组，数组里面再包含字典，那还需要多级转换。这里有一个关于字典里面包含数组的demo.</p><h1 id="Runtime缺点"><a href="#Runtime缺点" class="headerlink" title="Runtime缺点"></a>Runtime缺点</h1><p>看了上面八大点之后，是不是感觉Runtime很神奇，可以迅速解决很多问题，然而，Runtime就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p><p>Method swizzling is not atomic<br>Method swizzling不是原子性操作。如果在+load方法里面写，是没有问题的，但是如果写在+initialize方法中就会出现一些奇怪的问题。</p><p>Changes behavior of un-owned code<br>如果你在一个类中重写一个方法，并且不调用super方法，你可能会导致一些问题出现。在大多数情况下，super方法是期望被调用的（除非有特殊说明）。如果你使用同样的思想来进行Swizzling，可能就会引起很多问题。如果你不调用原始的方法实现，那么你Swizzling改变的太多了，而导致整个程序变得不安全。</p><p>Possible naming conflicts<br>命名冲突是程序开发中经常遇到的一个问题。我们经常在类别中的前缀类名称和方法名称。不幸的是，命名冲突是在我们程序中的像一种瘟疫。一般我们会这样写Method Swizzling</p><pre><code>@interface NSView : NSObject- (void)setFrame:(NSRect)frame;@end@implementation NSView (MyViewAdditions)- (void)my_setFrame:(NSRect)frame {    // do custom work    [self my_setFrame:frame];}+ (void)load {    [self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)];}@end</code></pre><p>这样写看上去是没有问题的。但是如果在整个大型程序中还有另外一处定义了my_setFrame:方法呢？那又会造成命名冲突的问题。我们应该把上面的Swizzling改成以下这种样子：</p><pre><code>@implementation NSView (MyViewAdditions)static void MySetFrame(id self, SEL _cmd, NSRect frame);  static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame);static void MySetFrame(id self, SEL _cmd, NSRect frame) {      // do custom work    SetFrameIMP(self, _cmd, frame);}+ (void)load {    [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP];}@end</code></pre><p>虽然上面的代码看上去不是OC(因为使用了函数指针)，但是这种做法确实有效的防止了命名冲突的问题。原则上来说，其实上述做法更加符合标准化的Swizzling。这种做法可能和人们使用方法不同，但是这种做法更好。Swizzling Method 标准定义应该是如下的样子：</p><pre><code>typedef IMP *IMPPointer;BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) {      IMP imp = NULL;    Method method = class_getInstanceMethod(class, original);    if (method) {        const char *type = method_getTypeEncoding(method);        imp = class_replaceMethod(class, original, replacement, type);        if (!imp) {            imp = method_getImplementation(method);        }    }    if (imp &amp;&amp; store) { *store = imp; }    return (imp != NULL);}@implementation NSObject (FRRuntimeAdditions)+ (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store {    return class_swizzleMethodAndStore(self, original, replacement, store);}@end</code></pre><p>Swizzling changes the method’s arguments<br>这一点是这些问题中最大的一个。标准的Method Swizzling是不会改变方法参数的。使用Swizzling中，会改变传递给原来的一个函数实现的参数，例如</p><pre><code>[self my_setFrame:frame];</code></pre><p>会变转换成</p><pre><code>objc_msgSend(self, @selector(my_setFrame:), frame);</code></pre><p>objcmsgSend会去查找mysetFrame对应的IMP。一旦IMP找到，会把相同的参数传递进去。这里会找到最原始的setFrame:方法，调用执行它。但是这里的cmd参数并不是setFrame:，现在是mysetFrame:。原始的方法就被一个它不期待的接收参数调用了。这样并不好。</p><p>这里有一个简单的解决办法，上一条里面所说的，用函数指针去实现。参数就不会变了。</p><p>The order of swizzles matters<br>调用顺序对于Swizzling来说，很重要。假设setFrame:方法仅仅被定义在NSView类里面。</p><pre><code>[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)];</code></pre><p>当NSButton被swizzled之后会发生什么呢？大多数的swizzling应该保证不会替换setFrame:方法。因为一旦改了这个方法，会影响下面所有的View。所以它会去拉取实例方法。NSButton会使用已经存在的方法去重新定义setFrame:方法。以至于改变了IMP实现不会影响所有的View。相同的事情也会发生在对NSControl进行swizzling的时候，同样，IMP也是定义在NSView类里面，把NSControl 和 NSButton这上下两行swizzle顺序替换，结果也是相同的。</p><p>当调用NSButton的setFrame:方法，会去调用swizzled method，然后会跳入NSView类里面定义的setFrame:方法。NSControl 和 NSView对应的swizzled method不会被调用。</p><p>NSButton 和 NSControl各自调用各自的 swizzling方法，相互不会影响。</p><p>但是我们改变一下调用顺序，把NSView放在第一位调用。</p><pre><code>[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)];</code></pre><p>一旦这里的NSView先进行了swizzling了以后，情况就和上面大不相同了。NSControl的swizzling会去拉取NSView替换后的方法。相应的，NSControl在NSButton前面，NSButton也会去拉取到NSControl替换后的方法。这样就十分混乱了。但是顺序就是这样排列的。我们开发中如何能保证不出现这种混乱呢？</p><p>再者，在load方法中加载swizzle。如果仅仅是在已经加载完成的class中做了swizzle，那么这样做是安全的。load方法能保证父类会在其任何子类加载方法之前，加载相应的方法。这就保证了我们调用顺序的正确性。</p><p>Difficult to understand (looks recursive)<br>看着传统定义的swizzled method，我认为很难去预测会发生什么。但是对比上面标准的swizzling，还是很容易明白。这一点已经被解决了。</p><p>Difficult to debug<br>在调试中，会出现奇怪的堆栈调用信息，尤其是swizzled的命名很混乱，一切方法调用都是混乱的。对比标准的swizzled方式，你会在堆栈中看到清晰的命名方法。swizzling还有一个比较难调试的一点， 在于你很难记住当前确切的哪个方法已经被swizzling了。</p><p>在代码里面写好文档注释，即使你认为这段代码只有你一个人会看。遵循这个方式去实践，你的代码都会没问题。它的调试也没有多线程的调试困难。</p><p>#最后</p><p>经过在“神经病院”3天的修炼之后，对OC 的Runtime理解更深了。</p><p>关于黑魔法Method swizzling，我个人觉得如果使用得当，还是很安全的。一个简单而安全的措施是你仅仅只在load方法中去swizzle。和编程中很多事情一样，不了解它的时候会很危险可怕，但是一旦明白了它的原理之后，使用它又会变得非常正确高效。</p><p>对于多人开发，尤其是改动过Runtime的地方，文档记录一定要完整。如果某人不知道某个方法被Swizzling了，出现问题调试起来，十分蛋疼。</p><p>如果是SDK开发，某些Swizzling会改变全局的一些方法的时候，一定要在文档里面标注清楚，否则使用SDK的人不知道，出现各种奇怪的问题，又要被坑好久。</p><p>在合理使用 + 文档完整齐全 的情况下，解决特定问题，使用Runtime还是非常简洁安全的。</p><p>日常可能用的比较多的Runtime函数可能就是下面这些</p><pre><code>//获取cls类对象所有成员ivar结构体Ivar *class_copyIvarList(Class cls, unsigned int *outCount)  //获取cls类对象name对应的实例方法结构体Method class_getInstanceMethod(Class cls, SEL name)  //获取cls类对象name对应类方法结构体Method class_getClassMethod(Class cls, SEL name)  //获取cls类对象name对应方法imp实现IMP class_getMethodImplementation(Class cls, SEL name)  //测试cls对应的实例是否响应sel对应的方法BOOL class_respondsToSelector(Class cls, SEL sel)  //获取cls对应方法列表Method *class_copyMethodList(Class cls, unsigned int *outCount)  //测试cls是否遵守protocol协议BOOL class_conformsToProtocol(Class cls, Protocol *protocol)  //为cls类对象添加新方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)  //替换cls类对象中name对应方法的实现IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)  //为cls添加新成员BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types)  //为cls添加新属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount)  //获取m对应的选择器SEL method_getName(Method m)  //获取m对应的方法实现的imp指针IMP method_getImplementation(Method m)  //获取m方法的对应编码const char *method_getTypeEncoding(Method m)  //获取m方法参数的个数unsigned int method_getNumberOfArguments(Method m)  //copy方法返回值类型char *method_copyReturnType(Method m)  //获取m方法index索引参数的类型char *method_copyArgumentType(Method m, unsigned int index)  //获取m方法返回值类型void method_getReturnType(Method m, char *dst, size_t dst_len)  //获取方法的参数类型void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len)  //设置m方法的具体实现指针IMP method_setImplementation(Method m, IMP imp)  //交换m1，m2方法对应具体实现的函数指针void method_exchangeImplementations(Method m1, Method m2)  //获取v的名称const char *ivar_getName(Ivar v)  //获取v的类型编码const char *ivar_getTypeEncoding(Ivar v)  //设置object对象关联的对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)  //获取object关联的对象id objc_getAssociatedObject(id object, const void *key)  //移除object关联的对象void objc_removeAssociatedObjects(id object)</code></pre><p>这些API看上去不好记，其实使用的时候不难，关于方法操作的，一般都是method开头，关于类的，一般都是class开头的，其他的基本都是objc开头的，剩下的就看代码补全的提示，看方法名基本就能找到想要的方法了。当然很熟悉的话，可以直接打出指定方法，也不会依赖代码补全。</p><p>还有一些关于协议相关的API以及其他一些不常用，但是也可能用到的，就需要查看Objective-C Runtime官方API文档，这个官方文档里面详细说明，平时不懂的多看看文档。</p><p>最后请大家多多指教。</p><h1 id="涉及的资料"><a href="#涉及的资料" class="headerlink" title="涉及的资料"></a>涉及的资料</h1><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a></p><p><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" rel="external nofollow noopener noreferrer" target="_blank">《Objective-C +load vs +initialize》</a></p><p><a href="http://www.jianshu.com/p/0497afdad36d" rel="external nofollow noopener noreferrer" target="_blank">iOS动态性(二)可复用而且高度解耦的用户统计埋点实现</a></p><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" rel="external nofollow noopener noreferrer" target="_blank">Key-Value Observing Programming Guide</a></p><p><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" rel="external nofollow noopener noreferrer" target="_blank">KVO中的缺陷</a></p><p><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What are the Dangers of Method Swizzling in Objective C?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。&lt;br&gt;
    
    </summary>
    
      <category term="IOS_Runtime" scheme="http://yoursite.com/categories/IOS-Runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>NSInvocation的基本使</title>
    <link href="http://yoursite.com/wiki/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/foundation/NSInvocation%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF/"/>
    <id>http://yoursite.com/wiki/IOS基础知识/foundation/NSInvocation的基本使/</id>
    <published>2016-11-24T07:35:49.000Z</published>
    <updated>2018-02-28T08:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>iOS中可以间接向对象发送消息方式有两种：</p><ol><li>使用performSelector:withObject；</li><li>使用NSInvocation。<br>performSelector:withObject能完成简单的调用。但是对于大于2个的参数或者有返回值的消息，它就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。<a id="more"></a></li></ol><h1 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h1><p>An NSMethodSignature object records type information for the return value and parameters of a method. It is used to forward messages that the receiving object does not respond to—most notably in the case of distributed objects.<br>NSMethodSignature对象记录了方法的参数和返回值的类型信息。它被用于转发接受者不能处理的消息。</p><p>You typically create an NSMethodSignature object using the NSObject methodSignatureForSelector: instance method . It is then used to create an NSInvocation object,。</p><p>NSObject的实例方法methodSignatureForSelector:是创建NSMethodSignature对象的典型方法。 使用NSMethodSignature对象用于创建NSInvocation 对象(通过NSInvocation的invocationWithMethodSignature:类方法)。<br>下面是创建方法签名的代码：</p><pre><code>///1. 创建方法签名NSMethodSignature  *signature = [ViewController instanceMethodSignatureForSelector:@selector(fucWithName:)];if (signature == nil){    return;}</code></pre><p>使用numberOfArguments获取方法的参数个数，参数个数比sel多两个隐藏参数，一个是self,一个是_cmd。页可以使用getArgumentTypeAtIndex:获取参数。还可以使用methodReturnType获取返回类型。</p><h1 id="使用NSInvocation发送消息"><a href="#使用NSInvocation发送消息" class="headerlink" title="使用NSInvocation发送消息"></a>使用NSInvocation发送消息</h1><pre><code>///2、创建NSInvocation对象NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];invocation.target = self;//注意：这里的方法名一定要与方法签名类中的方法一致invocation.selector = @selector(fucWithName:);NSString *strName = @&quot;dog&quot;;//这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd)[invocation setArgument:&amp;strName atIndex:2];//3、调用invoke方法[invocation invoke];id res = nil;if (signature.methodReturnLength != 0){    [invocation getReturnValue:&amp;res];}NSLog(@&quot;res = %@&quot;,res);</code></pre><p>首先使用invocationWithMethodSignature:创建一个NSInvocation对象，然后设置对象的target、selector。NSInvocation对象实际上就是将方法封装为对象。然后使用invoke方法调用消息。使用getReturnValue获取返回值。输出的结果如下：</p><pre><code>ViewController object receive message functionWithName:res = dog</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS中可以间接向对象发送消息方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用performSelector:withObject；&lt;/li&gt;
&lt;li&gt;使用NSInvocation。&lt;br&gt;performSelector:withObject能完成简单的调用。但是对于大于2个的参数或者有返回值的消息，它就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。
    
    </summary>
    
      <category term="IOS基础知识" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="foundation" scheme="http://yoursite.com/categories/IOS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/foundation/"/>
    
    
      <category term="NSInvocation" scheme="http://yoursite.com/tags/NSInvocation/"/>
    
  </entry>
  
</feed>
