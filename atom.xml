<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-09T08:37:22.992Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>英语单词</title>
    <link href="http://yoursite.com/wiki/%E8%8B%B1%E8%AF%AD/%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/wiki/英语/英语单词/</id>
    <published>2019-12-09T04:07:12.000Z</published>
    <updated>2019-12-09T08:37:22.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="英语单词"><a href="#英语单词" class="headerlink" title="英语单词"></a>英语单词</h2><ol><li>semantics  英  [sɪˈmæntɪks]   美  [sɪˈmæntɪks] n. [语] 语义学；语义论</li><li>compliant 英 [kəmˈplaɪənt]   美 [kəmˈplaɪənt]  adj. 顺从的;百依百顺的;俯首帖耳的;(与系列规则相)符合的，一致的</li><li>attach 英 [əˈtætʃ]   美 [əˈtætʃ]   v. 把…固定，把…附(在…上);认为有重要性(或意义、价值、分量等);重视;(有时不受欢迎或未受邀请而)参加，和…在一起，缠着</li><li>inspect 英 [ɪnˈspekt]   美 [ɪnˈspekt]   v. 检查;查看;审视;视察</li><li>adapt 英 [əˈdæpt]   美 [əˈdæpt]   v. 使适应，使适合(新用途、新情况);适应(新情况);改编;改写</li><li>revoke  英  [rɪˈvəʊk]   美  [rɪˈvoʊk] vt. 撤回，取消；废除</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;英语单词&quot;&gt;&lt;a href=&quot;#英语单词&quot; class=&quot;headerlink&quot; title=&quot;英语单词&quot;&gt;&lt;/a&gt;英语单词&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;semantics  英  [sɪˈmæntɪks]   美  [sɪˈmæntɪks] n. [语] 语义学；
      
    
    </summary>
    
      <category term="英语" scheme="http://yoursite.com/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
  </entry>
  
  <entry>
    <title>获取Block捕获的变量</title>
    <link href="http://yoursite.com/wiki/IOS/Block/block_getCapture/"/>
    <id>http://yoursite.com/wiki/IOS/Block/block_getCapture/</id>
    <published>2019-12-04T04:07:12.000Z</published>
    <updated>2019-12-04T07:53:46.694Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解获取block捕获变量的原理，参考<a href="https://www.jianshu.com/p/8f02158649c5" rel="external nofollow noopener noreferrer" target="_blank">一种查看Block中引用的所有外部对象的实现方法</a></p><a id="more"></a><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void <span class="symbol">*</span>isa;</span><br><span class="line">volatile int32_t flags; // contains ref count</span><br><span class="line">int32_t reserved;</span><br><span class="line">void <span class="symbol">*</span>invoke;</span><br><span class="line">struct Block_descriptor_1 <span class="symbol">*</span>descriptor;</span><br><span class="line">struct Block_descriptor_2 <span class="symbol">*</span>descriptor2</span><br><span class="line">struct Block_descriptor_3 <span class="symbol">*</span>descriptor3</span><br><span class="line">        |</span><br><span class="line"><span class="string">        </span>|<span class="string">---------signature</span></span><br><span class="line"><span class="string">        </span>|<span class="string">---------layout</span></span><br><span class="line"><span class="string">                     </span>|<span class="string"> 压缩格式    0x02 3 4 表示有2个强引用、3个__block、4个弱引用对象</span></span><br><span class="line"><span class="string">strong NSObject * obj1; ------------</span>|<span class="string"> </span>|<span class="string">  </span>|</span><br><span class="line">strong NSObject <span class="symbol">*</span> obj2; ------------|<span class="string"> </span>|<span class="string">  </span>|</span><br><span class="line">                                      |<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj3;--------------|<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj4;--------------|<span class="string">  </span>|</span><br><span class="line">__block NSObject <span class="symbol">*</span> obj5;--------------|<span class="string">  </span>|</span><br><span class="line">                                         |</span><br><span class="line"><span class="string">__weak NSObject * obj6;------------------</span>|</span><br><span class="line">__weak NSObject <span class="symbol">*</span> obj7;------------------|</span><br><span class="line"><span class="string">__weak NSObject * obj8;------------------</span>|</span><br><span class="line">__weak NSObject <span class="symbol">*</span> obj9;------------------|</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void *isa;</span><br><span class="line">volatile int32_t flags; <span class="comment">// contains ref count</span></span><br><span class="line">int32_t reserved;</span><br><span class="line">void *invoke;</span><br><span class="line">struct Block_descriptor_1 *descriptor;</span><br><span class="line">struct Block_descriptor_2 *descriptor2</span><br><span class="line">struct Block_descriptor_3 *descriptor3</span><br><span class="line">        |</span><br><span class="line">        |---------signature</span><br><span class="line">        |---------layout</span><br><span class="line">                     | 非压缩格式 <span class="number">0x32</span> <span class="number">43</span> <span class="number">54</span> ... <span class="number">00</span></span><br><span class="line">strong NSObject * obj1; ------------| |  | <span class="number">0x32</span> 高<span class="number">4</span>位中<span class="number">3</span>表示强引用类型</span><br><span class="line">strong NSObject * obj2; ------------| |  |      低<span class="number">4</span>位中的<span class="number">2</span>表示有<span class="number">2</span>个对象 </span><br><span class="line">                                      |  |</span><br><span class="line">__block NSObject * obj3;--------------|  | <span class="number">0x43</span> 高<span class="number">4</span>位中<span class="number">4</span>表示__block类型</span><br><span class="line">__block NSObject * obj4;--------------|  |      低<span class="number">4</span>位中的<span class="number">3</span>表示有<span class="number">2</span>个对象 </span><br><span class="line">__block NSObject * obj5;--------------|  |</span><br><span class="line">                                         |</span><br><span class="line">__weak NSObject * obj6;------------------| <span class="number">0x54</span> 高<span class="number">4</span>位中<span class="number">5</span>表示若引用类型</span><br><span class="line">__weak NSObject * obj7;------------------|      低<span class="number">4</span>位中的<span class="number">4</span>表示有<span class="number">4</span>个对象 </span><br><span class="line">__weak NSObject * obj8;------------------|</span><br><span class="line">__weak NSObject * obj9;------------------|</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解获取block捕获变量的原理，参考&lt;a href=&quot;https://www.jianshu.com/p/8f02158649c5&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;一种查看Block中引用的所有外部对象的实现方法
&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/categories/IOS/Block/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/wiki/IOS/opensource/AlamoFire/alamofile%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/AlamoFire/alamofile学习/</id>
    <published>2019-11-29T10:24:38.759Z</published>
    <updated>2019-12-11T09:25:21.414Z</updated>
    
    <content type="html"><![CDATA[<p>AlamoFire 学习</p><h2 id="AlamoFire-使用"><a href="#AlamoFire-使用" class="headerlink" title="AlamoFire 使用"></a>AlamoFire 使用</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///创建一个请求</span></span><br><span class="line">let request = AF.request(<span class="string">"https://httpbin.org/post"</span>, method: .post)</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加一个完成Block，序列化器序列的类型String</span></span><br><span class="line">request<span class="selector-class">.responseString</span> &#123; response <span class="keyword">in</span></span><br><span class="line">                requestComplete(response<span class="selector-class">.response</span>, response.result)</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>下面是两个函数的定义</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">                               method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               headers: HTTPHeaders? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               interceptor: RequestInterceptor? = <span class="literal">nil</span>)</span></span> -&gt; <span class="type">DataRequest</span> </span><br><span class="line">                               </span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">responseString</span><span class="params">(queue: DispatchQueue = .main,</span></span></span><br><span class="line"><span class="function"><span class="params">                               encoding: String.Encoding? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                               completionHandler: @escaping <span class="params">(AFDataResponse&lt;String&gt;)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Self</span></span><br></pre></td></tr></table></figure><h2 id="拦截器部分（RequestInterceptor适配、重试）"><a href="#拦截器部分（RequestInterceptor适配、重试）" class="headerlink" title="拦截器部分（RequestInterceptor适配、重试）"></a>拦截器部分（RequestInterceptor适配、重试）</h2><h3 id="RequestAdapter-协议"><a href="#RequestAdapter-协议" class="headerlink" title="RequestAdapter 协议"></a>RequestAdapter 协议</h3><p>可以翻译为请求适配器，可以对URLRequest inspect、ptionally adapt，适配后，会执行completion block。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">RequestAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Inspects and adapts the specified `URLRequest` in some manner and calls the completion handler with the Result.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">adapt</span><span class="params">(<span class="number">_</span> urlRequest: URLRequest, <span class="keyword">for</span> session: Session, completion: @escaping <span class="params">(Result&lt;URLRequest, Error&gt;)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Result-表示结果的枚举"><a href="#Result-表示结果的枚举" class="headerlink" title="Result 表示结果的枚举"></a>Result 表示结果的枚举</h3><p>封装了成功和失败两个关联值的枚举</p><h3 id="RetryResult重试枚举"><a href="#RetryResult重试枚举" class="headerlink" title="RetryResult重试枚举"></a>RetryResult重试枚举</h3><p>封装了立即重试(retry)、延迟重试(retryWithDelay，关联了延时时间)、不重试（doNotRetry）、某种错误不重试(doNotRetryWithError，关联了某种类型的错误)</p><h3 id="RequestRetrier协议"><a href="#RequestRetrier协议" class="headerlink" title="RequestRetrier协议"></a>RequestRetrier协议</h3><p>RequestRetrier协议封装了：请求被session manager执行后，并遇到错误，是否重试。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">retry</span>(_ <span class="attribute">request</span>: Request, for <span class="attribute">session</span>: Session, dueTo <span class="attribute">error</span>: Error, <span class="attribute">completion</span>: <span class="variable">@escaping</span> (RetryResult) -&gt; Void)</span><br></pre></td></tr></table></figure><p>当决定重试时，通过completion完成重试</p><h3 id="RequestInterceptor-协议"><a href="#RequestInterceptor-协议" class="headerlink" title="RequestInterceptor 协议"></a>RequestInterceptor 协议</h3><p>准守RequestAdapter和RequestRetrier协议。</p><h3 id="Adapter-类"><a href="#Adapter-类" class="headerlink" title="Adapter 类"></a>Adapter 类</h3><p>基于闭包的RequestAdapter类型，准守RequestInterceptor协议</p><h3 id="Retrier-类"><a href="#Retrier-类" class="headerlink" title="Retrier 类"></a>Retrier 类</h3><p>基于闭包的RequestRetrier，准守RequestInterceptor协议</p><h3 id="Interceptor类"><a href="#Interceptor类" class="headerlink" title="Interceptor类"></a>Interceptor类</h3><p>可以使用多个RequestAdapter、RequestRetrier进行拦截，继承于RequestInterceptor。</p><p>内部存储多个RequestAdapter、RequestRetrier进行拦截</p><h2 id="ServerTrustManager–服务信任管理"><a href="#ServerTrustManager–服务信任管理" class="headerlink" title="ServerTrustManager–服务信任管理"></a>ServerTrustManager–服务信任管理</h2><p>管理 ServerTrustEvaluating和host的映射。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTrustManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 是否所有host都需要被评估，默认true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> allHostsMustBeEvaluated: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// host 与host对应的policies的字典</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> evaluators: [<span class="type">String</span>: <span class="type">ServerTrustEvaluating</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///返回host对应的评估器(ServerTrustEvaluating)</span></span><br><span class="line">    <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">serverTrustEvaluator</span><span class="params">(forHost host: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">ServerTrustEvaluating</span>?;</span><br></pre></td></tr></table></figure><h3 id="ServerTrustEvaluating-评估器协议"><a href="#ServerTrustEvaluating-评估器协议" class="headerlink" title="ServerTrustEvaluating 评估器协议"></a>ServerTrustEvaluating 评估器协议</h3><p>描述了评估服务器信任的API </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evaluate</span><span class="params">(<span class="number">_</span> trust: SecTrust, forHost host: String)</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure><p>评估给定host的trust是否可行</p><h3 id="DefaultTrustEvaluator"><a href="#DefaultTrustEvaluator" class="headerlink" title="DefaultTrustEvaluator"></a>DefaultTrustEvaluator</h3><p>使用服务器默认信任评估的评估器，可以控制是否验证挑战(challenge)提供的host</p><p>评估思路：</p><ol><li>host -&gt;SecPolicy </li><li>调用SecTrustSetPolicies函数，给SecTrust设置策略</li><li>调用SecTrustEvaluateWithError，验证SecTrust</li></ol><h3 id="RevocationTrustEvaluator-类"><a href="#RevocationTrustEvaluator-类" class="headerlink" title="RevocationTrustEvaluator  类"></a>RevocationTrustEvaluator  类</h3><p>使用默认的和撤销服务信任评估的评估器，继承ServerTrustEvaluating协议。</p><p>该信任评估和DefaultTrustEvaluator 的主要区别是创建策略的方法不同，使用的函数是SecPolicyCreateRevocation。</p><h3 id="PinnedCertificatesTrustEvaluator"><a href="#PinnedCertificatesTrustEvaluator" class="headerlink" title="PinnedCertificatesTrustEvaluator"></a>PinnedCertificatesTrustEvaluator</h3><p>使用证书评估服务器，只要任何一张固定证书匹配服务器的任何一张证书，就认为服务器是可信的。</p><p>自签名证书：</p><ol><li>调用SecTrustSetAnchorCertificates 函数，将证书添加到trust中。trust包含需要验证的证书、验证使用的策略、可选的验证证书的证书(AnchorCertificates )</li><li>SecTrustSetAnchorCertificatesOnly ，必须调用的，如果不调用，只用使用AnchorCertificates验证证书。调用了可以使用其他的证书，比如系统证书？</li><li>调用 SecTrustEvaluateWithError函数评估服务器信任</li></ol><p>正常情况：</p><p>判断固定证书是否包含在服务器的证书中，调用Set的 isDisjoint方法。</p><p>证书的读取方法 </p><ol><li>PinnedCertificatesTrustEvaluator初始哈方法中，调用了Bundle.main.af.certificates函数。</li><li>Bundle的扩展中有certificates计算属性，读取.cer, CER, .crt, .CRT, .der后缀文件。</li></ol><h3 id="PublicKeysTrustEvaluator"><a href="#PublicKeysTrustEvaluator" class="headerlink" title="PublicKeysTrustEvaluator"></a>PublicKeysTrustEvaluator</h3><p>使用公钥评估服务器信任。</p><h2 id="RedirectHandler-–-重定向处理"><a href="#RedirectHandler-–-重定向处理" class="headerlink" title="RedirectHandler – 重定向处理"></a>RedirectHandler – 重定向处理</h2><p>如何处理“服务端返回的重定向响应”—要求重定向到新的请求。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">task</span>(_ <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">              willBeRedirectedTo <span class="attribute">request</span>: URLRequest,</span><br><span class="line">              for <span class="attribute">response</span>: HTTPURLResponse,</span><br><span class="line">              <span class="attribute">completion</span>: <span class="variable">@escaping</span> (URLRequest?) -&gt; Void)</span><br></pre></td></tr></table></figure><h3 id="Redirector-结构体"><a href="#Redirector-结构体" class="headerlink" title="Redirector 结构体"></a>Redirector 结构体</h3><p>是一个便利的RedirectHandler，可以follow、not follow、modify a redirect。</p><p>扩展里面做了默认实现，</p><ol><li>follow，执行completion Block，参数是重定向指定的新请求。</li><li>not fllow 执行completion Block，参数是nil</li><li>如果是modify，使用modify关联的Closure创建新的请求，然后执行completion Block，参数是修改过的请求。</li></ol><h2 id="CachedResponseHandler-缓存协议"><a href="#CachedResponseHandler-缓存协议" class="headerlink" title="CachedResponseHandler 缓存协议"></a>CachedResponseHandler 缓存协议</h2><p>初始data task 是否缓存响应。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">func</span> <span class="selector-tag">dataTask</span>(_ <span class="attribute">task</span>: URLSessionDataTask,</span><br><span class="line">                  willCacheResponse <span class="attribute">response</span>: CachedURLResponse,</span><br><span class="line">                  <span class="attribute">completion</span>: <span class="variable">@escaping</span> (CachedURLResponse?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>completion 是执行缓存操作的Block，有三种情况</p><ol><li>服务器提供的缓存响应</li><li>修改响应的缓存</li><li>nil，不缓存</li></ol><h3 id="ResponseCacher-结构体"><a href="#ResponseCacher-结构体" class="headerlink" title="ResponseCacher 结构体"></a>ResponseCacher 结构体</h3><p>ResponseCacher是一个便利的缓存处理器（CachedResponseHandler），可以处理缓存、不缓存、修改缓存。</p><h2 id="RequestDelegate-请求代理"><a href="#RequestDelegate-请求代理" class="headerlink" title="RequestDelegate 请求代理"></a>RequestDelegate 请求代理</h2><p>执行URLSessionDelegate的方法的类。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private let fileManager: FileManager</span><br><span class="line">weak var <span class="keyword">state</span>Provider: SessionStateProvider?</span><br></pre></td></tr></table></figure><h3 id="SessionStateProvider"><a href="#SessionStateProvider" class="headerlink" title="SessionStateProvider"></a>SessionStateProvider</h3><p>SessionStateProvider协议提供Session的各种状态，包括主要的三要素：信任评估、 重定向、缓存。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> serverTrustManager: ServerTrustManager? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> redirectHandler: RedirectHandler? &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">var</span> cachedResponseHandler: CachedResponseHandler? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>一、SessionStateProvider功能：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SessionStateProvider</span>: <span class="title">AnyObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(<span class="keyword">for</span> task: URLSessionTask)</span></span> -&gt; <span class="type">Request</span>? <span class="comment">//创建请求</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didGatherMetricsForTask</span><span class="params">(<span class="number">_</span> task: URLSessionTask)</span></span> <span class="comment">//度量完成</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">didCompleteTask</span><span class="params">(<span class="number">_</span> task: URLSessionTask)</span></span><span class="comment">//任务完成</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">credential</span><span class="params">(<span class="keyword">for</span> task: URLSessionTask, <span class="keyword">in</span> protectionSpace: URLProtectionSpace)</span></span> -&gt; <span class="type">URLCredential</span>?<span class="comment">//创建凭证</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cancelRequestsForSessionInvalidation</span><span class="params">(with error: Error?)</span></span><span class="comment">//session非法时，取消请求 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二、 执行URLSessionDelegate的代理方法 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, didBecomeInvalidWithError <span class="attribute">error</span>: Error?) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="selector-tag">eventMonitor</span>?<span class="selector-class">.urlSession</span>(session, <span class="attribute">didBecomeInvalidWithError</span>: error)</span><br><span class="line"> <span class="selector-tag">stateProvider</span>?<span class="selector-class">.cancelRequestsForSessionInvalidation</span>(<span class="attribute">with</span>: error)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>session无效后，取消请求。</p><p>三、 URLSessionTaskDelegate 的代理方法 </p><p>插曲，下面是挑战的结构 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URLAuthenticationChallenge(挑战)</span><br><span class="line">    URLProtectionSpace(保护空间)  </span><br><span class="line">        realm 认证域</span><br><span class="line">        host  </span><br><span class="line">        port</span><br><span class="line">        authenticationMethod</span><br><span class="line">    proposedCredential: URLCredential(凭证)</span><br><span class="line">    用户名密码类型凭证</span><br><span class="line">    证书类型凭证</span><br><span class="line">    被接受的specified trust</span><br></pre></td></tr></table></figure><p>3.1 认证代理方法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         didReceive <span class="attribute">challenge</span>: URLAuthenticationChallenge,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void)</span><br></pre></td></tr></table></figure></p><p>根据挑战URLAuthenticationChallenge，创建凭证URLCredential。调用completionHandler接受挑战，参数是challenge.protectionSpace.authenticationMethod、凭证。</p><p>3.1 数据发送代理方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession,</span></span></span><br><span class="line"><span class="function"><span class="params">                         task: URLSessionTask,</span></span></span><br><span class="line"><span class="function"><span class="params">                         didSendBodyData bytesSent: Int64,</span></span></span><br><span class="line"><span class="function"><span class="params">                         totalBytesSent: Int64,</span></span></span><br><span class="line"><span class="function"><span class="params">                         totalBytesExpectedToSend: Int64)</span></span></span><br></pre></td></tr></table></figure></p><p>3.3  需要请求体代理方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         needNewBodyStream <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (InputStream?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>3.4 重定向代理方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">task</span>: URLSessionTask,</span><br><span class="line">                         willPerformHTTPRedirection <span class="attribute">response</span>: HTTPURLResponse,</span><br><span class="line">                         newRequest <span class="attribute">request</span>: URLRequest,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (URLRequest?) -&gt; Void)</span><br></pre></td></tr></table></figure><p>3.5 度量完成 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)</span></span></span><br></pre></td></tr></table></figure><p>3.6 请求完成 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, <span class="attribute">task</span>: URLSessionTask, didCompleteWithError <span class="attribute">error</span>: Error?) &#123;</span><br><span class="line">        <span class="selector-tag">eventMonitor</span>?<span class="selector-class">.urlSession</span>(session, <span class="attribute">task</span>: task, <span class="attribute">didCompleteWithError</span>: error)</span><br></pre></td></tr></table></figure><p>四、 URLSessionDataDelegate代理 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到数据</span></span><br><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession, <span class="attribute">dataTask</span>: URLSessionDataTask, didReceive <span class="attribute">data</span>: Data)</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存响应</span></span><br><span class="line"><span class="selector-tag">open</span> <span class="selector-tag">func</span> <span class="selector-tag">urlSession</span>(_ <span class="attribute">session</span>: URLSession,</span><br><span class="line">                         <span class="attribute">dataTask</span>: URLSessionDataTask,</span><br><span class="line">                         willCacheResponse <span class="attribute">proposedResponse</span>: CachedURLResponse,</span><br><span class="line">                         <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (CachedURLResponse?) -&gt; Void)</span><br></pre></td></tr></table></figure><h3 id="小小节"><a href="#小小节" class="headerlink" title="小小节"></a>小小节</h3><p>SessionDelegate 主要就是执行URLSession的代理。每个代理的工作是</p><ol><li>调用事件监控对应的方法(EventMonitor)</li><li>二是调用SessionStateProvider中定制方法、或者SessionStateProvider中的评估器、重定向器、缓冲器方法。</li></ol><p>所以，SessionStateProvider中的评估器、重定向器、缓冲器，就是为了将复杂的功能分离出去，独立为模块。</p><h2 id="请求参数编码"><a href="#请求参数编码" class="headerlink" title="请求参数编码"></a>请求参数编码</h2><h3 id="ParameterEncoding协议"><a href="#ParameterEncoding协议" class="headerlink" title="ParameterEncoding协议"></a>ParameterEncoding协议</h3><p>如何将一组请求参数应用到URLRequest中，封装了编码方法</p><h3 id="URLEncoding-类"><a href="#URLEncoding-类" class="headerlink" title="URLEncoding 类"></a>URLEncoding 类</h3><p>遵守ParameterEncoding协议，创建基于url-encoded的查询串，设置或添加到URL上，或者HTTP的body中。对于集合类型的参数如何编码，没有公开的规范，所以对于数组编码为形如foo[]=1&amp;foo[]=2的格式，字典形如foo[bar]=baz格式。可以通过ArrayEncoding删除中括号，BoolEncoding可以配置布尔值如何编码(比如true 1，false 0)</p><p>一、Destination 枚举 </p><p>url编码的查询串是否添加到已有查询串，还是添加到HTTP Body中</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">Destination</span> &#123;</span></span><br><span class="line">        /<span class="regexp">//</span> GET、HEAD、DELETE 查询，其他的请求放在Body中</span><br><span class="line">        <span class="keyword">case</span> methodDependent</span><br><span class="line">        <span class="keyword">case</span> queryString</span><br><span class="line">        <span class="keyword">case</span> httpBody</span><br><span class="line">        func encodesParametersInURL(<span class="keyword">for</span> <span class="symbol">method:</span> HTTPMethod) -&gt; Bool &#123;</span><br><span class="line">            switch <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">methodDependent:</span> <span class="keyword">return</span> [.get, .head, .delete].contains(method)</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">queryString:</span> <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">httpBody:</span> <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>二、 ArrayEncoding 枚举 </p><p>配置Array参数如何编码</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">enum</span> <span class="title">ArrayEncoding</span> &#123;</span></span><br><span class="line">        <span class="keyword">case</span> brackets</span><br><span class="line">        <span class="keyword">case</span> noBrackets</span><br><span class="line">        func encode(<span class="symbol">key:</span> String) -&gt; String &#123;</span><br><span class="line">            switch <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">brackets:</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"\(key)[]"</span></span><br><span class="line">            <span class="keyword">case</span> .<span class="symbol">noBrackets:</span></span><br><span class="line">                <span class="keyword">return</span> key</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>三、 BoolEncoding </p><p>配置Bool参数如何编码</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">enum</span> BoolEncoding &#123;</span><br><span class="line">        /// Encode `<span class="literal">true</span>` as `<span class="number">1</span>` <span class="literal">and</span> `<span class="literal">false</span>` as `<span class="number">0</span>`. This is the <span class="keyword">default</span> behavior.</span><br><span class="line">        <span class="keyword">case</span> numeric</span><br><span class="line">        /// Encode `<span class="literal">true</span>` <span class="literal">and</span> `<span class="literal">false</span>` as <span class="built_in">string</span> literals.</span><br><span class="line">        <span class="keyword">case</span> literal</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(value: Bool)</span> -&gt; <span class="title">String</span> &#123;</span></span><br><span class="line">            <span class="keyword">switch</span> self &#123;</span><br><span class="line">            <span class="keyword">case</span> .numeric:</span><br><span class="line">                <span class="keyword">return</span> value ? <span class="string">"1"</span> : <span class="string">"0"</span></span><br><span class="line">            <span class="keyword">case</span> .literal:</span><br><span class="line">                <span class="keyword">return</span> value ? <span class="string">"true"</span> : <span class="string">"false"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>四、 属性</p><ol><li>default 返回编码方式是.methodDependent的编码器(URLEncoding)</li><li>queryString 返回编码方式是.queryString的编码器(URLEncoding)</li><li>httpBody 返回编码方式是.httpBody的编码器(URLEncoding)</li><li>destination 目标编码方式 (实例属性)</li><li>arrayEncoding 编码使用的array的编码方式 (实例属性)</li><li>boolEncoding 编码器编码Bool属性使用的编码方式 (实例属性)</li></ol><p>五 方法 </p><p>实现了编码方法 </p><h3 id="JSONEncoding"><a href="#JSONEncoding" class="headerlink" title="JSONEncoding"></a>JSONEncoding</h3><p>使用JSONSerialization 将请求参数编码为JSON格式 ，并将Content type 设置为 application/json</p><h2 id="序列化响应"><a href="#序列化响应" class="headerlink" title="序列化响应"></a>序列化响应</h2><h3 id="DataResponseSerializerProtocol-协议"><a href="#DataResponseSerializerProtocol-协议" class="headerlink" title="DataResponseSerializerProtocol 协议"></a>DataResponseSerializerProtocol 协议</h3><p>DataResponseSerializerProtocol 协议</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataResponseSerializerProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of serialized object to be created.</span></span><br><span class="line">    associatedtype <span class="type">SerializedObject</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">serialize</span><span class="params">(request: URLRequest?, response: HTTPURLResponse?, data: Data?, error: Error?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SerializedObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了序列化的方法 </p><h3 id="DownloadResponseSerializerProtocol-协议"><a href="#DownloadResponseSerializerProtocol-协议" class="headerlink" title="DownloadResponseSerializerProtocol 协议"></a>DownloadResponseSerializerProtocol 协议</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DownloadResponseSerializerProtocol</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// The type of serialized object to be created.</span></span><br><span class="line">    associatedtype <span class="type">SerializedObject</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">serializeDownload</span><span class="params">(request: URLRequest?, response: HTTPURLResponse?, fileURL: URL?, error: Error?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">SerializedObject</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了下载请求序列化的方法 </p><h3 id="ResponseSerializer"><a href="#ResponseSerializer" class="headerlink" title="ResponseSerializer"></a>ResponseSerializer</h3><p>能够处理数据和下载的序列化器</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public protocol ResponseSerializer: DataResponseSerializerProtocol &amp; DownloadResponseSerializerProtocol &#123;</span><br><span class="line">    <span class="comment"><span class="markdown">/// 准备数据</span></span></span><br><span class="line">    <span class="keyword">var</span> dataPreprocessor: DataPreprocessor &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment"><span class="markdown">/// <span class="code">`HTTPMethod`</span>s for which empty response bodies </span>are<span class="markdown"> considered appropriate.</span></span></span><br><span class="line">    <span class="keyword">var</span> emptyRequestMethods: <span class="built_in">Set</span>&lt;HTTPMethod&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment"><span class="markdown">/// HTTP response codes for which empty response bodies </span>are<span class="markdown"> considered appropriate.</span></span></span><br><span class="line">    <span class="keyword">var</span> emptyResponseCodes: <span class="built_in">Set</span>&lt;Int&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="DataPreprocessor-数据预处理器"><a href="#DataPreprocessor-数据预处理器" class="headerlink" title="DataPreprocessor 数据预处理器"></a>DataPreprocessor 数据预处理器</h3><p>序列化前的数据处理 </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">DataPreprocessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Process           `Data` before it's handled by a serializer.</span></span><br><span class="line">    <span class="comment">/// - Parameter data: The raw `Data` to process.</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">preprocess</span><span class="params">(<span class="number">_</span> data: Data)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResponseSerializer-协议扩展"><a href="#ResponseSerializer-协议扩展" class="headerlink" title="ResponseSerializer  协议扩展"></a>ResponseSerializer  协议扩展</h3><p>该部分扩展添加了是否允许空响应的识别。</p><p>一、 判断请求是否允许空响应,从请求方式判断，Head允许<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">requestAllowsEmptyResponseData</span><span class="params">(<span class="number">_</span> request: URLRequest?)</span></span> -&gt; <span class="type">Bool</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> request.flatMap &#123; $<span class="number">0</span>.httpMethod &#125;</span><br><span class="line">            .flatMap(<span class="type">HTTPMethod</span>.<span class="keyword">init</span>)</span><br><span class="line">            .<span class="built_in">map</span> &#123; emptyRequestMethods.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>二、 判断响应是否允许空响应，从响应码判断，204 205 允许<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">responseAllowsEmptyResponseData</span><span class="params">(<span class="number">_</span> response: HTTPURLResponse?)</span></span> -&gt; <span class="type">Bool</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> response.flatMap &#123; $<span class="number">0</span>.statusCode &#125;</span><br><span class="line">            .<span class="built_in">map</span> &#123; emptyResponseCodes.<span class="built_in">contains</span>($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="DataRequest-在序列化文件中的扩展"><a href="#DataRequest-在序列化文件中的扩展" class="headerlink" title="DataRequest 在序列化文件中的扩展"></a>DataRequest 在序列化文件中的扩展</h3><p>一、 默认的只添加序列化完成的闭包，没有序列化功能 </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">response</span>(<span class="attribute">queue</span>: DispatchQueue = .main, <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Data?&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><p>二、 添加一个包含序列化器的完成处理闭包<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@discardableResult</span></span><br><span class="line">public func response&lt;<span class="attribute">Serializer</span>: DataResponseSerializerProtocol&gt;(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                                                                     <span class="attribute">responseSerializer</span>: Serializer,</span><br><span class="line">                                                                     <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Serializer.SerializedObject&gt;) -&gt; Void)</span><br></pre></td></tr></table></figure></p><p>内部调用appendResponseSerializer添加了一个序列化的block，block内部的工作 </p><ol><li>调用responseSerializer的序列化方法 serialize</li><li>将序列化的结果封装到result中，包含序列化完的数据、错误</li><li>封装DataResponse类型的response，包括request、response、data、serializationDuration、result</li><li>如果！(有错误有代理) 将完成block添加的responseSerializerDidComplete中</li><li>如果 (有错误有代理) ,调用重试结果</li></ol><p>重试的逻辑</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">序列化发生错误时，参数是序列化完成hander ：completionHandler</span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">| 调用</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line">Session-&gt;retryResult函数： retryCompletion</span><br><span class="line">                            <span class="string">|</span></span><br><span class="line">                            <span class="string">| 创建retryCompletion逻辑如下，参数是RetryResult</span></span><br><span class="line">                            <span class="string">|  </span></span><br><span class="line">                            <span class="number">1</span>. 如果不重试didComplete = completionHandler(response)</span><br><span class="line">                            <span class="number">2</span>. 有错误不重试，组装错误，didComplete =completionHandler(response)</span><br><span class="line">                            <span class="number">3</span>. 重试，执行重试操作</span><br><span class="line">                            <span class="number">4</span>. didComplete存储到session的 responseSerializerCompletions</span><br><span class="line"><span class="string">|</span></span><br><span class="line"><span class="string">| retryResult函数内部逻辑</span></span><br><span class="line"><span class="string">|</span></span><br><span class="line">    <span class="number">1</span>. 取得retrier：RequestRetrier </span><br><span class="line">    <span class="number">2</span>. 调用retry : 完成block，命名为 retryCompletion1</span><br><span class="line">                            <span class="string">|</span></span><br><span class="line">                            A. 重试没有错误，执行retryCompletion(result)</span><br><span class="line">                            B. 有错误，retryCompletion(.doNotRetryWithError(retryError))</span><br><span class="line">                    <span class="string">|</span></span><br><span class="line">                    <span class="string">| retry函数的逻辑</span></span><br><span class="line">                    <span class="string">|</span></span><br><span class="line">                    执行retryHandler函数： retryCompletion1</span><br></pre></td></tr></table></figure><p>上面是最外层，最外层的block最小，越下面的封装，block越大，最内侧的函数完成后执行最大的block，一直向最外层(顶部最小)扩展 </p><p>添加一个string类型的序列化器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">responseString</span>(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                               <span class="attribute">encoding</span>: String.Encoding? = nil,</span><br><span class="line">                               <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;String&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><p>添加一个JSON类型的序列化器</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">func</span> <span class="selector-tag">responseJSON</span>(<span class="attribute">queue</span>: DispatchQueue = .main,</span><br><span class="line">                             <span class="attribute">options</span>: JSONSerialization.ReadingOptions = .allowFragments,</span><br><span class="line">                             <span class="attribute">completionHandler</span>: <span class="variable">@escaping</span> (AFDataResponse&lt;Any&gt;) -&gt; Void) <span class="selector-tag">-</span>&gt; <span class="selector-tag">Self</span></span><br></pre></td></tr></table></figure><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p><code>Request</code> is the common superclass of all Alamofire request types and provides common state, delegate, and callback  handling.</p><p>request是有状态的，通过内部枚举State表征。状态通过resume、suspend、cancel函数改变。</p><h3 id="初始状态部分"><a href="#初始状态部分" class="headerlink" title="初始状态部分"></a>初始状态部分</h3><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">id:</span> UUID 为request提供唯一标识，用于hash、相等</span><br><span class="line"><span class="symbol">underlyingQueue:</span> DispatchQueue 内部异步操作的串行队列</span><br><span class="line"><span class="symbol">serializationQueue:</span> DispatchQueue 序列化使用的队列</span><br><span class="line"><span class="symbol">eventMonitor:</span> EventMonitor?   事件监控</span><br><span class="line"><span class="symbol">interceptor:</span> RequestInterceptor? 拦截器(重试器、适配器)</span><br><span class="line"><span class="symbol">delegate:</span> RequestDelegate?</span><br></pre></td></tr></table></figure><h3 id="可变状态部分"><a href="#可变状态部分" class="headerlink" title="可变状态部分"></a>可变状态部分</h3><p>通过结构体MutableState封装，包括进度、重定向、缓存、cURL、响应序列化、凭证、请求、task、metrics、重试次数、错误。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> protectedMutableState: Protector<span class="symbol">&lt;MutableState&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">struct MutableState &#123;</span><br><span class="line">        <span class="comment"><span class="markdown">/// State of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> state: State = .initialized</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`ProgressHandler`</span> and <span class="code">`DispatchQueue`</span> provided for upload progress callbacks.</span></span></span><br><span class="line">        <span class="keyword">var</span> uploadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`ProgressHandler`</span> and <span class="code">`DispatchQueue`</span> provided for download progress callbacks.</span></span></span><br><span class="line">        <span class="keyword">var</span> downloadProgressHandler: (handler: ProgressHandler, queue: DispatchQueue)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`RedirectHandler`</span> provided for to handle request redirection.</span></span></span><br><span class="line">        <span class="keyword">var</span> redirectHandler: RedirectHandler?</span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`CachedResponseHandler`</span> provided to handle response caching.</span></span></span><br><span class="line">        <span class="keyword">var</span> cachedResponseHandler: CachedResponseHandler?</span><br><span class="line">        <span class="comment"><span class="markdown">/// Closure called when </span>the<span class="markdown"> <span class="code">`Request`</span> is able to create </span>a<span class="markdown"> cURL description of itself.</span></span></span><br><span class="line">        <span class="keyword">var</span> cURLHandler: ((<span class="built_in">String</span>) -&gt; Void)?</span><br><span class="line">        <span class="comment"><span class="markdown">/// Response serialization closures that handle response parsing.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializers: [() -&gt; Void] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Response serialization completion closures executed once all response serializers </span>are<span class="markdown"> complete.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializerCompletions: [() -&gt; Void] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Whether response serializer processing is finished.</span></span></span><br><span class="line">        <span class="keyword">var</span> responseSerializerProcessingFinished = <span class="keyword">false</span></span><br><span class="line">        <span class="comment"><span class="markdown">/// <span class="code">`URLCredential`</span> used for authentication challenges.</span></span></span><br><span class="line">        <span class="keyword">var</span> credential: URLCredential?</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLRequest`</span>s created by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> requests: [URLRequest] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLSessionTask`</span>s created by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> tasks: [URLSessionTask] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// All <span class="code">`URLSessionTaskMetrics`</span> values gathered by Alamofire on behalf of </span>the<span class="markdown"> <span class="code">`Request`</span>. Should correspond</span></span></span><br><span class="line">        <span class="comment"><span class="markdown">/// exactly </span>the<span class="markdown"> </span>the<span class="markdown"> <span class="code">`tasks`</span> created.</span></span></span><br><span class="line">        <span class="keyword">var</span> metrics: [URLSessionTaskMetrics] = []</span><br><span class="line">        <span class="comment"><span class="markdown">/// Number of times any retriers provided retried </span>the<span class="markdown"> <span class="code">`Request`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> retryCount = <span class="number">0</span></span><br><span class="line">        <span class="comment"><span class="markdown">/// Final <span class="code">`AFError`</span> for </span>the<span class="markdown"> <span class="code">`Request`</span>, whether from various internal Alamofire calls or as </span>a<span class="markdown"> result of </span>a<span class="markdown"> <span class="code">`task`</span>.</span></span></span><br><span class="line">        <span class="keyword">var</span> error: AFError?</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>内部结构体MutableState 封装可变状态，可能被外部访问</p><h3 id="进度部分"><a href="#进度部分" class="headerlink" title="进度部分"></a>进度部分</h3><p>包括进度对象和进度处理器 </p><h3 id="重定向、缓存"><a href="#重定向、缓存" class="headerlink" title="重定向、缓存"></a>重定向、缓存</h3><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>返回 lastTask?.response as? HTTPURLResponse</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>数组存储着task</p><p>下面是功能部分 </p><h3 id="内部功能"><a href="#内部功能" class="headerlink" title="内部功能"></a>内部功能</h3><p>一 、didFailToCreateURLRequest</p><p>didFailToCreateURLRequest  —retryOrFinish – 调用delegate的retryResult—传递的block内部有finish– processNextResponseSerializer– 找出下一个序列化Hander在serializationQueue队列中执行，如果没有下一个句柄，表示序列化完成执行完成序列化Hander responseSerializerCompletions –&gt; cleanup</p><p>didCompleteTask 也是调用 retryOrFinish函数 </p><h3 id="验证响应"><a href="#验证响应" class="headerlink" title="验证响应"></a>验证响应</h3><p>实现在Validation文件中，验证response code、 response mime type 包含在request accept type中</p><h2 id="Protector"><a href="#Protector" class="headerlink" title="Protector"></a>Protector</h2><p>线程安全的设计思想,定义一个Protector的类，类中有一个锁，需要加锁操作放在block中。 </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UnfairLock </span><br><span class="line">     unfairLock: os_unfair_lock_t  锁对象</span><br><span class="line">     aroud  输入无参闭包，加锁执行，返回闭包结果</span><br><span class="line">     </span><br><span class="line">     func around&lt;T&gt;<span class="function"><span class="params">(_ closure: () -&gt; T)</span> -&gt;</span> T &#123;</span><br><span class="line">        lock(); </span><br><span class="line">        defer &#123; </span><br><span class="line">             unlock() </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closure()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Protector </span><br><span class="line">    <span class="keyword">let</span> lock = UnfairLock()</span><br><span class="line">    <span class="keyword">var</span> value: T</span><br><span class="line">    directValue 获取加锁对象</span><br><span class="line">    read 读保护资源的操作 ，入参block<span class="function"><span class="params">(带参数)</span> -&gt;</span>封装<span class="function"><span class="params">(非无参数的block)</span>-&gt;</span>调用锁的aroud方法</span><br><span class="line">    write 写保护资源的操作</span><br></pre></td></tr></table></figure><p>好处：</p><ol><li>不用每个受保护资源都写加锁解锁代码。</li><li>泛型使Protector能容纳任何类型。</li></ol><h2 id="session"><a href="#session" class="headerlink" title="session"></a>session</h2><ol><li>创建和管理request</li><li>提供了request的基本功能：队列、拦截、信任管理、缓存响应</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">session: URLSession  创建task使用的session</span></span><br><span class="line"><span class="section">delegate: SessionDelegate 处理URLSessionDelegate的代理，并与Request交互</span></span><br><span class="line"><span class="section">rootQueue: DispatchQueue 内部回调、状态更新的队列，必须是串行队列</span></span><br><span class="line"><span class="section">startRequestsImmediately: Bool 创建request后，是否立即调用resume</span></span><br><span class="line"><span class="section">requestQueue: DispatchQueue 可以异步创建请求，默认使用rootQueue</span></span><br><span class="line"><span class="section">serializationQueue: DispatchQueue  解析响应使用的队列</span></span><br><span class="line"><span class="section">interceptor: RequestInterceptor? 包括重试、适配器</span></span><br><span class="line"><span class="section">serverTrustManager: ServerTrustManager? 评估信任挑战、提供证书、公钥</span></span><br><span class="line"><span class="section">redirectHandler: RedirectHandler?  提供定制化重定向</span></span><br><span class="line"><span class="section">cachedResponseHandler: CachedResponseHandler? 响应缓存管理</span></span><br><span class="line"><span class="section">eventMonitor: CompositeEventMonitor  session事件、请求事件的监控</span></span><br><span class="line"><span class="section">defaultEventMonitors: [EventMonitor]  默认的通知类型监控</span></span><br><span class="line">requestTaskMap = RequestTaskMap() request和task的映射</span><br><span class="line"><span class="section">activeRequests: Set&lt;Request&gt;  激活状态的请求</span></span><br></pre></td></tr></table></figure><p>EventMonitor ： 包括session的事件和request生命周期中的事件</p><p>SessionDelegate  ：执行URLSessionDelegate的代理</p><h2 id="RequestTaskMap"><a href="#RequestTaskMap" class="headerlink" title="RequestTaskMap"></a>RequestTaskMap</h2><p>存储请求和tast的双向映射，两个字典 ，下标操作的新值未空是删除功能</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SessionDelegate</span><br><span class="line"> fileManager</span><br><span class="line"> 处理下载文件时候使用</span><br><span class="line">       <span class="keyword">state</span>Provider</span><br><span class="line">       serverTrustManager</span><br><span class="line">        ServerTrustManager类型</span><br><span class="line">        管理host ServerTrustEvaluating映射</span><br><span class="line">       redirectHandler</span><br><span class="line">       cachedResponseHandler   </span><br><span class="line">       </span><br><span class="line">       eventMonitor</span><br><span class="line">       包括session的事件和request生命周期中的事件</span><br><span class="line">           queue</span><br></pre></td></tr></table></figure><h2 id="Extended命名作用域"><a href="#Extended命名作用域" class="headerlink" title="Extended命名作用域"></a>Extended命名作用域</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">AlamofireExtended</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">AlamofireExtension</span> <span class="title">where</span> <span class="title">ExtendedType</span> == [<span class="title">SecCertificate</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data: [<span class="type">Data</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> type.<span class="built_in">map</span> &#123; <span class="type">SecCertificateCopyData</span>($<span class="number">0</span>) <span class="keyword">as</span> <span class="type">Data</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> publicKeys: [<span class="type">SecKey</span>] &#123;</span><br><span class="line">        <span class="keyword">return</span> type.compactMap &#123; $<span class="number">0</span>.af.publicKey &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">AlamofireExtension</span>&lt;<span class="title">ExtendedType</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">ExtendedType</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">AlamofireExtended</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> af: <span class="type">AlamofireExtension</span>&lt;<span class="type">ExtendedType</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">AlamofireExtended</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> af: <span class="type">AlamofireExtension</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="type">AlamofireExtension</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span>&#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明Array准守AlamofireExtended协议， AlamofireExtended协议中有一个af属性，类型是AlamofireExtension结构体类型。</p><p>也就是说如果让Array准守AlamofireExtended协议，即Array中存在名为af计算属性<br>充当命名空间的作用。</p><p>如果想给Array扩展功能，让Array遵守AlamofireExtended，然后给 AlamofireExtension添加扩展功能，通过type成员找到原始期望扩展的类Array。</p><p>实际上就是加了个中间层。把系统类的扩展转移到了AlamofireExtension中。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Array ： AlamofireExtended </span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line">af属性：AlamofireExtension<span class="variable">&lt;&gt;</span></span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line">type：被扩展的类型</span><br><span class="line">  |</span><br><span class="line"><span class="string">  </span>|</span><br><span class="line"><span class="variable">&lt;-------AlamofireExtension通过type可以直接找到Array本身</span></span><br></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlamofireExtension <span class="keyword">where</span> ExtendedType: <span class="built_in">Array</span> <span class="comment">//只要扩展的是array才能调用的方法</span></span><br></pre></td></tr></table></figure><p>下面是使用方法的理解“</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">certificates:[SecCertificate]</span><br><span class="line">certificates<span class="selector-class">.af</span><span class="selector-class">.publicKeys</span> </span><br><span class="line"></span><br><span class="line">extension Array: AlamofireExtended &#123;&#125;</span><br><span class="line">public extension AlamofireExtension where ExtendedType == [SecCertificate] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 枚举证书，获取公钥</span></span><br><span class="line">    <span class="selector-tag">var</span> publicKeys: [SecKey] &#123;</span><br><span class="line">        return type<span class="selector-class">.compactMap</span> &#123; $<span class="number">0</span><span class="selector-class">.af</span><span class="selector-class">.publicKey</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学习到的知识"><a href="#学习到的知识" class="headerlink" title="学习到的知识"></a>学习到的知识</h2><h3 id="OptionSet"><a href="#OptionSet" class="headerlink" title="OptionSet"></a>OptionSet</h3><p>OptionSet可以描述位集，每一位表示集合中的一个成员，该协议可以做一些结合的运算。协议有一个rawValue、一些选项。其中选项的值未1、2、4、8 等。以使每个位表示一个选项。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ShippingOptions</span></span>: OptionSet &#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: Int</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> nextDay    = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> secondDay  = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> priority   = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> standard   = ShippingOptions(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> express: ShippingOptions = [.nextDay, .secondDay]</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> all: ShippingOptions = [.express, .priority, .standard]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感想：</p><ol><li>相关的两个成员属性使用元组表示，可以减少属性个数，便于管理</li><li>只要有几种可选的处理方式，就使用枚举。枚举应用非常多</li><li>函数式编程，消费掉一个参数，生成新的block。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AlamoFire 学习&lt;/p&gt;
&lt;h2 id=&quot;AlamoFire-使用&quot;&gt;&lt;a href=&quot;#AlamoFire-使用&quot; class=&quot;headerlink&quot; title=&quot;AlamoFire 使用&quot;&gt;&lt;/a&gt;AlamoFire 使用&lt;/h2&gt;&lt;figure class
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="AlamoFire" scheme="http://yoursite.com/categories/IOS/opensource/AlamoFire/"/>
    
    
  </entry>
  
  <entry>
    <title>13 汇编分析String、Array的结构</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/13%20%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90String%E3%80%81Array%E7%9A%84%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/13 汇编分析String、Array的结构/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-22T06:52:10.463Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>0x30是数字0的ascii码</li><li>tag pointer 干嘛用的？直接将内容放在变量的地址中</li><li>rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验证。</li></ul><p>长度大于0xf 的存储情况：</p><ol><li>rax 长度   </li><li>rdx 地址，地址-0x7ffffffffffffe0=真实存储地址</li></ol><p>内存分布情况：</p><ol><li>代码区</li><li>常量区</li><li>全局区</li><li>堆区</li><li>栈区</li></ol><p>内存布局图：</p><ol><li>mach-o</li><li>运行内存</li><li>动态库</li></ol><blockquote><p>小技巧： 字符串的真实地址 ： 后面的地址+0x20</p><p>小技巧：1后面跟着4个0 一般是全局区，如果不是那么一般是堆区</p></blockquote><p>append干了什么事情： 变为堆空间， 跳过32字节，后面就是内容是存储的真实字符串</p><p><strong>小小总结：</strong></p><ol><li>字符串长度&lt;=0xf  字符串内容直接存储在变量的内存中</li><li>字符串的长度&gt;0xf,字符串存放在常量区（__TEXT.cstring）,地址信息存储在在变量的后8自己中，真实地址= 后面的地址+0x20</li><li>append 后有大于0xf，会开辟空间</li></ol><p><strong>dyld_stub_binder</strong></p><ol><li>stub 翻译为符号</li><li>动态库中的函数，加载完动态库才能知道（也就是运行的时候才知道），那么编译的时候怎么办？ 放置一个占位地址，这个函数就是一个占位地址</li></ol><p><strong>数组的内存结构</strong></p><p> arr占用8字节，这8字节存储着堆空间地址，堆空间结构：</p><ol><li>？</li><li>引用计数</li><li>元素数量</li><li>数组容量</li><li>元素1</li><li>元素2</li><li>元素3</li><li>元素n</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;0x30是数字0的ascii码&lt;/li&gt;
&lt;li&gt;tag pointer 干嘛用的？直接将内容放在变量的地址中&lt;/li&gt;
&lt;li&gt;rax rdx 两个寄存器存储返回值，rdi rsi rdx存储参数，可以创建一个多参数函数，验
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>18 swift OC 混合编程</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/18%20swift%20OC/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/18 swift OC/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-26T10:45:33.885Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用</p><p>补存内容 ： catch默认存在error</p><p>#warning()<br>// TODO:  </p><p>编码习惯： xcode自己生成的类冒号跟着前面        </p><p>@UIApplicationMain  就是新的入口 </p><p>Swift调用OC写的东西 </p><p>1 新建桥接文件 ： targetName-Bridging-Header.h  就是OC暴露给swift的东西<br>@_silgen_name(“sum”) func malloc(v1: Int32, v2: Int) -&gt; Int32</p><p>swift 暴露给OC的条件</p><ol><li>继承NSObject</li><li>objcMembers    或使用@objc 修饰需要暴露的成员 </li></ol><p>@objc  还能修改暴露给OC的类名的名称， 方法名 </p><p>字符串处理 ：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;表达式模式，调用了~=运算符 ，是一些复杂的情况 ，简单的没有调用&lt;/p&gt;
&lt;p&gt;补存内容 ： catch默认存在error&lt;/p&gt;
&lt;p&gt;#warning()&lt;br&gt;// TODO:  &lt;/p&gt;
&lt;p&gt;编码习惯： xcode自己生成的类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>协议</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/11%20%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/11 协议/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:22:03.805Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li>协议中的变量： 属性一律var</li><li>协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类的必要初始化器， 子类实现的时候，可以省略override。</li><li>非可失败的初始化器 ：  非可失败、 ！</li><li>可失败： 三种可以</li><li>协议组合 &amp;</li><li>类型属性必须是static</li><li>遍历枚举  CaseIterable   allcases</li><li>CustomStringConvertible description</li><li>any anyObject 只能被类准守</li><li>is 判断是否是某种类型 as ？ Student 可选项 as Any</li><li>metadata 元类型</li><li>Persion.self 和堆空间的前8个字节存储一样的内容  就是元类型</li><li>Persion.Type</li><li><p>AnyClass = AnyObject.type</p></li><li><p>类名和X.self有很多相同点，可以调用方法，不同点：X.self能赋值给变量，类名不能复制给变量。</p></li></ul><ol><li>使用元类型调用的初始化方法一定是requied的，因为你可以给元类型传递一个子类的对象，如果子类没有该初始化方法，那么就失败。为了不失败，所以标记为requied</li><li>Self  应用于返回值，如果协议中定义的方法返回当前对象，在子类中就需要返回子类对象，所以使用Self</li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;协议中的变量： 属性一律var&lt;/li&gt;
&lt;li&gt;协议里面要求的init 刚好是父类实现的init方法，需要required、override。required（来源于协议）和 override（来源于父类）都需要。而， 父类
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>14 枚举的本质、溢出运算符</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/14%20%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%9C%AC%E8%B4%A8%E3%80%81%E6%BA%A2%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/14 枚举的本质、溢出运算符/</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-25T05:52:49.910Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>运算符重载</p><p>运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能</p><p>运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法</p><p>static prefix func -(Int)-&gt; Int  {</p><p>}</p><p>Equatable协议<br>如果一个类已经有相等的方法，也要声明为准守Equatable协议，好处</p><p>明确告诉别人，我有比较功能<br>很多有要求Equatable协议的地方，都可以使用了<br>也能使用!= 运算符</p><p>对于引用类型，比较存储的地址值是否相等使用 ===       !==</p><p>Comparable 协议</p><p>比较的结果三种情况</p><p>自定义运算符<br>prefix operator<br>postfix operator<br>infix operator : 优先级组</p><p>结合性 ： 多个运算符，描述先从左边开始，还是先从右边开始 ，如果没有结合性，表示不允许连续出现多个运算符<br>优先级 ： 高于什么，低于什么<br>assignment ： 在可选链拥有和赋值运算符有一样的优先级</p><p>扩展</p><p>不能添加存储属性： 不能改变内存结构<br>扩展可以给协议提供默认实现，也间接的实现了可选协议</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;运算符重载&lt;/p&gt;
&lt;p&gt;运算符重载： 类、结构体、枚举都可以为现有的运算符提供新的动能&lt;/p&gt;
&lt;p&gt;运算符重载一般写在类里面 ，为了不定义实例，就能调用，定义为类型方法&lt;/p&gt;
&lt;p&gt;static prefix func -(Int)
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>错误处理</title>
    <link href="http://yoursite.com/wiki/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/12%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%20/"/>
    <id>http://yoursite.com/wiki/IOS/swift语言/小码哥视频学习记录/12 错误处理 /</id>
    <published>2019-11-20T04:07:12.000Z</published>
    <updated>2019-11-21T10:24:12.017Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p><strong>常见的错误</strong>：</p><ol><li>语法</li><li>逻辑</li><li>运行</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;常见的错误&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;语法&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="swift语言" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/"/>
    
      <category term="小码哥视频学习记录" scheme="http://yoursite.com/categories/IOS/swift%E8%AF%AD%E8%A8%80/%E5%B0%8F%E7%A0%81%E5%93%A5%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Block的本质</title>
    <link href="http://yoursite.com/wiki/IOS/Block/block/"/>
    <id>http://yoursite.com/wiki/IOS/Block/block/</id>
    <published>2019-09-27T04:07:12.000Z</published>
    <updated>2019-09-29T02:28:33.183Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解block的本质</p><a id="more"></a><h2 id="block的底层实现"><a href="#block的底层实现" class="headerlink" title="block的底层实现"></a>block的底层实现</h2><p>源码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void (^<span class="keyword">block)(void) </span>= ^&#123;</span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">    NSLog(@<span class="string">"this is a block"</span>)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"><span class="keyword">block();</span></span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void (<span class="name">*block</span>)(<span class="name">void</span>) = &amp;__main_block_impl_0(<span class="name">__main_block_func_0</span>, <span class="symbol">&amp;__main_block_desc_0_DATA</span>)<span class="comment">;</span></span><br><span class="line">block-&gt;FuncPtr(<span class="name">block</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>所以，block 的本质是<code>__main_block_impl_0</code>结构体，构造一个<code>__main_block_impl_0</code>结构，将<code>__main_block_impl_0</code>的地址赋值给block,执行block的过程是通过block找到函数指针FuncPtr，调用。  <code>__main_block_impl_0</code>的结构如下（这几个结构体名字不好记，牢记impl是整体实现，实现里面有函数指针func）：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>__main_block_impl_0</code>包含两个成员，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *isa;   <span class="comment">//isa，说明是OC对象</span></span><br><span class="line">    <span class="keyword">int</span> Flags;</span><br><span class="line">    <span class="keyword">int</span> Reserved;</span><br><span class="line">    <span class="keyword">void</span> *FuncPtr;  <span class="comment">//block内的代码封装为函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved;</span><br><span class="line">    <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>其中，函数指针 <code>__main_block_func_0</code>的定义</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void <span class="variable">__main_block_func_0</span>(struct <span class="variable">__main_block_impl_0</span> *<span class="variable">__cself</span>) &#123;</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span>);</span><br><span class="line">    NSLog((NSString *)&amp;<span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//常量字符串定义在数据区</span></span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br><span class="line">static <span class="variable">__NSConstantStringImpl</span> <span class="variable">__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2</span> <span class="variable">__attribute__</span> ((section (<span class="string">"__DATA, __cfstring"</span>))) = &#123;<span class="variable">__CFConstantStringClassReference</span>,<span class="number">0</span>x000007c8,<span class="string">"this is a block"</span>,<span class="number">15</span>&#125;;</span><br></pre></td></tr></table></figure><p>整体捋下思路，block的结构简单理解为：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Block是一个<span class="keyword">impl</span>结构  -&gt;__block_impl     -&gt; isa，表明是OC对象</span><br><span class="line">                   |                  -&gt; func函数指针,封装block的代码</span><br><span class="line">                   |</span><br><span class="line">                   -&gt; 描述</span><br></pre></td></tr></table></figure><blockquote><p>总结: block的本质就是封装了函数调用以及函数调用环境的OC对象</p></blockquote><h2 id="带参数的block"><a href="#带参数的block" class="headerlink" title="带参数的block"></a>带参数的block</h2><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) = ^(<span class="built_in">int</span> a, <span class="built_in">int</span> b)&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d,%d"</span>,a,b);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">block</span>(c, d);</span><br></pre></td></tr></table></figure><p>翻译为CPP代码:</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//初始化<span class="keyword">block</span>对象</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">int</span>, <span class="built_in">int</span>) =</span><br><span class="line">&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line"><span class="built_in">int</span> c= <span class="number">20</span>, d = <span class="number">10</span>;</span><br><span class="line">//执行<span class="keyword">block</span></span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>, c, d);</span><br></pre></td></tr></table></figure><p>各个结构的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//block的底层结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int flags=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//block内的函数指针</span></span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself, int a, int b) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_3e8a17_mi_0,a,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><h2 id="block变量捕获"><a href="#block变量捕获" class="headerlink" title="block变量捕获"></a>block变量捕获</h2><ol><li>在OC中变量的类型主要使用三种, 分别是auto、static、全局变量, 其中auto和static修饰的是局部变量</li><li>对这三种类型的变量, block在使用使用时, 会有不同的捕获方式</li></ol><h3 id="auto变量捕获-值捕获"><a href="#auto变量捕获-值捕获" class="headerlink" title="auto变量捕获(值捕获)"></a>auto变量捕获(值捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (*<span class="keyword">block</span>)(<span class="built_in">void</span>) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));</span><br><span class="line"><span class="keyword">block</span>-&gt;<span class="type">FuncPtr</span>(<span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">    int age;  <span class="comment">//多了一个成员变量</span></span><br><span class="line">    __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int _age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//age的赋值是通过构造函数初始化列表完成的</span></span><br><span class="line">        <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">        <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">        <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">        Desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">    int age = __cself-&gt;age; <span class="comment">// bound by copy 取出block结构内的age</span></span><br><span class="line">    </span><br><span class="line">    NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_82fbf9_mi_0,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> &#123;</span><br><span class="line">    size_t reserved;</span><br><span class="line">    size_t Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span>)&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，block对于auto变量会值不会，通过在block底层结构中增加捕获的变量定义。</p><h3 id="static变量捕获-指针捕获"><a href="#static变量捕获-指针捕获" class="headerlink" title="static变量捕获(指针捕获)"></a>static变量捕获(指针捕获)</h3><p>示例代码：</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">void</span> (^<span class="keyword">block</span>)(<span class="built_in">void</span>) = ^&#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">"%d"</span>,age);  //输出<span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line">age = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">block</span>();</span><br></pre></td></tr></table></figure><p>翻译为CPP代码</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> int age = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//将age的地址传入block的构造函数中</span></span><br><span class="line">void <span class="comment">(*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age);</span></span><br><span class="line"><span class="comment">age = 25;</span></span><br><span class="line"><span class="comment">block-&gt;FuncPtr(__block_impl *)</span><span class="keyword">block</span>);</span><br></pre></td></tr></table></figure><p>各个结构体的定义如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__block_impl</span></span> <span class="keyword">impl</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span>* Desc;</span><br><span class="line">  int *age;   <span class="comment">//定义为指针类型</span></span><br><span class="line">  __main_block_impl_0(void *fp, <span class="class"><span class="keyword">struct</span> <span class="title">__main_block_desc_0</span></span> *desc, int *_age, int flags=<span class="number">0</span>) : age(_age) &#123;  <span class="comment">//构造列表是初始化age指针</span></span><br><span class="line">    <span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    <span class="keyword">impl</span>.Flags = flags;</span><br><span class="line">    <span class="keyword">impl</span>.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> void __main_block_func_0(<span class="class"><span class="keyword">struct</span> <span class="title">__main_block_impl_0</span></span> *__cself) &#123;</span><br><span class="line">  int *age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_1d503d_mi_0,(*age));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="block中使用全局变量-不会捕获"><a href="#block中使用全局变量-不会捕获" class="headerlink" title="block中使用全局变量(不会捕获)"></a>block中使用全局变量(不会捕获)</h3><p>全局变量不捕获</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/wiki/IOS/Block/block/block1.png" alt="block总结"></p><h2 id="点点滴滴"><a href="#点点滴滴" class="headerlink" title="点点滴滴"></a>点点滴滴</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun -sdk iphoneos clang -<span class="keyword">arch</span> arm64 -rewrite-objc main.<span class="built_in">m</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解block的本质&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Block" scheme="http://yoursite.com/categories/IOS/Block/"/>
    
    
      <category term="Block" scheme="http://yoursite.com/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>学习runtime的参考文档</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/reffer/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/reffer/</id>
    <published>2019-09-19T03:38:11.000Z</published>
    <updated>2019-09-19T07:15:43.922Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录学习runtime过程中，有用的文档。</p><a id="more"></a><h2 id="学习过的文档"><a href="#学习过的文档" class="headerlink" title="学习过的文档"></a>学习过的文档</h2><ol><li><a href="https://juejin.im/user/5a329c1351882529707931f0/posts" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记</a></li><li><a href="https://juejin.im/post/5b248ad151882574e808d3c9" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第一天: Objective-C的本质</a></li><li><a href="https://juejin.im/post/5b646f44f265da0fae4f3e6c" rel="external nofollow noopener noreferrer" target="_blank">小码哥iOS学习笔记第二天: OC对象的分类</a></li><li></li></ol><h2 id="通用文档"><a href="#通用文档" class="headerlink" title="通用文档"></a>通用文档</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录学习runtime过程中，有用的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperation/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperation/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T09:45:48.872Z</updated>
    
    <content type="html"><![CDATA[<p>NSOperation类文档学习记录</p><a id="more"></a><h2 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h2><p>依赖可以控制操作执行的顺序，相关函数：</p><ol><li>addDependency</li><li>removeDependency</li></ol><p>当依赖的operation全部为完成状态时，operation才能为ready的状态。当最后一个依赖完成后，operation的状态变为ready状态。</p><p>依赖不区分operation是完成了还是取消了。</p><h2 id="KVO属性"><a href="#KVO属性" class="headerlink" title="KVO属性"></a>KVO属性</h2><p>KVO属性包括：</p><ol><li>isCancelled</li><li>isAsynchronous</li><li>isExecuting</li><li>isFinished</li><li>isReady</li><li>dependencies</li><li>queuePriority</li><li>completionBlock</li></ol><h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>多线程调用NSOperation的方法时安全的，不需要加锁。<br>子类的自定义方法需要考虑多线程问题。</p><h2 id="异步VS同步"><a href="#异步VS同步" class="headerlink" title="异步VS同步"></a>异步VS同步</h2><p>操作可以手动执行、也可以添加到queue中执行。</p><p>手动执行（直接调用start方法），分为同步operation和异步operation ，同步在当前线程立即执行。异步在新的线程执行任务。</p><p>如果操作在队列中执行，一般定义为同步的，队列不关注asynchronous属性，总是在一个单独的线程中调用start方法。所有没有理由设计为异步的。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>非并发队列：重写 main方法。<br>并发队列：需要重写start、 asynchronous、executing、finished方法。</p><p><strong>注意是否重写main决定了是否是并发操作。</strong></p><p>下面是子类化的要点：</p><ol><li>在并发队列中，start方法负责异步开始操作。</li><li>start方法中需要通过KVO更新operation的executing状态为YES。</li><li>operation完成或取消后，并发队列必须通过KVO更新isExecuting为NO 和 isFinished为YES。如果是取消，也需要更新isFinished状态为YES。</li><li>operation 只有完成了，才能从queue中移除。</li><li>同时需要重写 executing、finished属性（KVC）。</li><li>start方法需要检查是否operation被取消了。</li><li>如果定制了依赖，需要KVO isReady属性。</li></ol><p><strong>状态管理</strong>：</p><ol><li>isReady，一般不用管理，依赖的时候处理。</li><li>isExecuting，替换了start方法，一定要替换isExecuting方法，并在start开始的时候发出KVO</li><li>isFinished，替换了start方法，一定要替换isFinished方法。operation完成或取消，发出KVO</li><li>isCancelled，不需要发出KVO</li></ol><p><strong>响应取消</strong></p><p>一旦将operation添加到queue中，queue就掌管了operation。你可以通过调用operation的cancell方法取消，或者通过queue的cancelAllOperations取消。</p><p>执行中的任务并不会立马取消， 你必须显式的检测状态，需要的时候取消。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSOperation类文档学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>多线程参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/referr/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/referr/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-18T10:39:43.475Z</updated>
    
    <content type="html"><![CDATA[<p>记录读过的文章</p><a id="more"></a><h2 id="读过的文章"><a href="#读过的文章" class="headerlink" title="读过的文章"></a>读过的文章</h2><ol><li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></li><li><a href="https://objccn.io/issue-2-1/#challenges" rel="external nofollow noopener noreferrer" target="_blank">并发编程：API 及挑战</a></li><li><a href="https://blog.ibireme.com/2015/05/18/runloop/" rel="external nofollow noopener noreferrer" target="_blank">深入理解RunLoop</a>    </li><li><a href="https://bujige.net/blog/iOS-Complete-learning-RunLoop.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『RunLoop』详尽总结</a></li></ol><h2 id="需要读的"><a href="#需要读的" class="headerlink" title="需要读的"></a>需要读的</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrency Programming Guide</a></li><li><a href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/" rel="external nofollow noopener noreferrer" target="_blank">浅谈iOS多线程(源码)</a></li><li><a href="https://objccn.io/issue-2-3/" rel="external nofollow noopener noreferrer" target="_blank">底层并发 API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录读过的文章&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperaionQueue 源码学习</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperaionQueue/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperaionQueue/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-12-09T06:34:14.171Z</updated>
    
    <content type="html"><![CDATA[<p>记录NSOperaionQueue的理解</p><a id="more"></a><p><img src="/wiki/IOS/多线程/NSOperaionQueue/operaionQueue.png" alt="Queue执行operaion的流程"><br><img src="/wiki/IOS/多线程/NSOperaionQueue/2.png" alt="是否并发文档"></p><h2 id="NSOperation与GCD区别"><a href="#NSOperation与GCD区别" class="headerlink" title="NSOperation与GCD区别"></a>NSOperation与GCD区别</h2><p>其实我们在通过NSOperation和GCD进行开发过程中，会发现两者执行的方式有许多相似之处，NSOperation和GCD参照对比，NSOperationQueue和dispatch_queue参照对比，但是两者之间还是有许多差别的，具体区别:</p><ol><li><p>GCD的核心是C语言写的系统服务，执行和操作简单高效，因此NSOperation底层也通过GCD实现，换个说法就是NSOperation是对GCD更高层次的抽象，这是他们之间最本质的区别。因此如果希望自定义任务，建议使用NSOperation</p></li><li><p>依赖关系，NSOperation可以设置两个NSOperation之间的依赖，第二个任务依赖于第一个任务完成执行，GCD无法设置依赖关系，不过可以通过dispatch_barrier_async来实现这种效果；</p></li><li>KVO(键值对观察)，NSOperation和容易判断Operation当前的状态(是否执行，是否取消)，对此GCD无法通过KVO进行判断；</li><li>优先级，NSOperation可以设置自身的优先级，但是优先级高的不一定先执行，GCD只能设置队列的优先级，无法在执行的block设置优先级；</li><li>继承，NSOperation是一个抽象类，实际开发中常用的两个类是NSInvocationOperation和NSBlockOperation，同样我们可以自定义NSOperation，GCD执行任务可以自由组装，没有继承那么高的代码复用度；</li><li>效率，直接使用GCD效率确实会更高效，NSOperation会多一点开销，但是通过NSOperation可以获得依赖，优先级，继承，键值对观察这些优势，相对于多的那么一点开销确实很划算，鱼和熊掌不可得兼，取舍在于开发者自己；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录NSOperaionQueue的理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>GCD源码理解</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD_Source/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/GCD_Source/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T11:57:53.764Z</updated>
    
    <content type="html"><![CDATA[<p>GCD源码理解</p><a id="more"></a><h2 id="GCD理解"><a href="#GCD理解" class="headerlink" title="GCD理解"></a>GCD理解</h2><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_sync.png" alt="同步"></p><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_async.png" alt="异步"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCD源码理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/定积分/</id>
    <published>2019-09-10T01:07:12.000Z</published>
    <updated>2019-10-26T09:59:19.211Z</updated>
    
    <content type="html"><![CDATA[<p>记录定积分的学习记录，方便以后复习</p><a id="more"></a><h2 id="定积分的概念和性质"><a href="#定积分的概念和性质" class="headerlink" title="定积分的概念和性质"></a>定积分的概念和性质</h2><p><strong>一、 定积分问题举例</strong></p><ol><li><p>曲边梯形的面积 $A=\lim \limits_{\lambda \to 0} {\sum_{i=1}^n{f(\xi) \Delta x}}$</p></li><li><p>变速直线运动的路程 $s = \lim_{\lambda \to 0}{\sum_{i = 1}^{n}{\nu}({\tau}_i)} \Delta t_i$</p></li></ol><blockquote><p>相同点： 特定和的极限</p></blockquote><p>定义： 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点</p><p>$$a=x_0 &lt; x_1&lt;x_2…&lt;x_{n-1}&lt;x_n = b$$</p><p>把区间[a,b]分成n个小区间<br>$$[x_0,x_1],[x_1,x_2],…,[x_{n-1}]$$<br>各个小区间的长度依次为<br>$$\Delta x_1 = x_1-x_0,\Delta x_2 = x_2-x_1 … \Delta x_n = x_n - x_{n-1}$$<br>在每个小区间上任意去一点$\xi$,作为函数值$f(\xi)$与小区间长度$\Delta x_i$的乘积 $f(\xi_i) \cdot \Delta x_i$，并作出和<br>$$S = \sum_{i=1}^n{f(\xi_i) \cdot \Delta x_i}$$<br>如果和的极限存在，且闭区间[a,b]的分法及点$\xi_i$的取法无关，那么这个极限I为函数f(x)在区间[a,b]上的定积分，记作$\int_a^b{f(x)dx}$，即<br>$$\int_a^b{f(x)dx} = I = \lim_{\lambda \to 0}{\sum_{i=1}^n{f(\xi_i) \Delta x_i}}$$<br>其中[a,b]叫做积分区间。a叫做积分下限，b叫做积分上限</p><p>定积分的值只与被积函数和积分区间有关，而与积分变量和记法无关。</p><p>那么，对于定积分，函数$f(x)$在[a,b]上满足怎样的条件，f(x)一定可积呢？下面两个定理回答这个问题。</p><p><strong>定理1</strong> 设f(x)在区间[a,b]上连续，则f(x)在[a,b]上可积<br><strong>定理2</strong> 设f(x)在区间[a,b]上有界，且只有有限个间断点，则f(x)在[a,b]上可积</p><p>利用积分的性质，解决开篇的两个问题 :</p><ol><li>$A = \int^b_a{f(x)dx}$</li><li>$s = \int^{T_2}_{T_1}{\nu}(t)dt$</li></ol><p><strong>三、 定积分的近似计算</strong></p><ol><li>矩形法</li><li>抛物线法</li></ol><p><strong>四、 定积分的性质 </strong></p><p><strong>性质1</strong>： 设$\alpha$与$\beta$为常数，则：</p><p>$$\int^b_a{[{\alpha}f(x)+{\beta}g(x)]dx} = {\alpha} \int^b_a{f(x)dx}+{\beta}\int^b_a{g(x)dx}$$</p><p><strong>性质2(积分区间可加性)</strong>：设a&lt;c&lt;b，则<br>$$\int^b_a{f(x)dx} = \int^c_a{f(x)dx} + \int^b_c{f(x)dx}$$</p><p><strong>性质三</strong>： 如果在区间[a,b]上f(x)=1,那么<br>$$\int^b_a 1dx = \int^b_a dx = b-a$$</p><p><strong>性质四</strong> 如果在区间[a,b]上f(x)$\ge 0$，那么</p><p>$$\int^b_a{f(x)dx} \ge 0$$</p><p><strong>性质五</strong> 如果M及m分别是函数f(x)在区间【a,b】上的最大值及最小值，则<br>$$ m(b-a) \le \int^b_a{f(x)dx} \le M(b-a)$$</p><blockquote><p>积分就是宽、高的和</p></blockquote><p><strong>性质六</strong>（定积分中值定理） 如果函数f(x)在积分区间[a,b]上连续，那么在[a,b]上至少存在一点$\xi$，使下式成立：<br>$$\int^b_a{f(x)dx} = f(\xi)(b-a)$$</p><h2 id="第二节-微分基本公式"><a href="#第二节-微分基本公式" class="headerlink" title="第二节 微分基本公式"></a>第二节 微分基本公式</h2><p><strong>一、 变速直线运动中，位置函数与速度函数之间的联系</strong></p><p>位置函数与速度函数有如下关系：</p><p>$$\int^{T_2}_{T_1}{\nu}(t)dt = s(T_2) - s(T_1) \text{，位置函数是速度函数的原函数，定积分是原函数的增量}$$</p><p><strong>二、积分上限的函数及其导数</strong> </p><p><strong>定理一</strong> 如果函数f(x)在区间[a,b]上连续，那么积分上限函数：<br>$$ \Phi (x) = \int^x_a{f(t)}dt$$<br>在[a,b]上可导，并且它的导数:</p><p>$$ {\Phi}’ (x) = \frac{d}{dx} \int^x_a{f(t)}dt = f(x)$$</p><p>这个定理指出了一个重要结论： 连续函数f(x)取边上限x的定积分，然后求导，其结果还原为f(x)本身。所以${\Phi} (x)$是连续函数 f(x)的一个原函数。</p><p><strong>定理二</strong> 如果函数f(x)在区间[a,b]上连续，那么函数</p><p>$$\Phi (x) = \int^x_a{f(t)}dt$$<br>就是f(x)在[a,b]上的一个原函数。</p><p>这个定理的意义：定积分和原函数的联系，因此我们就有可能通过原函数计算定积分。</p><p><strong>三、 牛顿-莱布尼茨公式</strong></p><p>这个定理的意义： 给出了用原函数计算定积分的公式。</p><p><strong>定理三：微积分基本定理</strong>：如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，那么<br>$$\int_a^b{f(x)dx}=F(b)-F(a)$$</p><p>这个函数进一步揭秘了原函数和不定积分之间的关系。</p><h2 id="第三节-定积分的换元法和分部积分法"><a href="#第三节-定积分的换元法和分部积分法" class="headerlink" title="第三节 定积分的换元法和分部积分法"></a>第三节 定积分的换元法和分部积分法</h2><p>定积分的分部积分法：</p><p>$$\int^b_a{\mu}d{\nu}= [{\mu}{\nu}]^b_a - \int^b_a{\nu} \mu d \mu$$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><ol><li>$1^2+2^2+..+n^2= \frac{1}{6}n(n+1)(2n+1)$</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录定积分的学习记录，方便以后复习&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷脸登录调研</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/faceLogin/"/>
    <id>http://yoursite.com/wiki/编程理论/人脸登录/faceLogin/</id>
    <published>2019-09-03T04:11:35.000Z</published>
    <updated>2019-09-03T08:57:01.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文调研人脸登录的实现思路。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>人脸登录包括两个流程：人脸注册、人脸查找。</p><h2 id="人脸注册"><a href="#人脸注册" class="headerlink" title="人脸注册"></a>人脸注册</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/register.png" alt="人脸注册流程"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data1.png" alt="图片组织结构"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data2.png" alt="facetoken和profileid对应关系"></p><h2 id="刷脸登录（查找人脸的过程）"><a href="#刷脸登录（查找人脸的过程）" class="headerlink" title="刷脸登录（查找人脸的过程）"></a>刷脸登录（查找人脸的过程）</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/login.png" alt="刷脸登录"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>非常像的双胞胎能识别出来吗？</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/zzqaaasss/article/details/89194437" rel="external nofollow noopener noreferrer" target="_blank">微信小程序使用face++实现人脸识别登录注册</a></li><li><a href="https://console.faceplusplus.com.cn/documents/4888373" rel="external nofollow noopener noreferrer" target="_blank">face++文档中心</a></li><li><a href="https://blog.csdn.net/qq_23412263/article/details/86232682" rel="external nofollow noopener noreferrer" target="_blank">使用 face++ API 实现人脸识别，刷脸登陆和活体检测（张张嘴，眨眨眼）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文调研人脸登录的实现思路。&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
      <category term="人脸登录" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>第四章 不定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/four_indefinite_integral/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/four_indefinite_integral/</id>
    <published>2019-08-29T01:07:12.000Z</published>
    <updated>2019-10-26T07:32:33.631Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点，</p><a id="more"></a><h2 id="第一节-不定积分的概念和性质"><a href="#第一节-不定积分的概念和性质" class="headerlink" title="第一节 不定积分的概念和性质"></a>第一节 不定积分的概念和性质</h2><p>一、 原函数和不定积分的概念 </p><p>定义1：如果在区间I上，可导函数F(x)的导函数为f(x),即对任意x属于I都有：<br>$$F’(x)=f(x) 或dF(x)=f(x)dx$$<br>那么函数F(x)就称为f(x)（或f(x)dx）在区间I上的一个<strong>原函数</strong>。</p><p>什么样的函数才存在原函数？</p><p><strong>原函数存在定理</strong>：如果函数f(x)在区间I上连续，那么在区间I上存在可导函数F(x),使对任一x属于I，都有：</p><p>$$F’(x)=f(x)$$</p><p>简单的说，连续函数一定有原函数。</p><p>一个函数的原函数有怎样的特点呢：</p><ol><li>如果函数$f(x)$有一个原函数，那么$f(x)$有无限多个原函数</li><li>无限多个原函数相差一个常数，表达式 $F(x) + C $可以表示f(x)的任意一个原函数。</li></ol><p>所以，使用下面的定义表示无限多个原函数：</p><p><strong>定义2</strong> 在区间I上，函数$f(x)$的带有任意常数项的原函数称为$f(x)$(或$f(x)dx$)在区间I上的不定积分，记作：<br>$$\int{f(x)dx}$$<br>其中记号$\int$称为积分号，$f(x)$称为被积函数，$f(x)dx$<br>称为被积表达式，x称为积分变量。</p><p>结论：因而<strong>不定积分</strong>$\int{f(x)dx}$<strong>可以表达$f(x)$的任意一个原函数</strong>。</p><p>函数f(x)的原函数的图形称为函数f(x)的积分曲线。</p><p><strong>微分和积分的关系</strong> ：</p><p>由于$\int {f(x)dx}$ 是$f(x)$的原函数，所以：</p><p>$$\frac{d}{dx} \left[\int{f(x) dx} \right] = f(x)$$</p><p>又由于$F(x)$是$F’(x)$的原函数所以 ： $$\int F’(x)dx = F(x) + C$$</p><p>或者记作：</p><p>$$\int dF(x) = F(x) + C$$</p><p>由此可见，微分运算（以符号d表示）与不定积分运算（以记号$\int$表示）是互逆的，当$\int$和d连在一起的时候，或者可以抵消，或者抵消后差一个常数。</p><p><strong>基本积分表</strong></p><ol><li>$\int k dx = kx +C$</li><li>$\int x^{\mu} dx= \frac{x^{\mu + 1}}{\mu + 1} + C  \text  (\mu \ne -1) $</li><li>$\int \frac{dx}{x} = \ln |x| + C$</li><li>$\int \cos x dx = \sin x +C $</li><li>$\int \sin x dx$ = - cos x +C</li><li>$\int \frac{dx}{\sqrt{1-x^2}} = \arcsin x + C$</li><li>$\int \frac{dx}{\cos^2 x} = \int \sec^2 dx= \tan x + C $</li><li>$ \int \frac{dx}{\sin^2 x} = \int \csc^2 x dx = -\cot x + C$</li><li>$\int \frac{dx}{1+x^2} = \arctan x + C$</li><li>$\int \sec x \tan x dx = \sec x + C$</li><li>$\int \csc x \cot x dx = -\csc x +C$</li><li>$\int e^x dx = e^x + C$</li><li>$\int a^x dx = \frac{a^x}{\ln a} + C$</li></ol><p><strong>不定积分的性质</strong></p><p><strong>性质1(不定积分加法性质)</strong> 设函数f(x)及 g(x)<strong>的原函数存在</strong>，则</p><p>$$\int{[f(x)+g(x)]dx} = \int{f(x)dx} + \int{g(x)dx}$$</p><p><strong>性质2（不定积分系数性质）</strong> 设函数f(x)的原函数存在，k为非零常数，则 </p><p>$$\int{kf(x)dx}=k\int{f(x)dx}$$</p><h2 id="第二节-换元积分法"><a href="#第二节-换元积分法" class="headerlink" title="第二节 换元积分法"></a>第二节 换元积分法</h2><p>把复合函数的微分法反过来，用于求不定积分，利用中间变量的代换，得到复合函数的积分，称为<strong>积分换元法</strong>。</p><p>一、 第一类换元法 </p><p>定理1 设f(u)具有原函数，u=$\psi$(x)可导，则有换元公式<br>$$\int{f[\psi (x)]\psi ‘(x)dx} = [\int{f(u)du}]_{u=\psi (x)}$$</p><p>如果应用换元法求不定积分呢？设要求$\int{g(x)dx}$，如果g(x)可以化为g(x)= $f[\psi (x)]\psi ‘(x)$的形式，那么<br>$$\int {g(x)dx}= \int{f[\psi (x)]\psi ‘(x)dx}=\int{f(u)du}$$</p><blockquote><p>其中$\psi ‘(x)dx 转化为du$ 是将自变量微分形式 转化为整个因变量的微分形式。这需要理解。</p></blockquote><p>这样，就将函数$g(x)$的积分转化为函数$f(u)$的积分，如果能求出$f(u)$的原函数，那么就得到了$g(x)$的原函数。</p><p><strong>具体求解的步骤</strong>：</p><ol><li>选取$u = \psi (x)$</li><li>转化为这个$\int{f[\psi (x)]\psi ‘(x)dx} = \int{f(u)du}$  的形式</li><li>计算$f(u)$的积分</li><li>使用$u = \psi (x)$ 积分中的$u$替换为$x$。</li></ol><p><strong>示例</strong>： 计算$\int 2 \cos 2x dx$</p><ol><li>选取$u = 2x$</li><li>转化形式：$\int 2 \cos 2x dx = \int \cos 2x \cdot (2x)’ dx = \int \cos u du $</li><li>计算积分： $\int 2 \cos 2x dx = \sin u + C$</li><li>将$u$代换为$x$： $\int 2 \cos 2x dx = \sin 2x + C$</li></ol><p>二、 第二类换元法 </p><p>适当的选择变量代换，$x=\psi (t)$，将积分$\int f(x)dx$化为积分$\int f[\psi (t)] {\psi}’(t) dt $，这是另一种形式的变量代换，还原公式可以表达为 :</p><p>$$\int f(x)dx = \int f[\psi (t)] {\psi}’(t) dt$$</p><p>定理2 设$x=\psi (t)$是单调的可导函数，并且${\psi}’(t) \ne 0$ 又设$f[{\psi}(t)]{\psi}’(t)$具有原函数，则有还原公式 ：</p><p>$$\int{f(x)dx} = \left [{\int{f[{\psi(t)}]{\psi}’(t)dt}}\right ]_{t={\psi}^{-1}{(x)}}$$</p><h2 id="第三节-分部积分法"><a href="#第三节-分部积分法" class="headerlink" title="第三节 分部积分法"></a>第三节 分部积分法</h2><p>积分换元法基于的原理是复合函数求导法则， 现在我们利用两个函数乘积的求导法则，来推得另一个求积分的基本方法–分部积分法。</p><p>设$\mu = {\mu}(x)$及$\nu={\nu}(x)$具有连续的导函数，则两个函数乘积的导数公式为：<br>$$({\mu}{\nu})’ = {\mu}’{\nu}+{\mu}{\nu}’$$,<br>移项，得：<br>$${\mu}’{\nu}  = ({\mu}{\nu})’ - {\mu}{\nu}’$$<br>两边求不定积分，得<br>$$\int {\mu}’{\nu}dx  = ({\mu}{\nu}) - \int {\mu}{\nu}’dx$$</p><p>这个公式称为分部积分公式。如果求$\int {\mu}’{\nu}dx$有困难，而求$ \int {\mu}{\nu}’dx$比较容易时，分部积分公式就可以发挥作用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点，&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="不定积分" scheme="http://yoursite.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>第一章 函数与极限</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/函数与极限/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-10-23T06:23:22.129Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录《函数与极限》章节中，比较重要的内容，以便以后复习。</p><a id="more"></a><h2 id="第二节-数列的极限"><a href="#第二节-数列的极限" class="headerlink" title="第二节 数列的极限"></a>第二节 数列的极限</h2><p><strong>定义</strong>： 设{$x_n$}为一数列，如果存在常数a，对于任意给定的正数$\epsilon$ (不论它多么小)，总存在正整数N，使得，当n&gt;N时，不等式<br>$$|x_n-a|&lt;\epsilon$$<br>都成立，那么就称常数a是数列{$x_n$}的<strong>极限</strong>，或者称数列{$x_n$}<strong>收敛</strong>于a，记为：<br>$$\lim \limits_{n \to \infty} {x_n} = a$$</p><p>如果不存在这样的常数a，就说数列没有极限，或者说数列是<strong>发散</strong>的。</p><blockquote><p>等式中的绝对值表达了两数之差，说明$x_n$无限趋近a含义,也就是两项非常的接近。</p></blockquote><p><strong>收敛数列的性质 </strong></p><p><strong>定理一（极限的唯一性）</strong> 如果数列{$x_n$}收敛，那么他的极限唯一</p><p><strong>定理二（收敛数列的有界性）</strong>如果数列{$x_n$}收敛，那么数列{$x_n$}一定有界。</p><p><strong>定理三（收敛数列的保号性）</strong>如果$\lim \limits_{n \to \infty} {x_n} = a$，且a&gt;0，那么存在正整数N，当n&gt;N时，都有$x_n$&gt;0</p><p><strong>定理四（收敛数列与其子数列间的关系）</strong>如果数列{$x_n$}收敛于a，那么他的任一子数列也收敛，且极限也是a。</p><h2 id="第三节-函数的极限"><a href="#第三节-函数的极限" class="headerlink" title="第三节 函数的极限"></a>第三节 函数的极限</h2><p>讨论函数极限时，自变量变化的情形有两种情况：</p><ol><li>自变量x任意的接近于有限值$x_0$ ，$x \to x_0$</li><li>自变量x的绝对值无限大，$x \to \infty$</li></ol><p><strong>函数极限定义1</strong> 设函数f(x)在点$x_0$的去心领域内有定义，如果存在常数A，对于任意给定的正数$\epsilon$(不论多么小)，总存在正数$\delta$,使得当x满足不等式0&lt;|x-$x_0$|&lt;$\delta$时，对应的函数值f(x)都满足不等式<br>$$|f(x)-A|&lt;\epsilon$$<br>那么常数A就叫做函数f(x)当x-&gt;$x_0$时的极限记作：<br>$$\lim_{x-&gt;x_0}f(x)=A$$</p><blockquote><p>函数极限的定义就是规定了定义域，得出值域的满足的条件 。</p></blockquote><p>函数极限的性质：</p><ol><li>极限的唯一性</li><li>局部有界性  </li><li>局部保号性</li><li>函数极限和数列极限的关系（函数有极限，数列也有极限）</li></ol><h2 id="第四节-无穷小和无穷大"><a href="#第四节-无穷小和无穷大" class="headerlink" title="第四节 无穷小和无穷大"></a>第四节 无穷小和无穷大</h2><p><strong>定义</strong>： 极限为零，那么称函数为当x-&gt;$x_0$时的无穷小</p><p>下面的定理说明无穷小与函数极限的关系：</p><p><strong>定理1</strong> ： 在自变量的同一变化过程$x-&gt;x_0$中，函数f(x)具有极限的充分必要条件是f(x) = A + $\alpha$,其中 $\alpha$是无穷小。</p><p>下面是无穷大和无穷小的关系：</p><p><strong>定理2</strong>： 在自变量的同一变化过程中，如果f(x)为无穷大，那么$\frac{1}{f(x)}$为无穷小，如果f(x)为无穷小，且f(x)!=0 .那么$\frac{1}{f(x)}$为无穷大。</p><blockquote><ol><li>充分性：由条件推断出命题成立。</li><li>必要性： 由命题成立推断出条件的成立。</li></ol></blockquote><h2 id="第五节极限运算法则"><a href="#第五节极限运算法则" class="headerlink" title="第五节极限运算法则"></a>第五节极限运算法则</h2><p><strong>定理1</strong> 两个无穷小的和是无穷小</p><p><strong>定理2</strong> 有界函数与无穷小的乘积是无穷小</p><p><strong>推论1</strong> 常数与无穷小的乘积是无穷小</p><p><strong>推论2</strong> 有限个无穷小的乘积是无穷小</p><p><strong>定理3</strong> 当$x \to x_0 （或 x \to \infty）$ 如果limf(x)=A,limg(x)=B,那么</p><ol><li>lim[f(x)+g(x)]=limf(x)+limg(x)=A+B</li><li>lim[f(x)g(x)]=limf(x)limg(x)=AB</li><li>lim$\frac{f(x)}{g(x)}$=$\frac{limf(x)}{limg(x)}=\frac{A}{B}$，其中B不等于0</li></ol><p><strong>定理4</strong> 数列和函数有类似定理3的性质</p><p><strong>定理5</strong> $\upsilon(x)&gt;=\psi$(x),而lim$\upsilon(x)$=A,lim$\psi(x)$=B,那么A&gt;=B</p><blockquote><p>注意： 求极限时，如果分母为0，需要化为不为0</p></blockquote><p><strong>定理6</strong> 复合函数的极限运算法则，设函数y=f[g(x)]是由函数u=g(x)与函数y=f(u)复合而成，f[g(x)]在点$x_0$的某个去心领域内有定义，$\lim \limits_{x \to x_0}{g(x)}=u_0$ , $\lim \limits_{u \to u_0} {f(u)}=A$,且存在$\delta_0&gt;0$，当x属于（$x_0,\delta_0$）时，有g(x)!=$u_0$,则<br>$$\lim \limits_{x \to x_0} {f[g(x)]} = \lim \limits_{u \to u_0} {f(u)}=A $$</p><h2 id="第六节-极限存在准则、两个重要极限"><a href="#第六节-极限存在准则、两个重要极限" class="headerlink" title="第六节 极限存在准则、两个重要极限"></a>第六节 极限存在准则、两个重要极限</h2><p><strong>准则1</strong> ，如果数列{$x_n$}、{$y_n$}、{$z_n$}满足下面条件：</p><p>$$y_n&lt;=x_n&lt;=$z_n$$</p><p>且$\lim_ \limits{n-&gt;\infty}y_n=a,\lim_ \limits{n-&gt;\infty}z_n=a$</p><p>那么数列{$x_n$}的极限存在，且$\lim \limits_{n-&gt;\infty}x_n=a$</p><p>这个准则称为<strong>夹逼准则</strong>。</p><p><strong>使用夹逼准则计算第一个重要的极限</strong>: $\lim_{x \to 0}{\frac{\sin x}{x} }=1$</p><p><strong>准则2 单调有界必有极限。</strong></p><p>一对重要的极限公式：$$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e$$</p><p>$$\lim \limits_{n-&gt;\infty}(1-\frac{1}{n})^n= \frac{1}{e}$$</p><p><strong>柯西极限存在准则</strong>  数列{$x_n$} 收敛的充分必要条件是：对于任意给定的正数$\epsilon$,存在正整数N，使得m&gt;N, n&gt;N时，有：</p><p>$$|x_n-x_m|&lt;\epsilon$$</p><p>上面公式说明两项的差趋于无穷小。</p><h2 id="第七节：无穷小的比较"><a href="#第七节：无穷小的比较" class="headerlink" title="第七节：无穷小的比较"></a>第七节：无穷小的比较</h2><p>上面的章节说明两个无穷小的和、差、商仍旧是无穷小，但是两个无穷小的商，确出现不同的结果。</p><p>无穷小定义： 如果函数f(x)当$x \to x_0 （或 x \to \infty）$时极限为零，那么称函数f(x)为当$x \to x_0 （或 x \to \infty）$时的无穷小。</p><p>定理1 在自变量的同一变化过程$x \to x_0 （或 x \to \infty）$中，函数f(x)具有极限A的充分必要条件是f(x)=A+a,其中a是无穷小。</p><p>定义(<strong>更小的阶数更高</strong>) ：</p><ol><li>如果$lim \frac{\beta}{\alpha}$ = 0，那么就说$\beta$是比$\alpha$高阶的无穷小，记作$\beta$=o($\alpha$)</li><li>如果$lim \frac{\beta}{\alpha}$ = $\infty$，那么就说$\beta$是比$\alpha$低阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = c，那么就说$\beta$,$\alpha$同阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha^k}$ =c，那么就说$\beta$是$\alpha$的k阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = 1，那么就说$\beta$、$\alpha$时等阶无穷小 记作$\alpha \sim \beta$</li></ol><h2 id="第八节-函数的连续性和间断性"><a href="#第八节-函数的连续性和间断性" class="headerlink" title="第八节 函数的连续性和间断性"></a>第八节 函数的连续性和间断性</h2><p>定义： 设函数y=f(x)在点$x_0$的某一领域内有定义，如果：</p><p>$$\lim \limits_{\bigtriangleup x \to 0}\bigtriangleup y = \lim_{\Delta x \to 0}{[f(x_{x0})]}0$$</p><p>那么就称函数y=f(x)在点$x_0$连续。</p><p>下面是连续性定义中增量的示意图：<br><img src="/wiki/数学知识/高数/函数与极限/1.png" alt="增量示意图"></p><p>连续性的也可以描述为：</p><p>设函数y=f(x)在点$x_0$的某一领域内有定义，如果<br>$$lim_{x \to x_0} {f(x)} = f(x_0)$$<br>那么就称函数f(x)在点$x_0$连续。</p><p>函数的间断点：</p><p>设函数f(x)在点$x_0$的某个去心领域内有定义，在此前提下，如果函数f(x)有下列三种情形之一：</p><ol><li>在$x=x_0$没有定义</li><li>虽在$x=x_0$有定义，但$\lim_{x \to x_0}{f(x)}$不存在</li><li>虽在$x=x_0$有定义，且$\lim_{x \to x_0}{f(x)}$存在，但是不等于$f(x_0)$</li></ol><p>那么函数f(x)在点$x_0$w为不连续，且点$x_0$称为函数f(x)的<strong>不连续点</strong>或<strong>间断点</strong>。</p><h2 id="第九节-连续函数的运算与初等函数的连续性"><a href="#第九节-连续函数的运算与初等函数的连续性" class="headerlink" title="第九节 连续函数的运算与初等函数的连续性"></a>第九节 连续函数的运算与初等函数的连续性</h2><p>一. 连续函数的和、差、积、商的连续性 </p><p>连续函数的和、差、积、商的连续性  连续函数的和、差、积、商（分母不为0）是连续的</p><p>二 反函数和复合函数的连续性 </p><p><strong>定理二</strong> 如果函数f(x) 是单调增加且连续，那么反函数也单调增加且连续</p><p><strong>定理三</strong> 复合函数的两个函数连续，复合后也连续。</p><p>三 初等函数的连续性</p><p><strong>定理四</strong> 所有初等函数都是连续的。</p><p>一组重要的公式</p><ul><li>$\lim_{x \to 0}{\frac{\log_\alpha{(1+x)} }{x{ { = \lim_{x \to 0}{\log_{\alpha}{(1+x)}^{\frac{1}{x} }} = \log_{\alpha}e = \frac{1}{\ln{\alpha} }$ </li><li><p>$\lim_{x \to 0}{\frac{\alpha^x - 1}{x} }$  </p><p> 令 $\alpha^x - 1 = t$，则 $x=\log_{\alpha}{(1+t)}$,当x $\to$0， t $\to$0， 于是：</p><p> $\lim_{x \to 0}{\frac{\alpha^x - 1}{x} }$   = $\lim_{t \to 0}{\frac{t}{\log_{\alpha}{(1+t)} }} = \log_{\alpha}{e} = \frac{1}{\ln{\alpha} }$</p></li><li><p>$\lim_{x \to 0}{\frac{(1+x)^{\alpha}-1}{x} } = \alpha$</p></li></ul><h2 id="第十节-闭区间上连续函数的性质"><a href="#第十节-闭区间上连续函数的性质" class="headerlink" title="第十节 闭区间上连续函数的性质"></a>第十节 闭区间上连续函数的性质</h2><p><strong>定理1</strong> 有界性与最大值最小值定理，在闭区间上连续的函数在该区间上有界，且一定能取得他的最大值和最小值。</p><p><strong>零点定理</strong>： 设函数f(x)在闭区间【a,b】上连续，且f(a)与f(b)异号，则在开区间(a,b)内至少有一点$\epsilon$， 使 $$f(\epsilon) = 0$$</p><p><strong>定理2（介值定理）</strong> 设函数f(x)在闭区间【a,b】上连续，且在这区间的端点取不同的函数值，$$f(a)=A,f(b)=B$$<br>则对于A于B之间的任意一个数C，在开区间（a,b）内至少有一点$\epsilon$,使得</p><p>$$f(\epsilon) = C $$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><ol><li>$x^2-9=(x+3)(x-3)$</li><li>$1+\frac{1}{2}+\frac{1}{2^2}+…+\frac{1}{2^{n-1} }=\frac{1-\frac{1}{2^n} }{1-\frac{1}{2} }$</li><li>二项式定理 $(x+y)^n = \binom {n}{0}x^ny^0 + \binom {n}{1}x^{n-1}y^1 +\binom {n}{2}x^{n-2}y^2 + …+ \binom {n}{n-1}x^1y^{n-1} + \binom {n}{n}x^0y^n$,其中$\binom {n}{k}$为二项系数，等于$\frac{n!}{k!(n-k)!}$.</li><li>$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e=2.718281$ （二项式展开可证明）</li><li>$\lim \limits_{x \to \infty}(1-\frac{1}{x})^x = \frac{1}{e}$ </li><li>$\lim_{x \to 0} {\frac{\log_a(1+x)}{x} }=\frac{1}{\ln a}$  （将 $\frac{1}{x}提到指数位置，$利用公式4、换底公式 可以证明）</li><li>$\lim \limits_{x \to 0}{\frac{a^x -1}{x} } = \ln a$     (替换 $a^x -1 =t $，利用公式5可证明)</li><li>$\lim \limits_{x \to 0}{\frac{(1+x)^a -1 }{x} } = a$</li><li>$\ln{(1+x)} \sim x (x \to 0)$(等价无穷小)</li><li>$e^x-1 \sim x  (x \to 0)$(等价无穷小)</li><li>$(1+x)^a-1 \sim ax  (x \to 0)$ (等价无穷小)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文记录《函数与极限》章节中，比较重要的内容，以便以后复习。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章导数与微分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/导数与微分/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-10-26T02:49:05.262Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点</p><a id="more"></a><h2 id="第一节、导数的概念"><a href="#第一节、导数的概念" class="headerlink" title="第一节、导数的概念"></a>第一节、导数的概念</h2><h3 id="导数的引例"><a href="#导数的引例" class="headerlink" title="导数的引例"></a>导数的引例</h3><ul><li><p>速度问题<br>  $$\nu = \lim_{t \to t_0}\frac{f(t) - f(t_0)}{t-t_0}$$</p><p>  这时就把极限值$\nu$称为质点在时刻$t_0$的<strong>瞬时速度</strong></p></li><li><p>切线问题<br>  $$k = \lim_{t \to x_0}\frac{f(x) - f(x_0)}{x-x_0}$$</p><p>  那么k就是切线的斜率 。下面是切线的示意图：</p><p>  <img src="/wiki/数学知识/高数/导数与微分/12.png" alt="切线示意图"></p></li></ul><p>定义： 设函数y=f(x)在点$x_0$的某个领域内有定义，当自变量x在$x_0$处取得增量$\Delta x$(点$x_0 + \Delta x$ 仍在该领域内)时，相应的，因变量取得增量$\Delta y = f(x_0 + \Delta x) - f(x_0)$；如果 $\Delta y$ 与  $\Delta x$之比（当 $\Delta x \to 0$ 时）的极限存在，那么称函数 y= f(x)在点$x_0$处可导，并称这个极限为函数y=f(x)在点$x_0$处的导数，即为f’($x_0$) ,即</p><p>$$f’(x_0) = \lim_{\Delta x \to 0}{\frac{\Delta y}{\Delta x} } = \lim_{\Delta x \to 0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}, 也可以记作 y’, \frac{dy}{dx} 或\frac{df(x)}{dx}$$</p><p>也可以写作 ：</p><p>$$f’(x_0) = \lim_{h \to 0}{\frac{f(x_0+h)-f(x_0)}{h} }$$<br>或<br>$$f’(x_0)=\lim_{x \to x_0} \frac{f(x)- f(x_0)}{x-x_0}$$</p><p><strong>导数的意义</strong>： 导数的概念就是<strong>函数变化</strong>率这一概念的精确描述。<strong>因变量增量</strong>与<strong>自变量增量</strong>之比$\frac{\Delta y}{\Delta x}$ 是因变量y再以$x_0$和$x_0+\Delta x$为端点的区间上的平均变化率，而导数$f’(x_0)$则是因变量y在点$x_0$处的变化率。<strong>他反应了因变量随自变量的变化而变化的快慢程度。</strong></p><p><strong>下面是求导的示例：</strong></p><ul><li><p><strong>常数的导数</strong>： $C’ = 0$  ， 常数的导数为0</p></li><li><p><strong>幂函数的导数</strong> ：<br>$<br>(x^n)’=<br>\begin{cases}<br>0, &amp; \text{n=1} \\<br>n x^{n-1}, &amp; n&gt;1<br>\end{cases}<br>$</p></li><li><p><strong>sinx的导数</strong> $(\sin x)’=\cos x$、 $(\cos x)’ = - \sin x$</p></li><li><p><strong>指数函数的导数</strong>： $(a^x)’ = \lim_{h \to 0} {\frac{ {\alpha}^{x+h} - {\alpha}^x}{h} } = {\alpha}^x \lim_{h \to 0} \frac{ {\alpha}^h - 1}{h} = a^{x} \ln{a} $</p></li><li><p><strong>对数函数的导数</strong>：$(\log_ x)’ = \frac{1}{x \ln a}$<br>$\begin{equation} \begin{split}<br>f’(x)&amp;=\lim_{h \to 0} \frac{\log_{\alpha}{(x+h)} - \log_{\alpha}{x} }{h}\\<br>&amp;=\lim_{h \to 0}{\frac{1}{h} } \log_{\alpha}{\frac{x+h}{x} } = \lim_{h \to 0}{\frac{1}{x} } \cdot \frac{x}{h} \log_{\alpha}{(1+\frac{h}{x})}\\<br>&amp;=\frac{1}{x} \lim_{h \to 0}{\frac{\log_{\alpha}{(1+\frac{h}{x})} }{\frac{h}{x} } }\\<br>&amp;=\frac{1}{x \cdot \ln{\alpha} }<br>\end{split}\end{equation}$</p></li></ul><p><strong>导数的几何意义</strong>：函数y=f(x)在$x_0$处的导数表示曲线y=f(x）在点M处的切线的斜率。</p><ol><li>切线方程： $y-y_0 = f’(x_0)(x-x_0)$</li><li>法线方程： $y-y_0 = - \frac{1}{f’(x_0)}(x-x_0)$ </li></ol><p><img src="/wiki/数学知识/高数/导数与微分/13.png" alt="切线示意图"></p><p>函数的可导性和可连续性的关系：</p><ol><li>如果y=f(x)在点x处可导，那么函数在该点x处必连续。 $\frac{\Delta y}{\Delta y} = f’(x)+\alpha \Rightarrow \Delta y = f’(x) \Delta x +\alpha \Delta x$</li><li>连续不一定可导</li></ol><h2 id="第二节、函数的求导法则"><a href="#第二节、函数的求导法则" class="headerlink" title="第二节、函数的求导法则"></a>第二节、函数的求导法则</h2><p>一、 函数的和、差、积、商的求导法则</p><p><strong>定理1</strong> 如果函数$\mu$=$\mu(x)$及$\nu(x)$=$\nu(x)$都在点x具有导数，那么它们的和、差、积、商（除分母为零的点外）都在点x具有导数，且 </p><ol><li>[ $\mu(x)$ + $\nu(x)]’ = \mu(x)’ + \nu(x)’ $</li><li>$[\mu(x)\nu(x)]’ = \mu(x)’\nu(x) + \mu(x)\nu(x)’$</li><li>$[\frac{\mu(x)}{\nu(x)}]’ = \frac{\mu(x)’\nu(x)- \mu(x)\nu(x)’}{\nu^2(x)}$ 其中$\nu(x)$!=0</li></ol><p><strong>定理2（反函数求导法则）</strong>:如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：<br>$$[f^{-1}(x)]’ = \frac{1}{f’(y)}或 \frac{dy}{dx}=\frac{1}{\frac{dx}{dy} }$$ </p><blockquote><p>简单的说：反函数的导数等于直接函数导数的倒数。</p></blockquote><p><strong>示例：</strong></p><p>设x = sin y 为直接函数，则 y = arcsin x 是它的反函数。计算过程如下：</p><p>$<br>\begin{equation}\begin{split}<br>(arcsin x)’&amp; =\frac{1}{(sin y)’} = \frac{1}{cos y}\\<br>&amp;又:cos y = \sqrt {1- sin^2y} = \sqrt{1-x^2}\\<br>&amp;所以:(arcsin x)’ = \frac{1}{\sqrt{1- x^2} }\\<br>\end{split}\end{equation}<br>$<br>​    </p><p><strong>定理3（复合函数求导法则</strong>）如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：<br>$$\frac{dy}{dx}=f’(u) \cdot g’(x) 或 \frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$$</p><h2 id="第二节求导法则总结"><a href="#第二节求导法则总结" class="headerlink" title="第二节求导法则总结"></a>第二节求导法则总结</h2><p>一、 导数公式和基本求导法则 </p><table><thead><tr><th style="text-align:left">常用导数公式</th><th style="text-align:left">常用导数公式</th></tr></thead><tbody><tr><td style="text-align:left">(1). $(C)’ = 0 $</td><td style="text-align:left">(2). $(x^{\mu})’ = {\mu}x^{\mu -1} \text {幂函数}$</td></tr><tr><td style="text-align:left">(3). $(\sin x)’ = \cos x $</td><td style="text-align:left">(4). $(\cos x)’ = - \sin x $</td></tr><tr><td style="text-align:left">(5). $(\tan x)’ = \sec^{2} x $</td><td style="text-align:left">(6). $(\cot x)’ = - \csc^{2} x $</td></tr><tr><td style="text-align:left">(7). $(\sec x)’ = \sec{x} \tan{x} $</td><td style="text-align:left">(8). $(\csc x)’ = - \csc{x} \cot{x} $</td></tr><tr><td style="text-align:left">(9). $({\alpha}^x)’ = {\alpha}^x \ln{\alpha} $</td><td style="text-align:left">(10). $({e}^x)’ = e^x  $</td></tr><tr><td style="text-align:left">(11). $(\log_{\alpha}{x})’ = \frac{1}{x \ln{\alpha} } $</td><td style="text-align:left">(12). $(\ln{x})’ = \frac{1}{x } $</td></tr><tr><td style="text-align:left">(13). $(\arcsin x)’ = \frac{1}{\sqrt{1-x^2} } $</td><td style="text-align:left">(14). $(\arccos x)’ = - \frac{1}{\sqrt{1-x^2} } $</td></tr><tr><td style="text-align:left">(15). $(\arctan x)’ =  \frac{1}{1 + x^2} $</td><td style="text-align:left">(16). $(arccot x)’ = - \frac{1}{1 + x^2} $</td></tr></tbody></table><p>二、 函数的和、差、积、商的求导法则</p><p>设$\mu = \mu (x)$，$\nu = \nu (x)$ 都可导，则</p><table><thead><tr><th style="text-align:left">函数的和、差、积、商的求导法则</th><th style="text-align:left">函数的和、差、积、商的求导法则</th></tr></thead><tbody><tr><td style="text-align:left">(1). $ (\mu + \nu)’ = {\mu}’ + {\nu}’ $</td><td style="text-align:left">(2). $ (C \mu)’ = C{\mu}’ $</td></tr><tr><td style="text-align:left">(3). $ (\mu \nu)’ = {\mu}’ \nu + \mu {\nu}’ $</td><td style="text-align:left">(4). $ (\frac{\mu}{\nu})’ = \frac{ {\mu}’ \nu + \mu {\nu}’} { {\nu}^2} $</td></tr></tbody></table><p>三、 反函数求导法则 </p><p>如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：<br>$$[f^{-1}(x)]’ = \frac{1}{f’(y)}或 \frac{dy}{dx}=\frac{1}{\frac{dx}{dy} }$$ </p><p>四、 复合函数求导法则  </p><p>如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：<br>$$\frac{dy}{dx}=f’(u) \cdot g’(x) 或 \frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$$</p><h2 id="第三节、高阶导数"><a href="#第三节、高阶导数" class="headerlink" title="第三节、高阶导数"></a>第三节、高阶导数</h2><p>没有学习</p><h2 id="第五节、函数的微分"><a href="#第五节、函数的微分" class="headerlink" title="第五节、函数的微分"></a>第五节、函数的微分</h2><p>定义： 设函数 y= f(x)在某区间内有定义，$x_0$及$x_0 + \Delta x$在这区间内，如果函数的增量：</p><p>$$\Delta y = f(x_0 + \Delta x) - f(x_0)$$</p><p>可表示为：</p><p>$$\Delta y = A \Delta x + o(\Delta x)$$</p><p>其中A是不依赖于$\Delta x$的常数，那么称函数 y = f(x)在点 $x_0$处是可微的，而$A \Delta x$叫做函数 y = f(x)在点$x_0$相应于自变量增量$\Delta x$的微分，记作 dy 即</p><p>$$dy = A \Delta x$$</p><p>$$dy = f’(x_)) \Delta x$$</p><blockquote><p>微分的理解：相对于自变量的增量，因变量的变化，这个变化时微小的，理解为微分。</p></blockquote><p>微分和$\Delta y$的关系：<br>$$ \Delta y = dy + o(dy) $$</p><p><strong>微分可以近视代替因变量的增量 。微分是 $\Delta y$的主部。</strong></p><p>通常把自变量x的增量$\Delta x$称为自变量微分（微小的数），记作dx，于是函数y=f(x)的微分又可记作<br>$$dy = f’(x)dx$$</p><p><strong>微分的几何意义</strong>： dy 是曲线的切线上点的众坐标的相应增量。非线性函数的局部线性化。</p><p><img src="/wiki/数学知识/高数/导数与微分/14.png" alt="微分的几何意义"></p><p>从图中可以看出，dy = QP。当$\Delta y$是曲线y = f（x） 上的点的众坐标的增量， dy是曲线的切线上点的众坐标的相应的增量。当$\Delta x$很小时，$\Delta y - dy$比 $\Delta x$小的多，因此在点M的邻近，我们可以使用切线段来近视代替曲线段。 这就是<strong>非线性函数的局部线性化</strong>。</p><h2 id="微分公式总结"><a href="#微分公式总结" class="headerlink" title="微分公式总结"></a>微分公式总结</h2><p>暂无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章 随机变量及其分布</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"/>
    <id>http://yoursite.com/wiki/数学知识/概率论和数理统计/第二章 随机变量及其分布/</id>
    <published>2019-08-22T02:07:12.000Z</published>
    <updated>2019-08-22T07:52:53.715Z</updated>
    
    <content type="html"><![CDATA[<p>第二章学习记录。</p><a id="more"></a><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>定义： 设随机实验的样本空间为S={e},X=X(e)是定义在样本空间S上的实值单值函数，成X=X(e)为随机变量。</p><h2 id="离散型随机变量及其分布规律"><a href="#离散型随机变量及其分布规律" class="headerlink" title="离散型随机变量及其分布规律"></a>离散型随机变量及其分布规律</h2><p>有些随机变量，它全部可能取到的值是有限个或可列无限多个，这种随机变量称为离散型随机变量。</p><p>设离散型随机变量X多有可能的取值为$x_k$(k=1,2,…),X取各个可能值的概率，即事件{X=$x_k$}的概率，为<br>$$P\{X=x_k\} = p_k,k=1,2,….$$</p><h3 id="0-1分布"><a href="#0-1分布" class="headerlink" title="0-1分布"></a>0-1分布</h3><p>设随机变量X只可能取0与1两个值，它的分布律是：<br>$$P\{X=k\}=p^k(1-p)^{(1-k)}. k=0,1 (0&lt;p&lt;1)$$<br>则称X服从以p为参数的0-1分布或两点分布。</p><h3 id="伯努利实验、二项分布"><a href="#伯努利实验、二项分布" class="headerlink" title="伯努利实验、二项分布"></a>伯努利实验、二项分布</h3><p>设实验E只有两种可能，A 即 $\overline A$,则称E为伯努利实验，此时P(A)= p,$P(\overline A)=1-p$,将E独立重复的进行n次，则称这一串重复的独立实验为n重伯努利实验。</p><p>以X表示n重伯努利实验中事件A发生的次数，X是一个随机变量，我们求它的分布规律。X所有可能的取值为 0，1，2，…,n 。由于各次实验是相互独立的，因此事件A在指定的k次实验中发生，在其他n-k次实验中A不发生的概率为</p><p>$$pppp….pp(1-p)(1-p)….(1-p)=p^k(1-p)^{n-k}$$</p><p>这种指定的方式共有$\binom {n}{k}$种，他们是两两互不相容的，故在n次实验中A发生k次的概率为$\binom {n}{k}p^k(1-p)^{n-k}$,记q = 1-p，即有：</p><p>$$P\{X=k\}=\binom{n}{k}p^kq^{n-k},k=0,1,2,…,n\tag{2.6}$$</p><p>显然：</p><p>$$\sum_{k=0}^{n}P\{X=k\}=\sum_{k=0}^{n}\binom{n}{k}p^kq^{n-k}=(p+q)^n=1$$</p><p>注意到$\binom{n}{k}p^kq^{n-k}$刚好是二项式$(p+q)^n$的展开式中出现$p^k$的那一项，我们称随机变量X服从参数n，p的二项分布，并记为$X\sim b(n,p)$</p><p>特别的，当n=1时，二项分布化为：</p><p>$$P\{X=k\}=p^kq^{1-k},k=0,1$$</p><p>就是0-1分布。</p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>设随机变量X所有可能的取值为0，1，2…，取而代之的概率为：<br>$$P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,2….$$<br>其中$\lambda$&gt;0是常数，则称X服从参数为$\lambda$的泊松分布，记为X$\sim\pi(\lambda)$</p><p><strong>泊松定理</strong>：设$\lambda$&gt;0是一个常数，n是任意正整数，设$np_n=\lambda$，则对于人一个固定的非负整数k，有：</p><p>$$\lim_{n\to \infty}\binom{n}{k}p_n^k(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}$$</p><h2 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h2><p><strong>分布函数</strong>：设X是一个随机变量，x是任意实数，函数：</p><p>$$F(x)=P{X&lt;=x}$$<br>称为X的分布函数。</p><p>如果将X看成是数轴上的随机点左边，那么，分布函数F（x）在x出的函数值就表示X落在区间$(-\infty,x)$上的概率。</p><p>分布函数F（x）满足的基本性质：</p><ol><li>不减函数</li><li>0-1</li></ol><h2 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h2><p>如果对于随机变量X的分布函数F(x)，存在非负函数f(x),对于任意实数x有</p><p>$$F(x)=\int_{-\infty}^xf(t)dt\tag{4.1}$$<br>则称x为连续型随机变量，其中函数f(x)称为X的<strong>概率密度函数</strong>，简称<strong>概率密度</strong></p><p>三种重要的连续型随机变量</p><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><ol><li>指数分布</li><li>正态分布</li></ol><h2 id="随机变量的函数分布"><a href="#随机变量的函数分布" class="headerlink" title="随机变量的函数分布"></a>随机变量的函数分布</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="概率论和数理统计" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
</feed>
