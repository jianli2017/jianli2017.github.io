<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-18T01:30:53.415Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程参考资料</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/referr/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/referr/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-18T01:30:53.415Z</updated>
    
    <content type="html"><![CDATA[<p>记录度过的文章</p><a id="more"></a><h2 id="读过的文章"><a href="#读过的文章" class="headerlink" title="读过的文章"></a>读过的文章</h2><ol><li><a href="https://bujige.net/blog/iOS-Complete-learning-NSOperation.html" rel="external nofollow noopener noreferrer" target="_blank">iOS 多线程：『NSOperation、NSOperationQueue』详尽总结</a></li><li><a href="https://objccn.io/issue-2-1/#challenges" rel="external nofollow noopener noreferrer" target="_blank">并发编程：API 及挑战</a></li></ol><h2 id="需要读的"><a href="#需要读的" class="headerlink" title="需要读的"></a>需要读的</h2><ol><li><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html" rel="external nofollow noopener noreferrer" target="_blank">Concurrency Programming Guide</a></li><li><a href="https://leylfl.github.io/2018/01/16/浅谈iOS多线程-源码/" rel="external nofollow noopener noreferrer" target="_blank">浅谈iOS多线程(源码)</a></li><li><a href="https://objccn.io/issue-2-3/" rel="external nofollow noopener noreferrer" target="_blank">底层并发 API</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录度过的文章&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>NSOperation</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/NSOperation/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/NSOperation/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T09:45:48.872Z</updated>
    
    <content type="html"><![CDATA[<p>NSOperation类文档学习记录</p><a id="more"></a><h2 id="操作依赖"><a href="#操作依赖" class="headerlink" title="操作依赖"></a>操作依赖</h2><p>依赖可以控制操作执行的顺序，相关函数：</p><ol><li>addDependency</li><li>removeDependency</li></ol><p>当依赖的operation全部为完成状态时，operation才能为ready的状态。当最后一个依赖完成后，operation的状态变为ready状态。</p><p>依赖不区分operation是完成了还是取消了。</p><h2 id="KVO属性"><a href="#KVO属性" class="headerlink" title="KVO属性"></a>KVO属性</h2><p>KVO属性包括：</p><ol><li>isCancelled</li><li>isAsynchronous</li><li>isExecuting</li><li>isFinished</li><li>isReady</li><li>dependencies</li><li>queuePriority</li><li>completionBlock</li></ol><h2 id="多线程安全"><a href="#多线程安全" class="headerlink" title="多线程安全"></a>多线程安全</h2><p>多线程调用NSOperation的方法时安全的，不需要加锁。<br>子类的自定义方法需要考虑多线程问题。</p><h2 id="异步VS同步"><a href="#异步VS同步" class="headerlink" title="异步VS同步"></a>异步VS同步</h2><p>操作可以手动执行、也可以添加到queue中执行。</p><p>手动执行（直接调用start方法），分为同步operation和异步operation ，同步在当前线程立即执行。异步在新的线程执行任务。</p><p>如果操作在队列中执行，一般定义为同步的，队列不关注asynchronous属性，总是在一个单独的线程中调用start方法。所有没有理由设计为异步的。</p><h2 id="子类化"><a href="#子类化" class="headerlink" title="子类化"></a>子类化</h2><p>非并发队列：重写 main方法。<br>并发队列：需要重写start、 asynchronous、executing、finished方法。</p><p><strong>注意是否重写main决定了是否是并发操作。</strong></p><p>下面是子类化的要点：</p><ol><li>在并发队列中，start方法负责异步开始操作。</li><li>start方法中需要通过KVO更新operation的executing状态为YES。</li><li>operation完成或取消后，并发队列必须通过KVO更新isExecuting为NO 和 isFinished为YES。如果是取消，也需要更新isFinished状态为YES。</li><li>operation 只有完成了，才能从queue中移除。</li><li>同时需要重写 executing、finished属性（KVC）。</li><li>start方法需要检查是否operation被取消了。</li><li>如果定制了依赖，需要KVO isReady属性。</li></ol><p><strong>状态管理</strong>：</p><ol><li>isReady，一般不用管理，依赖的时候处理。</li><li>isExecuting，替换了start方法，一定要替换isExecuting方法，并在start开始的时候发出KVO</li><li>isFinished，替换了start方法，一定要替换isFinished方法。operation完成或取消，发出KVO</li><li>isCancelled，不需要发出KVO</li></ol><p><strong>响应取消</strong></p><p>一旦将operation添加到queue中，queue就掌管了operation。你可以通过调用operation的cancell方法取消，或者通过queue的cancelAllOperations取消。</p><p>执行中的任务并不会立马取消， 你必须显式的检测状态，需要的时候取消。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSOperation类文档学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="NSOperation" scheme="http://yoursite.com/tags/NSOperation/"/>
    
  </entry>
  
  <entry>
    <title>GCD源码理解</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/GCD_Source/"/>
    <id>http://yoursite.com/wiki/IOS/多线程/GCD_Source/</id>
    <published>2019-09-17T02:35:49.000Z</published>
    <updated>2019-09-17T11:57:53.764Z</updated>
    
    <content type="html"><![CDATA[<p>GCD源码理解</p><a id="more"></a><h2 id="GCD理解"><a href="#GCD理解" class="headerlink" title="GCD理解"></a>GCD理解</h2><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_sync.png" alt="同步"></p><p><img src="/wiki/IOS/多线程/GCD_Source/dispatch_async.png" alt="异步"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GCD源码理解&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/IOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/定积分/</id>
    <published>2019-09-10T01:07:12.000Z</published>
    <updated>2019-09-10T10:10:45.085Z</updated>
    
    <content type="html"><![CDATA[<p>记录定积分的学习记录，方便以后复习</p><a id="more"></a><h2 id="定积分的概念和性质"><a href="#定积分的概念和性质" class="headerlink" title="定积分的概念和性质"></a>定积分的概念和性质</h2><p><strong>定积分问题举例</strong></p><ol><li>曲边梯形的面积 $A=\lim \limits_{\lambda \to 0} {\sum_{i=1}^n{f(\xi) \Delta x}}$</li><li>变速直线运动的路程</li></ol><p>定义： 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点</p><p>$$a=x_0 &lt; x_1&lt;x_2…&lt;x_{n-1}&lt;x_n = b$$</p><p>把区间[a,b]分成n个小区间<br>$$[x_0,x_1],[x_1,x_2],…,[x_{n-1}]$$<br>各个小区间的长度依次为<br>$$\Delta x_1 = x_1-x_0,\Delta x_2 = x_2-x_1 … \Delta x_n = x_n - x_{n-1}$$<br>在每个小区间上任意去一点$\xi$,作为函数值$f(\xi)$与小区间长度$\Delta x_i$的乘积 $f(\xi_i) \cdot \Delta x_i$，并作出和<br>$$S = \sum_{i=1}^n{f(\xi_i) \cdot \Delta x_i}$$<br>如果和的极限存在，且闭区间[a,b]的分法及点$\xi_i$的取法无关，那么这个极限I为函数f(x)在区间[a,b]上的定积分，记作$\int_a^b{f(x)dx}$，即<br>$$\int_a^b{f(x)dx} = I = \lim_{\lambda \to 0}{\sum_{i=1}^n{f(\xi_i) \Delta x_i}}$$<br>其中[a,b]叫做积分区间。a叫做积分下限，b叫做积分上限</p><p>定积分的值只与被积函数和积分区间有关，而与积分变量和记法无关。</p><p>定理1 设f(x)在区间[a,b]上连续，则f(x)在[a,b]上可积<br>定理2 设f(x)在区间[a,b]上有界，且只有有限个剪短点，则f(x)在[a,b]上可积</p><p>牛顿-莱布尼茨公式</p><p><strong>微积分基本公式</strong>：如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，那么<br>$$\int_a^b{f(x)dx}=F(b)-F(a)$$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><p>$1^2+2^2+..+n^2= \frac{1}{6}n(n+1)(2n+1)$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录定积分的学习记录，方便以后复习&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>刷脸登录调研</title>
    <link href="http://yoursite.com/wiki/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/faceLogin/"/>
    <id>http://yoursite.com/wiki/编程理论/人脸登录/faceLogin/</id>
    <published>2019-09-03T04:11:35.000Z</published>
    <updated>2019-09-03T08:57:01.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文调研人脸登录的实现思路。</p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>人脸登录包括两个流程：人脸注册、人脸查找。</p><h2 id="人脸注册"><a href="#人脸注册" class="headerlink" title="人脸注册"></a>人脸注册</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/register.png" alt="人脸注册流程"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data1.png" alt="图片组织结构"></p><p><img src="/wiki/编程理论/人脸登录/faceLogin/data2.png" alt="facetoken和profileid对应关系"></p><h2 id="刷脸登录（查找人脸的过程）"><a href="#刷脸登录（查找人脸的过程）" class="headerlink" title="刷脸登录（查找人脸的过程）"></a>刷脸登录（查找人脸的过程）</h2><p><img src="/wiki/编程理论/人脸登录/faceLogin/login.png" alt="刷脸登录"></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ol><li>非常像的双胞胎能识别出来吗？</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/zzqaaasss/article/details/89194437" rel="external nofollow noopener noreferrer" target="_blank">微信小程序使用face++实现人脸识别登录注册</a></li><li><a href="https://console.faceplusplus.com.cn/documents/4888373" rel="external nofollow noopener noreferrer" target="_blank">face++文档中心</a></li><li><a href="https://blog.csdn.net/qq_23412263/article/details/86232682" rel="external nofollow noopener noreferrer" target="_blank">使用 face++ API 实现人脸识别，刷脸登陆和活体检测（张张嘴，眨眨眼）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文调研人脸登录的实现思路。&lt;/p&gt;
    
    </summary>
    
      <category term="编程理论" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/"/>
    
      <category term="人脸登录" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B%E7%90%86%E8%AE%BA/%E4%BA%BA%E8%84%B8%E7%99%BB%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>不定积分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/four_indefinite_integral/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/four_indefinite_integral/</id>
    <published>2019-08-29T01:07:12.000Z</published>
    <updated>2019-09-10T03:58:27.021Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点，</p><a id="more"></a><h2 id="不定积分的概念和性质"><a href="#不定积分的概念和性质" class="headerlink" title="不定积分的概念和性质"></a>不定积分的概念和性质</h2><p>定义1：如果在区间I上，可导函数F(x)的导函数为f(x),即对任意x属于I都有：<br>$$F’(x)=f(x) 或dF(x)=f(x)dx$$<br>那么函数F(x)就称为f(x)（或f(x)dx）在区间I上的一个<strong>原函数</strong>。</p><p>原函数存在定理：如果函数f(x)在区间I上连续，那么在区间I上存在可导函数F(x),使对任一x属于I都有<br>$$F’(x)=f(x)$$<br>简单的说，连续函数一定有原函数。</p><p>表达式 F(x) + C 可以表示f(x)的任意一个原函数。</p><p>定义2 在区间I上，函数f(x)的带有任意常数项的原函数称为f(x)(或f(x)dx)在区间I上的不定积分，记作：<br>$$\int{f(x)dx}$$<br>其中记号$\int$称为积分号，f(x)称为被积函数，f(x)dx<br>称为被积表达式，x称为积分变量。</p><p>因而不定积分$\int{f(x)dx}$可以表达f(x)的任意一个原函数。</p><p><strong>基本积分表</strong></p><p><img src="/wiki/数学知识/高数/four_indefinite_integral/1.png" alt=""></p><p><strong>不定积分的性质</strong></p><p>性质1 设函数f(x)及 g(x)的原函数存在，则<br>$$\int{[f(x)+g(x)]dx} = \int{f(x)dx} + \int{g(x)dx}$$</p><p>性质2 设函数f(x)的原函数存在，k为非零常数，则<br>$$\int{kf(x)dx}=k\int{f(x)dx}$$</p><h2 id="换元积分法"><a href="#换元积分法" class="headerlink" title="换元积分法"></a>换元积分法</h2><p>把复合函数的微分法反过来，用于求不定积分，利用中间变量的代换，得到符合函数的积分，称为<strong>积分换元法</strong>。</p><p>定理1 设f(u)具有原函数，u=$\psi$(x)可导，则有换元公式<br>$$\int{f[\psi (x)]\psi ‘(x)dx} = [\int{f(u)du}]_{u=\psi (x)}$$</p><p>如果应用换元法求不定积分呢？设要求$\int{g(x)dx}$，如果g(x)可以化为g(x)= $f[\psi (x)]\psi ‘(x)$的形式，那么<br>$$\int {g(x)dx}= \int{f[\psi (x)]\psi ‘(x)dx}=\int{f(u)du}$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点，&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="不定积分" scheme="http://yoursite.com/tags/%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>导数与微分</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%AF%BC%E6%95%B0%E4%B8%8E%E5%BE%AE%E5%88%86/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/导数与微分/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-09-09T08:18:52.692Z</updated>
    
    <content type="html"><![CDATA[<p>记录导数与微分的主要知识点</p><a id="more"></a><h2 id="第一节、导数的概念"><a href="#第一节、导数的概念" class="headerlink" title="第一节、导数的概念"></a>第一节、导数的概念</h2><p>定义： 设函数y=f(x)在点$x_0$的某个领域内有定义，当自变量x在$x_0$处取得增量$\Delta x$(点$x_0 + \Delta x$ 仍在该领域内)时，相应的，因变量取得增量$\Delta y = f(x_0 + \Delta x) - f(x_0)$；如果 $\Delta y$ 与  $\Delta x$之比（当 $\Delta x \to 0$ 时）的极限存在，那么称函数 y= f(x)在点$x_0$处可导，并称这个极限为函数y=f(x)在点$x_0$处的导数，即为f’($x_0$) ,即</p><p>$$f’(x_0) = \lim_{\Delta x \to 0}{\frac{\Delta y}{\Delta x}} = \lim_{\Delta x \to 0} \frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}, 也可以记作 y’, \frac{dy}{dx} 或\frac{df(x)}{dx}$$</p><p>也可以写作 ：</p><p>$$f’(x_0) = \lim_{h \to 0}{\frac{f(x_0+h)-f(x_0)}{h}}$$<br>或<br>$$f’(x_0)=\lim_{x \to x_0} \frac{f(x)- f(x_0)}{x-x_0}$$</p><p><strong>导数的意义</strong>： 导数的概念就是函数变化率这一概念的精确描述。因变量增量与自变量增量之比$\frac{\Delta y}{\Delta x}$ 是因变量y再以$x_0$和$x_0+\Delta x$为端点的区间上的平均变化率，而导数$f’(x_0)$则是因变量y在点$x_0$处的变化率。他反应了因变量随自变量的变化而变化的快慢程度。</p><p><strong>下面是求导的示例：</strong></p><p><strong>常数的导数</strong>： $$C’ = 0$$  常数的导数为0</p><p><strong>幂函数的导数</strong> ：</p><p>$$<br>(x^n)’=<br>\begin{cases}<br>0, &amp; \text{n=1} \\<br>n x^{n-1}, &amp; n&gt;1<br>\end{cases}<br>$$</p><p><strong>sinx的导数</strong> $$(sinx)’=cosx$$</p><p><strong>指数函数的导数</strong>： $$(a^x)’ =a^{x} \ln{a} $$</p><p><strong>对数函数的导数</strong>：$(\log_ x)’ = \frac{1}{x \ln a}$</p><p><strong>导数的几何意义</strong>：函数y=f(x)在$x_0$处的导数表示曲线y=f(x）在点M处的切线的斜率。</p><ol><li>切线方程： $y-y_0 = f’(x_0)(x-x_0)$</li><li>法线方程： $y-y_0 = - \frac{1}{f’(x_0)}(x-x_0)$ </li></ol><p>函数的可导性和可连续性的关系：</p><ol><li>如果y=f(x)在点x处可导，那么函数在该点x处必连续。</li><li>连续不一定可导</li></ol><h2 id="第二节、函数的求导法则"><a href="#第二节、函数的求导法则" class="headerlink" title="第二节、函数的求导法则"></a>第二节、函数的求导法则</h2><p><strong>定理1</strong> 如果函数$\mu$=$\mu(x)$及$\nu(x)$=$\nu(x)$都在点x具有导数，那么它们的和、差、积、商（除分母为零的点外）都在点x具有导数，且 </p><ol><li>[ $\mu(x)$ + $\nu(x)]’ = \mu(x)’ + \nu(x)’ $</li><li>$[\mu(x)\nu(x)]’ = \mu(x)’\nu(x) + \mu(x)\nu(x)’$</li><li>$[\frac{\mu(x)’}{\nu(x)}]’ = \frac{\mu(x)’\nu(x)- \mu(x)\nu(x)’}{\nu^2(x)}$ 其中$\nu(x)$!=0</li></ol><p><strong>定理2（反函数求导法则）</strong>:如果函数x=f(y)在区间$I_y$内单调、可导且f’(y)!=0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：<br>$$[f^{-1}(x)]’ = \frac{1}{f’(y)}或 \frac{dy}{dx}=\frac{1}{\frac{dx}{dy}}$$ </p><p><strong>定理3（复合函数求导法则</strong>）如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：<br>$$\frac{dy}{dx}=f’(u) \cdot g’(x) 或 \frac{dy}{dx}=\frac{dy}{du} \cdot \frac{du}{dx}$$</p><p><img src="/wiki/数学知识/高数/导数与微分/9.png" alt="导数公式"></p><h2 id="第三节、高阶导数"><a href="#第三节、高阶导数" class="headerlink" title="第三节、高阶导数"></a>第三节、高阶导数</h2><p>没有学习</p><h2 id="第五节、函数的微分"><a href="#第五节、函数的微分" class="headerlink" title="第五节、函数的微分"></a>第五节、函数的微分</h2><p>定义： 设函数 y= f(x)在某区间内有定义，$x_0$及$x_0 + \Delta x$在这区间内，如果函数的增量：</p><p>$$\Delta y = f(x_0 + \Delta x) - f(x_0)$$</p><p>可表示为：</p><p>$$\Delta y = A \Delta x + o(\Delta x)$$</p><p>其中A是不依赖于$\Delta x$的常数，那么称函数 y = f(x)在点 $x_0$处是可微的，而$A \Delta x$叫做函数 y = f(x)在点$x_0$相应于自变量增量$\Delta x$的微分，记作 dy 即</p><p>$$dy = A \Delta x$$</p><p>$$dy = f’(x_)) \Delta x$$</p><p><strong>微分可以近视代替因变量的增量 。微分是 $\Delta y$的主部。</strong></p><p>通常把自变量x的增量$\Delta x$称为自变量微分（微小的数），记作dx，于是函数y=f(x)的微分又可记作<br>$$dy = f’(x)dx$$</p><p>微分的几何意义： dy 是曲线的切线上点的众坐标的相应增量。非线性函数的局部线性化。</p><p>下面是微分公式：</p><p><img src="/wiki/数学知识/高数/导数与微分/10.png" alt="微分公式"></p><p>和差化积的微分公式：<br><img src="/wiki/数学知识/高数/导数与微分/11.png" alt="微分公式"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录导数与微分的主要知识点&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>函数与极限</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%81%E9%99%90/"/>
    <id>http://yoursite.com/wiki/数学知识/高数/函数与极限/</id>
    <published>2019-08-25T01:07:12.000Z</published>
    <updated>2019-09-09T06:00:52.694Z</updated>
    
    <content type="html"><![CDATA[<p>记录函数与极限学习记录</p><a id="more"></a><h2 id="数列的极限"><a href="#数列的极限" class="headerlink" title="数列的极限"></a>数列的极限</h2><p><strong>定义</strong>： 设{$x_n$}为一数列，如果存在常数a，对于任意给定的正数$\epsilon$ (不论它多么小)，总存在正整数N，使得，当n&gt;N时，不等式<br>$$|x_n-a|&lt;\epsilon$$<br>都成立，那么就称常数a是数列{$x_n$}的极限，或者称数列{$x_n$}收敛于a，记为：<br>$$\lim \limits_{n \to \infty} {x_n} = a$$</p><p><strong>收敛数列的性质 </strong></p><p><strong>定理一（极限的唯一性）</strong> 如果数列{$x_n$}收敛，那么他的极限唯一</p><p><strong>定理二（收敛数列的有界性）</strong>如果数列{$x_n$}收敛，那么数列{$x_n$}一定有界。</p><p><strong>定理三（收敛数列的保号性）</strong>如果$\lim \limits_{n \to \infty} {x_n} = a$，且a&gt;0，那么存在正整数N，当n&gt;N时，都有$x_n$&gt;0</p><p>定理四（收敛数列与其子数列间的关系）如果数列{$x_n$}收敛于a，那么他的任一子数列也收敛，且极限也是a。</p><h2 id="函数的极限"><a href="#函数的极限" class="headerlink" title="函数的极限"></a>函数的极限</h2><p>讨论函数极限时，自变量变化的情形包括：</p><ol><li>自变量x任意的接近于有限制$x_0$</li><li>自变量x的绝对值无限大</li></ol><p><strong>定义1</strong> 设函数f(x)在点$x_0$的去心领域内有定义，如果存在常数A，对于任意给定的正数$\epsilon$(不论多么小)，总存在正数$\delta$,使得当x满足不等式0&lt;|x-$x_0$|&lt;$\delta$时，对应的函数值f(x)都满足不等式<br>$$|f(x)-A|&lt;\epsilon$$<br>那么常数A就叫做函数f(x)当x-&gt;$x_0$时的极限记作：<br>$$\lim_{x-&gt;x_0}f(x)=A$$</p><p>函数极限的性质：</p><ol><li>极限的唯一性</li><li>局部有界性  </li><li>局部保号性</li><li>函数极限和数列极限的关系（函数有极限，数列也有极限）</li></ol><h2 id="第四节-无穷小和无穷大"><a href="#第四节-无穷小和无穷大" class="headerlink" title="第四节 无穷小和无穷大"></a>第四节 无穷小和无穷大</h2><p><strong>定义</strong>： 极限为零，那么称函数为当x-&gt;$x_0$时的无穷小</p><p><strong>定理1</strong> ： 在自变量的同一变化过程$x-&gt;x_0$中，函数f(x)具有极限的充分必要条件是f(x) = A + $\alpha$,其中 $\alpha$是无穷小。</p><p><strong>定理2</strong>： 在自变量的同一变化过程中，如果f(x)为无穷大，那么$\frac{1}{f(x)}$为无穷大，如果f(x)为无穷小，且f(x)!=0 .那么$\frac{1}{f(x)}$为无穷大。</p><h2 id="第五节极限运算法则"><a href="#第五节极限运算法则" class="headerlink" title="第五节极限运算法则"></a>第五节极限运算法则</h2><p><strong>定理1</strong> 两个无穷小的和是无穷小</p><p><strong>定理2</strong> 有界函数与无穷小的乘积是无穷小</p><p>$x \to x_0 （或 x \to \infty）$ 如果limf(x)=A,limg(x)=B,那么</p><ol><li>lim[f(x)+g(x)]=limf(x)+limg(x)=A+B</li><li>lim[f(x)g(x)]=limf(x)limg(x)=AB</li><li>lim$\frac{f(x)}{g(x)}$=$\frac{limf(x)}{limg(x)}=\frac{A}{B}$，其中B不等于0</li></ol><p>定理4 数列和函数有类似定理3的性质<br>定理5 $\upsilon(x)&gt;=\psi$(x),而lim$\upsilon(x)$=A,lim$\psi(x)$=B,那么A&gt;=B</p><blockquote><p>注意： 求极限时，如果分母为0，需要化为不为0</p></blockquote><p>定理6 复合函数的极限运算法则，设函数y=f[g(x)]是由函数u=g(x)与函数y=f(u)符合而成，f[g(x)]在点$x_0$的某个去心领域内有定义，$\lim \limits_{x \to x_0}{g(x)}=u_0$ , $\lim \limits_{u \to u_0} {f(u)}=A$,且存在$\delta_0&gt;0$，当x属于（$x_0,\delta_0$）时，有g(x)!=$u_0$,则<br>$$\lim \limits_{x \to x_0} {f[g(x)]} = \lim \limits_{u \to u_0} {f(u)}=A $$</p><h2 id="第六节-极限存在准则、两个重要极限"><a href="#第六节-极限存在准则、两个重要极限" class="headerlink" title="第六节 极限存在准则、两个重要极限"></a>第六节 极限存在准则、两个重要极限</h2><p><strong>准则1</strong> ，如果数列{$x_n$}、{$y_n$}、{$z_n$}满足下面条件：</p><p>$y_n$&lt;=$x_n$&lt;=$z_n$</p><p>且$\lim_ \limits{n-&gt;\infty}y_n=a,\lim_ \limits{n-&gt;\infty}z_n=a$</p><p>那么数列{$x_n$}的极限存在，且$\lim \limits_{n-&gt;\infty}x_n=a$</p><p>这个准则称为<strong>夹逼准则</strong>。</p><p><strong>准则2 单调有界必有极限。</strong></p><p>一个重要的极限公式：$$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e$$</p><p>柯西极限存在准则  数列{$x_n$} 收敛的充分必要条件是：对于任意给定的正数$\epsilon$,存在正整数N，使得m&gt;N, n&gt;N时，有：</p><p>$$|x_n-x_m|&lt;\epsilon$$</p><h2 id="第七节：无穷小的比较"><a href="#第七节：无穷小的比较" class="headerlink" title="第七节：无穷小的比较"></a>第七节：无穷小的比较</h2><p>定义： 如果函数f(x)当$x \to x_0 （或 x \to \infty）$时极限为零，那么称函数f(x)为当$x \to x_0 （或 x \to \infty）时的无穷小。</p><p>定理1 在自变量的同一变化过程$x \to x_0 （或 x \to \infty）$中，函数f(x)具有极限A的充分必要条件是f(x)=A+a,其中a是无穷小。</p><p>定义(更小的阶数更高) ：</p><ol><li>如果$lim \frac{\beta}{\alpha}$ = 0，那么就说$\beta$是比$\alpha$高阶的无穷小，记作$\beta$=o($\alpha$)</li><li>如果$lim \frac{\beta}{\alpha}$ = $\infty$，那么就说$\beta$是比$\alpha$低阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = c，那么就说$\beta$,$\alpha$同阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha^k}$ =c，那么就说$\beta$是$\alpha$的k阶的无穷小</li><li>如果$lim \frac{\beta}{\alpha}$ = 1，那么就说$\beta$、$\alpha$时等阶无穷小 记作$\alpha \sim \beta$</li></ol><h2 id="函数的连续性和间断性"><a href="#函数的连续性和间断性" class="headerlink" title="函数的连续性和间断性"></a>函数的连续性和间断性</h2><p>定义： 设函数y=f(x)在点$x_0$的某一领域内有定义，如果：</p><p>$$\lim \limits_{\bigtriangleup x \to 0}\bigtriangleup y = 0$$</p><p>那么就称函数y=f(x)在点$x_0$连续。</p><h2 id="闭区间上连续函数的性质"><a href="#闭区间上连续函数的性质" class="headerlink" title="闭区间上连续函数的性质"></a>闭区间上连续函数的性质</h2><p><strong>定理1</strong> 有界性与最大值最小值定理，在闭区间上连续的函数在该区间上有界，且一定能取得他的最大值和最小值。</p><p><strong>零点定理</strong>： 设函数f(x)在闭区间【a,b】上连续，且f(a)与f(b)异号，则在开区间(a,b)内至少有一点$\epsilon$， 使 $$f(\epsilon) = 0$$</p><p><strong>定理2（介值定理）</strong> 设函数f(x)在闭区间【a,b】上连续，且在这区间的端点去不同的函数值，$$f(a)=A,f(b)=B$$<br>则对于A于B之间的任意一个数C，在开区间（a,b）内至少有一点$\epsilon$,使得</p><p>$$f(\epsilon) = C $$</p><h2 id="有用的公式"><a href="#有用的公式" class="headerlink" title="有用的公式"></a>有用的公式</h2><ol><li>$x^2-9=(x+3)(x-3)$</li><li>$1+\frac{1}{2}+\frac{1}{2^2}+…+\frac{1}{2^{n-1}}=\frac{1-\frac{1}{2^n}}{1-\frac{1}{2}}$</li><li>二项式定理 $(x+y)^n = \binom {n}{0}x^ny^0 + \binom {n}{1}x^{n-1}y^1 +\binom {n}{2}x^{n-2}y^2 + …+ \binom {n}{n-1}x^1y^{n-1} + \binom {n}{n}x^0y^n$,其中$\binom {n}{k}$为二项系数，等于$\frac{n!}{k!(n-k)!}$.</li><li>$\lim \limits_{n-&gt;\infty}(1+\frac{1}{n})^n=e=2.718281$ （二项式展开可证明）</li><li>$\lim \limits_{x \to \infty}(1-\frac{1}{x})^x = \frac{1}{e}$ </li><li>$\lim_{x \to 0} {\frac{\log_a(1+x)}{x}}=\frac{1}{\ln a}$  （将 $\frac{1}{x}提到指数位置，$利用公式4、换底公式 可以证明）</li><li>$\lim \limits_{x \to 0}{\frac{a^x -1}{x}} = \ln a$     (替换 $a^x -1 =t $，利用公式5可证明)</li><li>$\lim \limits_{x \to 0}{\frac{(1+x)^a -1 }{x}} = a$</li><li>$\ln{(1+x)} \sim x (x \to 0)$(等价无穷小)</li><li>$e^x-1 \sim x  (x \to 0)$(等价无穷小)</li><li>$(1+x)^a-1 \sim ax  (x \to 0)$ (等价无穷小)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录函数与极限学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="高数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E9%AB%98%E6%95%B0/"/>
    
    
      <category term="高数" scheme="http://yoursite.com/tags/%E9%AB%98%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章 随机变量及其分布</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"/>
    <id>http://yoursite.com/wiki/数学知识/概率论和数理统计/第二章 随机变量及其分布/</id>
    <published>2019-08-22T02:07:12.000Z</published>
    <updated>2019-08-22T07:52:53.715Z</updated>
    
    <content type="html"><![CDATA[<p>第二章学习记录。</p><a id="more"></a><h2 id="随机变量"><a href="#随机变量" class="headerlink" title="随机变量"></a>随机变量</h2><p>定义： 设随机实验的样本空间为S={e},X=X(e)是定义在样本空间S上的实值单值函数，成X=X(e)为随机变量。</p><h2 id="离散型随机变量及其分布规律"><a href="#离散型随机变量及其分布规律" class="headerlink" title="离散型随机变量及其分布规律"></a>离散型随机变量及其分布规律</h2><p>有些随机变量，它全部可能取到的值是有限个或可列无限多个，这种随机变量称为离散型随机变量。</p><p>设离散型随机变量X多有可能的取值为$x_k$(k=1,2,…),X取各个可能值的概率，即事件{X=$x_k$}的概率，为<br>$$P\{X=x_k\} = p_k,k=1,2,….$$</p><h3 id="0-1分布"><a href="#0-1分布" class="headerlink" title="0-1分布"></a>0-1分布</h3><p>设随机变量X只可能取0与1两个值，它的分布律是：<br>$$P\{X=k\}=p^k(1-p)^{(1-k)}. k=0,1 (0&lt;p&lt;1)$$<br>则称X服从以p为参数的0-1分布或两点分布。</p><h3 id="伯努利实验、二项分布"><a href="#伯努利实验、二项分布" class="headerlink" title="伯努利实验、二项分布"></a>伯努利实验、二项分布</h3><p>设实验E只有两种可能，A 即 $\overline A$,则称E为伯努利实验，此时P(A)= p,$P(\overline A)=1-p$,将E独立重复的进行n次，则称这一串重复的独立实验为n重伯努利实验。</p><p>以X表示n重伯努利实验中事件A发生的次数，X是一个随机变量，我们求它的分布规律。X所有可能的取值为 0，1，2，…,n 。由于各次实验是相互独立的，因此事件A在指定的k次实验中发生，在其他n-k次实验中A不发生的概率为</p><p>$$pppp….pp(1-p)(1-p)….(1-p)=p^k(1-p)^{n-k}$$</p><p>这种指定的方式共有$\binom {n}{k}$种，他们是两两互不相容的，故在n次实验中A发生k次的概率为$\binom {n}{k}p^k(1-p)^{n-k}$,记q = 1-p，即有：</p><p>$$P\{X=k\}=\binom{n}{k}p^kq^{n-k},k=0,1,2,…,n\tag{2.6}$$</p><p>显然：</p><p>$$\sum_{k=0}^{n}P\{X=k\}=\sum_{k=0}^{n}\binom{n}{k}p^kq^{n-k}=(p+q)^n=1$$</p><p>注意到$\binom{n}{k}p^kq^{n-k}$刚好是二项式$(p+q)^n$的展开式中出现$p^k$的那一项，我们称随机变量X服从参数n，p的二项分布，并记为$X\sim b(n,p)$</p><p>特别的，当n=1时，二项分布化为：</p><p>$$P\{X=k\}=p^kq^{1-k},k=0,1$$</p><p>就是0-1分布。</p><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>设随机变量X所有可能的取值为0，1，2…，取而代之的概率为：<br>$$P\{X=k\}=\frac{\lambda^ke^{-\lambda}}{k!},k=0,1,2….$$<br>其中$\lambda$&gt;0是常数，则称X服从参数为$\lambda$的泊松分布，记为X$\sim\pi(\lambda)$</p><p><strong>泊松定理</strong>：设$\lambda$&gt;0是一个常数，n是任意正整数，设$np_n=\lambda$，则对于人一个固定的非负整数k，有：</p><p>$$\lim_{n\to \infty}\binom{n}{k}p_n^k(1-p_n)^{n-k}=\frac{\lambda^ke^{-\lambda}}{k!}$$</p><h2 id="随机变量的分布函数"><a href="#随机变量的分布函数" class="headerlink" title="随机变量的分布函数"></a>随机变量的分布函数</h2><p><strong>分布函数</strong>：设X是一个随机变量，x是任意实数，函数：</p><p>$$F(x)=P{X&lt;=x}$$<br>称为X的分布函数。</p><p>如果将X看成是数轴上的随机点左边，那么，分布函数F（x）在x出的函数值就表示X落在区间$(-\infty,x)$上的概率。</p><p>分布函数F（x）满足的基本性质：</p><ol><li>不减函数</li><li>0-1</li></ol><h2 id="连续型随机变量及其概率密度"><a href="#连续型随机变量及其概率密度" class="headerlink" title="连续型随机变量及其概率密度"></a>连续型随机变量及其概率密度</h2><p>如果对于随机变量X的分布函数F(x)，存在非负函数f(x),对于任意实数x有</p><p>$$F(x)=\int_{-\infty}^xf(t)dt\tag{4.1}$$<br>则称x为连续型随机变量，其中函数f(x)称为X的<strong>概率密度函数</strong>，简称<strong>概率密度</strong></p><p>三种重要的连续型随机变量</p><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><ol><li>指数分布</li><li>正态分布</li></ol><h2 id="随机变量的函数分布"><a href="#随机变量的函数分布" class="headerlink" title="随机变量的函数分布"></a>随机变量的函数分布</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二章学习记录。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="概率论和数理统计" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Choosing a Specific Interface Style for Your iOS App（选择明确的界面样式）</title>
    <link href="http://yoursite.com/wiki/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/%E9%80%89%E6%8B%A9%E6%98%8E%E7%A1%AE%E7%9A%84%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS/黑夜模式/选择明确的样式/</id>
    <published>2019-08-19T02:07:12.000Z</published>
    <updated>2019-08-19T03:17:22.005Z</updated>
    
    <content type="html"><![CDATA[<p>Adopt a specific interface style for your views, view controllers, or app when it is inappropriate to support both light and dark variants.</p><p>当你的APP不适合light、dark模式时，为你的view，controller选择一个明确的样式。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>系统假设在ios13或者以后， app默认支持light、dark样式。在IOS中，你可以为window、view、controller指定明确的样式。也可以在plist中静止黑夜模式。</p><h2 id="Override-the-Interface-Style-for-a-Window-View-or-View-Controller重写界面样式"><a href="#Override-the-Interface-Style-for-a-Window-View-or-View-Controller重写界面样式" class="headerlink" title="Override the Interface Style for a Window, View, or View Controller重写界面样式"></a>Override the Interface Style for a Window, View, or View Controller重写界面样式</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always adopt a light interface style.    </span></span><br><span class="line">    overrideUserInterfaceStyle = .light</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Override-the-Interface-Style-for-Child-View-Controllers重写子控制器的样式"><a href="#Override-the-Interface-Style-for-Child-View-Controllers重写子控制器的样式" class="headerlink" title="Override the Interface Style for Child View Controllers重写子控制器的样式"></a>Override the Interface Style for Child View Controllers重写子控制器的样式</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var overrideTraitCollection: UITraitCollection? &#123; <span class="builtin-name">get</span> <span class="builtin-name">set</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="Opt-Out-of-Dark-Mode-Entirely-全部退出黑夜模式"><a href="#Opt-Out-of-Dark-Mode-Entirely-全部退出黑夜模式" class="headerlink" title="Opt Out of Dark Mode Entirely 全部退出黑夜模式"></a>Opt Out of Dark Mode Entirely 全部退出黑夜模式</h2><p>在plist中设置 UIUserInterfaceStyle的值为Light。</p><blockquote><p>Supporting Dark Mode is strongly encouraged. Use the UIUserInterfaceStyle key to opt out only temporarily while you work on improvements to your app’s Dark Mode support.</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/documentation/appkit/supporting_dark_mode_in_your_interface/choosing_a_specific_interface_style_for_your_ios_app" rel="external nofollow noopener noreferrer" target="_blank">Choosing a Specific Interface Style for Your iOS App</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Adopt a specific interface style for your views, view controllers, or app when it is inappropriate to support both light and dark variants.&lt;/p&gt;
&lt;p&gt;当你的APP不适合light、dark模式时，为你的view，controller选择一个明确的样式。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="黑夜模式" scheme="http://yoursite.com/categories/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="dark" scheme="http://yoursite.com/tags/dark/"/>
    
  </entry>
  
  <entry>
    <title>Supporting Dark Mode in Your Interface（支持黑夜模式）</title>
    <link href="http://yoursite.com/wiki/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/%E6%94%AF%E6%8C%81%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/IOS/黑夜模式/支持黑夜模式/</id>
    <published>2019-08-19T02:07:12.000Z</published>
    <updated>2019-08-19T03:17:29.905Z</updated>
    
    <content type="html"><![CDATA[<p>Update colors, images, and behaviors so that your app adapts automatically when Dark Mode is active.</p><p>当黑夜模式激活后，更新颜色、图片、行为，使app自动适应黑夜模式。</p><a id="more"></a><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Standard views and controls automatically update their appearance to match the current interface style，If you already use color and image assets, you can add dark variants without changing your code.</p><p>标准view、controls自动更新界面去匹配当前界面模式。如果你使用了<strong>color and image assets</strong>你可以不修改代码，从而添加黑夜模式的支持。</p><h2 id="Choose-Adaptive-Colors-for-Your-UI-为你的UI选择适合的颜色"><a href="#Choose-Adaptive-Colors-for-Your-UI-为你的UI选择适合的颜色" class="headerlink" title="Choose Adaptive Colors for Your UI 为你的UI选择适合的颜色"></a>Choose Adaptive Colors for Your UI 为你的UI选择适合的颜色</h2><p>There are two ways to create adaptive color objects:</p><ol><li>Choose semantic colors instead of fixed color values. When configuring UI elements, choose colors with names like labelColor. These semantic colors convey the intended use of the color, rather than specific color values. When you use them for their intended purpose, they render with color values appropriate for the current settings. For a complete list of semantic color names, see NSColor and UIColor.</li><li>Define custom colors in your asset catalog. When you need a specific color, create it as a color asset. In your asset, specify different color values for both light and dark appearances. You can also specify high-contrast versions of your colors.</li></ol><ol><li>选择UIColor类中定义的<strong>语义color</strong>,而不是固定的颜色</li><li>将自定义color定义在asset catalog中，指定dark、light中颜色。代码中使用<strong>UIColor(named: “customControlColor”)</strong> 加载颜色。</li></ol><p>定义在asset catalog中的颜色自动适配dark、light模式。模式的变化，不需要重新加载。</p><h2 id="Create-Images-for-All-Appearances"><a href="#Create-Images-for-All-Appearances" class="headerlink" title="Create Images for All Appearances"></a>Create Images for All Appearances</h2><p>If an image is difficult to see when changing appearances, provide a new image asset that looks good in the other appearance.</p><p>提供image asset 支持两种模式。</p><h2 id="Update-Custom-Views-Using-Specific-Methods-使用特定方法更新自定义view。"><a href="#Update-Custom-Views-Using-Specific-Methods-使用特定方法更新自定义view。" class="headerlink" title="Update Custom Views Using Specific Methods 使用特定方法更新自定义view。"></a>Update Custom Views Using Specific Methods 使用特定方法更新自定义view。</h2><p><img src="/wiki/IOS/黑夜模式/支持黑夜模式/1.png" alt=""></p><p>模式敏感的操作全部放在上面的方法里面。如果不在上面的方法里面，可能不能正常响应当前的模式变化。</p><h2 id="Avoid-Expensive-Tasks-During-Appearance-Transitions"><a href="#Avoid-Expensive-Tasks-During-Appearance-Transitions" class="headerlink" title="Avoid Expensive Tasks During Appearance Transitions"></a>Avoid Expensive Tasks During Appearance Transitions</h2><p>避免模式过渡时完成复杂任务。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://developer.apple.com/documentation/appkit/supporting_dark_mode_in_your_interface" rel="external nofollow noopener noreferrer" target="_blank">Supporting Dark Mode in Your Interface</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Update colors, images, and behaviors so that your app adapts automatically when Dark Mode is active.&lt;/p&gt;
&lt;p&gt;当黑夜模式激活后，更新颜色、图片、行为，使app自动适应黑夜模式。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="黑夜模式" scheme="http://yoursite.com/categories/IOS/%E9%BB%91%E5%A4%9C%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="dark" scheme="http://yoursite.com/tags/dark/"/>
    
  </entry>
  
  <entry>
    <title>第一章 基本知识</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/wiki/数学知识/概率论和数理统计/第一章 概率论的基本概念/</id>
    <published>2019-08-13T02:07:12.000Z</published>
    <updated>2019-08-22T02:19:08.698Z</updated>
    
    <content type="html"><![CDATA[<p>随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象</p><a id="more"></a><h2 id="随机实验"><a href="#随机实验" class="headerlink" title="随机实验"></a>随机实验</h2><ol><li>可以在相同的条件下重复地进行</li><li>每次实验的可能结果不止一个，并且能事先明确实验的所有可能结果</li><li>进行一次实验前不能确定哪一个结果会出现 </li></ol><p>我们将具有上面三个特点的实验称为随机实验</p><h2 id="样本空间、-随机事件"><a href="#样本空间、-随机事件" class="headerlink" title="样本空间、 随机事件"></a>样本空间、 随机事件</h2><h3 id="一-样本空间"><a href="#一-样本空间" class="headerlink" title="一 样本空间"></a>一 样本空间</h3><p>我们将随机实验E的所有可能结果组成的集合称为E的<strong>样本空间</strong>。记作S 样本空间的每个结果称为<strong>样本点</strong></p><h3 id="二-随机事件"><a href="#二-随机事件" class="headerlink" title="二 随机事件"></a>二 随机事件</h3><p>一般，我们称实验E的样本空间S的子集为E 的<strong>随机事件</strong>，当且仅当这一子集中的样本点出现时，称这一事件发生。</p><p>由一个样本点组成的单点集，称为<strong>基本事件</strong>  </p><p>每个实验中它总是发生的，S称为<strong>必然事件</strong> 。空集是<strong>不可能事件</strong></p><h3 id="事件间的关系和运算"><a href="#事件间的关系和运算" class="headerlink" title="事件间的关系和运算"></a>事件间的关系和运算</h3><ol><li>若$A\subset{B}$ 事件A发生必然导致事件B发生。</li><li>$A\cup{B}$ 和事件，当且仅当A、B至少有衣蛾发生时，事件A\cup{B}$ 发生</li><li>事件$A\cap{B}$积事件，当且仅当A、B同时发生时，事件$A\cap{B}$发生。</li><li>差事件，A-B 当且仅当A发生，B不发生时，事件A-B发生。</li><li>若$A\cap{B}=\emptyset$ ,则称事件A与时间B互不相容或互斥。事件A、B不能同时发生。</li><li>若$A\cup{B}=s$ 且$A\cap{B}=\emptyset$则称事件A与时间B互为逆事件。或对立事件</li></ol><h2 id="频率和概率"><a href="#频率和概率" class="headerlink" title="频率和概率"></a>频率和概率</h2><p>定义： 在相同条件下，进行n次试验，在这n次试验中，事件A发生的次数称为事件A的频数，比值$n_a/n$称为事件A发生的频率。并记作$f_n（A）$</p><p>概率的性质：</p><ol><li>P($\emptyset$)=0</li><li>有限可加性 ，$若A_1，A_2,… A_n$是两两互不相容的事件，则有P（$A_1\cup{A_2}…\cap{A_n}$） = $P(A_1)+P(A_2)+…+P(A_n)$</li><li>设A、B是两个事件，若$A\subset{B}$,则：$$P(B-A)=P(B)-P(A)$$</li><li>对任一事件A P(A)&lt;=1</li><li>逆事件概率，对于任一事件A有$ P(\overline A) $= 1- P(A)</li><li>加法公式： 对任意两事件 A、B 有，$ P(A\cup B) = P(A)+P(B)-P(AB)$</li></ol><h2 id="等可能概型（古典概型）"><a href="#等可能概型（古典概型）" class="headerlink" title="等可能概型（古典概型）"></a>等可能概型（古典概型）</h2><p>若事件A包含k个基本事件 ，则<br>$$P(A)=\frac {k} {n} = \frac {A包含的基本事件数} {S中基本事件的总数}$$</p><p>$$\left ( \frac {N}{n} \right ) = \frac {N(N-1)…(N-n+1)} {n!} \text N<br>中取n个的总数$$</p><p>$$A_N^n = N(N-1)…(N-n+1) \text 也是N中取n个的总数 $$</p><h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>设A，B是两个事件，且P（A） &gt; 0 称 </p><p>$$ P(B|A)=\frac{P(AB)}{P(A)}$$<br>为在事件A发生的条件下，事件B发生的条件概率。</p><p><strong>乘法定理</strong>： $P(AB)=P(B|A)P(A)$</p><p><strong>全概率公式</strong>： 设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，且$P(B_i)$&gt;0,则<br>$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+…+P(A|B_n)P(B_n)$$<br>称为全概率公式。</p><p><strong>个人理解</strong>：A和每个划分的积事件之和。</p><p><strong>贝叶斯公式</strong>：设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，则<br>$$P(B_i|A)=\frac{P(A|B_i)P(B)}{\sum_{j=1}^{n}{P(A|B_j)P(B_j)}}$$<br>称为贝叶斯公式</p><p>当n=2时，全概率公式和贝叶斯公式分别为：</p><p>$$P(A)=P(A|B)P(B)+P(A|\overline B)P(\overline B)$$</p><p>$$P(B|A)=\frac{P(AB)}{P(A)}=\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\overline B)P(\overline B)}$$</p><h2 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h2><p>定义： 设A，B是两个事件，如果满足等式：<br>$$P(AB)=P(A)P(B)$$<br>则称事件AB是相互独立，简称A，B独立</p><p>定理1： 设A，B是两个事件，若A，B相互独立，则P(B|A) = P(B),反之亦然。</p><p>定理2：如事件A与B相互独立，则下列各事件也相互独立：<br>$$A \text{与} \overline{B} , \overline A 与B，\overline A与\overline B$$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="概率论和数理统计" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E6%A6%82%E7%8E%87%E8%AE%BA%E5%92%8C%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="概率论" scheme="http://yoursite.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第五章 相似矩阵</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/%E7%9B%B8%E4%BC%BC%E7%9F%A9%E9%98%B5/"/>
    <id>http://yoursite.com/wiki/数学知识/线性代数/相似矩阵/</id>
    <published>2019-08-11T02:07:12.000Z</published>
    <updated>2019-08-13T06:19:02.194Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵的特征值与特征向量是线性代数中十分重要的内容，是矩阵和向量理论深层次上的发展.本章主要讨论矩阵的特征值与特征向量的概念、性质与计算及矩阵的相似对角化问题，特别是对称矩阵的正交相似对角化问题.</p><a id="more"></a><h2 id="向量的內积和正交性"><a href="#向量的內积和正交性" class="headerlink" title="向量的內积和正交性"></a>向量的內积和正交性</h2><h3 id="向量的內积"><a href="#向量的內积" class="headerlink" title="向量的內积"></a>向量的內积</h3><p>$$[x，y]=x_1y_2+x_2y_2+…+x_ny_n.$$</p><p><strong>内积的运算规律</strong>（其中x，y，z为n维向量，λ为实数）：</p><ol><li>[x，y]=[y，x]；</li><li>[λx，y]=λ[x，y]；</li><li>[x+y，z]=[x，z]+[y，z]；</li><li>[x，x]≥0，当且仅当x=0时，[x，x]=0；</li><li>柯西一施瓦茨（CauchySchwarz）不等式：$[x，y]^2≤[x，x][y，y]$，当且仅当x与y线性相关时等号成立.</li></ol><h3 id="向量的长度"><a href="#向量的长度" class="headerlink" title="向量的长度"></a>向量的长度</h3><p>定义2　设x是n维向量，称$\sqrt{[x,x]}$为向量x的长度（或范数），记作‖x‖.即若x＝（x1，x2，…，xn）T，则有<br>$$||x||=\sqrt{[x,x]}=\sqrt{x_1^2+x_2^2+x_n^2}$$</p><p>向量的长度具有以下<strong>性质</strong>：</p><ol><li>非负性　‖x‖≥0，当且仅当x=0时等号成立；</li><li>齐次性　‖λx‖=|λ|‖x‖，λ为任意实数；</li><li>三角不等式　‖x+y‖≤‖x‖+‖y‖.</li></ol><p>若‖x‖=1，则称x为单位向量.</p><p>设a为任意非零向量，则向量$\frac{1}{||a||}a$为单位向量，</p><p>对于一个非零向量，用a的长度‖a‖去除a，即得到一个单位向量，这个过程称为将a单位化.</p><h3 id="向量的夹角与正交向量组"><a href="#向量的夹角与正交向量组" class="headerlink" title="向量的夹角与正交向量组"></a>向量的夹角与正交向量组</h3><p><strong>定义3</strong>　设向量x与y均是n维非零向量，称</p><p>$$\theta=arccos\frac{[x,y]}{||x|| ||y||}$$<br>为向量x与y的夹角.<strong>当[x，y]=0时，称向量x与y正交</strong>.显然，零向量与任何向量都正交.两两正交的非零向量组，称为正交向量组.</p><p><strong>定理1</strong>　若向量组$a_1，a_2，…，a_m$是正交向量组，则$a_1，a_2，…，a_m$线性无关.</p><p>定义4　设n维向量组$e_1，e_2，…，e_r$是向量空间V的一个基，若$e_1，e_2，…，e_r$两两<strong>正交</strong>，且都是<strong>单位</strong>向量，则称$e_1，e_2，…，e_r$是V的一个规范正交基</p><p>规范正交化的步骤  :</p><p><img src="/wiki/数学知识/线性代数/相似矩阵/1.png" alt="规范正交化的步骤 "></p><h3 id="正交矩阵与正交变换"><a href="#正交矩阵与正交变换" class="headerlink" title="正交矩阵与正交变换"></a>正交矩阵与正交变换</h3><p><img src="/wiki/数学知识/线性代数/相似矩阵/2.png" alt="正交矩阵的定义 "></p><p><strong>性质：</strong></p><p><img src="/wiki/数学知识/线性代数/相似矩阵/3.png" alt="正交矩阵的定义 "></p><h2 id="方阵的特征值与特征向量"><a href="#方阵的特征值与特征向量" class="headerlink" title="方阵的特征值与特征向量"></a>方阵的特征值与特征向量</h2><h3 id="特征值和特征向量的概念"><a href="#特征值和特征向量的概念" class="headerlink" title="特征值和特征向量的概念"></a>特征值和特征向量的概念</h3><p>定义7　设A为n阶方阵，若存在数λ和非零n维列向量x，使得$$Ax=λx（5.1）成立，$$则称数λ为方阵A的特征值，非零向量x称为A的对应于特征值λ的特征向量.式（5.1）也可写成$$（A-λE）x=0，（5.2）$$这是n个未知数n个方程的齐次线性方程组</p><p>求n阶方阵A的特征值和特征向量的步骤：</p><ol><li>第一步：求出A的特征多项式|A-λE|；</li><li>第二步：求解特征方程|A-λE|=0，得到A的n个特征值λ1，λ2，…λn；</li><li>第三步：对于A的每一个特征值λi，求出齐次线性方程组（A-λiE）x=0的一个基础解系ξ1，ξ2，…ξs，则A的对应于特征值λi的全部特征向量为pi=c1ξ1+c2ξ2+…+csξs，其中，c1，c2，…，cs为不全为零的任意实数.</li></ol><h3 id="方阵的特征值和特征向量的性质"><a href="#方阵的特征值和特征向量的性质" class="headerlink" title="方阵的特征值和特征向量的性质"></a>方阵的特征值和特征向量的性质</h3><p><strong>性质1</strong>　一个特征向量只能属于一个特征值（相同的看成一个）</p><p><strong>性质2　</strong>若λ是方阵A的特征值，x是属于λ的特征向量，则</p><ol><li>μλ是μA的特征值，x是属于μλ的特征向量（μ是常数）：</li><li>λk是Ak的特征值，x是属于λk的特征向量（k是正整数）；</li><li>当|A|≠0时λ1是A1的特征值，λ1|A|为$A*$的特征值，且x为对应的特征向量.</li><li>φ（λ）是φ（A）的特征值（其中φ（λ）$=a_0+a_1λ+…+a_mλ^m$是λ的多项式，φ（A）=$a_0E+a_1A+…+a_mA^m$是方阵A的多项式）</li></ol><p><strong>性质3</strong>　A与AT有相同的特征值</p><p><strong>性质5</strong>　设λ1，λ2，…，λm是方阵A的m个特征值，p1，p2，…，pm是依次与之对应的特征向量.若λ1，λ2，…，λm互不相等，则p1，p2，…，pm线性无关.</p><h2 id="相似矩阵"><a href="#相似矩阵" class="headerlink" title="相似矩阵"></a>相似矩阵</h2><h3 id="相似矩阵的定义"><a href="#相似矩阵的定义" class="headerlink" title="相似矩阵的定义"></a>相似矩阵的定义</h3><p>定义8　设A，B都是n阶方阵，若存在一个n阶可逆矩阵P，使$$P^1AP=B$$</p><p>则称A与B是相似的，或称B是A的相似矩阵.称$P^1AP$为对A作相似变换，可逆矩阵P称为把A变成B的相似变换矩阵</p><p><strong>性质1</strong>　若A与B相似，则R（A）=R（B），且|A|=|B|.</p><p><strong>性质2</strong>　若A可逆，且A与B相似，则B可逆，且A1与B1也相似.</p><p><strong>性质3</strong>　若A与B相似，则$A^k$与$B^k$（k为整数）相似.</p><p><strong>定理3</strong>　若n阶方阵A与B相似，则A与B的特征多项式相同，从而A与B的特征值也相同.</p><p><strong>推论</strong>　若n阶方阵A与对角矩阵相似，则λ1，λ2，…，λn是A的n个特征值.</p><h3 id="矩阵的对角化"><a href="#矩阵的对角化" class="headerlink" title="矩阵的对角化"></a>矩阵的对角化</h3><p>定理4　n阶方阵A与对角矩阵相似的充分必要条件是A有n个线性无关的特征向量.</p><p>推论　若n阶方阵A有n个互不相同的特征值，则A与对角矩阵相似.</p><p>定理5　若对于n阶方阵A的任一k重特征值λ，有R（A-λE）=n-k，则A可对角化.</p><h3 id="实对称矩阵的对角化"><a href="#实对称矩阵的对角化" class="headerlink" title="实对称矩阵的对角化"></a>实对称矩阵的对角化</h3><p>定理7 实对称矩阵不同特征值对象特征向量正交  </p><p>定理8　A为n阶实对称矩阵，则必存在正交矩阵P，使得$$P^1AP=P^TAP=A$$，其中A是以A的n个特征值未对角线元素的对角矩阵</p><p>推论： 设A为n阶实对称矩阵，λ是A的k重特征值，则 R（A-λE）= n-k，从而对应特征值λ恰好有k个线性无关的特征向量</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;矩阵的特征值与特征向量是线性代数中十分重要的内容，是矩阵和向量理论深层次上的发展.本章主要讨论矩阵的特征值与特征向量的概念、性质与计算及矩阵的相似对角化问题，特别是对称矩阵的正交相似对角化问题.&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第四章 向量组的线性相关性</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/vector/"/>
    <id>http://yoursite.com/wiki/数学知识/线性代数/vector/</id>
    <published>2019-08-11T02:07:12.000Z</published>
    <updated>2019-08-13T03:06:16.478Z</updated>
    
    <content type="html"><![CDATA[<p>本章讨论向量组的线性相关性，引入最大无关组和向量组的秩的概念。</p><a id="more"></a><h2 id="向量组及其线性组合"><a href="#向量组及其线性组合" class="headerlink" title="向量组及其线性组合"></a>向量组及其线性组合</h2><p><strong>定义2</strong>　设有向量组$A:a_1，a_2，…，a_m$及任意给定的m个实数$k_1，k_2，…，k_m$，表达式：</p><p>$$k_1a_1+k_2a_2+…+k_ma_m$$</p><p>称为向量组A的一个<strong>线性组合</strong>，$k_1，k_2，…，k_m$，称为这个线性组合的系数.</p><p>若向量b等于向量组A的某一线性组合，即存在数$λ_1，λ_2，…，λ_m$，使$$b=λ_1a_1+λ_2a_2+…+λ_ma_m$$，则称<strong>向量b可由向量组A线性表示</strong>.</p><p><strong>定理1</strong>　向量b可由向量组A:a1，a2，…，am线性表示的充分必要条件是矩阵A=（a1，a2，…，am）的秩等于矩阵B=（a1，a2，…，am，b）的秩.</p><p><strong>定义3</strong>　若向量组B:b1，b2，…，bl的每个向量都可由向量组A:a1，a2，…，am线性表示，则称向量组B可由向量组A线性表示；若向量组A与向量组B可相互线性表示，则称向量组A与B等价.</p><p><strong>定理2</strong>　向量组$B:b_1，b_2，…，b_l$可由向量组$A:a_1，a_2，…a_m$线性表示的充分必要条件是矩阵A＝$（a_1，a_2，…，a_m）$的秩等于矩阵$（A，B）=（a_1，…，a_m，b_1，…b_l）$的秩，即$$R（A）=R（A，B）$$</p><p><strong>推论　</strong>向量组$A:a_1，a_2，…，a_m$与向量组$B:b_1，b_2，…，b_l$等价的充分必要条件是$$R（A）=R（B）=R（A，B）$$，其中，A和B分别是向量组A和向量组B构成的矩阵.</p><p><strong>定理3</strong>　设$A=（a_1，a_2，…，a_m），B=（b_1，b_2，…，b_l），$若向量组$B：b_1，b_2，…，b_l$可由向量组$A:a_1，a_2，….a_m$线性表示，则$$R（B）≤R（A）$$.</p><h2 id="向量组的线性相关性"><a href="#向量组的线性相关性" class="headerlink" title="向量组的线性相关性"></a>向量组的线性相关性</h2><p>定义4　给定向量组$A:a_1，a_2，…，a_m$，若存在不全为零的一组数$k_1，k_2，…，k_m$，使$$k_1a_1+k_2a_2+…+k_ma_m=0$$，则称向量组A是线性相关的，否则称向量组A线性无关.根据相关性的定义，易得如下结论：</p><ol><li>对于只有一个向量a的向量组，当a=0时线性相关，当a≠0时线性无关：</li><li>含两个向量a1，a2的向量组线性相关a1，a2的分量对应成比例；</li><li>含有零向量的向量组一定线性相关.</li></ol><p>向量组线性相关概念也可移用于线性方程组，当方程组中某个方程是其余方程的线性组合时，这个方程就是多余的，这时称方程组是线性相关的；当方程组中没有多余方程时，就称方程组是线性无关的.设$A=（a_1，a_2，…，a_m）$，则向量组$A:a_1，a_2，…，a_m$线性相关，就是齐次线性方程组</p><p>$$x_1a_1+x_2a_2+…+x_ma_m=0$$，即Ax=0有非零解.由第3章定理7，可得</p><p><strong>定理4　</strong>向量组$A:a_1，a_2，…，a_m$线性相关的充分必要条件是矩阵$A=（a_1，a_2，…，a_m）$的秩R（A）&lt;m；线性无关的充分必要条件是R（A）=m（m为向量组A中向量的个数）.</p><p><strong>推论</strong>　m个n维列向量构成的向量组$A:a_1，a_2，….a_m$，当m&gt;n时，一定线性相关.</p><p><strong>定理5　</strong></p><ol><li>向量组$A:a_1，a_2.…，a_m（m≥2）$线性相关的充分必要条件是向量组中至少有一个向量可由其余m1个向量线性表示.</li><li>若向量组$A:a_1.a_2，…，a_m$线性相关，则向量组$B:a_1，a_2，…，a_m，a_{m+1}$也线性相关；反之，若向量组$B:a_1，a_2，…，a_m，a_{m+1}$，线性无关，则向量组$A:a_1，a_2，…，a_m$也线性无关.</li><li>设向量组$A:a_1，a_2，…a_m$线性无关，而向量组$B:a_1，a_2，…，a_m，b$线性相关，则向量b必能由向量组A线性表示，且表示唯一</li></ol><h2 id="向量组的秩"><a href="#向量组的秩" class="headerlink" title="向量组的秩"></a>向量组的秩</h2><p><strong>定义5</strong>　给定向量组A，若在A中能选出一个含r个向量的部分组$A0:a_1，a_2，…，a_r$，满足：</p><ol><li>向量组A0线性无关；</li><li>向量组A中任意r+l个向量（如果A中有r+l个向量的话）都线性相关，则称向量组A0为向量组A的一个最大线性无关组，简称为最大无关组.最大无关组A0中所含向量个数：称为向量组A的秩.向量组$A:a_1，a_2，…，a_m$的秩，记作RA或$R（a_1，a_2，…，a_m）$</li></ol><p>只含有零向量的向量组没有最大无关组，规定它的秩为0.</p><p>由定义可知：</p><ol><li>若向量组A线性无关，则A的最大无关组就是A本身，它的秩就等于它所含向量的个数；</li><li>向量组A线性相关的充分必要条件是向量组A的秩小于所含向量的个数；</li><li>向量组A与它的最大无关组A0等价.因为A0是A的一个部分组，故A0总能由A线性表示；在A中任取一向量a，则有$a_1，a_2，…，a_r$，a这r+1个向量线性相关，而a1.a2，…，ar，线性无关，由4.2节定理5可知a能由$a_1，a_2，…，a_r$线性表示，即A能由A0线性表示.</li></ol><p>定理6　矩阵的秩等于它的列向量组的秩，也等于它的行向量组的秩.</p><h2 id="线性方程组的解结构"><a href="#线性方程组的解结构" class="headerlink" title="线性方程组的解结构"></a>线性方程组的解结构</h2><h3 id="齐次线性方程组的解结构"><a href="#齐次线性方程组的解结构" class="headerlink" title="齐次线性方程组的解结构"></a>齐次线性方程组的解结构</h3><p><strong>性质1　</strong>若x=ξ1，x=ξ2为Ax=0的解，则x=ξ1+ξ2也是Ax=0的解.</p><p><strong>性质2</strong>　若X=ξ1，为Ax=0的解，k为实数，则x=kξ1，也是Ax=0的解.</p><p>定义6　若向量$ξ_1，ξ_2，…，ξ_t$为齐次线性方程组Ax=0的解向量，且满足： </p><ol><li>$ξ_1，ξ_2.…，ξ_t$线性无关；</li><li>Ax=0的所有解均可由$ξ_1，ξ_2，…，ξ_t$线性表示，则称$ξ_1，ξ_2，…，ξ_t$为方程组Ax=0的一个基础解系，</li></ol><p>称$$x=k_1ξ_1+k_2ξ_2+…+k_tξ_t，$$（其中k1，k2，…，kt为任意实数）为方程组Ax=0的通解.若把方程组Ax=0的所有解组成一个向量组S，则基础解系$ξ_1，ξ_2，…，ξ_t$为向量组S的一个最大无关组.</p><p><strong>定理7</strong>　设A为m×n矩阵，若R（A）=r，则n元齐次线性方程组Ax=0的解集S的秩$R_S=n-r$.</p><h3 id="非齐次线性方程组的解结构"><a href="#非齐次线性方程组的解结构" class="headerlink" title="非齐次线性方程组的解结构"></a>非齐次线性方程组的解结构</h3><p><strong>性质3</strong>　若x=η1，x=η2为Ax=b的解，则x=η1η2为对应齐次线性方程组Ax=0的解.</p><p><strong>性质4</strong>　设x=η是方程Ax=b的解，x=ξ是方程Ax=0的解，则x=ξ+η仍是方程Ax=b的解.</p><p>由性质3可知，若求得方程Ax=b的一个特解$η^{*}$，则方程Ax=b的任一解都可表示为$$x=ξ+η*.（其中ξ为方程Ax=0的解）$$若方程Ax=0的通解为<br>$$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}$$，则方程Ax=b的任一解都可表示为</p><p>$$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}+η^*$$.由性质4可知，方程Ax=b的通解为<br>$$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}+η^*$$，其中，$k_1，k_2，…，k_{n-r}$为任意实数，$ξ_1，ξ_2，…，ξ_{n-r}$是方程Ax=0的基础解系.</p><h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><p><strong>定义7</strong>　设V是非空的n维向量的集合，若集合V对向量的加法及向量的数乘这两种运算封闭，则称集合V是一个向量空间.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本章讨论向量组的线性相关性，引入最大无关组和向量组的秩的概念。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第三章 矩阵的初等变换和线性方程组</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/matrixTransformation/"/>
    <id>http://yoursite.com/wiki/数学知识/线性代数/matrixTransformation/</id>
    <published>2019-08-11T02:07:12.000Z</published>
    <updated>2019-08-12T07:11:26.487Z</updated>
    
    <content type="html"><![CDATA[<p>学习线性代数的第三章。</p><a id="more"></a><h2 id="矩阵初等变换"><a href="#矩阵初等变换" class="headerlink" title="矩阵初等变换"></a>矩阵初等变换</h2><p>定义1　下面3种变换称为矩阵的初等行变换：</p><ol><li>对调矩阵的两行（对调i，j两行，记作ri↔rj）；</li><li>将某一行所有元素乘以数k≠0（第i行乘k，记作ri×k）；</li><li>把某一行所有元素的k倍加到另一行对应元素上去（第j行的k倍加到第i行上，记作ri+krj）.</li></ol><p><strong>矩阵的初等行变换与初等列变换统称为矩阵的初等变换.</strong></p><p>这里，矩阵B1与B2都称为<strong>行阶梯形矩阵</strong>，其特点是：可画一条一行为一个台阶的阶梯线，线的下方元素全为0，台阶数就是非零行的行数，阶梯线的竖线（每段竖线的长度为一行）后面的第一个元素为非零元，也就是非零行的第一个非零元.</p><p>行阶梯形矩阵B2还称为行<strong>最简形矩阵</strong>，其特点是：每个非零行的第一个非零元为1，且这些非零元所在的列的其他元素都为0.</p><p><strong>标准形</strong>，其特点是：左上角是一个单位矩阵，其余元素全为</p><p>任何矩阵A都有唯一的标准形.等价矩阵有相同的标准形.即有相同标准形的矩阵是等价的.因此所有与A等价的矩阵组成一个集合，称为一个等价类，标准形F是这个等价类中形式最简单的矩阵.</p><h2 id="初等矩阵"><a href="#初等矩阵" class="headerlink" title="初等矩阵"></a>初等矩阵</h2><p>定义2　由单位矩阵E经过一次初等变换得到的方阵称为初等矩阵.</p><p>定理1　设A是一个m×n矩阵，则对A施行一次初等行变换，相当于用相应的m阶初等矩阵左乘A；对A施行一次初等列变换，相当于用相应的n阶初等矩阵右乘A.</p><p>定理2　方阵A可逆的充分必要条件是存在有限个初等矩阵P1，P2，…，Ps，使A=P1P2…Ps.</p><p>推论4　对于n阶矩阵A与n×s矩阵B，若，则A可逆，且X=A1B.特别地，对于n个未知数n个方程的线性方程组Ax=b，若增广矩阵，则A可逆，且x=A1b为方程组的唯一解.</p><h2 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩"></a>矩阵的秩</h2><h3 id="矩阵秩的定义"><a href="#矩阵秩的定义" class="headerlink" title="矩阵秩的定义"></a>矩阵秩的定义</h3><p>定义4　设在m×n矩阵A中有一个不等于0的r阶子式D，且所有的r+1阶子式（如果存在的话）全等于0，则D称为矩阵A的最高阶非零子式.数r称为矩阵A的秩，记作R（A）=r.我们规定零矩阵的秩为0.</p><p>注意：</p><ol><li>由行列式的展开法则可知，在A中，当所有r+l阶子式全等于0时，所有高于r+l阶的子式也全等于0，因此把r阶非零子式称为A的最高阶非零子式，而A的秩R（A）就是A中不等于0的子式的最高阶数. </li><li>若矩阵A中存在某个s阶子式不等于0，则R（A）≥s；若所有t阶子式全为0，则R（A）&lt;t.</li><li>对任意m×n矩阵A，有O≤R（A）≤min{m，n}.</li><li>对任意m×n矩阵A，有R（A）=$R(A^T)$. </li><li>对n阶方阵A，若|A|≠0，则R（A）=n，此时方阵A可逆，所以可逆矩阵又称满秩矩阵；若|A|=0，则R（A）&lt;n，此时方阵A不可逆，因此不可逆矩阵又称降秩矩阵（或奇异矩阵）.</li></ol><h3 id="矩阵秩与矩阵的初等变换"><a href="#矩阵秩与矩阵的初等变换" class="headerlink" title="矩阵秩与矩阵的初等变换"></a>矩阵秩与矩阵的初等变换</h3><p>定理3　若A～B，则R（A）=R（B）.</p><p>由定理3可知，要求矩阵的秩，只要把矩阵用初等行变换化为行阶梯形矩阵，则行阶梯形矩阵中，非零行的行数即为该矩阵的秩.</p><h3 id="矩阵的秩的性质"><a href="#矩阵的秩的性质" class="headerlink" title="矩阵的秩的性质"></a>矩阵的秩的性质</h3><ol><li>性质1　0≤R（Am×n）≤min{m，n}，且R（A）=0的充分必要条件是A=O.</li><li>性质2　R（A）=R（$A^T$）.</li><li>性质3　R（A）=R（kA）（k≠0）.</li><li>性质4　若A～B，则R（A）=R（B）.</li><li>性质5　若P，Q可逆，则R（PAQ）=R（A）.</li><li>性质6　max{R（A），R（B）}≤R（A，B）≤R（A）+R（B），特别地，当B=b为列向量时，有R（A）≤R（A，b）≤R（A）+1.</li><li>性质7　R（A±B）≤R（A）+R（B）</li><li>性质8　R（AB）≤min{R（A），R（B）}.</li><li>性质9　若$A_{m×n}B_{n×l}=O$，则R（A）+R（B）≤n.</li></ol><h2 id="线性方程组的解"><a href="#线性方程组的解" class="headerlink" title="线性方程组的解"></a>线性方程组的解</h2><p>消元法就是<strong>增广矩阵</strong> 变换的过程。</p><p>定理4　n元非齐次线性方程组Ax=b，</p><ol><li>无解的充分必要条件是R（A）&lt;R（A，b）；</li><li>有唯一解的充分必要条件是R（A）=R（A，b）=n；</li><li>有无穷多解的充分必要条件是R（A）=R（A，b）&lt;n.</li></ol><p>由定理4，可知解线性方程组Ax=b时，只需对增广矩阵B=（A，b）施行初等行变换化为行阶梯形矩阵，判别线性方程组是否有解；在有解时，继续对增广矩阵施行初等行变换化为行最简形矩阵，而后求出线性方程组的解.</p><p>定理5　矩阵方程AX=B有解的充分必要条件是R（A）=R（A，B）.</p><p>齐次线性方程组有非零解的充分必要条件：</p><p>定理7　n元齐次线性方程组Ax=0有非零解的充分必要条件是系数矩阵A的秩R（A）&lt;n；而只有零解得充分必要条件是R（A）=n.</p><p>推论1　若齐次线性方程组Ax=0中方程的个数小于未知数的个数，则它必有非零解.</p><p>推论2　n个方程n个未知数的齐次线性方程组Ax=0有非零解的充分必要条件是系数行列式|A|=0；而它只有零解的充分必要条件是系数行列式|A|≠0.定理7还可以推广到矩阵方程情形中.</p><p>定理8　矩阵方程$A_{m×n}X_{n×l}=O_{m×l}$只有零解的充分必要条件是R（A）=n.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习线性代数的第三章。&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第一章行列式</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/det/"/>
    <id>http://yoursite.com/wiki/数学知识/线性代数/det/</id>
    <published>2019-08-09T04:07:12.000Z</published>
    <updated>2019-08-09T08:45:20.424Z</updated>
    
    <content type="html"><![CDATA[<p>第一章，行列式学习记录</p><a id="more"></a><h2 id="1、二三阶行列式"><a href="#1、二三阶行列式" class="headerlink" title="1、二三阶行列式"></a>1、二三阶行列式</h2><p>定理1 ： 一个排列进行一次对换，排列改变奇偶性一次</p><h3 id="n阶行列式"><a href="#n阶行列式" class="headerlink" title="n阶行列式"></a>n阶行列式</h3><p>在三阶行列式中,行标固定为123，列表为123的全排列，有6中情况。所以，三阶行列式的定义如下： $$ \sum (-1)^t a_{1p_1} a_{2p_2} a_{3p_3}$$</p><p>定理2： n阶行列式也可以定义为：</p><p> $$ D = \sum (-1)^τ a_{p_11} a_{p_22} … a_{p_nn}  \text    ，其中τ为行排列p_1p_2…p_n 的逆序数$$</p><p> 定理3 ：  n阶行列式也可以定义为：</p><p> $$ D = \sum (-1)^{τ_1+τ_2} a_{p_1q_1} a_{p_2q_2} … a_{p_nq_n}  \text    ，其中τ_1为行排列p_1p_2…p_n 的逆序数, τ_2为列排列的逆序数$$</p><h2 id="2、行列式的性质"><a href="#2、行列式的性质" class="headerlink" title="2、行列式的性质"></a>2、行列式的性质</h2><p>性质1： 行列式和它的转置行列式相等，即$$D = D^T$$</p><p>性质2： 互换行列式的两行，行列式变号</p><p>推论： 若行列式有两行完全相同，则该行列式等于0</p><p>性质3： 行列式的某一行的各元素乘以同一数k，等于用数乘此行列式。</p><p>性质4： 若行列式中有两行的元素对应成比例，则该行列式等于0</p><p>性质5：若行列式的某一行的元素都是两数之和，  等于两个行列式的和</p><p>性质6： 把行列式的某一行的各元素乘以同一个数k后，加到另一行对应的元素上去，行列式的值不变。</p><p>把行列式化为上三角行列式的步骤为：</p><ol><li>若第一列第一个元素为0，先将第一行与其他行交换，使得第一列第一个元素不为0，然后把第一行分别乘以适当的数加到其他各行，使得第一列除第一个元素外，其余元素全为0；</li><li>用同样的方法处理除去第一行和第一列后余下的低一阶的行列式，如此反复下去，直到使它变为上三角行列式，这时主对角线上元素的乘积就是所求行列式的值.</li></ol><h2 id="3、-行列式按行（列）展开"><a href="#3、-行列式按行（列）展开" class="headerlink" title="3、 行列式按行（列）展开"></a>3、 行列式按行（列）展开</h2><p>定义2　在n阶行列式中，把元素$a_{ij}$所在的第i行和第j列划去，余下的n-1阶行列式（依原来的排法），称为元素$a_{ij}$的余子式，记作$M_{ij}$  ；记$$A_{ij}= (-1)^{i+j}M_{ij}，$$称$A_{ij}$为元素$a_{ij}$的代数余子式.</p><p>引理　一个n阶行列式D，若第i行所有元素除$a_{ij}$为全为零，则该行列式等于$a_{ij}$与它的代数余子式的乘积，即$$D=a_{ij}A_{ij}$$</p><p>定理4　行列式等于它的任一行（列）的各元素与其对应的代数余子式的乘积之和，即<br>$$D=a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}（i=1，2，…，n），$$<br>或<br>$$D=a_{1j}A_{1j}+a_{2j}A_{2j}＋…＋a_{nj}A_{nj}（j=1，2，…，n）.$$</p><p>下面是范德蒙行列式：<br>$$<br>D_n =<br>\begin{vmatrix}<br>1 &amp; 1 &amp; \cdots &amp; 1 \\<br>x_1 &amp; x_2 &amp; \cdots  &amp; x_n \\<br>x_1^2 &amp; x_2^2 &amp; \cdots  &amp; x_n^2 \\<br>\vdots &amp; \vdots &amp;  &amp; \vdots \\<br>x_1^{n-1} &amp; x_2^{n-1} &amp; \cdots &amp; x_n^{n-1}<br>\end{vmatrix}<br>=\prod_{n\ge{i}\gt{j}\ge{i}}{(x_i - x_j)}<br>$$</p><p>下面这个公式不明白，但是后面会使用</p><p>$$  \sum_{k=1}^n{a_{ik}A_{jk}} = D\delta_{ij} =<br>\begin{cases}<br>D,  &amp;当 i=j \\<br>0,  &amp; 当 i \ne j<br>\end{cases}  $$</p><p>其中</p><p>$$<br>\delta_{ij} =<br>\begin{cases}<br>1,  &amp;当 i=j \\<br>0,  &amp; 当 i \ne j<br>\end{cases}<br> $$</p><h2 id="4、-克莱姆法则（Carmer）"><a href="#4、-克莱姆法则（Carmer）" class="headerlink" title="4、 克莱姆法则（Carmer）"></a>4、 克莱姆法则（Carmer）</h2><p>定理5 ： 线性方程组的系数行列式不为0.则线性方程组有解。</p><p>$$ x_1 = \frac{D_1}{D}  , x_2 = \frac{D_2}{D}…. $$<br>其中，$D_j$（j=1，2，…，n）是将D中的第j列元素换成方程组右端的常数项所得的行列式.</p><p>使用克莱姆法则必须注意：</p><ol><li>未知量的个数与方程的个数要相等；</li><li>系数行列式不为零.</li></ol><p>常数项全为0的方程称为齐次线性方程。</p><p>$$<br>\left \{<br>\begin{array}{c}<br>a_{11}x_{1}+a_{12}x_{2} + \cdots + a_{1n}x_{n} = 0 \\<br>a_{21}x_{1}+a_{22}x_{2} + \cdots + a_{2n}x_{n} = 0 \\<br>………………………….. \\<br>a_{n1}x_{1}+a_{n2}x_{2} + \cdots + a_{nn}x_{n}  = 0<br>\end{array}<br>\right.<br>$$</p><p>定理6　如果齐次线性方程组的系数行列式D≠0，则齐次线性方程组只有零解.</p><p>定理6′　如果齐次线性方程组有非零解，则它的系数行列式必为零.</p><p>定理6′　说明系数行列式D=0是齐次线性方程组有非零解的必要条件.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一章，行列式学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>第二章矩阵</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/matrix/"/>
    <id>http://yoursite.com/wiki/数学知识/线性代数/matrix/</id>
    <published>2019-08-08T04:07:12.000Z</published>
    <updated>2019-08-13T06:47:42.591Z</updated>
    
    <content type="html"><![CDATA[<p>矩阵学习记录</p><a id="more"></a><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>定义： 矩阵可以记作：$A=(a_{ij})_{m×s}$，也可以记作 $A_{m×n}$</p><ol><li>只有一行元素，这样的矩阵称为行矩阵,A=$（a_1，a_2，…，a_n）$.</li><li>若矩阵只有一列元素，这样的矩阵称为列矩阵</li><li>若n阶方阵，主对角线以外的元素全为0，这样的矩阵称为对角阵，A=$diag（λ_1，λ_2，…，λ_n）$</li><li>对角元素相同的对角阵，称为数量阵</li><li>数量阵的元素为1，单位阵</li></ol><p>定义2　若两个矩阵的行数与列数分别相等，则称它们为同型矩阵.</p><h2 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h2><p>矩阵加法的运算规律：</p><ol><li>A+B = B + A 交换律</li><li>(A+B) + C = A + (B + C) 结合律</li></ol><p>数与矩阵的乘法：</p><p>定义4　数λ与矩阵A的乘积记作λA.</p><p>数与矩阵相乘的运算规律：</p><ol><li>(λμ)A = λ(μA)</li><li>(λ+μ)A = λA+μA</li><li>λ(A+B) = λA + λB</li></ol><h3 id="矩阵乘法"><a href="#矩阵乘法" class="headerlink" title="矩阵乘法"></a>矩阵乘法</h3><p>定义5　设矩阵$A=(a_{ij})_{m×s}，B=(b_{ij})_{s×n}，$则规定矩阵A与矩阵B的乘积是一个m×n矩阵$C= (c_{ij})_{m×n}$，其中<br> $c_{ij} = \sum_{k=1}^{s}a_{ik}b_{kj}$.</p><ol><li>对于两个n阶方阵A、B ，若AB = BA， 则A与B是可交换的</li><li>特别注意：若两个矩阵A，B满足AB=O，不能推出A=O或B=O的结论；若AB=AC，A≠O，也不能推出B=C的结论.</li></ol><p>矩阵乘法的运算规律：</p><ol><li>（AB）C=A（BC）； </li><li>A（B+C）=AB+AC，（B+C）A= BA+CA；</li><li>λ（AB）=（λA）B=A（λB）.</li></ol><p>对于单位矩阵E，容易验证$E_mA_{m×n}=A_{m×n}，A_{m×n}E_n=A_{m×n}$，可简记为EA=AE=A.</p><p>方阵的幂的运算规律 :</p><ol><li>$A^kA^1 = A^{k+1}$</li><li>$(A^k)^l = A^{kl}$</li></ol><p>特别注意： 矩阵乘法不满足交换律。</p><h3 id="矩阵转置"><a href="#矩阵转置" class="headerlink" title="矩阵转置"></a>矩阵转置</h3><p>定义6　将m×n矩阵A的行换成同序数的列得到的一个n×m矩阵，称为A的转置矩阵，记作$A^T$.</p><p>矩阵转置的运算规律：</p><ol><li>$(A^T)^T = A$</li><li>$(A+B)^T = A^T + B^T$</li><li>$(λA)^T = λA^T$</li><li>$(AB)^T = B^TA^T$</li></ol><p>定义7　设A为n阶方阵，如果满足$A^T$=A，则称对称阵，特点是它的元素以主对角线为对称轴，对应相等。</p><p>反对称阵： $A^T = -A$</p><h3 id="方阵的行列式"><a href="#方阵的行列式" class="headerlink" title="方阵的行列式"></a>方阵的行列式</h3><p>由n阶方阵A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记作|A|或detA.</p><p>注意：方阵与行列式是两个不同的概念，n阶方阵是n2个数按一定方式排成的数表，而n阶行列式则是n2个数按一定的运算法则所确定的一个数.</p><p>方阵行列式的运算规律：</p><ol><li>$|A^T| = |A|$$</li><li>$|λA| = λ^n|A| $</li><li>|AB| = |A||B|</li></ol><p>对于n阶方阵A，B，一般来说AB≠BA，但总有|AB|=|BA|=|A|·|B|.</p><h2 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h2><p>设A为n阶方阵，若存在n阶矩阵B，使得：</p><p>AB = BA = E</p><p>则称方阵A是可逆的，并称B是A的逆矩阵 记作 $A^{-1} = B$,逆矩阵一定是方阵。</p><p>定理1 ： 若矩阵A可逆，则其逆矩阵唯一</p><p>定理2： 设$A^*$ 为A的伴随矩阵，就是每个元素都是对应的代数余子式。则有：</p><p>$$AA^*=A^*A=|A|E$$</p><p>定理3 ： n阶方阵A可逆的充分必要条件是|A| != 0 且有：</p><p>$ A^{-1} = \frac{1}{|A|}A^*$</p><p>方阵的逆矩阵的性质：</p><ol><li>若A可逆，则$(A^{-1})^{-1} = A$</li><li>若A可逆，数λ不为0， 则λA可逆，且$(λA)^{-1} = \frac{1}{λ}A^{-1}$</li><li>若AB为同阶方阵，且A、B都可逆，则AB可逆，且 $(AB)^{-1} = B^{-1}A^{-1}$</li><li>若A可逆，则$A^T$可逆，且$ (A^T)^{-1} = (A^{-1})^T$</li><li>若A可逆，则$ |A^{-1}| = \frac{1}{|A|} = |A|^{-1} $</li></ol><h2 id="矩阵的分块"><a href="#矩阵的分块" class="headerlink" title="矩阵的分块"></a>矩阵的分块</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;矩阵学习记录&lt;/p&gt;
    
    </summary>
    
      <category term="数学知识" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    
      <category term="线性代数" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
    
      <category term="线性代数" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>aspect源码浅析</title>
    <link href="http://yoursite.com/wiki/IOS/opensource/Aspects/aspect/"/>
    <id>http://yoursite.com/wiki/IOS/opensource/Aspects/aspect/</id>
    <published>2019-08-08T02:07:12.000Z</published>
    <updated>2019-08-08T03:59:31.281Z</updated>
    
    <content type="html"><![CDATA[<p>图解<a href="https://github.com/steipete/Aspects" rel="external nofollow noopener noreferrer" target="_blank">aspect</a>。</p><a id="more"></a><h2 id="图解aspect"><a href="#图解aspect" class="headerlink" title="图解aspect"></a>图解aspect</h2><p>aspect 切方法分为两种：</p><ol><li>为实例切方法，只实例有效，类的其他实例不受影响，类似KVO，原理是交换了isa。</li><li>为类切方法： 交换了类的实例方法，所有实例都生效。</li></ol><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_1.png" alt="aspect主流程"></p><p>其实看过原理后，就交换了两个方法，一个是当前selector，一个是forwardInvocation。<br><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_2.png" alt="aspect交换方法后的结果"></p><p>一定要理解方法的中包含SEL、IMP，SEL理解为方法的名称，IMP是方法的代码实现，图中很多地方使用SEL、IMP后缀区分两着。</p><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_3.png" alt="aspect执行切片方法的流程"></p><p><img src="/wiki/IOS/opensource/Aspects/aspect/aspect_4.png" alt="aspect执行切片方法的流程直观理解"><br>特别注意步骤9，解决的是如果向切片类发送了非切片类的方法，还走原来的消息转发流程，如不认识的方法报 not recognize selector send to instance错误。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>无</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图解&lt;a href=&quot;https://github.com/steipete/Aspects&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;aspect&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="opensource" scheme="http://yoursite.com/categories/IOS/opensource/"/>
    
      <category term="Aspects" scheme="http://yoursite.com/categories/IOS/opensource/Aspects/"/>
    
    
      <category term="aspect" scheme="http://yoursite.com/tags/aspect/"/>
    
  </entry>
  
  <entry>
    <title>方法交换理解</title>
    <link href="http://yoursite.com/wiki/IOS/Runtime/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/method_swizzing/"/>
    <id>http://yoursite.com/wiki/IOS/Runtime/日常总结/method_swizzing/</id>
    <published>2019-08-06T03:38:11.000Z</published>
    <updated>2019-08-06T08:40:11.919Z</updated>
    
    <content type="html"><![CDATA[<p>本文理解方法交换写法的含义</p><a id="more"></a><h2 id="方法交换源码解读"><a href="#方法交换源码解读" class="headerlink" title="方法交换源码解读"></a>方法交换源码解读</h2><p>下面是方法交换的常用源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector</span><br><span class="line">&#123;</span><br><span class="line">    Class <span class="class"><span class="keyword">class</span> = [<span class="title">self</span> <span class="title">class</span>];</span></span><br><span class="line">    </span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">origSelector);</span></span></span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="type">newSelector);</span></span></span><br><span class="line">    </span><br><span class="line">    BOOL didAddMethod = class_addMethod(<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                                        origSelector,</span><br><span class="line">                                        method_getImplementation(swizzledMethod),</span><br><span class="line">                                        method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="class"><span class="keyword">class</span>,<span class="type"></span></span></span><br><span class="line">                            newSelector,</span><br><span class="line">                            method_getImplementation(originalMethod),</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。</p><p>下面分析 class_addMethod的源码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> </span><br><span class="line">class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    rwlock_writer_t lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, <span class="literal">NO</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class_addMethod 内部调用了addMethod，并将addMethod的结果取反，作为返回值。其中replace参数（最后一个）传递NO，表示如果类中存在该方法（originalMethod），不替换。</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">static IMP </span><br><span class="line">addMethod(Class cls, SEL <span class="keyword">name</span>, IMP imp, const char *types, bool replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line"></span><br><span class="line">    assert(types);</span><br><span class="line">    <span class="function"><span class="title">assert</span>(cls-&gt;</span>isRealized());</span><br><span class="line"></span><br><span class="line">    method_t *m;</span><br><span class="line">    <span class="keyword">if</span> ((m = getMethodNoSuper_nolock(cls, <span class="keyword">name</span>))) &#123;</span><br><span class="line">        <span class="comment">// already exists</span></span><br><span class="line">        <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">            <span class="function"><span class="title">result</span> = m-&gt;</span>imp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fixme optimize</span></span><br><span class="line">        method_list_t *newlist;</span><br><span class="line">        newlist = (method_list_t *)calloc(sizeof(*newlist), <span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>entsizeAndFlags = </span><br><span class="line">            (uint32_t)sizeof(method_t) | fixed_up_method_list;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>count = <span class="number">1</span>;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.<span class="keyword">name</span> = <span class="keyword">name</span>;</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.types = strdupIfMutable(types);</span><br><span class="line">        <span class="function"><span class="title">newlist</span>-&gt;</span>first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, <span class="number">1</span>, NO, NO);</span><br><span class="line">        <span class="function"><span class="title">cls</span>-&gt;</span><span class="function"><span class="title">data</span>()-&gt;</span>methods.attachLists(&amp;newlist, <span class="number">1</span>);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先查找类是否有方法，如果有，返回方法，如果没有添加并返回空，所以addMethod的返回值可以理解为<strong>返回旧的方法</strong>。</p><p>所以进一步理解class_addMethod返回值的含义： 它取反了addMethod的结果，所以，添加成功，返回yes，没有添加成功（也就是存在方法），返回no。</p><p>方法添加成功，也就是类中没有originalMethod方法，调用了class_replaceMethod，接着看class_replaceMethod方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IMP </span><br><span class="line">class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> addMethod(cls, name, imp, types ?: <span class="string">""</span>, YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为上面class_addMethod添加成功，说明原始类是没有旧方法，也就不用管我们添加的旧方法，所以直接调用class_replaceMethod将<strong>添加的方法originalMethod</strong>换为新方法即可，不需要交换，所以，传递给addMethod方法的最后一个参数是yes，<strong>直接替换</strong>。</p><p>如果没有添加成功，说明原类中有originalMethod，所以不能直接替换，如果直接替换了，调用原方法的函数就会出问题（死循环），需要交换，条用method_exchangeImplementations交换方法。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void method_exchangeImplementations(<span class="function"><span class="keyword">Method</span> <span class="title">m1_gen</span>, <span class="title">Method</span> <span class="title">m2_gen</span>)</span></span><br><span class="line"><span class="function"><span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">    IMP m1_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    old_method *m1 = oldmethod(m1_gen);</span></span></span><br><span class="line"><span class="function"><span class="comment">    old_method *m2 = oldmethod(m2_gen);</span></span></span><br><span class="line"><span class="function"><span class="comment">    if (!m1  ||  !m2) return;</span></span></span><br><span class="line"><span class="function"><span class="comment"></span></span></span><br><span class="line"><span class="function"><span class="comment">    impLock.lock();</span></span></span><br><span class="line"><span class="function"><span class="comment">    m1_imp = m1-&gt;method_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    m1-&gt;method_imp = m2-&gt;method_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    m2-&gt;method_imp = m1_imp;</span></span></span><br><span class="line"><span class="function"><span class="comment">    impLock.unlock();</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/Draveness/analyze" rel="external nofollow noopener noreferrer" target="_blank">Draveness git地址</a></li><li><a href="http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html" rel="external nofollow noopener noreferrer" target="_blank">Classes and Metaclasses</a></li><li><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">类型编码</a></li><li><a href="http://nshipster.cn/type-encodings/" rel="external nofollow noopener noreferrer" target="_blank">Type Encodings</a></li><li><a href="https://en.wikipedia.org/wiki/Tagged_pointer" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文理解方法交换写法的含义&lt;/p&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="Runtime" scheme="http://yoursite.com/categories/IOS/Runtime/"/>
    
      <category term="日常总结" scheme="http://yoursite.com/categories/IOS/Runtime/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="runtime" scheme="http://yoursite.com/tags/runtime/"/>
    
  </entry>
  
  <entry>
    <title>1. 两数之和</title>
    <link href="http://yoursite.com/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1_10/1_%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <id>http://yoursite.com/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/</id>
    <published>2019-07-25T09:07:12.000Z</published>
    <updated>2019-07-25T09:31:21.420Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/problem.png" alt="题目"></p><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(<span class="number">_</span> nums: [Int], <span class="number">_</span> target: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">       <span class="comment">// num = [2, 7, 11, 15] target = 9</span></span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Int</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i, v) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="comment">// i = 0, v = 2</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIndex = dict[target - v] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIndex, i]</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dict[v] = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"NO Output"</span>)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/prob
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="LeetCode" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/"/>
    
      <category term="top1_10" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/LeetCode/top1-10/"/>
    
    
  </entry>
  
</feed>
