<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LJ小窝</title>
  
  <subtitle>勤总结、勤记录</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-08-27T10:54:38.495Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>顺序容器</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/</id>
    <published>2018-08-27T10:07:12.000Z</published>
    <updated>2018-08-27T10:54:38.495Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>顺序容器概述</li><li>容器库概览</li><li>顺序容器操作</li><li>vector对象是如何生长的</li><li>额外的string操作</li><li>容器适配器</li></ol><a id="more"></a><h2 id="顺序容器概述"><a href="#顺序容器概述" class="headerlink" title="顺序容器概述"></a>顺序容器概述</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顺序容器概述&lt;/li&gt;
&lt;li&gt;容器库概览&lt;/li&gt;
&lt;li&gt;顺序容器操作&lt;/li&gt;
&lt;li&gt;vector对象是如何生长的&lt;/li&gt;
&lt;li&gt;额外的string操作&lt;/li&gt;
&lt;li&gt;容器适配器&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第九章顺序容器" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B9%9D%E7%AB%A0%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
    
      <category term="顺序容器" scheme="http://yoursite.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>IO库</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/IO%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第八章io库/IO库/</id>
    <published>2018-08-27T04:07:12.000Z</published>
    <updated>2018-08-27T10:51:38.547Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容</p><ol><li>IO类</li><li>文件输入输出</li><li>string流</li></ol><a id="more"></a><h2 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h2><h3 id="IO对象无拷贝或赋值"><a href="#IO对象无拷贝或赋值" class="headerlink" title="IO对象无拷贝或赋值"></a>IO对象无拷贝或赋值</h3><p>进行IO操作的函数通常以引用方式传递、返回流。读写一个IO对象会改变其状态，因此，传递和返回的引用不能是const的。</p><h3 id="条件状态"><a href="#条件状态" class="headerlink" title="条件状态"></a>条件状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>strm::iostate</td><td>strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能</td></tr><tr><td>strm::badbit</td><td>指出输出流已崩溃</td></tr><tr><td>strm::faillbit</td><td>一个IO操作失败</td></tr><tr><td>strm::eofbit</td><td>流达到了文件结尾</td></tr><tr><td>strm::goodbit</td><td>流未处于错误状态，此值保证为0</td></tr><tr><td>s.eof()</td><td>若流s的eofbit置位，则返回true</td></tr><tr><td>s.fail()</td><td>若流s的failbit置位，则返回true</td></tr><tr><td>s.bad()</td><td>若流s的badbit置位，则返回true</td></tr><tr><td>s.good()</td><td>若流处于有效状态，则返回true</td></tr><tr><td>s.clear()</td><td>将流的所有状态复位</td></tr><tr><td>s.clear(flags)</td><td>根据给定的flags标志位，将流s中对应的条件状态位复位</td></tr><tr><td>s.setstate(flags)将流s中对应条件状态位置位</td><td></td></tr><tr><td>s.rdstate()</td><td>返回流s的当前条件状态</td></tr></tbody></table><p>一个流一旦发生错误状态，其后续的IO操作都失败。只有流处于无错状态是，我们才可以从它读取数据、写入数据。</p><p>属性缓存区：</p><ol><li>endl， 换行并刷新缓冲区</li><li>flush ，刷新缓存区，不输出任何额为的字符</li><li>ends，向缓冲区插入一个空字符，然后刷新缓冲区</li></ol><p>unitbuf 操纵符：如果每次输出操作后，都属性缓存区，我们可以使用unitbuf操纵符。</p><p>如果程序崩溃，输出缓冲区不会被刷新。</p><p>tie： 如果本对象关联到一个输出流，则返回的就是这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。</p><h2 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>fstream fstrm</td><td>创建一个未绑定的文件流</td></tr><tr><td>fstream fstrm(s)</td><td>创建一个fstream，并打开名为s的文件。 s可以是string类型，或者是一个指向C风格字符串类型</td></tr><tr><td>fstream fstrm(s,mode)</td><td>安装mode打开文件</td></tr><tr><td>fstrm.open(s)</td><td>打开名为s的文件，并将文件与fstrm绑定，返回void</td></tr><tr><td>fstrm.close()</td><td>关闭于fstrm绑定的文件，返回void</td></tr><tr><td>fstrm.is_open</td><td>返回一个bool，指出与fstrm关联的文件是否成功打开且尚未关闭</td></tr></tbody></table><p>创建文件流对象时，我们可以提供文件名，如果提供了一个文件名，则open自动被调用。</p><h3 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h3><table><thead><tr><th>文件模式</th><th>说明</th></tr></thead><tbody><tr><td>in</td><td>以读方式打开</td></tr><tr><td>out</td><td>以写方式打开</td></tr><tr><td>app</td><td>每次写操作前均定位到文件末尾</td></tr><tr><td>ate</td><td>打开文件后，立即定位到文件末尾</td></tr><tr><td>trunc</td><td>截断文件</td></tr><tr><td>binary</td><td>以二进制方式进行IO</td></tr></tbody></table><h2 id="stirng流"><a href="#stirng流" class="headerlink" title="stirng流"></a>stirng流</h2><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>sstream strm</td><td>strm是未绑定的stringstream对象</td></tr><tr><td>sstram strm(s)</td><td>strm 是一个sstream对象，保存string的一个拷贝，此构造函数是explicit的</td></tr><tr><td>strm.str()</td><td>返回strm中保存的string的拷贝</td></tr><tr><td>strm.str(s)</td><td>将string s 拷贝到strm中，返回void</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IO类&lt;/li&gt;
&lt;li&gt;文件输入输出&lt;/li&gt;
&lt;li&gt;string流&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第八章io库" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%85%AB%E7%AB%A0io%E5%BA%93/"/>
    
    
      <category term="IO库" scheme="http://yoursite.com/tags/IO%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>What’s New in User Notifications</title>
    <link href="http://yoursite.com/wiki/WWDC/What%E2%80%99s%20New%20in%20User%20Notifications/"/>
    <id>http://yoursite.com/wiki/WWDC/What’s New in User Notifications/</id>
    <published>2018-08-23T04:07:12.000Z</published>
    <updated>2018-08-23T07:01:53.069Z</updated>
    
    <content type="html"><![CDATA[<p>Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notifications team, and we’re very excited to be back at WWDC to share with you all the new and exciting features around user notifications that your applications can start using with iOS 12. Today, we will be going over a range of topics as you can see from the list here. We will start with talking about grouped notifications, a new paradigm that we’ve introduced to iOS notifications when presented in the user’s notification list. Then we’ll talk about notification content extensions, which are existing extension points with notifications, and discuss new APIs that you’ve added around these. Then, we’ll cover notification management and talk about all the new ways in which your application users can now tweak your notification settings and what you need to do to respond to these new options. Then, we’ll cover provisional authorization, which allows your applications to have a trial phase for sending notifications to users without their explicit permission but do it quietly. And lastly, we’ll cover critical alerts, which allows your applications to send important notifications to the users, which bypass certain system settings if your users allows your applications to do so.<br>下午好，欢迎大家来这个叫做what’s new in user notifications的session </p><p>So there’s a range of topics to be covered today, and let’s begin with looking at grouped notifications. Now up to iOS 11, all new incoming notifications for the users were inserted in a chronological order in the notification list.<br>So these would be interspersed across multiple applications, and it would be hard for the user to find a certain notification or triage multiple notifications together.<br>So starting in iOS 12, we’ve decided to improve this by introducing notification grouping, so now, as you can see here, all notifications across different applications get grouped into their unique groups. Let’s take a deeper look at how grouped notifications works. Now all these notifications will be automatically grouped, so there’s nothing explicit that you need to do to start using notification grouping.<br>However, if you do want to have your own custom groups then you can use the thread identifier, which is an existing property on the UN notification content object.<br>So some of you might already be using the thread identifier and for a local notification.<br>You can set it on the UNMutableNotificationContent object as seen here.<br>And for a remote notification payload, you can also include it as part of your notification payload. Now the thread identifier might be familiar to some of you already. We use it today for forwarding notifications to a notification content extension that is presented for your application, which has the exact same thread identifier, allowing the content extension view to update it based on the new incoming notification. Starting in iOS 11, we started using the thread identifier for doing grouping of notifications, if the user had turned on [inaudible] notification previous. So we’re just taking this concept and expanding it for all notifications in general. So how does this grouping work? So when a new notification comes in to you, the user’s device, if there is no thread identifier set on this notification, then this notifications gets grouped with the application bundle. We can see that from our sample application here, that as new notifications are incoming, they are getting bundled with the same group and the group is getting updated with the latest content.<br>And then the user can simply expand this notification group to see all the notifications that are present in that group. On the other hand, if the notification does have a thread identifier set on it, then it gets grouped with all the other notifications from that same application with that exact same thread ID. What this also means is that the same application can then have multiple different custom groups, depending upon the unique thread identifiers that you’re setting on them. A good example of this is the messages application, where here you can see there are two different threads, and as new notifications are incoming, they are going to their own respective groups.<br>And then the user can expand a specific group to see all the notifications that are part of that group. So by using the thread identifier, messages is able to do so. Now, your application users also have the option of tweaking this notification grouping setting from your per application notification setting’s page.<br>Here, they get three options. If they choose automatic, then they get the behavior that we just described. However, the user also has the option of just grouping by application, where the system will ignore your thread identifier and group all notifications into a single group. And if the user wants the same behavior as it exists in iOS 11 today, then they can simply turn off grouping for your applications’ notifications. So do keep this in mind when you’re creating your own custom groups that they create enough value for users when they receive your applications’ notifications. Now what are the different components of a notification group? The content that we show is for the latest notification that was received as part of that group. And then the user can simply see all the notifications by tapping on this group, and we expand all the notifications’ content. And then the user can interact with all these notifications individually as well. The two buttons at the top give the users much greater control like collapsing the stack as well as clearing all these notifications together. Now, notification grouping also makes triaging of notifications much better. For example, in this case, the user can clear all these notifications together by simply swiping to the right and tapping clear all.<br>Apart from the content of the notification group, we also show a summary text.<br>Now, this summary text, by default, shows the count of all the notifications that are part of that group. However, you can also create a custom summary text so you can give your users much better context of what kind of information is included in that group. Now, we will cover this API and go over much larger use cases of how you can create your custom groups in the advanced session around using group notifications, which will follow this session. So let’s do a quick summary of group notifications as we saw them today. Starting in iOS 12, all application notifications are going to be grouped automatically.<br>You can start using the thread identifier if you want to create your own custom groups for your applications, but the user does have the option of changing this grouping setting for your applications’ notifications. And lastly, you can use the summary text for customizing the information you want to provide the user around the notification groups that you’re creating.<br>All right, so that was group notifications. Now, let’s move on to the next topic and talk about notification content extensions. Now, some of you might already be familiar with these content extensions that we included with iOS 10.<br>Content extensions allow your applications to present a rich notification view around the user’s notifications, so you can have a much more customized and interactive interface for the notification that the user is seeing. Let’s do a quick recap of setting up these content extensions. Xcode gives you a standard template to add a target for the content extensions to your applications and once you set that up, we create a default class for the notification view controller, which implements the UNNotificationContentExtension protocol. Here, the did receive notification method is important because this is your entry point for setting up the view associated with the content extension, and you can use the notification object past here to get all the information around that notification to set up your custom view.<br>The info.plist file associated with your content extension gives you more options.<br>The important thing here is the category identifier. Now, this identifier needs to match the same category identifier you’re setting on your notification requests because that’s how the system knows which content extension to launch with which notification.<br>Along with this, you can do some quick configurations of your content extension such as setting the initial content size ratio, hiding the default content, as well as overriding the title of this content extension. Now, the primary way in which your users interact with these content extensions is through notification actions, and these actions are presented right below the content of the content extension.<br>Let’s summarize how we can set up these actions as well. So doing so is fairly trivial in code. For example, here, we have two actions here for like and comment, and we create a simple UNNotificationAction for like and a text input action for commenting. And once we’ve created these actions, we create a new category giving it the same identifier as the content extension where we want these actions to be presented. And then, we pass it, the two new actions that we created.<br>Once we’ve set up this category, then we call setNotificationCategories on the UNNotificationCenter object associated with our class, giving it the new category that we created. So by simply doing so, the next time when the user goes to your content extension we can see that these actions are now available for them to interact with your notification content. Now let’s take a look at how we can handle the responses from these actions. There are two ways to do that. Firstly, you can handle this response in the AppDelegate that is associated with your application that implements the UNUserNotificationCenter Delegate protocol. Here, the function UserNotificationCenter did receive response, includes the response object which includes information about the request, the notification request from which the user took this action.<br>However, the content extension also allows you to intercept this action response so that you can update your view and make a much more interactive and dynamic experience for users for the content extension. So for our sample here, we enter the did receive response method and checked the action identifier for the like action. And then we update our UI with the new label as well as update our application state. Finally calling the completion block we do not dismiss. If you do want to dismiss your content extension view here, then you can simply change the parameter you’re passing to the completion block to dismiss or dismiss and forward, where we will forward this response to your AppDelegate function as well. All right, so now that we set this up, we can see that when the user takes the like action, the content extension content gets updated right there and then. So it’s a much more interactive experience for your user and they’re getting real-time feedback. However, if you look at the current state of the content extension, we see that there is some redundant information.<br>The user has already taken the like action, so having the action there doesn’t really serve a purpose anymore. Now notification actions, in general, have certain limitations. They are not very dynamic and can’t be updated based on the context of your content extensions. Also, these tend to be tied to the notification categories that you have to define at the time of your application setup.<br>So we wanted to address these issues and we have introduced a new API around notification actions, where now we’re exposing these notification actions as part of the NSExtensionContext tied to your content extension. What this API allows you to do is access the currently presented notification actions to the user as well as replace these actions by setting a brand new array of notification actions for your content extension. So going back to our sample, what if after the user took the like action we wanted to replace it say with the unlike action so that they can do the reverse of the action they just took? So using this new API, let’s take a look of how we can set this up. So we go back to our did receive response method and again identify the like action and update our application state. This time, we also create a new action for unlike, giving it a unique identifier as well as a title.<br>We can also take a look at the currently presented actions so that we can extract the comment action from there without having to create it again. Then we create a new array of these new actions that we’ve created and simply set that on the notification actions variable. So once we’ve done this and the user takes the like action, then the UI will automatically update to show them the new action, and then the user can then toggle between the two actions, depending upon how you handle that state in your content extensions. Now, this API can be used in multiple other ways as well.<br>For example, now you can set your actions at the time you’re setting up your content extension view in the did receive notification method. What this means is your notification requests are no longer tied to the category to define the actions that you want to present around these notifications. You can also now present a secondary set of actions by replacing the currently presented actions.<br>For example, if the leading action was rate, then you can provide a secondary list of the different types of ratings that you want your user to take. And you can also remove all these notification actions if you feel it does not make sense anymore for your content extension to present these actions. So that’s the new API around notification actions. And we feel this will really help you enhance the experience that your users have around your content extensions with the different actions now you can present to them. Let’s move on and talk about user interaction with these content extensions. Now notification actions were important up till this point because till iOS 11 we did not allow user interaction touches with your content extension view. Now we received a lot of feedback around this.<br>And I’m happy to announce that we’re taking away this restriction with iOS 12.<br>So now your content extensions have the option of opting in to receiving user interaction [inaudible] touches, and setting this up, it’s fairly trivial.<br>All you have to do is add a new key value option to your info.plist file.<br>And the key that we’ve added is the UNNotificationExtensionUser InteractionEnabled.<br>So going back to our sample, what if we want to remove the like action from a notification action and make it a UI interaction touch that’s part of the view itself? So once we’ve configured our info.plist file, we can go back to our content extension view and create our own custom button to handle the like gesture. We add a target for our own private method and inside that function, we update the UI as well as update our application state. So here, it’s important that since you’re implementing your own user interactions that you are responsible for handling all these actions, responses, and callbacks from the users yourself. So once we’ve set this up, now when the user goes to your content extension we see the Like button, part of the UI itself, and the user can simply interact with that button right there and then.<br>So that’s the new functionality that we’ve added around content extensions.<br>And coupled with notification actions, along with user interaction touches, you now have a much richer set of tools for creating much more interactive and dynamic content extension experiences for your applications notifications users.<br>Now let’s talk about launching your application from the notification content extension.<br>So today the user can launch your application if touches were not allowed by simply tapping the content extension view. They could also do so by tapping your application icon in the top left corner. Or you could create a foreground action, which then would in turn launch the application. But what if you wanted to do this from your own custom control? What if you wanted to launch the application programmatically? To enable this, there is a new API on the NSExtensionContext called performNotification DefaultAction, which would allow you to do this now. Now, what does the default action mean? So, as we said, it launches the application, but at the same time, it calls the UserNotificationCenter did receive response method in your application delegate. Now the UNNotificationResponse object contains the information of the notification from which the user came, so you can update your application state based on the notification. And the identifier that’s passed here is the UNNotificationDefault ActionIdentifier. So going back to our sample, let’s see how we can set this custom control up. Now again, we create our own UI button for the all comments and then tie it up with our own private function.<br>And in that function, we’re simply calling PerformNotification DefaultAction. So by simply doing that, you get this functionality to call this method programmatically from anywhere in your content extension code.<br>So that was launching the application. What about dismissing the content extension view? Again, let’s take a look at how the user can do that today.<br>They can do that by tapping the Dismiss Button in the top right corner, or you can create your own custom notification action, which would in turn dismiss the content extension view.<br>Which you can set up, as we saw before, by passing dismiss to the completion block.<br>But again, what if we want to dismiss the view through our own custom buttons, and we want to do this programmatically? Say that when the user taps the Like button, then the view dismisses because we feel the user’s done interacting with the content extension.<br>To enable this as well, there’s a new API called dismissNotificationContent Extension that’s on the NSExtensionContext. We go back to how we set up our Like button, and now this time, we also call the new function that we added for dismissing the content extension view. And once we set this up, now when the user takes the like action, the view of the content extension gets dismissed. Now one thing to note here.<br>That calling this method does not withdraw the notification that was posted to the user.<br>If you want to do that then use the existing API for removing delivered notifications with identifiers to get that functionality. All right, now let’s summarize all the new APIs that we’ve looked at today around the notification content extensions.<br>We started with talking about notification actions where now you can access these notification actions as well as replace them dynamically from anywhere in your content extension code. You can now opt in to having user interaction based on touches within your content extension views. You can programmatically launch the application from anywhere in your content extension code as well as dismiss the content extension view, depending upon where you feel it serves best your user’s experience around the content extensions. So that’s a varied list of APIs around content extensions, and we hope this really helps you enhance your user’s experience around your content extensions and then you start using these APIs. So that was notification content extensions. Now, the next topic today we’re going to look at is notification management, and to tell you all about that, let me invite my colleague Teja to the stage.<br>Thank you. Thank you Kritarth.<br>Hi everyone. My name is Teja Kondapalli, and I’m also an engineer on the iOS Notifications’ Team. And, of course, I’m here to talk to you about a couple of the new APIs that we have. The first of which is notification management.<br>But before I dive into this API, I want to cover some of the user facing features to give you some more context and then we can deep dive into the API. As our users get more and more apps on their phones, notifications become the primary way that they interact with these apps. But often, they find themselves in a situation like this.<br>With far too many notifications. And it becomes hard to sift through and find the important ones. So perhaps to make this easier, this user has decided that notifications from podcasts don’t need to be shown on the locked screen.<br>Right now to configure that they’d have to launch the settings app, find notifications, find the podcast app, and then they can configure their settings.<br>We wanted to make this easier. So, in iOS 12, we’re introducing a new management view where the users can configure their notification settings directly from the notification without having to launch the settings app. There’s three really easy ways to get into this management view. The first is what we just saw.<br>You simply swipe over a notification, tap manage, and the management view comes up.<br>The second is if you can go into the rich notification, you can tap in the right corner, and you can also launch the management view. And the third is actually in the list itself. Depending on how your users are interacting with their notifications, they will occasionally see suggestions, like this one, that ask them if they want to keep receiving podcast notifications. And from here, as well, they can tap manage and bring up the management view. Let’s take a closer look at the management view. And we obviously have options here where users can configure their notification settings directly from this view. But if they want to go into the settings app and configure in a more detailed manner, they have a quick link to the settings for this application, the notification settings. A And also from this view, they have some actions they can take directly, the first of which says deliver quietly, which is probably a concept that’s new to all of you. Some of these management views will also have an option that says deliver prominently, so let’s talk about what this means. In iOS, we have a lot of settings that users can configure, and this is really great for the power user. The can customize their settings to every detail, but for the regular user, we think that we can help them out by categorizing their notification settings into two big categories.<br>Notifications that are delivered prominently and notifications that are delivered quietly.<br>Notifications that are delivered prominently are what we’re used to.<br>They show up on the locked screen. They show up in notification center. They roll down as banners. They badge the AP icon and they can play a sound. Notifications that are delivered quietly only show up in notification center and they don’t play a sound. And from the management view, in addition to configuring whether they want their notifications delivered prominently or quietly, users also have the option to turn off their notifications.<br>Now, I know that you might worry that your users are going to turn off the notifications for your app, so we’ve added this extra confirmation sheet just in case they do tap turn off.<br>And from here, they can also turn off their notifications. But we’ve also added an API to add a second option to this confirmation sheet, and podcast has taken advantage of this API, so it says configure in podcast. This is a link that will deep link within the podcast app to a custom settings view that allows the user more granular control about what kind of podcast notifications they want. And as your apps send more and more notifications and various type of notifications, we think it’s really important to allow them this granular level of control over what kind of notifications are important to them.<br>This link can also be accessed from the systems settings app from your apps’ notification settings. And you can see for podcasts it’s right at the bottom.<br>It says podcast notifications settings. Let’s see how we do this in code. In the class that conforms to UNUserNotificationCenter Delegate, we have a new delegate method. Open settings for notification, and as long as you implement this delegate method, those links that we talked about from the management view, or from the settings app, will automatically be populated by the system for you. So when the user taps on any of these links, this delegate method will be called. And it’s really important when this delegate method is called that you immediately take your users into the view where they can configure their notification settings within your app. And if you notice, we have [inaudible] parameter to this method, and it is notification. So depending on where the link was tapped from, if it was tapped from one of the management views, it will have the value of the notification that that management view came from. If it was tapped from the settings app, the value of notification will be nil, and you can use this information to show the appropriate notification settings when this delegate method is called.<br>So that’s what we have for notification management. It’s a new way for your users to configure whether they want their notifications delivered prominently or quietly, or turn them off, or even configure them at a granular level within your app.<br>And to encourage your users to keep getting your notifications delivered, we think it’s really important that you make the content in the notifications relevant.<br>We also encourage you to use thread identifiers to group the notifications when you think it’s appropriate. This will help the users organize their lists better and will make sure that they’re not overwhelmed by the notifications from your app.<br>We also think that as your apps send various types of notifications, it’s really important to provide that custom settings view within that app so that users have more granular control about what kind of notifications are important to them.<br>That’s what we have for notification management. And the next big feature I want to talk to you about is provisional authorization. Right now, when a user installs your app, before they start receiving notifications, at some point they’ll have to respond to a prompt that looks like this, which is asking them if they want these notifications.<br>And the biggest problem with this is, at this point, the user doesn’t know what kind of notifications this app is going to send, so they don’t know if they want them or not.<br>So, in iOS 12, we’re introducing provisional authorization, and this is an automatic trial of the notifications from your app. This will help your users make a more informed decision on whether they want these notifications or not. So you can opt into this, and if you do, your users will not get that authorization prompt that we just saw.<br>Instead, the notifications from your app will automatically start getting delivered.<br>But these notifications will be delivered quietly, and if we recall, notifications that are delivered quietly only show up in notifications center, and they don’t play a sound.<br>Notifications that are delivered with provisional authorization will have a prompt like this on the notification itself. And this will help the users decide after having received a few notifications whether they want to keep getting these notifications or whether they want to turn them off. And this turn off confirmation sheet will also have the custom settings link if you have provided it. Let’s see how you can do this in code. In the location where you regularly request authorization, in addition to whatever options you might be requesting, you can add a dot qualifying option called .provisional. And if you include this, you will automatically start participating in the trial. It’s really important to note that the .provisional option is in addition to whatever other options you may be providing. That’s because if the users decide to keep getting your notifications delivered, we want to know how you want them delivered, with badges or sounds or as alerts. So that’s what provisional authorization is. It’s an automatic trial of the notifications from your app to help your users make a more informed decision about whether they want these notifications.<br>And again, to encourage your users to keep getting your notifications delivered, it’s really important to make the content in your notifications relevant.<br>And also, it’s really important to use .provisional as a qualifier option in addition to whatever other options you’re requesting. That’s what we have for provisional authorization. And the last big feature that I want to talk to you about are critical alerts. Often when I’m in the middle of a meeting or attending something important, my phone looks like this. And as you can see, I have do not disturb turned on. Or at least I have the ringer switch turned off so that I don’t hear any sounds when I get notifications. And usually this is really good, but I would have missed a really important notification like this one.<br>This is a health-related notification. That’s from a glucose monitor that’s warning me of low blood sugar, and this is something I would want to see immediately.<br>Scenarios like this made us realize that we need a new type of notification, and this is what we call critical alerts. Critical alerts are medical- and health-related notifications.<br>Or home- and security-related notifications. Or public safety notifications.<br>And the key to a critical alert is that it requires the user to take action immediately.<br>The way that critical alerts behave is that they bypass both do not disturb and the ringer switch, and they will play a sound. And they can even play a custom sound. But what that means is that these are very disruptive, and for that reason we don’t think that all apps should be able to send critical notifications.<br>Critical alerts. So in order to start sending a critical alert, you will need to apply for entitlement, and you can do that on the developer.apple website.<br>This is what a critical alert looks like, and you can see that it has a unique icon indicating that it’s critical. And it would have also come in with a sound.<br>Critical alerts also have their own section in notifications settings.<br>This means that a user can choose to allow critical alerts for a particular application but choose not to allow any other type of notification. And before users start receiving critical alerts, they will have to accept a prompt that looks like this that’s asking them specifically whether they want to accept critical alerts from a particular application.<br>So, of course, in order to start sending critical alerts, you’ll have to request authorization.<br>So after you apply for entitlement and get it, in the place where you regularly request authorization, in addition to whatever other options you want to request, you can also request a .criticalAlert option. And this will give your users the prompt. And let’s see how it actually set up and send a critical alert. It actually behaves very similarly to a regular notification. You can see that I just set up a notification with the title body and category identifier, but what distinguishes this as a critical alert is that it plays a sound. So I need to set a critical alert sound.<br>And here, you can see that I’m setting the default critical alert sound that’s provided by the framework. I can also set a custom sound. And I can also set a custom audio volume level. And of course, critical alerts can also be push notifications so all of this information can be set in the push payload as well.<br>So that’s what we have for critical alerts. They’re a new type of notification that requires the users to take action immediately.<br>And they’re very disruptive, so you need entitlement to be able to send them.<br>So that’s all the new exciting APIs that we have for you today. I just want to quickly go over all the things that we covered. We talked about how you can use thread identifiers to group your notifications to help your users organize their notification lists better.<br>We talked about all the great new APIs around notification content extensions, which will help you make your rich notifications much more interactive.<br>We talked about how you can provide a custom settings view within your app to allow your users more granular control over what kind of notifications they want to receive.<br>We also talked about provisional authorizations, which is an automatic trial of the notifications from your app, which will help you users make a more informed decision about whether they want these notifications or not. And last, we talked about critical alerts, which are a new type of notification that requires the user to take action immediately and that are disruptive. So we hope you take advantage of all of these great APIs and make the notification experience for your users even better.<br>You can find all the information about this session on our sessions’ page at developer.apple.com. We’re session 710. We have another session just following this one in hall three called using grouped notification where we’ll help you determine how to best group notifications for your app. We have two notifications labs, one today and one tomorrow, where you can come and ask the engineers on our team any questions that you may have. And on Friday morning, we have an interesting session called designing notifications. That’s going to be hosted by the designers who helped us come up with the designs for these, and they’ll be talking about notification best practices.<br>Thank you and have a great dot dot.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Good afternoon and welcome everybody to our session, what’s new in user notifications. I’m Kritarth Jain [inaudible] on the iOS notificat
      
    
    </summary>
    
      <category term="WWDC" scheme="http://yoursite.com/categories/WWDC/"/>
    
    
      <category term="Notifications" scheme="http://yoursite.com/tags/Notifications/"/>
    
  </entry>
  
  <entry>
    <title>IOS12 兼容</title>
    <link href="http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/"/>
    <id>http://yoursite.com/wiki/IOS/IOS12/IOS12-compatibility/</id>
    <published>2018-08-22T04:07:12.000Z</published>
    <updated>2018-08-22T08:04:01.212Z</updated>
    
    <content type="html"><![CDATA[<p>主要遇到的问题：</p><ol><li>Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。</li><li>CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中</li></ol><a id="more"></a><h2 id="libstdc-问题"><a href="#libstdc-问题" class="headerlink" title="libstdc++问题"></a>libstdc++问题</h2><ul><li>现象是无法找到libstdc++，编译报错如下：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">library</span> <span class="selector-tag">not</span> <span class="selector-tag">found</span> <span class="selector-tag">for</span> <span class="selector-tag">-lstdc</span>++<span class="selector-class">.6</span><span class="selector-class">.0</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><ul><li>临时解决办法—-从Xcode9中复制libstdc++库到Xcode10中，命令如下：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneOS.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneOS.sdk/u</span>sr<span class="regexp">/lib/</span></span><br><span class="line"></span><br><span class="line">cp <span class="regexp">/Applications/</span>Xcode.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span>libstdc++.* <span class="regexp">/Applications/</span>Xcode-beta.app<span class="regexp">/Contents/</span>Developer<span class="regexp">/Platforms/i</span>PhoneSimulator.platform<span class="regexp">/Developer/</span>SDKs<span class="regexp">/iPhoneSimulator.sdk/u</span>sr<span class="regexp">/lib/</span></span><br></pre></td></tr></table></figure><ul><li>最终解决办法：</li></ul><p>需要联系第三方公司，将GMThirdParty/BestPay 、GMF_EaseMobSDK2.2.9更新。</p><h2 id="CocoaPods无法复制资源到app中"><a href="#CocoaPods无法复制资源到app中" class="headerlink" title="CocoaPods无法复制资源到app中"></a>CocoaPods无法复制资源到app中</h2><p>现象：登录界面没有图标，或者启动时 NSBundle的initWithUrl方法崩溃。</p><p>解决办法：</p><ol><li>升级CocoaPods到1.4.0，命令是：<code>sudo gem install -n /usr/local/bin cocoapods -v 1.4.0</code> 。</li><li>移除<code>Build Phases</code> 中的 <code>[cp]Copy Pods Resources</code> 。</li><li>重新pod install。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.im/post/5b1634f0f265da6e61788998" rel="external nofollow noopener noreferrer" target="_blank">Xcode10和iOS12踩坑</a></li><li><a href="http://www.cocoachina.com/ios/20180611/23749.html" rel="external nofollow noopener noreferrer" target="_blank">libstdc++适配Xcode10与iOS12</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要遇到的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。&lt;/li&gt;
&lt;li&gt;CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="IOS12" scheme="http://yoursite.com/categories/IOS/IOS12/"/>
    
    
      <category term="IOS12 兼容" scheme="http://yoursite.com/tags/IOS12-%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>类</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/%E7%B1%BB/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第七章类/类/</id>
    <published>2018-08-20T04:07:12.000Z</published>
    <updated>2018-08-27T07:46:20.108Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>定义抽象数据类型</li><li>访问控制与封装</li><li>类的其他特性</li><li>类的作用域</li><li>构造函数再探</li><li>类的静态成员</li></ol><p>数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。</p><a id="more"></a><h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="一、设计Sales-data类"><a href="#一、设计Sales-data类" class="headerlink" title="一、设计Sales_data类"></a>一、设计Sales_data类</h3><ol><li>一个isbn成员函数，返回对象的ISBN编号</li><li>一个combine成员函数，用于将一个Sales_data对象加到另一个对象上</li><li>一个名为add的函数，执行两个Sales_data对象的加法</li><li>一个read函数，将数据从istream读入到Sales_data对象中</li><li>一个print函数，将Sales_data对象的值输入到ostream </li></ol><h3 id="二、定义改进的Sales-data类"><a href="#二、定义改进的Sales-data类" class="headerlink" title="二、定义改进的Sales_data类"></a>二、定义改进的Sales_data类</h3><p>定义在类内部的函数隐式的inline函数。</p><p>成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。对我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">total</span><span class="selector-class">.isbn</span>()</span><br></pre></td></tr></table></figure><p>则编译器负责把total的地址传给isbn的隐式参数this，可以等价的认为编译器将该调用重写成如下形式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Sales_data:</span>:isbn(<span class="variable">&amp;total</span>);</span><br></pre></td></tr></table></figure><p>this是常量指针，我们不允许改变this中保存的地址。</p><p>const成员函数： 紧随参数列表后面的const关键字表示const成员函数。这里的const的所用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。这也意味着我们不能把this绑定到一个常量对象上。不能在一个常量对象上调用普通成员函数。</p><p>常量对象以及常量对象的引用或者指针都只能调用常量成员函数。</p><p>类的作用域和成员函数： </p><ol><li>返回类型、参数列表、函数名都得于类内部的声明一样</li><li>如果成员被定义成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。</li><li>类外部定义的成员的名字必须包含所属的类名</li></ol><h3 id="三、定义类相关的非成员函数"><a href="#三、定义类相关的非成员函数" class="headerlink" title="三、定义类相关的非成员函数"></a>三、定义类相关的非成员函数</h3><p>IO类属于不能拷贝的类型，所以只能通过引用来传递他们，而且，因为读取和写入的操作会改变流的内容，所以两个函数接受都是普通引用，而非对常量的引用。</p><h3 id="四、构造函数"><a href="#四、构造函数" class="headerlink" title="四、构造函数"></a>四、构造函数</h3><p>类通过特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时，只要类的对象被创建，就会执行构造函数。</p><p>构造函数的名字和和类名相同，和其他函数不一样的是，构造函数没有返回类型。</p><p>构造函数不能声明为const的，当我们创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得常量属性，所以构造函数在const对象构造的过程中，是可以向其写值的。</p><p>合成的默认构造函数：类通过特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。合成默认构造函数初始化规则：</p><ol><li>如果存在类内初始值，用它初始化</li><li>否则，默认初始化</li></ol><p>某些类不能依赖合成的默认构造函数，原因有三：</p><ol><li>只有当类内没有声明任何构造函数时，编译器才会自动的生产默认构造函数。</li><li>如果累内部有内置类型或者符合类型成员，则只有当这些成员全部被赋予了类内初始值时，这个类才适合使用合成的默认构造函数。</li><li>有些类不能合成默认的构造函数</li></ol><p>=default： 如果我们定义了其他的构造函数，同时，也需要默认构造函数，并且默认构造函数的功能等同于合成的默认构造函数，使用=default来要求编译器生成构造函数。如果=default在类的内部，则是内联的。</p><p>构造函数初始值列表：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(const <span class="attribute">std</span>::string &amp; s,unsinged n, double p)<span class="selector-pseudo">:bookNo(s)</span>,<span class="selector-tag">unit_sold</span>(n),<span class="selector-tag">revenue</span>(p*n)&#123;&#125;;</span><br></pre></td></tr></table></figure><p>冒号和花括号之间的代码称为构造函数初始值列表。当某个数据成员被构造函数初始值列表忽略时，他将以合成默认构造函数相同的方式隐式初始化。</p><h3 id="拷贝、赋值、析构"><a href="#拷贝、赋值、析构" class="headerlink" title="拷贝、赋值、析构"></a>拷贝、赋值、析构</h3><p>拷贝、赋值、析构发生的场景</p><ol><li>拷贝：初始化变量、以值的方式传递、返回一个对象。（用同类型的对象或者自己类型的对象）</li><li>赋值：使用赋值运算符时发送。</li><li>析构：当对象不存在时销毁，超出作用域、vector容器销毁时存储在其中的对象销毁</li><li>构造： 用成员的值创建（不是自己的类型）</li></ol><p>如果我们不主动定义这些操作。编译器将替我们合成默认的。编译器生成的版本将对对象的每个成员执行拷贝、赋值、销毁操作。</p><p>某些类不能依赖合成的版本：例如动态类型。vector、string能避免分配和释放内存带来的复杂性。如果类中包含vector、string，合成的版本能正常工作</p><h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><p>使用访问说明符（access specifiers）控制类的封装性</p><ol><li>定义在public说明符后面的成员在整个程序内可以被访问。public成员定义类的接口</li><li>定义在private说明符之后的成员可以被类的成员访问，但不能被类的使用者访问。private部分封装了类的实现细节。</li></ol><p>使用class、struct关键字：class和struct定义的唯一区别是默认的访问权限。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的。如果是class，则是private。</p><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>类可以允许其他的类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元（friend），如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。</p><p>友元声明只能出现在类定义的内部，但是在类内部出现的位置不限，友元不是类的成员，也不受它所在区域访问控制级别的约束。</p><p>封装的优点：</p><ol><li>用户代码不会无意间破坏封装对象的状态</li><li>被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。</li></ol><p>友元的声明：友元的声明仅仅指定了访问权限，而非一个通常意义上的声明，如果我们需要类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。</p><h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>这些特性包括：类型成员、类的成员的类内初始值、可变数据成员、从成员返回this* 、关于如何定义并使用类类型及友元类。</p><h3 id="类成员再探"><a href="#类成员再探" class="headerlink" title="类成员再探"></a>类成员再探</h3><p>类型成员： 某种类型在类中的别名。类定义的类型名字和其他成员一样，存在访问控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">pos cursor = <span class="number">0</span>;</span><br><span class="line">pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型成员必须先定义后使用。 和类的其他成员的区别</p><p>因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认构造函数，如果我们的类需要默认构造函数，必须显示的把他声明出来。</p><p>令成员作为内联函数：定义在类内部的成员函数自动是inline的。</p><p>我们无需在声明和定义的地方同时说明inline，单这么做是合法的。不过最好只在类的外部定义的地方说明inline，这样可以使类更容易理解。</p><p>inline成员函数也应该与相应的类定义在同一个头文件中。</p><p>重载成员函数：和普通成员函数一样。</p><p>可变数据成员： 有时，我们希望能修改类的某个数据成员，即使是在一个const成员函数。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员永远不会是const的，即使const对象的成员。</p><p>类内初始值：必须使用等号或者花括号</p><h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><p>从const成员函数返回<em>this，一个const成员函数如果以引用的形式返回</em>this，那么他的返回类型将是常量引用。</p><p>基于const的重载：通过成员函数是否是const的，我们可以对其进行重载。</p><h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>类的声明： class Screen </p><p>对于类型Screen来说，在它的声明之后定义之前，是一个不完全类型（incomlete type）。也就是说，此时我们已知Screen是一个类类型，但是不清楚他到底包含哪些成员。</p><p>不完全类型只能在非常有限的情景下使用，可以定义指向这种类型的指针或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数</p><h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>类可以把其他的类定义成友元，也可以把其他类（之前定义过的）的成员函数定义成友元</p><p>类之间的友元：如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元不存在传递性</p><p>令成员函数作为友元：</p><h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了。这里的剩余部分包括参数列表、函数体。</p><p>函数的返回类型通常出现在函数名之前，因此，当成员杉树定义在类的外部，返回类型中使用的名字都位于类的作用域之外。</p><h3 id="名字查找和类的作用域"><a href="#名字查找和类的作用域" class="headerlink" title="名字查找和类的作用域"></a>名字查找和类的作用域</h3><p>名字查找（name lookup）</p><p>普通名字查找：</p><ol><li>在名字所在的块中寻找其声明语句，只考虑名字的使用之前出现的声明</li><li>如果没有找到，继续查找外层作用域</li><li>如果最终没有找到匹配的声明，则程序报错</li></ol><p>类的定义步骤：</p><ol><li>首先，编译成员的声明</li><li>知道类全部可见后，编译函数体</li></ol><p>编译器处理完类中的全部声明后，才会处理成员函数的定义</p><p>用于类成员声明的名字查找：上面两阶段的处理方式只适用于成员函数中适用的名字，声明中使用的名字，包括返回类型、参数列表中使用的名字，都必须在使用前确保可见。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal;&#125;;</span><br><span class="line"></span><br><span class="line">Money bal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Money 出现在声明中，所有从使用处开始找名字，找到了外层的double。 balance 函数体，等成员声明编译完后，处理，所以bal是成员。不是外层的string。</p><p>类型名需要特殊处理：类内部不能重新定义外层作用域中的类型名字，类内部的类型名字定义放在类的开始处，</p><p>成员定义中的普通块作用域中的名字查找：</p><ol><li>首先在成员函数内查找名字的声明，只有在函数使用前面出现的声明才被考虑</li><li>如果在成员函数内没有找到，则在类内继续查找，这是类的所有成员都可以考虑</li><li>如果类内也没有该名字的声明，在成员函数定义之前的作用域内继续查找。</li></ol><p>不建议成员的名字作为某个成员函数的参数。</p><p>类作用域之后，在外围作用域中查找：  可以使用::访问隐藏的外层中的名字 。</p><h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><p>如果没有在构造函数的初始值列表中显示的初始化成员，则该成员在构造函数体之前执行默认初始化。</p><p>构造函数的初始值有时必不可少：有时候我们可以忽略数据成员的初始化和赋值之间的差异，单并非总是这样，如果成员有const或者引用的话，必须将其初始哈。</p><p>随着构造函数体的开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。</p><p>成员是const、引用或者属于某种未提供默认构造函数的类型。我们必须通过构造函数初始值列表为这些成员提供初始值。</p><p>成员初始化顺序：成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p><h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者把他自己的一些职责委托给了其他构造函数 。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Sales_data</span>(<span class="attribute">std</span>::string s, unsigned cnt , double price )<span class="selector-pseudo">:bookNo(s)</span>, <span class="selector-tag">units_sold</span>(cnt),<span class="selector-tag">revenue</span>(cnt*price)&#123;&#125;</span><br><span class="line"><span class="selector-tag">Sales_data</span>()<span class="selector-pseudo">:Sales_data(""</span>,<span class="selector-tag">0</span>,<span class="selector-tag">0</span>)&#123;&#125;</span><br></pre></td></tr></table></figure><p>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体一次被执行，然后将控制权交给委托函数体。</p><h3 id="默认构造函数的作用"><a href="#默认构造函数的作用" class="headerlink" title="默认构造函数的作用"></a>默认构造函数的作用</h3><p>当对象被默认初始化或者值初始化时，自动执行默认构造函数。 默认初始化发送的场景：</p><ol><li>当我们在快作用域内，不适用任何初始值定义一个非静态变量。</li><li>当一个类本身还有一个类类型的成员，且使用合成的默认构造函数。</li><li>当类类型成员没有在构造函数初始值列表中显示的初始化时。</li></ol><p>值初始化发生的场景：</p><ol><li>在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时。</li><li>当我们不适用初始值定义一个局部静态变量时</li><li>当我们通过书写形如T()的表达式显示的请求值初始化时。</li></ol><p>实际中，如果定义了其他的构造函数，那么最好定义一个默认构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>; <span class="comment">///声明了一个函数，而非对象</span></span><br><span class="line">Sales_data obj2;  <span class="comment">///obj2是一个对象，默认初始化</span></span><br></pre></td></tr></table></figure><h3 id="隐式的类类型转化"><a href="#隐式的类类型转化" class="headerlink" title="隐式的类类型转化"></a>隐式的类类型转化</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转化机制，有时候，我们把这样的构造函数称为转换构造函数。</p><p>能通过一个实参调用的构造函数，定义了一条从构造函数的参数类型向类类型隐式转化的规则。</p><p>只允许一步类型转换</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">item.combine(<span class="string">"9-999-9999"</span>); <span class="regexp">//</span>错误，两步转化，<span class="number">1</span>、char * -&gt;string <span class="number">2</span>. string-&gt;Sales_data</span><br></pre></td></tr></table></figure><p><strong>抑制构造函数定义的隐式转化：</strong> 我们可以通过将构造函数声明成explicit加以阻止。</p><p>关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式类型转换，所以无需将这些构造函数指定为explicit，只能在类内声明构造函数时使用explicit关键字，在类外部定义时，不应该重复。</p><p>explicit构造函数只能用于直接初始化：不能将explicit构造函数用于拷贝形式的初始化过程。当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，而且，编译器不会再自动类型转换过程中使用该构造函数。</p><p>显示类型转换可以使用explicit构造函数。</p><p>标准库中含有显示构造函数的类：</p><ol><li>接受一个参数const char*的string的构造函数不是explicit的</li><li>接受一个容量参数的vector的构造函数是explicit的。</li></ol><h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>特定：</p><ol><li>所有成员都是public</li><li>没有定义任何构造函数</li><li>没有类内初始值</li><li>没有基类、virturl函数。</li></ol><p>可以提供一个花括号括起来的成员初始值列表。列表中成员的顺序和聚合类的成员的顺序一直， 如果初始值列表的元素的个数少于成员数量，后面的被值初始化。</p><h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>类的静态成员和类本身直接相关。静态函数没有this，不能是const，通过作用域访问静态成员，也可以通过对象访问静态成员，成员函数可以不通过作用域直接访问静态成员。</p><p>定义静态成员：我们可以在类的内部、外部定义静态成员函数。在类的外部定义静态成员时，不能重复static关键字，改关键字只能在类的内部声明语句中。静态成语不属于任何一个对象，他们不是在类创建的时候定义的，这意味着不能又类的构造函数初始化。</p><p>静态成员的类内初始化：通常情况下，静态成员不应该在类的内部初始化，然而，我们可以为静态成员提供const整数类型的类内初始值。</p><p>即使一个常量金泰数据成员在类内部被初始化了，通常情况下，他们也应该在类外部定义下该成员。</p><p>静态成员的功能：</p><ol><li>可以是不完全类型</li><li>可以作为默认参数。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义抽象数据类型&lt;/li&gt;
&lt;li&gt;访问控制与封装&lt;/li&gt;
&lt;li&gt;类的其他特性&lt;/li&gt;
&lt;li&gt;类的作用域&lt;/li&gt;
&lt;li&gt;构造函数再探&lt;/li&gt;
&lt;li&gt;类的静态成员&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第七章类" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%B1%BB/"/>
    
    
      <category term="类" scheme="http://yoursite.com/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>表达式</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第四章 表达式/表达式/</id>
    <published>2018-08-14T04:07:12.000Z</published>
    <updated>2018-08-16T02:27:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>基础</li><li>算术运算符</li><li>逻辑和关系运算符</li><li>赋值运算符</li><li>递增和递减运算符</li><li>成员访问运算符</li><li>条件运算符</li><li>位运算符</li><li>sizeof运算符</li><li>逗号运算符</li><li>类型转换运算符</li><li>运算符优先级</li></ol><p>运算符优先级大概层级：</p><ol><li>作用域运算符</li><li>成员选择、下标、函数调用</li><li>后置加加减减、类型id，类型转化</li><li>一元运算符</li><li>乘法</li><li>加法</li><li>移位</li><li>关系</li><li>位</li><li>逻辑</li><li>条件</li><li>赋值</li><li>逗号</li></ol><a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li>优先级（precedence）</li><li>结合律（asscociativity）</li><li>求值顺序</li></ol><p>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存的位置）。</p><ol><li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也是一个左值。</li><li>取地址运算符作用域左值运算对象，返回一个指向改运算对象的指针，这个指针是一个右值。</li><li>内置解引用、下标运算符、迭代器解引用求值结果是左值.</li><li>内置类型、迭代器递增运算符作用域左值，前置版本结果左值.</li></ol><p>使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。</p><ol><li>优先级</li><li>结合律</li><li>求值顺序</li></ol><p>有4种表达式明确规定了求值顺序</p><ol><li>逻辑与&amp;&amp;</li><li>逻辑或||</li><li>条件运算符？：</li><li>逗号表达式</li></ol><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>(-m)/n = m/(-n) = -(m/n)</p><p>m%(-n) = m%n</p><p>(-m)%n = -(m%n)</p><p>m%n的符号和m的相同</p><h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>逻辑与、逻辑或求值短路</p><p>几个关系运算符链子一起会产生意想不到的结果</p><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的结果是左侧运算对象，并且是左值。如果赋值运算符的两个运算对象类型不同，右侧对象将转换为左侧运行对象类型。</p><p>赋值运算符满足右结合律，这个和其他的二元运算符不太一样。</p><p>赋值运算符的优先级低于关系运算符</p><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><p>为啥有？ 某些迭代器不支持算术运算</p><ol><li>前置版本递增：首先将运算对象加1，然后将改变后的对象作为求值结果。</li><li>后置版本的递增：将运算对象加1，但是求值结果是运算对象改变之前的那个值的副本。</li></ol><p>优先使用前置版本，前置版本的递增运算符避免了不必要的功过，把加1后的对象直接返回，相反：后置版本需要将原始值存储下来，以便返回未修改的内容，对于复杂的迭代器，这种额外的工作消耗巨大。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*iter++  <span class="comment">//这种写法比较普遍，后置++的优先级高,等价于下面两行代码</span></span><br><span class="line">*iter;</span><br><span class="line">++iter</span><br><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">while</span>(pbeg != v.<span class="built_in">end</span>() )</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">end</span> ;  <span class="comment">//输出当前值，并将pbeg向前移动一个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">while</span> (<span class="built_in">begin</span> != v.<span class="built_in">end</span> &amp;&amp; !isspace(*<span class="built_in">begin</span>))</span><br><span class="line">&#123;</span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>++);  <span class="comment">//错误：该语句未定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///可以解释为下面的任何一种</span></span><br><span class="line">*<span class="built_in">begin</span> = toupper(*<span class="built_in">begin</span>);</span><br><span class="line">*(<span class="built_in">begin</span>+<span class="number">1</span>) = touper(*<span class="built_in">begin</span>)</span><br></pre></td></tr></table></figure><p>所以，如果一条子表达式改变了某个运算对象的值，另一个表达式又要使用该值的话，运算符的求值顺序非常关键。</p><h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><p>表达式ptr-&gt;mem 等价于 (*ptr).mem。</p><p>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种两种情况：如果成员所属的对象是左值，结果是左值，反之，如果成员所属的对象是右值，那么结果是右值。</p><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符将简单的if else 逻辑切入到单个表达式当中。基本形式</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cond</span>? <span class="symbol">expr1:</span> expr2</span><br></pre></td></tr></table></figure><h2 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h2><p>二进制移位，移出边界之外的位就被舍弃掉了</p><p>位求反运算符~ 将运算对象逐位求反。</p><p>如果运算对象是小整数，它的值会被自动提升。</p><ol><li>位于 &amp;</li><li>位或 |</li><li>位异或 ^</li></ol><h2 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h2><p>sizeof返回一个表达式或者一个类型名字所占的字节数，满足右结合律，返回值类型是size_t类型。sizeof并不计算运算对象的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">type</span>)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure><p>sizeof *p  sizeof不需要解引用指针也能知道它所指对象的类型，所以即使p是无效指针也不会有什么影响。</p><ol><li>对char或者类型是char的表达式执行sizeof运算，结果是1.</li><li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li><li>对指针执行sizeof运算，得到指针本身所占内存的大小</li><li>对解引用指针指向sizeof运算，得到指针所指对象所占空间的大小，指针不需要有效</li><li>对数组执行sizeof运算，得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算，并求和。sizeof不会把数组转化为指针。</li><li>对string、vector对象执行sizeof运算，只返回该类型固定部分大小。不会计算对象中元素所占空间。</li></ol><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><p>对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么求值结果是左值。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则，设法将运算对象的类型统一后再求值。</p><p>隐式类型转换发生场景</p><ol><li>在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。</li><li>在条件中，非布尔类型转换为布尔类型。</li><li>初始化过程中，初始值转换为变量的类型。在赋值语句中，右侧对象转换为左侧运算对象类型</li><li>算术或者关系运算对象有多种类型，需要转换为同一种类型</li><li>函数调用时会发生类型转换</li></ol><h3 id="算术转换"><a href="#算术转换" class="headerlink" title="算术转换"></a>算术转换</h3><p>整数提示：char signed char、 unsigned char、 short 、unsigned short 、bool 一般会提升为int </p><p>有符号的转化为无符号的（大小相等）<br>整数转化为浮点数<br>转化为宽类型</p><h3 id="其他隐式类型转换"><a href="#其他隐式类型转换" class="headerlink" title="其他隐式类型转换"></a>其他隐式类型转换</h3><ol><li>数组转成指针： 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作decltyoe关键字参数，或者取地址&amp;，sizeof及typeid等运算对象时，上述转化不会发生。如果用引用初始化数组，也不会发生转化。</li><li>指针的转化：常量整数0或者字面值nullptr能转化成任意指针类型。指向任何非常量指针能转换成void<em> 指向任何对象的指针能转化成const void </em></li><li>转换成布尔类型：存在一种从算术类型或者指针类型向布尔类型自动转化的机制，如果指针或算术类型值为0，转换结果是false，否则转换结果是true。</li><li>转换成常量：允许冲非常量类型的指针转化为常量类型的指针。</li><li>命名的强制类型转换。</li></ol><p>static_cast：任何具有明确定义的类型转化，只要不包含底层const，都可以使用<br>const_cast：只能改变运算对象的底层const<br>reinterpret_cast: 通常为运算对象的位模式提供较底层次上的重新解释。</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><table><thead><tr><th>结合律</th><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>左</td><td>::</td><td>全局作用域</td><td>::name</td></tr><tr><td>左</td><td>::</td><td>类作用域</td><td>class::name</td></tr><tr><td>左</td><td>::</td><td>命名空间作用域</td><td>namespace::name</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>.</td><td>成员选择</td><td>object.member</td></tr><tr><td>左</td><td>-&gt;</td><td>成员选择</td><td>pointer-&gt;member</td></tr><tr><td>左</td><td>[]</td><td>下标</td><td>expr[expr]</td></tr><tr><td>左</td><td>()</td><td>函数调用</td><td>name(expr_lit)</td></tr><tr><td>左</td><td>()</td><td>类型构造</td><td>type(expr_lit)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>后置递增运算</td><td>lvalue++</td></tr><tr><td>右</td><td>–</td><td>后置递减运算</td><td>lvalue–</td></tr><tr><td>右</td><td>typeid</td><td>类型ID</td><td>typeid(type)</td></tr><tr><td>右</td><td>typeid</td><td>运行时类型ID</td><td>typeid(expr)</td></tr><tr><td>右</td><td>explicit cast</td><td>类型转换</td><td>cast_name<type>(expr)</type></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>++</td><td>前置递增运算</td><td>++lvalue</td></tr><tr><td>右</td><td>–</td><td>前置递减运算</td><td>–lvalue</td></tr><tr><td>右</td><td>~</td><td>位求反</td><td>~expr</td></tr><tr><td>右</td><td>!</td><td>逻辑非</td><td>!expr</td></tr><tr><td>右</td><td>-</td><td>一元负号</td><td>-expr</td></tr><tr><td>右</td><td>+</td><td>一元正号</td><td>+expr</td></tr><tr><td>右</td><td>*</td><td>解引用</td><td>*expr</td></tr><tr><td>右</td><td>&amp;</td><td>取地址</td><td>&amp;lvalue</td></tr><tr><td>右</td><td>()</td><td>类型转换</td><td>(type)expr</td></tr><tr><td>右</td><td>sizeof</td><td>对象大小</td><td>sizeof expr</td></tr><tr><td>右</td><td>sizeof</td><td>类型大小</td><td>sizeof(type)</td></tr><tr><td>右</td><td>Sizeof…</td><td>参数包的大小</td><td>sizeof…(name)</td></tr><tr><td>右</td><td>new</td><td>创建对象</td><td>new type</td></tr><tr><td>右</td><td>new []</td><td>创建数组</td><td>new type[size]</td></tr><tr><td>右</td><td>delete</td><td>释放对象</td><td>delete expr</td></tr><tr><td>右</td><td>delete []</td><td>释放数组</td><td>delete [] expr</td></tr><tr><td>右</td><td>noexcept</td><td>能否抛出异常</td><td>noexcept(expr)</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>-&gt;*</td><td>指向成员选择的指针</td><td>ptr-&gt;*prt_to_member</td></tr><tr><td>左</td><td>.*</td><td>指向成员选择的指针</td><td>obj.*prt_to_member</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*</td><td>乘法</td><td>expr*expr</td></tr><tr><td>左</td><td>/</td><td>除法</td><td>expr/expr</td></tr><tr><td>左</td><td>%</td><td>取模（取余）</td><td>expr%expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>+</td><td>加法</td><td>expr + expr</td></tr><tr><td>左</td><td>-</td><td>减法</td><td>expr -expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;&lt;</td><td>向左移位</td><td>expr &lt;&lt; expr</td></tr><tr><td>左</td><td>&gt;&gt;</td><td>向右移位</td><td>expr &gt;&gt; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&lt;</td><td>小于</td><td>expr &lt; expr</td></tr><tr><td>左</td><td>&lt;=</td><td>小于等于</td><td>expr &lt;=expr</td></tr><tr><td>左</td><td>&gt;</td><td>大于</td><td>expr &gt; expr</td></tr><tr><td>左</td><td>&gt;=</td><td>大于等于</td><td>expr &gt;= expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>==</td><td>相等</td><td>expr == expr</td></tr><tr><td>左</td><td>!=</td><td>不相等</td><td>expr != expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;</td><td>位与</td><td>expr &amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>^</td><td>位异或</td><td>expr ^ expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td>`</td><td>位或</td><td>`expr</td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>&amp;&amp;</td><td>逻辑与</td><td>expr &amp;&amp; expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>`</td><td></td><td>`</td><td>逻辑或</td><td>`expr</td><td></td><td>expr`</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>?:</td><td>条件</td><td>expr?expr:expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>=</td><td>赋值</td><td>lvalue = expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>*=,/-,%=</td><td>符合赋值</td><td>lvalue+=expr等</td></tr><tr><td>左</td><td>+=,-=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&lt;&lt;=,&gt;&gt;=</td><td>符合赋值</td><td></td></tr><tr><td>左</td><td>&amp;=,`</td><td>=`,^=</td><td>符合赋值</td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>右</td><td>throw</td><td>抛出异常</td><td>throw expr</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>左</td><td>,</td><td>逗号</td><td>expr,expr</td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础&lt;/li&gt;
&lt;li&gt;算术运算符&lt;/li&gt;
&lt;li&gt;逻辑和关系运算符&lt;/li&gt;
&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;li&gt;递增和递减运算符&lt;/li&gt;
&lt;li&gt;成员访问运算符&lt;/li&gt;
&lt;li&gt;条件运算符&lt;/li&gt;
&lt;li&gt;位运算符&lt;/li&gt;
&lt;li&gt;sizeof运算符&lt;/li&gt;
&lt;li&gt;逗号运算符&lt;/li&gt;
&lt;li&gt;类型转换运算符&lt;/li&gt;
&lt;li&gt;运算符优先级&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;运算符优先级大概层级：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用域运算符&lt;/li&gt;
&lt;li&gt;成员选择、下标、函数调用&lt;/li&gt;
&lt;li&gt;后置加加减减、类型id，类型转化&lt;/li&gt;
&lt;li&gt;一元运算符&lt;/li&gt;
&lt;li&gt;乘法&lt;/li&gt;
&lt;li&gt;加法&lt;/li&gt;
&lt;li&gt;移位&lt;/li&gt;
&lt;li&gt;关系&lt;/li&gt;
&lt;li&gt;位&lt;/li&gt;
&lt;li&gt;逻辑&lt;/li&gt;
&lt;li&gt;条件&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;逗号&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第四章 表达式" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="表达式" scheme="http://yoursite.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>字符串、向量、数组</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/</id>
    <published>2018-08-10T04:07:12.000Z</published>
    <updated>2018-08-14T09:02:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>命令空间的using声明</li><li>标准库类型string</li><li>标准库类型vector</li><li>迭代器介绍</li><li>数组</li><li>多维数组</li></ol><p>基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。</p><a id="more"></a><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>std::cin中作用域运算符的含义：编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。</p><p>using声明的形式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure><p>using 声明每次只能引入一个名字。using 声明必须以分号结束。</p><p>头文件不应该包括using声明。</p><h2 id="标准库string"><a href="#标准库string" class="headerlink" title="标准库string"></a>标准库string</h2><p>C++标准一方面对库类型所提供的操作做了详细的规定、另一方面也对库的实现者做了性能的要求。</p><h3 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h3><p>如何初始化对象由类的本身决定的。</p><p>初始化sting对象的方式</p><table><thead><tr><th>初始化形式</th><th>说明</th></tr></thead><tbody><tr><td>string s1</td><td>默认初始化，s1是空串</td></tr><tr><td>string s2(s1)</td><td>s2是s1的一个副本</td></tr><tr><td>string s2= s1</td><td>等价于s2(s1)</td></tr><tr><td>string s3(“value”)</td><td>s3是字面值value的副本，除了字面值最后的那个空字符外</td></tr><tr><td>string s3 = “value”</td><td>等价于s3(“value”)</td></tr><tr><td>string s4(n,’c’)</td><td>初始化为连续n个字符c组成的字符串</td></tr></tbody></table><h4 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h4><ol><li>拷贝初始化（copy initialization）：使用等号（=）初始化一个变量</li><li>直接初始化：不用等号</li></ol><p>当初始值只有一个时，使用直接初始化和拷贝初始化都行，如果用到多个初始值，一般来说只能直接初始化。如果非要用拷贝初始化也可以，需要显示的创建一个临时对象用于拷贝。</p><h3 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h3><p>一个类除了规定初始化对象的方式外，还要定义对象上所能执行的操作。</p><table><thead><tr><th>操作示例</th><th>说明</th></tr></thead><tbody><tr><td>os&lt;&lt;s</td><td>将s写到输出流os当中，返回os</td></tr><tr><td>is&gt;&gt;s</td><td>从is中读取字符串赋给s，字符串以空白介绍，返回s</td></tr><tr><td>getline(is,s)</td><td>从is中读取一行赋给s，返回is</td></tr><tr><td>s.empty</td><td>s为空返回true，否则返回false</td></tr><tr><td>s.size</td><td>返回s中字符的个数</td></tr><tr><td>s[n]</td><td>返回s中第n个字符的引用</td></tr><tr><td>s1+s2</td><td>返回s1、s2连接后的结果</td></tr><tr><td>s1=s2</td><td>用s2的副本代替s1中原来的字符</td></tr><tr><td>s1 == s2</td><td>如果s1和s2所含的字符完全一样，则他们相等</td></tr><tr><td>s1 != s2</td><td></td></tr><tr><td>&lt;,&lt;=,&gt;,&gt;=</td><td>利用字符在字典中的顺序进行比较</td></tr></tbody></table><h4 id="读取string对象"><a href="#读取string对象" class="headerlink" title="读取string对象"></a>读取string对象</h4><p>string对象会自动忽略开头的空白（空格，换行、制表符）并从第一个真正的字符开始算起，知道遇到下一处空白为止。</p><p>sting对象的此类输入输出操作返回运算符左侧的运算对象，所以，如果多个输入或者多个输出可以连在一起写。</p><h4 id="使用getline读取一行"><a href="#使用getline读取一行" class="headerlink" title="使用getline读取一行"></a>使用getline读取一行</h4><p>getline函数从给定的输入流中读入内容，直到遇到换行符为止，换行符的内容也被读入进来。然后将所读的内容从存入到string中。</p><p>触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。</p><h4 id="string的empty、size操作"><a href="#string的empty、size操作" class="headerlink" title="string的empty、size操作"></a>string的empty、size操作</h4><p>size返回的是string:size_type</p><p>string的相等意味着长度相同，且所包含的字符也完全相等。</p><p>当把string对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个加法的两侧的运算符对象至少有一个是string。</p><h3 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h3><p>cctype头文件中定义了一组标准函数处理字符：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>isalnum(c)</td><td>当c是字母或数字时为真</td></tr><tr><td>isalpha(c)</td><td>当c是字母时为真</td></tr><tr><td>iscntrl(c)</td><td>当c是控制字符时为真</td></tr><tr><td>isdigit(c)</td><td>当c是数字时为真</td></tr><tr><td>isgraph(c)</td><td>当c不为空格，单可打印时为真</td></tr><tr><td>islower(c)</td><td>当c是小写字母时为真</td></tr><tr><td>isprint(c)</td><td>当c是可打印字符时为真，空格，可视字符</td></tr><tr><td>ispunct(c)</td><td>当c是标点符号时为真</td></tr><tr><td>isspace(c)</td><td>当c是空白时为真(空格、制表符、回车、换行、进制符)</td></tr><tr><td>issupper(c)</td><td>当c是大写字母时为真</td></tr><tr><td>isxdigit(c)</td><td>当c是十六进制数字时为真</td></tr><tr><td>tolower(c)</td><td>如果c是大写字母，输出对应的小写字母，否则原样输出</td></tr><tr><td>toupper(c)</td><td>如果c是小写字母，输出对应的大小字母，否则原因输出</td></tr></tbody></table><p>c语言的头文件形如name.h，在C++中将这些文件命名为cname，也就是去掉了.h后缀，在name名字前添加了字母c，这里的c表示是一个属于c语言标准库的头文件。cnmae的头文件中定义的明智属于命名空间std。而定义在.h的名字则不在。</p><h4 id="范围for语句（range-for）"><a href="#范围for语句（range-for）" class="headerlink" title="范围for语句（range for）"></a>范围for语句（range for）</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : <span class="type">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>其中expression部分是一个对象，表示序列。declaration是定义一个变量，用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">auto</span> c : str)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">///对字符串c的每个字符c做某种操作</span></span><br></pre></td></tr></table></figure><p>如果想改变string对象中的字符的值，必须把循环变量定义成引用类型。这个变量实际上绑定到序列中的每个元素。</p><p>下标运算符：通过位置，返回该位置上字符的引用。 使用超出下标范围将引发不可预知的结果，使用下标访问空string也引发不可预知结果。</p><p>不管什么时候，只要对string对象使用下标，都要确认在那个位置上确实有值。</p><p>只要字符串不为常量，就能为下标运算符返回的字符串赋新值。</p><h2 id="标准库vector"><a href="#标准库vector" class="headerlink" title="标准库vector"></a>标准库vector</h2><p>标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，索引可以访问对象。因为vector“容纳着”其他对象，所以，所以他被称为容器（container）。</p><p>模板本身不是类或者函数，相反，可以看做是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称为<code>实例化</code>（instantiation），当使用模板时，需要指出编译器应把类或者函数实例化成何种形式。</p><p>提供信息的方式：即在类模板名字后面跟一对尖括号，括号内放类型信息。</p><p>vector是模板，而不是类。</p><h3 id="定义、初始化vector对象"><a href="#定义、初始化vector对象" class="headerlink" title="定义、初始化vector对象"></a>定义、初始化vector对象</h3><p>|初始化示例|说明|<br>|vector<t> v1| v1是一个空vector，他潜在的元素是T类型，执行默认初始化|<br>|vector<t> v2(v1)|v2中包含v1所有元素副本|<br>|vector<t> v2 = v1|等价于v2(v1)|<br>|vector<t> v3(n,val)|v3包含那个重复的元素。每个元素的值是val|<br>|vector<t> v4(n)|v4 包含了n个重复的执行了值初始化的元素|<br>|vector<t> v5{a,b,c,…}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值|<br>|vector<t> v5 = {a,b,c,…}|等价于v5{a,b,c,…}|</t></t></t></t></t></t></t></p><p><strong>列表初始化</strong>vector对象。</p><p>值初始化：通常情况下，可以只提供vector对象容纳元素数量，而略去初始值，此时，库会创建一个值初始化的元素初值，并且把它赋值给容器中所有元素。这个初始值由vector元素类型决定。</p><p>如果是内置类型，如int，元素初始值自动设置为0，如果是类类型，比如string，元素由类默认初始化。</p><p>如果只提供元素的数量而没有设定初始值，只能使用直接初始化。不让就是将数量拷贝给string对象了。</p><p>初始化过程中，尽可能地把花括号内的值当做是元素初始值列表处理，但是如果花括号形式所提供的值不能进行列表初始化，就要考虑用这样的值构造vector对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125; <span class="comment">//列表初始化，v5有一个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6(<span class="string">"hi"</span>); <span class="comment">//错误不能构建</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;   <span class="comment">//v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>,<span class="string">"hi"</span>&#125;; <span class="comment">//v8有10个值为“hi” 的元素</span></span><br></pre></td></tr></table></figure><p> 在确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。</p><h3 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h3><p>vector对象能高效的增长，如果初始化的时候指定大小，可能效率会低。</p><p>范围for循环体内不应改变其所遍历序列的大小。</p><h3 id="其他vector操作"><a href="#其他vector操作" class="headerlink" title="其他vector操作"></a>其他vector操作</h3><table><thead><tr><th>vector操作</th><th>说明</th></tr></thead><tbody><tr><td>v.empty()</td><td>如果v不含有任何元素，返回真，否则，返回假</td></tr><tr><td>v.size()</td><td>返回v中元素个数</td></tr><tr><td>v.push_back(t)</td><td>向v的尾部添加一个值为t的元素</td></tr><tr><td>v[n]</td><td>返回v中第n个位置上元素的引用</td></tr><tr><td>v1 = v2</td><td>用v2中元素的拷贝替换v1中的元素</td></tr><tr><td>v1 = {a,b,c…}</td><td>用列表中元素的拷贝替换v1中的元素</td></tr><tr><td>v1== v2</td><td>元素数目相同、对应位置上的元素值相同</td></tr><tr><td>v1 != v2</td><td></td></tr><tr><td>&lt; ,&lt;=, &gt; ,&gt;=</td><td>以字典的顺序进行比较</td></tr></tbody></table><p>vector对象的类型总是包含元素的类型。只有当元素的类型可以比较时，vector对象才能比较。vector可以使用下标读写元素，不能通过下标添加元素。<br>只能对已经存在的元素</p><p>缓冲区溢出（buffer overflow） 就是指的下标越界这类错误。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>类似指针类型，迭代器提供了对对象的间接访问。就迭代器而言，其对象是容器中元素或者string对象中的字符。</p><p>和指针不同，获取迭代器不是使用取地址符，有迭代器的类型，同时拥有返回迭代器的成员。比如begin、end成员。</p><ol><li>begin成员负责返回指向第一个元素的迭代器。</li><li>end成员负责返回指向容器 <strong>尾元素的下一个位置</strong>的迭代器。</li><li>end成员返回的迭代器通常称为尾后迭代器。</li><li>如果容器为空，则begin、end返回的是同一个迭代器。都是尾后迭代器。</li></ol><h3 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h3><p>迭代器的运算符如下：</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>*iter</td><td>返回迭代器所指元素的引用</td></tr><tr><td>iter-&gt;mem</td><td>解引用iter并获取该元素的名为mem的成员，等价于(*iter)-&gt;mem</td></tr><tr><td>++iter</td><td>令iter指示容器的下一个元素</td></tr><tr><td>–iter</td><td>令iter指示容器的上一个元素</td></tr><tr><td>iter1 == iter2</td><td>判断两个元素是否相等，如果两个迭代器指示的是同一个元素，或者他们是同一个容器的尾后迭代器，则他们相等，否则不行等</td></tr><tr><td>iter1 != iter2</td></tr></tbody></table><p>指针和迭代器的相同点：</p><ol><li>可以解引用来获取它所指元素</li><li>也有有效和无效之分，有效：迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他所有情况都无效</li><li>提供了对对象的间接访问</li><li>都可以移动到下一个元素、上一个元素</li><li>视图解引用非法迭代器或者尾后迭代器都是未定义的，  解引用非法指针也是非法的</li></ol><p>指针和迭代器的不同点：</p><ol><li>获取方式不同，指针：取地址； 迭代器：通过容器的成员。</li></ol><p>迭代器使用实例</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string </span>s(<span class="string">"some string"</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">if</span>(s.<span class="keyword">begin() </span>!= s<span class="meta">.end</span>())</span><br><span class="line">&#123;</span><br><span class="line">auto <span class="keyword">it </span>= s.<span class="keyword">begin();</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= touper(*<span class="keyword">it);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>因为end返回的迭代器并不实际指示元素，所以不能对其进行递增或者解引用的操作。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">for</span>(auto <span class="keyword">it </span>= s.<span class="keyword">begin(); </span><span class="keyword">it </span>!= s<span class="meta">.end</span>() &amp;&amp; !isspace(*<span class="keyword">it); </span>++<span class="keyword">it)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"></span>*<span class="keyword">it </span>= toupper(*<span class="keyword">ite);</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure><p>只有string、vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库的迭代器都定义了==、!=，但是他们中的大多数没有定义&lt; 运算符，因此， 我们要养成使用迭代器和!=运算符的习惯。</p><p>实际上，那些拥有迭代器的标准库使用iterator、const_iterator表示迭代器类型。</p><p>const_iterator和常量指针差不多。能读取，不能修改。</p><p>如果vector、string对象是一个常量，只能使用const_iterator，如果vector、string不是常量，既能使用iterator，也能使用const_iterator</p><p>begin和end运算符： begin和end返回的具体类型由对象是否常量觉得，如果对象是常量，begin和end返回const_iterator，如果不是，返回iterator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt; v2;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v1.begin(); <span class="comment">//iter1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = v2.begin(); <span class="comment">//iter2 的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>cbegin()、cend() 返回const_iterator类型迭代器。</p><p>箭头-&gt;运算符将解引用和成员访问两个操作结合在一起。也就是it-&gt;mem和(*it).mem表达式的意思相同。</p><p>凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。</p><h3 id="迭代器运算"><a href="#迭代器运算" class="headerlink" title="迭代器运算"></a>迭代器运算</h3><table><thead><tr><th>迭代器运算</th><th>说明</th></tr></thead><tbody><tr><td>iter + n</td><td>迭代器加上整数值，扔是一个迭代器类型。迭代器指示的新位置与原来的位置相比，向前移动了n个元素。结果迭代器或者指向容器的下一个元素，或者指向容器尾元素的下一个位置</td></tr><tr><td>iter - n</td><td></td></tr><tr><td>iter += n</td><td></td></tr><tr><td>iter1= n</td><td></td></tr><tr><td>iter 1 - iter2</td><td></td></tr><tr><td>&lt;, &lt;=, &gt;,&gt;=</td></tr></tbody></table><p>两个迭代器的间距的类型是diffrence 类型。带符号的。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义、初始化内置数组"><a href="#定义、初始化内置数组" class="headerlink" title="定义、初始化内置数组"></a>定义、初始化内置数组</h3><p>数组中元素的个数也属于数组类型的一部分，编译的时候纬度应该已知。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *parr[<span class="number">10</span>]  ; <span class="comment">//含有10个整形指针的数组。</span></span><br></pre></td></tr></table></figure><p>默认情况下，数组的元素被默认初始化。和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。</p><p>定义数组的时候必须指定数组的类型。不允许使用auto关键字由初始值的列表来推断类型。</p><p>可以对数组的元素进行列表初始化，此时，允许忽略数组的纬度。如果声明时没有指定纬度，编译器会根据初始值的数量计算并推断出来，如果指定了维度，那么初始值的总数量不应该超过指定的大小。</p><p>字符数组的特殊性： 一定要注意，字符串字面值的结尾还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="keyword">a</span>[] = <span class="string">"C++"</span> ;<span class="comment"> // 容量4</span></span><br></pre></td></tr></table></figure><p>不能讲数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">int a2[] = a; <span class="comment">//错误不能用一个数组初始化另一个数组</span></span><br><span class="line">a2 =a; <span class="comment">//错误不能把一个数组赋值给另一个数组</span></span><br></pre></td></tr></table></figure><p>理解复杂数组声明</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">ptrs</span><span class="selector-attr">[10]</span>; <span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">&amp;</span><span class="selector-tag">refs</span><span class="selector-attr">[10]</span>; <span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (*parray)<span class="selector-attr">[10]</span>; <span class="comment">//parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="selector-tag">int</span> (&amp;arrRef)<span class="selector-attr">[10]</span>;<span class="comment">//parray引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure><p>对数组而言，由内向外阅读比较合适。parray是一个指针，指向一个含有10个元素的数组，数组的元素类型是整形。</p><h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>数组的特性：在很多用到数组名字的地方，编译器都会自动的将其替换为一个指向数组首元素的指针。<br>当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。</p><p>decltype不会执行数组到指针的转化。</p><p>指针也是迭代器</p><p>标注库函数begin、end。由于数组不是类类型，因此这两个函数不是成员函数。begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一个位置的指针。</p><p>尾后迭代器不能执行解引用和递增操作。</p><p>两个指针递减的结果类型是一种名为ptrdiff_t的标准库类型。定义在cstddef头文件中。</p><p>很多情况下，使用数组的名字，其实用的是一个指向数组首元素的指针。</p><p>内置下标运算符所用的索引值不是无符号类型，这一点和vector和string不一样。</p><h3 id="C分格字符串"><a href="#C分格字符串" class="headerlink" title="C分格字符串"></a>C分格字符串</h3><table><thead><tr><th>c分格字符串的函数</th><th>说明</th></tr></thead><tbody><tr><td>strlen()</td><td>返回p的长度，空字符不计算在内</td></tr><tr><td>strcmp(p1,p2)</td><td>比较p1、p2的相等性，如果p1==p2 返回0，如果p1&gt;p2，返回一个正值，如果p1&lt;p2,返回一个负值</td></tr><tr><td>strcat(p1,p2)</td><td>将p2附加到p1之后，返回p1</td></tr><tr><td>strcpy(p1,p2)</td><td>将p2拷贝给P1，返回p1</td></tr></tbody></table><p>当使用数组的时候其实真正用的是指向数组首元素的指针。所以比较字符串实际上比较的是指针。</p><h3 id="与旧代码的接口"><a href="#与旧代码的接口" class="headerlink" title="与旧代码的接口"></a>与旧代码的接口</h3><ol><li>允许使用 以空字符结束的字符数组来初始哈动态string对象或者为string对象赋值</li><li>在string对象的加法运算中，允许使用空字符结束的字符数组作为其中一个运算对象。</li></ol><p>string对象的c_str函数返回一个C风格的字符串。</p><p>可以使用数组初始化vector对象。</p><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>严格来说，C++语言没有多维数组，通常所说的多维数组其实是数组的数组。</p><p>要使用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。<br>类型别名简化多维数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_ary = <span class="keyword">int</span>[<span class="number">4</span>];  <span class="comment">//int_ary 是含有4个整型元素的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_ary[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;命令空间的using声明&lt;/li&gt;
&lt;li&gt;标准库类型string&lt;/li&gt;
&lt;li&gt;标准库类型vector&lt;/li&gt;
&lt;li&gt;迭代器介绍&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;多维数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第三章 字符串、向量、数组" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84/"/>
    
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>特殊工具和技术</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/</id>
    <published>2018-08-02T01:07:12.000Z</published>
    <updated>2018-08-02T11:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="控制内存"><a href="#控制内存" class="headerlink" title="控制内存"></a>控制内存</h2><h3 id="重载new和delete"><a href="#重载new和delete" class="headerlink" title="重载new和delete"></a>重载new和delete</h3><p>当我们使用new表达式时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> * sp = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"a string"</span>);</span><br><span class="line"><span class="built_in">string</span> * arr = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>实际执行了三步：</p><ol><li>new 表达式调用 operator new 或operator new [] 标准库，分配一块足够大、原始的、未命名的内存空间。</li><li>编译器运行相应的构造函数，并传入初始值。</li><li>返回一个指向该对象的指针。</li></ol><p>当我们使用delete表达式时</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> sp;</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure><ol><li>调用析构函数</li><li>调用名为operator delete 或者operator delete [] 释放空间。</li></ol><p>发现new、delete表达式，如果对象是类类型，首先在类类型中查找，然后是全局作用域。也可以使用::new直接使用全局作用域的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="keyword">size_t</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>*)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="keyword">void</span>*) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>类作用域的new、delete是静态的。因为operator new 用在对象构造之前，operator delete 用在对象销毁后。而且不能操作类的任何成员。</p><p>new表达式和 operator new 函数：不能改变new表达式、delete表达式的含义。</p><p>malloc函数接受一个表示带分配字节数的size_t，返回指向分配空间的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">void</span>* mem = <span class="built_in">malloc</span>(size))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">throw</span> bad_alloc();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* mem)</span> <span class="keyword">noexcept</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">free</span>(mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定位new表达式"><a href="#定位new表达式" class="headerlink" title="定位new表达式"></a>定位new表达式</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new (place_address) type</span><br><span class="line">new (place_address)<span class="built_in"> type </span>(initializers)</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size]</span><br><span class="line">new (place_address)<span class="built_in"> type </span>[size] &#123;braced initializer list&#125;</span><br></pre></td></tr></table></figure><p>定位new 使用 operation new (size_t ,void *)函数<br>定位new 可以构造对象，单不分配内存</p><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>allcator</td></tr><tr><td>allocate</td><td>construct</td></tr><tr><td>destroy</td><td>deallocate</td></tr></tbody></table><table><thead><tr><th>申请释放空间</th><th>构造销毁对象</th></tr></thead><tbody><tr><td>new的形式</td></tr><tr><td>operator new</td><td>构造函数（定位new可以只构造对象，不申请空间）</td></tr><tr><td>free</td><td>析构函数（可以直接调用）</td></tr></tbody></table><h2 id="运行时类型识别"><a href="#运行时类型识别" class="headerlink" title="运行时类型识别"></a>运行时类型识别</h2><ol><li>typeid 运算符，返回表达式的类型</li><li>dynamic_cast运算符 用于将基类指针或引用安全的转化为派生类的指针或者引用</li></ol><p>当操作被定义为虚函数时，编译器将根据对象的动态类型自动的选择正确的版本 。</p><ol><li>dynamic_cast<type*> (e)</type*></li><li>dynamci_cast<type&> (e)</type&></li><li>dynamic_cast<type&&> (e)</type&&></li></ol><p>当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。</p><p>type_info 类的name成员函数返回一个C风格的字符串，表示对象的类型名字。type_info 只能通过typeid运算符创建。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型使我们可以将一组整形常量组织在一起。 </p><ol><li>限定作用域</li><li>不限定作用域</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> 枚举名 &#123; 逗号分隔的枚举列表&#125;;</span></span><br></pre></td></tr></table></figure><p>枚举值可以不唯一，枚举成员是常量表达式。</p><p>和类一样，枚举也定义新的类型，也能定义变量。enum对象赋值必须使用该类型的一个枚举成员，或该类型的另一个对象。</p><p>指定enum的大小</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">intValue</span> : <span class="title">unsigned</span> <span class="title">long</span> <span class="title">long</span> </span></span><br><span class="line">&#123;&#125;;</span><br></pre></td></tr></table></figure><p>枚举类型的前置声明</p><h2 id="类成员指针"><a href="#类成员指针" class="headerlink" title="类成员指针"></a>类成员指针</h2><p>成员指针，是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员。</p><p>成员指针的类型囊括了类的类型、成员的类型。当初始化一个这样的指针时，我们另其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。</p><h3 id="数据成员指针"><a href="#数据成员指针" class="headerlink" title="数据成员指针"></a>数据成员指针</h3><p>声明成员指针时，必须包含成员所属的类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> className:: * pdata;</span><br><span class="line">pdata = &amp;Screen::contents <span class="comment">//指向某个非特定Screen对象的contents成员</span></span><br></pre></td></tr></table></figure><p>当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员，而非该成员所属的对象。只有当解引用成员指针时，我们才提供对象的信息。 也就是解引用时候绑定到特定的对象上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> Screen::*  data()</span><br><span class="line">&#123;</span><br><span class="line">retrun &amp;Screen::contents;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// data 指向Screen类const string 成员指针。</span></span><br></pre></td></tr></table></figure><h3 id="成员函数指针"><a href="#成员函数指针" class="headerlink" title="成员函数指针"></a>成员函数指针</h3><p><code>char (Screen::*pmf2)(int,int ) const;</code></p><h3 id="将成员函数用作可调用对象"><a href="#将成员函数用作可调用对象" class="headerlink" title="将成员函数用作可调用对象"></a>将成员函数用作可调用对象</h3><p>成员函数指针不是可调用对象，调用前必须使用.<em>或者-&gt;</em>绑定到特定对象上。所以不能直接将成员函数指针传递给算法。</p><font color="red"><br>以下内容无法理解：<br><br>1. 可以使用function生成一个可调用对象。<br>2. 可以使用mem_fn生成一个可调用对象。<br>3. 使用bind 生成一个可调用对象。<br><br></font><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>一个类可以定义在另一个类的内部，前者称为嵌套类（nested class） ，后者称为嵌套类型（nested type）。</p><p>嵌套类是一个独立的类，与外层基本没有什么关系，特别是，外层类对象和嵌套类对象是相互独立的，嵌套类的对象不能包括任何外层类定义的成员；类似的，在外层类的对象也不能报考任何嵌套类定义的成员。嵌套类的名字在外层作用域内是可见的。之外不可见。 嵌套类对外层类的成员也没有特殊的访问权限。</p><h2 id="union-一种节省空间的类"><a href="#union-一种节省空间的类" class="headerlink" title="union 一种节省空间的类"></a>union 一种节省空间的类</h2><p>union可以定义多个数据成员，但在任何时刻，只有一个数据成员可以有值。union可以定义包括构造函数和析构函数在内的成员函数。但union不能继承自其它类，也不能作为基类使用。 不能有虚函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;控制内存&quot;&gt;&lt;a href=&quot;#控制内存&quot; class=&quot;headerlink&quot; title=&quot;控制内存&quot;&gt;&lt;/a&gt;控制内存&lt;/h2&gt;&lt;h3 id=&quot;重载new和delete&quot;&gt;&lt;a href=&quot;#重载new和delete&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十九章特殊工具和技术" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="特殊工具和技术" scheme="http://yoursite.com/tags/%E7%89%B9%E6%AE%8A%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>变量和基本类型</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-08-13T05:59:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。</p><p>主要内容 ：</p><ol><li>基本内置类型</li><li>变量</li><li>复合类型</li><li>const限定符</li><li>处理类型</li><li>自定义数据类型</li></ol><a id="more"></a><h2 id="基本内置类型"><a href="#基本内置类型" class="headerlink" title="基本内置类型"></a>基本内置类型</h2><p>C++ 定义了一套包括算术类型和空类型的基本数据类型。</p><p>算术类型：</p><table><thead><tr><th>类型</th><th>含义</th><th>最小尺寸</th></tr></thead><tbody><tr><td>bool</td><td>布尔类型</td><td>未定义</td></tr><tr><td>char</td><td>字符</td><td>8位</td></tr><tr><td>wchar_t</td><td>宽字符</td><td>16位</td></tr><tr><td>char16_t</td><td>Unicode字符</td><td>16</td></tr><tr><td>char32_t</td><td>Unicode字符</td><td>32</td></tr><tr><td>short</td><td>短整形</td><td>16</td></tr><tr><td>int</td><td>整形</td><td>16</td></tr><tr><td>long</td><td>长整形</td><td>32</td></tr><tr><td>long long</td><td>长整形</td><td>64</td></tr><tr><td>float</td><td>单精度浮点数</td><td>6位有效数字</td></tr><tr><td>double</td><td>双精度浮点数</td><td>10位有效数字</td></tr><tr><td>long double</td><td>扩展精度浮点数</td><td>10 位有效数字</td></tr></tbody></table><ol><li>寻址的最小内存块为 <strong>字节(byte)</strong> 大多数的字节由8个bit构成。</li><li>存储的基本单元称为 <strong>字(word) </strong>一般32或64bit。</li></ol><p>通常，float一个字，double两个字，long double4个字，类型float和double 分别有<strong>7</strong>个和<strong>16</strong>个有效位。</p><p>与其他类型不同，字符型被分为三种：char、signed char 、 unsigned char。char 和signed char 并不是一种，尽管类型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种的一种，具体由编译器决定。</p><p>如何选择类型：</p><ol><li>在算术表达式中不要使用char 、bool 只有在存放字符或者bool值时候才使用它们，因为类型char在一些机器上有符号，而在另外一些机器上又是无符号的，所以，如果使用char 进行运算特别容易出问题。如果使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。</li><li>执行浮点运算选用double，这是因为float通常进度不够。对于某些机器，双精度运算甚至比单精度还快。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>当给某种类型的对象强制赋予了另一种类型的值时，到底发生了什么？</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool </span><span class="keyword">b </span>= <span class="number">42</span><span class="comment">;</span></span><br><span class="line">int i = <span class="keyword">b </span><span class="comment">; ///i的值时1</span></span><br></pre></td></tr></table></figure><ol><li>当把一个非布尔类型的算术值赋给布尔类型时，初始值0是false，否则为true。</li><li>当把一个布尔值赋值给非布尔类型时，初始值false 是0，true是1.</li><li>浮点数赋值给整数类型时，进行近视处理，保留小数部分之前的。</li><li>将超出范围的值赋值给无符号类型：结果是初始值对无符号类型表示的总数取模后的余数。</li><li>将超出范围的值赋给带符号类型，结果未定义。</li></ol><h3 id="含有无符号类型的表达式"><a href="#含有无符号类型的表达式" class="headerlink" title="含有无符号类型的表达式"></a>含有无符号类型的表达式</h3><p><font color="red"></font></p><ol><li>无符号数递减不能是负值，如果为负值，会是取模的余数。</li><li>切勿混用带符号和无符号类型。如果表达式里面既有带符号的，又有无符号的，带符号的数会转化为无符号的数。<br><h3 id="字面值常量"><a href="#字面值常量" class="headerlink" title="字面值常量"></a>字面值常量</h3></li></ol><table><thead><tr><th>字面常量</th><th>进制</th></tr></thead><tbody><tr><td>20</td><td>十进制</td></tr><tr><td>024</td><td>八进制</td></tr><tr><td>0x14</td><td>十六进制</td></tr></tbody></table><ol><li>字面值常量的类型是能容纳该数值的尺寸最小的那个（int long， long long），默认是带符号的。类型short没有对应的字面值。浮点型字面值类型是double。</li><li><strong>字符串字面值的类型实际上是由常量字符构成的数组，末尾添加‘\0’。</strong></li><li><strong>如果两个字符串字面值位置紧邻且仅由空格，缩进、换行符分隔，则他们实际上是一个整体</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a really"</span> </span><br><span class="line">              <span class="string">"that spans"</span>;</span><br></pre></td></tr></table></figure><p>有两种类型字符不能直接使用，需要转义：</p><ol><li>不可打印</li><li>特殊含义字符：单引号、双引号、问号、反斜杠</li></ol><h3 id="指定字面值的类型"><a href="#指定字面值的类型" class="headerlink" title="指定字面值的类型"></a>指定字面值的类型</h3><p>指定字符和字符串字面值：指定的方法如下表：</p><table><thead><tr><th>前缀</th><th>含义</th><th>类型</th></tr></thead><tbody><tr><td>u</td><td>Unicode 16字符</td><td>char16_t</td></tr><tr><td>U</td><td>Unicode 32 字符</td><td>char32_t</td></tr><tr><td>L</td><td>宽字符</td><td>wchar_t</td></tr><tr><td>u8</td><td>UTF-8(仅用于字符串字面常量)</td><td>char</td></tr></tbody></table><p>指定整数字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>u U</td><td>unsigned</td></tr><tr><td>l L</td><td>long</td></tr><tr><td>ll LL</td><td>long long</td></tr></tbody></table><p>指定浮点字面值</p><table><thead><tr><th>后缀</th><th>类型</th></tr></thead><tbody><tr><td>f F</td><td>float</td></tr><tr><td>l L</td><td>long double</td></tr></tbody></table><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量提供具名的、可供程序操作的存储空间。C++每个变量都有数据类型，数据类型决定着变量所占内存空间的大小、布局方式、该空间能存储的值的范围、以及变量能参与的运算。</p><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><p>基本形式：类型说明符（type specifier） + 变量名</p><p>string表示可变长字符序列  的数据类型</p><p>对象是指能存储数据并具有某种类型的存储空间。</p><p>当一次定义了两个或多个变量时，对象的名字随着定义也马上可以使用了。因此在同一条语句中，可以用先定义的变量去初始化后定义的其他变量。</p><p>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象的当前值擦除，而以一个新值来代替。</p><p>初始化的四种形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>花括号的初始化形式称为<strong>初始化列表</strong>。</p><p>初始化列表用于内置类型的变量时：<strong>如果初始值存在丢失信息的风险，编译器报错。</strong></p><p>如果定义变量时没有指定值，则变量被默认初始化（default initialized），此时变量被赋予了默认值。</p><p>函数体之外的内置变量被初始化为0；函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示初始化，则其值由类确定。</p><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明：规定了变量的类型和名字，这一点上和定义相同。<br>定义：除了规定变量的类型和名字，还申请存储空间、为变量赋一个初始值。</p><p>声明代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">//声明i，而非定义i，</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; 任何包含了显示初始化的声明既变为定义。</span><br></pre></td></tr></table></figure><p>变量能且只能别定义一次，但是可以被多次声明。</p><p>这相当于为分离式编程提供了支持</p><p>C++是一种静态类型语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查。 编译器知道每一个实体对象的类型是通过类型声明。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>用户定义的标识符不能连续出现两个下划线、不能以下划线紧连大写字母开头、定义在函数体外的标识符不能以下划线开头。</p><p>变量命名规范：</p><ol><li>标识符要能体现实际含义</li><li>变量一般用小写字母</li><li>用户定义的类名一般以大写字母开头</li><li>标识符由多个单词组成，则单词间应该有明显区分</li></ol><h3 id="名字的作用域"><a href="#名字的作用域" class="headerlink" title="名字的作用域"></a>名字的作用域</h3><p>名字的有效区域始于名字的声明语句，以声明语句所在的作用域未端为结束。</p><p>第一次使用变量时再定义变量，这样好处：</p><ol><li>更容易找到变量的定义</li><li>容易赋值合理的初始值</li></ol><ol><li>全局作用域</li><li>块作用域</li><li>嵌套作用域</li></ol><ol><li>内层作用域可以访问外层作用域中的名字</li><li>内层作用域中可以重新定义外层作用域中的名字</li><li>使用作用域运算符可以直接访问外层作用域中的名字</li></ol><h2 id="符合类型（引用、指针）"><a href="#符合类型（引用、指针）" class="headerlink" title="符合类型（引用、指针）"></a>符合类型（引用、指针）</h2><p>符合类型是基于其他类型定义的类型（compound type）</p><p>基本数据类型  + 声明符</p><p><strong>声明符</strong>命令了一个变量，并指定该变量的相关类型。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference） 为对象起了另一个名字。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;refVal = ival;</span><br></pre></td></tr></table></figure><p>一般在初始化变量时，初始值会被拷贝到新建的对象中，然而，定义引用时，程序把引用和它的初始值绑定在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此，引用必须初始化。</p><p>定义一个引用后，对其进行的所有操作都是在与之绑定的对象进行的。</p><ol><li>获取引用的值：实际上是获取了与引用绑定的对象的值。</li><li>以引用为初始值： 实际上是以与引用绑定的对象作为初始值。</li></ol><p>因为引用本身不是一个对象，所以不能定义引用的引用。</p><p>用于在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。</p><p>引用的类型要和与之绑定的对象严格匹配。引用只能绑定在一个对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>与引用类型，指针也实现了对其他对象的间接访问。</p><p>指针和引用的区别：</p><ol><li>指针本身也是对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。</li><li>指针无需在定义的时候赋值。</li></ol><p>指针存放某个对象的地址。要想获取该地址，使用取地址符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;ival;<span class="comment">//p存放变量ival的地址。 或者说p是指向变量ival的指针。</span></span><br></pre></td></tr></table></figure><p>指针的类型都要和它所指向的对象严格匹配。</p><p>指针值：指针的值（即地址）应属于下列4中转态之一：</p><ol><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置</li><li>空指针，意味着指针没有指向任何对象。</li><li>无效指针，也就是上述情况之外的其他值。</li></ol><p>解引用来访问该对象，解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p>空指针使用nullptr，新标准使用NULL，NULL是预处理变量。</p><p>如果使用了未经初始化的指针，则该指针所占内存空间的当前内容被看做是一个地址值，访问该指针，相当于去访问一个本不存在的位置上的</p><p>指针和引用都能踢动对其他对象的间接访问，然而，在具体实现细节上，二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法领其在绑定到另外的对象。之后每次使用这个引用都是访问他最初绑定的那个对象。</p><p>给指针赋值，就是令其存放一个新地址。</p><p>如果两个指针存放的地址值相同，则他们相等。</p><p>void<em> 是一种特殊的指针类型，可用于存放任何对象的地址。一个`void</em><code>指针存放着一个地址。这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象不了解。 不能直接操作</code>void*` 指针所指的对象。因为我们不知道这个对象到底是什么类型。</p><h3 id="理解符合类型"><a href="#理解符合类型" class="headerlink" title="理解符合类型"></a>理解符合类型</h3><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//p是<span class="built_in">int</span>型指针、r是一个<span class="built_in">int</span>型引用</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">int</span> *<span class="built_in">pi</span> = &amp;ival;</span><br><span class="line"><span class="built_in">int</span> **ppi = &amp;<span class="built_in">pi</span>; ///ppi指向一个<span class="built_in">int</span>型的指针</span><br></pre></td></tr></table></figure><p>ppi  -&gt; pi -&gt; ival (1024)</p><h4 id="指向指针的引用"><a href="#指向指针的引用" class="headerlink" title="指向指针的引用"></a>指向指针的引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p ;<span class="comment">//r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i; <span class="comment">//r 引用了一个指针，因此给r赋值，就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">//解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure><p>离变量名最近的符号对变量类型有最直接的影响。所以r是引用。</p><p>##const限定符</p><p>默认情况下，const对象仅仅在文件内有效。如果想在多个文件中共享const对象，就对const变量不管是声明还是定义都添加extern关键字。这样只需定义一次就可以了。</p><h3 id="const-引用"><a href="#const-引用" class="headerlink" title="const 引用"></a>const 引用</h3><p>可以把引用绑定到const 对象上，我们称为对常量的引用（refernce to const） 。一定要记住，</p><h4 id="初始化和对const的引用"><a href="#初始化和对const的引用" class="headerlink" title="初始化和对const的引用"></a>初始化和对const的引用</h4><p>引用的类型必须和其所引用对象的类型一致，但是有两个例外，第一种例外情况是初始化常量引用时允许用任何表达式作为初始值，只要改表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">//允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;  <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span> <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1* <span class="number">2</span>;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure><h4 id="对const的引用可能引用一个并非const的对象"><a href="#对const的引用可能引用一个并非const的对象" class="headerlink" title="对const的引用可能引用一个并非const的对象"></a>对const的引用可能引用一个并非const的对象</h4><p>必须认识到：常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。</p><h3 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h3><p>指向常量的指针（pointer to const） 不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; <span class="comment">//pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr  = &amp;pi;  <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi; <span class="comment">//正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>; <span class="comment">//错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure><p>指针的类型必须与其所指对象的类型一致，但是有两个例外，其中一个是：允许一个指向常量的指针指向一个非常量对象。</p><p>试试这样想吧：所谓指向常量的指针和引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以自觉的不去改变所指对象的值。</p><h4 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a>const指针</h4><p>指针是对象而引用不是，所以就像其他对象类型一样，允许指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量。即不能改变指针本身的值，而非指向的那个值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb; <span class="comment">//curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> * <span class="keyword">const</span> pip <span class="comment">//pip 是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure><p>要想弄清楚这些声明的含义，最行之有效的方法是从右向左阅读</p><h3 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层const</h3><p>指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题，用名词顶层const表示指针本身是一个常量，而用名词底层const 表示指针所指的对象是一个常量。</p><p>更一般的，顶层const可以表示任意的对象是常量，这一点对任何类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。</p><p>当执行对象的拷贝操作时，常量的顶层const还是底层const区别名下，其中顶层const不受影响：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci <span class="comment">//允许改变p2的值，底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;  <span class="comment">//正确，底层一样</span></span><br></pre></td></tr></table></figure><p>另一方面，底层const的限制不能忽视</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误，p指向的值可以通过p改变，但p指向的值是常量，所以错误</span></span><br></pre></td></tr></table></figure><h3 id="constexpr-和常量表达式"><a href="#constexpr-和常量表达式" class="headerlink" title="constexpr 和常量表达式"></a>constexpr 和常量表达式</h3><p>常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式</p><p>constexpr变量：如果认定变量是一个常量表达式，那就把它声明为constexpr类型</p><h4 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h4><p>字面值类型： 比较简单，值也显而易见，容易得到，算术类型、引用类型、指针都属于字面值类型。  string 不属于，也就不能被定义成constexpr。</p><p>函数体内定义的变量，一般来说并非存放固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于多有函数体之外的对象，其地址固定不变，能用来初始哈constexpr指针。</p><h4 id="指针和constexpr"><a href="#指针和constexpr" class="headerlink" title="指针和constexpr"></a>指针和constexpr</h4><p>在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p = <span class="literal">nullptr</span>  <span class="comment">//p是一个指向整型常量的 指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>; <span class="comment">//q是一个指向整形的向量指针。</span></span><br></pre></td></tr></table></figure><h2 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h2><p>为了简化复杂类型的定义</p><h3 id="类型别名（type-alias）"><a href="#类型别名（type-alias）" class="headerlink" title="类型别名（type alias）"></a>类型别名（type alias）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;  <span class="comment">//wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wage base,*p ;<span class="comment">// base 是double的同义词，p是double*的同义词</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">//SI 是sales_item的同义词</span></span><br></pre></td></tr></table></figure><p>using 把等号左侧的名字规定成等号右侧类型的别名。</p><h4 id="指针、常量和类型别名"><a href="#指针、常量和类型别名" class="headerlink" title="指针、常量和类型别名"></a>指针、常量和类型别名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span>* pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;<span class="comment">// cstr 是指向char的常量指针</span></span><br></pre></td></tr></table></figure><p>pstring 的基本数据类型是指针 。 不能展开，如果展开就错了</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">char</span> * <span class="built_in">cstr</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>展开就成了底层常量了</p><h3 id="auto类型说明符"><a href="#auto类型说明符" class="headerlink" title="auto类型说明符"></a>auto类型说明符</h3><p>auto让编译器通过初始值来推断变量的类型，显然，auto的定义必须有初始值。</p><ol><li>引用： 编译器以引用对象的类型作为auto的类型，希望推断引用，需要 auto &amp;</li><li>顶层const常量： 忽略，希望推断顶层const常量，需要用const auto</li><li>底层const常量： 保留</li></ol><h3 id="decltype-类型指示符"><a href="#decltype-类型指示符" class="headerlink" title="decltype 类型指示符"></a>decltype 类型指示符</h3><p>场景：希望从表达式的类型推断出要定义的变量类型，但是不想用改表达式的值初始化变量。decltype不实际计算表达式的值。</p><p>decltype处理顶层const和引用的方式与auto有些不同，如果decltyoe使用的表达式时一个表里，则decltype返回改变量的类型，包括顶层const和引用在内。</p><p>引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外。</p><p>如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此，decltype（*p）的结果类型就是int&amp;，而非int。</p><p>decltype的表达式如果是加上括号的变量，结果是引用。</p><h2 id="自定义数据结构"><a href="#自定义数据结构" class="headerlink" title="自定义数据结构"></a>自定义数据结构</h2><p>类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名，以表示该类型对象的定义，所以分号必不可少。</p><p>可以为数据成员提供一个<strong>类内初始值</strong>，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p>头文件通常包含哪些只能被定义一次的实体。例如类、const、constexpr变量等。</p><p>确保头文件多次包含仍能安全工作的技术是<strong>预处理器</strong>，预处理器是在编译之前执行的一段程序。#include就是预处理，当预处理器看到#include标记时，就会用指定的头文件内容替换#include</p><p>C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义、未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义。#ifdef、#ifndef、#endif。</p><p>预处理变量无视C++语言中关于作用域的规则。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。&lt;/p&gt;
&lt;p&gt;主要内容 ：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本内置类型&lt;/li&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;复合类型&lt;/li&gt;
&lt;li&gt;const限定符&lt;/li&gt;
&lt;li&gt;处理类型&lt;/li&gt;
&lt;li&gt;自定义数据类型&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第二章变量和基本类型" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
    
      <category term="变量和基本类型" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>模板和泛型编程</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/</id>
    <published>2018-07-25T04:07:12.000Z</published>
    <updated>2018-07-26T07:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有模板和泛型编程内容</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有模板和泛型编程内容&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十六章 模板和泛型编程" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0-%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="模板和泛型编程" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>组件化-库</title>
    <link href="http://yoursite.com/wiki/IOS/%E5%BA%93/%E7%BB%84%E4%BB%B6%E5%8C%96-%E5%BA%93/"/>
    <id>http://yoursite.com/wiki/IOS/库/组件化-库/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.cocoachina.com/ios/20170427/19136.html" rel="external nofollow noopener noreferrer" target="_blank">组件化-动态库实战</a>    </p><p><a href="https://blog.csdn.net/u013604612/article/details/43197465" rel="external nofollow noopener noreferrer" target="_blank">iOS开发——创建你自己的Framework</a>  </p><p><a href="http://blog.startry.com/2015/08/25/Renaming-umbrella-header-for-iOS-framework/" rel="external nofollow noopener noreferrer" target="_blank">iOS - Umbrella Header在framework中的应用</a></p><p><a href="https://www.jianshu.com/p/48aff237e8ff" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发中的『库』(一)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.cocoachina.com/ios/20170427/19136.html&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;组件化-动态库实战&lt;/a&gt;    
      
    
    </summary>
    
      <category term="IOS" scheme="http://yoursite.com/categories/IOS/"/>
    
      <category term="库" scheme="http://yoursite.com/categories/IOS/%E5%BA%93/"/>
    
    
      <category term="组件化" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/set%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/set命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T10:29:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="built_in">command</span> 1</span><br><span class="line"><span class="built_in">command</span> 2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure><p>Every script you write should include set -e at the top. This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit.</p><p>你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。</p><p>Using -e gives you error checking for free. If you forget to check something, bash will do it for you. Unfortunately it means you can’t check $? as bash will never get to the checking code if it isn’t zero. There are other constructs you could use:</p><p>使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">command</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"$?"</span>-ne <span class="number">0</span>]; then </span><br><span class="line">echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi </span><br><span class="line">could be replaced with</span><br></pre></td></tr></table></figure><p>能够被代替为</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">command || &#123; echo <span class="string">"command failed"</span>; <span class="keyword">exit</span> <span class="number">1</span>; &#125; </span><br><span class="line">or</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> ! command; then</span><br><span class="line"> echo <span class="string">"command failed"</span>; </span><br><span class="line"><span class="keyword">exit</span> <span class="number">1</span>; </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>What if you have a command that returns non-zero or you are not interested in its return value? You can use command || true, or if you have a longer section of code, you can turn off the error checking, but I recommend you use this sparingly.</p><p>如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/export%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/wiki/linux命令/export命令/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T11:00:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>export命令设置或显示环境变量。</p><a id="more"></a><h2 id="Linux-export-命令"><a href="#Linux-export-命令" class="headerlink" title="Linux export 命令"></a>Linux export 命令</h2><p>功能说明：设置或显示环境变量。（比如我们要用一个命令，但这个命令的执行文件不在当前目录，这样我们每次用的时候必须指定执行文件的目录，麻烦，在代码中先执行export，这个相当于告诉程序，执行某某东西时，需要的文件或什么东东在这些目录里）</p><p>语　　法：export [-fnp][变量名称]=[变量设置值]</p><p>补充说明：在shell中执行程序时，shell会提供一组环境变量。 export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。</p><p>参　　数：</p><p>-f 　代表[变量名称]中为函数名称。</p><p>　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>　<br>　-p 　列出所有的shell赋予程序的环境变量。<br>　<br>　一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。     —-《UNIX教程》<br>　<br>　<br>　<br>　在 linux 里设置环境变量的方法 （ export PATH ）<br>　<br>　一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。例如我的mips-linux-gcc编译器在“/opt/au1200_rm /build_tools/bin”目录下，build_tools就是我的编译工具，则有如下三种方法来设置环境变量：<br>　<br>　1、直接用export命令：<br>　#export PATH=$PATH:/opt/au1200_rm/build_tools/bin<br>　查看是否已经设好，可用命令export查看：<br>　<br>　<br>　<br>　[root@localhost bin]#export<br>　declare -x BASH_ENV=”/root/.bashrc”<br>　declare -x G_BROKEN_FILENAMES=”1”<br>　declare -x HISTSIZE=”1000”<br>　declare -x HOME=”/root”<br>　declare -x HOSTNAME=”localhost.localdomain”<br>　declare -x INPUTRC=”/etc/inputrc”<br>　declare -x LANG=”zh_CN.GB18030”<br>　declare -x LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN”<br>　declare -x LESSOPEN=”|/usr/bin/lesspipe.sh %s”<br>　declare -x LOGNAME=”root”<br>　declare -x LS_COLORS=”no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:<em>.cmd=01;32:</em>.exe=01;32:<em>.com=01;32:</em>.btm=01;32:<em>.bat=01;32:</em>.sh=01;32:<em>.csh=01;32:</em>.tar=01;31:<em>.tgz=01;31:</em>.arj=01;31:<em>.taz=01;31:</em>.lzh=01;31:<em>.zip=01;31:</em>.z=01;31:<em>.Z=01;31:</em>.gz=01;31:<em>.bz2=01;31:</em>.bz=01;31:<em>.tz=01;31:</em>.rpm=01;31:<em>.cpio=01;31:</em>.jpg=01;35:<em>.gif=01;35:</em>.bmp=01;35:<em>.xbm=01;35:</em>.xpm=01;35:<em>.png=01;35:</em>.tif=01;35:”<br>　declare -x MAIL=”/var/spool/mail/root”<br>　declare -x OLDPWD=”/opt/au1200_rm/build_tools”<br>　declare -x PATH=”/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin:/opt/au1200_rm/build_tools/bin”<br>　declare -x PWD=”/opt/au1200_rm/build_tools/bin”<br>　declare -x SHELL=”/bin/bash”<br>　declare -x SHLVL=”1”<br>　declare -x SSH_ASKPASS=”/usr/libexec/openssh/gnome-ssh-askpass”<br>　declare -x SSH_AUTH_SOCK=”/tmp/ssh-XX3LKWhz/agent.4242”<br>　declare -x SSH_CLIENT=”10.3.37.152 2236 22”<br>　declare -x SSH_CONNECTION=”10.3.37.152 2236 10.3.37.186 22”<br>　declare -x SSH_TTY=”/dev/pts/2”<br>　declare -x TERM=”linux”<br>　declare -x USER=”root”<br>　declare -x USERNAME=”root”<br>　<br>　可以看到灰色部分有设置的路径，说明环境变量已经设好，PATH里面已经有了我要加的编译器的路径。<br>　<br>　2、修改profile文件：<br>　#vi /etc/profile<br>　在里面加入:<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　3. 修改.bashrc文件：<br>　# vi /root/.bashrc<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下：<br>　# echo $PATH<br>　看看输出里面是不是已经有了 /my_new_path这个路径了。<br>　<br>　另有：4. 修改/etc/re.local文件：<br>　# vi /etc/re.local<br>　在里面加入：<br>　export PATH=”$PATH:/opt/au1200_rm/build_tools/bin”<br>　<br>　<br>　———————————————————————————————————————–<br>　<br>　“/bin”、“/sbin”、“ /usr/bin”、“/usr/sbin”、“/usr/local/bin”等路径已经在系统环境变量中了，如果可执行文件在这几个标准位置，在终端命令行输入该软件可执行文件的文件名和参数(如果需要参数)，回车即可。<br>　<br>　　　如果不在标准位置，文件名前面需要加上完整的路径。不过每次都这样跑就太麻烦了，一个“一劳永逸”的办法是把这个路径加入环境变量。命令 export $PATH=”路径”(或“PATH=$PATH:路径”) ($PATH为环境变量名，如DVSDK；调用时用$DVSDK)可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下的“.bash_profile”只对这个用户有效。<br>　　　<br>　　　　　export $PATH=”$PATH:路径1:路径2:…:路径n” （或“PATH=$PATH:路径1:路径2:…:路径n”　），意思是可执行文件的路径包括原先设定的路径，也包括从“路径1”到“路径n”的所有路径。当用户输入一个一串字符并按回车后，shell会依次在这些路径里找对应的可执行文件并交给系统核心执行。那个“$PATH”表示原先设定的路径仍然有效，注意不要漏掉。某些软件可能还有“PATH”以外类型的环境变量需要添加，但方法与此相同，并且也需要注意“$”。<br>　　　　　<br>　　　　　　　注意，与DOS/Window不同，UNIX类系统环境变量中路径名用冒号分隔，不是分号。另外，软件越装越多，环境变量越添越多，为了避免造成混乱，建议所有语句都添加在文件结尾，按软件的安装顺序添加。<br>　　　　　　　<br>　　　　　　　　　格式如下()：<br>　　　　　　　　　<br>　　　　　　　　　　　# 软件名-版本号<br>　　　　　　　　　　　<br>　　　　　　　　　　　　　PATH=$PATH:路径1:路径 2:…:路径n<br>　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　其他环境变量=$其他环境变量:…<br>　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　在“profile”和“.bash_profile”中，“#”是注释符号，写在这里除了视觉分隔外没有任何效果。<br>　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　设置完毕，注销并重新登录，设置就生效了。如果不注销，直接在shell里执行这些语句，也能生效，但是作用范围只限于执行了这些语句的shell。<br>　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　相关的环境变量生效后，就不必老跑到软件的可执行文件目录里去操作了。<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　———————————————————————————————————————–<br>　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　<br>　　　　　　　　　　　　　　　　　　　　　　 执行一个脚本时，会先开启一个子shell环境（不知道执行其它程序是不是这样），然后将父shell中的所有系统环境变量复制过来，这个脚本中的语句就在子shell中执行。（也就是说父shell的环境变量在子shell中可以调用，但反过来就不行，如果在子shell中定义了环境变量，则只对该shell或者它的子shell有效，当该子shell结束时，也可以理解为脚本执行完时，变量消失。）为了证明这一点，请看脚本内容：<br>　　　　　　　　　　　　　　　　　　　　　　 　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　这样的脚本执行完后，test实际上是不存在的。接着看下面的：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　export test<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　bash<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　这里在脚本最后一行再开一个子shell，该shell应该是脚本文件所在shell的子shell，这个脚本执行完后，是可以看到test这个变量的，因为现在是处于它的子shell中，当用exit退出子shell后，test变量消失。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　如果用source对脚本进行执行时，如果不加export，就不会在子shell中看到这个变量，因为它还不是一个系统环境变量呀，如脚本内容是：<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　test=’value’<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　用source执行后，在shell下是能看到这个变量，但再执行bash开一个子shell时，test是不会被复制到子shell中的，因为执行脚本文件其实也是在一个子shell中运行，所以我再建另一个脚本文件执行时，是不会输入任何东西的，内容如：echo $test。所以这点特别注意了，明明在提示符下可以用echo $test输出变量值，为什么把它放进脚本文件就不行了呢？<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　所以得出的结论是：1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；2、一个shell中的系统环境变量才会被复制到子shell中（用export定义的变量）；3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。3、不用export定义的变量只对该shell有效，对子shell也是无效的。<br>　　　　　　　　　　　　　　　　　　　　　　 　　　　　　　　　　　　　　　　　　　　　　　　后来根据版主的提示，整理了一下贴子：为什么一个脚本直接执行和用source执行不一行呢？这也是我自己碰到的一个问题。manual原文是这样的：Read and execute commands from filename in the current shell environment and return the exit status of the last command executed from filename.明白了为什么不一样了吧？直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;export命令设置或显示环境变量。&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>set命令</title>
    <link href="http://yoursite.com/wiki/linux%E5%91%BD%E4%BB%A4/$0,$?,$!%E7%AD%89%E7%9A%84%E7%89%B9%E6%AE%8A%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/wiki/linux命令/$0,$?,$!等的特殊用法/</id>
    <published>2018-07-20T04:07:12.000Z</published>
    <updated>2018-07-20T11:15:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下linux shell下的特殊用法及参数的说明.</p><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">变量说明:</span><br><span class="line"></span><br><span class="line">$$ </span><br><span class="line">Shell本身的PID（ProcessID） </span><br><span class="line">$! </span><br><span class="line">Shell最后运行的后台Process的PID </span><br><span class="line">$? </span><br><span class="line">最后运行的命令的结束代码（返回值） </span><br><span class="line">$- </span><br><span class="line">使用Set命令设定的Flag一览 </span><br><span class="line">$* </span><br><span class="line">所有参数列表。如<span class="string">"$*"</span>用「<span class="string">"」括起来的情况、以"</span><span class="variable">$1</span> <span class="variable">$2</span> … <span class="variable">$n</span><span class="string">"的形式输出所有参数。 </span></span><br><span class="line"><span class="string"><span class="variable">$@</span> </span></span><br><span class="line"><span class="string">所有参数列表。如"</span><span class="variable">$@</span><span class="string">"用「"</span>」括起来的情况、以<span class="string">"<span class="variable">$1</span>"</span> <span class="string">"<span class="variable">$2</span>"</span> … <span class="string">"<span class="variable">$n</span>"</span> 的形式输出所有参数。 </span><br><span class="line"><span class="variable">$#</span> </span><br><span class="line">添加到Shell的参数个数 </span><br><span class="line"><span class="variable">$0</span> </span><br><span class="line">Shell本身的文件名 </span><br><span class="line"><span class="variable">$1</span>～<span class="variable">$n</span> </span><br><span class="line">添加到Shell的各参数值。<span class="variable">$1</span>是第1参数、<span class="variable">$2</span>是第2参数…。</span><br><span class="line"></span><br><span class="line">我们先写一个简单的脚本，执行以后再解释各个变量的意义 </span><br><span class="line"><span class="comment"># touch variable </span></span><br><span class="line"><span class="comment"># vi variable </span></span><br><span class="line">脚本内容如下： </span><br><span class="line"><span class="meta">#!/bin/sh </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"number:<span class="variable">$#</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"scname:<span class="variable">$0</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"first :<span class="variable">$1</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"second:<span class="variable">$2</span>"</span> </span><br><span class="line"><span class="built_in">echo</span> <span class="string">"argume:<span class="variable">$@</span>"</span> </span><br><span class="line">保存退出 </span><br><span class="line">赋予脚本执行权限 </span><br><span class="line"><span class="comment"># chmod +x variable </span></span><br><span class="line">执行脚本 </span><br><span class="line"><span class="comment"># ./variable aa bb </span></span><br><span class="line">number:2 </span><br><span class="line">scname:./variable </span><br><span class="line">first: aa </span><br><span class="line">second:bb </span><br><span class="line">argume:aa bb </span><br><span class="line">通过显示结果可以看到： </span><br><span class="line"><span class="variable">$#</span> 是传给脚本的参数个数 </span><br><span class="line"><span class="variable">$0</span> 是脚本本身的名字 </span><br><span class="line"><span class="variable">$1</span>是传递给该shell脚本的第一个参数 </span><br><span class="line"><span class="variable">$2</span>是传递给该shell脚本的第二个参数 </span><br><span class="line"><span class="variable">$@</span> 是传给脚本的所有参数的列表</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下linux shell下的特殊用法及参数的说明.&lt;/p&gt;
    
    </summary>
    
      <category term="linux命令" scheme="http://yoursite.com/categories/linux%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="set" scheme="http://yoursite.com/tags/set/"/>
    
  </entry>
  
  <entry>
    <title>static关键字作用总结(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/static/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字理解/static/</id>
    <published>2018-07-17T10:07:12.000Z</published>
    <updated>2018-07-17T10:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。</p><a id="more"></a><h2 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h2><p>1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）</p><p>当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。<br>举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.c</span></span><br><span class="line"><span class="keyword">char</span> a = <span class="string">'A'</span>; <span class="comment">// global variable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">msg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">extern</span> <span class="keyword">char</span> a; <span class="comment">// extern variable must be declared before use</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"%c "</span>, a);</span><br><span class="line">     (<span class="keyword">void</span>)msg();</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">A</span> Hello</span><br></pre></td></tr></table></figure><p>为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。<br>如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏.</p><h2 id="内容持久化（static变量中的记忆功能和全局生存期）"><a href="#内容持久化（static变量中的记忆功能和全局生存期）" class="headerlink" title="内容持久化（static变量中的记忆功能和全局生存期）"></a>内容持久化（static变量中的记忆功能和全局生存期）</h2><p>存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见</p><p>PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。</p><p>程序举例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">＃<span class="keyword">include</span> &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> fun()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">10</span>; <span class="comment">//在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">count</span>--; <span class="comment">//就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量：    </span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">     printf(<span class="string">"global\t\tlocal static\n"</span>);</span><br><span class="line">     <span class="keyword">for</span>(; <span class="keyword">count</span> &lt;= <span class="number">10</span>; ++<span class="keyword">count</span>)</span><br><span class="line">               printf(<span class="string">"%d\t\t%d\n"</span>, <span class="keyword">count</span>, fun());</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">global  local static</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span> <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>—基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。</p><h2 id="默认初始化为0"><a href="#默认初始化为0" class="headerlink" title="默认初始化为0"></a>默认初始化为0</h2><p>其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\0’;不妨做个小实验验证一下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">＃include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> i;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"integer: %d; string: (begin)%s(end)"</span>, a, str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果是：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">integer</span>: <span class="number">0</span>; <span class="keyword">string</span>: (<span class="keyword">begin</span>) (<span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. </p><h2 id="C-中的类成员声明static"><a href="#C-中的类成员声明static" class="headerlink" title="C++中的类成员声明static"></a>C++中的类成员声明static</h2><p> 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：</p><ol><li>类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </li><li>不能将静态成员函数定义为虚函数。      </li><li>由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</li><li>由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）</li><li>static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。</li><li>静态数据成员在&lt;定义或说明&gt;时前面加关键字static。</li><li>静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）</li><li><p>静态成员初始化与一般数据成员初始化不同:</p><p> 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；<br>初始化时不加该成员的访问权限控制符private，public等；<br>初始化时使用作用域运算符来标明它所属类；</p><pre><code>所以我们得出静态数据成员初始化的格式：</code></pre><p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p></li><li><p>为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p></li></ol><h2 id="转载地址"><a href="#转载地址" class="headerlink" title="转载地址"></a>转载地址</h2><p><a href="https://www.cnblogs.com/songdanzju/p/7422380.html" rel="external nofollow noopener noreferrer" target="_blank">C++中static关键字作用总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字理解" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>explicit实例浅析(转载)</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/explicit-learn/"/>
    <id>http://yoursite.com/wiki/C++语言/C++关键字理解/explicit-learn/</id>
    <published>2018-07-16T01:07:12.000Z</published>
    <updated>2018-07-16T03:54:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。</p><a id="more"></a><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>按默认规定，只用传一个参数的构造函数也定义了一个隐式转换。举个例子：<br>（下面这个CExample没有什么实际的意义，主要是用来说明问题）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Example.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CExample</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~CExample(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> m_iFirst;</span><br><span class="line"><span class="keyword">int</span> m_iSecond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Example.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StdAfx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line">CExample::CExample(<span class="keyword">void</span>)</span><br><span class="line">: m_iFirst(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::~CExample(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">CExample::CExample(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond):m_iFirst(iFirst), m_iSecond(iSecond)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//TestExplicitKey.cpp</span></span><br><span class="line">...<span class="comment">//其它头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Example.h"</span></span></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">CExample objOne; <span class="comment">//调用没有参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objTwo</span><span class="params">(<span class="number">12</span>, <span class="number">12</span>)</span></span>; <span class="comment">//调用有两个参数的构造函数</span></span><br><span class="line"><span class="function">CExample <span class="title">objThree</span><span class="params">(<span class="number">12</span>)</span></span>; <span class="comment">//同上，可以传一个参数是因为该构造函数的第二个参数有默认值</span></span><br><span class="line">CExample objFour = <span class="number">12</span>; <span class="comment">//执行了隐式转换,等价于CExample temp(12);objFour(temp);注意这个地方调用了</span></span><br><span class="line"><span class="comment">//编译器为我们提供的默认复制构造函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在构造函数声明中加入关键字explicit，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">CExample</span><span class="params">(<span class="keyword">int</span> iFirst, <span class="keyword">int</span> iSecond = <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>那么CExample objFour = 12; 这条语句将不能通过编译。在vs05下的编译错误提示如下</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error C2440: <span class="string">'initializing'</span> : cannot convert <span class="keyword">from</span> <span class="string">'int'</span> <span class="keyword">to</span> <span class="string">'CExample'</span></span><br><span class="line">    <span class="function"><span class="keyword">Constructor</span> <span class="title">for</span> <span class="title">class</span> '<span class="title">CExample</span>' <span class="title">is</span> <span class="title">declared</span> '<span class="title">explicit</span>'</span></span><br></pre></td></tr></table></figure><h2 id="explicit意义"><a href="#explicit意义" class="headerlink" title="explicit意义"></a>explicit意义</h2><p>对于某些类型，这一情况非常理想。<font color="blue">但在大部分情况中，隐式转换却容易导致错误（不是语法错误，编译器不会报错）。隐式转换总是在我们没有察觉的情况下悄悄发生，除非有心所为，隐式转换常常是我们所不希望发生的。通过将构造函数声明为explicit（显式）的方式可以抑制隐式转换。也就是说，explicit构造函数必须显式调用。</font><br>引用一下Bjarne Stroustrup的例子:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">String</span>&#123;</span><br><span class="line">   <span class="keyword">explicit</span> <span class="keyword">String</span>(<span class="keyword">int</span> n);</span><br><span class="line">   <span class="keyword">String</span>(<span class="keyword">const</span> <span class="keyword">char</span> *p);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">String</span> s1 = <span class="string">'a'</span>; <span class="comment">//错误：不能做隐式char-&gt;String转换</span></span><br><span class="line"><span class="keyword">String</span> s2(<span class="number">10</span>);  <span class="comment">//可以：调用explicit String(int n);</span></span><br><span class="line"><span class="keyword">String</span> s3 = <span class="keyword">String</span>(<span class="number">10</span>);<span class="comment">//可以：调用explicit String(int n);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s4 = <span class="string">"Brian"</span>; <span class="comment">//可以：隐式转换调用String(const char *p);再调用默认的复制构造函数</span></span><br><span class="line"><span class="keyword">String</span> s5(<span class="string">"Fawlty"</span>); <span class="comment">//可以：正常调用String(const char *p);</span></span><br><span class="line"><span class="keyword">void</span> f(<span class="keyword">String</span>);</span><br><span class="line"><span class="keyword">String</span> g()</span><br><span class="line">&#123;</span><br><span class="line">  f(<span class="number">10</span>); <span class="comment">//错误：不能做隐式int-&gt;String转换</span></span><br><span class="line">  f(<span class="string">"Arthur"</span>); <span class="comment">//可以：隐式转换，等价于f(String("Arthur"));</span></span><br><span class="line">  <span class="built_in">return</span> <span class="number">10</span>; <span class="comment">//同上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际代码中的东西可不像这种故意造出的例子。<br>发生隐式转换，除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。<br>原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。</p><p>原文链接：<a href="http://blog.csdn.net/chollima/article/details/3486230" rel="external nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/chollima/article/details/3486230</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++关键字理解" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-%E5%85%B3%E9%94%AE%E5%AD%97%E7%90%86%E8%A7%A3/"/>
    
    
      <category term="explicit" scheme="http://yoursite.com/tags/explicit/"/>
    
  </entry>
  
  <entry>
    <title>拷贝控制</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十三章/拷贝控制/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-13T11:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们将学到：拷贝、赋值、移动、销毁做什么？</p><ol><li>拷贝构造函数  </li><li>拷贝赋值运算符</li><li>移动构造函数</li><li>移动赋值运算符</li><li>析构函数</li></ol><p>函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么<br>运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。</p><p>如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。</p><a id="more"></a><h2 id="拷贝、赋值、销毁"><a href="#拷贝、赋值、销毁" class="headerlink" title="拷贝、赋值、销毁"></a>拷贝、赋值、销毁</h2><h3 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h3><p>如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   plublic:</span><br><span class="line">   Foo(canst Foo&amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="合成拷贝构造函数"><a href="#合成拷贝构造函数" class="headerlink" title="合成拷贝构造函数"></a>合成拷贝构造函数</h4><p>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。</p><p>合成拷贝构造函数如何拷贝：</p><ol><li>类类型：使用其拷贝构造函数来拷贝</li><li>内置类型：直接拷贝</li><li>数组：逐个拷贝数组成员</li></ol><p>例子：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(const Sales_data&amp; orig):</span><br><span class="line"><span class="function"><span class="title">bookNO</span><span class="params">(orig.bookNO)</span></span>,</span><br><span class="line"><span class="function"><span class="title">units_sold</span><span class="params">(orig.units_sold)</span></span>,</span><br><span class="line"><span class="function"><span class="title">revenue</span><span class="params">(orig.revenue)</span></span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><ol><li>直接初始化：我们实际上要求编译器用普通的函数匹配类选择与我们提供的参数最匹配的构造函数</li><li>拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。</li></ol><p>拷贝初始化发生的场景：</p><ol><li>将一个对象作为实参传递给一个非引用类型的形参</li><li>从一个返回类型为非引用类型的函数返回一个对象</li><li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li><li>insert 、push（emplace 直接初始化）</li></ol><h4 id="参数和返回值"><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h4><p>当一个函数具有非引用类型的返回值类型时，返回值会被用来初始化调用方的结果</p><h3 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h3><p>赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。<br>如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;);</span><br></pre></td></tr></table></figure></p><p>赋值运算符通常应该返回一个指向其左侧运算对象的引用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">booNO = rhs.bookNO;</span><br><span class="line">units_sold = rhs.units_sold;</span><br><span class="line">revenue = rhs.revenue;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ol><li>构造函数初始化对象的非static数据成员。</li><li>析构函数释放对象使用的资源，并销毁对象的非静态成员。</li></ol><p>析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">~Foo()</span>;</span><br></pre></td></tr></table></figure></p><ol><li>在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。</li><li>在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。</li></ol><p>隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。</p><p>什么时候会调用析构函数：</p><ol><li>变量在离开其作用域时</li><li>对象被销毁，其成员被销毁</li><li>容器被销毁，其成员被销毁</li><li>动态分配的对象，delete 运算符时会被销毁</li><li>对于临时对象，当创建他的完整表达式结束时被销毁</li></ol><p><font color="red">析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的</font></p><h3 id="三五法则"><a href="#三五法则" class="headerlink" title="三五法则"></a>三五法则</h3><p>需要析构函数的类也需要拷贝和赋值。<br>需要拷贝操作的类也需要赋值操作。</p><h3 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用=default</h3><p>可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。</p><h3 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h3><p>应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。<br>删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。</p><p>=default 、=delete区别：</p><ol><li>=delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。</li><li>可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。</li></ol><p>析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。</p><p>对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。</p><p>合成的拷贝成员可能是删除的：如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。</p><p>一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。</p><p>对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，次运算符视图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。</p><h2 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h2><p>管理类外资源的类必须定义拷贝控制函数。</p><ol><li>类值拷贝</li><li>类指针拷贝</li></ol><p>赋值运算符通常组合了析构函数和构造函数的操作。类型析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">//拷贝底层String</span></span><br><span class="line"><span class="keyword">delete</span> ps; <span class="comment">//是否旧内存</span></span><br><span class="line">ps = newp;</span><br><span class="line">i=rhs.i;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它吱声，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</p><p>引用计数的工作方式：</p><ul><li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。</li><li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。</li><li>析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。</li><li>拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将学到：拷贝、赋值、移动、销毁做什么？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;拷贝构造函数  &lt;/li&gt;
&lt;li&gt;拷贝赋值运算符&lt;/li&gt;
&lt;li&gt;移动构造函数&lt;/li&gt;
&lt;li&gt;移动赋值运算符&lt;/li&gt;
&lt;li&gt;析构函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数类：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么&lt;br&gt;运算符类：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。&lt;/p&gt;
&lt;p&gt;如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十三章" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    
    
      <category term="拷贝控制" scheme="http://yoursite.com/tags/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>函数</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%87%BD%E6%95%B0/%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第六章函数/函数/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-08-20T11:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要内容：</p><ol><li>函数基础</li><li>参数传递</li><li>函数类型和return语句</li><li>函数重载</li><li>特殊用途语言特性</li><li>函数匹配</li><li>函数指针</li></ol><a id="more"></a><p>函数是一个命名了的代码块，我们通过调用函数执行响应的代码。</p><h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>函数的组成部分：</p><ol><li>返回类型</li><li>函数名字</li><li>形参列表</li><li>函数体</li></ol><p>我们通过调用运算符来执行函数，调用运算符的形式是一对圆括号。</p><p>函数调用完成的工作：</p><ol><li>用实参初始化函数对应的形参</li><li>将控制权转移给被调函数，此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行</li></ol><p>return语句完成的工作：</p><ol><li>返回return语句中的值</li><li>将控制权从被调函数转移回主调函数。</li></ol><p>函数的形参：即使两个形参的类型一样，也必须把两个类型都写出来。任何两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p><p>函数返回类型：函数的返回类型不能是数组类型、函数类型，但是可以是指向数组或者函数的指针。为啥？</p><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h3><p>名字有作用域，对象有生命周期。</p><ol><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ol><p>形参和函数体内部定义的变量统称为局部变量。局部变量会隐藏在外层作用域中同名的其他所有声明。</p><p>在所有函数体之外定义的对象，存在于程序的整个过程中，此类对象在程序启动的时候被创建，直到程序结束才会销毁。</p><p>自动对象:当函数的控制路径经过变量定义语句时，创建该对象，当达到定义语句所在的快末尾时销毁，我们把只存在于快执行期间的对象称为自动对象。</p><p>形参是自动变量，函数开始执行时为形参申请空间，因为形参定义在函数作用域内，所以一旦函数终止，形参就被销毁。</p><p>局部静态对象：生命周期贯穿函数调用及之后的时间，在程序执行路径第一次经过对象的定义语句时初始化对象。并且直到程序终止才被销毁。</p><p>如果局部静态变量没有显示的初始化，执行值初始化，内置类型的局部静态变量初始化为0.</p><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>函数的声明不包括函数体，所以他无需形参名字。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><ol><li>引用传递：引用形参是他对象实参的别名</li><li>值传递：值拷贝，形参和实参是两个相互独立的对象</li></ol><h3 id="传值参数"><a href="#传值参数" class="headerlink" title="传值参数"></a>传值参数</h3><p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。对变量的改动不会影响初始值。</p><p>指针形参：指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。因为指针使我们可以间接的访问他所指的对象，所以通过指针可以修改它所指对象的值。</p><h3 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h3><p>对引用的操作实际上是作用在引用所引用对象上。</p><p>优点吧：</p><ol><li>使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本不支持拷贝操作，当某种类型不支持拷贝操作时，函数只能通过引用参数访问该类型对象。</li><li>使用引用形参返回额外信息。</li></ol><h3 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h3><p>当形参有顶层const时，传给它常量或非常量对象都可以。</p><p>我们可以使用非常量初始化一个底层const对象。C++允许字面值初始化常量引用。</p><p>常量引用接收的实参范围大，可以接收非常量、常量、字面值、需要类型转换的对象。</p><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组的特点：</p><ol><li>内置类型。</li><li>不允许拷贝，所以不能以值传递方式使用数组。</li><li>使用数组时，大部分情况会转换为指向数组首元素的指针。</li></ol><p>管理指针形参，标记数组的大小：</p><ol><li>使用标记指定数组的大小，就是数组本身包含一个结束标记，典型的例子是C风格的字符串</li><li>使用标准库，需要传入两个指针，一个指向数组首元素，另一个指向尾元素的下一个位置。</li><li>显示传递一个表示数组大小的形参</li></ol><p>数组引用形参：引用绑定到数组实参上。纬度也是类型的一部分，但是这样限制只能传递数组大小为10 的实参，函数模板可以实现传递任何大小的数组。</p><p>传递多维数组： 数组真正传递的是首元素的地址，因为，多维数组时数组的数组，所以首元素本身是一个数组，就是指向数组的指针，可以想象，数组的第二纬的大小是数组类型的一部分。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span>  (*matrix)<span class="selector-attr">[10]</span> ; <span class="comment">//第二个纬度是类型的一部分。</span></span><br></pre></td></tr></table></figure><h3 id="main：处理命令行选项"><a href="#main：处理命令行选项" class="headerlink" title="main：处理命令行选项"></a>main：处理命令行选项</h3><p>argv中的可选实参从argv[1]开始，argv[0]保存程序的名字，而非用户的输入。</p><h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h3><p>可变参数的的实现方式：</p><ol><li>传递initializer——list标准库类型，所有实参类型相同</li><li>可变参数模板，参数类型不同</li><li>特殊的形参类型——省略号，一般用于和C交互的程序</li></ol><h4 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h4><p>实参数量未知，类型相同。</p><table><thead><tr><th>initializer_list提供的操作</th><th>说明</th></tr></thead><tbody><tr><td><code>initializer_list&lt;T&gt; lst;</code></td><td>默认初始化，T类型元素的空列表</td></tr><tr><td><code>initializer_list&lt;T&gt; lst{a,b,c...}  list2 = list</code></td><td>lst的元素数量和初始值一样多，lst元素是对应初始值的副本，列表中的元素是const</td></tr><tr><td>lst2(lst)</td><td>拷贝或者赋值一个initializer_list对象，不会拷贝列表中的元素，拷贝后，原始列表和副本共享元素</td></tr><tr><td>list.size()</td><td>列表中元素数量</td></tr><tr><td>list.begin()</td><td>list中首元素指针</td></tr><tr><td>list.end()</td><td>list中尾元素下一个位置</td></tr></tbody></table><p>如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一个或括号中。</p><h3 id="省略符形参"><a href="#省略符形参" class="headerlink" title="省略符形参"></a>省略符形参</h3><p>省略符形参是为了便于C++程序访问某些特殊的C代码设置的。这些代码使用名为varargs的C标准库。大多数类类型对象在传递给省略符形参时，都无法正确拷贝。省略符形参只能出现在形参列表的最后一个位置。省略符形参对应的实参无需进行类型检查。省略符前面的逗号可以省略。</p><h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><h3 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h3><p>返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式的执行return。。</p><p>强行令void函数返回其他类型的表达式将产生编译错误。</p><h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><p>return语句的返回值类型必须与函数的返回类型形同，或者可以隐式转换。</p><h4 id="值是如何被返回的"><a href="#值是如何被返回的" class="headerlink" title="值是如何被返回的"></a>值是如何被返回的</h4><p>返回一个值，和初始化一个变量或者形参的方式完全一样。</p><h4 id="不要返回局部对象的指针或者引用"><a href="#不要返回局部对象的指针或者引用" class="headerlink" title="不要返回局部对象的指针或者引用"></a>不要返回局部对象的指针或者引用</h4><p>因为局部对象释放了，引用或者指针无效</p><h4 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a>返回类类型的函数和调用运算符</h4><p>为啥点运算符和箭头运算符、调用运算符优先级形同呢？如果调用一个函数，返回一个对象，我么可以直接通过点运算符访问对象的属性。他们是左结合律</p><h4 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h4><p>我们能为返回类型是非常量引用的函数的结果赋值。就是把函数调用放在赋值语句的左侧。</p><h4 id="列表初始化返回值"><a href="#列表初始化返回值" class="headerlink" title="列表初始化返回值"></a>列表初始化返回值</h4><h4 id="主函数main的返回值"><a href="#主函数main的返回值" class="headerlink" title="主函数main的返回值"></a>主函数main的返回值</h4><p>main可以不写返回值，编译器帮插入</p><h3 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h3><p>因为数组不能拷贝，所以函数不能返回数组，不过函数可以返回数组的指针或者引用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//arrT是是一个类型别名，表示类型是10个整数的数组。</span></span><br></pre></td></tr></table></figure><p>基本形式]、示例：</p><p>``<br>type (*function(parameter_list))[demension]</p><p>int (*func(int i))[10];<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">理解的方式：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">func</span><span class="params">(int i)</span></span> 表示条用<span class="function"><span class="keyword">func</span>函数时需要一个<span class="title">int</span>类型的实参</span></span><br><span class="line"><span class="function">2. <span class="params">(* <span class="keyword">func</span><span class="params">(int i)</span></span></span>) 意味着我们可以对函数调用的结果执行解引用操作</span><br><span class="line"><span class="number">3</span>. (* <span class="function"><span class="keyword">func</span><span class="params">(int i)</span></span>)[<span class="number">10</span>] 表示解引用<span class="function"><span class="keyword">func</span>的调用将得到一个大小是10的数组</span></span><br><span class="line"><span class="function">4. <span class="title">int</span> <span class="params">(*<span class="keyword">func</span><span class="params">(int i)</span></span></span>)[<span class="number">10</span>] 表示数组中的元素类型是int类型</span><br><span class="line"></span><br><span class="line">使用尾置返回类型： <span class="type">C</span>++新标准中可以还有一种简化上述<span class="function"><span class="keyword">func</span>声明的方法，就是使用位置返回类型。任何函数定义都能使用位置返回，位置返回类型跟在新参列表后面，并以-&gt;开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个<span class="title">auto</span>。</span></span><br></pre></td></tr></table></figure></p><p>auto func(int i) -&gt; int(*)[10];<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">使用<span class="keyword">decltype</span>： 如果我们知道函数返回的指针指向哪个数组，就可以使用<span class="keyword">decltype</span>关键字声明返回类型。<span class="keyword">decltype</span>并不负责把数组类型转换为对应的指针。所以<span class="keyword">decltype</span>的结果是数组。</span><br><span class="line"></span><br><span class="line">## 函数重载</span><br><span class="line"></span><br><span class="line">对于重载的函数来说，他们应该在形参数量或形参类型上有所不同。返回类型不能当做重载的判断依据。</span><br><span class="line"></span><br><span class="line">重载和<span class="keyword">const</span>：顶层<span class="keyword">const</span>不构成重载。底层<span class="keyword">const</span>构成重载</span><br><span class="line"></span><br><span class="line"><span class="keyword">const_cast</span>和重载：<span class="keyword">const_cast</span>在重载函数的场景最有用。</span><br><span class="line"></span><br><span class="line">### 重载与作用域</span><br><span class="line"></span><br><span class="line">如果在内存作用域中声明名字，他将隐藏外层作用域中声明的同名实体。在不同的作用域无法重载函数名。</span><br><span class="line"></span><br><span class="line">在C++中，名字查找发生在类型检查之前</span><br><span class="line"></span><br><span class="line">## 特殊用途语言特殊</span><br><span class="line"></span><br><span class="line">### 默认实参</span><br><span class="line"></span><br><span class="line">某些函数有这样一种形参，在函数的很多次调用中，他们都被赋予一个相同的值。此时，我们吧这个反复出现的值称为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略改实参。</span><br><span class="line"></span><br><span class="line">默认实参作为形参的初始值出现在形参列表中，我们可以为一个或多个形参定义默认值，不过注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</span><br><span class="line"></span><br><span class="line">函数调用时，实参按位置解析，默认实参负责填补函数调用缺少的尾部实参。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面。而让那些经常使用默认值的形参出现在后面。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 默认实参声明</span><br><span class="line"></span><br><span class="line">对于函数的声明，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点注意：在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参。而且该形参的右侧的所有形参必须有默认值。</span><br><span class="line"></span><br><span class="line">通常，应该在函数声明中指定默认实参，并将声明放在合适的头文件中。</span><br><span class="line"></span><br><span class="line">默认实参的初始值：用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程烦死在函数调用时。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 内联函数 和<span class="keyword">constexpr</span>函数</span><br><span class="line"></span><br><span class="line">内联函数可以避免函数调用的开销： 通常在调用点内联的展开。在函数的返回类型前面加上关键字<span class="keyword">inline</span>，可以将函数声明为内联的。内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</span><br><span class="line"></span><br><span class="line">一般来说：内联机制用于优化规模较小、流程直接、频繁调用的函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span>函数：是指 能用于常量表达式的函数。需要满足两个条件</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 函数的返回类型和所有形参类型都是字面值类型</span><br><span class="line"><span class="number">2.</span> 函数体内必须有且只有一条<span class="built_in">return</span>语句。</span><br><span class="line"></span><br><span class="line">为了能在编译过程中随时展开，<span class="keyword">constexpr</span>函数被隐式的指定为内联函数。</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span>函数不一定返回常量表达式。由编译器确定是不是常量。</span><br><span class="line"></span><br><span class="line">### 调试帮组</span><br><span class="line"></span><br><span class="line">###<span class="meta"># assert预处理宏</span></span><br></pre></td></tr></table></figure></p><p>assert(expr)<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">首先对expr求值，如果表达式的值为假（0），assert输出信息并终止程序执行，如果表达式为真，assert什么页不做。</span><br><span class="line"></span><br><span class="line">预处理名字由预处理器而非编译器管理，所以使用assert无需使用using声明。宏名字在程序内必须唯一。</span><br><span class="line"></span><br><span class="line"><span class="section">#### NDEBUG 预处理变量</span></span><br><span class="line"></span><br><span class="line">assert的行为依赖于一个名为NDEUBG的预处理变量的状态。如果定义了NDEBUG，则assert什么页不做。</span><br><span class="line"></span><br><span class="line">除了C++编译器定义的<span class="strong">__func__</span>之外，预处理器还定义了另外4个对于程序调试很有用的名字。</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span><span class="code">`__FILE__`</span> 存放文件名的字符串字面值</span><br><span class="line"><span class="bullet">2. </span><span class="code">`__LINE__ `</span>存放当前行号的整形字面值</span><br><span class="line"><span class="bullet">3. </span><span class="code">`__TIME__`</span> 存放文件编译时间的字符串字面值</span><br><span class="line"><span class="bullet">4. </span><span class="code">`__DATW__ `</span>存放文件编译日志的字符串字面值。</span><br><span class="line"></span><br><span class="line"><span class="section">## 函数匹配</span></span><br><span class="line"></span><br><span class="line"><span class="section">### 确定候选函数、可行函数</span></span><br><span class="line"></span><br><span class="line">函数匹配的第一步是选定本次调用对象的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>于被调用函数同名</span><br><span class="line"><span class="bullet">2. </span>其声明在调用点可见</span><br><span class="line"></span><br><span class="line">第二步：考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数的特征</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>其形参数量与本次调用提供的实参数量相等</span><br><span class="line"><span class="bullet">2. </span>每个实参的类型与对象的形参类型相同或者能转化为形参类型。</span><br><span class="line"></span><br><span class="line">第三步： 寻找最佳匹配</span><br><span class="line"></span><br><span class="line">最佳的条件：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>该函数每个实参的匹配都不劣于其他可行函数的匹配</span><br><span class="line"><span class="bullet">2. </span>至少有一个实参的匹配优于其他可行函数提供的匹配。</span><br><span class="line"></span><br><span class="line"><span class="section">### 实参类型转换</span></span><br><span class="line"></span><br><span class="line">编译器将实参类型到形参类型的转化划分为几个等级：具体的排序如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">1. </span>精确匹配： 类型完全相同、实参从数组类型或函数类型转换成对应的指针类型、向实参类型添加顶层const或者从实参中删除顶层const</span><br><span class="line"><span class="bullet">2. </span>通过const转化实现的匹配</span><br><span class="line"><span class="bullet">3. </span>通过类型提升实现的匹配</span><br><span class="line"><span class="bullet">4. </span>通过算术类型转换实现的匹配</span><br><span class="line"><span class="bullet">5. </span>通过类类型转换实现的匹配</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">### 函数匹配和const实参</span></span><br><span class="line"></span><br><span class="line">如果两个函数的唯一区别是他的指针形参指向常量或者非常量。则编译器通过实参是否常量来决定需用那个函数。如果实参是指向常量的指针，调用形参是const*的函数。否则，调用普通版本函数。</span><br><span class="line"></span><br><span class="line"><span class="section">## 函数指针</span></span><br><span class="line"></span><br><span class="line">函数指针指向的是函数，而非对象，和其他指针一样，函数指针指向某种特定的类型。函数的类型是由它的返回类型和形参类型共同决定的。于函数名无关。要想声明一个可以指向函数的指针，只需要用指针代替函数名即可：</span><br></pre></td></tr></table></figure></p><p>bool (*pf)(const string&amp;, const string &amp;);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当我们把函数名当一个值使用时，函数自动的转化为指针。我们还可以直接使用函数指针调用改函数，无需提前解引用指针。不同函数类型的指针间不存在类型转换</span><br></pre></td></tr></table></figure></p><p>pf = lengthCompara;<br>pf = &amp; lengthCompara; //等价的赋值语句<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">重载函数的指针：指针类型必须与重载函数中的某一个精确匹配。</span><br><span class="line"></span><br><span class="line">函数指针形参：虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。形参如果是函数类型，会自动转化为函数指针类型。decltype作用于函数，只返回函数类型，如果需要函数指针，需要单加*</span><br><span class="line"></span><br><span class="line">返回指向函数的指针：和数组类型，不能返回一个函数，但能返回指向函数类型的指针，我们必须把返回类型写成指针形式，编译器不会自动将函数类型转换为指针类型</span><br></pre></td></tr></table></figure></p><p>typedef bool Func(const string&amp;, const string &amp;);  //函数类型<br>using Func = bool(const string&amp;, const string &amp;) //函数类型</p><p>typedef bool (<em>Func1)(const string&amp;, const string &amp;);  //函数指针类型<br>using Func1 = bool(</em>)(const string&amp;, const string &amp;) //函数指针类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>int (<em>f1(int))( int </em>, int)<br>```</p><ol><li>f1 有形参列表，所以f1是个函数，f1前面有个* 所以f1 返回一个指针</li><li>指针的类型本身也包含了形参列表。因此，指针直线函数</li><li>改函数的返回类型是int </li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数基础&lt;/li&gt;
&lt;li&gt;参数传递&lt;/li&gt;
&lt;li&gt;函数类型和return语句&lt;/li&gt;
&lt;li&gt;函数重载&lt;/li&gt;
&lt;li&gt;特殊用途语言特性&lt;/li&gt;
&lt;li&gt;函数匹配&lt;/li&gt;
&lt;li&gt;函数指针&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第六章函数" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%87%BD%E6%95%B0/"/>
    
    
      <category term="函数" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>面向对象程序设计</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/C++Primer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/</id>
    <published>2018-07-13T04:07:12.000Z</published>
    <updated>2018-07-19T10:53:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>主要有虚函数、访问控制等内容</p><a id="more"></a><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>静态类型和动态类型</p><ol><li>通过使用数据抽象，可以将类的接口和实现分离</li><li>使用继承可以定义相似类型并对相似类型建模</li><li>使用动态绑定，可以忽略相似类型的区别，而用统一的方式使用对象</li></ol><p>当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。</p><ol><li>成员函数如果没用被声明为虚函数，解析过程发生在编译时候</li><li>成员函数声明为虚函数，根据调用指针在运行的时候确定调用的版本。</li></ol><p>派生类显示的著名他使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字。</p><p>回避虚函数使用：在函数名前加作用域运算符。</p><h2 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h2><ol><li>protected用来声明希望与派生类共享、但不被共有访问的成员。</li><li>派生类成员和友元只能通过派生类对象访问基类的受保护的成员。</li><li>protected成员对于派生类和友元来说可以访问。</li><li>protected对于类的用户来说不可访问。</li></ol><p>某个类对其继承而来的成员的访问权限收到两个因素的影响：</p><ol><li>基类中该成员的访问说明符</li><li>派生列表中派生访问说明符</li></ol><p>爸爸受保护的属性，儿子的小三（友元）想通过儿子窃取，不行（友元不能传递）</p><p>爸爸受保护的属性，爸爸的小三想通过儿子获取，可以（谁的小三就能获取到谁的保护属性，小三具有破坏性）</p><p>派生类的作用域位于基类的作用域内</p><ol><li>class的访问说明符、派生访问说明符默认都是private</li><li>struct的访问说明符、派生访问说明符默认都是public的</li></ol><p>两个角度理解访问控制：</p><ol><li>普通用户</li><li>实现者</li></ol><p>派生类的成员隐藏同名的基类成员。</p><p>使用作用域运算符来使用一个被隐藏的基类成员</p><p>除了覆盖继承而来的虚函数，派生类最好不用重新定义其他在基类中名字</p><p>函数调用解析过程</p><p>假如我们调用p-&gt;mem()，</p><ol><li>确定p的静态类型</li><li>在静态类型对应的类中找mem</li><li>找到后判断是否虚函数，是产生虚函数调用版本、不是编译器产生常规调用版本。</li></ol><p>名字查找先于类型检测</p><h2 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h2><p>析构函数定义成虚函数，确保删除指针能执行正确的版本。</p><p>如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要有虚函数、访问控制等内容&lt;/p&gt;
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="C++Primer" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/"/>
    
      <category term="第十五章 面向对象程序设计" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/C-Primer/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="面向对象程序设计" scheme="http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>为什么`forward_list`不支持`push_back`操作？</title>
    <link href="http://yoursite.com/wiki/C++%E8%AF%AD%E8%A8%80/container/forward_list%E4%B8%8D%E6%94%AF%E6%8C%81push_back%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/wiki/C++语言/container/forward_list不支持push_back操作/</id>
    <published>2018-06-27T02:07:12.000Z</published>
    <updated>2018-06-27T02:40:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么forward-list不支持push-back操作？"><a href="#为什么forward-list不支持push-back操作？" class="headerlink" title="为什么forward_list不支持push_back操作？"></a>为什么forward_list不支持push_back操作？</h2><p>由于forward_list是单向链表，所以我们如果想要访问尾元素，都要从首元素开始跌代，算法复杂度为O(n)。而对于list为双向链表，直接通过尾指针可以访问尾元素，实现在尾元素添加元素，函数复杂度为O(1)，而vector，string,deque,也可以通过尾指针来添加元素，函数复杂度为O(1)。</p><p>同样的原因也有forward_list不支持pop_back。<br>由于类似原因(算法的复杂度)，有vector，string，不支持push_front，pop_front，但是通过insert，和erase操作仍然可以完成添加/删除首元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么forward-list不支持push-back操作？&quot;&gt;&lt;a href=&quot;#为什么forward-list不支持push-back操作？&quot; class=&quot;headerlink&quot; title=&quot;为什么forward_list不支持push_back操作？&quot;&gt;
      
    
    </summary>
    
      <category term="C++语言" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/"/>
    
      <category term="container" scheme="http://yoursite.com/categories/C-%E8%AF%AD%E8%A8%80/container/"/>
    
    
      <category term="forward_list" scheme="http://yoursite.com/tags/forward-list/"/>
    
  </entry>
  
</feed>
