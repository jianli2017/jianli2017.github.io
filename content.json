{"pages":[{"title":"About","date":"2018-02-12T11:54:24.000Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-02-12T11:54:24.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-02-12T11:54:24.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"自己搭建博客的经历","date":"2018-02-13T07:33:17.000Z","path":"wiki/工具/hexo/自己搭建博客的经历/","text":"本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。 ##初始化hexo 新建博客的文件夹 12~/Desktop/jiangli2017 cd ~/Desktop/jianli2017 初始化hexo 1hexo init hexo init本博客根据自己的喜好，选择的Wikitten主题，这个主题类似wiki，具有文章的目录结构。 进入你的 hexo 站点文件夹，克隆 Wikitten 主题到 themes/ 路径下 12cd ~/Desktop/jiangli2017 git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 覆盖站点目录中一些默认页面模板 12cp -rf themes/Wikitten/_source/* source/cp -rf themes/Wikitten/_scaffolds/* scaffolds/ 重命名主题中的 _config.yml.example 到 _config.yml，然后可以使用配置文件配置主题 123cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# 编辑配置文件，定制你的配置项vim themes/Wikitten/_config.yml 大部分的配置项都和 icarus 主题中的配置项一样，你可以首先去阅读一下 icraus 的文档。 需要安装的插件写在主题的 package.json 文件中 这里列出了这些插件的功能作用： 12345hexo-autonofollow // 打开非本站链接时自动开启新标签页hexo-directory-category // 根据文章文件目录自动为文章添加分类hexo-generator-feed // 生成 RSS 源hexo-generator-json-content // 生成全站文章 json 内容，用于全文搜索hexo-generator-sitemap // 生成全站站点地图 sitemap 你可以将这些插件合并到站点的 package.json 文件中通过 npm install 一次安装， 或者在站点目录下，你可以通过以下命令安装他们： 1$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap 配置站点配置下面是站点推荐配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758yaml# Hexo Configuration# URLpermalink: wiki/:title/# Directoryskip_render: - README.md - &apos;_posts/**/embed_page/**&apos;# Writingnew_post_name: :title.md # File name of new posts## Markdown## https://github.com/hexojs/hexo-renderer-markedmarked: gfm: true ## Plugins: https://hexo.io/plugins/### JsonContentjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml### Adds nofollow attribute to all external links in your hexo blog posts automatically.nofollow: enable: true exclude: - &lt;your site url domain&gt; # eg: zthxxx.me# Deployment（发布git）## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/jianli2017/jianli2017.github.io.git branch: master # 多级目录结构auto_dir_categorize: enable: true # options:true, false; default is true force: true # options:true, false; default is false 修改站点 _config.yml 文件中的 theme 选项为 Wikitten。 遇到的问题 不能发布到git上面 12hexo dERROR Deployer not found: git 解决办法：hexo目录下安装： 1npm install --save hexo-deployer-git hexo d 没有反应 需要在站点目录下的_config.yml 中添加如下配置： 1234deploy: type: git repo: https://github.com/jianli2017/jianli2017.github.io.git branch: master 图床 我的博客中用相对目录显示图片，无法显示，需要用图床，我选择的是七牛云 参考资料","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"hexo","slug":"工具/hexo","permalink":"http://yoursite.com/categories/工具/hexo/"}]},{"title":"git时光穿梭(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git工作区/","text":"本文全部复制Git教程,自己理解的就简单复制，没有理解的就全部粘贴。 git 配置12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 工作区的状态 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 先用git status查看一下状态： 12345678910111213$ git status# On branch master# Changes not staged for commit:# (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)# (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)## modified: readme.txt## Untracked files:# (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)## LICENSEno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 12345678$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## new file: LICENSE# modified: readme.txt# 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m &quot;understand how stage works&quot;[master 27c9860] understand how stage works 2 files changed, 675 insertions(+) create mode 100644 LICENSE 123$ git status# On branch masternothing to commit (working directory clean) 小结暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 12345678$ git add readme.txt$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD ...&quot; to unstage)## modified: readme.txt# 12345$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 123$ git commit -m &quot;git tracks changes&quot;[master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别： 1234567891011$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 1$ git checkout -- readme.txt 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 1234567$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD ...&quot; to unstage)## modified: readme.txt# 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt 再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 12345$ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退][1]一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退][2]一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： 12345$ git add test.txt$ git commit -m &quot;add test.txt&quot;[master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 1$ rm test.txt 123456789$ git status# On branch master# Changes not staged for commit:# (use &quot;git add/rm ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## deleted: test.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 123456$ git rm test.txtrm &apos;test.txt&apos;$ git commit -m &quot;remove test.txt&quot;[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt 小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}]},{"title":"Git分支管理(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git分支管理/","text":"本文全部复制Git教程,自己理解的就简单复制，没有理解的就全部粘贴。 创建和合并分支在[版本回退][1]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： 12$ git checkout -b devSwitched to a new branch &apos;dev&apos; 123$ git branch dev$ git checkout devSwitched to branch &apos;dev&apos; 123$ git branch* dev master 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： 1Creating a new branch is quick. 1234$ git add readme.txt $ git commit -m &quot;branch test&quot;[dev fec145a] branch test 1 file changed, 1 insertion(+) 12$ git checkout masterSwitched to branch &apos;master&apos; 现在，我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was fec145a). 12$ git branch* master 小结Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch dev 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch &apos;feature1&apos; 1Creating a new branch is quick AND simple. 1234$ git add readme.txt $ git commit -m &quot;AND simple&quot;[feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 123$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 1 commit. 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 1234$ git add readme.txt $ git commit -m &quot;&amp; simple&quot;[master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 12345678910$ git status# On branch master# Your branch is ahead of &apos;origin/master&apos; by 2 commits.## Unmerged paths:# (use &quot;git add/rm ...&quot; as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 1Creating a new branch is quick and simple. 123$ git add readme.txt $ git commit -m &quot;conflict fixed&quot;[master 59bc1cb] conflict fixed 用带参数的git log也可以看到分支的合并情况： 12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 12$ git branch -d feature1Deleted branch feature1 (was 75a857c). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 分支管理策略合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 12345678910111213$ git status# On branch dev# Changes to be committed:# (use &quot;git reset HEAD ...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## modified: readme.txt# 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 12345$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 6 commits.$ git checkout -b issue-101Switched to a new branch &apos;issue-101&apos; 1234$ git add readme.txt $ git commit -m &quot;fix bug 101&quot;[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 123456789$ git checkout masterSwitched to branch &apos;master&apos;Your branch is ahead of &apos;origin/master&apos; by 2 commits.$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101Merge made by the &apos;recursive&apos; strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 12345$ git checkout devSwitched to branch &apos;dev&apos;$ git status# On branch devnothing to commit (working directory clean) 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234567891011121314$ git stash pop# On branch dev# Changes to be committed:# (use &quot;git reset HEAD ...&quot; to unstage)## new file: hello.py## Changes not staged for commit:# (use &quot;git add ...&quot; to update what will be committed)# (use &quot;git checkout -- ...&quot; to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 1$ git stash list 1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 ##feature 分支 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 1$ git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into &apos;learngit&apos;...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 12$ git branch* master 1$ git checkout -b dev origin/dev 1234567891011$ git commit -m &quot;add /usr/bin/env&quot;[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112$ git add hello.py $ git commit -m &quot;add coding: utf-8&quot;[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to &apos;git@github.com:michaelliao/learngit.git&apos;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. &apos;git pull&apos;)hint: before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details. 12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/ 12$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 12345678910$ git commit -m &quot;merge &amp; fix hello.py&quot;[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch &apos;master&apos; 1$ git tag v1.0 12$ git tagv1.0 方法是找到历史提交的commit id，然后打上就可以了： 1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 1$ git tag v0.9 6224937 123$ git tagv0.9v1.0 1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author: Michael Liao Date: Thu Aug 22 11:22:08 2013 +0800 add merge... 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 3628164 123456789101112$ git show v0.1tag v0.1Tagger: Michael Liao Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao Date: Tue Aug 20 15:11:49 2013 +0800 append GPL 1$ git tag -s v0.2 -m &quot;signed version 0.2 released&quot; fec145a 123gpg: signing failed: secret key not availableerror: gpg failed to sign the dataerror: unable to sign the tag 用命令git show 可以看到PGP签名信息： 1234567891011121314151617$ git show v0.2tag v0.2Tagger: Michael Liao Date: Mon Aug 26 07:28:33 2013 +0800signed version 0.2 released-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.12 (Darwin)iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...-----END PGP SIGNATURE-----commit fec145accd63cdc9ed95a2f557ea0658a2a6537fAuthor: Michael Liao Date: Thu Aug 22 10:37:30 2013 +0800 branch test 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…”可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 标签操作 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}]},{"title":"Git仓库(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git仓库/","text":"本文全部复制Git教程,自己理解的就简单复制，没有理解的就全部粘贴。 添加远程库小结要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 克隆远程仓库1git clone git@github.com:michaelliao/gitskills.git 使用码云使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。 如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——[码云][1]（[gitee.com][2]）。 和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。 码云的免费版本也提供私有库功能，只是有5人的成员上限。 使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去： 点击“确定”即可完成并看到刚才添加的Key： 如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？ 首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”： 项目名称最好与本地库保持一致： 然后，我们在本地库上使用命令git remote add把它和码云的远程库关联： 1git remote add origin git@gitee.com:liaoxuefeng/learngit.git 如果在使用命令git remote add时报错： 12git remote add origin git@gitee.com:liaoxuefeng/learngit.gitfatal: remote origin already exists. 123git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 我们可以删除已有的GitHub远程库： 1git remote rm origin 1git remote add origin git@gitee.com:liaoxuefeng/learngit.git 123git remote -vorigin git@gitee.com:liaoxuefeng/learngit.git (fetch)origin git@gitee.com:liaoxuefeng/learngit.git (push) 有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？ 答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库： 1git remote rm origin 1git remote add github git@github.com:michaelliao/learngit.git 接着，再关联码云的远程库： 1git remote add gitee git@gitee.com:liaoxuefeng/learngit.git 现在，我们用git remote -v查看远程库信息，可以看到两个远程库： 12345git remote -vgitee git@gitee.com:liaoxuefeng/learngit.git (fetch)gitee git@gitee.com:liaoxuefeng/learngit.git (push)github git@github.com:michaelliao/learngit.git (fetch)github git@github.com:michaelliao/learngit.git (push) 1git push github master 1git push gitee master 码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：[https://gitee.com/liaoxuefeng/learngit][3]，创建一个your-gitee-id.txt的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在码云和GitHub做双向同步。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}]},{"title":"hexo使用指南","date":"2018-02-07T07:57:29.000Z","path":"wiki/工具/hexo/hexo-use/","text":"使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC） 常用命令123hexo n #写文章hexo g #生成hexo d #部署 # 可与hexo g合并为 hexo d -g 环境搭建 安装Node.js 安装git（Xcode自带） 安装hexo hexo 是基于Node.js的静态博客程序，使用npm 安装： 1npm install -g hexo GitHub 首先注册一个『GitHub』帐号 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 说明 git使用两种协议传输：https、git，如我的blog 的两种协议git地址如下： git@github.com:jianli2017/jianli2017.github.io.githttps://github.com/jianli2017/jianli2017.github.io.git SSH 作用于git协议，使用SSH 后，git协议的push、pull操作不需要输入密码。 初始化使用hexo init 命令在当前目录下初始化一个hexo项目 生成静态页面cd 到你的init目录，执行如下命令，生成静态页面到 ./public/目录。 1hexo generate 本地启动执行如下命令，启动本地服务，进行文章预览调试。 1hexo server 写文章执行new命令，生成指定名称的文章至hexo/source/_posts/postName.md。 1hexo new [lay“out] &quot;postName&quot; #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md 123title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: 请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories: tags: postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 注意，所有文件：后面都必须有个空格，不然会报错。 看一下刚才生成的文件hexo/source/_posts/postName.md，内容如下： 1234title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格 fancybox可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片： 1234567layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 经过测试，文件头上的layout: photo可以省略。 不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md 12345layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: photos: 然后每次可以执行带layout的new命令生成照片文章： 1hexo new photo &quot;photoPostName&quot; #新建照片文章 descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。 12345title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述 hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。 文章摘要在需要显示摘要的地方添加如下代码即可： 123以上是摘要&lt;!--more--&gt;以下是余下全文 more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 hexo中所有文件的编码格式均是UTF-8。 主题安装安装主题的方法就是一句git命令： 1git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 目录是否是modernist无所谓，只要与_config.yml文件一致即可。 安装完成后，打开hexo/_config.yml，修改主题为modernist 1theme: modernist 打开hexo/themes/modernist目录，编辑主题配置文件_config.yml： 1234567891011121314151617181920212223menu: #配置页头显示哪些菜单# Home: / Archives: /archives Reading: /reading About: /about# Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件 - category# - tag - tagcloud - recent_posts# - blogrollblogrolls: #友情链接 - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com - bruce sha&apos;s javaeye: http://buru.iteye.com - bruce sha&apos;s oschina blog: http://my.oschina.net/buru - bruce sha&apos;s baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss: #更新 更新hexo： 1npm update -g hexo 参考 hexo你的博客 Hexo静态博客搭建+个人定制 hexo搭建的Github博客绑定域名 初次安装git配置用户名和邮箱","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}]},{"title":"","date":"2018-01-29T22:35:00.000Z","path":"wiki/工具/git/git简略版/git简略版/","text":"Git笔记 Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git SVN和Git主要的区别在于历史版本维护的位置 Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。 这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。Git命令Git配置12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个Git仓库1$ git init 添加文件到Git仓库包括两步：12$ git add &lt;file&gt;$ git commit -m \"description\" git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1$ git status 查看修改内容1$ git diff 1$ git diff --cached 1$ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别查看提交日志1$ git log 简化日志输出信息1$ git log --pretty=oneline 查看命令历史1$ git reflog 版本回退1$ git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。 回退指定版本号1$ git reset --hard commit_id commit_id是版本号，是一个用SHA1计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。 进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支撤销修改丢弃工作区的修改1$ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：1$ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改1$ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1$ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行12$ rm &lt;file&gt;$ git add &lt;file&gt; 进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区12$ git reset head text.txt$ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库创建SSH Key1$ ssh-keygen -t rsa -C \"youremail@example.com\" 关联远程仓库1$ git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库1$ git push -u origin master -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆1$ git clone https://github.com/usern/repositoryname.git 分支创建分支1$ git branch &lt;branchname&gt; 查看分支1$ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支1$ git checkout &lt;branchname&gt; 创建+切换分支1$ git checkout -b &lt;branchname&gt; 合并某分支到当前分支1$ git merge &lt;branchname&gt; 删除分支1$ git branch -d &lt;branchname&gt; 查看分支合并图1$ git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支1$ git merge --no-ff -m \"description\" &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场1$ git stash 查看工作现场1$ git stash list 恢复工作现场1$ git stash pop 丢弃一个没有合并过的分支1$ git branch -D &lt;branchname&gt; 查看远程库信息1$ git remote -v 在本地创建和远程分支对应的分支1$ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1$ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1$ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交； 从远程抓取分支1$ git pull 如果有冲突，要先处理冲突。 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 新建一个标签1$ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 指定标签信息1$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签1$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。 查看所有标签1$ git tag 推送一个本地标签1$ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1$ git push origin --tags 删除一个本地标签1$ git tag -d &lt;tagname&gt; 删除一个远程标签1$ git push origin :refs/tags/&lt;tagname&gt;","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/工具/git/"},{"name":"git简略版","slug":"工具/git/git简略版","permalink":"http://yoursite.com/categories/工具/git/git简略版/"}]},{"title":"dispatch_semaphore 的使用方法","date":"2017-02-11T07:35:49.000Z","path":"wiki/IOS基础知识/GCD/use-dispatch-semaphore/","text":"转载请注明出处 关于dispatch_semaphore的使用。dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。 下面我们逐一介绍三个函数： dispatch_semaphore_createdispatch_semaphore_create的声明为： dispatch_semaphore_t dispatch_semaphore_create(long value); 传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。 dispatch_semaphore_signaldispatch_semaphore_signal的声明为： long dispatch_semaphore_signal(dispatch_semaphore_t dsema) 这个函数会使传入的信号量dsema的值加1； dispatch_semaphore_waitdispatch_semaphore_wait的声明为： long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)； 这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。 返回值dispatch_semaphore_signal的返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。dispatch_semaphore_wait的返回值也为long型。当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。当其返回不为0时，表示timeout发生。 宏在设置timeout时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。 DISPATCH_TIME_NOW 表示当前； DISPATCH_TIME_FOREVER 表示遥远的未来； 一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。利用创建dispatch_time创建dispatch_time_t类型变量的时候一般也会用到这两个变量。 dispatch_time的声明如下： dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)； 其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。例如： dispatch_time_t t = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); 表示当前时间向后延时一秒为timeout的时间。 关于信号量，一般可以用停车来比喻。停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。 示例代码举简单示例如下： dispatch_semaphore_t signal; signal = dispatch_semaphore_create(1); __block long x = 0; NSLog(@&quot;0_x:%ld&quot;,x); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ sleep(1); NSLog(@&quot;waiting&quot;); x = dispatch_semaphore_signal(signal); NSLog(@&quot;1_x:%ld&quot;,x); sleep(2); NSLog(@&quot;waking&quot;); x = dispatch_semaphore_signal(signal); NSLog(@&quot;2_x:%ld&quot;,x); }); // dispatch_time_t duration = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); //超时1秒 // dispatch_semaphore_wait(signal, duration); x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER); NSLog(@&quot;3_x:%ld&quot;,x); x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER); NSLog(@&quot;wait 2&quot;); NSLog(@&quot;4_x:%ld&quot;,x); x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER); NSLog(@&quot;wait 3&quot;); NSLog(@&quot;5_x:%ld&quot;,x); 最终打印的结果为： 2014-08-11 22:51:54.734 LHTest[15700:70b] 0_x:0 2014-08-11 22:51:54.737 LHTest[15700:70b] 3_x:0 2014-08-11 22:51:55.738 LHTest[15700:f03] waiting 2014-08-11 22:51:55.739 LHTest[15700:70b] wait 2 2014-08-11 22:51:55.739 LHTest[15700:f03] 1_x:1 2014-08-11 22:51:55.739 LHTest[15700:70b] 4_x:0 2014-08-11 22:51:57.741 LHTest[15700:f03] waking 2014-08-11 22:51:57.742 LHTest[15700:f03] 2_x:1 2014-08-11 22:51:57.742 LHTest[15700:70b] wait 3 2014-08-11 22:51:57.742 LHTest[15700:70b] 5_x:0","tags":[{"name":"dispatch_semaphore GCD","slug":"dispatch-semaphore-GCD","permalink":"http://yoursite.com/tags/dispatch-semaphore-GCD/"}],"categories":[{"name":"GCD","slug":"GCD","permalink":"http://yoursite.com/categories/GCD/"}]},{"title":"搭建weex断点调试环境","date":"2016-12-28T01:48:40.000Z","path":"wiki/Hybird研究/weex/weex-debug/","text":"Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。 Weex Devtools 基于 Chrome devtools 实现了 Chrome Debugging Protocol，能够使用Chrome devtools调试 Weex 项目，其主要功能分为两大部分—— Debugger 和 Inspector。若使用Devtools调试weex项目，需要搭建调试环境，包括两部分：安装weex-devtool模块、App项目中集成weex-devtool SDK。 安装weex-devtool 模块weex-devtool是node.js的一个模块，用来启动服务器和Chrome页面，安装weex-devtool需要使用npm安装，由于使用npm安装特别慢，有时候一点速度都没有，这里使用淘宝的镜像源，切换方法： npm install cnpm -g --registry=https://registry.npm.taobao.org 切换完后，使用cnpm安装weex-devtool： cnpm install -g weex-devtool weex-devtool 的用法： weex debug [options] [we_file|bundles_dir] 选项有下面几种： -h, --help 显示帮助 -V, --verbose 显示debug服务器运行时的各种log -v, --version 显示版本 -p, --port [port] 设置debug服务器端口号 默认为8088 -e, --entry [entry] debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码) -m, --mode [mode] 设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer 启动服务和chrome页面： weex debug 输出如下： bogon:~ lijian$ weex debug start debugger server at http://10.144.36.206:8088 The websocket address for native is ws://10.144.36.206:8088/debugProxy/native Launching Dev Tools... 输出上面的内容，表示weex-devtool已经并启动。其中ws://10.144.36.206:8088/debugProxy/native是APP连接到Chrome的调试的地址。App集成weex-devtool-iOS后，需要使用这个地址。 APP集成weex-devtool-iOS SDK集成weex-devtool-iOS SDK，可以参考weex-devtool-iOS将 weex-devtool-iOS 集成到项目中。这篇文章中介绍了pod集成方法和源码集成方法。这里假设已经集成完成。直接到使用SDK的步骤。在AppDelegate中添加下面的代码，就可以使APP链接到Chrome的调试环境： #import &lt;WXDevtool.h&gt; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://10.144.36.206:8088/debugProxy/native&quot;]; setDebug:参数为YES时，直接开启debug模式，反之关闭。launchDevToolDebugWithUrl 中的url就是在控制台启动Chrome时输出的地址。 调试到目前为止，环境已配置完成，可以体验下调试过程。启动App，App会连接到chrome，Chrome中会显示出连接上的APP，如下： 如图所示，有两个功能debug（调试）、inspector（元素省察）。其中debug可以调试JS的代码；inspector 可以审查界面的元素。点击debuger，进入调试提示页面，界面如下：界面提示：使用option+commond+j进入调试JS代码界面，点击Sources标签，左边的导航栏显示源码列表，可以切换源码。调试面板包括设置断点、单步执行、查看运行时变量值等功能。 具体详细的调试方法请参考如何使用 Devtools 调试 Weex 页面。","tags":[{"name":"weex断点调试","slug":"weex断点调试","permalink":"http://yoursite.com/tags/weex断点调试/"}],"categories":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/categories/weex/"}]},{"title":"weex 事件原理分析","date":"2016-12-16T09:46:54.000Z","path":"wiki/Hybird研究/weex/event-analize/","text":"weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。 事件传递过程分析本节通过一段示例代码，分析事件的传递过程。如果要实现一个点击事件，只需要在模板的某个标签下添加类似的代码onclick=”clickTest”，具体如下： &lt;template&gt; &lt;div&gt; &lt;text class=&quot;btn&quot; onclick=&quot;clickTest&quot;&gt;测试点击事件&lt;/text&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; module.exports = { data: { }, methods: { clickTest: function (e) { console.log(&apos;$event.type + $event.detail&apos;); }, } } &lt;/script&gt; 上面这段代码就是给text标签添加点击事件，事件的响应函数为clickTest。执行上面的JS代码，weex渲染text标签为Native的WXText组件，会调用WXText的初始化函数，定义如下： - (instancetype)initWithRef:(NSString *)ref type:(NSString*)type styles:(nullable NSDictionary *)styles attributes:(nullable NSDictionary *)attributes events:(nullable NSArray *)events weexInstance:(WXSDKInstance *)weexInstance; 从定义可以看到，参数events会传入组件包含的事件列表，也就是说，weex将text标签中的on开头的属性都当做事件，渲染时，传递到Native中，本例中，events的值为click，接下来继续看initWithRef:type:styles:attributes:events:weexInstance中怎么处理events的。 @property (nonatomic, readonly, strong) NSArray *events; @property(nonatomic, readonly, strong) UIView *view; - (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance { .... _events = events ? [NSMutableArray arrayWithArray:events] : [NSMutableArray array]; .... } - (UIView *)view { ... [self _initEvents:self.events]; ... } 上面代码说明，在初始化文本组件WXText（WXComponent的子类）时，将事件列表保存到events属性中。当加载组件的view到父视图的时候，会调用属性view的get方法，在get方法中初始化所有的事件。下面是初始化事件的代码。 - (void)_initEvents:(NSArray *)events { NSArray *eventsCopy = [events copy]; for (NSString *addEventName in eventsCopy) { [self _addEventOnMainThread:addEventName]; } } - (void)_addEventOnMainThread:(NSString *)addEventName { WX_ADD_EVENT(appear, addAppearEvent) WX_ADD_EVENT(disappear, addDisappearEvent) WX_ADD_EVENT(click, addClickEvent) WX_ADD_EVENT(swipe, addSwipeEvent) WX_ADD_EVENT(longpress, addLongPressEvent) WX_ADD_EVENT(panstart, addPanStartEvent) WX_ADD_EVENT(panmove, addPanMoveEvent) WX_ADD_EVENT(panend, addPanEndEvent) WX_ADD_EVENT(touchstart, addTouchStartEvent) WX_ADD_EVENT(touchmove, addTouchMoveEvent) WX_ADD_EVENT(touchend, addTouchEndEvent) WX_ADD_EVENT(touchcancel, addTouchCancelEvent) [self addEvent:addEventName]; } #define WX_ADD_EVENT(eventName, addSelector) \\ if ([addEventName isEqualToString:@#eventName]) {\\ [self addSelector];\\ } - (void)addClickEvent { if (!_tapGesture) { _tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onClick:)]; _tapGesture.delegate = self; [self.view addGestureRecognizer:_tapGesture]; } } 上面的代码说明初始化事件就是给文本组件的view属性添加一个点击手势tapGesture， 手势的响应函数为onClick。 - (void)onClick:(__unused UITapGestureRecognizer *)recognizer { NSMutableDictionary *position = [[NSMutableDictionary alloc] initWithCapacity:4]; if (!CGRectEqualToRect(self.calculatedFrame, CGRectZero)) { CGRect frame = [self.view.superview convertRect:self.calculatedFrame toView:self.view.window]; position[@&quot;x&quot;] = @(frame.origin.x); position[@&quot;y&quot;] = @(frame.origin.y); position[@&quot;width&quot;] = @(frame.size.width); position[@&quot;height&quot;] = @(frame.size.height); } [self fireEvent:@&quot;click&quot; params:@{@&quot;position&quot;:position}]; } - (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params { [self fireEvent:eventName params:params domChanges:nil]; } - (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges { NSMutableDictionary *dict = [NSMutableDictionary dictionary]; NSTimeInterval timeSp = [[NSDate date] timeIntervalSince1970] * 1000; [dict setObject:@(timeSp) forKey:@&quot;timestamp&quot;]; if (params) { [dict addEntriesFromDictionary:params]; } [[WXSDKManager bridgeMgr] fireEvent:self.weexInstance.instanceId ref:self.ref type:eventName params:dict domChanges:domChanges]; } 上面的代码说明：在手势响应函数中，最后调用weex的WXBridgeManager中的fireEvent函数。代码如下： - (void)fireEvent:(NSString *)instanceId ref:(NSString *)ref type:(NSString *)type params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges { if (!type || !ref) { WXLogError(@&quot;Event type and component ref should not be nil&quot;); return; } NSArray *args = @[ref, type, params?:@{}, domChanges?:@{}]; NSMutableDictionary *methodDict = [NSMutableDictionary dictionaryWithObjectsAndKeys: @&quot;fireEvent&quot;, @&quot;method&quot;, args, @&quot;args&quot;, nil]; WXBridgeMethod *method = [[WXBridgeMethod alloc] initWithInstance:instanceId data:methodDict]; [self executeJsMethod:method]; } - (void)executeJsMethod:(WXBridgeMethod *)method { if (!method) return; __weak typeof(self) weakSelf = self; WXPerformBlockOnBridgeThread(^(){ [weakSelf.bridgeCtx executeJsMethod:method]; }); } 上面的代码说明： fireEvent实际上就是执行JS的fireEvent函数，JS的fireEvent函数会根据传递的参数找到组件、组件的事件、事件响应函数，最后执行事件。本例中就是第一段JS代码的clickTest函数。其中传递的参数本例如下： { args =( ///ref（组件的标记） 5, ///type（事件类型） click, ///params { ///事件触发的位置 position ={ height = &quot;39.5&quot;; width = 768; x = 0; y = 64; }; timestamp = &quot;1481882724298.018&quot;; }, ///domChanges（是否更新界面） { } ); ///JS的方法 method = fireEvent; } 到目前为止，weex的事件传递机制讲完了，下面做个简单的总结。 总结weex的事件处理机制是： 在JS中定义标签的事件类型、事件的处理函数，在Native实现事件。原理是：将标签初始化为组件的时候，初始化标签的事件。其中click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel初始化为手势事件，appear、disappear初始化为滑动视图的出现事件和消息事件。当事件触发时，通过WXBridgeManager调用JS的fireEvent函数，在JS中调用标签的事件处理函数。下面是做了一张大概的原理图。图中红色部分是JS逻辑，黑色部分是组件的逻辑，蓝色部分是WXBridgeManager逻辑。","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/categories/weex/"}]},{"title":"weex 通信原理分析","date":"2016-12-13T10:01:31.000Z","path":"wiki/Hybird研究/weex/weex-conmunication/","text":"本文首先简单阐述了JavaScriptCore中JS和Native的通信机制，在此基础上，分析了weex中的JS和Native的通信机制。 万物之源 -JavaScriptCore不论是RN、weex、JSPatch，他们的核心交互机制都使用JavaScriptCore，通过它完成JS和Native的通信。关于JavaScriptCore的简单介绍可以参考IOS7开发～JavaScriptCore （一），这里只简单提及下。 关键类-JSContext、JSValueJavaScriptCore中的两个关键类： JSContext(JS脚本的执行环境) JSValue（JS 和Native传值的载体） JSContext 的核心方法- (JSValue )evaluateScript:(NSString )script;，功能是执行JS脚本代码，执行完后，会将JS中的对象、方法添加到JSContext上下文中的全局对象中。这样就可以通过JSContext引用到JS代码中的对象、方法。 JSValue是用来呈现JS的对象，它可以将JS中的对象、方法转化为Native的对象、函数，反之亦然。下面是JSValue的两个核心方法： - (JSValue *)callWithArguments:(NSArray *)arguments; - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments; 如果JSValue实例代表JS中一个函数变量（变量中存储的是函数），用callWithArguments调用JS的函数。如果拿到了JS代码的执行环境的全局对象，可以向全局对象发送invokeMethod消息调用JS中的函数。参数包括JS的函数名称、调用参数。 Native调用JS机制可以使用JSValue 的callWithArguments 和 invokeMethod方法 单独调用JS中的某个函数 。也可以使用JSContext 的evaluateScript方法执行整个JS代码。下面给出一个例子，其中，test.js的内容如下 ///匿名函数 var functionVar = function(num) { return num + 1; } function jsFucton(num) { return num + 1; } jsFucton(2); 测试代码如下： -(void) nativeCallJS { NSString *path = [[NSBundle mainBundle]pathForResource:@&quot;test&quot;ofType:@&quot;js&quot;]; NSString *testScript = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; JSContext *jsContext = [[JSContext alloc] init]; ///1.执行整个JS代码 JSValue *resultEvaluate =[jsContext evaluateScript:testScript]; NSLog(@&quot;resultEvaluate = %@&quot;,[resultEvaluate toObject]); ///2. callWithArguments 调用方式 JSValue *fuctionVar = jsContext[@&quot;functionVar&quot;]; JSValue *resultVar = [fuctionVar callWithArguments:@[@(4)]]; NSLog(@&quot;resultVar = %@&quot;,[resultVar toObject]); ///3. invokeMethod 调用方式 JSValue *resultFuction = [[jsContext globalObject] invokeMethod:@&quot;jsFucton&quot; withArguments:@[@(6)]]; NSLog(@&quot;resultFuction = %@&quot;,[resultFuction toObject]); } 输出如下： 2016-12-14 13:36:27.237 Test2222[15246:172495] resultEvaluate = 3 2016-12-14 13:36:27.238 Test2222[15246:172495] resultVar = 5 2016-12-14 13:36:30.166 Test2222[15246:172495] resultFuction = 7 例子中展示了使用JSContext的evaluateScript:方法执行整个JS代码，调用完evaluateScript之后，会将JS代码中的变量、方法添加到jsContext的全局对象中，这样可以使用jsContext[@”functionVar”]访问到JS中的functionVar对象。在JS中，functionVar是一个函数对象，可以向fuctionVar发送callWithArguments消息，执行JS中的functionVar变量中存储的函数。同时也可以使用[[jsContext globalObject] invokeMethod:@”jsFucton” withArguments:@[@(6)]]调用到JS中的jsFucton函数。 上面是Native调用JS的三种方式。每种方式使用的场景不同。 JS调用Native机制JS调用Native有两种方式： block JSExport 主要介绍Block方式，因为weex中使用的是Block方式，直接以代码为例： -(NSString *) nativeFuction:(NSString *) strParam1 param2:(NSString *)strParam2 { return [NSString stringWithFormat:@&quot;%@_%@&quot;,strParam1,strParam2]; } -(void) JSCallNative { JSContext *jsContext = [[JSContext alloc] init]; ///给JS添加一个方法，JS就能调用到Native的方法 __weak typeof(self) weakSelf = self; jsContext[@&quot;jsMethod&quot;] = ^(NSString * strParam1, NSString *strParam2) { NSString * strResult = [weakSelf nativeFuction:strParam1 param2:strParam2]; return strResult; }; JSValue *strResult = [jsContext evaluateScript:@&quot;jsMethod(&apos;这是第一个参数&apos;,&apos;这是第二个参数&apos;)&quot;]; NSLog(@&quot;strResult = %@&quot;,[strResult toObject]); } 输出： strResult = 这是第一个参数_这是第二个参数 在Native中block相当于JS中的function，jsContext[@”jsMethod”]=…相当于给JS添加一个名为jsMethod的function，不过，这个jsMethod的实现是Native的代码。在JS中执行jsMethod方法，就会调用到Native的代码。 小小结了解了JSContext、JSValue、Native和JS的交互机制，是看懂weex的前提。不论weex如何封装，都离不开上面的基本原理。Native调用JS有三种方式： JSValue 的callWithArguments JSValue的invokeMethod JSContext的evaluateScript JS调用Native有两种方式 block JSExport 刨根问底-weex的交互机制这一节我一步步的分析weex的通信原理，目标两个： 了解weex通信原理 了解通信原理相关的两个重要部分Module、Bridge。 具体的思路是找到SDK初始化的入口，顺着入口逐渐深入分析。直到了解weex的通信机制为止。 寻踪觅迹- 分析初始化weex SDK的入口是WXSDKEngine类，WXSDKEngine 是一个全局类。其中，initSDKEnviroment:完成sdk的初始化工作： + (void)initSDKEnviroment:(NSString *)script { [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers]; [[WXSDKManager bridgeMgr] executeJsFramework:script]; } weex有中有三个重要的部分：Components、Modules、Handlers。Components 是布局Native界面的元素，例如UILabel对应的组件是WXTextComponent，他和html元素text对应。Modules是Native的功能模块，是JS可以访问的Native类。应该封装了必须有Native完成的功能。我们主要关注Modules模块，他是weex中Native和JS通信的核心部分。_registerDefaultModules是注册默认的Module： + (void)_registerDefaultModules { [self registerModule:@&quot;dom&quot; withClass:NSClassFromString(@&quot;WXDomModule&quot;)]; [self registerModule:@&quot;navigator&quot; withClass:NSClassFromString(@&quot;WXNavigatorModule&quot;)]; ..... } 这段代码是注册weex提供给开发者的默认模块。每个模块都实现某种功能，它是JS可以调用的Native类。接着分析registerModule函数： + (void)registerModule:(NSString *)name withClass:(Class)clazz { ///注册native的module NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz]; ///组成JS的module NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName]; [[WXSDKManager bridgeMgr] registerModules:dict]; } 这段代码完成两个功能，初始化Native端Module的配置信息、初始化JS端Module的配置信息。到目前为止，我们已经找到了weex的入口，后续部分需要分两个单独的模块分析讲解。一个是Module，一个是通信机制。 刨根问底-配置信息和ModuleModule 相关的类有WXModuleFactory、WXModuleManager、WXModuleProtocol。三个类的类图如下：WXModuleManager只有一个方法，-dispatchMethod:(WXBridgeMethod *)method，根据传入的method在配置文件中找到方法并执行。WXModuleFactory是Module的工厂类，存储着所有Module的配置信息。WXModuleProtocol是Module需要遵守的协议。只有遵守了WXModuleProtocol协议的Native类才叫做Module，他才会被添加到Native和JS的配置信息中，这样JS就可以调用到这个类中的方法。这里贴出WXModuleProtocol的代码如下： ///1. 定义了module JS 回调native的方法 typedef void (^WXModuleCallback)(id result); typedef void (^WXModuleKeepAliveCallback)(id result, BOOL keepAlive); #define WX_EXPORT_METHOD(method) \\ + (NSString *)WX_CONCAT_WRAPPER(wx_export_method_, __LINE__) { \\ return NSStringFromSelector(method); \\ } ///2. 导出类 #define WX_EXPORT_MODULE(module) ///3. 导出方法 (其实是定义了一个类方法 ) WX_EXPORT_METHOD(@selector(getNetUrl:page:sucCallBack:failCallBack:)) ///4. 执行方法的线程 - (NSThread *)targetExecuteThread; @property (nonatomic, weak) WXSDKInstance *weexInstance; 主要有三部分： 定义回调 定义导出Native方法的方法 定义Native方法的执行线程。 回调就是JS执行完Native代码后，可以回调的JS的代码。定义导出方法就是：给每个导出方法定义一个类方法，类方法的名字大概就是wx_export_method_100这种样式，返回导出的方法名称。这样做的目的就是不用初始化Module类，就能获取到Module的导出方法信息，并加入到两端的配置信息中。targetExecuteThread是定义了所有的导出方法执行的线程。如果没有实现，默认在主线程执行方法。如果实现，返回对应的线程，就在该线程中执行方法。到目前为止，Native端的Module配置信息都讲完了。总结为：配置信息中包括了所有Module的导出方法、Module的名称、对应的类。接下来简单分析下JS端的配置信息。注册Module的信息到JS，调用的是WXBridgeManager的registerModules 方法： - (void)registerModules:(NSDictionary *)modules { if (!modules) return; __weak typeof(self) weakSelf = self; WXPerformBlockOnBridgeThread(^(){ [weakSelf.bridgeCtx registerModules:modules]; }); } registerModules: 调用了WXBridgeContext中的registerModules:方法，代码如下： - (void)registerModules:(NSDictionary *)modules { [self callJSMethod:@&quot;registerModules&quot; args:@[modules]]; } 内部调用了JS中的方法registerModules，下面转入到main.js，registerModules代码如下： function registerModules(modules) { if((typeof modules===&quot;undefined&quot;?&quot;undefined&quot;:_typeof(modules))===&quot;object&quot;) { (0,_register.initModules)(modules) } } function initModules(modules,ifReplace) { var _loop=function _loop(moduleName) { var methods=nativeModules[moduleName]; if(!methods) { methods={}; nativeModules[moduleName]=methods } modules[moduleName].forEach( function(method) { if(typeof method===&quot;string&quot;) { method={name:method} } if(!methods[method.name]||ifReplace) { methods[method.name]=method } }) }; for(var moduleName in modules) { _loop(moduleName) } } 大概可以理解为：JS中有个nativeModules变量，这个对象保存着module名称和对应的方法列表。注册就是向nativeModules中添加Module的信息。 终极目标-Bridge(通信机制)接下来了解如何利用这些配置信息完成JS和Native之间的交互。交互就需要一个桥梁，在weex中用Bridge表示。Bridge封装了交互的规则，主要有几个类WXBridgeManager、WXBridgeProtocol、WXBridgeMethod、WXJSCoreBridge、WXBridgeContext。首先将这几个类的类图贴出来：WXBridgeManager是Brider的管理类，承接着Native和JS的交互、调试管理、界面更新、事件传递等任务。具体干活的类是WXBridgeContext和WXJSCoreBridge，其中WXJSCoreBridge是遵守了WXBridgeProtocol协议的类。 图中红色的代码完成Native和JS交互功能的代码。交互分为两部分：JS到Native、Native到JS。首先分析Native到JS这个路径。executeJsMethod: 是Native调用JS的入口方法。内部调用了WXJSCoreBridge的callJSMethod方法，传递的JS方法名是callJS。具体的代码如下： - (void)executeJsMethod:(WXBridgeMethod *)method { .... [sendQueue addObject:method]; [self performSelector:@selector(_sendQueueLoop) withObject:nil]; } - (void)_sendQueueLoop { ///构造方法的相关参数 .... ///调用方法 if ([methods count] &gt; 0 &amp;&amp; execIns) { [self callJSMethod:@&quot;callJS&quot; args:@[execIns, methods]]; } if (hasTask) { [self performSelector:@selector(_sendQueueLoop) withObject:nil]; } } - (void)callJSMethod:(NSString *)method args:(NSArray *)args { if (self.frameworkLoadFinished) { [self.jsBridge callJSMethod:method args:args]; } else { [_methodQueue addObject:@{@&quot;method&quot;:method, @&quot;args&quot;:args}]; } } ///WXJSCoreBridge 的callJSMethod方法 - (JSValue *)callJSMethod:(NSString *)method args:(NSArray *)args { WXLogDebug(@&quot;Calling JS... method:%@, args:%@&quot;, method, args); return [[_jsContext globalObject] invokeMethod:method withArguments:args]; } 上面是Native调用JS的原理 ，下面分析JS调用Native的原理。 当首次调用- (id)jsBridge方法创建Bridge时，会调用Bridge的registerCallNativeJS设置JS调用Native的入口。入口名称为callNative，即JS代码中调用callNative函数，就能调用到Native的代码。当进入Native后，会调用WXBridgeContext的invokeNative方法，内部会查找配置信息，然后invoke相应的方法。代码如下： - (id&lt;WXBridgeProtocol&gt;)jsBridge { ... _jsBridge = _debugJS ? [NSClassFromString(@&quot;WXDebugger&quot;) alloc] : [[WXJSCoreBridge alloc] init]; __weak typeof(self) weakSelf = self; [_jsBridge registerCallNative:^NSInteger(NSString *instance, NSArray *tasks, NSString *callback) { return [weakSelf invokeNative:instance tasks:tasks callback:callback]; }]; .... return _jsBridge; } - (void)registerCallNative:(WXJSCallNative)callNative { NSInteger (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^(JSValue *instance, JSValue *tasks, JSValue *callback){ NSString *instanceId = [instance toString]; NSArray *tasksArray = [tasks toArray]; NSString *callbackId = [callback toString]; return callNative(instanceId, tasksArray, callbackId); }; _jsContext[@&quot;callNative&quot;] = callNativeBlock; } - (NSInteger)invokeNative:(NSString *)instance tasks:(NSArray *)tasks callback:(NSString *)callback { ... ///批量调用方法 for (NSDictionary *task in tasks) { WXBridgeMethod *method = [[WXBridgeMethod alloc] initWihData:task]; method.instance = instance; [[WXSDKManager moduleMgr] dispatchMethod:method]; } ///下面是处理回调的 NSMutableArray *sendQueue = [self.sendQueue valueForKey:instance]; if (![callback isEqualToString:@&quot;undefined&quot;] &amp;&amp; ![callback isEqualToString:@&quot;-1&quot;] &amp;&amp; callback) { WXBridgeMethod *method = [self _methodWithCallback:callback]; method.instance = instance; [sendQueue addObject:method]; } [self performSelector:@selector(_sendQueueLoop) withObject:nil]; return 1; } 图中蓝色代码是Native直接调用JS的函数，分别为： createInstance、destroyInstance、refreshInstance、registerModules、registerComponents。具体的功能在JS那边。这里不做了解。 归纳总结weex的JS和Native通信原理可以使用下面图简单描述：在weexSDK初始化的时候，完成JS端和Native端的配置信息。JS端的配置信息的作用应该是确保什么样的Native方法可以在JS中调用；Native配置信息的作用是：当JS调用到Native的方法，需要查找调用的Module、方法、方法的SEL等信息，这样才能invoke到相应的方法。weex这样设计的原因大概是为了统一管理JS和Native的通信机制，假如，有许多Native的方法可以被JS调用，那么就需要配置很多的入口，这样随着代码的增加，无法有效维护，weex借助配置信息，巧妙的将入口控制为两个，一个是JS到Native的入口为callNative，一个是Native到JS的入口为callJS。","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/categories/weex/"}]},{"title":"CSS笔记","date":"2016-12-02T09:58:40.000Z","path":"wiki/JS/CSS笔记/","text":"","tags":[],"categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}]},{"title":"flexBox 伸缩盒子模型","date":"2016-12-02T08:18:26.000Z","path":"wiki/Hybird研究/weex/flexBox/","text":"本文主要说明下flexBox的各个效果 一、盒子模型1.1 标准盒子模型标准的盒子模型如下图所示： 1.2 伸缩盒子模型任何一个元素都可以指定为flexbox 布局，设置为display:flex或display:inline-flex的元素称为伸缩容器，伸缩容器的子元素称为伸缩项目，下面是伸缩的模型： 二、React Native中使用flexBox flexDirection（伸缩容器） alignItems（伸缩容器） flexWrap（伸缩容器） justifyContent（伸缩容器） alignSelf（伸缩项目） flex （伸缩项目） 2.1 flexDirection 指定主轴方向1flexDirection:row|column row、column的效果图如下： 2.2 alignItems 该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式1alignSelf:auto|flex-start|flex-end|center|stretch flex-start、flex-end、center的效果图如下： 2.3 flexWrap 指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行1flexWrap:wrap|nowrap wrap、nowrap的效果图如下： 2.4 justifyContent指定伸缩项目沿主轴线的对齐方式1justifyContent:flex-start|flex-end|center|space-between|space-around flex-start、flex-end、center、space-between、space-around的效果图如下： 2.5 alignSelf 设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式1alignSelf:auto|flex-start|flex-end|center|stretch lex-start、flex-end、center 的效果图如下： 2.6 flex1flex:number 分别设置四个伸缩项目的 flex为3、2、1、4，效果图如下：","tags":[{"name":"flexBox","slug":"flexBox","permalink":"http://yoursite.com/tags/flexBox/"}],"categories":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/categories/weex/"}]},{"title":"Objective-C 消息发送与转发机制原理","date":"2016-12-02T06:42:23.000Z","path":"wiki/IOS_Runtime/Objective-C-消息发送与转发机制原理/","text":"消息发送和转发流程可以概括为： 消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；消息转发（Message Forwarding）是在查找 IMP 失败后执行的一系列转发流程，如果不作转发处理，则会打日志和抛出异常。 本文不讲述开发者在消息发送和转发流程中需要做的事，而是讲述原理。能够很好地阅读本文的前提是你对 Objective-C Runtime 已经有一定的了解，关于什么是消息，Class 的结构，selector、IMP、元类等概念将不再赘述。本文用到的源码为 objc4-680 和 CF-1153.18，逆向 CoreFoundation.framework 的系统版本为 macOS 10.11.5，汇编语言架构为 x86_64。 八面玲珑的 objc_msgSend此函数是消息发送必经之路，但只要一提 objc_msgSend，都会说它的伪代码如下或类似的逻辑，反正就是获取 IMP 并调用： id objc_msgSend(id self, SEL _cmd, ...) { Class class = object_getClass(self); IMP imp = class_getMethodImplementation(class, _cmd); return imp ? imp(self, _cmd, ...) : 0; } 源码解析为啥老用伪代码？因为 objc_msgSend 是用汇编语言写的，针对不同架构有不同的实现。如下为 x86_64 架构下的源码，可以在 objc-msg-x86_64.s 文件中找到，关键代码如下： ENTRY _objc_msgSend MESSENGER_START NilTest NORMAL GetIsaFast NORMAL // r11 = self-&gt;isa CacheLookup NORMAL // calls IMP on success NilTestSupport NORMAL GetIsaSupport NORMAL // cache miss: go search the method lists LCacheMiss: // isa still in r11 MethodTableLookup %a1, %a2 // r11 = IMP cmp %r11, %r11 // set eq (nonstret) for forwarding jmp *%r11 // goto *imp END_ENTRY _objc_msgSend 这里面包含一些有意义的宏： NilTest 宏，判断被发送消息的对象是否为 nil 的。如果为 nil，那就直接返回 nil。这就是为啥也可以对 nil 发消息。 GetIsaFast 宏可以『快速地』获取到对象的 isa 指针地址（放到 r11 寄存器，r10 会被重写；在 arm 架构上是直接赋值到 r9） CacheLookup 这个宏是在类的缓存中查找 selector 对应的 IMP（放到 r10）并执行。如果缓存没中，那就得到 Class 的方法表中查找了。 MethodTableLookup 宏是重点，负责在缓存没命中时在方法表中负责查找 IMP： .macro MethodTableLookup MESSENGER_END_SLOW SaveRegisters // _class_lookupMethodAndLoadCache3(receiver, selector, class) movq $0, %a1 movq $1, %a2 movq %r11, %a3 call __class_lookupMethodAndLoadCache3 // IMP is now in %rax movq %rax, %r11 RestoreRegisters .endmacro 从上面的代码可以看出方法查找 IMP 的工作交给了 OC 中的 _class_lookupMethodAndLoadCache3 函数，并将 IMP 返回（从 r11 挪到 rax）。最后在 objc_msgSend 中调用 IMP。 为什么使用汇编语言其实在 objc-msg-x86_64.s 中包含了多个版本的 objc_msgSend 方法，它们是根据返回值的类型和调用者的类型分别处理的： objc_msgSendSuper:向父类发消息，返回值类型为 id objc_msgSend_fpret:返回值类型为 floating-point，其中包含 objc_msgSend_fp2ret 入口处理返回值类型为 long double 的情况 objc_msgSend_stret:返回值为结构体 objc_msgSendSuper_stret:向父类发消息，返回值类型为结构体 当需要发送消息时，编译器会生成中间代码，根据情况分别调用 objc_msgSend, objc_msgSend_stret, objc_msgSendSuper, 或 objc_msgSendSuper_stret 其中之一。这也是为什么 objc_msgSend 要用汇编语言而不是 OC、C 或 C++ 语言来实现，因为单独一个方法定义满足不了多种类型返回值，有的方法返回 id，有的返回 int。考虑到不同类型参数返回值排列组合映射不同方法签名（method signature）的问题，那 switch 语句得老长了。。。这些原因可以总结为 Calling Convention，也就是说函数调用者与被调用者必须约定好参数与返回值在不同架构处理器上的存取规则，比如参数是以何种顺序存储在栈上，或是存储在哪些寄存器上。除此之外还有其他原因，比如其可变参数用汇编处理起来最方便，因为找到 IMP 地址后参数都在栈上。要是用 C++ 传递可变参数那就悲剧了，prologue 机制会弄乱地址（比如 i386 上为了存储 ebp 向后移位 4byte），最后还要用 epilogue 打扫战场。而且汇编程序执行效率高，在 Objective-C Runtime 中调用频率较高的函数好多都用汇编写的。 使用 lookUpImpOrForward 快速查找 IMP上一节中说到的 _class_lookupMethodAndLoadCache3 函数其实只是简单的调用了 lookUpImpOrForward 函数： IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } 注意 lookUpImpOrForward 调用时使用缓存参数传入为 NO，因为之前已经尝试过查找缓存了。IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver) 实现了一套查找 IMP 的标准路径，也就是在消息转发（Forward）之前的逻辑。 优化缓存查找&amp;类的初始化先对 debug 模式下的 assert 进行 unlock： runtimeLock.assertUnlocked(); runtimeLock 本质上是对 Darwin 提供的线程读写锁 pthread_rwlock_t 的一层封装，提供了一些便捷的方法。lookUpImpOrForward 接着做了如下两件事： 如果使用缓存（cache 参数为 YES），那就调用 cache_getImp 方法从缓存查找 IMP。cache_getImp 是用汇编语言写的，也可以在 objc-msg-x86_64.s 找到，其依然用了之前说过的 CacheLookup 宏。因为 _class_lookupMethodAndLoadCache3 调用 lookUpImpOrForward 时 cache 参数为 NO，这步直接略过。 如果是第一次用到这个类且 initialize 参数为 YES（initialize &amp;&amp; !cls-&gt;isInitialized()），需要进行初始化工作，也就是开辟一个用于读写数据的空间。先对 runtimeLock 写操作加锁，然后调用 cls 的 initialize 方法。如果 sel == initialize 也没关系，虽然 initialize 还会被调用一次，但不会起作用啦，因为 cls-&gt;isInitialized() 已经是 YES 啦。 继续在类的继承体系中查找考虑到运行时类中的方法可能会增加，需要先做读操作加锁，使得方法查找和缓存填充成为原子操作。添加 category 会刷新缓存，之后如果旧数据又被重填到缓存中，category 添加操作就会被忽略掉。 runtimeLock.read(); 之后的逻辑整理如下： 如果 selector 是需要被忽略的垃圾回收用到的方法，则将 IMP 结果设为 _objc_ignored_method，这是个汇编程序入口，可以理解为一个标记。对此种情况进行缓存填充操作后，跳到第 7 步；否则执行下一步。 查找当前类中的缓存，跟之前一样，使用 cache_getImp 汇编程序入口。如果命中缓存获取到了 IMP，则直接跳到第 7 步；否则执行下一步。 在当前类中的方法列表（method list）中进行查找，也就是根据 selector 查找到 Method 后，获取 Method 中的 IMP（也就是 method_imp 属性），并填充到缓存中。查找过程比较复杂，会针对已经排序的列表使用二分法查找，未排序的列表则是线性遍历。如果成功查找到 Method 对象，就直接跳到第 7 步；否则执行下一步。 在继承层级中递归向父类中查找，情况跟上一步类似，也是先查找缓存，缓存没中就查找方法列表。这里跟上一步不同的地方在于缓存策略，有个 _objc_msgForward_impcache 汇编程序入口作为缓存中消息转发的标记。也就是说如果在缓存中找到了 IMP，但如果发现其内容是 _objc_msgForward_impcache，那就终止在类的继承层级中递归查找，进入下一步；否则跳到第 7 步。 当传入 lookUpImpOrForward 的参数 resolver 为 YES 并且是第一次进入第 5 步时，时进入动态方法解析；否则进入下一步。这步消息转发前的最后一次机会。此时释放读入锁（runtimeLock.unlockRead()），接着间接地发送 +resolveInstanceMethod 或 +resolveClassMethod 消息。这相当于告诉程序员『赶紧用 Runtime 给类里这个 selector 弄个对应的 IMP 吧』，因为此时锁已经 unlock 了所以不会缓存结果，甚至还需要软性地处理缓存过期问题可能带来的错误。这里的业务逻辑稍微复杂些，后面会总结。因为这些工作都是在非线程安全下进行的，完成后需要回到第 1 步再次查找 IMP。 此时不仅没查找到 IMP，动态方法解析也不奏效，只能将 _objc_msgForward_impcache 当做 IMP 并写入缓存。这也就是之前第 4 步中为何查找到 _objc_msgForward_impcache 就表明了要进入消息转发了。 读操作解锁，并将之前找到的 IMP 返回。（无论是正经 IMP 还是不正经的 _objc_msgForward_impcache）这步还偏执地做了一些脑洞略大的 assert，很有趣。 对于第 5 步，其实是直接调用 _class_resolveMethod 函数，在这个函数中实现了复杂的方法解析逻辑。如果 cls 是元类则会发送 +resolveClassMethod，然后根据 lookUpImpOrNil(cls, sel, inst, NO/initialize/, YES/cache/, NO/resolver/) 函数的结果来判断是否发送 +resolveInstanceMethod；如果不是元类，则只需要发送 +resolveInstanceMethod 消息。这里调用 +resolveInstanceMethod 或 +resolveClassMethod 时再次用到了 objc_msgSend，而且第三个参数正是传入 lookUpImpOrForward 的那个 sel。在发送方法解析消息之后还会调用 lookUpImpOrNil(cls, sel, inst, NO/initialize/, YES/cache/, NO/resolver/) 来判断是否已经添加上 sel 对应的 IMP 了，打印出结果。最后 lookUpImpOrForward 方法也会把真正的 IMP 或者需要消息转发的 _objc_msgForward_impcache 返回，并最终专递到 objc_msgSend 中。而 _objc_msgForward_impcache 会在转化成 _objc_msgForward 或 _objc_msgForward_stret。这个后面会讲解原理。 回顾 objc_msgSend 伪代码回过头来会发现 objc_msgSend 的伪代码描述得很传神啊，因为class_getMethodImplementation 的实现如下： IMP class_getMethodImplementation(Class cls, SEL sel) { IMP imp; if (!cls || !sel) return nil; imp = lookUpImpOrNil(cls, sel, nil, YES/*initialize*/, YES/*cache*/, YES/*resolver*/); // Translate forwarding function to C-callable external version if (!imp) { return _objc_msgForward; } return imp; } lookUpImpOrNil 函数获取不到 IMP 时就返回 _objc_msgForward，后面会讲到它。lookUpImpOrNil 跟 lookUpImpOrForward 的功能很相似，只是将 lookUpImpOrForward 实现中的 _objc_msgForward_impcache 替换成了 nil: IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver) { IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp; } lookUpImpOrNil 方法可以查找到 selector 对应的 IMP 或是 nil，所以如果不考虑返回值类型为结构体的情况，用那几行伪代码来表示复杂的汇编实现还是挺恰当的。 forwarding 转发消息objc_msgForward_impcache 的转换_objc_msgForward_impcache 只是个内部的函数指针，只存储于上节提到的类的方法缓存中，需要被转化为 _objc_msgForward 和 _objc_msgForward_stret 才能被外部调用。但在 Mac OS X macOS 10.6 及更早版本的 libobjc.A.dylib 中是不能直接调用的，况且我们根本不会直接用到它。带 stret 后缀的函数依旧是返回值为结构体的版本。上一节最后讲到如果没找到 IMP，就会将 _objc_msgForward_impcache 返回到 objc_msgSend 函数，而正是因为它是用汇编语言写的，所以将内部使用的 _objc_msgForward_impcache 转化成外部可调用的 _objc_msgForward 或 _objc_msgForward_stret 也是由汇编代码来完成。实现原理很简单，就是增加个静态入口 __objc_msgForward_impcache，然后根据此时 CPU 的状态寄存器的内容来决定转换成哪个。如果是 NE(Not Equal) 则转换成 _objc_msgForward_stret，反之是 EQ(Equal) 则转换成 _objc_msgForward: jne __objc_msgForward_stret jmp __objc_msgForward 为何根据状态寄存器的值来判断转换成哪个函数指针呢？回过头来看看 objc_msgSend 中调用完 MethodTableLookup 之后干了什么： MethodTableLookup %a1, %a2 // r11 = IMP cmp %r11, %r11 // set eq (nonstret) for forwarding jmp *%r11 // goto *imp 再看看返回值为结构体的 objc_msgSend_stret 这里的逻辑： MethodTableLookup %a2, %a3 // r11 = IMP test %r11, %r11 // set ne (stret) for forward; r11!=0 jmp *%r11 // goto *imp 稍微懂汇编的人一眼就看明白了，不懂的看注释也懂了，我就不墨迹了。现在总算是把消息转发前的逻辑绕回来构成闭环了。上一节中提到 class_getMethodImplementation 函数的实现，在查找不到 IMP 时返回 _objc_msgForward，而 _objc_msgForward_stret 正好对应着 class_getMethodImplementation_stret: IMP class_getMethodImplementation_stret(Class cls, SEL sel) { IMP imp = class_getMethodImplementation(cls, sel); // Translate forwarding function to struct-returning version if (imp == (IMP)&amp;_objc_msgForward /* not _internal! */) { return (IMP)&amp;_objc_msgForward_stret; } return imp; } 也就是说 _objc_msgForward* 系列本质都是函数指针，都用汇编语言实现，都可以与 IMP 类型的值作比较。_objc_msgForward 和 _objc_msgForward_stret 声明在 message.h 文件中。_objc_msgForward_impcache 在早期版本的 Runtime 中叫做 _objc_msgForward_internal。 objc_msgForward 也只是个入口从汇编源码可以很容易看出 _objc_msgForward 和 _objc_msgForward_stret 会分别调用 _objc_forward_handler 和 _objc_forward_handler_stret： ENTRY __objc_msgForward // Non-stret version movq __objc_forward_handler(%rip), %r11 jmp *%r11 END_ENTRY __objc_msgForward ENTRY __objc_msgForward_stret // Struct-return version movq __objc_forward_stret_handler(%rip), %r11 jmp *%r11 END_ENTRY __objc_msgForward_stret 这两个 handler 函数的区别从字面上就能看出来，不再赘述。也就是说，消息转发过程是现将 _objc_msgForward_impcache 强转成 _objc_msgForward 或 _objc_msgForward_stret，再分别调用 _objc_forward_handler 或 _objc_forward_handler_stret。 objc_setForwardHandler 设置了消息转发的回调在 Objective-C 2.0 之前，默认的 _objc_forward_handler 或 _objc_forward_handler_stret 都是 nil，而新版本的默认实现是这样的： // Default forward handler halts the process. __attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel) { _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self); } void *_objc_forward_handler = (void*)objc_defaultForwardHandler; #if SUPPORT_STRET struct stret { int i[100]; }; __attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel) { objc_defaultForwardHandler(self, sel); } void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler; #endif objc_defaultForwardHandler 中的 _objc_fatal 作用就是打日志并调用 builtin_trap() 触发 crash，可以看到我们最熟悉的那句 “unrecognized selector sent to instance” 日志。builtin_trap() 在杀掉进程的同时还能生成日志，比调用 exit() 更好。objc_defaultForwardStretHandler 就是装模作样搞个形式主义，把 objc_defaultForwardHandler 包了一层。attribute((noreturn)) 属性通知编译器函数从不返回值，当遇到类似函数需要返回值而却不可能运行到返回值处就已经退出来的情况，该属性可以避免出现错误信息。这里正适合此属性，因为要求返回结构体哒。因为默认的 Handler 干的事儿就是打日志触发 crash，我们想要实现消息转发，就需要替换掉 Handler 并赋值给 _objc_forward_handler 或 _objc_forward_handler_stret，赋值的过程就需要用到 objc_setForwardHandler 函数，实现也是简单粗暴，就是赋值啊： void objc_setForwardHandler(void *fwd, void *fwd_stret) { _objc_forward_handler = fwd; #if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret; #endif } 总结我将整个实现流程绘制出来，过滤了一些不会进入的分支路径和跟主题无关的细节：","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"深入理解Objective-C：Category(转载)","date":"2016-12-02T02:47:02.000Z","path":"wiki/IOS基础知识/Category/深入理解Objective-C：Category/","text":"无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。 初入宝地-category简介category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。 声明私有方法 不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景： 模拟多继承 把framework的私有方法公开 Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。 连类比事-category和extensionextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。 但是category则完全不一样，它是在运行期决议的。就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。 挑灯细览-category真面目我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了1)、类的名字（name）2)、类（cls）3)、category中所有给类添加的实例方法的列表（instanceMethods）4)、category中所有添加的类方法的列表（classMethods）5)、category实现的所有协议的列表（protocols）6)、category中添加的所有属性（instanceProperties） typedef struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; } category_t; 从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。ok，我们先去写一个category看一下category到底为何物：MyClass.h： #import &lt;Foundation/Foundation.h&gt; @interface MyClass : NSObject - (void)printName; @end @interface MyClass(MyAddition) @property(nonatomic, copy) NSString *name; - (void)printName; @end MyClass.m： #import &quot;MyClass.h&quot; @implementation MyClass - (void)printName { NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;); } @end @implementation MyClass(MyAddition) - (void)printName { NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;); } @end 我们使用clang的命令去看看category到底会变成什么： clang -rewrite-objc MyClass.m 好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段： ///实例方法列表 static struct /*_method_list_t*/ { unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1]; } _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = { sizeof(_objc_method), 1, {{(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName}} }; ///实例属性列表 static struct /*_prop_list_t*/ { unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1]; } _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = { sizeof(_prop_t), 1, {{\"name\",\"T@\\\"NSString\\\",C,N\"}} }; extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass; ///category 本身 static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = { &quot;MyClass&quot;, 0, // &amp;OBJC_CLASS_$_MyClass, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition, 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition, }; static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) { _OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass; } #pragma section(&quot;.objc_inithooks$B&quot;, long, read, write) __declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = { (void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition, }; ///DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组 static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= { &amp;OBJC_CLASS_$_MyClass, }; static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = { &amp;OBJC_CLASS_$_MyClass, }; static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= { &amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition, }; 我们可以看到: 首先编译器生成了实例方法列表OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition和属性列表OBJC$_PROP_LISTMyClass$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。 其次，编译器生成了category本身OBJC$_CATEGORYMyClass$_MyAddition，并用前面生成的列表来初始化category本身。 最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJCLABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^^），用于运行期category的加载。到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。 追本溯源-category如何加载我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。想了解更多dyld地同学可以移步这里。对于OC运行时，入口方法如下（在objc-os.mm文件中）： void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images); } category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段： // Discover categories. for (EACH_HEADER) { category_t *catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) { category_t cat = catlist[i]; class_t *cls = remapClass(cat-&gt;cls); if (!cls) { // Category&apos;s target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = NULL; if (PrintConnecting) { _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); } continue; } // Process this category. // First, register the category with its target class. // Then, rebuild the class&apos;s method lists (etc) if // the class is realized. BOOL classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) { addUnattachedCategoryForClass(cat, cls, hi); if (isRealized(cls)) { remethodizeClass(cls); classExists = YES; } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, getName(cls), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); } } if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) { addUnattachedCategoryForClass(cat, cls-&gt;isa, hi); if (isRealized(cls-&gt;isa)) { remethodizeClass(cls-&gt;isa); } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, getName(cls), cat-&gt;name); } } } }首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。略去PrintConnecting这个用于log的东西，这段代码很容易理解： 把category的实例方法、协议以及属性添加到类上 把category的类方法和协议添加到类的metaclass上 值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。 static void remethodizeClass(class_t *cls) { category_list *cats; BOOL isMeta; rwlock_assert_writing(&amp;runtimeLock); isMeta = isMetaClass(cls); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls))) { chained_property_list *newproperties; const protocol_list_t **newprotos; if (PrintConnecting) { _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;, getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;); } // Update methods, properties, protocols ///添加方法 BOOL vtableAffected = NO; attachCategoryMethods(cls, cats, &amp;vtableAffected); ///添加属性 newproperties = buildPropertyList(NULL, cats, isMeta); if (newproperties) { newproperties-&gt;next = cls-&gt;data()-&gt;properties; cls-&gt;data()-&gt;properties = newproperties; } ///添加协议 newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols); if (cls-&gt;data()-&gt;protocols &amp;&amp; cls-&gt;data()-&gt;protocols != newprotos) { _free_internal(cls-&gt;data()-&gt;protocols); } cls-&gt;data()-&gt;protocols = newprotos; _free_internal(cats); // Update method caches and vtables flushCaches(cls); if (vtableAffected) flushVtables(cls); } } 而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods： static void attachCategoryMethods(class_t *cls, category_list *cats, BOOL *inoutVtablesAffected) { if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); BOOL isMeta = isMetaClass(cls); method_list_t **mlists = (method_list_t **) _malloc_internal(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; BOOL fromBundle = NO; while (i--) { method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta); if (mlist) { mlists[mcount++] = mlist; fromBundle |= cats-&gt;list[i].fromBundle; } } attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected); _free_internal(mlists); } attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段： for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist-&gt;count; m++) { SEL sel = method_list_nth(mlist, m)-&gt;name; if (scanForCustomRR &amp;&amp; isRRSelector(sel)) { cls-&gt;setHasCustomRR(); scanForCustomRR = false; } else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) { cls-&gt;setHasCustomAWZ(); scanForCustomAWZ = false; } } // Fill method list array newLists[newCount++] = mlist; . . . // Copy old methods to the method list array for (i = 0; i &lt; oldCount; i++) { newLists[newCount++] = oldLists[i]; } 需要注意的有两点： category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 旁枝末叶-category和+load方法我们知道，在类和category中都可以有+load方法，那么有两个问题：1)、在类的+load方法调用的时候，我们可以调用category中声明的方法么？2)、这么些个+load方法，调用顺序是咋样的呢？鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下： objc[1187]: REPLACED: -[MyClass printName] by category Category1 objc[1187]: REPLACED: -[MyClass printName] by category Category2 . . . objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load objc[1187]: LOAD: +[MyClass load] . . . objc[1187]: LOAD: +[MyClass(Category1) load] . . . objc[1187]: LOAD: +[MyClass(Category2) load] 所以，对于上面两个问题，答案是很明显的： 可以调用，因为附加category到类的工作会先于+load方法的执行 +load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。 目前的编译顺序是这样的：虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。 触类旁通-category和方法覆盖鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:怎么调用到原来类中被category覆盖掉的方法？对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法： Class currentClass = [MyClass class]; MyClass *my = [[MyClass alloc] init]; if (currentClass) { unsigned int methodCount; Method *methodList = class_copyMethodList(currentClass, &amp;methodCount); IMP lastImp = NULL; SEL lastSel = NULL; for (NSInteger i = 0; i &lt; methodCount; i++) { Method method = methodList[i]; NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding]; if ([@&quot;printName&quot; isEqualToString:methodName]) { lastImp = method_getImplementation(method); lastSel = method_getName(method); } } typedef void (*fn)(id,SEL); if (lastImp != NULL) { fn f = (fn)lastImp; f(my,lastSel); } free(methodList); } 更上一层-category和关联对象如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。 MyClass+Category1.h: #import &quot;MyClass.h&quot; @interface MyClass (Category1) @property(nonatomic,copy) NSString *name; @end MyClass+Category1.m: #import &quot;MyClass+Category1.h&quot; #import &lt;objc/runtime.h&gt; @implementation MyClass (Category1) + (void)load { NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;); } - (void)setName:(NSString *)name { objc_setAssociatedObject(self, &quot;name&quot;, name, OBJC_ASSOCIATION_COPY); } - (NSString*)name { NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;); return nameObject; } @end 但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference： void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); _class_setInstancesHaveAssociatedObjects(_object_getClass(object)); } } else { // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association); } 我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下： class AssociationsManager { static OSSpinLock _lock; static AssociationsHashMap *_map; // associative references: object pointer -&gt; PtrPtrHashMap. public: AssociationsManager() { OSSpinLockLock(&amp;_lock); } ~AssociationsManager() { OSSpinLockUnlock(&amp;_lock); } AssociationsHashMap &amp;associations() { if (_map == NULL) _map = new AssociationsHashMap(); return *_map; } }; AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。而在对象的销毁逻辑里面，见objc-runtime-new.mm: void *objc_destructInstance(id obj) { if (obj) { Class isa_gen = _object_getClass(obj); class_t *isa = newcls(isa_gen); // Read all of the flags at once for performance. bool cxx = hasCxxStructors(isa); bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (!UseGC) objc_clear_deallocating(obj); } return obj; } 嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。","tags":[{"name":"category","slug":"category","permalink":"http://yoursite.com/tags/category/"}],"categories":[{"name":"category","slug":"category","permalink":"http://yoursite.com/categories/category/"}]},{"title":"神经病院Objective-C Runtime出院第三天——如何正确使用Runtime(转载)","date":"2016-11-29T06:25:09.000Z","path":"wiki/IOS_Runtime/神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime-转载/","text":"到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。 实现多继承Multiple Inheritance在上一篇文章里面讲到的forwardingTargetForSelector:方法就能知道，一个类可以做到继承多个类的效果，只需要在这一步将消息转发给正确的类对象就可以模拟多继承的效果。 在Objective-C Runtime Programming Guide上记录了这样一段例子。在OC程序中可以借用消息转发机制来实现多继承的功能。 在上图中，一个对象对一个消息做出回应，类似于另一个对象中的方法借过来或是“继承”过来一样。 在图中，warrior实例转发了一个negotiate消息到Diplomat实例中，执行Diplomat中的negotiate方法，结果看起来像是warrior实例执行了一个和Diplomat实例一样的negotiate方法，其实执行者还是Diplomat实例。这使得不同继承体系分支下的两个类可以“继承”对方的方法，这样一个类可以响应自己继承分支里面的方法，同时也能响应其他不相干类发过来的消息。在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。消息转发提供了许多类似于多继承的特性，但是他们之间有一个很大的不同： 多继承：合并了不同的行为特征在一个单独的对象中，会得到一个重量级多层面的对象。 消息转发：将各个功能分散到不同的对象中，得到的一些轻量级的对象，这些对象通过消息转发联合起来。 这里值得说明的一点是，即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开。像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个Warrior对象如果被问到是否能响应negotiate消息： if ( [aWarrior respondsToSelector:@selector(negotiate)] ) 结果是NO，虽然它能够响应negotiate消息而不报错，但是它是靠转发消息给Diplomat类来响应消息的。如果非要制造假象，反应出这种“假”的继承关系，那么需要重新实现 respondsToSelector:和 isKindOfClass:来加入你的转发算法： - (BOOL)respondsToSelector:(SEL)aSelector { if ( [super respondsToSelector:aSelector] ) return YES; else { /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ } return NO; } 除了respondsToSelector:和 isKindOfClass:之外，instancesRespondToSelector:中也应该写一份转发算法。如果使用了协议，conformsToProtocol:也一样需要重写。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个methodSignatureForSelector:来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现methodSignatureForSelector: - (NSMethodSignature*)methodSignatureForSelector:(SEL)selector { NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) { signature = [surrogate methodSignatureForSelector:selector]; } return signature; } Note: This is an advanced technique, suitable only for situations where no other solution is possible. It is not intended as a replacement for inheritance. If you must make use of this technique, make sure you fully understand the behavior of the class doing the forwarding and the class you’re forwarding to.需要引起注意的一点，实现methodSignatureForSelector方法是一种先进的技术，只适用于没有其他解决方案的情况下。它不会作为继承的替代。如果您必须使用这种技术，请确保您完全理解类做的转发和您转发的类的行为。请勿滥用！ Method Swizzling提到Objective-C 中的 Runtime，大多数人第一个想到的可能就是黑魔法Method Swizzling。毕竟这是Runtime里面很强大的一部分，它可以通过Runtime的API实现更改任意的方法，理论上可以在运行时通过类名/方法名hook到任何 OC 方法，替换任何类的实现以及新增任意类。举的最多的例子应该就是埋点统计用户信息的例子。假设我们需要在页面上不同的地方统计用户信息，常见做法有两种： 傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。 把统计的代码写入基类中，比如说BaseViewController。这样虽然代码只需要写一次，但是UITableViewController，UICollectionViewcontroller都需要写一遍，这样重复的代码依旧不少。 基于这两点，我们这时候选用Method Swizzling来解决这个事情最优雅。 Method Swizzling原理Method Swizzing是发生在运行时的，主要用于在运行时将两个Method进行交换，我们可以将Method Swizzling代码写到任何地方，但是只有在这段Method Swilzzling代码执行完毕之后互换才起作用。而且Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式，我们可以利用苹果这一特性来实现AOP编程。Method Swizzling本质上就是对IMP和SEL进行交换。 Method Swizzling使用一般我们使用都是新建一个分类，在分类中进行Method Swizzling方法的交换。交换的代码模板如下： #import &lt;objc/runtime.h&gt; @implementation UIViewController (Swizzling) + (void)load { static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } #pragma mark - Method Swizzling - (void)xxx_viewWillAppear:(BOOL)animated { [self xxx_viewWillAppear:animated]; NSLog(@&quot;viewWillAppear: %@&quot;, self); } @end Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在category中添加一个方法。 Method Swizzling注意点Swizzling应该总在+load中执行Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用， +initialize方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize方法是永远不会被调用的。所以Swizzling要是写在+initialize方法中，是有可能永远都不被执行。和+initialize比较+load能保证在类的初始化过程中被加载。关于+load和+initialize的比较可以参看这篇文章《Objective-C +load vs +initialize》 Swizzling应该总是在dispatch_once中执行Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为Method Swizzling的最佳实践。这里有一个很容易犯的错误，那就是继承中用了Swizzling。如果不写dispatch_once就会导致Swizzling失效！举个例子，比如同时对NSArray和NSMutableArray中的objectAtIndex:方法都进行了Swizzling，这样可能会导致NSArray中的Swizzling失效的。可是为什么会这样呢？ 原因是，我们没有用dispatch_once控制Swizzling只执行一次。如果这段Swizzling被执行多次，经过多次的交换IMP和SEL之后，结果可能就是未交换之前的状态。比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的IMP，子类C持有B方法的IMP，但是再次交换一次，就又还原了。父类A还是持有B方法的IMP，子类C还是持有D方法的IMP，这样就相当于咩有交换。可以看出，如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！ Swizzling在+load中执行时，不要调用[super load]原因同注意点二，如果是多继承，并且对同一个方法都进行了Swizzling，那么调用[super load]以后，父类的Swizzling就失效了。 上述模板中没有错误有些人怀疑我上述给的模板可能有错误。在这里需要讲解一下。在进行Swizzling的时候，我们需要用class_addMethod先进行判断一下原有类中是否有要替换的方法的实现。如果class_addMethod返回NO，说明当前类中有要替换方法的实现，所以可以直接进行替换，调用method_exchangeImplementations即可实现Swizzling。如果class_addMethod返回YES，说明当前类中没有要替换方法的实现，我们需要在父类中去寻找。这个时候就需要用到method_getImplementation去获取class_getInstanceMethod里面的方法实现。然后再进行class_replaceMethod来实现Swizzling。这是Swizzling需要判断的一点。还有一点需要注意的是，在我们替换的方法- (void)xxx_viewWillAppear:(BOOL)animated中，调用了[self xxx_viewWillAppear:animated];这不是死循环了么？其实这里并不会死循环。 由于我们进行了Swizzling，所以其实在原来的- (void)viewWillAppear:(BOOL)animated方法中，调用的是- (void)xxx_viewWillAppear:(BOOL)animated方法的实现。所以不会造成死循环。相反的，如果这里把[self xxx_viewWillAppear:animated];改成[self viewWillAppear:animated];就会造成死循环。因为外面调用[self viewWillAppear:animated];的时候，会交换方法走到[self xxx_viewWillAppear:animated];这个方法实现中来，然后这里又去调用[self viewWillAppear:animated]，就会造成死循环了。所以按照上述Swizzling的模板来写，就不会遇到这4点需要注意的问题啦。 Method Swizzling使用场景Method Swizzling使用场景其实有很多很多，在一些特殊的开发需求中适时的使用黑魔法，可以做法神来之笔的效果。这里就举3种常见的场景。 实现AOPAOP的例子在上一篇文章中举了一个例子，在下一章中也打算详细分析一下其实现原理，这里就一笔带过。 实现埋点统计如果app有埋点需求，并且要自己实现一套埋点逻辑，那么这里用到Swizzling是很合适的选择。优点在开头已经分析了，这里不再赘述。看到一篇分析的挺精彩的埋点的文章，推荐大家阅读。 iOS动态性(二)可复用而且高度解耦的用户统计埋点实现 实现异常保护日常开发我们经常会遇到NSArray数组越界的情况，苹果的API也没有对异常保护，所以需要我们开发者开发时候多多留意。关于Index有好多方法，objectAtIndex，removeObjectAtIndex，replaceObjectAtIndex，exchangeObjectAtIndex等等，这些设计到Index都需要判断是否越界。 常见做法是给NSArray，NSMutableArray增加分类，增加这些异常保护的方法，不过如果原有工程里面已经写了大量的AtIndex系列的方法，去替换成新的分类的方法，效率会比较低。这里可以考虑用Swizzling做。 #import &quot;NSArray+ Swizzling.h&quot; #import &quot;objc/runtime.h&quot; @implementation NSArray (Swizzling) + (void)load { Method fromMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(&quot;__NSArrayI&quot;), @selector(swizzling_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod); } - (id)swizzling_objectAtIndex:(NSUInteger)index { if (self.count-1 &lt; index) { // 异常处理 @try { return [self swizzling_objectAtIndex:index]; } @catch (NSException *exception) { // 打印崩溃信息 NSLog(@&quot;---------- %s Crash Because Method %s ----------\\n&quot;, class_getName(self.class), __func__); NSLog(@&quot;%@&quot;, [exception callStackSymbols]); return nil; } @finally {} } else { return [self swizzling_objectAtIndex:index]; } } @end 注意，调用这个objc_getClass方法的时候，要先知道类对应的真实的类名才行，NSArray其实在Runtime中对应着NSArrayI，NSMutableArray对应着NSArrayM，NSDictionary对应着NSDictionaryI，NSMutableDictionary对应着NSDictionaryM。 Aspect Oriented ProgrammingWikipedia 里对 AOP 是这么介绍的:An aspect can alter the behavior of the base code by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches).类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(Cross-cutting concern)，AOP作用就是分离横向关注点(Cross-cutting concern)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。 接下来分析分析AOP的工作原理。在上一篇中我们分析过了，在objc_msgSend函数查找IMP的过程中，如果在父类也没有找到相应的IMP，那么就会开始执行_class_resolveMethod方法，如果不是元类，就执行_class_resolveInstanceMethod，如果是元类，执行_class_resolveClassMethod。在这个方法中，允许开发者动态增加方法实现。这个阶段一般是给@dynamic属性变量提供动态方法的。如果_class_resolveMethod无法处理，会开始选择备援接受者接受消息，这个时候就到了forwardingTargetForSelector方法。如果该方法返回非nil的对象，则使用该对象作为新的消息接收者。 - (id)forwardingTargetForSelector:(SEL)aSelector { if(aSelector == @selector(Method:)){ return otherObject; } return [super forwardingTargetForSelector:aSelector]; } 同样也可以替换类方法 + (id)forwardingTargetForSelector:(SEL)aSelector { if(aSelector == @selector(xxx)) { return NSClassFromString(@&quot;Class name&quot;); } return [super forwardingTargetForSelector:aSelector]; } 替换类方法返回值就是一个类对象。 forwardingTargetForSelector这种方法属于单纯的转发，无法对消息的参数和返回值进行处理。 最后到了完整转发阶段。Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。 // 为目标对象中被调用的方法返回一个NSMethodSignature实例 #warning 运行时系统要求在执行标准转发时实现这个方法 - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{ return [self.proxyTarget methodSignatureForSelector:sel]; } 对象需要创建一个NSInvocation对象，把消息调用的全部细节封装进去，包括selector, target, arguments 等参数，还能够对返回结果进行处理。AOP的多数操作就是在forwardInvocation中完成的。一般会分为2个阶段，一个是Intercepter注册阶段，一个是Intercepter执行阶段。 Intercepter注册首先会把类里面的某个要切片的方法的IMP加入到Aspect中，类方法里面如果有forwardingTargetForSelector:的IMP，也要加入到Aspect中。然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换。两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:。这样主要的Intercepter注册就完成了。 Intercepter执行当执行func()方法的时候，会去查找它的IMP，现在它的IMP已经被我们替换为了objc_msgForward()方法，于是开始查找备援转发对象。 查找备援接受者调用forwardingTargetForSelector:这个方法，由于这里是被我们hook过的，所以IMP指向的是hook过的forwardingTargetForSelector:方法。这里我们会返回Aspect的target，即选取Aspect作为备援接受者。有了备援接受者之后，就会重新objc_msgSend，从消息发送阶段重头开始。objc_msgSend找不到指定的IMP，再进行_class_resolveMethod，这里也没有找到，forwardingTargetForSelector:这里也不做处理，接着就会methodSignatureForSelector。在methodSignatureForSelector方法中创建一个NSInvocation对象，传递给最终的forwardInvocation方法。Aspect里面的forwardInvocation方法会干所有切面的事情。这里转发逻辑就完全由我们自定义了。Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP，这里我们可以在forwardInvocation方法中去执行这些IMP。在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的。 Isa Swizzling前面第二点谈到了黑魔法Method Swizzling，本质上就是对IMP和SEL进行交换。其实接下来要说的Isa Swizzling，和它类似，本质上也是交换，不过交换的是Isa。在苹果的官方库里面有一个很有名的技术就用到了这个Isa Swizzling，那就是KVO——Key-Value Observing。Key-Value Observing Programming Guide官方文档上对于KVO的定义是这样的: Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 官方给的就这么多，具体实现也没有说的很清楚。那只能我们自己来实验一下。KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。具体实现应该是重写其setter方法即可。官方是如何优雅的实现重写监听类的setter方法的呢？实验代码如下： Student *stu = [[Student alloc]init]; [stu addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil]; 我们可以打印观察isa指针的指向 Printing description of stu-&gt;isa: Student Printing description of stu-&gt;isa: NSKVONotifying_Student 通过打印，我们可以很明显的看到，被观察的对象的isa变了，变成了NSKVONotifying_Student这个类了。 在@interface NSObject(NSKeyValueObserverRegistration) 这个分类里面，苹果定义了KVO的方法。 - (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context; - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0); - (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; KVO在调用addObserver方法之后，苹果的做法是在执行完addObserver: forKeyPath: options: context: 方法之后，把isa指向到另外一个类去。在这个新类里面重写被观察的对象四个方法。class，setter，dealloc，_isKVOA。 重写class方法重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。 static NSArray * ClassMethodNames(Class c) { NSMutableArray * array = [NSMutableArray array]; unsigned int methodCount = 0; Method * methodList = class_copyMethodList(c, &amp;methodCount); unsigned int i; for(i = 0; i &lt; methodCount; i++) { [array addObject: NSStringFromSelector(method_getName(methodList[i]))]; } free(methodList); return array; } int main(int argc, char * argv[]) { Student *stu = [[Student alloc]init]; NSLog(@&quot;self-&gt;isa:%@&quot;,object_getClass(stu)); NSLog(@&quot;self class:%@&quot;,[stu class]); NSLog(@&quot;ClassMethodNames = %@&quot;,ClassMethodNames(object_getClass(stu))); [stu addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew context:nil]; NSLog(@&quot;self-&gt;isa:%@&quot;,object_getClass(stu)); NSLog(@&quot;self class:%@&quot;,[stu class]); NSLog(@&quot;ClassMethodNames = %@&quot;,ClassMethodNames(object_getClass(stu))); } 打印结果 self-&gt;isa:Student self class:Student ClassMethodNames = ( &quot;.cxx_destruct&quot;, name, &quot;setName:&quot; ) self-&gt;isa:NSKVONotifying_Student self class:Student ClassMethodNames = ( &quot;setName:&quot;, class, dealloc, &quot;_isKVOA&quot; ) 这里也可以看出，这是object_getClass方法和class方法的区别。 重写setter方法在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用： - (void)willChangeValueForKey:(NSString *)key - (void)didChangeValueForKey:(NSString *)key 在didChangeValueForKey:方法再调用 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 这里有几种情况需要说明一下： 如果使用了KVC如果有访问器方法，则运行时会在setter方法中调用will/didChangeValueForKey:方法；如果没用访问器方法，运行时会在setValue:forKey方法中调用will/didChangeValueForKey:方法。所以这种情况下，KVO是奏效的。 有访问器方法运行时会重写访问器方法调用will/didChangeValueForKey:方法。 因此，直接调用访问器方法改变属性值时，KVO也能监听到。 直接调用will/didChangeValueForKey:方法。 综上所述，只要setter中重写will/didChangeValueForKey:方法就可以使用KVO了。 重写dealloc方法销毁新生成的NSKVONotifying_类。 重写_isKVOA方法这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。 Foundation 到底为我们提供了哪些用于 KVO 的辅助函数。打开 terminal，使用 nm -a 命令查看 Foundation 中的信息： nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation 里面包含了以下这些KVO中可能用到的函数 00000000000233e7 t __NSSetDoubleValueAndNotify 00000000000f32ba t __NSSetFloatValueAndNotify 0000000000025025 t __NSSetIntValueAndNotify 000000000007fbb5 t __NSSetLongLongValueAndNotify 00000000000f33e8 t __NSSetLongValueAndNotify 000000000002d36c t __NSSetObjectValueAndNotify 0000000000024dc5 t __NSSetPointValueAndNotify 00000000000f39ba t __NSSetRangeValueAndNotify 00000000000f3aeb t __NSSetRectValueAndNotify 00000000000f3512 t __NSSetShortValueAndNotify 00000000000f3c2f t __NSSetSizeValueAndNotify 00000000000f363b t __NSSetUnsignedCharValueAndNotify 000000000006e91f t __NSSetUnsignedIntValueAndNotify 0000000000034b5b t __NSSetUnsignedLongLongValueAndNotify 00000000000f3766 t __NSSetUnsignedLongValueAndNotify 00000000000f3890 t __NSSetUnsignedShortValueAndNotify 00000000000f3060 t __NSSetValueAndNotifyForKeyInIvar 00000000000f30d7 t __NSSetValueAndNotifyForUndefinedKey Foundation 提供了大部分基础数据类型的辅助函数（Objective C中的 Boolean 只是 unsigned char 的 typedef，所以包括了，但没有 C++中的 bool），此外还包括一些常见的结构体如 Point, Range, Rect, Size，这表明这些结构体也可以用于自动键值观察，但要注意除此之外的结构体就不能用于自动键值观察了。对于所有 Objective C 对象对应的是 __NSSetObjectValueAndNotify 方法。 KVO即使是苹果官方的实现，也是有缺陷的，这里有一篇文章详细了分析了KVO中的缺陷，主要问题在KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-addObserver:forKeyPath:options:context:方法所引发的一系列问题。而且只监听一两个属性值还好，如果监听的属性多了, 或者监听了多个对象的属性, 那有点麻烦，需要在方法里面写很多的if-else的判断。最后，官方文档上对于KVO的实现的最后，给出了需要我们注意的一点是，永远不要用用isa来判断一个类的继承关系，而是应该用class方法来判断类的实例。 Associated Object 关联对象Associated Objects是Objective-C 2.0中Runtime的特性之一。众所周知，在 Category 中，我们无法添加@property，因为添加了@property之后并不会自动帮我们生成实例变量以及存取方法。那么，我们现在就可以通过关联对象来实现在 Category 中添加属性的功能了。 用法借用这篇经典文章Associated Objects里面的例子来说明一下用法。 // NSObject+AssociatedObject.h @interface NSObject (AssociatedObject) @property (nonatomic, strong) id associatedObject; @end // NSObject+AssociatedObject.m @implementation NSObject (AssociatedObject) @dynamic associatedObject; - (void)setAssociatedObject:(id)object { objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (id)associatedObject { return objc_getAssociatedObject(self, @selector(associatedObject)); } 这里涉及到了3个函数： OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); OBJC_EXPORT void objc_removeAssociatedObjects(id object) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); 来说明一下这些参数的意义： id object 设置关联对象的实例对象 const void key 区分不同的关联对象的 key。这里会有3种写法。使用 &amp;AssociatedObjectKey 作为key值static char AssociatedObjectKey = “AssociatedKey”;使用AssociatedKey 作为key值static const void AssociatedKey = “AssociatedKey”;使用@selector@selector(associatedKey)3种方法都可以，不过推荐使用更加简洁的第三种方式。 id value 关联的对象 objc_AssociationPolicy policy 关联对象的存储策略，它是一个枚举，与property的attribute 相对应。 这里需要注意的是标记成OBJC_ASSOCIATION_ASSIGN的关联对象和 @property (weak) 是不一样的，上面表格中等价定义写的是 @property (unsafe_unretained)，对象被销毁时，属性值仍然还在。如果之后再次使用该对象就会导致程序闪退。所以我们在使用OBJC_ASSOCIATION_ASSIGN时，要格外注意。 According to the Deallocation Timeline described in WWDC 2011, Session 322(~36:00), associated objects are erased surprisingly late in the object lifecycle, inobject_dispose(), which is invoked by NSObject -dealloc. 关于关联对象还有一点需要说明的是objc_removeAssociatedObjects。这个方法是移除源对象中所有的关联对象，并不是其中之一。所以其方法参数中也没有传入指定的key。要删除指定的关联对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可。 objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC); 关联对象3种使用场景 为现有的类添加私有变量 为现有的类添加公有属性 为KVO创建一个关联的观察者。 源码分析objc_setAssociatedObject方法void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } } else { // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); } } else { // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } } } // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association); } 这个函数里面主要分为2部分，一部分是if里面对应的new_value不为nil的时候，另一部分是else里面对应的new_value为nil的情况。当new_value不为nil的时候，查找时候，流程如下：首先在AssociationsManager的结构如下 class AssociationsManager { static spinlock_t _lock; static AssociationsHashMap *_map; public: AssociationsManager() { _lock.lock(); } ~AssociationsManager() { _lock.unlock(); } AssociationsHashMap &amp;associations() { if (_map == NULL) _map = new AssociationsHashMap(); return *_map; } }; 在AssociationsManager中有一个spinlock类型的自旋锁lock。保证每次只有一个线程对AssociationsManager进行操作，保证线程安全。AssociationsHashMap对应的是一张哈希表。 AssociationsHashMap哈希表里面key是disguised_ptr_t。 disguised_ptr_t disguised_object = DISGUISE(object); 通过调用DISGUISE( )方法获取object地址的指针。拿到disguised_object后，通过这个key值，在AssociationsHashMap哈希表里面找到对应的value值。而这个value值ObjcAssociationMap表的首地址。 在ObjcAssociationMap表中，key值是set方法里面传过来的形参const void *key，value值是ObjcAssociation对象。 ObjcAssociation对象中存储了set方法最后两个参数，policy和value。 所以objc_setAssociatedObject方法中传的4个形参在上图中已经标出。 现在弄清楚结构之后再来看源码，就很容易了。objc_setAssociatedObject方法的目的就是在这2张哈希表中存储对应的键值对。 先初始化一个 AssociationsManager，获取唯一的保存关联对象的哈希表 AssociationsHashMap，然后在AssociationsHashMap里面去查找object地址的指针。 如果找到，就找到了第二张表ObjectAssociationMap。在这张表里继续查找object的key。 if (i != associations.end()) { // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } } 如果在第二张表ObjectAssociationMap找到对应的ObjcAssociation对象，那就更新它的值。如果没有找到，就新建一个ObjcAssociation对象，放入第二张表ObjectAssociationMap中。 再回到第一张表AssociationsHashMap中，如果没有找到对应的键值 ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); 此时就不存在第二张表ObjectAssociationMap了，这时就需要新建第二张ObjectAssociationMap表，来维护对象的所有新增属性。新建完第二张ObjectAssociationMap表之后，还需要再实例化 ObjcAssociation对象添加到 Map 中，调用setHasAssociatedObjects方法，表明当前对象含有关联对象。这里的setHasAssociatedObjects方法，改变的是isa_t结构体中的第二个标志位has_assoc的值。(关于isa_t结构体的结构，详情请看第一天的解析) // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association); 最后如果老的association对象有值，此时还会释放它。 以上是new_value不为nil的情况。其实只要记住上面那2张表的结构，这个objc_setAssociatedObject的过程就是更新 / 新建 表中键值对的过程。 再来看看new_value为nil的情况 // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { old_association = j-&gt;second; refs-&gt;erase(j); } } 当new_value为nil的时候，就是我们要移除关联对象的时候。这个时候就是在两张表中找到对应的键值，并调用erase( )方法，即可删除对应的关联对象。 objc_getAssociatedObject方法id _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) { ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); } } } if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); } return value; } objc_getAssociatedObject方法 很简单。就是通过遍历AssociationsHashMap哈希表 和 ObjcAssociationMap表的所有键值找到对应的ObjcAssociation对象，找到了就返回ObjcAssociation对象，没有找到就返回nil。 objc_removeAssociatedObjects方法void objc_removeAssociatedObjects(id object) { if (object &amp;&amp; object-&gt;hasAssociatedObjects()) { _object_remove_assocations(object); } } void _object_remove_assocations(id object) { vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; { AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) { elements.push_back(j-&gt;second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue()); } 在移除关联对象object的时候，会先去判断object的isa_t中的第二位has_assoc的值，当object 存在并且object-&gt;hasAssociatedObjects( )值为1的时候，才会去调用_object_remove_assocations方法。 _object_remove_assocations方法的目的是删除第二张ObjcAssociationMap表，即删除所有的关联对象。删除第二张表，就需要在第一张AssociationsHashMap表中遍历查找。这里会把第二张ObjcAssociationMap表中所有的ObjcAssociation对象都存到一个数组elements里面，然后调用associations.erase( )删除第二张表。最后再遍历elements数组，把ObjcAssociation对象依次释放。 以上就是Associated Object关联对象3个函数的源码分析。 动态的增加方法在消息发送阶段，如果在父类中也没有找到相应的IMP，就会执行resolveInstanceMethod方法。在这个方法里面，我们可以动态的给类对象或者实例对象动态的增加方法。 + (BOOL)resolveInstanceMethod:(SEL)sel { NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@&quot;method1&quot;]) { class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, &quot;@:&quot;); } return [super resolveInstanceMethod:sel]; } 关于方法操作方面的函数还有以下这些 // 调用指定方法的实现 id method_invoke ( id receiver, Method m, ... ); // 调用返回一个数据结构的方法的实现 void method_invoke_stret ( id receiver, Method m, ... ); // 获取方法名 SEL method_getName ( Method m ); // 返回方法的实现 IMP method_getImplementation ( Method m ); // 获取描述方法参数和返回值类型的字符串 const char * method_getTypeEncoding ( Method m ); // 获取方法的返回值类型的字符串 char * method_copyReturnType ( Method m ); // 获取方法的指定位置参数的类型字符串 char * method_copyArgumentType ( Method m, unsigned int index ); // 通过引用返回方法的返回值类型字符串 void method_getReturnType ( Method m, char *dst, size_t dst_len ); // 返回方法的参数的个数 unsigned int method_getNumberOfArguments ( Method m ); // 通过引用返回方法指定位置参数的类型字符串 void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len ); // 返回指定方法的方法描述结构体 struct objc_method_description * method_getDescription ( Method m ); // 设置方法的实现 IMP method_setImplementation ( Method m, IMP imp ); // 交换两个方法的实现 void method_exchangeImplementations ( Method m1, Method m2 ); 这些方法其实平时不需要死记硬背，使用的时候只要先打出method开头，后面就会有补全信息，找到相应的方法，传入对应的方法即可。 NSCoding的自动归档和自动解档现在虽然手写归档和解档的时候不多了，但是自动操作还是用Runtime来实现的。 - (void)encodeWithCoder:(NSCoder *)aCoder{ [aCoder encodeObject:self.name forKey:@&quot;name&quot;]; } - (id)initWithCoder:(NSCoder *)aDecoder{ if (self = [super init]) { self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;]; } return self; } 手动的有一个缺陷，如果属性多起来，要写好多行相似的代码，虽然功能是可以完美实现，但是看上去不是很优雅。用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。 #import &quot;Student.h&quot; #import &lt;objc/runtime.h&gt; #import &lt;objc/message.h&gt; @implementation Student - (void)encodeWithCoder:(NSCoder *)aCoder{ unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) { Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; } } - (nullable __kindof)initWithCoder:(NSCoder *)aDecoder{ if (self = [super init]) { unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) { Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; } } return self; } @end class_copyIvarList方法用来获取当前 Model 的所有成员变量，ivar_getName方法用来获取每个成员变量的名称。 字典和模型互相转换字典转模型1 调用 class_getProperty 方法获取当前 Model 的所有属性。2 调用 property_copyAttributeList 获取属性列表。3 根据属性名称生成 setter 方法。4 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC） +(id)objectWithKeyValues:(NSDictionary *)aDictionary{ id objc = [[self alloc] init]; for (NSString *key in aDictionary.allKeys) { id value = aDictionary[key]; /*判断当前属性是不是Model*/ objc_property_t property = class_getProperty(self, key.UTF8String); unsigned int outCount = 0; objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount); objc_property_attribute_t attribute = attributeList[0]; NSString *typeString = [NSString stringWithUTF8String:attribute.value]; if ([typeString isEqualToString:@&quot;@\\&quot;Student\\&quot;&quot;]) { value = [self objectWithKeyValues:value]; } //生成setter方法，并用objc_msgSend调用 NSString *methodName = [NSString stringWithFormat:@&quot;set%@%@:&quot;,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]]; SEL setter = sel_registerName(methodName.UTF8String); if ([objc respondsToSelector:setter]) { ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value); } free(attributeList); } return objc; } 这段代码里面有一处判断typeString的，这里判断是防止model嵌套，比如说Student里面还有一层Student，那么这里就需要再次转换一次，当然这里有几层就需要转换几次。 几个出名的开源库JSONModel、MJExtension等都是通过这种方式实现的(利用runtime的class_copyIvarList获取属性数组，遍历模型对象的所有成员属性，根据属性名找到字典中key值进行赋值，当然这种方法只能解决NSString、NSNumber等，如果含有NSArray或NSDictionary，还要进行第二步转换，如果是字典数组，需要遍历数组中的字典，利用objectWithDict方法将字典转化为模型，在将模型放到数组中，最后把这个模型数组赋值给之前的字典数组) 模型转字典这里是上一部分字典转模型的逆步骤：1 调用 class_copyPropertyList 方法获取当前 Model 的所有属性。2 调用 property_getName 获取属性名称。3 根据属性名称生成 getter 方法。4 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC） //模型转字典 -(NSDictionary *)keyValuesWithObject{ unsigned int outCount = 0; objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount); NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for (int i = 0; i &lt; outCount; i ++) { objc_property_t property = propertyList[i]; //生成getter方法，并用objc_msgSend调用 const char *propertyName = property_getName(property); SEL getter = sel_registerName(propertyName); if ([self respondsToSelector:getter]) { id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter); /*判断当前属性是不是Model*/ if ([value isKindOfClass:[self class]] &amp;&amp; value) { value = [value keyValuesWithObject]; } if (value) { NSString *key = [NSString stringWithUTF8String:propertyName]; [dict setObject:value forKey:key]; } } } free(propertyList); return dict; } 中间注释那里的判断也是防止model嵌套，如果model里面还有一层model，那么model转字典的时候还需要再次转换，同样，有几层就需要转换几次。不过上述的做法是假设字典里面不再包含二级字典，如果还包含数组，数组里面再包含字典，那还需要多级转换。这里有一个关于字典里面包含数组的demo. Runtime缺点看了上面八大点之后，是不是感觉Runtime很神奇，可以迅速解决很多问题，然而，Runtime就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：What are the Dangers of Method Swizzling in Objective C?，它的危险性主要体现以下几个方面： Method swizzling is not atomicMethod swizzling不是原子性操作。如果在+load方法里面写，是没有问题的，但是如果写在+initialize方法中就会出现一些奇怪的问题。 Changes behavior of un-owned code如果你在一个类中重写一个方法，并且不调用super方法，你可能会导致一些问题出现。在大多数情况下，super方法是期望被调用的（除非有特殊说明）。如果你使用同样的思想来进行Swizzling，可能就会引起很多问题。如果你不调用原始的方法实现，那么你Swizzling改变的太多了，而导致整个程序变得不安全。 Possible naming conflicts命名冲突是程序开发中经常遇到的一个问题。我们经常在类别中的前缀类名称和方法名称。不幸的是，命名冲突是在我们程序中的像一种瘟疫。一般我们会这样写Method Swizzling @interface NSView : NSObject - (void)setFrame:(NSRect)frame; @end @implementation NSView (MyViewAdditions) - (void)my_setFrame:(NSRect)frame { // do custom work [self my_setFrame:frame]; } + (void)load { [self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)]; } @end 这样写看上去是没有问题的。但是如果在整个大型程序中还有另外一处定义了my_setFrame:方法呢？那又会造成命名冲突的问题。我们应该把上面的Swizzling改成以下这种样子： @implementation NSView (MyViewAdditions) static void MySetFrame(id self, SEL _cmd, NSRect frame); static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame); static void MySetFrame(id self, SEL _cmd, NSRect frame) { // do custom work SetFrameIMP(self, _cmd, frame); } + (void)load { [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP]; } @end 虽然上面的代码看上去不是OC(因为使用了函数指针)，但是这种做法确实有效的防止了命名冲突的问题。原则上来说，其实上述做法更加符合标准化的Swizzling。这种做法可能和人们使用方法不同，但是这种做法更好。Swizzling Method 标准定义应该是如下的样子： typedef IMP *IMPPointer; BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) { IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) { const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) { imp = method_getImplementation(method); } } if (imp &amp;&amp; store) { *store = imp; } return (imp != NULL); } @implementation NSObject (FRRuntimeAdditions) + (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store { return class_swizzleMethodAndStore(self, original, replacement, store); } @end Swizzling changes the method’s arguments这一点是这些问题中最大的一个。标准的Method Swizzling是不会改变方法参数的。使用Swizzling中，会改变传递给原来的一个函数实现的参数，例如 [self my_setFrame:frame]; 会变转换成 objc_msgSend(self, @selector(my_setFrame:), frame); objcmsgSend会去查找mysetFrame对应的IMP。一旦IMP找到，会把相同的参数传递进去。这里会找到最原始的setFrame:方法，调用执行它。但是这里的cmd参数并不是setFrame:，现在是mysetFrame:。原始的方法就被一个它不期待的接收参数调用了。这样并不好。 这里有一个简单的解决办法，上一条里面所说的，用函数指针去实现。参数就不会变了。 The order of swizzles matters调用顺序对于Swizzling来说，很重要。假设setFrame:方法仅仅被定义在NSView类里面。 [NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; [NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)]; [NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; 当NSButton被swizzled之后会发生什么呢？大多数的swizzling应该保证不会替换setFrame:方法。因为一旦改了这个方法，会影响下面所有的View。所以它会去拉取实例方法。NSButton会使用已经存在的方法去重新定义setFrame:方法。以至于改变了IMP实现不会影响所有的View。相同的事情也会发生在对NSControl进行swizzling的时候，同样，IMP也是定义在NSView类里面，把NSControl 和 NSButton这上下两行swizzle顺序替换，结果也是相同的。 当调用NSButton的setFrame:方法，会去调用swizzled method，然后会跳入NSView类里面定义的setFrame:方法。NSControl 和 NSView对应的swizzled method不会被调用。 NSButton 和 NSControl各自调用各自的 swizzling方法，相互不会影响。 但是我们改变一下调用顺序，把NSView放在第一位调用。 [NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; [NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)]; [NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; 一旦这里的NSView先进行了swizzling了以后，情况就和上面大不相同了。NSControl的swizzling会去拉取NSView替换后的方法。相应的，NSControl在NSButton前面，NSButton也会去拉取到NSControl替换后的方法。这样就十分混乱了。但是顺序就是这样排列的。我们开发中如何能保证不出现这种混乱呢？ 再者，在load方法中加载swizzle。如果仅仅是在已经加载完成的class中做了swizzle，那么这样做是安全的。load方法能保证父类会在其任何子类加载方法之前，加载相应的方法。这就保证了我们调用顺序的正确性。 Difficult to understand (looks recursive)看着传统定义的swizzled method，我认为很难去预测会发生什么。但是对比上面标准的swizzling，还是很容易明白。这一点已经被解决了。 Difficult to debug在调试中，会出现奇怪的堆栈调用信息，尤其是swizzled的命名很混乱，一切方法调用都是混乱的。对比标准的swizzled方式，你会在堆栈中看到清晰的命名方法。swizzling还有一个比较难调试的一点， 在于你很难记住当前确切的哪个方法已经被swizzling了。 在代码里面写好文档注释，即使你认为这段代码只有你一个人会看。遵循这个方式去实践，你的代码都会没问题。它的调试也没有多线程的调试困难。 #最后 经过在“神经病院”3天的修炼之后，对OC 的Runtime理解更深了。 关于黑魔法Method swizzling，我个人觉得如果使用得当，还是很安全的。一个简单而安全的措施是你仅仅只在load方法中去swizzle。和编程中很多事情一样，不了解它的时候会很危险可怕，但是一旦明白了它的原理之后，使用它又会变得非常正确高效。 对于多人开发，尤其是改动过Runtime的地方，文档记录一定要完整。如果某人不知道某个方法被Swizzling了，出现问题调试起来，十分蛋疼。 如果是SDK开发，某些Swizzling会改变全局的一些方法的时候，一定要在文档里面标注清楚，否则使用SDK的人不知道，出现各种奇怪的问题，又要被坑好久。 在合理使用 + 文档完整齐全 的情况下，解决特定问题，使用Runtime还是非常简洁安全的。 日常可能用的比较多的Runtime函数可能就是下面这些 //获取cls类对象所有成员ivar结构体 Ivar *class_copyIvarList(Class cls, unsigned int *outCount) //获取cls类对象name对应的实例方法结构体 Method class_getInstanceMethod(Class cls, SEL name) //获取cls类对象name对应类方法结构体 Method class_getClassMethod(Class cls, SEL name) //获取cls类对象name对应方法imp实现 IMP class_getMethodImplementation(Class cls, SEL name) //测试cls对应的实例是否响应sel对应的方法 BOOL class_respondsToSelector(Class cls, SEL sel) //获取cls对应方法列表 Method *class_copyMethodList(Class cls, unsigned int *outCount) //测试cls是否遵守protocol协议 BOOL class_conformsToProtocol(Class cls, Protocol *protocol) //为cls类对象添加新方法 BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) //替换cls类对象中name对应方法的实现 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) //为cls添加新成员 BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) //为cls添加新属性 BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) //获取m对应的选择器 SEL method_getName(Method m) //获取m对应的方法实现的imp指针 IMP method_getImplementation(Method m) //获取m方法的对应编码 const char *method_getTypeEncoding(Method m) //获取m方法参数的个数 unsigned int method_getNumberOfArguments(Method m) //copy方法返回值类型 char *method_copyReturnType(Method m) //获取m方法index索引参数的类型 char *method_copyArgumentType(Method m, unsigned int index) //获取m方法返回值类型 void method_getReturnType(Method m, char *dst, size_t dst_len) //获取方法的参数类型 void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len) //设置m方法的具体实现指针 IMP method_setImplementation(Method m, IMP imp) //交换m1，m2方法对应具体实现的函数指针 void method_exchangeImplementations(Method m1, Method m2) //获取v的名称 const char *ivar_getName(Ivar v) //获取v的类型编码 const char *ivar_getTypeEncoding(Ivar v) //设置object对象关联的对象 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取object关联的对象 id objc_getAssociatedObject(id object, const void *key) //移除object关联的对象 void objc_removeAssociatedObjects(id object) 这些API看上去不好记，其实使用的时候不难，关于方法操作的，一般都是method开头，关于类的，一般都是class开头的，其他的基本都是objc开头的，剩下的就看代码补全的提示，看方法名基本就能找到想要的方法了。当然很熟悉的话，可以直接打出指定方法，也不会依赖代码补全。 还有一些关于协议相关的API以及其他一些不常用，但是也可能用到的，就需要查看Objective-C Runtime官方API文档，这个官方文档里面详细说明，平时不懂的多看看文档。 最后请大家多多指教。 涉及的资料Objective-C Runtime Programming Guide 《Objective-C +load vs +initialize》 iOS动态性(二)可复用而且高度解耦的用户统计埋点实现 Key-Value Observing Programming Guide KVO中的缺陷 What are the Dangers of Method Swizzling in Objective C?","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"NSInvocation的基本使","date":"2016-11-24T07:35:49.000Z","path":"wiki/IOS基础知识/foundation/NSInvocation的基本使/","text":"iOS中可以间接向对象发送消息方式有两种： 使用performSelector:withObject； 使用NSInvocation。performSelector:withObject能完成简单的调用。但是对于大于2个的参数或者有返回值的消息，它就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。 方法签名An NSMethodSignature object records type information for the return value and parameters of a method. It is used to forward messages that the receiving object does not respond to—most notably in the case of distributed objects.NSMethodSignature对象记录了方法的参数和返回值的类型信息。它被用于转发接受者不能处理的消息。 You typically create an NSMethodSignature object using the NSObject methodSignatureForSelector: instance method . It is then used to create an NSInvocation object,。 NSObject的实例方法methodSignatureForSelector:是创建NSMethodSignature对象的典型方法。 使用NSMethodSignature对象用于创建NSInvocation 对象(通过NSInvocation的invocationWithMethodSignature:类方法)。下面是创建方法签名的代码： ///1. 创建方法签名 NSMethodSignature *signature = [ViewController instanceMethodSignatureForSelector:@selector(fucWithName:)]; if (signature == nil) { return; } 使用numberOfArguments获取方法的参数个数，参数个数比sel多两个隐藏参数，一个是self,一个是_cmd。页可以使用getArgumentTypeAtIndex:获取参数。还可以使用methodReturnType获取返回类型。 使用NSInvocation发送消息///2、创建NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; invocation.target = self; //注意：这里的方法名一定要与方法签名类中的方法一致 invocation.selector = @selector(fucWithName:); NSString *strName = @&quot;dog&quot;; //这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd) [invocation setArgument:&amp;strName atIndex:2]; //3、调用invoke方法 [invocation invoke]; id res = nil; if (signature.methodReturnLength != 0) { [invocation getReturnValue:&amp;res]; } NSLog(@&quot;res = %@&quot;,res); 首先使用invocationWithMethodSignature:创建一个NSInvocation对象，然后设置对象的target、selector。NSInvocation对象实际上就是将方法封装为对象。然后使用invoke方法调用消息。使用getReturnValue获取返回值。输出的结果如下： ViewController object receive message functionWithName: res = dog","tags":[{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://yoursite.com/tags/NSInvocation/"}],"categories":[{"name":"foundation","slug":"foundation","permalink":"http://yoursite.com/categories/foundation/"}]},{"title":"神经病院Objective-C Runtime住院第二天——消息发送与转发（转载)","date":"2016-11-22T02:38:11.000Z","path":"wiki/IOS_Runtime/神经病院Objective-C-Runtime住院第二天——消息发送与转发（转载/","text":"现在越来越多的app都使用了JSPatch实现app热修复，而JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。今天就来详细解析一下OC中runtime最为吸引人的地方。 消息发送阶段—objc_msgSend函数简介最初接触到OC Runtime，一定是从[receiver message]这里开始的。[receiver message]会被编译器转化为： id objc_msgSend ( id self, SEL op, ... ); 这是一个可变参数函数。第二个参数类型是SEL。SEL在OC中是selector方法选择器。 typedef struct objc_selector *SEL; objc_selector是一个映射到方法的C字符串。需要注意的是@selector()选择子只与函数名有关。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。由于这点特性，也导致了OC不支持函数重载。 在receiver拿到对应的selector之后，如果自己无法执行这个方法，那么该条消息要被转发。或者临时动态的添加方法实现。如果转发到最后依旧没法处理，程序就会崩溃。所以编译期仅仅是确定了要发送消息，而消息如何处理是要运行期需要解决的事情。 objc_msgSend函数究竟会干什么事情呢？从这篇objc_msgSend() Tour文章里面可以得到一个比较详细的结论。 Check for ignored selectors (GC) and short-circuit. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache)If found, jump to it. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism.总结一下objc_msgSend会做一下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。如果这里有相应的nil的处理函数，就跳转到相应的函数中。 如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。如果找到，就跳转进去执行。 如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程。 消息发送阶段—objc_msgSend源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 #include id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...) { struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) { cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do { method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; } while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); } return( (id) self); recache: /* ... */ return( 0); } 该源码中有一个do-while循环，这个循环就是上一章里面提到的在方法分发表里面查找method的过程。不过在obj4-680里面的objc-msg-x86_64.s文件中实现是一段汇编代码。 /******************************************************************** * * id objc_msgSend(id self, SEL _cmd,...); * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes _objc_debug_taggedpointer_classes: .fill 16, 8, 0 ENTRY _objc_msgSend MESSENGER_START NilTest NORMAL GetIsaFast NORMAL // r11 = self-&gt;isa CacheLookup NORMAL // calls IMP on success NilTestSupport NORMAL GetIsaSupport NORMAL // cache miss: go search the method lists LCacheMiss: // isa still in r11 MethodTableLookup %a1, %a2 // r11 = IMP cmp %r11, %r11 // set eq (nonstret) for forwarding jmp *%r11 // goto *imp END_ENTRY _objc_msgSend ENTRY _objc_msgSend_fixup int3 END_ENTRY _objc_msgSend_fixup STATIC_ENTRY _objc_msgSend_fixedup // Load _cmd from the message_ref movq 8(%a2), %a2 jmp _objc_msgSend END_ENTRY _objc_msgSend_fixedup 来分析一下这段汇编代码。 乍一看，如果从LCacheMiss:这里上下分开，可以很明显的看到objc_msgSend就干了两件事情—— CacheLookup 和 MethodTableLookup。 ///////////////////////////////////////////////////////////////////// // // NilTest return-type // // Takes: $0 = NORMAL or FPRET or FP2RET or STRET // %a1 or %a2 (STRET) = receiver // // On exit: Loads non-nil receiver in %a1 or %a2 (STRET), or returns zero. // ///////////////////////////////////////////////////////////////////// .macro NilTest .if $0 == SUPER || $0 == SUPER_STRET error super dispatch does not test for nil .endif .if $0 != STRET testq %a1, %a1 .else testq %a2, %a2 .endif PN jz LNilTestSlow_f .endmacro NilTest是用来检测是否为nil的。传入参数有4种，NORMAL / FPRET / FP2RET / STRET。 objc_msgSend 传入的参数是NilTest NORMALobjc_msgSend_fpret 传入的参数是NilTest FPRETobjc_msgSend_fp2ret 传入的参数是NilTest FP2RETobjc_msgSend_stret 传入的参数是NilTest STRET 如果检测方法的接受者是nil，那么系统会自动clean并且return。 GetIsaFast宏可以快速地获取到对象的 isa 指针地址（放到 r11 寄存器，r10会被重写；在 arm 架构上是直接赋值到 r9） .macro CacheLookup ldrh r12, [r9, #CACHE_MASK] // r12 = mask ldr r9, [r9, #CACHE] // r9 = buckets .if $0 == STRET || $0 == SUPER_STRET and r12, r12, r2 // r12 = index = SEL &amp; mask .else and r12, r12, r1 // r12 = index = SEL &amp; mask .endif add r9, r9, r12, LSL #3 // r9 = bucket = buckets+index*8 ldr r12, [r9] // r12 = bucket-&gt;sel 2: .if $0 == STRET || $0 == SUPER_STRET teq r12, r2 .else teq r12, r1 .endif bne 1f CacheHit $0 1: cmp r12, #1 blo LCacheMiss_f // if (bucket-&gt;sel == 0) cache miss it eq // if (bucket-&gt;sel == 1) cache wrap ldreq r9, [r9, #4] // bucket-&gt;imp is before first bucket ldr r12, [r9, #8]! // r12 = (++bucket)-&gt;sel b 2b .endmacro r12里面存的是方法method，r9里面是cache。r1，r2是SEL。在这个CacheLookup函数中，不断的通过SEL与cache中的bucket-&gt;sel进行比较，如果r12 = = 0，则跳转到LCacheMiss_f标记去继续执行。如果r12找到了,r12 = =1，即在cache中找到了相应的SEL，则直接执行该IMP(放在r10中)。 程序跳到LCacheMiss，就说明cache中无缓存，未命中缓存。这个时候就要开始下一阶段MethodTableLookup的查找了。 ///////////////////////////////////////////////////////////////////// // // MethodTableLookup classRegister, selectorRegister // // Takes: $0 = class to search (a1 or a2 or r10 ONLY) // $1 = selector to search for (a2 or a3 ONLY) // r11 = class to search // // On exit: imp in %r11 // ///////////////////////////////////////////////////////////////////// .macro MethodTableLookup MESSENGER_END_SLOW SaveRegisters // _class_lookupMethodAndLoadCache3(receiver, selector, class) movq $0, %a1 movq $1, %a2 movq %r11, %a3 call __class_lookupMethodAndLoadCache3 // IMP is now in %rax movq %rax, %r11 RestoreRegisters .endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class.mm中）。具体是把receiver, selector, class三个参数传给$0，$1，r11，然后再去调用lookupMethodAndLoadCache3方法。最后会将 IMP 返回（从 r11 挪到 rax）。最后在 objc_msgSend中调用 IMP。 /*********************************************************************** * _class_lookupMethodAndLoadCache. * Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp(). * This lookup avoids optimistic cache scan because the dispatcher * already tried that. 这个查找方法的函数只能被 dispatchers （也就是 objc_msgSend、objc_msgSend_stret 等函数）使用其他的代码应该使用 lookUpImp() 函数 这个函数避免了扫描缓存，因为 dispatchers 已经尝试过扫描缓存了，正是因为缓存中没有找到，才调用这个方法找的 **********************************************************************/ IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) { return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/); } __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。再来看看lookUpImpOrForward函数实现 /*********************************************************************** * lookUpImpOrForward. * The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails) * cache==NO skips optimistic unlocked lookup (but uses cache elsewhere) * Most callers should use initialize==YES and cache==YES. * inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster. * May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret. * If you don&apos;t want forwarding at all, use lookUpImpOrNil() instead. **********************************************************************/ // 标准的查找 IMP 的函数 // 在 cls 类以及父类中寻找 sel 对应的 IMP， // initialize == NO 表示尝试避免触发 +initialize (但有时失败)， // cache == NO 表示跳过 optimistic unlocked lookup，即跳过前面不加锁的部分对缓存的查找，但是在 retry 里加锁的部分还是会优先查找缓存 // 大多数调用者应该用 initialize==YES and cache==YES. // inst 是这个类的实例，或者它的子类的实例，也可能是 nil， // 如果这个类是一个不是 initialized 状态的元类，那么 obj 非空的话，会快一点， // resolver == YES 的话，如果在缓存和方法列表中都没有找到 IMP，就会进行 resolve，尝试动态添加方法 // 有可能返回 _objc_msgForward_impcache。IMPs 被用作外部的使用时（转发？？），一定要转为 _objc_msgForward 或者 _objc_msgForward_stret // 如果确实不想转发，就用 lookUpImpOrNil() 代替 IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver) { Class curClass; IMP imp = nil; Method meth; // 用来标记是否尝试过 resolver，调用 _class_resolveMethod 后就置为 YES， // 即使再 retry 也不会再 resolver，详情自己在下面找 bool triedResolver = NO; runtimeLock.assertUnlocked(); // 确定 runtimeLock 已经解锁 // Optimistic cache lookup if (cache) { // 如果指定了需要在缓存中查找，这时是不加锁的，这是与 retry 部分的缓存查找最大的不同 imp = cache_getImp(cls, sel); // 就在缓存中找 if (imp) { return imp; // 如果很幸运得在缓存中找到了，就将找到的 IMP 返回，注意哦，有可能找到的是 _objc_msgForward_impcache 函数 // 这个函数会进行消息转发 } } // 如果 cls 还没被 realized，就将 cls 类 realize 了 if (!cls-&gt;isRealized()) { // runtimeLock 加写锁 rwlock_writer_t lock(runtimeLock); // 将 cls 类 realize 了，realizeClass() 函数里还会顺便把 cls 类的父类和元类也一并 realize 了 // 当然这会造成递归，会把 cls 往上的所有没 realize 的祖宗类和 cls类的元类往上所有没有被 realize 的元类都 realize 了 realizeClass(cls); } // 如果 cls 类还不是 initialized 状态，并且指定了需要 initialize 的话，就将它 initialize 了 if (initialize &amp;&amp; !cls-&gt;isInitialized()) { // 1. 先调用 _class_getNonMetaClass() 取得 cls 的实例类 // 如果 cls 不是元类的话，_class_getNonMetaClass 返回的就是 cls 本身 // 如果 cls 是元类，就找到它对应的实例类 // 2. 对 _class_getNonMetaClass 返回的类进行 initialize， // 其中如果父类没有初始化，会将父类也初始化了；其中会有递归，在完成 cls 的初始化工作之前，会将所有祖宗类都完成初始化， // 如果有 cls 类或者其中有个祖宗类正在其他线程上被初始化，本线程还会挂起等待，所以这都是串行并且线程安全的， // 类的状态会从 未初始化 -&gt; initializing -&gt; initialized _class_initialize (_class_getNonMetaClass(cls, inst)); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won&apos;t happen. 2778172 /* 这段话是说，如果 sel 本身就是 initialize 方法的话，因为 _class_initialize 中会调用 +initialize 方法， 所以本函数结束以后，会再一次调用 +initialize 方法，也就是 +initialize 会悲催地走两次。 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。 因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现： + (void)initialize { if (self == [ClassName self]) { // ... do the initialization ... } } 或者使用： + (void)initialize { static BOOL b = false; if (!b) { NSLog(@&quot;Person initialize&quot;); b = true; } } */ } // The lock is held to make method-lookup + cache-fill atomic // with respect to method addition. Otherwise, a category could // be added but ignored indefinitely because the cache was re-filled // with the old value after the cache flush on behalf of the category. // 这个锁是用来实现 方法查找 + 填充缓存 两个步骤的原子性的, // 否则，一个分类被添加进来后有可能被无限期地忽略， // 添加分类的时候会清空缓存，见 attachCategories() 函数，而调用 attachCategories() 函数之前都对 runtimeLock 加写锁， // 设想下，如果没有 runtimeLock 读写锁的存在，那么就可能会出现下面的情况： // 1. 线程 1 method-lookup 方法查找 找到了老的 IMP， // 2. 线程 2 attachCategories() 函数中添加完分类并清空方法缓存， // 3. 线程 1 cache-fill 将老的 IMP 插进了缓存中 // 这时，缓存中存的还是老的 IMP，之后 objc_msgSend 函数在缓存中找到的也都是老的 IMP，通过分类添加的新的方法就被忽略了 retry: // 进行 resolve 后，会进行一次 retry，即重新查一次 IMP，如果这回再找不到，就会进行消息转发 runtimeLock.read(); // runtimeLock 加读锁，原因见上面 // Ignore GC selectors if (ignoreSelector(sel)) { // 查看 sel 是否需要被忽略 imp = _objc_ignored_method; // 被忽略的 sel，会被分配 _objc_ignored_method 为 IMP， // 这与 _objc_ignored_method() 的做法是一致的 // _objc_ignored_method 的实现源码也在 objc_msg_arm.s 文件中 cache_fill(cls, sel, imp, inst); // 将 sel 和 imp(_objc_ignored_method) 插入到缓存中 goto done; // 就算是已经确定 IMP 了，完成，跳到 done } // Try this class&apos;s cache. // 再在缓存中查找一次，与函数开头的缓存查找不同的是，现在是加了读锁的 // 还有个不同是，这时可能是 retry，即命中的这个 IMP 可能是 resolve 成功时插入到缓存中的 imp = cache_getImp(cls, sel); if (imp) { goto done; // 找到就跳到 done } // Try this class&apos;s method lists. meth = getMethodNoSuper_nolock(cls, sel); // 在 cls 类中搜索 sel 对应的方法，NoSuper 即不在 cls 的父类中查找 if (meth) { // 如果找到了，就将 meth 中的 IMP 和 sel 一并存入缓存 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); // 存起来，后面需要返回 imp imp = meth-&gt;imp; goto done; } // Try superclass caches and method lists. // 缓存中没有、cls 类中也没有，只能沿着 cls 类的祖宗类一路向上寻找了 curClass = cls; // 先从父类开始找，直到找到 NSObject 类，NSObject 类没有父类，就停止循环了 while ((curClass = curClass-&gt;superclass)) { // Superclass cache. // 在 curClass 类的缓存中寻找 imp = cache_getImp(curClass, sel); if (imp) { // 如果找到了，并且 IMP 不是 _objc_msgForward_impcache // 即不是消息转发，就将 IMP 放入 cls 类的方法缓存中 // 一定要注意哦，是 cls 类的方法缓存，不是 curClass 类的方法缓存 // 因为我们在为 cls 类寻找 IMP，最后存在 cls 类的方法缓存中，也有利于以后对 cls 类的方法调用，即各自类缓存各自的 IMP，互不干扰，查起来即简单又快 if (imp != (IMP)_objc_msgForward_impcache) { // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; } else { // Found a forward:: entry in a superclass. // Stop searching, but don&apos;t cache yet; call method // resolver for this class first. // 找到一个消息转发，就停止寻找，但是不缓存， // 先对这个 curClass 类调用 resolver 方法，即 +resolveInstanceMethod 和 +resolveClassMethod // 这两个方法可以给程序员动态添加 实例方法 和 类方法 的机会 break; } } // Superclass method list. // 缓存中没找到，就只能在 curClass 类的方法列表中查找 meth = getMethodNoSuper_nolock(curClass, sel); // 如果找到了，就将方法的 IMP 插入 cls 类的方法缓存中，注意，是 cls 类的方法缓存 if (meth) { log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; // 保存一下 imp，后面返回用 goto done; } } // No implementation found. Try method resolver once. // 找不到 IMP，尝试一次 resolver，即调用 +resolveInstanceMethod 和 +resolveClassMethod // 但是必须指定需要 resolver，并且没有尝试过 resolver，才能进行 resolver // retry 最多只会进行一次，即 resolve 只有一次机会，如果还不成功，就进行完整的消息转发 if (resolver &amp;&amp; !triedResolver/*没有尝试过resolver*/) { runtimeLock.unlockRead(); // 释放 runtimeLock 的读锁，retry 的时候会再加上读锁 _class_resolveMethod(cls, sel, inst); // 调用 _class_resolveMethod() 尝试 resolve // Don&apos;t cache the result; we don&apos;t hold the lock so it may have // changed already. Re-do the search from scratch instead. // 不缓存结果，我们释放了读锁，所以结果是不可信的，中间过程中很有可能已经有其他的线程修改了它 // 进行 retry 时，会重新获得读锁，并重新进行搜索 triedResolver = YES; goto retry; } // No implementation found, and method resolver didn&apos;t help. // Use forwarding. // 任何方法都失败了，resolve 也失败了，就进行完整的消息转发，返回这个消息转发函数 imp = (IMP)_objc_msgForward_impcache; // 将 _objc_msgForward_impcache 作为 sel 对应的 IMP 插入到缓存中 cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); // 释放读锁 // paranoia: look for ignored selectors with non-ignored implementations // sel 必须不能是需要忽略的 SEL，且 imp 必须不是 _objc_ignored_method // 因为如果是这种情况，在上面就应该已经返回了，绝不应该走到这里 assert(!(ignoreSelector(sel) &amp;&amp; imp != (IMP)&amp;_objc_ignored_method)); // paranoia: never let uncached leak out // imp 必须不能是 _objc_msgSend_uncached_impcache 函数，绝不能泄漏未命中的缓存 // 我猜，如果返回 _objc_msgSend_uncached_impcache 的话，因为 _objc_msgSend_uncached_impcache 中会调用 _class_lookupMethodAndLoadCache3() 函数，而 _class_lookupMethodAndLoadCache3() 又会调用 lookUpImpOrForward，即本函数，那么就反反复复死循环了 // 理解 _objc_msgSend_uncached_impcache 函数需要看 objc_msg_arm.s 中的 STATIC_ENTRY _objc_msgSend_uncached_impcache // 它也只在汇编中用到，其他地方并没有用到这个函数 assert(imp != _objc_msgSend_uncached_impcache); return imp; } 下面来分析代码，整个代码的目的是查找IMP。 调用cache_getImp 在缓存中查找，如果找到，直接返回，其中cache_getImp在objc-msg-x86_64.s里面，是汇编语言实现。 调用realizeClass，实现Class。 将class的bits成员变量从ro转化为rw ，转化后，bits 指向class_rw_t rw，rw中的ro指向原来的ro。 更新superclass. 调用reconcileInstanceVariables重建成员变量 调用addSubclass 给父类添加一个子类 调用methodizeClass，将分类中的方法列表、属性列表、协议列表加载到 methods、 properties 和 protocols 列表数组中，并且添加categories 进入retry 流程，resolve后，还会进入到这里，重新查找imp。下面都是retry流程 判断是否是忽略的消息，忽略的消息就是垃圾回收的消息，包括release，autorelease，retainCount，dealloc。IOS不支持垃圾回收（GC），所以没有忽略的消息 调用cache_getImp，再一次在缓存中查找imp 调用getMethodNoSuper_nolock，在Class 中查找sel,返回的是method_t，不是IMP。查找方法是枚举cls-&gt;bits-&gt;methods方法列表。 循环class的superclass，查找imp，查找方法先用cache_getImp找，后用getMethodNoSuper_nolock找。 如果步骤4-7任何一步找到，都会调用cache_fill缓存方法。跳转到done 流程。 调用class_resolveMethod 尝试解决方法 。如果成功，跳转到步骤4。 如果还是没有找到，调用_objc_msgForward_impcache 进行完整的消息转发流程。 消息转发Message Forwarding阶段到了转发阶段，会调用id _objc_msgForward(id self, SEL _cmd,…)方法。在objc-msg-x86_64.s中有其汇编的实现。 STATIC_ENTRY __objc_msgForward_impcache // Method cache version // THIS IS NOT A CALLABLE C FUNCTION // Out-of-band condition register is NE for stret, EQ otherwise. MESSENGER_START nop MESSENGER_END_SLOW jne __objc_msgForward_stret jmp __objc_msgForward END_ENTRY __objc_msgForward_impcache ENTRY __objc_msgForward // Non-stret version movq __objc_forward_handler(%rip), %r11 jmp *%r11 END_ENTRY __objc_msgForward 在执行_objc_msgForward之后会调用__objc_forward_handler函数。 // Default forward handler halts the process. __attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel) { _objc_fatal(&quot;%c[%s %s]: unrecognized selector sent to instance %p &quot; &quot;(no message forward handler is installed)&quot;, class_isMetaClass(object_getClass(self)) ? &apos;+&apos; : &apos;-&apos;, object_getClassName(self), sel_getName(sel), self); } void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在最新的Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 void *_objc_forward_handler = (void*)objc_defaultForwardHandler; #if SUPPORT_STRET struct stret { int i[100]; }; __attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel) { objc_defaultForwardHandler(self, sel); } void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler; #endif #endif void objc_setForwardHandler(void *fwd, void *fwd_stret) { _objc_forward_handler = fwd; #if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret; #endif } 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 但是当你想要弄清objc_setForwardHandler调用栈的情况的时候，你会发现打印不出来入口。因为苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这两篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理Hmmm, What’s that Selector? 还是回到消息转发上面来。当前的SEL无法找到相应的IMP的时候，开发者可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来“偷梁换柱”，把消息的接受者换成一个可以处理该消息的对象。 - (id)forwardingTargetForSelector:(SEL)aSelector { if(aSelector == @selector(Method:)){ return otherObject; } return [super forwardingTargetForSelector:aSelector]; } 当然也可以替换类方法，那就要重写 + (id)forwardingTargetForSelector:(SEL)aSelector方法，返回值是一个类对象。 + (id)forwardingTargetForSelector:(SEL)aSelector { if(aSelector == @selector(xxx)) { return NSClassFromString(@&quot;Class name&quot;); } return [super forwardingTargetForSelector:aSelector]; } 这一步是替消息找备援接收者，如果这一步返回的是nil，那么补救措施就完全的失效了，Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。 接下来未识别的方法崩溃之前，系统会做一次完整的消息转发。 我们只需要重写下面这个方法，就可以自定义我们自己的转发逻辑了。 - (void)forwardInvocation:(NSInvocation *)anInvocation { if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation]; } 实现此方法之后，若发现某调用不应由本类处理，则会调用超类的同名方法。如此，继承体系中的每个类都有机会处理该方法调用的请求，一直到NSObject根类。如果到NSObject也不能处理该条消息，那么就是再无挽救措施了，只能抛出“doesNotRecognizeSelector”异常了。 至此，消息发送和转发的过程都清楚明白了。 forwardInvocation的例子这里我想举一个好玩的例子，来说明一下forwardInvocation的使用方法。这个例子中我们会利用runtime消息转发机制创建一个动态代理。利用这个动态代理来转发消息。这里我们会用到两个基类的另外一个神秘的类，NSProxy。NSProxy类和NSObject同为OC里面的基类，但是NSProxy类是一种抽象的基类，无法直接实例化，可用于实现代理模式。它通过实现一组经过简化的方法，代替目标对象捕捉和处理所有的消息。NSProxy类也同样实现了NSObject的协议声明的方法，而且它有两个必须实现的方法。 - (void)forwardInvocation:(NSInvocation *)invocation; - (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(&quot;NSInvocation and related APIs not available&quot;); 另外还需要说明的是，NSProxy类的子类必须声明并实现至少一个init方法，这样才能符合OC中创建和初始化对象的惯例。Foundation框架里面也含有多个NSProxy类的具体实现类。 NSDistantObject类：定义其他应用程序或线程中对象的代理类。 NSProtocolChecker类：定义对象，使用这话对象可以限定哪些消息能够发送给另外一个对象。接下来就来看看下面这个好玩的例子。 #import &lt;Foundation/Foundation.h&gt; @interface Student : NSObject -(void)study:(NSString *)subject andRead:(NSString *)bookName; -(void)study:(NSString *)subject :(NSString *)bookName; @end 定义一个student类，里面随便给两个方法。 #import &quot;Student.h&quot; #import &lt;objc/runtime.h&gt; @implementation Student -(void)study:(NSString *)subject :(NSString *)bookName { NSLog(@&quot;Invorking method on %@ object with selector %@&quot;,[self class],NSStringFromSelector(_cmd)); } -(void)study:(NSString *)subject andRead:(NSString *)bookName { NSLog(@&quot;Invorking method on %@ object with selector %@&quot;,[self class],NSStringFromSelector(_cmd)); } @end 在两个方法实现里面增加log信息，这是为了一会打印的时候方便知道调用了哪个方法。 #import &lt;Foundation/Foundation.h&gt; #import &quot;Invoker.h&quot; @interface AspectProxy : NSProxy /** 通过NSProxy实例转发消息的真正对象 */ @property(strong) id proxyTarget; /** 能够实现横切功能的类（遵守Invoker协议）的实例 */ @property(strong) id&lt;Invoker&gt; invoker; /** 定义了哪些消息会调用横切功能 */ @property(readonly) NSMutableArray *selectors; // AspectProxy类实例的初始化方法 - (id)initWithObject:(id)object andInvoker:(id&lt;Invoker&gt;)invoker; - (id)initWithObject:(id)object selectors:(NSArray *)selectors andInvoker:(id&lt;Invoker&gt;)invoker; // 向当前的选择器列表中添加选择器 - (void)registerSelector:(SEL)selector; @end 定义一个AspectProxy类，这个类专门用来转发消息的。 #import &quot;AspectProxy.h&quot; @implementation AspectProxy - (id)initWithObject:(id)object selectors:(NSArray *)selectors andInvoker:(id&lt;Invoker&gt;)invoker { _proxyTarget = object; _invoker = invoker; _selectors = [selectors mutableCopy]; return self; } - (id)initWithObject:(id)object andInvoker:(id&lt;Invoker&gt;)invoker { return [self initWithObject:object selectors:nil andInvoker:invoker]; } // 添加另外一个选择器 - (void)registerSelector:(SEL)selector{ NSValue *selValue = [NSValue valueWithPointer:selector]; [self.selectors addObject:selValue]; } // 为目标对象中被调用的方法返回一个NSMethodSignature实例 // 运行时系统要求在执行标准转发时实现这个方法 - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel{ return [self.proxyTarget methodSignatureForSelector:sel]; } /** * 当调用目标方法的选择器与在AspectProxy对象中注册的选择器匹配时，forwardInvocation:会 * 调用目标对象中的方法，并根据条件语句的判断结果调用AOP（面向切面编程）功能 */ - (void)forwardInvocation:(NSInvocation *)invocation{ // 在调用目标方法前执行横切功能 if ([self.invoker respondsToSelector:@selector(preInvoke:withTarget:)]) { if (self.selectors != nil) { SEL methodSel = [invocation selector]; for (NSValue *selValue in self.selectors) { if (methodSel == [selValue pointerValue]) { [[self invoker] preInvoke:invocation withTarget:self.proxyTarget]; break; } } }else{ [[self invoker] preInvoke:invocation withTarget:self.proxyTarget]; } } // 调用目标方法 [invocation invokeWithTarget:self.proxyTarget]; // 在调用目标方法后执行横切功能 if ([self.invoker respondsToSelector:@selector(postInvoke:withTarget:)]) { if (self.selectors != nil) { SEL methodSel = [invocation selector]; for (NSValue *selValue in self.selectors) { if (methodSel == [selValue pointerValue]) { [[self invoker] postInvoke:invocation withTarget:self.proxyTarget]; break; } } }else{ [[self invoker] postInvoke:invocation withTarget:self.proxyTarget]; } } } 接着我们定义一个代理协议 #import &lt;Foundation/Foundation.h&gt; @protocol Invoker &lt;NSObject&gt; @required // 在调用对象中的方法前执行对功能的横切 - (void)preInvoke:(NSInvocation *)inv withTarget:(id)target; @optional // 在调用对象中的方法后执行对功能的横切 - (void)postInvoke:(NSInvocation *)inv withTarget:(id)target; @end 最后还需要一个遵守协议的类 #import &lt;Foundation/Foundation.h&gt; #import &quot;Invoker.h&quot; @interface AuditingInvoker : NSObject&lt;Invoker&gt;//遵守Invoker协议 @end #import &quot;AuditingInvoker.h&quot; @implementation AuditingInvoker - (void)preInvoke:(NSInvocation *)inv withTarget:(id)target{ NSLog(@&quot;before sending message with selector %@ to %@ object&quot;, NSStringFromSelector([inv selector]),[target className]); } - (void)postInvoke:(NSInvocation *)inv withTarget:(id)target{ NSLog(@&quot;after sending message with selector %@ to %@ object&quot;, NSStringFromSelector([inv selector]),[target className]); } @end 在这个遵循代理类里面我们只实现协议里面的两个方法。写出测试代码 #import &lt;Foundation/Foundation.h&gt; #import &quot;AspectProxy.h&quot; #import &quot;AuditingInvoker.h&quot; #import &quot;Student.h&quot; int main(int argc, const char * argv[]) { @autoreleasepool { id student = [[Student alloc] init]; // 设置代理中注册的选择器数组 NSValue *selValue1 = [NSValue valueWithPointer:@selector(study:andRead:)]; NSArray *selValues = @[selValue1]; // 创建AuditingInvoker AuditingInvoker *invoker = [[AuditingInvoker alloc] init]; // 创建Student对象的代理studentProxy id studentProxy = [[AspectProxy alloc] initWithObject:student selectors:selValues andInvoker:invoker]; // 使用指定的选择器向该代理发送消息---例子1 [studentProxy study:@&quot;Computer&quot; andRead:@&quot;Algorithm&quot;]; // 使用还未注册到代理中的其他选择器，向这个代理发送消息！---例子2 [studentProxy study:@&quot;mathematics&quot; :@&quot;higher mathematics&quot;]; // 为这个代理注册一个选择器并再次向其发送消息---例子3 [studentProxy registerSelector:@selector(study::)]; [studentProxy study:@&quot;mathematics&quot; :@&quot;higher mathematics&quot;]; } return 0; } 这里有3个例子。里面会分别输出什么呢？ before sending message with selector study:andRead: to Student object Invorking method on Student object with selector study:andRead: after sending message with selector study:andRead: to Student object Invorking method on Student object with selector study:: before sending message with selector study:: to Student object Invorking method on Student object with selector study:: after sending message with selector study:: to Student object 例子1中会输出3句话。调用Student对象的代理中的study:andRead:方法，会使该代理调用AuditingInvoker对象中的preInvoker:方法、真正目标（Student对象）中的study:andRead:方法，以及AuditingInvoker对象中的postInvoker:方法。一个方法的调用，调用起了3个方法。原因是study:andRead:方法是通过Student对象的代理注册的； 例子2就只会输出1句话。调用Student对象代理中的study::方法，因为该方法还未通过这个代理注册，所以程序仅会将调用该方法的消息转发给Student对象，而不会调用AuditorInvoker方法。 例子3又会输出3句话了。因为study::通过这个代理进行了注册，然后程序再次调用它，在这次调用过程中，程序会调用AuditingInvoker对象中的AOP方法和真正目标（Student对象）中的study::方法。 这个例子就实现了一个简单的AOP(Aspect Oriented Programming)面向切面编程。我们把一切功能”切”出去，与其他部分分开，这样可以提高程序的模块化程度。AOP能解耦也能动态组装，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能。比如上面的例子三，我们通过把方法注册到动态代理类中，于是就实现了该类也能处理方法的功能。 入院考试下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface NSObject (Sark) + (void)foo; - (void)foo; @end @implementation NSObject (Sark) - (void)foo { NSLog(@&quot;IMP: -[NSObject(Sark) foo]&quot;); } @end int main(int argc, const char * argv[]) { @autoreleasepool { [NSObject foo]; [[NSObject new] foo]; } return 0; } 这道有两处难点，难点一是给NSObject增加了一个分类，分类声明的是一个加号的类方法，而实现中是一个减号的实例方法。在main中去NSObject去调用了这个foo方法，会编译错误，还是会Crash呢？ 难点二是会输出什么内容呢？ 先来看难点一，这里会牵扯到Category的知识。推荐文章还是美团的这篇经典的深入理解Objective-C：Category // 这个函数算是整个 objc4 库的入口函数，被 libSystem 库调用 #if !__OBJC2__ static __attribute__((constructor)) #endif void _objc_init(void) { static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something // 首先第一步，注册 unmap 函数，万一有的类的 +load 方法需要 unmap 一些东西 // unmap，即 un-memory-mapped，这里应该就是取消内存映射，移除镜像的意思 _dyld_register_func_for_remove_image(&amp;unmap_image); // 注册镜像状态改变时的回调函数 dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch 是否批处理*/, &amp;map_2_images); // 注册镜像状态改变时的回调函数，镜像加载完成后，需要调用 +load 时会回调 load_images 函数 // 不进行批处理，所以 load_images 会被调用多次，每次有新的镜像进来时，都会被调用 dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images); } OC在初始化的时候，会去加载map_images，map_images最终会调用objc-runtime-new.mm里面的_read_images方法。_read_images方法里面会去初始化内存中的map, 这个时候将会load所有的类，协议还有Category。NSOBject的+load方法就是这个时候调用的。 // Discover categories. for (EACH_HEADER) { // 遍历 hList // 取得 hi 镜像中的所有分类 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) { // 遍历所有分类 category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 得到分类所属的类的 live class if (!cls) { // 如果 cls 为空 // Category&apos;s target class is missing (probably weak-linked). // Disavow any knowledge of this category. // 分类所属的类丢了，很多可能是 weak-linked 了 // 这个分类就是不可信的，完全没有什么鸟用了 catlist[i] = nil; // 将这个分类从列表中删除 if (PrintConnecting) { _objc_inform(&quot;CLASS: IGNORING category \\?\\?\\?(%s) %p with &quot; &quot;missing weak-linked target class&quot;, cat-&gt;name, cat); } continue; } // Process this category. // First, register the category with its target class. // Then, rebuild the class&apos;s method lists (etc) if // the class is realized. // 处理这个分类 // 首先，注册注册这个分类 // 然后，如果这个类已经是 realized 的话，就重新建立这个类的方法列表（把分类的方法添加进去） bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) // 如果分类中存在实例方法 or 协议 or 实例属性 { // 添加分类到所属的 cls 类上，即把这个分类添加到 cls 对应的所有 unattached 的分类的列表中 addUnattachedCategoryForClass(cat, cls, hi); // 如果 cls 类已经被 realized if (cls-&gt;isRealized()) { // 就重新 methodize 一下 cls 类，里面会重新 attachCategories 一下所有未被 attach 的分类 // 即把这些分类中的方法、协议、属性添加到 cls 类中 remethodizeClass(cls); classExists = YES; // 标记类存在 } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;, cls-&gt;nameForLogging(), cat-&gt;name, classExists ? &quot;on existing class&quot; : &quot;&quot;); } } // 如果分类中存在类方法 or 协议 if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) { // 添加分类到所属类 cls 的元类中 addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); // 如果 cls 的元类已经 realized 过了 if (cls-&gt;ISA()-&gt;isRealized()) { // 就重新 methodize 一下 cls 类的元类 remethodizeClass(cls-&gt;ISA()); } if (PrintConnecting) { _objc_inform(&quot;CLASS: found category +%s(%s)&quot;, cls-&gt;nameForLogging(), cat-&gt;name); } } } } 在这个加载中，for循环中会反复调用_getObjc2CategoryList 方法，这个方法的具体实现是 // function name content type section name GETSECT(_getObjc2CategoryList, category_t *, &quot;__objc_catlist&quot;); 最后一个参数__objc_catlist就是编译器刚刚生成的category数组。加载完所有的category之后，就开始处理这些类别。大体思路还是分为2类来分开处理。 if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties){ } 第一类是实例方法 if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) { } 第二类是类方法。 处理完之后的结果 把category的实例方法、协议以及属性添加到类上 把category的类方法和协议添加到类的metaclass上 这两种情况里面的处理方式都差不多，先去调用addUnattachedCategoryForClass函数，申请内存，分配空间。remethodizeClass这个方法里面会调用attachCategories方法。attachCategories方法代码就不贴了，有兴趣的可以自己去看看。这个方法里面会用头插法，把新加的方法从头插入方法链表中。并且最后还会flushCaches。这也就是为什么我们可以在Category里面覆盖原有的方法的原因，因为头插法，新的方法在链表的前面，会优先被遍历到。以上就是Category加载时候的流程。 再回到这道题目上面来，在加载NSObject的Category中，在编译期会提示我们没有实现+(void)foo的方法，因为在.m文件中并没有找到+的方法，而是一个-号的方法，所以会提示。但是在实际加载Category的时候，会把-(void)foo加载进去，由于是实例方法，所以会放在NSObject的实例方法链表里面。根据第二章分析的objc_msgSend源码实现，我们可以知道： 在调用[NSObject foo]的时候，会先在NSObject的meta-class中去查找foo方法的IMP，未找到，继续在superClass中去查找，NSObject的meta-class的superClass就是本身NSObject，于是又回到NSObject的类方法中查找foo方法，于是乎找到了，执行foo方法，输出 IMP: -[NSObject(Sark) foo] 在调用[[NSObject new] foo]的时候，会先生成一个NSObject的对象，用这个NSObject实例对象再去调用foo方法的时候，会去NSObject的类方法里面去查找，找到，于是也会输出 IMP: -[NSObject(Sark) foo] 所以上面这题，不会Compile Error ，更不会 Runtime Crash ，会输出两个相同的结果。 Runtime中的优化关于Runtime系统中，有3种地方进行了优化。 方法列表的缓存 虚函数表vTable dyld共享缓存 方法列表的缓存在消息发送过程中，查找IMP的过程，会优先查找缓存。这个缓存会存储最近使用过的方法都缓存起来。这个cache和CPU里面的cache的工作方式有点类似。原理是调用的方法有可能经常会被调用。如果没有这个缓存，直接去类方法的方法链表里面去查找，查询效率实在太低。所以查找IMP会优先搜索饭方法缓存，如果没有找到，接着会在虚函数表中寻找IMP。如果找到了，就会把这个IMP存储到缓存中备用。基于这个设计，使Runtime系统能能够执行快速高效的方法查询操作。 虚函数表虚函数表也称为分派表，是编程语言中常用的动态绑定支持机制。在OC的Runtime运行时系统库实现了一种自定义的虚函数表分派机制。这个表是专门用来提高性能和灵活性的。这个虚函数表是用来存储IMP类型的数组。每个object-class都有这样一个指向虚函数表的指针。 dyld共享缓存在我们的程序中，一定会有很多自定义类，而这些类中，很多SEL是重名的，比如alloc，init等等。Runtime系统需要为每一个方法给定一个SEL指针，然后为每次调用个各个方法更新元数据，以获取唯一值。这个过程是在应用程序启动的时候完成。为了提高这一部分的执行效率，Runtime会通过dyld共享缓存实现选择器的唯一性。 dyld是一种系统服务，用于定位和加载动态库。它含有共享缓存，能够使多个进程共用这些动态库。dyld共享缓存中含有一个选择器表，从而能使运行时系统能够通过使用缓存访问共享库和自定义类的选择器。 关于dyld的知识可以看看这篇文章dyld: Dynamic Linking On OS X","tags":[{"name":"消息发送 消息转发","slug":"消息发送-消息转发","permalink":"http://yoursite.com/tags/消息发送-消息转发/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"union定义(转载)","date":"2016-11-21T04:07:12.000Z","path":"wiki/C语言语法/union定义/","text":"union定义union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。例子如下： 1234567union StateMachine&#123; char character; int number; char *str; double exp;&#125;; 一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。 在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。 大小端模式对union 类型数据的影响下面再看一个例子： 12345678union&#123; int i; char a[2];&#125;*p, u;p =&amp;u;p-&gt;a[0] = 0x39;p-&gt;a[1] = 0x38; p.i 的值应该为多少呢？ 这里需要考虑存储模式：大端模式和小端模式。大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？ 如何用程序确认当前系统的存储模式？上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian 的，则返回1。 先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。 以大端模式存储，其内存布局如下图：以小端模式存储，其内存布局如下图： 变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。如果取出低地址上的值为0，毫无疑问，这是大端模式；如果取出低地址上的值为1，毫无疑问，这是小端模式。既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一致。 到现在，应该知道怎么写了吧？参考答案如下： 12345678910int checkSystem( )&#123; union check &#123; int i; char ch; &#125; c; c.i = 1; return (c.ch ==1);&#125; 总结union同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，它所占的空间等于其最大的成员所占的空间，机器的大小端存储影响union成员的取值。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"神经病院Objective-C Runtime入院第一天——isa和Class(转载)","date":"2016-11-18T01:50:28.000Z","path":"wiki/IOS_Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/","text":"本文转载自神经病院Objective-C Runtime入院第一天——isa和Class。Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。 Runtime简介C语言中，在编译期，函数的调用就会决定调用哪个函数。而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。编译时向接受者发送消息，运行时找到函数调用Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。Objc 在三种层面上与 Runtime 系统进行交互： 通过 Objective-C 源代码一般情况开发者只需要编写 OC 代码即可，Runtime系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码 ，在运行时确定对应的数据结构和调用具体哪个方法。 通过 Foundation 框架的 NSObject 类定义的方法在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。 在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。 - (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;anObject.dynamicType&apos; instead&quot;); - (BOOL)isKindOfClass:(Class)aClass; - (BOOL)isMemberOfClass:(Class)aClass; - (BOOL)conformsToProtocol:(Protocol *)aProtocol; - (BOOL)respondsToSelector:(SEL)aSelector; -class方法返回对象的类；-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；-respondsToSelector: 检查对象能否响应指定的消息；-conformsToProtocol:检查对象是否实现了指定协议类的方法； 在NSObject的类中还定义了一个方法 - (IMP)methodForSelector:(SEL)aSelector; 这个方法会返回指定方法实现的地址IMP。 以上这些方法会在本篇文章中详细分析具体实现。 通过对 Runtime 库函数的直接调用关于库函数可以在Objective-C Runtime Reference中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，那些函数里面的参数和描述都没有了。对于熟悉Runtime的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从iOS6开始开发的同学，依稀可能能感受到，关于Runtime的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从Xcode5开始，苹果就不建议我们手动调用Runtime的API，也同样希望我们不要知道具体底层实现。所以IDE上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释。 具体设置如下:如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成NO，即可。 NSObject起源由上面一章节，我们知道了与Runtime交互有3种方式，前两种方式都与NSObject有关，那我们就从NSObject基类开始说起。以下源码分析均来自objc4-680NSObject的定义如下: typedef struct objc_class *Class; @interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY; } 在Objc2.0之前，objc_class源码如下： struct objc_class { Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif } OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。 ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这表明可以通过动态修改*methodLists的值来实现添加成员方法的目的，这也是Category实现的原理，同样解释了Category不能添加属性的原因。 关于Category，这里推荐2篇文章可以仔细研读一下。深入理解Objective-C：Category结合 Category 工作原理分析 OC2.0 中的 runtime 然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了。 typedef struct objc_class *Class; typedef struct objc_object *id; @interface Object { Class isa; } @interface NSObject &lt;NSObject&gt; { Class isa OBJC_ISA_AVAILABILITY; } struct objc_object { private: isa_t isa; } struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags } union isa_t { isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; } 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在objc2.0中，所有的对象都会包含一个isa_t类型的结构体。 objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。 objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法表。 object类和NSObject类里面分别都包含一个objc_class类型的isa。上图的左半边类的关系描述完了，接着先从isa来说起。当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。关于元类，更多具体可以研究这篇文章What is a meta-class in Objective-C（译文）? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。调用对象的实例方法时，通过对象的 isa 在类中获取方法的实现。调用类对象的类方法时，通过类的isa指针在元类中获取方法的实现。meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。 对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系:图中实线是 super_class指针，虚线是isa指针。 Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。 每个Class都有一个isa指针指向唯一的元类（Meta class）。 Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。 每个Meta class的isa指针都指向Root class (meta)。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。具体可看sunnyxx这篇iOS 程序 main 函数之前发生了什么 isa_t结构体的具体实现接下来我们就该研究研究isa的具体实现了。objc_object里面的isa是isa_t类型。通过查看源码，我们可以知道isa_t是一个union联合体。 union isa_t { // 构造函数 isa_t() { } isa_t(uintptr_t value) : bits(value) { } Class cls; uintptr_t bits; struct { uintptr_t indexed : 1; // 0表示普通的isa指针 1表示优化过的，存储引用计数 uintptr_t has_assoc : 1; // 对象是否包含 associated object，如果没有，析构时会更快 uintptr_t has_cxx_dtor : 1; // 是否有C++或ARC的析构函数，如果没有，析构时会更快 uintptr_t shiftcls : 33; // 最重要的原来的Class cls部分，占33个bit，与 ISA_MASK 进行 &amp; 操作可以得到 // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; // 用于调试时分辨对象是否完成初始化 uintptr_t weakly_referenced : 1; // 对象是否有过weak引用，如果没有，析构时会更快 uintptr_t deallocating : 1; // 对象是否正在析构 uintptr_t has_sidetable_rc : 1; // 表示对象的引用计数过大，无法存储在isa指针，只能存在side table中 uintptr_t extra_rc : 19; // 存储引用计数，不过好像是减 1 后的值，可以在 rootRetainCount 方法中看到 // 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。 # define RC_ONE (1ULL&lt;&lt;45) // 左移 45 bit，正好是extra_rc 所在的位置 # define RC_HALF (1ULL&lt;&lt;18) // extra_rc 总共是19位，RC_HALF是18位，也就是全部引用计数的一半 }; } struct objc_object { private: isa_t isa; public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor); private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor); ｝ 那就从initIsa方法开始研究。下面以arm64为例。 inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor) { initIsa(cls, true, hasCxxDtor); } inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) { if (!indexed) { isa.cls = cls; } else { isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; } } initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。 # if __arm64__ # define ISA_MASK 0x0000000ffffffff8ULL # define ISA_MAGIC_MASK 0x000003f000000001ULL # define ISA_MAGIC_VALUE 0x000001a000000001ULL struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; # define RC_ONE (1ULL&lt;&lt;45) # define RC_HALF (1ULL&lt;&lt;18) }; # elif __x86_64__ # define ISA_MASK 0x00007ffffffffff8ULL # define ISA_MAGIC_MASK 0x001f800000000001ULL # define ISA_MAGIC_VALUE 0x001d800000000001ULL struct { uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; # define RC_ONE (1ULL&lt;&lt;56) # define RC_HALF (1ULL&lt;&lt;7) }; ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：关于参数的说明： 第一位index，代表是否开启isa指针优化。index = 1，代表开启isa指针优化。 在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。 在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。 假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示：苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：关于Tagged Pointer技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64架构中有33位可以存储类指针。 源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解isa 这篇文章里面的shiftcls分析。 magic判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要存在side table中。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。 ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。 inline Class objc_object::ISA() { assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK); } 关于x86_64的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。 cache_t的具体实现还是继续看源码 struct cache_t { struct bucket_t *_buckets; mask_t _mask; mask_t _occupied; } typedef unsigned int uint32_t; typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t; typedef uintptr_t cache_key_t; struct bucket_t { private: cache_key_t _key; IMP _imp; } 根据源码，我们可以知道cache_t中存储了一个bucket_t的结构体，和两个unsigned int的变量。 mask：分配用来缓存bucket的总数。occupied：表明目前实际占用的缓存bucket的个数。 bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。 cache_t中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。 Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。 class_data_bits_t的具体实现源码实现如下： struct class_data_bits_t { // Values are the FAST_ flags above. uintptr_t bits; } struct class_rw_t { uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName; } struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const { return baseMethodList; } }; 在 objc_class结构体中的注释写到 class_data_bits_t相当于 class_rw_t指针加上 rr/alloc 的标志。 class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags 它为我们提供了便捷方法用于返回其中的 class_rw_t *指针： class_rw_t *data() { return bits.data(); } Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite，ro-readonly 在编译期类的结构中的 class_data_bits_t data指向的是一个 class_ro_t 指针：在运行时调用 realizeClass方法，会做以下3件事情： 从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针 初始化一个 class_rw_t结构体 设置结构体 ro的值以及 flag 最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。 struct method_t { SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; { bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) { return lhs.name &lt; rhs.name; } }; }; 方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是Type Encoding类型编码，类型可参考Type Encoding，在此不细说。 IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。 整个运行时过程可以描述如下：更加详细的分析，请看@Draveness 的这篇文章 深入解析 ObjC 中方法的结构 到此，总结一下objc_class 1.0和2.0的差别。 入院考试[self class] 与 [super class]下面代码输出什么? @implementation Son : Father - (id)init { self = [super init]; if (self) { NSLog(@&quot;%@&quot;, NSStringFromClass([self class])); NSLog(@&quot;%@&quot;, NSStringFromClass([super class])); } return self; } @end self和super的区别： self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。 super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。 在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ ) /// Specifies the superclass of an instance. struct objc_super { /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class; #else __unsafe_unretained Class super_class; #endif /* super_class is the first class to search */ }; 在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是 当前类的父类super_class。 入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。 objc_msgSendSuper的工作原理应该是这样的:从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc-&gt;receiver去调用父类的这个selector。注意，最后的调用者是objc-&gt;receiver，而不是super_class！ 那么objc_msgSendSuper最后就转变成 objc_msgSend(objc_super-&gt;receiver, @selector(class)) + (Class)class { return self; } 由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super-&gt;receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。 isKindOfClass 与 isMemberOfClass下面代码输出什么？ @interface Sark : NSObject @end @implementation Sark @end int main(int argc, const char * argv[]) { @autoreleasepool { BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; Y BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; Y BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4); } return 0; } 先来分析一下源码这两个函数的对象实现 + (Class)class { return self; } - (Class)class { return object_getClass(self); } Class object_getClass(id obj) { if (obj) return obj-&gt;getIsa(); else return Nil; } inline Class objc_object::getIsa() { if (isTaggedPointer()) { uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; } return ISA(); } inline Class objc_object::ISA() { assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK); } + (BOOL)isKindOfClass:(Class)cls { for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO; } - (BOOL)isKindOfClass:(Class)cls { for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) { if (tcls == cls) return YES; } return NO; } + (BOOL)isMemberOfClass:(Class)cls { return object_getClass((id)self) == cls; } - (BOOL)isMemberOfClass:(Class)cls { return [self class] == cls; } 首先题目中NSObject 和 Sark分别调用了class方法。 (BOOL)isKindOfClass:(Class)cls方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj-&gt;getIsa()，最后在ISA()方法中获得meta class的指针。 接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。 [NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。 同理，[Sark class]执行完之后调用isKindOfClass，第一次for循环，Sark的Meta Class与[Sark class]不等，第二次for循环，Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Sark Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。 如果把这里的Sark改成它的实例对象，[sark isKindOfClass:[Sark class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断sark的meta class是自己的元类Sark，第一次for循环就能输出YES了。 isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Sark的Meta Class，和Sark Class也不等，所以第二行res2和第四行res4都输出NO。 Class与内存地址下面的代码会？Compile Error / Runtime Crash / NSLog…? @interface Sark : NSObject @property (nonatomic, copy) NSString *name; - (void)speak; @end @implementation Sark - (void)speak { NSLog(@&quot;my name&apos;s %@&quot;, self.name); } @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak]; } @end 这道题有两个难点。难点一，obj调用speak方法，到底会不会崩溃。难点二，如果speak方法不崩溃，应该输出什么？ 首先需要谈谈隐藏参数self和_cmd的问题。 当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self在上面已经讲解明白了，接下来就来说说_cmd。_cmd表示当前调用方法，其实它就是一个方法选择器SEL。 难点一，能不能调用speak方法？ id cls = [Sark class]; void *obj = &amp;cls; 答案是可以的。obj被转换成了一个指向Sark Class的指针，然后使用id转换成了objc_object类型。obj现在已经是一个Sark类型的实例对象了。当然接下来可以调用speak的方法。 难点二，如果能调用speak，会输出什么呢？ 很多人可能会认为会输出sark相关的信息。这样答案就错误了。 正确的答案会输出 my name is &lt;ViewController: 0x7ff6d9f31c50&gt; 内存地址每次运行都不同，但是前面一定是ViewController。why？ 我们把代码改变一下，打印更多的信息出来。 - (void)viewDidLoad { [super viewDidLoad]; NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self); id cls = [Sark class]; NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls); void *obj = &amp;cls; NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark,&amp;sark); [sark speak]; } 我们把对象的指针地址都打印出来。输出结果： ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8 Sark class = Sark 地址 = 0x7fff543f5a88 Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80 my name is &lt;ViewController: 0x7fb570e2ad00&gt; Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78 my name is (null) // objc_msgSendSuper2() takes the current search class, not its superclass. OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0); objc_msgSendSuper2方法入参是一个objc_super *super。 /// Specifies the superclass of an instance. struct objc_super { /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class; #else __unsafe_unretained Class super_class; #endif /* super_class is the first class to search */ }; #endif 所以按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class，self，obj。 第一个self和第二个_cmd是隐藏参数。第三个self.class和第四个self是[super viewDidLoad]方法执行时候的参数。 在调用self.name的时候，本质上是self指针在内存向高位地址偏移一个指针。在32位下面，一个指针是4字节=4*8bit=32bit。 从打印结果我们可以看到，obj就是cls的地址。在obj向上偏移32bit就到了0x7fff543f5aa8，这正好是ViewController的地址。 所以输出为my name is 。 至此，Objc中的对象到底是什么呢？ 实质：Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ - (void)viewDidLoad { [super viewDidLoad]; NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self); NSString *myName = @&quot;halfrost&quot;; id cls = [Sark class]; NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls); void *obj = &amp;cls; NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark,&amp;sark); [sark speak]; } ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78 Sark class = Sark 地址 = 0x7fff56a48a50 Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48 my name is halfrost Sark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40 my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak];这句话会输出“my name is halfrost” 原因还是和上面的类似。按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class，self，myName，obj。obj往上偏移32位，就是myName字符串，所以输出变成了输出myName了。","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"What is a meta-class in Objective-C(译文)","date":"2016-11-12T11:56:17.000Z","path":"wiki/IOS_Runtime/meta_class/","text":"本文是对What is a meta-class in Objective-C的翻译,这篇文章主要讲解Objective-C中的元类（meta-class），元类对runtime的理解非常有用。不过快翻译完后，发现已经有前辈翻译过了–Objective-C 中的元类（meta class）是什么？。后面就使用它的翻译。 In this post, I look at one of the stranger concepts in Objective-C — the meta-class. Every class in Objective-C has its own associated meta-class but since you rarely ever use a meta-class directly, they can remain enigmatic. I’ll start by looking at how to create a class at runtime. By examining the “class pair” that this creates, I’ll explain what the meta-class is and also cover the more general topic of what it means for data to be an object or a class in Objective-C. 在这篇文章中，我讲解Objective-C中的一个陌生概念——meta-class。在Objective-C，每个类都有一个相关meta-class，由于你很少直接使用meta-class，所以meta-class仍感觉很神秘。我从运行时如何创建一个meta-class开始，然后通过查看创建出的两个类（class 和meta-class），解释什么是meta-class，其中，还会涉及它对于Objective-C中对象和类的意义。 Creating a class at runtimeThe following code creates a new subclass of NSError at runtime and adds one method to it:下面的代码在运行时创建了一个NSError的子类RuntimeErrorSubclass，并且为RuntimeErrorSubclass添加一个类方法： Class newClass = objc_allocateClassPair([NSError class], &quot;RuntimeErrorSubclass&quot;, 0); class_addMethod(newClass, @selector(report), (IMP)ReportFunction, &quot;v@:&quot;); objc_registerClassPair(newClass); The method added uses the function named ReportFunction as its implementation, which is defined as follows:新添加的实现 是ReportFunction函数。定义如下： void ReportFunction(id self, SEL _cmd) { NSLog(@&quot;This object is %p.&quot;, self); NSLog(@&quot;Class is %@, and super is %@.&quot;, [self class], [self superclass]); Class currentClass = [self class]; for (int i = 1; i &lt; 5; i++) { NSLog(@&quot;Following the isa pointer %d times gives %p&quot;, i, currentClass); currentClass = object_getClass(currentClass); } NSLog(@&quot;NSObject&apos;s class is %p&quot;, [NSObject class]); NSLog(@&quot;NSObject&apos;s meta class is %p&quot;, object_getClass([NSObject class])); } On the surface, this is all pretty simple. Creating a class at runtime is just three easy steps:表面上，这非常的简单，在运行时创建一个类只需要三步： Allocate storage for the “class pair” (using objc_allocateClassPair). Add methods and ivars to the class as needed (I’ve added one method using class_addMethod). Register the class so that it can be used (using objc_registerClassPair). 使用objc_allocateClassPair函数为两个类（class pair）申请内存。 使用class_addMethod函数为类添加方法。 使用objc_registerClassPair注册类。 However, the immediate question is: what is a “class pair”? The function objc_allocateClassPair only returns one value: the class. Where is the other half of the pair?然而，问题就马上来了，什么是“class pair”？ objc_allocateClassPair函数只返回了一个值：newClass，一对类的另一半是什么？ I’m sure you’ve guessed that the other half of the pair is the meta-class (it’s the title of this post) but to explain what that is and why you need it, I’m going to give some background on objects and classes in Objective-C.我确信你已经猜到：一对类的另一半是meta-class。 为了解释它是什么和我们为什么需要它，还需要交代下Objective-C的对象和类的相关背景 什么数据结构才能称之为对象What is needed for a data structure to be an object? Every object has a class. This is a fundamental object-oriented concept but in Objective-C, it is also a fundamental part of the data. Any data structure which has a pointer to a class in the right location can be treated as an object.每个对象都有一个类。这是面向对象的基本概念。但是在Objective-C中，它对数据结构也一样。含有一个指针且该指针可以正确指向类的数据结构，都可以被视作为对象。 In Objective-C, an object’s class is determined by its isa pointer. The isa pointer points to the object’s Class.在Objective-C中，对象的类是有isa指针决定的。isa指针指向对象所属的类。 In fact, the basic definition of an object in Objective-C looks like this:事实上，在Objective-C中，对象的基本定义如下： typedef struct objc_object { Class isa; } What this says is: any structure which starts with a pointer to a Class structure can be treated as an objc_object.这就是说：以指向类结构指针开始的数据结构，可以被认为是objc_object（这里使用objc_object，表示包括实例和类）； The most important feature of objects in Objective-C is that you can send messages to them:在Objective-C中，objc_object的主要特征是可以向它发生消息。 [@&quot;stringValue&quot; writeToFile:@&quot;/file.txt&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL] This works because when you send a message to an Objective-C object (like the NSCFString here), the runtime follows object’s isa pointer to get to the object’s Class (the NSCFString class in this case). The Class then contains a list of the Methods which apply to all objects of that Class and a pointer to the superclass to look up inherited methods. The runtime looks through the list of Methods on the Class and superclasses to find one that matches the message selector (in the above case, writeToFile:atomically:encoding:error on NSString). The runtime then invokes the function (IMP) for that method.上面的例子可以运行的原因是：当向对象（NSCFString）发送消息时，runtime根据跟随isa指针找到对象所属类（这里是NSCFString），对象的类包含方法列表（类的所有对象都具有）和指向父类的指针（包含继承来的方法列表）。这个类包含了能应用于这个类的所有实例方法和指向超类的指针以便可以找到父类的实例方法。运行时库检查这个类和其超类的方法列表，找到一个匹配这条消息的方法（在上面的代码里，是NSString类的writeToFile:atomically:encoding:error方法）。运行时库基于那个方法调用函数（IMP）。 The important point is that the Class defines the messages that you can send to an object.Class的主要特点是：类定义了发送给对象的消息。 什么是元类What is a meta-class? Now, as you probably already know, a Class in Objective-C is also an object. This means that you can send messages to a Class.现在，你可能已经知道，在Objective-C中，一个Class也是一个objc_object。也就是说：你可以向Class发送消息。 NSStringEncoding defaultStringEncoding = [NSString defaultStringEncoding]; In this case, defaultStringEncoding is sent to the NSString class.上面这个例子里，defaultStringEncoding消息发送给了NSString类。 This works because every Class in Objective-C is an object itself. This means that the Class structure must start with an isa pointer so that it is binary compatible with the objc_object structure I showed above and the next field in the structure must be a pointer to the superclass (or nil for base classes).可以向Class发送消息的原因是：在Objective-C中，任何一个类都是一个objc_object。这就是说：类的数据结构必须是以isa开头，这样才可以被看做是objc_object，紧跟着isa后面的是指向父类的指针（对于基类为nil）。 As I showed last week, there are a couple different ways that a Class can be defined, depending on the version of the runtime you are running, but yes, they all start with an isa field followed by a superclass field.如我上周说的，Class在不同的runtime版本中有两种不同的定义。但他们都以isa指针开始，后续跟着指向父类的指针。 typedef struct objc_class *Class; struct objc_class { Class isa; Class super_class; /* followed by runtime specific details... */ }; However, in order to let us invoke a method on a Class, the isa pointer of the Class must itself point to a Class structure and that Class structure must contain the list of Methods that we can invoke on the Class.然而，为了可以调用Class的方法，Class的isa指针必须指向包含类方法的类结构体。 This leads to the definition of a meta-class: the meta-class is the class for a Class object.引出meta-class的原因：meta-class是类对象的类 Simply put:简言之 When you send a message to an object, that message is looked up in the method list on the object’s class. When you send a message to a class, that message is looked up in the method list on the class’ meta-class. 当向对象发送消息的时候，消息在对象的类中查找 当向类发送消息，消息在类的meta-class中查找 The meta-class is essential because it stores the class methods for a Class. There must be a unique meta-class for every Class because every Class has a potentially unique list of class methods.meta-class重要的原因是：meta-calss存储了类的类方法。每个类都有一个唯一的元类，原因是每个类都有自己唯一的类方法列表。 元类的类是什么？What is the class of the meta-class? The meta-class, like the Class before it, is also an object. This means that you can invoke methods on it too. Naturally, this means that it must also have a class.meta-class就像前面提到的Class，也是一个objc_object。就是说可以向meta-class发送消息。自然的，meta-class也有一个类。 All meta-classes use the base class’ meta-class (the meta-class of the top Class in their inheritance hierarchy) as their class. This means that for all classes that descend from NSObject (most classes), the meta-class has the NSObject meta-class as its class.所有元类的类是根基类的元类。也就是说：所有从NSObject继承下来的类，他们的元类的类是NSObject的元类。这就意味着所有NSObject的子类（大多数类）的元类都会以NSObject的元类作为他们的类 Following the rule that all meta-classes use the base class’ meta-class as their class, any base meta-classes will be its own class (their isa pointer points to themselves). This means that the isa pointer on the NSObject meta-class points to itself (it is an instance of itself).依据下面的规则：所有的元类使用根基类的元类作为他们的类，根元类的元类则就是它自己。也就是说基类（NSObject）的元类的isa指针指向他自己（NSObject）。 #类和元类的继承Inheritance for classes and meta-classes In the same way that the Class points to the superclass with its super_class pointer, the meta-class points to the meta-class of the Class’ super_class using its own super_class pointer.类用 super_class指针指向了超类，同样的，元类用super_class指向类的super_class的元类。 As a further quirk, the base class’ meta-class sets its super_class to the base class itself.说的更拗口一点就是，根元类把它自己的基类设置成了super_class。 The result of this inheritance hierarchy is that all instances, classes and meta-classes in the hierarchy inherit from the hierarchy’s base class.在这样的继承体系下，所有实例、类以及元类（meta class）都继承自一个基类。 For all instances, classes and meta-classes in the NSObject hierarchy, this means that all NSObject instance methods are valid. For the classes and meta-classes, all NSObject class methods are also valid.这意味着对于继承于NSObject的所有实例、类和元类，他们可以使用NSObject的所有实例方法，类和元类可以使用NSObject的所有类方法 All this is pretty confusing in text. Greg Parker has put together an excellent diagram of instances, classes, meta-classes and their super classes and how they all fit together.这些文字看起来莫名其妙难以理解。Greg Parker给出了一份精彩的图谱来展示这些关系。 实验证明Experimental confirmation of this To confirm all of this, let’s look at the output of the ReportFunction I gave at the start of this post. The purpose of this function is to follow the isa pointers and log what it finds. To run the ReportFunction, we need to create an instance of the dynamically created class and invoke the report method on it. id instanceOfNewClass = [[newClass alloc] initWithDomain:@”someDomain” code:0 userInfo:nil];[instanceOfNewClass performSelector:@selector(report)];[instanceOfNewClass release];Since there is no declaration of the report method, I invoke it using performSelector: so the compiler doesn’t give a warning. The ReportFunction will now traverse through the isa pointers and tell us what objects are used as the class, meta-class and class of the meta-class. Getting the class of an object: the ReportFunction uses object_getClass to follow the isa pointers because the isa pointer is a protected member of the class (you can’t directly access other object’s isa pointers). The ReportFunction does not use the class method to do this because invoking the class method on a Class object does not return the meta-class, it instead returns the Class again (so [NSString class] will return the NSString class instead of the NSString meta-class).This is the output (minus NSLog prefixes) when the program runs: This object is 0x10010c810.Class is RuntimeErrorSubclass, and super is NSError.Following the isa pointer 1 times gives 0x10010c600Following the isa pointer 2 times gives 0x10010c630Following the isa pointer 3 times gives 0x7fff71038480Following the isa pointer 4 times gives 0x7fff71038480NSObject’s class is 0x7fff710384a8NSObject’s meta class is 0x7fff71038480Looking at the addresses reached by following the isa value repeatedly: the object is address 0x10010c810.the class is address 0x10010c600.the meta-class is address 0x10010c630.the meta-class’s class (i.e. the NSObject meta-class) is address 0x7fff71038480.the NSObject meta-class’ class is itself.The value of the addresses is not really important except that it shows the progress from class to meta-class to NSObject meta-class as discussed. 结论（Conclusion） The meta-class is the class for a Class object. Every Class has its own unique meta-class (since every Class can have its own unique list of methods). This means that all Class objects are not themselves all of the same class.元类是 Class 对象的类。每个类（Class）都有自己独一无二的元类（每个类都有自己第一无二的方法列表）。这意味着所有的类对象都不同。 The meta-class will always ensure that the Class object has all the instance and class methods of the base class in the hierarchy, plus all of the class methods in-between. For classes descended from NSObject, this means that all the NSObject instance and protocol methods are defined for all Class (and meta-class) objects.元类总是会确保类对象和基类的所有实例和类方法。对于从NSObject继承下来的类，这意味着所有的NSObject实例和protocol方法在所有的类（和meta-class）中都可以使用。 All meta-classes themselves use the base class’ meta-class (NSObject meta-class for NSObject hierarchy classes) as their class, including the base level meta-class which is the only self-defining class in the runtime.所有的meta-class使用基类的meta-class作为自己的类，对于根基类的meta-class也是一样，只是它指向自己而已。 读后总结翻译完后，总是感觉还是不好理解，所以自己画了一张图，方便理解。 具有指向Class的isa指针的数据结构可以称之为objc_objcet对象。 objc_object对象的主要特点是可以向它发送消息。 Object、Class、meta-class都属于objc_class。 对象的isa指针指向对象所属的类，对象所属的类保存对象的实例方法。 类的isa指针指向类的元类（meta-class）。类的元类保存类的类方法。 向实例发送消息，消息查找的路径是：跟随对象的isa指针，找到对象所属的类，在类中查找，如果类中没有，依次从超类中查找直到根基类。 向对象发行消息，消息查找的路径是：跟随类的isa指针，找到类的元类，在元类中查找，如果元类中没有，依次从元类的超类中查找，如果最后根元类也没有，在根基类（NSObject）中查找。 元类就是类的类（就是类的isa指针）。 元类的作用：当向对象和类发送消息时，统一了类对象和对象查找方法的机制—都从isa中查找。","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"runtime1","date":"2016-11-03T09:27:29.000Z","path":"wiki/IOS_Runtime/runtime1/","text":"现在越来越多的app都使用了JSPatch实现app热修复，而JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C是动态语言，OC上所有方法的调用/类的生成都通过Objective-C Runtime在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。今天就来详细解析一下OC中runtime最为吸引人的地方。 #objc_msgSend函数简介 最初接触到OC Runtime，一定是从[receiver message]这里开始的。[receiver message]会被编译器转化为： id objc_msgSend ( id self, SEL op, ... ); 这是一个可变参数函数。第二个参数类型是SEL。SEL在OC中是方法选择器。 typedef struct objc_selector *SEL; objc_selector是一个映射到方法的C字符串。下面就做了个测试： -(NSString *) selectorTestWithName:(NSString *)strName sex:(NSString *) strSex { NSLog(@&quot;sel = %s&quot;, @selector(selectorTestWithName:sex:)); return nil; } 输出如下： sel = selectorTestWithName:sex: 需要注意的是@selector()选择子只与函数名有关。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。由于这点特性，也导致了OC不支持函数重载。 在receiver拿到对应的selector之后，如果自己无法执行这个方法，那么该条消息要被转发。或者临时动态的添加方法实现。如果转发到最后依旧没法处理，程序就会崩溃。 所以编译期仅仅是确定了要发送消息，而消息如何处理是要运行期需要解决的事情。 objc_msgSend函数究竟会干什么事情呢？ 1.检测这个 selector是不是要忽略的。2.检查target是不是为nil。如果这里有相应的nil的处理函数，就跳转到相应的函数中。 如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。3.确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。如果找到，就跳转进去执行。 如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。4.如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程。 消息发送Messaging阶段—objc_msgSend源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 #include id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...) { struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) { cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do { method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; } while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); } return( (id) self); recache: /* ... */ return( 0); } 该源码中有一个do-while循环，这个循环就是上一章里面提到的在方法分发表里面查找method的过程。 不过在obj4-680里面的objc-msg-x86_64.s文件中实现是一段汇编代码。 /******************************************************************** * * id objc_msgSend(id self, SEL _cmd,...); * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes _objc_debug_taggedpointer_classes: .fill 16, 8, 0 ENTRY _objc_msgSend MESSENGER_START NilTest NORMAL GetIsaFast NORMAL // r11 = self-&gt;isa CacheLookup NORMAL // calls IMP on success NilTestSupport NORMAL GetIsaSupport NORMAL // cache miss: go search the method lists LCacheMiss: // isa still in r11 MethodTableLookup %a1, %a2 // r11 = IMP cmp %r11, %r11 // set eq (nonstret) for forwarding jmp *%r11 // goto *imp END_ENTRY _objc_msgSend ENTRY _objc_msgSend_fixup int3 END_ENTRY _objc_msgSend_fixup STATIC_ENTRY _objc_msgSend_fixedup // Load _cmd from the message_ref movq 8(%a2), %a2 jmp _objc_msgSend END_ENTRY _objc_msgSend_fixedup","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/categories/runtime/"}]},{"title":"二级指针动态申请内存","date":"2016-10-29T07:53:34.000Z","path":"wiki/C语言语法/CC_pointer_memry/","text":"在读《高质量CC++编程指南》的时候，为了透彻理解二级指针传递内存的原理，写下本文，本文用图形化的方式描述二级指针传递内存的原理。 一级指针不能动态申请内存如果函数的参数是一个指针，不要指望用该指针去申请动态内存，下面的代码试图用GemMemory函数获取内存失败。 1234567891011void GetMemory(char *p,int num)&#123; p = (char*)malloc(sizeof(char)*num);&#125;void Test(void)&#123; char * sz = NULL; GeyMemory(sz,100); ///执行完sz任然为NULL strcpy(sz,&quot;hello&quot;); ///运行错误&#125; 下面给出一张图，说明GemMemory函数为什么传递不了内存。 编译器总是为函数的每个参数制作临时副本，在被调用函数内部使用副本，指针p的副本是_p,函数执行前，_p = p ,都指向地址0x00000000处，用虚线头表示；GemMemory函数执行时，_p指向了新申请的内存0xA0101010地址；函数调用结束后，p还指向地址0x00000000处，_p指向了0xA0101010，但应该已经不存在，_p改变不能改变p指针，不能让p指针指向地址0xA0101010出处，执行完的指针指向使用实线表示。所以GemMemory不能传递内存。 二级指针动态申请内存下面是二级指针动态申请内存的示例代码： 1234567891011void GetMemory2(char **p,int num)&#123; *p = (char*)malloc(sizeof(char)*num);&#125;void Test(void)&#123; char * sz = NULL; GeyMemory2(&amp;sz,100); strcpy(sz,&quot;hello&quot;); ///没有问题 &#125; 下面给出一张图，说明GemMemory2函数可以传递内存的原因。图中所有地址都是随机写的，不是真实地址。 现在假设，指针p的副本是_p,函数执行前，_p = p，他俩都指向地址0x88888888，0x88888888地址的内容还是个地址，指向地址0x00000000 ；GemMemory2执行时， *_p指向了0xB0101010地址，也就是说，地址0x88888888中的内容变为0xB0101010，那么，*p也就指向了0xB0101010地址。修改*_p，*p也被修改；函数执行结束：二级指针P最终指向了地址0xB0101010。所以GemMemory2可以动态申请内存。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"给IOS模拟器按照APP","date":"2016-10-27T01:15:55.000Z","path":"wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/","text":"这里介绍了给IOS模拟器安装APP的方法。 安装步骤 安装HomeBrew ,终端输入 ： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装node.js, 终端输入： brew install node 安装ios-sim，在终端中输入 ： npm install ios-sim -g 安装、启动APP ios-sim launch APP路径 –devicetypeid iPhone-6s","tags":[{"name":"IOS 工具","slug":"IOS-工具","permalink":"http://yoursite.com/tags/IOS-工具/"}],"categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}]},{"title":"struct定义语法","date":"2016-10-26T10:13:26.000Z","path":"wiki/C语言语法/struct_Analize/","text":"在C语言中，若使用struct node {}这样来定义结构体的话。在定义变量时，需要这样写：struct node n;若用typedef定义结构体，typedef struct node{}NODE; 。在定义变量时可以这样写，NODE n;区别就在于使用时，是否可以省去struct这个关键字。 定义结构体C 定义结构体在C中定义一个结构体类型要用typedef: 1234typedef struct Student&#123; int a;&#125;Stu; Stu就变为了结构体类型，等同于struct Student，相当于一个别名。于是声明变量可以使用： Stu stu1; struct Student stu1; 另外这里也可以不写Student（于是也不能struct Student stu1;了） 1234typedef struct&#123; int a;&#125;Stu; C++ 定义结构体但在c++里很简单，直接 1234struct Student&#123;int a;&#125;; 于是就定义了结构体类型Student，声明变量时直接Student stu2； 在c++中如果用typedef的话，又会造成区别： 123456789struct Student&#123;int a;&#125;stu1;//stu1是一个变量typedef struct Student2&#123;int a;&#125;stu2;//stu2是一个结构体类型 使用时可以直接访问stu1.a但是stu2则必须先 stu2 s2;然后 s2.a=10; struct 与class 的区别在C++里struct 关键字与class 关键字一般可以通用，只有一个很小的区别。struct 的成员默认情况下属性是public 的，而class 成员却是private 的。很多人觉得不好记，其实很容易。你平时用结构体时用public 修饰它的成员了吗？既然struct 关键字与class 关键字可以通用，你也不要认为结构体内不能放函数了。 ##位域有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。为了节省存储空间，并使处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： struct 位域结构名 { 位域列表 }; 其中位域列表的形式为： 类型说明符 位域名：位域长度例如：123456struct bs&#123;int a:8;int b:2;int c:6;&#125;; 下面是IOS runtime中使用位域的一个例子 1234567891011121314 struct &#123; uintptr_t indexed : 1; // 0表示普通的isa指针 1表示优化过的，存储引用计数 uintptr_t has_assoc : 1; // 对象是否包含 associated object，如果没有，析构时会更快 uintptr_t has_cxx_dtor : 1; // 是否有C++或ARC的析构函数，如果没有，析构时会更快 uintptr_t shiftcls : 33; // 最重要的原来的Class cls部分，占33个bit，与 ISA_MASK 进行 &amp; 操作可以得到 // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; // 用于调试时分辨对象是否完成初始化 uintptr_t weakly_referenced : 1; // 对象是否有过weak引用，如果没有，析构时会更快 uintptr_t deallocating : 1; // 对象是否正在析构 uintptr_t has_sidetable_rc : 1; // 表示对象的引用计数过大，无法存储在isa指针，只能存在side table中 uintptr_t extra_rc : 19; // 存储引用计数，不过好像是减 1 后的值，可以在 rootRetainCount 方法中看到 // 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。# define RC_ONE (1ULL&lt;&lt;45) // 左移 45 bit，正好是extra_rc 所在的位置# define RC_HALF (1ULL&lt;&lt;18) // extra_rc 总共是19位，RC_HALF是18位，也就是全部引用计数的一半 &#125;; 总结在C语言和C++语言中，struct的定义感觉非常难记忆，我记忆的方法是：首先记住C语言中的struct的定义，“typedef struct Student{}Stu;”，struct Student整体才当做是类型，至于C++的struct的定义不用记，就把struct当成是class，class怎么使用，struct就怎么使用。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"收集、符号化IOS崩溃日志","date":"2016-10-17T04:18:26.000Z","path":"wiki/IOS基础知识/crash/Analize_Crash/","text":"由于代码的缺陷，我们千辛万苦发布发布出去的APP，在用户手中，偶尔会出现Crash现象。为了及时查找到Crash的原因，我们需要收集这些Crash信息。本文就是从分析系统Crash日志开始，一直到定制个性化的Crash日志收集系统，一步步的说明如何完成Crash日志收集系统。千里之行，始于足下，我们先从系统Crash日志开始。 系统Crash日志结构分析系统的Crash日志相信大家都见过，但不一定都认真分析过，所以我想，有必要重新对它做个认识。先贴出一张Crash日志截图，方便大家认识我啊~~~。 Crash日志内容非常，截图只能展示一部分内容，后续会依次贴出每个模块的内容，分别讲解。一个Crash日志由六部分组成：基本信息模块、系统信息模块、异常信息模块、线程回溯、CUP寄存器信息、镜像信息。 基本信息模块///崩溃报告的唯一标识符，标识不同的Crash Incident Identifier: 2964A813-5C6B-4E43-B7FD-40965E97F720 CrashReporter Key: d280e6d8a2446a3c34436cf9d1c6e98448d0c5ca ///代表发生Crash的设备类型 Hardware Model: iPhone7,1 ///Crash的APP名称、APP进程id Process: Simple-Example [2279] ///Crash的APP在设备上的存储路径 Path: /private/var/containers/Bundle/Application/A86C469E-5A97-4948-8BBF-98C0B814088E/Simple-Example.app/Simple-Example ///APP 的描述符 Identifier: com.gome.gomeEShop ///APP的版本 Version: 1.0 (1.0) ///代码的构架，可以通过file命名查看代码的编译构架， ///了解更过的构架信息可以到IOS SDK路径下的/usr/include/mach/machine.h文件中查找 Code Type: ARM-64 (Native) Role: Foreground ///父进程 Parent Process: launchd [1] Coalition: com.gome.gomeEShop [1008] 系统信息模块系统信息模块包含Crash时间、 APP启动时间、OS 版本信息、Crash日志的格式 ///Crash发生的时间 Date/Time: 2016-10-17 16:11:43.7670 +0800 ///Crash的APP的启动时间 Launch Time: 2016-10-17 16:11:40.0612 +0800 ///系统版本，（）内的数字代表的是Bulid号 OS Version: iPhone OS 10.0.2 (14A456) Crash日志的格式，一般为104 Report Version: 104 异常信息模块异常信息模块包含异常类型（Mach异常、Unix信号异常）、异常子类型、异常原因、异常线程ID。 ///异常类型 Exception Type: EXC_BAD_ACCESS (SIGSEGV) ///异常子类型、异常的地址 Exception Subtype: KERN_INVALID_ADDRESS at 0xffffffffffffffff Termination Signal: Segmentation fault: 11 ///异常原因（非常重要） Termination Reason: Namespace SIGNAL, Code 0xb Terminating Process: exc handler [0] ///发生异常的线程ID Triggered by Thread: 0 异常类型(Exception Type)由两部分构成：Mach异常、Unix信号异常。 苹果系统有一个微内核，叫做XNU，它的源码可以在opensource上载到。Mach是XNU的核心，因而，Mach异常就指Mach内核异常。Mach包含三部分内容：thread，task，host。后续的章节中很多地方都会用到Mach。不妨移步到Mach IPC Interface，了解下Mach暴露给用户的API。 Mach暴露给了用户部分API，允许用户和内核交互。用户态的开发者可以通过Mach API设置thread、task、host的异常端口，来捕获Mach异常，抓取Crash事件。 Mach异常包括： #define EXC_BAD_ACCESS 1 /* Could not access memory */ /* Code contains kern_return_t describing error. */ /* Subcode contains bad memory address. */ #define EXC_BAD_INSTRUCTION 2 /* Instruction failed */ /* Illegal or undefined instruction or operand */ #define EXC_ARITHMETIC 3 /* Arithmetic exception */ /* Exact nature of exception is in code field */ #define EXC_EMULATION 4 /* Emulation instruction */ /* Emulation support instruction encountered */ /* Details in code and subcode fields */ #define EXC_SOFTWARE 5 /* Software generated exception */ /* Exact exception is in code field. */ /* Codes 0 - 0xFFFF reserved to hardware */ /* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */ #define EXC_BREAKPOINT 6 /* Trace, breakpoint, etc. */ /* Details in code field. */ #define EXC_SYSCALL 7 /* System calls. */ #define EXC_MACH_SYSCALL 8 /* Mach system calls. */ #define EXC_RPC_ALERT 9 /* RPC alert */ #define EXC_CRASH 10 /* Abnormal process exit */ #define EXC_RESOURCE 11 /* Hit resource consumption limit */ Unix信号：信号是通知进程已发生某种情况的软中断技术。例如：某个进程执行了除法操作，其除数为0，则将名为SIGFPE（浮点异常）的信号发送给该进程。 那么，怎么会有两种异常信息呢？ 念茜的漫谈iOS Crash收集框架阐述了两者的关系，我这里再重复下。 苹果系统是基于Unix系统的，苹果的大牛们为了兼容Unix信号，将Mach异常转化为Unix信号，并投射到异常的线程，这样做的目的是：对于不懂Mach异常的人，也可以使用Unix信号捕获异常。所以，Crash日志有两种异常信息。 Mach和Unix关系图：所有Mach异常都在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。 捕获Mach异常或者Unix信号都可以抓到crash事件，这两种方式哪个更好呢？优选Mach异常，因为Mach异常的处理会先于Unix信号处理，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。 所以，Crash日志中的EXC_BAD_ACCESS 是Mach异常信息，SIGSEGV是Unix信号异常信息。 小贴士:因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用kill和pthread_kill)也首先沉下来被转换为Mach异常，再转换为Unix信号。 线程回溯符号化回溯线程线程的回溯是APP Crash瞬间，程序中所有线程的逆向调用堆栈。线程回溯对我们修复Crash非常非常的有用，根据线程回溯，可以分析、定位程序崩溃的原因。 下面将崩溃的代码、未符号化崩溃日志、符号化崩溃日志贴出来，做个对比性的理解。 @implementation ViewController - (IBAction) onCrash:(__unused id) sender { char* ptr = (char*)-1; *ptr = 10; ///这里程序崩溃了 } @end 未符号化的崩溃日志（图5）符号化的崩溃日志（图6） 图5中红色文字展示了几个名词：镜像文件、加载地址、堆栈地址。还有没有展示出来的一个名词：符号在二进制中的偏移量。他们的含义分别为： 镜像文件：是可执行二进制文件和二进制文件依赖的动态库的总称。堆栈地址：是代码在内存中执行的内存地址。镜像的加载地址：程序执行时，内核会将包含程序代码的镜像加载到内存中，镜像在内存中的基地址就是加载地址。程序每次启动时，镜像的加载地址是随机的。所以，同一代码在不同的设备中执行时，堆栈地址是不一样的。符号在二进制中的偏移量：按照字面意思理解吧。它以通过下面的公式得到： 符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址 符号在二进制中的偏移量非常有用，我们就是根据它，从符号文件中查找出地址对应的代码符号。这里的符号文件指的是：带有符号表的可执行二进制文件、dSYM文件，这两种文件在后续章节中都统称为符号文件。 那么怎么将图5中的Crash日志符号化为图6中的形式呢？ 苹果自带的atos命令行工具可以查找地址对应的符号，在终端中输入： /usr/bin/atos -o [符号文件] -arch arm64 -l 0x100030000 0x000000010003522c 输出结果如下： -[ViewController onCrash:] (in Simple-Example) (ViewController.m:10) 是不是很简单的就将地址转换为符号？是的，只需将符号文件（-o指定）、代码构架（-arch指定）、加载地址（-l指定）、堆栈地址 传入atos命令，就能解析出符号。 atos命令解析出了堆栈地址为0x000000010003522c、加载地址为0x100030000对应的符号。符号为[ViewController onCrash:]，也验证了崩溃发生在onCrash函数中，也验证了崩溃日志中的地址是可以符号化的。 符号化是简单，但是原理是什么？怎么就通过地址找到了Crash代码的符号，要听详细信息，请看《符号化内幕》。 符号化内幕符号化的内幕就是：在符号文件中，通过偏移量查找符号。下面，一步步的来分析，首先计算Crash地址在符号文件中的偏移量，为000000010000522c。 符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址 = 0x000000010003522c - 0x100030000 = 000000010000522c 在符号文件中直接找地址000000010000522c，应该是找不到，在后续你可以理解。我们使用逆向方法，根据符号-[ViewController onCrash:]，找对应的地址，比较是不是000000010000522c，如果是，就充分说明了，通过偏移量是可以查找到内存地址对应的符号的。在终端中输入下面的命令： nm [符号文件] | grep &quot;ViewController onCrash:&quot; 输出如下 00008320 t -[ViewController onCrash:] 0000000100005224 t -[ViewController onCrash:] 输出的第一行是armv7s构架的符号，第二行是arm64构架的符号，Crash日志显示的代码构架是arm64，使用第二行，符号-[ViewController onCrash:]对应的偏移量是0000000100005224，而不是 000000010000522c，是我给你埋了个坑吗？专门来坑你的？不是的，不是的，这个问题也困扰了我N久、折磨了我N久。这个公式是在stack overflow上找到的，我也怀疑他们骗了我，但是，仔细看两个地址，又那么的相似、那么的相近—就相差8！！！ 虽说相差8，但毕竟不一样。差之毫厘谬以千里啊。感觉就要成功，但就是不对。就永远差了那么一点点，试了好多崩溃日志，都是差那么一点点，相信你也体会过这种感觉，只差一点点，真的只差一点点。就差那么该死的一点点，问题就能解决。百思不得其姐的困扰、抓狂的困扰 。。好久好久我都没想明白，那一点点是怎么差的。这不，今天写日志组织测试用例的时候，忽然明白了为什么差那一点点，踏破铁鞋无觅处，得来全不费功夫！！。原来，我们通过nm命令查找出的符号地址对，是函数入口地址和对应的函数调用的符号对，仅仅是函数调用的符号，没有函数内部代码的符号，而程序是崩溃到函数内部，崩溃到ptr = 10这句话，内部代码的地址怎么可能和入口地址一样呢！相差一点点！下面根据偏移量000000010000522c和代码推算函数的入口地址吧，看看是什么。崩溃代码ptr = 10前面只有一个语句—定义初始化指针“char ptr = (char)-1”，在64位系统上指针的地址占8个字节，000000010000522c - 8= 0000000100005224， 果然是0000000100005224。这个不就是函数的入口地址嘛，对，就是。原来那一点点的原因在这里。 那么偏移量0000000100005224 对应的符号正是-[ViewController onCrash:]。 上面通过nm 命令查找符号可能不直观，可以通过可视化工具MachOView查看。验证下吧，选择 Debug Symbols（ARM64_ALL）-&gt;Symbol Table-&gt;Symbols,然后在右上角的搜索框中输入符号：-[ViewController onCrash:]，结果如下，通过这个工具可以直观的查看到符号和地址的对应关系。 小小结ok，终于可以歇一歇了，我们终于把符号化和符号化原理阐述完了。简单的回顾下： 可以通过系统的atos符号化崩溃日志的单个符号 符号化内部原理就是：根据符号在二进制中的偏移量，在符号文件中查找对应的符号。其中：符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址。 线程的状态寄存器Thread 0 crashed with ARM Thread State (64-bit): x0: 0x000000010050b460 x1: 0x0000000100102cea x2: 0x00000001004339d0 x3: 0x00000001740f8f00 x4: 0x00000001740f8f00 x5: 0x00000001740f8f00 x6: 0x0000000000000001 x7: 0x0000000000000000 x8: 0xffffffffffffffff x9: 0x000000000000000a x10: 0x00000001b3ad0018 x11: 0x00c1580100c15880 x12: 0x0000000000c15800 x13: 0x0000000000c15900 x14: 0x0000000000c158c0 x15: 0x0000000000c15801 x16: 0x0000000000000000 x17: 0x00000001000c1224 x18: 0x0000000000000000 x19: 0x00000001740f8f00 x20: 0x00000001004339d0 x21: 0x0000000100102cea x22: 0x000000010050b460 x23: 0x0000000170240bd0 x24: 0x000000017400db90 x25: 0x0000000000000001 x26: 0x0000000000000000 x27: 0x00000001b2822000 x28: 0x0000000000000040 fp: 0x000000016fd41ab0 lr: 0x0000000194aea7b0 sp: 0x000000016fd41a90 pc: 0x00000001000c122c cpsr: 0x60000000 这是APP crash的时候，ARM64 构架CPU的32个寄存器的值， 其中fp 帧指针、sp堆栈指针，lr 是返回地址指针，这三个都比较有用，用来逐级回溯线程调用栈。 Binary Images图8 镜像文件就是上面讲的可执行程序 和 依赖的所有动态库。镜像文件中包括镜像的加载地址，和线程回溯中的镜像加载地址指的是一个地址。加载地址后面有个UUID，符号文件中也有个UUID，只有这两个地址一致，才能解析出地址对应的符号。符号文件中的UUID可以通过终端中输入下面的命令得到： dwarfdump —u [符号文件] 输出如下： UUID: C8E0E6E4-F761-3A19-B231-A31C1BB9037A (armv7) UUID: 39BBB8F4-CCB0-3193-8491-C007931CA05E (arm64) 第二行的arm64构架的UUID居然和图8中的红色矩形框中UUID惊人的一致。是的。必须得一致，这才表示代码对应的符号能在这个符号文件中找到，如果不一致，就没法解析出地址对应的符号。不论是Xcode，还是symbolicatecrash，都解析不了。也可以通过MachOView查看符号文件的UUID，结果如下： 小结这节阐述了崩溃日志的组成结构、通过atos命令行工具符号化崩溃日志以及符号化崩溃日志的原理。同时提及了几个工具有用的工具： file,文件类型显示工具（The file-type displaying tool，位于/usr/bin/file）; atos,(将数字地址转换为镜像或可执行程序中的符号工具，convert numeric addresses to symbols of binary images or processes，位于/usr/bin/atos); nm，（符号表展示工具，The symbol table display tool,位于 /usr/bin/nm）; 可视化查看Mach-O工具，MachOView。 系统收集、符号化Crash日志系统如何收集、符号化Crash日志有多种方式，主要有如下几种方式： CrashReporter收集、Xocde或symbolicatecrash符号化。当iOS系统上的某个 APP崩溃时，IOS系统自带的CrashReporter会创建一份crash日志保存在设备上。如果能拿到Crash的手机，就可以通过Xcode或symbolicatecrash符号化Crash日志。 第三方SDK。如友盟，鹅厂的Bugly 等等 Crash 打造自己的收集、符号化程序。主要方法：使用NSSetUncaughtExceptionHandler注册异常处理函数，当APP 发生Crash时刻，回调到异常处理函数，在异常处理函数中收集Crash信息，然后上传到服务器；当需要分析的时候，从服务器取回Crash日志，如果没有符号化，使用atos命令符号化。 开源框架KSCrash。如果上面的几种收集、符号化的方式依然不能满足你的需求，那么完备的KSCrash框架应该是一个不错的选择。 这章只阐述第一种方式，后续的第三章、第四章分别阐述第三、四种方式。 CrashReporter收集日志CrashReporter 是IOS自带的工具，当APP发生崩溃时，CrashReporter会创建一份Crash日志并保存到设备上。上一章阐述的Crash日志，就是出自CrashReporter之手。 可以使用Xcode、iTool导出CrashReporter创建的日志。其中：Xcode导出Crash日志的方法如下：在Xcode-&gt;Window菜单-&gt;Devices，弹出的设备面板，选择崩溃的设备 -&gt; 选择右侧的View Device Logs-&gt;选中导出的日志，右击，选中export log, 导出.crash后缀的崩溃日志 Xcode 解析Crash日志Xcode可以将日志中的地址信息符号化为代码中的符号，但有个前提条件：crash log和dSYM或APP携带的UUID一致。crash log携带的UUID指的是镜像的UUID。这两种UUID在《1.6 Binary Images 》 已经阐明。 如果APP是自己电脑编译生成的，Xcode会根据spotlight自动找到对应的符号文件 如果不是自己电脑编译生成的，只需要将.app和dSYM放入同一文件夹，然后手动生成索引，这样Xcode也能找到。在命令行中输入如下命令手动创建索引： mdimport pathName mdimport ,导入文件到datastore（import file hierarchies into the metadata datastore）。上面两种方式确保了Xcode能依据UUID找到地址对应的符号文件，这样，Xcode就能解析出崩溃日志。 使用Xcode解析崩溃日志的方法：在Xcode-&gt;Devices-&gt;View Device Logs中，查看设备的所有崩溃日志，如果能解析，Xcode会自动解析崩溃日志。这种方式可以实现批量解析崩溃日志Xcode解析崩溃日志的优势： 批量解析，可以一次解析出所有可解析的Crash日志。 稳定性比symbolicatecrash好。网上说symbolicatecrash经常出现解析不出来，解析出错的问题。但是我没有遇到过。 那些年我们一起使用的符号化工具你是不是也在网上搜过“IOS崩溃解析”？网上有好多的文章都讲symbolicatecrash工具。symbolicatecrash，按照字面意思理解，就是符号化异常工具。symbolicatecrash符号化日志的一般步骤为： 查找symbolicatecrash的存储位置，symbolicatecrash在各个Xcode版本中的位置都不一样，我没有办法记住每个版本的位置，所以使用查找命令查找symbolicatecrash 的位置 find /Applications/Xcode.app -name symbolicatecrash -type f #查找symbolicatecrash 的路径。 输出如下: AAA$ find /Applications/Xcode.app -name symbolicatecrash -type f /Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 将符号文件、Crash日志、symbolicatecrash放在同一目录下。cd 到该目录下，终端执行命令： ./symbolicatecrash name.crash 符号文件 &gt; out.txt 如果成功，会将符号化的日志重定向到out.txt中。 备注： 如果执行中遇到下面的错误： Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 60. 执行下面的命令，设置环境变量 export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 打造自己的收集、符号化程序当APP发布到AppStore后，如果发生了Crash，通常情况下我们拿不到崩溃手机，也就是说拿不到Crash日志。这是一个棘手的问题。有人说可以在开发者中心找到用户上传到苹果的日志，但是，不是所有的用户都会在程序Crash后上传Crash日志，所以有必要打造一个属于我们自己的异常收集系统。下面就讲讲我打造的异常收集系统，主要思路：使用NSSetUncaughtExceptionHandler注册异常处理函数，当APP 发生Crash时，回调到异常处理函数，在异常处理函数中收集Crash信息，然后上传到服务器；当需要分析的时候，从服务器取回Crash日志，如果没有符号化，使用atos命令符号化。由于我没有服务器，就保存到了沙盒路径的Document目录下，可以使用itunes方便的导出日志。这里我提供了一个简单示例代码：caughtException，有代码才有真相，才有说服力。那就先从代码入手。 实现代码这里会分别列出关键的代码。下面是 AppDelegate.m中的代码 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [LJCaughtException setDefaultHandler]; // Override point for customization after application launch. return YES; } 在application:didFinishLaunchingWithOptions:中注册异常处理函数，所有的异常注册和异常处理函数的代码都封装到LJCaughtException.m中，如下： ///先前注册的处理句柄 NSUncaughtExceptionHandler *preHander; /// 异常处理函数 void UncaughtExceptionHandler(NSException * exception) { [LJCaughtException processException:exception]; } @implementation LJCaughtException + (void)setDefaultHandler { ///首先保存先前注册的异常处理句柄 preHander = [LJCaughtException getHandler]; ///注册异常处理句柄 NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler); } + (NSUncaughtExceptionHandler *)getHandler { return NSGetUncaughtExceptionHandler(); } ///异常处理句柄 + (void)processException:(NSException *)exception { /// 异常的堆栈信息 NSArray *aryCrashBackTrace = [exception callStackSymbols]; if (!aryCrashBackTrace) { return; } /// 出现异常的原因 NSString *strCrashReason = [exception reason]; /// 异常名称 NSString *strCrashName = [exception name]; .... } ... @end 上面代码可以分解为三个部分理解： 定义异常处理函数：异常处理函数的原型为： typedef void NSUncaughtExceptionHandler(NSException *exception); 注册异常处理函数：使用NSSetUncaughtExceptionHandler注册异常处理函数,注册的代码为：NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler); 执行异常处理函数：当异常发生时，自动执行异常处理函数。异常处理函数内部完成收集Crash信息的功能。 下面是在Debug和Release模式下，Crash时捕获的线程回溯： 可以看出，使用系统的API可以完美的捕获到崩溃日志，而且符号化了，一行代码（callStackSymbols）就获取了异常线程的回溯并完成了符号化工作，不费吹灰之力。其实，事情没有这么简单，不妨试试发布包，是不是也能像在debug和release模式那样，获取到符号化的异常线程回溯？ 发布包没带符号表将测试程序打为发布包，查看异常线程回溯图，如下：图11 发布包的Crash日志 是不是很奇怪，图中红框是异常线程的关键回溯，显示的是镜像的名字，没有被转化为有效的代码符号。这是为什么？ 静静的想想。。。。。。前面提到符号化的前提条件，是得有符号表，那么我们推测debug和release的APP包含了符号表，而发布包没有包含符号表，是不是？ 请在终端中使用nm命令验证下。 确实是，发布包没有符号表，为什么？ 原来，符号表是一个debug产物，如果使用archive模式打包，那么符号表会被剪裁掉。不过你也可以在Xcode的编译选项中配置为符号表不剪裁。方法是设置Strip Style选项为Debugging Symbols，但是会让最后生成的IPA变大约%5。我用我们项目测试，居然大了约%30，可能是代码太多的原因吧。这个对于严格限制APP大小的人来说，是无法接受的。下图是设置发布包带符号表的方法： 天无绝人之路，在使用archive打包时，生成了一个dSYM符号文件，这个文件不发布，在本地保存着。这个文件太有用了，也是我们符号化的唯一选择了。 显然，对于发布到用户手中的发布包，在程序Crash后，不能在用户设备上完成符号化工作，callStackSymbols只能返回带地址的日志信息，需要我们线下符号化，还好苹果提供了一个命令行工具—–atos，完成符号化工作。 若想通过atos工具在符号文件中查找到地址对应的符号，需要代码构架、镜像加载地址这两个参数，查看图11，这两个参数都没有，怎么办？我只能祭出OS X ABI Mach-O File Format Reference和KSCrash 开源框架这两个终极神器。OS X ABI Mach-O File Format Reference阐述了可执行二进制程序的存储格式，提供原理性的支撑。KSCrash包含了获取代码构架和镜像加载地址的代码。依据这两个神器，我们可以顺利的拿到代码构架、镜像加载地址。其中《OS X ABI Mach-O File Format Reference》居然在苹果的官网上找不到了，前段时间都能找到的，幸好我又一个备份，我只能放在七牛上保存起来了。 Mach-O File FormatMach-O 是Mach object 的意思，就是OS X系统中对象文件的存储格式，对象文件包括： kernel extensions, command-line tools, applications, frameworks, and libraries (shared and static)。 详细的也可以参考Mach-O Programming Topics 一个Mach-O 文件包括下面三个部分 Header: Specifies the target architecture of the file, such as PPC, PPC64, IA-32, or x86-64. Load commands: Specify the logical structure of the file and the layout of the file in virtual memory. Raw segment data: Contains raw data for the segments defined in the load commands. 下面是官网上的一张图形化的Mach-O结构示意图： 下面依次讲解这三部分，他们的数据结构定义在mach-o/loader.h中。我会通过三种方式来层显Mach-O文件结构：代码定义、通过命令行工具otool呈现、通过MachOView呈现。其中otool是系统自带的对象文件查看工具。MachOView 是网上下载的可视化查看Mach-O结构工具。由于存在两个代码构架，armv7s、ARM64，他们的定义稍微有点区别，我仅以ARM64构架为例。 headerheader的数据结构的定义如下： struct mach_header_64 { uint32_t magic; ///魔数，标记这个是Mach-O文件 cpu_type_t cputype; ///cup 的类型 cpu_subtype_t cpusubtype; uint32_t filetype; uint32_t ncmds; /// load commands 个数 uint32_t sizeofcmds; uint32_t flags; uint32_t reserved; }; 终端中查看header： otool -hV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出如下： magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 23 2432 NOUNDEFS DYLDLINK TWOLEVEL PIE Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 23 2872 NOUNDEFS DYLDLINK TWOLEVEL PIE MachOView显示的结果： magic 是MH_MAGIC_64，固定值：0xfeedfacf，标记这是一个Mach-O文件。filetype 文件类型是EXECUTE，可执行程序，ncmds，load commond个数是23个 load Commond load Commond 种类特别多，大概有60多种，每种commond的数据结构是不同的， 我不会去一一的说明，只拿LC_SEGMENT、LC_SYMTAB 做个示例。下面列表了部分load commond。 #define LC_SEGMENT 0x1 /* segment of this file to be mapped */ #define LC_SYMTAB 0x2 /* link-edit stab symbol table info */ #define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */ #define LC_THREAD 0x4 /* thread */ #define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */ #define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */ ..... LC_SEGMENTLC_SEGMENT ,segment load command indicates that a part of this file is to be mapped into a 64-bit task’s address space,说白了，就是映射到内存中的所有数据，自然包括代码、数据等等。segment进一步可以分为 PAGEZERO、TEXT、DATA、 OBJC、IMPORT、LINKEDIT。PAGEZERO 类型的segment是可执行程序的第一个segment，代表指针地址NULL。TEXT就是可执行代码，当然是只读了。DATA 是可写的数据segement，应该就是代码中的变量区域。OBJC 是Objective-C runtime support library。 The __LINKEDIT segment contains raw data used by the dynamic linker, such as symbol, string, and relocation table entries。 每种segement可能包含多种类型的内容，例如TEXT代码段，可以有代码（text）、字符串（cstring） 、常量（const）、符号（symbol_stub）、字面量（literal4、__literal8），所以进一步用二级目录（section）表示。下面是segment、section的数据结构： struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */ }; struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */ }; 终端输入： otool -lV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： ........ cmd LC_SEGMENT_64 cmdsize 712 segname __TEXT vmaddr 0x0000000100000000 vmsize 0x0000000000008000 fileoff 0 filesize 32768 maxprot r-x initprot r-x nsects 8 flags (none) ....... MachOView显示的结果：图中直观的显示出了LC_SEGMENT的数据 、LC_SEGMENT的二级目录section的数据。 LC_SYMTABLC_SYMTAB的数据结构如下： struct symtab_command { uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; /* symbol table offset */ uint32_t nsyms; /* number of symbol table entries */ uint32_t stroff; /* string table offset */ uint32_t strsize; /* string table size in bytes */ }; 终端输出的结果: Load command 6 cmd LC_SYMTAB cmdsize 24 symoff 132944 nsyms 48 stroff 133916 strsize 1152 MachOView看到的结果： LC_SYMTAB 指定了符号的个数和相对Mach-O的偏移量。 数据部分紧跟着load commond 后面的是数据部分，就是各个load commond 对应的具体数据。 小小结我觉得Mach-O文件的格式非常像 一篇文章的结构，Header部分是文章的摘要，总体描述了非常重要部分。Load commands 相当于目录，Mach-O文件所有内容的索引。Raw segment data 正文内容。 Mach-O 文件格式就是一个规范，各个部分都有自己的数据格式，内容繁多，只能多看。不过提到了一个有用的工具—otool，查看Mach-O对象文件的命令行工具。 获取构架、镜像加载地址好了，上面说了那么多Mach-O文件结构，主要是提供原理支撑，目的是通过对Mach-O文件结构的理解，找到获取构架、镜像加载地址的方法。构架很好获取，就在Mach-O的文件头中，获取的关键代码如下 ： /* 获取代码的构架 */ NSString * getCodeArch() { NSString *strSystemArch =nil; ///获取应用程序的名称 NSDictionary *dicInfo = [[NSBundle mainBundle] infoDictionary]; if (LJM_Dic_Not_Valid(dicInfo)) { return strSystemArch; } NSString *strAppName = dicInfo[@&quot;CFBundleName&quot;]; if (!strAppName) { return strSystemArch; } ///获取 cpu 的大小版本号 uint32_t count = _dyld_image_count(); cpu_type_t cpuType = -1; cpu_type_t cpuSubType =-1; for(uint32_t iImg = 0; iImg &lt; count; iImg++) { const char* szName = _dyld_get_image_name(iImg); if (strstr(szName, strAppName.UTF8String) != NULL) { const struct mach_header* machHeader = _dyld_get_image_header(iImg); cpuType = machHeader-&gt;cputype; cpuSubType = machHeader-&gt;cpusubtype; break; } } if(cpuType &lt; 0 || cpuSubType &lt;0) { return strSystemArch; } ///转化cpu 版本为文字类型 switch(cpuType) { case CPU_TYPE_ARM: { strSystemArch = @&quot;arm&quot;; switch (cpuSubType) { case CPU_SUBTYPE_ARM_V6: strSystemArch = @&quot;armv6&quot;; break; case CPU_SUBTYPE_ARM_V7: strSystemArch = @&quot;armv7&quot;; break; case CPU_SUBTYPE_ARM_V7F: strSystemArch = @&quot;armv7f&quot;; break; case CPU_SUBTYPE_ARM_V7K: strSystemArch = @&quot;armv7k&quot;; break; #ifdef CPU_SUBTYPE_ARM_V7S case CPU_SUBTYPE_ARM_V7S: strSystemArch = @&quot;armv7s&quot;; break; #endif } break; } #ifdef CPU_TYPE_ARM64 case CPU_TYPE_ARM64: strSystemArch = @&quot;arm64&quot;; break; #endif case CPU_TYPE_X86: strSystemArch = @&quot;i386&quot;; break; case CPU_TYPE_X86_64: strSystemArch = @&quot;x86_64&quot;; break; } return strSystemArch; } 主要思路是：通过_dyld_image_count 获取到所有的镜像个数，然后根据镜像索引（0…镜像个数-1），依次枚举出镜像的名字，然后，镜像名字使用_dyld_get_image_header函数获取到镜像的header结构体信息，赋值到：mach_header* machHeader中。最后，通过machHeader-&gt;cputype（ CPU的类型）和machHeader-&gt;cpusubtype（CPU的子类型）转化为具体的代码构架。 对于镜像的加载地址，其实就是镜像的header结构体的首地址。详细代码如下 /* 获取应用程序的加载地址 */ NSString * getImageLoadAddress() { NSString *strLoadAddress =nil; NSString * strAppName = getAppName(); if (!strAppName) { return strLoadAddress; } ///获取应用程序的load address uint32_t count = _dyld_image_count(); for(uint32_t iImg = 0; iImg &lt; count; iImg++) { const char* szName = _dyld_get_image_name(iImg); if (strstr(szName, strAppName.UTF8String) != NULL) { const struct mach_header* header = _dyld_get_image_header(iImg); strLoadAddress = [NSString stringWithFormat:@&quot;0x%lX&quot;,(uintptr_t)header]; break; } } return strLoadAddress; } 主要思路就是：利用_dyld_get_image_header获取镜像的header结构体，header结构体是整个Mach-O的起始部分，所以，header结构体的首地址就是镜像的加载地址。 好了，到目前为止，使用atos符号化崩溃日志的三个条件条件（符号文件、代码构架、镜像加载地址）都有了，那么我们就可以完成异常地址的符号化工作了。所以，到目前为止，我们定制的异常系统基本完成了，收集功能、符号化动能都有了。下面来看看我们的系统输出的内容。 输出Crash日志本崩溃收集系统的输出格式使用json格式，输出的信息包括arch、CrashName、CrashReason、CrashBackTrace、CrashSystemVerson 。有了这些信息，我们完全可以符号化崩溃地址了。 { &quot;strCrashArch&quot; : &quot;arm64&quot;, ///代码构架 &quot;strCrashName&quot; : &quot;NSRangeException&quot;, &quot;strCrashSystemVersion&quot; : &quot;10.0.2&quot;, &quot;strCrashReason&quot; : &quot;*** -[__NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]&quot;, &quot;aryCrashBackTrace&quot; : [ { &quot;strStackAddress&quot; : &quot;0x000000018ec6c1d8&quot;, &quot;strImageName&quot; : &quot;CoreFoundation&quot;, &quot;strImageLoadAddress&quot; : &quot;&lt;redacted&gt;&quot; }, { &quot;strStackAddress&quot; : &quot;0x000000018d6a455c&quot;, &quot;strImageName&quot; : &quot;libobjc.A.dylib&quot;, &quot;strImageLoadAddress&quot; : &quot;objc_exception_throw&quot; }, { &quot;strStackAddress&quot; : &quot;0x000000018eb48584&quot;, &quot;strImageName&quot; : &quot;CoreFoundation&quot;, &quot;strImageLoadAddress&quot; : &quot;CFRunLoopRemoveTimer&quot; }, { &quot;strStackAddress&quot; : &quot;0x00000001000b48a0&quot;, ///崩溃地址 &quot;strImageName&quot; : &quot;UncaughtException&quot;, &quot;strImageLoadAddress&quot; : &quot;0x1000B0000&quot; ///镜像加载地址 }, { &quot;strStackAddress&quot; : &quot;0x0000000194aea7b0&quot;, &quot;strImageName&quot; : &quot;UIKit&quot;, &quot;strImageLoadAddress&quot; : &quot;&lt;redacted&gt;&quot; }, ........ ........ { &quot;strStackAddress&quot; : &quot;0x0000000194b1b360&quot;, &quot;strImageName&quot; : &quot;UIKit&quot;, &quot;strImageLoadAddress&quot; : &quot;UIApplicationMain&quot; }, { &quot;strStackAddress&quot; : &quot;0x00000001000b4df0&quot;, &quot;strImageName&quot; : &quot;UncaughtException&quot;, &quot;strImageLoadAddress&quot; : &quot;0x1000B0000&quot; }, { &quot;strStackAddress&quot; : &quot;0x000000018db285b8&quot;, &quot;strImageName&quot; : &quot;libdyld.dylib&quot;, &quot;strImageLoadAddress&quot; : &quot;&lt;redacted&gt;&quot; } ] } 小结这章，我们使用苹果的API完成了Crash日志收集系统，这个系统输出的日志可以使用atos在线下符号化。同时介绍了Mach-O的文件结构。 你被默默的坑了吗通常一个大型的APP总是会引用第三方的SDK，第三方SDK也会集成一个Crash收集服务，以及时发现他们SDK的问题。当多个收集服务集成到一个APP中时，难免出现时序问题，强行覆盖等等的恶意竞争，总会有人默默被坑。所以NSSetUncaughtExceptionHandler设置自己的异常处理函数前，要保存先前的异常处理函数。当我们的异常处理函数执行完，将先前的异常处理函数注册回去。这样才能保证多个异常收集系统能有序工作。 深度定制异常收集系统我们上面定制的系统非常简单，功能单一。只能捕获到Object C异常。不能满足实际项目的需求，所以有必要找一个功能完善的异常收集框架，经过筛选，KSCrash是个不错的选择。 KSCrash 是一个异常收集的开源框架。它可以捕获到Mach级内核异常、信号异常、C++异常、Objective-C异常、主线程死锁；当捕获到异常后，KSCrash可以在设备上完成符号化崩溃日志(前提是编译的时候将符号表编译到可执行程序中)；日志的格式你也可以定制，可以是JSON格式的，也可以是Apple crash日志风格。另外，还有僵尸对象查找、内存自省等特性。 由于这篇文章罗列的内容太多，废话太多，所有移到《KSCrash崩溃原理浅析》 中单独阐述。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/categories/Crash/"}]},{"title":"KSCrash崩溃收集原理浅析","date":"2016-07-17T04:18:26.000Z","path":"wiki/IOS基础知识/crash/KSCrash_Analize/","text":"KSCrash 是一个异常收集的开源框架。它可以捕获到Mach级内核异常、信号异常、C++异常、Objective-C异常、主线程死锁；当捕获到异常后，KSCrash可以在设备上完成符号化崩溃日志(前提是编译的时候将符号表编译到可执行程序中)；日志的格式你也可以定制，可以是JSON格式的，也可以是Apple crash日志风格。另外，还有僵尸对象查找、内存自省等特性。 目前异常收集的框架非常多，有集成了收集、统计功能的一条龙产品，如，友盟，鹅厂的Bugly 等等；也有几个开源框架，如，KSCrash，plcrashreporter，CrashKit。基于我们项目的安全性考虑，即，不希望第三方SDK看到崩溃日志，我选取了开源框架这条路。纵览这几个开源框架，只有KSCrash一直在更新。所以，毫不犹豫的选用了它。 APP Crash后，获取崩溃线程的程调用堆栈的过程，是程序执行过程的逆向过程。那么，了解APP的执行正向过程，对获取崩溃线程的调用堆栈是非常非常有益的。所以，在分析KSCrash原理前，依照APP正向执行过程先推导下 异常收集、符号化的原理。 推导异常收集、符号化的原理本节描述的内容只是按照自己的理解编写的，由于道行尚浅，理解不深，所以具体安排的内容不一定合理。依据APP执行的过程，主要囊括了：编译生成可执行APP、内核加载并启动APP、调用堆栈等，并穿插了一点理解KSCrash的必备知识。 编译生成可执行APP开发者通过IDE集成开发环境（例如Xcode），将源码文件转化为临时中间文件（这种文件应该是机器语言了），然后使用链接器（/usr/bin/ld）将临时的对象文件（object file）合并为可执行文件。不过上面的编译、链接步骤都集成到Xcode中了。我们在Xcode中编译的时候，体会不到这个过程。在苹果系统中，可执行APP的存储格式是Mach-O格式。所以我们先了解下Mach-O文件格式。 Mach-O文件存储格式Mach-O (Mach object的缩写) 是苹果系统上存储可执行程序和库（libraries）的标准格式。它是BSD系统中.a文件格式的替代物，它封装着程序的可执行代码和数据。可以参考《OS X ABI Mach-O File Format Reference》官方文档。这个文档在官网打不来了，我就链接到我自己的pdf地址了。 概述Mach-O文件包括三个组成部分，分别如下： header：指定了文件的基本信息，如CUP类型、加载命令个数等。 Load commands：加载命令，指定了文件的逻辑结构、在虚拟内存（virtual memory）中文件的布局。你可以理解为一片文章的目录。 Raw segment data：数据部分。 这个是官网上的结构示意图。 headerMach-O文件的开头部分是就是Header—文件头。Header的数据结构定义在XNU微内核的loader.h文件中。loader.h也可以在IOS SDK的/usr/include/mach-o目录下找到，header的数据结构定义如下： 12345678910struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;; 可以看出包括了 ：魔数、cup的类型、子类型、文件的类型、load commend个数、load commend大小等数据。 load commend紧跟在Header后面的是load commend。load commend指定了文件的布局。具体指定了以下内容： • The initial layout of the file in virtual memory 文件在虚拟内存中的初始布局 • The location of the symbol table (used for dynamic linking) 符号表的位置 • The initial execution state of the main thread of the program 程序主线程的入口地址 • The names of shared libraries that contain definitions for the main executable’s imported symbols 主执行文件依赖的分享库 load commend 的种类非常多，loader.h 中的定义了各种所有的类型。我们仅以LC_SEGMENT、LC_SYMTAB（符号表）为例了解load commend。每种类型的load commend都有对应的数据结构，可以在loader.h文件中查看。下面是部分类型Load Commond： #define LC_SEGMENT 0x1 ///代码段 #define LC_SYMTAB 0x2 /// 符号表 #define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */ #define LC_THREAD 0x4 /* thread */ #define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */ #define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */ #define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */ #define LC_IDENT 0x8 /* object identification info (obsolete) */ #define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */ #define LC_PREPAGE 0xa /* prepage command (internal use) */ #define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */ #define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */ #define LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */ #define LC_LOAD_DYLINKER 0xe /* load a dynamic linker */ #define LC_ID_DYLINKER 0xf /* dynamic linker identification */ #define LC_PREBOUND_DYLIB 0x10 /* modules prebound for a dynamically */ ................... DataData紧跟在Load Commond后面。load commend中定义的各种数据都存储在这部分中。 查看Mach-O实用工具在终端中有几个工具是可以查看Mach-O文件内容的。另外位于usr/include/mach-o/dyld.h中的函数可以在程序中访问Mach-O文件内容。 文件类型展示工具-file。The file-type displaying tool, 位于/usr/bin/file，显示文件的类型，对于多构架的文件，它显示每个构架下的镜像类型。在终端中输入： ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive: Mach-O universal binary with 2 architectures /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture armv7): Mach-O executable arm /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): Mach-O 64-bit executable 对象文件展示工具otool。The object-file displaying tool，位于/usr/bin/otool，显示Mach-O文件的各种数据。查看Mach-O header内容，在终端中输入： otool -hV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 23 2432 NOUNDEFS DYLDLINK TWOLEVEL PIE Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 23 2872 NOUNDEFS DYLDLINK TWOLEVEL PIE 可以使用otool 查看load commend。在终端中输入： otool -lV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedface 12 9 0x00 2 23 2432 0x00200085 Load command 0 cmd LC_SEGMENT cmdsize 56 segname __PAGEZERO vmaddr 0x00000000 vmsize 0x00004000 fileoff 0 filesize 0 maxprot 0x00000000 initprot 0x00000000 nsects 0 flags 0x0 ………. 符号展示工具-nm，The symbol table display tool,位于 /usr/bin/nm, allows you to view the contents of an object file’s symbol table。查看符号表，在终端中输入： nm ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): U _NSGetUncaughtExceptionHandler U _NSLog U _NSSearchPathForDirectoriesInDomains U _NSSetUncaughtExceptionHandler U _NSStringFromClass U _objc_msgSend U _objc_msgSendSuper2 U _objc_release U _objc_retain U _objc_retainAutorelease U _objc_retainAutoreleasedReturnValue U _objc_setProperty_nonatomic_copy U _objc_storeStrong U _strstr U dyld_stub_binder ........... 绑定和执行根据上面分析的可执行文件的结构，我们可以看到，可执行文件中已经包含了符号表 ，这个符号表是可执行代码的虚拟地址和代码中符号的对应表。符号表是绑定过程中建立的，程序的绑定有很多种，可以参看下面的文档：Mach-O Programming Topics - Binding Symbols，里面详细介绍了绑定和查找符号的过程。 看到符号表，那么我们可以做这样的设想：如果程序崩溃，只要我们获取到了崩溃调用堆栈的回溯地址，然后从这个符号表中查找对应的符号，就完成了调用堆栈的符号化工作？ 还有就是我们如何获取程序的调用堆栈呢？还有很多需要我们接着往下看。为了知道如何获取调用堆栈的回溯，我们了解下程序的执行过程： 程序的执行过程：内核首先加载可执行文件，并且检测程序文件的起始部分的mach_header结构，内核验证是否合法的Macj-O文件，解析header中的load commands。加载Load Commond中指定依赖镜像到内存中，然后启动进程，执行程序的入口函数，进入正常的run loop。 调用堆栈首先介绍一下什么叫调用堆栈：假设我们为了完成一个任务1，任务1的完成需要完成任务2…. 分别定义为几个函数：function1,function2,function3,funtion4。即，function1调用function2，function2调用function3，function3调用function4。在function4运行过程中，我们可以从线程当前堆栈中了解到调用他的那几个函数分别是谁。function4、function3、function2、function1呈现出一种“堆栈”的特征，最后被调用的函数出现在最上方。因此称呼这种关系为调用堆栈(call stack)。 下面有一个图展示下： 函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。理解了入栈和出栈，基本能理解调用堆栈，下面两个图，一个是入栈，一个是出栈，图中描述的很清楚。 所以获取到崩溃时线程的ebp和esp 就能回溯到上一个调用，依次类推，回溯出所有的调用堆栈。下面了解下寄存器。 寄存器为了线程获取BP和SP，我们需要了解一点点寄存器。因为他们保存在CPU的寄存器中。arm64构架的寄存器在Procedure Call Standard for the ARM 64-bit Architecture (AArch64)有详细的说明。不过都是英文的，我没有看，我从代码中也找到了它的定义，位于IOS SDK的usr/include/arm目录下的_mcontext.h文件中。其中几个关键的定义的代码我摘录下来了，如下： _STRUCT_MCONTEXT64 { _STRUCT_X86_EXCEPTION_STATE64 __es; ///异常寄存器 _STRUCT_X86_THREAD_STATE64 __ss; ///线程状态寄存器 _STRUCT_X86_FLOAT_STATE64 __fs; ///浮点寄存器 }; 这个结构体定义了所有的寄存器。其中_STRUCT_MCONTEXT64结构体定义了三大类寄存器，根据字面意思理解为：异常寄存器、线程状态寄存器、浮点寄存器。我们只关注线程状态寄存器。 _STRUCT_ARM_THREAD_STATE64 { __uint64_t __x[29]; ///General purpose registers x0-x28 __uint64_t __fp; ///这里就是BP,x29 __uint64_t __lr; /// Link register x30 __uint64_t __sp; ///这里就是SP x31 __uint64_t __pc; Program counter __uint32_t __cpsr; Current program status register __uint32_t __pad; /* Same size for 32-bit or 64-bit clients */ }; 不管你见或者不见我我就在那里，BP就在 _STRUCT_MCONTEXT64-&gt;ss.fp里，SP就在_STRUCT_MCONTEXT64-&gt;ss-&gt;sp里。不知不觉的问题已经转化了，转化为获取线程的_STRUCT_X86_THREAD_STATE64数据，即，获取线程的状态结构体。 XNU微内核的核心部分Mach，里面暴露了一些线程的接口函数，我们应该能获取到线程的状态结构体。了解这些函数的接口定义可以参考：Mach IPC Interface、IPC 原理讲解。 获取线程状态IPC 接口文档的线程接口部分（Thread Interface）的 thread_get_state函数可以获取线程的状态。他的定义如下： kern_return_t thread_get_state (thread_act_t target_thread, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t old_state_count); thread_get_state函数返回target_thread的执行状态，存储在flavor参数里。看着上面的定义，是不是一点感觉都没有，一头雾水，摸不着头脑？我也是，幸好KSCrash中有这部分代码，贴出来瞅瞅： bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE, ARM_THREAD_STATE_COUNT); } bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount) { mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) { KSLOG_ERROR(&quot;thread_get_state: %s&quot;, mach_error_string(kr)); return false; } return true; } 上面代码说明了thread_get_state函数可以根据线程ID（thread_t thread），获取到线程状态（_STRUCT_ARM_THREAD_STATE64），也就是通过线程ID，就能获取到线程当前执行状态的BP 和SP。 思路回溯上面讲了，那么多，目的只有一个，就是理出一个思路—–获取程序崩溃时线程的调用堆栈。现在大概是这样的： 程序发生崩溃，我们获取到崩溃的线程，取出线程的threadID。 通过thread_get_state函数， 获取线程ID为threadID的线程的 当前执行状态，目的是获取：帧指针BP、栈指针SP； 依据《1.4 调用堆栈》原理、BP、SP，循环取出线程的调用堆栈。 依据《1.2 Mach-O文件存储格式》原理，将调用堆栈中的地址转换为代码中的符号。 总体逻辑现在通了，但是，还有好多好多的细节，等待我们去完善，比如，一个关键的逻辑，我是怎么知道程序崩溃了呢？从而让程序执行到崩溃处理函数里，完成线程回溯功能。 通过分析KS的代码，得知，可以在程序启动的时候注册崩溃的处理函数，程序崩溃发生时，会执行崩溃处理函数。 其实，捕获异常的方式多种多样，不同捕获方式，捕获的原理不同。捕获原理请参看《二、KSCrash异常捕获原理》。这里只扫盲下经典的捕获方式。 捕获崩溃方式捕获崩溃的方式有： 捕获Mach 异常 捕获Unix 信号其实，这部分内容在漫谈 iOS Crash 收集框架中阐述的非常明白。为了表示写的好，这里再重复的阐述下。 iOS 系统自带的Apple’s Crash Reporter 记录在设备中的 Crash 日志，Exception Type项通常会包含两个元素：Mach 异常 和 Unix 信号。 Exception Type: EXC_BAD_ACCESS (SIGSEGV) Exception Subtype: KERN_INVALID_ADDRESS at 0x041a6f3 Mach 异常是什么？它又是如何与 Unix 信号建立联系的？Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件。 所有 Mach 异常都在 host 层被ux_exception转换为相应的 Unix 信号，并通过threadsignal将信号投递到出错的线程。iOS 中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。 因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach 层的EXC_BAD_ACCESS异常，在 host 层被转换成 SIGSEGV 信号投递到出错的线程。既然最终以信号的方式投递到出错的线程，那么就可以通过注册 signalHandler 来捕获信号: signal(SIGSEGV,signalHandler); 捕获 Mach 异常或者 Unix 信号都可以抓到 crash 事件，这两种方式哪个更好呢？优选 Mach 异常，因为 Mach 异常处理会先于 Unix 信号处理发生，如果 Mach 异常的 handler 让程序 exit 了，那么 Unix 信号就永远不会到达这个进程了。转换 Unix 信号是为了兼容更为流行的 POSIX 标准 (SUS 规范)，这样不必了解 Mach 内核也可以通过 Unix 信号的方式来兼容开发。 KSCrash异常捕获原理KSCrash是一个完备的异常捕获开源框架，它不仅可以捕获到各种异常，并可在设备上完成符号化工作。同时，还有很多高级的特性，例如查找僵尸对象（Zombie）、 内存自省（Introspection）、 主线程死锁检测。 捕获日志流程这里只分析KSCrash获取崩溃日志的原理。下面是主要的流程： 获取崩溃日志主要流程有： 注册异常处理函数 等待异常发生 异常发生 回调到异常处理函数 在异常处理函数中获取异常发生时刻的所有线程 循环获取每个线程的调用堆栈 符号化调用堆栈 保存异常日志 程序结束 下次启动发送上次的崩溃日志 捕获的异常种类根据KSCrash的官网介绍，它可以捕获多种异常,包括： Mach kernel exceptions Fatal signals C++ exceptions Objective-C exceptions Main thread deadlock (experimental) Custom crashes (e.g. from scripting languages) 下面主要介绍下 Mach kernel exceptions、Fatal signals、C++ exceptions异常的注册异常处理函数原理。 Mach异常注册原理下面是mach exceptions 的注册流程图 基本流程是： 首先调用task_get_exception_ports 保存先前的异常处理端口。 调用mach_port_allocate 创建异常处理端口g_exceptionPort。 调用 mach_port_insert_right 获取端口的权限 设置异常处理端口 创建线程，线程中不停的调用mach_msg ，读取g_exceptionPort端口上的数据，如果异常发生，mach_msg成功，进入异常处理流程。 恢复先前的异常处理端口 调用ksmachexc_i_fetchMachineState 获取线程状态。 保存状态并完成符号化功能。 卸载异常处理函数。 千言万语，不如几行代码的说服力，所以后面的内容都使用代码+注释的形式表述。 bool kscrashsentry_installMachHandler(KSCrash_SentryContext* const context) { bool attributes_created = false; pthread_attr_t attr; kern_return_t kr; int error; const task_t thisTask = mach_task_self(); exception_mask_t mask = EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT; if(g_installed) { return true; } g_installed = 1; g_context = context; ///获取先前异常捕获的端口 kr = task_get_exception_ports(thisTask, mask, g_previousExceptionPorts.masks, &amp;g_previousExceptionPorts.count, g_previousExceptionPorts.ports, g_previousExceptionPorts.behaviors, g_previousExceptionPorts.flavors); if(g_exceptionPort == MACH_PORT_NULL) { ///创建异常捕获端口 kr = mach_port_allocate(thisTask, MACH_PORT_RIGHT_RECEIVE, &amp;g_exceptionPort); ///获取端口的权限 kr = mach_port_insert_right(thisTask, g_exceptionPort, g_exceptionPort, MACH_MSG_TYPE_MAKE_SEND); } ///设置异常捕获端口 kr = task_set_exception_ports(thisTask, mask, g_exceptionPort, EXCEPTION_DEFAULT, THREAD_STATE_NONE); ///启动读异常端口数据的线程 pthread_attr_init(&amp;attr); attributes_created = true; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); error = pthread_create(&amp;g_secondaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadSecondary); g_secondaryMachThread = pthread_mach_thread_np(g_secondaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachSecondary] = g_secondaryMachThread; error = pthread_create(&amp;g_primaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadPrimary); pthread_attr_destroy(&amp;attr); g_primaryMachThread = pthread_mach_thread_np(g_primaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachPrimary] = g_primaryMachThread; failed: return false; } 这里完了展示主要逻辑，去掉了很多日志和错误判断的代码。下面是异常处理函数 void* ksmachexc_i_handleExceptions(void* const userData) { MachExceptionMessage exceptionMessage = {{0}}; MachReplyMessage replyMessage = {{0}}; const char* threadName = (const char*) userData; pthread_setname_np(threadName); if(threadName == kThreadSecondary) { thread_suspend(ksmach_thread_self()); } for(;;) { ///读取异常端口 kern_return_t kr = mach_msg(&amp;exceptionMessage.header, MACH_RCV_MSG, 0, sizeof(exceptionMessage), g_exceptionPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if(kr == KERN_SUCCESS) { break; } } ///读取到异常信息，证明崩溃发生 if(g_installed) { bool wasHandlingCrash = g_context-&gt;handlingCrash; kscrashsentry_beginHandlingCrash(g_context); ///挂起所有的线程 kscrashsentry_suspendThreads(); // Switch to the secondary thread if necessary, or uninstall the handler // to avoid a death loop. if(ksmach_thread_self() == g_primaryMachThread) { KSLOG_DEBUG(&quot;This is the primary exception thread. Activating secondary thread.&quot;); if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS) { KSLOG_DEBUG(&quot;Could not activate secondary thread. Restoring original exception ports.&quot;); ksmachexc_i_restoreExceptionPorts(); } } else { KSLOG_DEBUG(&quot;This is the secondary exception thread. Restoring original exception ports.&quot;); ksmachexc_i_restoreExceptionPorts(); } ///是否正在处理异常 if(wasHandlingCrash) { KSLOG_INFO(&quot;Detected crash in the crash reporter. Restoring original handlers.&quot;); // The crash reporter itself crashed. Make a note of this and // uninstall all handlers so that we don&apos;t get stuck in a loop. g_context-&gt;crashedDuringCrashHandling = true; kscrashsentry_uninstall(KSCrashTypeAsyncSafe); } /// 填充异常信息 STRUCT_MCONTEXT_L machineContext; if(ksmachexc_i_fetchMachineState(exceptionMessage.thread.name, &amp;machineContext)) { if(exceptionMessage.exception == EXC_BAD_ACCESS) { g_context-&gt;faultAddress = ksmach_faultAddress(&amp;machineContext); } else { g_context-&gt;faultAddress = ksmach_instructionAddress(&amp;machineContext); } } g_context-&gt;crashType = KSCrashTypeMachException; g_context-&gt;offendingThread = exceptionMessage.thread.name; g_context-&gt;registersAreValid = true; g_context-&gt;mach.type = exceptionMessage.exception; g_context-&gt;mach.code = exceptionMessage.code[0]; g_context-&gt;mach.subcode = exceptionMessage.code[1]; g_context-&gt;onCrash(); kscrashsentry_uninstall(KSCrashTypeAsyncSafe); kscrashsentry_resumeThreads(); } // Send a reply saying &quot;I didn&apos;t handle this exception&quot;. replyMessage.header = exceptionMessage.header; replyMessage.NDR = exceptionMessage.NDR; replyMessage.returnCode = KERN_FAILURE; mach_msg(&amp;replyMessage.header, MACH_SEND_MSG, sizeof(replyMessage), 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); return NULL; } signals异常注册下图是signals exceptions 异常处理函数的注册过程： 替换信号处理函数栈 int sigaltstack(const stack_t *ss, stack_t *oss);&lt;/signal.h&gt; int sigaction(int signo,const struct sigaction *restrict act, struct sigaction *restrict oact); 给信号signum设置新的信号处理函数act， 同时保留该信号原有的信号处理函数oldact 安装的信号句柄是g_signalStack，信号的种类包括如下： SIGABRT, /* abort() */ SIGBUS, /* bus error */ SIGFPE, /* floating point exception */ SIGILL, /* illegal instruction (not reset when caught) */ SIGPIPE, /* write on a pipe with no one to read it */ SIGSEGV, /* segmentation violation */ SIGSYS, /* bad argument to system call */ SIGTRAP, /* trace trap (not reset when caught) */ C++ exceptions 异常注册这个比较简单，直接调用了标注库的std::set_terminate(CPPExceptionTerminate)函数，设置CPPExceptionTerminate为C++ exceptions 的异常处理函数。 Object C 异常注册具体看代码Sentry 目录下的KSCrashSentry_NSException.m文件 获取线程的调用堆栈、符号化调用堆栈获取线程的调用堆栈、符号化调用堆栈原理 下面只用代码讲解，代码只保留主要逻辑，kscrash_i_onCrash符号化的入口函数： void kscrash_i_onCrash(void) { ... ///根据崩溃上下文context，写崩溃日志 kscrashreport_writeMinimalReport(context, g_recrashReportFilePath); ...... } void kscrashreport_writeStandardReport(KSCrash_Context* const crashContext, const char* const path) { ...... /// 写崩溃时刻所有线程的 回溯 kscrw_i_writeAllThreads(writer, KSCrashField_Threads, &amp;crashContext-&gt;crash, crashContext-&gt;config.introspectionRules.enabled, crashContext-&gt;config.searchThreadNames, crashContext-&gt;config.searchQueueNames); ..... } void kscrw_i_writeAllThreads(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, bool writeNotableAddresses, bool searchThreadNames, bool searchQueueNames) { const task_t thisTask = mach_task_self(); thread_act_array_t threads; mach_msg_type_number_t numThreads; kern_return_t kr; ///获取所有线程 if((kr = task_threads(thisTask, &amp;threads, &amp;numThreads)) != KERN_SUCCESS) { KSLOG_ERROR(&quot;task_threads: %s&quot;, mach_error_string(kr)); return; } // Fetch info for all threads. writer-&gt;beginArray(writer, key); { for(mach_msg_type_number_t i = 0; i &lt; numThreads; i++) { kscrw_i_writeThread(writer, NULL, crash, threads[i], (int)i, writeNotableAddresses, searchThreadNames, searchQueueNames); } } .... } void kscrw_i_writeThread(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, const thread_t thread, const int index, const bool writeNotableAddresses, const bool searchThreadNames, const bool searchQueueNames) { bool isCrashedThread = thread == crash-&gt;offendingThread; char nameBuffer[128]; STRUCT_MCONTEXT_L machineContextBuffer; uintptr_t backtraceBuffer[kMaxBacktraceDepth]; int backtraceLength = sizeof(backtraceBuffer) / sizeof(*backtraceBuffer); int skippedEntries = 0; /// 获取线程状态、 异常状态 STRUCT_MCONTEXT_L* machineContext = kscrw_i_getMachineContext(crash, thread, &amp;machineContextBuffer); ///获取异常线程的回溯 uintptr_t* backtrace = kscrw_i_getBacktrace(crash, thread, machineContext, backtraceBuffer, &amp;backtraceLength, &amp;skippedEntries); if(backtrace != NULL) { ///符号化线程回溯 kscrw_i_writeBacktrace(writer, KSCrashField_Backtrace, backtrace, backtraceLength, skippedEntries); } ...... } 代码分析到目前，关键的代码已经出现了，三部分： 获取线程状态、 异常状态 获取异常线程的回溯 符号化线程回溯 获取线程状态 代码分析STRUCT_MCONTEXT_L* kscrw_i_getMachineContext(const KSCrash_SentryContext* const crash, const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer) { if(!kscrw_i_fetchMachineState(thread, machineContextBuffer)) { return NULL; } return machineContextBuffer; } bool kscrw_i_fetchMachineState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer) { if(!ksmach_threadState(thread, machineContextBuffer)) { return false; } if(!ksmach_exceptionState(thread, machineContextBuffer)) { return false; } return true; } bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE64, ARM_THREAD_STATE64_COUNT); } bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount) { mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) { return false; } return true; } bool ksmach_exceptionState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__es, ARM_EXCEPTION_STATE64, ARM_EXCEPTION_STATE64_COUNT); } 获取异常线程的回溯 代码分析uintptr_t* kscrw_i_getBacktrace(const KSCrash_SentryContext* const crash, const thread_t thread, const STRUCT_MCONTEXT_L* const machineContext, uintptr_t* const backtraceBuffer, int* const backtraceLength, int* const skippedEntries) { int actualSkippedEntries = 0; int actualLength = ksbt_backtraceLength(machineContext); *backtraceLength = ksbt_backtraceThreadState(machineContext, backtraceBuffer, actualSkippedEntries, *backtraceLength); return backtraceBuffer; } int ksbt_backtraceThreadState(const STRUCT_MCONTEXT_L* const machineContext, uintptr_t*const backtraceBuffer, const int skipEntries, const int maxEntries) { int i = 0; if(skipEntries == 0) { const uintptr_t instructionAddress = ksmach_instructionAddress(machineContext); backtraceBuffer[i] = instructionAddress; i++; } KSFrameEntry frame = {0}; const uintptr_t framePtr = ksmach_framePointer(machineContext); if(framePtr == 0 || ksmach_copyMem((void*)framePtr, &amp;frame, sizeof(frame)) != KERN_SUCCESS) { return 0; } for(; i &lt; maxEntries; i++) { backtraceBuffer[i] = frame.return_address; if(backtraceBuffer[i] == 0 || frame.previous == 0 || ksmach_copyMem(frame.previous, &amp;frame, sizeof(frame)) != KERN_SUCCESS) { break; } } return i; } uintptr_t ksmach_instructionAddress(const STRUCT_MCONTEXT_L* const machineContext) { return machineContext-&gt;__ss.__pc; } 符号化的代码 代码分析struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */ }; typedef struct dl_info { const char *dli_fname; /* Pathname of shared object */ void *dli_fbase; /* Base address of shared object */ const char *dli_sname; /* Name of nearest symbol */ void *dli_saddr; /* Address of nearest symbol */ } Dl_info; void kscrw_i_writeBacktrace(const KSCrashReportWriter* const writer, const char* const key, const uintptr_t* const backtrace, const int backtraceLength, const int skippedEntries) { Dl_info symbolicated[backtraceLength]; ksbt_symbolicate(backtrace, symbolicated, backtraceLength, skippedEntries); } #define CALL_INSTRUCTION_FROM_RETURN_ADDRESS(A) (DETAG_INSTRUCTION_ADDRESS((A)) - 1) void ksbt_symbolicate(const uintptr_t* const backtraceBuffer, Dl_info* const symbolsBuffer, const int numEntries, const int skippedEntries) { int i = 0; for(; i &lt; numEntries; i++) { ksdl_dladdr(CALL_INSTRUCTION_FROM_RETURN_ADDRESS(backtraceBuffer[i]), &amp;symbolsBuffer[i]); } } bool ksdl_dladdr(const uintptr_t address, Dl_info* const info) { info-&gt;dli_fname = NULL; info-&gt;dli_fbase = NULL; info-&gt;dli_sname = NULL; info-&gt;dli_saddr = NULL; const uint32_t idx = ksdl_imageIndexContainingAddress(address); if(idx == UINT_MAX) { return false; } const struct mach_header* header = _dyld_get_image_header(idx); const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx); /// 符号在镜像的偏移量 = 堆栈地址 - 镜像的加载地址 const uintptr_t addressWithSlide = address - imageVMAddrSlide; const uintptr_t segmentBase = ksdl_segmentBaseOfImageIndex(idx) + imageVMAddrSlide; if(segmentBase == 0) { return false; } info-&gt;dli_fname = _dyld_get_image_name(idx); info-&gt;dli_fbase = (void*)header; // Find symbol tables and get whichever symbol is closest to the address. const STRUCT_NLIST* bestMatch = NULL; uintptr_t bestDistance = ULONG_MAX; uintptr_t cmdPtr = ksdl_firstCmdAfterHeader(header); if(cmdPtr == 0) { return false; } for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) { const struct load_command* loadCmd = (struct load_command*)cmdPtr; ///查找LC_SYMTAB load command if(loadCmd-&gt;cmd == LC_SYMTAB) { const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPtr; const STRUCT_NLIST* symbolTable = (STRUCT_NLIST*)(segmentBase + symtabCmd-&gt;symoff); const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff; ///在符号表中循环查找，直到首次达到 镜像偏移量imageVMAddrSlide for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) { // If n_value is 0, the symbol refers to an external object. if(symbolTable[iSym].n_value != 0) { uintptr_t symbolBase = symbolTable[iSym].n_value; uintptr_t currentDistance = addressWithSlide - symbolBase; if((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) { bestMatch = symbolTable + iSym; bestDistance = currentDistance; } } } ///取出符号信息，符号信息存储在 if(bestMatch != NULL) { info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddrSlide); info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx); if(*info-&gt;dli_sname == &apos;_&apos;) { info-&gt;dli_sname++; } // This happens if all symbols have been stripped. if(info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == 3) { info-&gt;dli_sname = NULL; } break; } } cmdPtr += loadCmd-&gt;cmdsize; } return true; } 上面是所有的关键代码。用到了一些Mach 的API，单不是苹果私有API，放心用吧。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/categories/Crash/"}]},{"title":"KSCrash崩溃收集原理浅析","date":"2016-07-17T04:18:26.000Z","path":"wiki/IOS基础知识/crash/22/KSCrash_Analize/","text":"KSCrash 是一个异常收集的开源框架。它可以捕获到Mach级内核异常、信号异常、C++异常、Objective-C异常、主线程死锁；当捕获到异常后，KSCrash可以在设备上完成符号化崩溃日志(前提是编译的时候将符号表编译到可执行程序中)；日志的格式你也可以定制，可以是JSON格式的，也可以是Apple crash日志风格。另外，还有僵尸对象查找、内存自省等特性。 目前异常收集的框架非常多，有集成了收集、统计功能的一条龙产品，如，友盟，鹅厂的Bugly 等等；也有几个开源框架，如，KSCrash，plcrashreporter，CrashKit。基于我们项目的安全性考虑，即，不希望第三方SDK看到崩溃日志，我选取了开源框架这条路。纵览这几个开源框架，只有KSCrash一直在更新。所以，毫不犹豫的选用了它。 APP Crash后，获取崩溃线程的程调用堆栈的过程，是程序执行过程的逆向过程。那么，了解APP的执行正向过程，对获取崩溃线程的调用堆栈是非常非常有益的。所以，在分析KSCrash原理前，依照APP正向执行过程先推导下 异常收集、符号化的原理。 推导异常收集、符号化的原理本节描述的内容只是按照自己的理解编写的，由于道行尚浅，理解不深，所以具体安排的内容不一定合理。依据APP执行的过程，主要囊括了：编译生成可执行APP、内核加载并启动APP、调用堆栈等，并穿插了一点理解KSCrash的必备知识。 编译生成可执行APP开发者通过IDE集成开发环境（例如Xcode），将源码文件转化为临时中间文件（这种文件应该是机器语言了），然后使用链接器（/usr/bin/ld）将临时的对象文件（object file）合并为可执行文件。不过上面的编译、链接步骤都集成到Xcode中了。我们在Xcode中编译的时候，体会不到这个过程。在苹果系统中，可执行APP的存储格式是Mach-O格式。所以我们先了解下Mach-O文件格式。 Mach-O文件存储格式Mach-O (Mach object的缩写) 是苹果系统上存储可执行程序和库（libraries）的标准格式。它是BSD系统中.a文件格式的替代物，它封装着程序的可执行代码和数据。可以参考《OS X ABI Mach-O File Format Reference》官方文档。这个文档在官网打不来了，我就链接到我自己的pdf地址了。 概述Mach-O文件包括三个组成部分，分别如下： header：指定了文件的基本信息，如CUP类型、加载命令个数等。 Load commands：加载命令，指定了文件的逻辑结构、在虚拟内存（virtual memory）中文件的布局。你可以理解为一片文章的目录。 Raw segment data：数据部分。 这个是官网上的结构示意图。 headerMach-O文件的开头部分是就是Header—文件头。Header的数据结构定义在XNU微内核的loader.h文件中。loader.h也可以在IOS SDK的/usr/include/mach-o目录下找到，header的数据结构定义如下： 12345678910struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;; 可以看出包括了 ：魔数、cup的类型、子类型、文件的类型、load commend个数、load commend大小等数据。 load commend紧跟在Header后面的是load commend。load commend指定了文件的布局。具体指定了以下内容： • The initial layout of the file in virtual memory 文件在虚拟内存中的初始布局 • The location of the symbol table (used for dynamic linking) 符号表的位置 • The initial execution state of the main thread of the program 程序主线程的入口地址 • The names of shared libraries that contain definitions for the main executable’s imported symbols 主执行文件依赖的分享库 load commend 的种类非常多，loader.h 中的定义了各种所有的类型。我们仅以LC_SEGMENT、LC_SYMTAB（符号表）为例了解load commend。每种类型的load commend都有对应的数据结构，可以在loader.h文件中查看。下面是部分类型Load Commond： #define LC_SEGMENT 0x1 ///代码段 #define LC_SYMTAB 0x2 /// 符号表 #define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */ #define LC_THREAD 0x4 /* thread */ #define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */ #define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */ #define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */ #define LC_IDENT 0x8 /* object identification info (obsolete) */ #define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */ #define LC_PREPAGE 0xa /* prepage command (internal use) */ #define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */ #define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */ #define LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */ #define LC_LOAD_DYLINKER 0xe /* load a dynamic linker */ #define LC_ID_DYLINKER 0xf /* dynamic linker identification */ #define LC_PREBOUND_DYLIB 0x10 /* modules prebound for a dynamically */ ................... DataData紧跟在Load Commond后面。load commend中定义的各种数据都存储在这部分中。 查看Mach-O实用工具在终端中有几个工具是可以查看Mach-O文件内容的。另外位于usr/include/mach-o/dyld.h中的函数可以在程序中访问Mach-O文件内容。 文件类型展示工具-file。The file-type displaying tool, 位于/usr/bin/file，显示文件的类型，对于多构架的文件，它显示每个构架下的镜像类型。在终端中输入： ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive: Mach-O universal binary with 2 architectures /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture armv7): Mach-O executable arm /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): Mach-O 64-bit executable 对象文件展示工具otool。The object-file displaying tool，位于/usr/bin/otool，显示Mach-O文件的各种数据。查看Mach-O header内容，在终端中输入： otool -hV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC ARM V7 0x00 EXECUTE 23 2432 NOUNDEFS DYLDLINK TWOLEVEL PIE Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 23 2872 NOUNDEFS DYLDLINK TWOLEVEL PIE 可以使用otool 查看load commend。在终端中输入： otool -lV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags 0xfeedface 12 9 0x00 2 23 2432 0x00200085 Load command 0 cmd LC_SEGMENT cmdsize 56 segname __PAGEZERO vmaddr 0x00000000 vmsize 0x00004000 fileoff 0 filesize 0 maxprot 0x00000000 initprot 0x00000000 nsects 0 flags 0x0 ………. 符号展示工具-nm，The symbol table display tool,位于 /usr/bin/nm, allows you to view the contents of an object file’s symbol table。查看符号表，在终端中输入： nm ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： /Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): U _NSGetUncaughtExceptionHandler U _NSLog U _NSSearchPathForDirectoriesInDomains U _NSSetUncaughtExceptionHandler U _NSStringFromClass U _objc_msgSend U _objc_msgSendSuper2 U _objc_release U _objc_retain U _objc_retainAutorelease U _objc_retainAutoreleasedReturnValue U _objc_setProperty_nonatomic_copy U _objc_storeStrong U _strstr U dyld_stub_binder ........... 绑定和执行根据上面分析的可执行文件的结构，我们可以看到，可执行文件中已经包含了符号表 ，这个符号表是可执行代码的虚拟地址和代码中符号的对应表。符号表是绑定过程中建立的，程序的绑定有很多种，可以参看下面的文档：Mach-O Programming Topics - Binding Symbols，里面详细介绍了绑定和查找符号的过程。 看到符号表，那么我们可以做这样的设想：如果程序崩溃，只要我们获取到了崩溃调用堆栈的回溯地址，然后从这个符号表中查找对应的符号，就完成了调用堆栈的符号化工作？ 还有就是我们如何获取程序的调用堆栈呢？还有很多需要我们接着往下看。为了知道如何获取调用堆栈的回溯，我们了解下程序的执行过程： 程序的执行过程：内核首先加载可执行文件，并且检测程序文件的起始部分的mach_header结构，内核验证是否合法的Macj-O文件，解析header中的load commands。加载Load Commond中指定依赖镜像到内存中，然后启动进程，执行程序的入口函数，进入正常的run loop。 调用堆栈首先介绍一下什么叫调用堆栈：假设我们为了完成一个任务1，任务1的完成需要完成任务2…. 分别定义为几个函数：function1,function2,function3,funtion4。即，function1调用function2，function2调用function3，function3调用function4。在function4运行过程中，我们可以从线程当前堆栈中了解到调用他的那几个函数分别是谁。function4、function3、function2、function1呈现出一种“堆栈”的特征，最后被调用的函数出现在最上方。因此称呼这种关系为调用堆栈(call stack)。 下面有一个图展示下： 函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。理解了入栈和出栈，基本能理解调用堆栈，下面两个图，一个是入栈，一个是出栈，图中描述的很清楚。 所以获取到崩溃时线程的ebp和esp 就能回溯到上一个调用，依次类推，回溯出所有的调用堆栈。下面了解下寄存器。 寄存器为了线程获取BP和SP，我们需要了解一点点寄存器。因为他们保存在CPU的寄存器中。arm64构架的寄存器在Procedure Call Standard for the ARM 64-bit Architecture (AArch64)有详细的说明。不过都是英文的，我没有看，我从代码中也找到了它的定义，位于IOS SDK的usr/include/arm目录下的_mcontext.h文件中。其中几个关键的定义的代码我摘录下来了，如下： _STRUCT_MCONTEXT64 { _STRUCT_X86_EXCEPTION_STATE64 __es; ///异常寄存器 _STRUCT_X86_THREAD_STATE64 __ss; ///线程状态寄存器 _STRUCT_X86_FLOAT_STATE64 __fs; ///浮点寄存器 }; 这个结构体定义了所有的寄存器。其中_STRUCT_MCONTEXT64结构体定义了三大类寄存器，根据字面意思理解为：异常寄存器、线程状态寄存器、浮点寄存器。我们只关注线程状态寄存器。 _STRUCT_ARM_THREAD_STATE64 { __uint64_t __x[29]; ///General purpose registers x0-x28 __uint64_t __fp; ///这里就是BP,x29 __uint64_t __lr; /// Link register x30 __uint64_t __sp; ///这里就是SP x31 __uint64_t __pc; Program counter __uint32_t __cpsr; Current program status register __uint32_t __pad; /* Same size for 32-bit or 64-bit clients */ }; 不管你见或者不见我我就在那里，BP就在 _STRUCT_MCONTEXT64-&gt;ss.fp里，SP就在_STRUCT_MCONTEXT64-&gt;ss-&gt;sp里。不知不觉的问题已经转化了，转化为获取线程的_STRUCT_X86_THREAD_STATE64数据，即，获取线程的状态结构体。 XNU微内核的核心部分Mach，里面暴露了一些线程的接口函数，我们应该能获取到线程的状态结构体。了解这些函数的接口定义可以参考：Mach IPC Interface、IPC 原理讲解。 获取线程状态IPC 接口文档的线程接口部分（Thread Interface）的 thread_get_state函数可以获取线程的状态。他的定义如下： kern_return_t thread_get_state (thread_act_t target_thread, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t old_state_count); thread_get_state函数返回target_thread的执行状态，存储在flavor参数里。看着上面的定义，是不是一点感觉都没有，一头雾水，摸不着头脑？我也是，幸好KSCrash中有这部分代码，贴出来瞅瞅： bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE, ARM_THREAD_STATE_COUNT); } bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount) { mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) { KSLOG_ERROR(&quot;thread_get_state: %s&quot;, mach_error_string(kr)); return false; } return true; } 上面代码说明了thread_get_state函数可以根据线程ID（thread_t thread），获取到线程状态（_STRUCT_ARM_THREAD_STATE64），也就是通过线程ID，就能获取到线程当前执行状态的BP 和SP。 思路回溯上面讲了，那么多，目的只有一个，就是理出一个思路—–获取程序崩溃时线程的调用堆栈。现在大概是这样的： 程序发生崩溃，我们获取到崩溃的线程，取出线程的threadID。 通过thread_get_state函数， 获取线程ID为threadID的线程的 当前执行状态，目的是获取：帧指针BP、栈指针SP； 依据《1.4 调用堆栈》原理、BP、SP，循环取出线程的调用堆栈。 依据《1.2 Mach-O文件存储格式》原理，将调用堆栈中的地址转换为代码中的符号。 总体逻辑现在通了，但是，还有好多好多的细节，等待我们去完善，比如，一个关键的逻辑，我是怎么知道程序崩溃了呢？从而让程序执行到崩溃处理函数里，完成线程回溯功能。 通过分析KS的代码，得知，可以在程序启动的时候注册崩溃的处理函数，程序崩溃发生时，会执行崩溃处理函数。 其实，捕获异常的方式多种多样，不同捕获方式，捕获的原理不同。捕获原理请参看《二、KSCrash异常捕获原理》。这里只扫盲下经典的捕获方式。 捕获崩溃方式捕获崩溃的方式有： 捕获Mach 异常 捕获Unix 信号其实，这部分内容在漫谈 iOS Crash 收集框架中阐述的非常明白。为了表示写的好，这里再重复的阐述下。 iOS 系统自带的Apple’s Crash Reporter 记录在设备中的 Crash 日志，Exception Type项通常会包含两个元素：Mach 异常 和 Unix 信号。 Exception Type: EXC_BAD_ACCESS (SIGSEGV) Exception Subtype: KERN_INVALID_ADDRESS at 0x041a6f3 Mach 异常是什么？它又是如何与 Unix 信号建立联系的？Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件。 所有 Mach 异常都在 host 层被ux_exception转换为相应的 Unix 信号，并通过threadsignal将信号投递到出错的线程。iOS 中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。 因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach 层的EXC_BAD_ACCESS异常，在 host 层被转换成 SIGSEGV 信号投递到出错的线程。既然最终以信号的方式投递到出错的线程，那么就可以通过注册 signalHandler 来捕获信号: signal(SIGSEGV,signalHandler); 捕获 Mach 异常或者 Unix 信号都可以抓到 crash 事件，这两种方式哪个更好呢？优选 Mach 异常，因为 Mach 异常处理会先于 Unix 信号处理发生，如果 Mach 异常的 handler 让程序 exit 了，那么 Unix 信号就永远不会到达这个进程了。转换 Unix 信号是为了兼容更为流行的 POSIX 标准 (SUS 规范)，这样不必了解 Mach 内核也可以通过 Unix 信号的方式来兼容开发。 KSCrash异常捕获原理KSCrash是一个完备的异常捕获开源框架，它不仅可以捕获到各种异常，并可在设备上完成符号化工作。同时，还有很多高级的特性，例如查找僵尸对象（Zombie）、 内存自省（Introspection）、 主线程死锁检测。 捕获日志流程这里只分析KSCrash获取崩溃日志的原理。下面是主要的流程： 获取崩溃日志主要流程有： 注册异常处理函数 等待异常发生 异常发生 回调到异常处理函数 在异常处理函数中获取异常发生时刻的所有线程 循环获取每个线程的调用堆栈 符号化调用堆栈 保存异常日志 程序结束 下次启动发送上次的崩溃日志 捕获的异常种类根据KSCrash的官网介绍，它可以捕获多种异常,包括： Mach kernel exceptions Fatal signals C++ exceptions Objective-C exceptions Main thread deadlock (experimental) Custom crashes (e.g. from scripting languages) 下面主要介绍下 Mach kernel exceptions、Fatal signals、C++ exceptions异常的注册异常处理函数原理。 Mach异常注册原理下面是mach exceptions 的注册流程图 基本流程是： 首先调用task_get_exception_ports 保存先前的异常处理端口。 调用mach_port_allocate 创建异常处理端口g_exceptionPort。 调用 mach_port_insert_right 获取端口的权限 设置异常处理端口 创建线程，线程中不停的调用mach_msg ，读取g_exceptionPort端口上的数据，如果异常发生，mach_msg成功，进入异常处理流程。 恢复先前的异常处理端口 调用ksmachexc_i_fetchMachineState 获取线程状态。 保存状态并完成符号化功能。 卸载异常处理函数。 千言万语，不如几行代码的说服力，所以后面的内容都使用代码+注释的形式表述。 bool kscrashsentry_installMachHandler(KSCrash_SentryContext* const context) { bool attributes_created = false; pthread_attr_t attr; kern_return_t kr; int error; const task_t thisTask = mach_task_self(); exception_mask_t mask = EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT; if(g_installed) { return true; } g_installed = 1; g_context = context; ///获取先前异常捕获的端口 kr = task_get_exception_ports(thisTask, mask, g_previousExceptionPorts.masks, &amp;g_previousExceptionPorts.count, g_previousExceptionPorts.ports, g_previousExceptionPorts.behaviors, g_previousExceptionPorts.flavors); if(g_exceptionPort == MACH_PORT_NULL) { ///创建异常捕获端口 kr = mach_port_allocate(thisTask, MACH_PORT_RIGHT_RECEIVE, &amp;g_exceptionPort); ///获取端口的权限 kr = mach_port_insert_right(thisTask, g_exceptionPort, g_exceptionPort, MACH_MSG_TYPE_MAKE_SEND); } ///设置异常捕获端口 kr = task_set_exception_ports(thisTask, mask, g_exceptionPort, EXCEPTION_DEFAULT, THREAD_STATE_NONE); ///启动读异常端口数据的线程 pthread_attr_init(&amp;attr); attributes_created = true; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); error = pthread_create(&amp;g_secondaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadSecondary); g_secondaryMachThread = pthread_mach_thread_np(g_secondaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachSecondary] = g_secondaryMachThread; error = pthread_create(&amp;g_primaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadPrimary); pthread_attr_destroy(&amp;attr); g_primaryMachThread = pthread_mach_thread_np(g_primaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachPrimary] = g_primaryMachThread; failed: return false; } 这里完了展示主要逻辑，去掉了很多日志和错误判断的代码。下面是异常处理函数 void* ksmachexc_i_handleExceptions(void* const userData) { MachExceptionMessage exceptionMessage = {{0}}; MachReplyMessage replyMessage = {{0}}; const char* threadName = (const char*) userData; pthread_setname_np(threadName); if(threadName == kThreadSecondary) { thread_suspend(ksmach_thread_self()); } for(;;) { ///读取异常端口 kern_return_t kr = mach_msg(&amp;exceptionMessage.header, MACH_RCV_MSG, 0, sizeof(exceptionMessage), g_exceptionPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if(kr == KERN_SUCCESS) { break; } } ///读取到异常信息，证明崩溃发生 if(g_installed) { bool wasHandlingCrash = g_context-&gt;handlingCrash; kscrashsentry_beginHandlingCrash(g_context); ///挂起所有的线程 kscrashsentry_suspendThreads(); // Switch to the secondary thread if necessary, or uninstall the handler // to avoid a death loop. if(ksmach_thread_self() == g_primaryMachThread) { KSLOG_DEBUG(&quot;This is the primary exception thread. Activating secondary thread.&quot;); if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS) { KSLOG_DEBUG(&quot;Could not activate secondary thread. Restoring original exception ports.&quot;); ksmachexc_i_restoreExceptionPorts(); } } else { KSLOG_DEBUG(&quot;This is the secondary exception thread. Restoring original exception ports.&quot;); ksmachexc_i_restoreExceptionPorts(); } ///是否正在处理异常 if(wasHandlingCrash) { KSLOG_INFO(&quot;Detected crash in the crash reporter. Restoring original handlers.&quot;); // The crash reporter itself crashed. Make a note of this and // uninstall all handlers so that we don&apos;t get stuck in a loop. g_context-&gt;crashedDuringCrashHandling = true; kscrashsentry_uninstall(KSCrashTypeAsyncSafe); } /// 填充异常信息 STRUCT_MCONTEXT_L machineContext; if(ksmachexc_i_fetchMachineState(exceptionMessage.thread.name, &amp;machineContext)) { if(exceptionMessage.exception == EXC_BAD_ACCESS) { g_context-&gt;faultAddress = ksmach_faultAddress(&amp;machineContext); } else { g_context-&gt;faultAddress = ksmach_instructionAddress(&amp;machineContext); } } g_context-&gt;crashType = KSCrashTypeMachException; g_context-&gt;offendingThread = exceptionMessage.thread.name; g_context-&gt;registersAreValid = true; g_context-&gt;mach.type = exceptionMessage.exception; g_context-&gt;mach.code = exceptionMessage.code[0]; g_context-&gt;mach.subcode = exceptionMessage.code[1]; g_context-&gt;onCrash(); kscrashsentry_uninstall(KSCrashTypeAsyncSafe); kscrashsentry_resumeThreads(); } // Send a reply saying &quot;I didn&apos;t handle this exception&quot;. replyMessage.header = exceptionMessage.header; replyMessage.NDR = exceptionMessage.NDR; replyMessage.returnCode = KERN_FAILURE; mach_msg(&amp;replyMessage.header, MACH_SEND_MSG, sizeof(replyMessage), 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); return NULL; } signals异常注册下图是signals exceptions 异常处理函数的注册过程： 替换信号处理函数栈 int sigaltstack(const stack_t *ss, stack_t *oss);&lt;/signal.h&gt; int sigaction(int signo,const struct sigaction *restrict act, struct sigaction *restrict oact); 给信号signum设置新的信号处理函数act， 同时保留该信号原有的信号处理函数oldact 安装的信号句柄是g_signalStack，信号的种类包括如下： SIGABRT, /* abort() */ SIGBUS, /* bus error */ SIGFPE, /* floating point exception */ SIGILL, /* illegal instruction (not reset when caught) */ SIGPIPE, /* write on a pipe with no one to read it */ SIGSEGV, /* segmentation violation */ SIGSYS, /* bad argument to system call */ SIGTRAP, /* trace trap (not reset when caught) */ C++ exceptions 异常注册这个比较简单，直接调用了标注库的std::set_terminate(CPPExceptionTerminate)函数，设置CPPExceptionTerminate为C++ exceptions 的异常处理函数。 Object C 异常注册具体看代码Sentry 目录下的KSCrashSentry_NSException.m文件 获取线程的调用堆栈、符号化调用堆栈获取线程的调用堆栈、符号化调用堆栈原理 下面只用代码讲解，代码只保留主要逻辑，kscrash_i_onCrash符号化的入口函数： void kscrash_i_onCrash(void) { ... ///根据崩溃上下文context，写崩溃日志 kscrashreport_writeMinimalReport(context, g_recrashReportFilePath); ...... } void kscrashreport_writeStandardReport(KSCrash_Context* const crashContext, const char* const path) { ...... /// 写崩溃时刻所有线程的 回溯 kscrw_i_writeAllThreads(writer, KSCrashField_Threads, &amp;crashContext-&gt;crash, crashContext-&gt;config.introspectionRules.enabled, crashContext-&gt;config.searchThreadNames, crashContext-&gt;config.searchQueueNames); ..... } void kscrw_i_writeAllThreads(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, bool writeNotableAddresses, bool searchThreadNames, bool searchQueueNames) { const task_t thisTask = mach_task_self(); thread_act_array_t threads; mach_msg_type_number_t numThreads; kern_return_t kr; ///获取所有线程 if((kr = task_threads(thisTask, &amp;threads, &amp;numThreads)) != KERN_SUCCESS) { KSLOG_ERROR(&quot;task_threads: %s&quot;, mach_error_string(kr)); return; } // Fetch info for all threads. writer-&gt;beginArray(writer, key); { for(mach_msg_type_number_t i = 0; i &lt; numThreads; i++) { kscrw_i_writeThread(writer, NULL, crash, threads[i], (int)i, writeNotableAddresses, searchThreadNames, searchQueueNames); } } .... } void kscrw_i_writeThread(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, const thread_t thread, const int index, const bool writeNotableAddresses, const bool searchThreadNames, const bool searchQueueNames) { bool isCrashedThread = thread == crash-&gt;offendingThread; char nameBuffer[128]; STRUCT_MCONTEXT_L machineContextBuffer; uintptr_t backtraceBuffer[kMaxBacktraceDepth]; int backtraceLength = sizeof(backtraceBuffer) / sizeof(*backtraceBuffer); int skippedEntries = 0; /// 获取线程状态、 异常状态 STRUCT_MCONTEXT_L* machineContext = kscrw_i_getMachineContext(crash, thread, &amp;machineContextBuffer); ///获取异常线程的回溯 uintptr_t* backtrace = kscrw_i_getBacktrace(crash, thread, machineContext, backtraceBuffer, &amp;backtraceLength, &amp;skippedEntries); if(backtrace != NULL) { ///符号化线程回溯 kscrw_i_writeBacktrace(writer, KSCrashField_Backtrace, backtrace, backtraceLength, skippedEntries); } ...... } 代码分析到目前，关键的代码已经出现了，三部分： 获取线程状态、 异常状态 获取异常线程的回溯 符号化线程回溯 获取线程状态 代码分析STRUCT_MCONTEXT_L* kscrw_i_getMachineContext(const KSCrash_SentryContext* const crash, const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer) { if(!kscrw_i_fetchMachineState(thread, machineContextBuffer)) { return NULL; } return machineContextBuffer; } bool kscrw_i_fetchMachineState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer) { if(!ksmach_threadState(thread, machineContextBuffer)) { return false; } if(!ksmach_exceptionState(thread, machineContextBuffer)) { return false; } return true; } bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE64, ARM_THREAD_STATE64_COUNT); } bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount) { mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) { return false; } return true; } bool ksmach_exceptionState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext) { return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__es, ARM_EXCEPTION_STATE64, ARM_EXCEPTION_STATE64_COUNT); } 获取异常线程的回溯 代码分析uintptr_t* kscrw_i_getBacktrace(const KSCrash_SentryContext* const crash, const thread_t thread, const STRUCT_MCONTEXT_L* const machineContext, uintptr_t* const backtraceBuffer, int* const backtraceLength, int* const skippedEntries) { int actualSkippedEntries = 0; int actualLength = ksbt_backtraceLength(machineContext); *backtraceLength = ksbt_backtraceThreadState(machineContext, backtraceBuffer, actualSkippedEntries, *backtraceLength); return backtraceBuffer; } int ksbt_backtraceThreadState(const STRUCT_MCONTEXT_L* const machineContext, uintptr_t*const backtraceBuffer, const int skipEntries, const int maxEntries) { int i = 0; if(skipEntries == 0) { const uintptr_t instructionAddress = ksmach_instructionAddress(machineContext); backtraceBuffer[i] = instructionAddress; i++; } KSFrameEntry frame = {0}; const uintptr_t framePtr = ksmach_framePointer(machineContext); if(framePtr == 0 || ksmach_copyMem((void*)framePtr, &amp;frame, sizeof(frame)) != KERN_SUCCESS) { return 0; } for(; i &lt; maxEntries; i++) { backtraceBuffer[i] = frame.return_address; if(backtraceBuffer[i] == 0 || frame.previous == 0 || ksmach_copyMem(frame.previous, &amp;frame, sizeof(frame)) != KERN_SUCCESS) { break; } } return i; } uintptr_t ksmach_instructionAddress(const STRUCT_MCONTEXT_L* const machineContext) { return machineContext-&gt;__ss.__pc; } 符号化的代码 代码分析struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */ }; typedef struct dl_info { const char *dli_fname; /* Pathname of shared object */ void *dli_fbase; /* Base address of shared object */ const char *dli_sname; /* Name of nearest symbol */ void *dli_saddr; /* Address of nearest symbol */ } Dl_info; void kscrw_i_writeBacktrace(const KSCrashReportWriter* const writer, const char* const key, const uintptr_t* const backtrace, const int backtraceLength, const int skippedEntries) { Dl_info symbolicated[backtraceLength]; ksbt_symbolicate(backtrace, symbolicated, backtraceLength, skippedEntries); } #define CALL_INSTRUCTION_FROM_RETURN_ADDRESS(A) (DETAG_INSTRUCTION_ADDRESS((A)) - 1) void ksbt_symbolicate(const uintptr_t* const backtraceBuffer, Dl_info* const symbolsBuffer, const int numEntries, const int skippedEntries) { int i = 0; for(; i &lt; numEntries; i++) { ksdl_dladdr(CALL_INSTRUCTION_FROM_RETURN_ADDRESS(backtraceBuffer[i]), &amp;symbolsBuffer[i]); } } bool ksdl_dladdr(const uintptr_t address, Dl_info* const info) { info-&gt;dli_fname = NULL; info-&gt;dli_fbase = NULL; info-&gt;dli_sname = NULL; info-&gt;dli_saddr = NULL; const uint32_t idx = ksdl_imageIndexContainingAddress(address); if(idx == UINT_MAX) { return false; } const struct mach_header* header = _dyld_get_image_header(idx); const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx); /// 符号在镜像的偏移量 = 堆栈地址 - 镜像的加载地址 const uintptr_t addressWithSlide = address - imageVMAddrSlide; const uintptr_t segmentBase = ksdl_segmentBaseOfImageIndex(idx) + imageVMAddrSlide; if(segmentBase == 0) { return false; } info-&gt;dli_fname = _dyld_get_image_name(idx); info-&gt;dli_fbase = (void*)header; // Find symbol tables and get whichever symbol is closest to the address. const STRUCT_NLIST* bestMatch = NULL; uintptr_t bestDistance = ULONG_MAX; uintptr_t cmdPtr = ksdl_firstCmdAfterHeader(header); if(cmdPtr == 0) { return false; } for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) { const struct load_command* loadCmd = (struct load_command*)cmdPtr; ///查找LC_SYMTAB load command if(loadCmd-&gt;cmd == LC_SYMTAB) { const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPtr; const STRUCT_NLIST* symbolTable = (STRUCT_NLIST*)(segmentBase + symtabCmd-&gt;symoff); const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff; ///在符号表中循环查找，直到首次达到 镜像偏移量imageVMAddrSlide for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) { // If n_value is 0, the symbol refers to an external object. if(symbolTable[iSym].n_value != 0) { uintptr_t symbolBase = symbolTable[iSym].n_value; uintptr_t currentDistance = addressWithSlide - symbolBase; if((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) { bestMatch = symbolTable + iSym; bestDistance = currentDistance; } } } ///取出符号信息，符号信息存储在 if(bestMatch != NULL) { info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddrSlide); info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx); if(*info-&gt;dli_sname == &apos;_&apos;) { info-&gt;dli_sname++; } // This happens if all symbols have been stripped. if(info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == 3) { info-&gt;dli_sname = NULL; } break; } } cmdPtr += loadCmd-&gt;cmdsize; } return true; } 上面是所有的关键代码。用到了一些Mach 的API，单不是苹果私有API，放心用吧。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/categories/Crash/"}]}]}