{"pages":[{"title":"About","date":"2018-02-28T08:39:10.000Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-02-28T08:39:10.000Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-02-28T08:39:10.000Z","path":"tags/index.html","text":""}],"posts":[{"title":"Block的类型","date":"2019-09-29T04:07:12.000Z","path":"wiki/IOS/Block/block2/","text":"本文理解block的本质 block的底层实现示例代码 1234567891011121314&#123; void (^block)(void); &#123; Persion *persion = [[Persion alloc] init]; persion.age = 20; block = ^()&#123; NSLog(@\"%d\",persion.age); &#125;; &#125; //由于block被强引用对象持有，block是__NSMallocBlock__ ，持有persion对象 NSLog(@\"%@\", [block class]);&#125;//超出block作用域，block释放，persion也释放//执行persion的dealloc方法 翻译为CPP代码 1234567891011&#123; void (*block)(void); &#123; Persion *persion = objc_msgSend(objc_msgSend(objc_getClass(\"Persion\"), sel_registerName(\"alloc\")), sel_registerName(\"init\")); objc_msgSend(persion, sel_registerName(\"setAge:\"), 20); block = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, persion, 570425344)); &#125; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_6d037c_mi_2, objc_msgSend(block, sel_registerName(\"class\")));&#125;NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_6d037c_mi_3); 下面是__main_block_impl_0的定义： 12345678910111213141516171819202122232425262728293031323334struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //定义了捕获的persion对象 Persion *persion; //构造函数中多了一个persion对象 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, Persion *_persion, int flags=0) : persion(_persion) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; //使用捕获的persion对象 Persion *persion = __cself-&gt;persion; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_6d037c_mi_1,((int (*)(id, SEL))(void *)objc_msgSend)((id)persion, sel_registerName(\"age\")));&#125;//增加捕获对象的引用计数器static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;_Block_object_assign((void*)&amp;dst-&gt;persion, (void*)src-&gt;persion, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;//减少捕获对象的引用计数器static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123;_Block_object_dispose((void*)src-&gt;persion, 3/*BLOCK_FIELD_IS_OBJECT*/);&#125;//__main_block_desc_0多了两个函数指针static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;; 点点滴滴1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m","tags":[{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Block","slug":"IOS/Block","permalink":"http://yoursite.com/categories/IOS/Block/"}]},{"title":"Block的本质","date":"2019-09-27T04:07:12.000Z","path":"wiki/IOS/Block/block/","text":"本文理解block的本质 block的底层实现源码 123456void (^block)(void) = ^&#123; NSLog(@\"this is a block\"); NSLog(@\"this is a block\"); NSLog(@\"this is a block\");&#125;;block(); 翻译为CPP代码 12void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA);block-&gt;FuncPtr(block); 所以，block 的本质是__main_block_impl_0结构体，构造一个__main_block_impl_0结构，将__main_block_impl_0的地址赋值给block,执行block的过程是通过block找到函数指针FuncPtr，调用。 __main_block_impl_0的结构如下（这几个结构体名字不好记，牢记impl是整体实现，实现里面有函数指针func）： 1234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; //构造函数 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; __main_block_impl_0包含两个成员，如下： 1234567891011struct __block_impl &#123; void *isa; //isa，说明是OC对象 int Flags; int Reserved; void *FuncPtr; //block内的代码封装为函数指针&#125;;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 其中，函数指针 __main_block_func_0的定义 123456789static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2);&#125;//常量字符串定义在数据区static __NSConstantStringImpl __NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_0 __attribute__ ((section (\"__DATA, __cfstring\"))) = &#123;__CFConstantStringClassReference,0x000007c8,\"this is a block\",15&#125;;static __NSConstantStringImpl __NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_1 __attribute__ ((section (\"__DATA, __cfstring\"))) = &#123;__CFConstantStringClassReference,0x000007c8,\"this is a block\",15&#125;;static __NSConstantStringImpl __NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_77e4e1_mi_2 __attribute__ ((section (\"__DATA, __cfstring\"))) = &#123;__CFConstantStringClassReference,0x000007c8,\"this is a block\",15&#125;; 整体捋下思路，block的结构简单理解为： 1234Block是一个impl结构 -&gt;__block_impl -&gt; isa，表明是OC对象 | -&gt; func函数指针,封装block的代码 | -&gt; 描述 总结: block的本质就是封装了函数调用以及函数调用环境的OC对象 带参数的block12345void (^block)(int, int) = ^(int a, int b)&#123; NSLog(@\"%d,%d\",a,b);&#125;;int c= 20, d = 10;block(c, d); 翻译为CPP代码: 123456//初始化block对象void (*block)(int, int) =&amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA));int c= 20, d = 10;//执行blockblock-&gt;FuncPtr(block, c, d); 各个结构的定义如下： 123456789101112131415161718192021//block的底层结构struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;//block内的函数指针static void __main_block_func_0(struct __main_block_impl_0 *__cself, int a, int b) &#123; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_3e8a17_mi_0,a,b);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; block变量捕获 在OC中变量的类型主要使用三种, 分别是auto、static、全局变量, 其中auto和static修饰的是局部变量 对这三种类型的变量, block在使用使用时, 会有不同的捕获方式 auto变量捕获(值捕获)示例代码： 12345int age = 20;void (^block)(void) = ^&#123; NSLog(@\"%d\",age);&#125;;block(); 翻译为CPP代码 123int age = 20;void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, age));block-&gt;FuncPtr(block); 各个结构体的定义 123456789101112131415161718192021struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; //多了一个成员变量 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123; //age的赋值是通过构造函数初始化列表完成的 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int age = __cself-&gt;age; // bound by copy 取出block结构内的age NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_82fbf9_mi_0,age);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 可以看出，block对于auto变量会值不会，通过在block底层结构中增加捕获的变量定义。 static变量捕获(指针捕获)示例代码： 123456static int age = 20;void (^block)(void) = ^&#123; NSLog(@\"%d\",age); //输出25&#125;;age = 25;block(); 翻译为CPP代码 12345static int age = 20;//将age的地址传入block的构造函数中void (*block)(void) = &amp;__main_block_impl_0(__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;age);age = 25;block-&gt;FuncPtr(__block_impl *)block); 各个结构体的定义如下： 12345678910111213141516struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int *age; //定义为指针类型 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int *_age, int flags=0) : age(_age) &#123; //构造列表是初始化age指针 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int *age = __cself-&gt;age; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_hs_21g8l7ps1p9cmwpn1nbnfn700000gn_T_main_1d503d_mi_0,(*age)); &#125; block中使用全局变量(不会捕获)全局变量不捕获 总结 点点滴滴1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m","tags":[{"name":"Block","slug":"Block","permalink":"http://yoursite.com/tags/Block/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Block","slug":"IOS/Block","permalink":"http://yoursite.com/categories/IOS/Block/"}]},{"title":"学习runtime的参考文档","date":"2019-09-19T03:38:11.000Z","path":"wiki/IOS/Runtime/reffer/","text":"本文记录学习runtime过程中，有用的文档。 学习过的文档 小码哥iOS学习笔记 小码哥iOS学习笔记第一天: Objective-C的本质 小码哥iOS学习笔记第二天: OC对象的分类 通用文档 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"}]},{"title":"NSOperation","date":"2019-09-17T02:35:49.000Z","path":"wiki/IOS/多线程/NSOperation/","text":"NSOperation类文档学习记录 操作依赖依赖可以控制操作执行的顺序，相关函数： addDependency removeDependency 当依赖的operation全部为完成状态时，operation才能为ready的状态。当最后一个依赖完成后，operation的状态变为ready状态。 依赖不区分operation是完成了还是取消了。 KVO属性KVO属性包括： isCancelled isAsynchronous isExecuting isFinished isReady dependencies queuePriority completionBlock 多线程安全多线程调用NSOperation的方法时安全的，不需要加锁。子类的自定义方法需要考虑多线程问题。 异步VS同步操作可以手动执行、也可以添加到queue中执行。 手动执行（直接调用start方法），分为同步operation和异步operation ，同步在当前线程立即执行。异步在新的线程执行任务。 如果操作在队列中执行，一般定义为同步的，队列不关注asynchronous属性，总是在一个单独的线程中调用start方法。所有没有理由设计为异步的。 子类化非并发队列：重写 main方法。并发队列：需要重写start、 asynchronous、executing、finished方法。 注意是否重写main决定了是否是并发操作。 下面是子类化的要点： 在并发队列中，start方法负责异步开始操作。 start方法中需要通过KVO更新operation的executing状态为YES。 operation完成或取消后，并发队列必须通过KVO更新isExecuting为NO 和 isFinished为YES。如果是取消，也需要更新isFinished状态为YES。 operation 只有完成了，才能从queue中移除。 同时需要重写 executing、finished属性（KVC）。 start方法需要检查是否operation被取消了。 如果定制了依赖，需要KVO isReady属性。 状态管理： isReady，一般不用管理，依赖的时候处理。 isExecuting，替换了start方法，一定要替换isExecuting方法，并在start开始的时候发出KVO isFinished，替换了start方法，一定要替换isFinished方法。operation完成或取消，发出KVO isCancelled，不需要发出KVO 响应取消 一旦将operation添加到queue中，queue就掌管了operation。你可以通过调用operation的cancell方法取消，或者通过queue的cancelAllOperations取消。 执行中的任务并不会立马取消， 你必须显式的检测状态，需要的时候取消。","tags":[{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"多线程","slug":"IOS/多线程","permalink":"http://yoursite.com/categories/IOS/多线程/"}]},{"title":"GCD源码理解","date":"2019-09-17T02:35:49.000Z","path":"wiki/IOS/多线程/GCD_Source/","text":"GCD源码理解 GCD理解","tags":[],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"多线程","slug":"IOS/多线程","permalink":"http://yoursite.com/categories/IOS/多线程/"}]},{"title":"多线程参考资料","date":"2019-09-17T02:35:49.000Z","path":"wiki/IOS/多线程/referr/","text":"记录读过的文章 读过的文章 iOS 多线程：『NSOperation、NSOperationQueue』详尽总结 并发编程：API 及挑战 深入理解RunLoop iOS 多线程：『RunLoop』详尽总结 需要读的 Concurrency Programming Guide 浅谈iOS多线程(源码) 底层并发 API","tags":[{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"多线程","slug":"IOS/多线程","permalink":"http://yoursite.com/categories/IOS/多线程/"}]},{"title":"NSOperaionQueue 源码学习","date":"2019-09-17T02:35:49.000Z","path":"wiki/IOS/多线程/NSOperaionQueue/","text":"记录NSOperaionQueue的理解","tags":[{"name":"NSOperation","slug":"NSOperation","permalink":"http://yoursite.com/tags/NSOperation/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"多线程","slug":"IOS/多线程","permalink":"http://yoursite.com/categories/IOS/多线程/"}]},{"title":"定积分","date":"2019-09-10T01:07:12.000Z","path":"wiki/数学知识/高数/定积分/","text":"记录定积分的学习记录，方便以后复习 定积分的概念和性质定积分问题举例 曲边梯形的面积 $A=\\lim \\limits_{\\lambda \\to 0} {\\sum_{i=1}^n{f(\\xi) \\Delta x}}$ 变速直线运动的路程 定义： 设函数f(x)在[a,b]上有界，在[a,b]中任意插入若干个分点 $$a=x_0 &lt; x_1&lt;x_2…&lt;x_{n-1}&lt;x_n = b$$ 把区间[a,b]分成n个小区间$$[x_0,x_1],[x_1,x_2],…,[x_{n-1}]$$各个小区间的长度依次为$$\\Delta x_1 = x_1-x_0,\\Delta x_2 = x_2-x_1 … \\Delta x_n = x_n - x_{n-1}$$在每个小区间上任意去一点$\\xi$,作为函数值$f(\\xi)$与小区间长度$\\Delta x_i$的乘积 $f(\\xi_i) \\cdot \\Delta x_i$，并作出和$$S = \\sum_{i=1}^n{f(\\xi_i) \\cdot \\Delta x_i}$$如果和的极限存在，且闭区间[a,b]的分法及点$\\xi_i$的取法无关，那么这个极限I为函数f(x)在区间[a,b]上的定积分，记作$\\int_a^b{f(x)dx}$，即$$\\int_a^b{f(x)dx} = I = \\lim_{\\lambda \\to 0}{\\sum_{i=1}^n{f(\\xi_i) \\Delta x_i}}$$其中[a,b]叫做积分区间。a叫做积分下限，b叫做积分上限 定积分的值只与被积函数和积分区间有关，而与积分变量和记法无关。 定理1 设f(x)在区间[a,b]上连续，则f(x)在[a,b]上可积定理2 设f(x)在区间[a,b]上有界，且只有有限个剪短点，则f(x)在[a,b]上可积 牛顿-莱布尼茨公式 微积分基本公式：如果函数F(x)是连续函数f(x)在区间[a,b]上的一个原函数，那么$$\\int_a^b{f(x)dx}=F(b)-F(a)$$ 有用的公式$1^2+2^2+..+n^2= \\frac{1}{6}n(n+1)(2n+1)$","tags":[{"name":"高数","slug":"高数","permalink":"http://yoursite.com/tags/高数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"高数","slug":"数学知识/高数","permalink":"http://yoursite.com/categories/数学知识/高数/"}]},{"title":"刷脸登录调研","date":"2019-09-03T04:11:35.000Z","path":"wiki/编程理论/人脸登录/faceLogin/","text":"本文调研人脸登录的实现思路。 概述人脸登录包括两个流程：人脸注册、人脸查找。 人脸注册 刷脸登录（查找人脸的过程） 思考 非常像的双胞胎能识别出来吗？ 参考资料 微信小程序使用face++实现人脸识别登录注册 face++文档中心 使用 face++ API 实现人脸识别，刷脸登陆和活体检测（张张嘴，眨眨眼）","tags":[],"categories":[{"name":"编程理论","slug":"编程理论","permalink":"http://yoursite.com/categories/编程理论/"},{"name":"人脸登录","slug":"编程理论/人脸登录","permalink":"http://yoursite.com/categories/编程理论/人脸登录/"}]},{"title":"不定积分","date":"2019-08-29T01:07:12.000Z","path":"wiki/数学知识/高数/four_indefinite_integral/","text":"记录导数与微分的主要知识点， 不定积分的概念和性质定义1：如果在区间I上，可导函数F(x)的导函数为f(x),即对任意x属于I都有：$$F’(x)=f(x) 或dF(x)=f(x)dx$$那么函数F(x)就称为f(x)（或f(x)dx）在区间I上的一个原函数。 原函数存在定理：如果函数f(x)在区间I上连续，那么在区间I上存在可导函数F(x),使对任一x属于I都有$$F’(x)=f(x)$$简单的说，连续函数一定有原函数。 表达式 F(x) + C 可以表示f(x)的任意一个原函数。 定义2 在区间I上，函数f(x)的带有任意常数项的原函数称为f(x)(或f(x)dx)在区间I上的不定积分，记作：$$\\int{f(x)dx}$$其中记号$\\int$称为积分号，f(x)称为被积函数，f(x)dx称为被积表达式，x称为积分变量。 因而不定积分$\\int{f(x)dx}$可以表达f(x)的任意一个原函数。 基本积分表 不定积分的性质 性质1 设函数f(x)及 g(x)的原函数存在，则$$\\int{[f(x)+g(x)]dx} = \\int{f(x)dx} + \\int{g(x)dx}$$ 性质2 设函数f(x)的原函数存在，k为非零常数，则$$\\int{kf(x)dx}=k\\int{f(x)dx}$$ 换元积分法把复合函数的微分法反过来，用于求不定积分，利用中间变量的代换，得到符合函数的积分，称为积分换元法。 定理1 设f(u)具有原函数，u=$\\psi$(x)可导，则有换元公式$$\\int{f[\\psi (x)]\\psi ‘(x)dx} = [\\int{f(u)du}]_{u=\\psi (x)}$$ 如果应用换元法求不定积分呢？设要求$\\int{g(x)dx}$，如果g(x)可以化为g(x)= $f[\\psi (x)]\\psi ‘(x)$的形式，那么$$\\int {g(x)dx}= \\int{f[\\psi (x)]\\psi ‘(x)dx}=\\int{f(u)du}$$","tags":[{"name":"不定积分","slug":"不定积分","permalink":"http://yoursite.com/tags/不定积分/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"高数","slug":"数学知识/高数","permalink":"http://yoursite.com/categories/数学知识/高数/"}]},{"title":"第一章 函数与极限","date":"2019-08-25T01:07:12.000Z","path":"wiki/数学知识/高数/函数与极限/","text":"本文记录《函数与极限》章节中，比较重要的内容，以便以后复习。 第二节 数列的极限定义： 设{$x_n$}为一数列，如果存在常数a，对于任意给定的正数$\\epsilon$ (不论它多么小)，总存在正整数N，使得，当n&gt;N时，不等式$$|x_n-a|&lt;\\epsilon$$都成立，那么就称常数a是数列{$x_n$}的极限，或者称数列{$x_n$}收敛于a，记为：$$\\lim \\limits_{n \\to \\infty} {x_n} = a$$ 如果不存在这样的常数a，就说数列没有极限，或者说数列是发散的。 等式中的绝对值表达了两数之差，说明$x_n$无限趋近a含义,也就是两项非常的接近。 收敛数列的性质 定理一（极限的唯一性） 如果数列{$x_n$}收敛，那么他的极限唯一 定理二（收敛数列的有界性）如果数列{$x_n$}收敛，那么数列{$x_n$}一定有界。 定理三（收敛数列的保号性）如果$\\lim \\limits_{n \\to \\infty} {x_n} = a$，且a&gt;0，那么存在正整数N，当n&gt;N时，都有$x_n$&gt;0 定理四（收敛数列与其子数列间的关系）如果数列{$x_n$}收敛于a，那么他的任一子数列也收敛，且极限也是a。 第三节 函数的极限讨论函数极限时，自变量变化的情形有两种情况： 自变量x任意的接近于有限值$x_0$ ，$x \\to x_0$ 自变量x的绝对值无限大，$x \\to \\infty$ 函数极限定义1 设函数f(x)在点$x_0$的去心领域内有定义，如果存在常数A，对于任意给定的正数$\\epsilon$(不论多么小)，总存在正数$\\delta$,使得当x满足不等式0&lt;|x-$x_0$|&lt;$\\delta$时，对应的函数值f(x)都满足不等式$$|f(x)-A|&lt;\\epsilon$$那么常数A就叫做函数f(x)当x-&gt;$x_0$时的极限记作：$$\\lim_{x-&gt;x_0}f(x)=A$$ 函数极限的定义就是规定了定义域，得出值域的满足的条件 。 函数极限的性质： 极限的唯一性 局部有界性 局部保号性 函数极限和数列极限的关系（函数有极限，数列也有极限） 第四节 无穷小和无穷大定义： 极限为零，那么称函数为当x-&gt;$x_0$时的无穷小 下面的定理说明无穷小与函数极限的关系： 定理1 ： 在自变量的同一变化过程$x-&gt;x_0$中，函数f(x)具有极限的充分必要条件是f(x) = A + $\\alpha$,其中 $\\alpha$是无穷小。 下面是无穷大和无穷小的关系： 定理2： 在自变量的同一变化过程中，如果f(x)为无穷大，那么$\\frac{1}{f(x)}$为无穷小，如果f(x)为无穷小，且f(x)!=0 .那么$\\frac{1}{f(x)}$为无穷大。 充分性：由条件推断出命题成立。 必要性： 由命题成立推断出条件的成立。 第五节极限运算法则定理1 两个无穷小的和是无穷小 定理2 有界函数与无穷小的乘积是无穷小 推论1 常数与无穷小的乘积是无穷小 推论2 有限个无穷小的乘积是无穷小 定理3 当$x \\to x_0 （或 x \\to \\infty）$ 如果limf(x)=A,limg(x)=B,那么 lim[f(x)+g(x)]=limf(x)+limg(x)=A+B lim[f(x)g(x)]=limf(x)limg(x)=AB lim$\\frac{f(x)}{g(x)}$=$\\frac{limf(x)}{limg(x)}=\\frac{A}{B}$，其中B不等于0 定理4 数列和函数有类似定理3的性质 定理5 $\\upsilon(x)&gt;=\\psi$(x),而lim$\\upsilon(x)$=A,lim$\\psi(x)$=B,那么A&gt;=B 注意： 求极限时，如果分母为0，需要化为不为0 定理6 复合函数的极限运算法则，设函数y=f[g(x)]是由函数u=g(x)与函数y=f(u)复合而成，f[g(x)]在点$x_0$的某个去心领域内有定义，$\\lim \\limits_{x \\to x_0}{g(x)}=u_0$ , $\\lim \\limits_{u \\to u_0} {f(u)}=A$,且存在$\\delta_0&gt;0$，当x属于（$x_0,\\delta_0$）时，有g(x)!=$u_0$,则$$\\lim \\limits_{x \\to x_0} {f[g(x)]} = \\lim \\limits_{u \\to u_0} {f(u)}=A $$ 第六节 极限存在准则、两个重要极限准则1 ，如果数列{$x_n$}、{$y_n$}、{$z_n$}满足下面条件： $$y_n&lt;=x_n&lt;=$z_n$$ 且$\\lim_ \\limits{n-&gt;\\infty}y_n=a,\\lim_ \\limits{n-&gt;\\infty}z_n=a$ 那么数列{$x_n$}的极限存在，且$\\lim \\limits_{n-&gt;\\infty}x_n=a$ 这个准则称为夹逼准则。 使用夹逼准则计算第一个重要的极限: $\\lim_{x \\to 0}{\\frac{\\sin x}{x} }=1$ 准则2 单调有界必有极限。 一对重要的极限公式：$$\\lim \\limits_{n-&gt;\\infty}(1+\\frac{1}{n})^n=e$$ $$\\lim \\limits_{n-&gt;\\infty}(1-\\frac{1}{n})^n= \\frac{1}{e}$$ 柯西极限存在准则 数列{$x_n$} 收敛的充分必要条件是：对于任意给定的正数$\\epsilon$,存在正整数N，使得m&gt;N, n&gt;N时，有： $$|x_n-x_m|&lt;\\epsilon$$ 上面公式说明两项的差趋于无穷小。 第七节：无穷小的比较上面的章节说明两个无穷小的和、差、商仍旧是无穷小，但是两个无穷小的商，确出现不同的结果。 无穷小定义： 如果函数f(x)当$x \\to x_0 （或 x \\to \\infty）$时极限为零，那么称函数f(x)为当$x \\to x_0 （或 x \\to \\infty）$时的无穷小。 定理1 在自变量的同一变化过程$x \\to x_0 （或 x \\to \\infty）$中，函数f(x)具有极限A的充分必要条件是f(x)=A+a,其中a是无穷小。 定义(更小的阶数更高) ： 如果$lim \\frac{\\beta}{\\alpha}$ = 0，那么就说$\\beta$是比$\\alpha$高阶的无穷小，记作$\\beta$=o($\\alpha$) 如果$lim \\frac{\\beta}{\\alpha}$ = $\\infty$，那么就说$\\beta$是比$\\alpha$低阶的无穷小 如果$lim \\frac{\\beta}{\\alpha}$ = c，那么就说$\\beta$,$\\alpha$同阶的无穷小 如果$lim \\frac{\\beta}{\\alpha^k}$ =c，那么就说$\\beta$是$\\alpha$的k阶的无穷小 如果$lim \\frac{\\beta}{\\alpha}$ = 1，那么就说$\\beta$、$\\alpha$时等阶无穷小 记作$\\alpha \\sim \\beta$ 第八节 函数的连续性和间断性定义： 设函数y=f(x)在点$x_0$的某一领域内有定义，如果： $$\\lim \\limits_{\\bigtriangleup x \\to 0}\\bigtriangleup y = \\lim_{\\Delta x \\to 0}{[f(x_{x0})]}0$$ 那么就称函数y=f(x)在点$x_0$连续。 下面是连续性定义中增量的示意图： 连续性的也可以描述为： 设函数y=f(x)在点$x_0$的某一领域内有定义，如果$$lim_{x \\to x_0} {f(x)} = f(x_0)$$那么就称函数f(x)在点$x_0$连续。 函数的间断点： 设函数f(x)在点$x_0$的某个去心领域内有定义，在此前提下，如果函数f(x)有下列三种情形之一： 在$x=x_0$没有定义 虽在$x=x_0$有定义，但$\\lim_{x \\to x_0}{f(x)}$不存在 虽在$x=x_0$有定义，且$\\lim_{x \\to x_0}{f(x)}$存在，但是不等于$f(x_0)$ 那么函数f(x)在点$x_0$w为不连续，且点$x_0$称为函数f(x)的不连续点或间断点。 第九节 连续函数的运算与初等函数的连续性一. 连续函数的和、差、积、商的连续性 连续函数的和、差、积、商的连续性 连续函数的和、差、积、商（分母不为0）是连续的 二 反函数和复合函数的连续性 定理二 如果函数f(x) 是单调增加且连续，那么反函数也单调增加且连续 定理三 复合函数的两个函数连续，复合后也连续。 三 初等函数的连续性 定理四 所有初等函数都是连续的。 一组重要的公式 $\\lim_{x \\to 0}{\\frac{\\log_\\alpha{(1+x)} }{x{ { = \\lim_{x \\to 0}{\\log_{\\alpha}{(1+x)}^{\\frac{1}{x} }} = \\log_{\\alpha}e = \\frac{1}{\\ln{\\alpha} }$ $\\lim_{x \\to 0}{\\frac{\\alpha^x - 1}{x} }$ 令 $\\alpha^x - 1 = t$，则 $x=\\log_{\\alpha}{(1+t)}$,当x $\\to$0， t $\\to$0， 于是： $\\lim_{x \\to 0}{\\frac{\\alpha^x - 1}{x} }$ = $\\lim_{t \\to 0}{\\frac{t}{\\log_{\\alpha}{(1+t)} }} = \\log_{\\alpha}{e} = \\frac{1}{\\ln{\\alpha} }$ $\\lim_{x \\to 0}{\\frac{(1+x)^{\\alpha}-1}{x} } = \\alpha$ 第十节 闭区间上连续函数的性质定理1 有界性与最大值最小值定理，在闭区间上连续的函数在该区间上有界，且一定能取得他的最大值和最小值。 零点定理： 设函数f(x)在闭区间【a,b】上连续，且f(a)与f(b)异号，则在开区间(a,b)内至少有一点$\\epsilon$， 使 $$f(\\epsilon) = 0$$ 定理2（介值定理） 设函数f(x)在闭区间【a,b】上连续，且在这区间的端点取不同的函数值，$$f(a)=A,f(b)=B$$则对于A于B之间的任意一个数C，在开区间（a,b）内至少有一点$\\epsilon$,使得 $$f(\\epsilon) = C $$ 有用的公式 $x^2-9=(x+3)(x-3)$ $1+\\frac{1}{2}+\\frac{1}{2^2}+…+\\frac{1}{2^{n-1} }=\\frac{1-\\frac{1}{2^n} }{1-\\frac{1}{2} }$ 二项式定理 $(x+y)^n = \\binom {n}{0}x^ny^0 + \\binom {n}{1}x^{n-1}y^1 +\\binom {n}{2}x^{n-2}y^2 + …+ \\binom {n}{n-1}x^1y^{n-1} + \\binom {n}{n}x^0y^n$,其中$\\binom {n}{k}$为二项系数，等于$\\frac{n!}{k!(n-k)!}$. $\\lim \\limits_{n-&gt;\\infty}(1+\\frac{1}{n})^n=e=2.718281$ （二项式展开可证明） $\\lim \\limits_{x \\to \\infty}(1-\\frac{1}{x})^x = \\frac{1}{e}$ $\\lim_{x \\to 0} {\\frac{\\log_a(1+x)}{x} }=\\frac{1}{\\ln a}$ （将 $\\frac{1}{x}提到指数位置，$利用公式4、换底公式 可以证明） $\\lim \\limits_{x \\to 0}{\\frac{a^x -1}{x} } = \\ln a$ (替换 $a^x -1 =t $，利用公式5可证明) $\\lim \\limits_{x \\to 0}{\\frac{(1+x)^a -1 }{x} } = a$ $\\ln{(1+x)} \\sim x (x \\to 0)$(等价无穷小) $e^x-1 \\sim x (x \\to 0)$(等价无穷小) $(1+x)^a-1 \\sim ax (x \\to 0)$ (等价无穷小)","tags":[{"name":"高数","slug":"高数","permalink":"http://yoursite.com/tags/高数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"高数","slug":"数学知识/高数","permalink":"http://yoursite.com/categories/数学知识/高数/"}]},{"title":"第二章导数与微分","date":"2019-08-25T01:07:12.000Z","path":"wiki/数学知识/高数/导数与微分/","text":"记录导数与微分的主要知识点 第一节、导数的概念导数的引例 速度问题 $$\\nu = \\lim_{t \\to t_0}\\frac{f(t) - f(t_0)}{t-t_0}$$ 这时就把极限值$\\nu$称为质点在时刻$t_0$的瞬时速度 切线问题 $$k = \\lim_{t \\to x_0}\\frac{f(x) - f(x_0)}{x-x_0}$$ 那么k就是切线的斜率 。下面是切线的示意图： 定义： 设函数y=f(x)在点$x_0$的某个领域内有定义，当自变量x在$x_0$处取得增量$\\Delta x$(点$x_0 + \\Delta x$ 仍在该领域内)时，相应的，因变量取得增量$\\Delta y = f(x_0 + \\Delta x) - f(x_0)$；如果 $\\Delta y$ 与 $\\Delta x$之比（当 $\\Delta x \\to 0$ 时）的极限存在，那么称函数 y= f(x)在点$x_0$处可导，并称这个极限为函数y=f(x)在点$x_0$处的导数，即为f’($x_0$) ,即 $$f’(x_0) = \\lim_{\\Delta x \\to 0}{\\frac{\\Delta y}{\\Delta x} } = \\lim_{\\Delta x \\to 0} \\frac{f(x_0+\\Delta x)-f(x_0)}{\\Delta x}, 也可以记作 y’, \\frac{dy}{dx} 或\\frac{df(x)}{dx}$$ 也可以写作 ： $$f’(x_0) = \\lim_{h \\to 0}{\\frac{f(x_0+h)-f(x_0)}{h} }$$或$$f’(x_0)=\\lim_{x \\to x_0} \\frac{f(x)- f(x_0)}{x-x_0}$$ 导数的意义： 导数的概念就是函数变化率这一概念的精确描述。因变量增量与自变量增量之比$\\frac{\\Delta y}{\\Delta x}$ 是因变量y再以$x_0$和$x_0+\\Delta x$为端点的区间上的平均变化率，而导数$f’(x_0)$则是因变量y在点$x_0$处的变化率。他反应了因变量随自变量的变化而变化的快慢程度。 下面是求导的示例： 常数的导数： $C’ = 0$ ， 常数的导数为0 幂函数的导数 ：$(x^n)’=\\begin{cases}0, &amp; \\text{n=1} \\\\n x^{n-1}, &amp; n&gt;1\\end{cases}$ sinx的导数 $(\\sin x)’=\\cos x$、 $(\\cos x)’ = - \\sin x$ 指数函数的导数： $(a^x)’ = \\lim_{h \\to 0} {\\frac{ {\\alpha}^{x+h} - {\\alpha}^x}{h} } = {\\alpha}^x \\lim_{h \\to 0} \\frac{ {\\alpha}^h - 1}{h} = a^{x} \\ln{a} $ 对数函数的导数：$(\\log_ x)’ = \\frac{1}{x \\ln a}$$\\begin{equation} \\begin{split}f’(x)&amp;=\\lim_{h \\to 0} \\frac{\\log_{\\alpha}{(x+h)} - \\log_{\\alpha}{x} }{h}\\\\&amp;=\\lim_{h \\to 0}{\\frac{1}{h} } \\log_{\\alpha}{\\frac{x+h}{x} } = \\lim_{h \\to 0}{\\frac{1}{x} } \\cdot \\frac{x}{h} \\log_{\\alpha}{(1+\\frac{h}{x})}\\\\&amp;=\\frac{1}{x} \\lim_{h \\to 0}{\\frac{\\log_{\\alpha}{(1+\\frac{h}{x})} }{\\frac{h}{x} } }\\\\&amp;=\\frac{1}{x \\cdot \\ln{\\alpha} }\\end{split}\\end{equation}$ 导数的几何意义：函数y=f(x)在$x_0$处的导数表示曲线y=f(x）在点M处的切线的斜率。 切线方程： $y-y_0 = f’(x_0)(x-x_0)$ 法线方程： $y-y_0 = - \\frac{1}{f’(x_0)}(x-x_0)$ 函数的可导性和可连续性的关系： 如果y=f(x)在点x处可导，那么函数在该点x处必连续。 $\\frac{\\Delta y}{\\Delta y} = f’(x)+\\alpha \\Rightarrow \\Delta y = f’(x) \\Delta x +\\alpha \\Delta x$ 连续不一定可导 第二节、函数的求导法则一、 函数的和、差、积、商的求导法则 定理1 如果函数$\\mu$=$\\mu(x)$及$\\nu(x)$=$\\nu(x)$都在点x具有导数，那么它们的和、差、积、商（除分母为零的点外）都在点x具有导数，且 [ $\\mu(x)$ + $\\nu(x)]’ = \\mu(x)’ + \\nu(x)’ $ $[\\mu(x)\\nu(x)]’ = \\mu(x)’\\nu(x) + \\mu(x)\\nu(x)’$ $[\\frac{\\mu(x)}{\\nu(x)}]’ = \\frac{\\mu(x)’\\nu(x)- \\mu(x)\\nu(x)’}{\\nu^2(x)}$ 其中$\\nu(x)$!=0 定理2（反函数求导法则）:如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：$$[f^{-1}(x)]’ = \\frac{1}{f’(y)}或 \\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy} }$$ 简单的说：反函数的导数等于直接函数导数的倒数。 示例： 设x = sin y 为直接函数，则 y = arcsin x 是它的反函数。计算过程如下： $\\begin{equation}\\begin{split}(arcsin x)’&amp; =\\frac{1}{(sin y)’} = \\frac{1}{cos y}\\\\&amp;又:cos y = \\sqrt {1- sin^2y} = \\sqrt{1-x^2}\\\\&amp;所以:(arcsin x)’ = \\frac{1}{\\sqrt{1- x^2} }\\\\\\end{split}\\end{equation}$​ 定理3（复合函数求导法则）如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：$$\\frac{dy}{dx}=f’(u) \\cdot g’(x) 或 \\frac{dy}{dx}=\\frac{dy}{du} \\cdot \\frac{du}{dx}$$ 第二节求导法则总结一、 导数公式和基本求导法则 常用导数公式 常用导数公式 (1). $(C)’ = 0 $ (2). $(x^{\\mu})’ = {\\mu}x^{\\mu -1} $ (3). $(\\sin x)’ = \\cos x $ (4). $(\\cos x)’ = - \\sin x $ (5). $(\\tan x)’ = \\sec^{2} x $ (6). $(\\cot x)’ = - \\csc^{2} x $ (7). $(\\sec x)’ = - \\sec{x} \\tan{x} $ (8). $(\\csc x)’ = - \\csc{x} \\cot{x} $ (9). $({\\alpha}^x)’ = {\\alpha}^x \\ln{\\alpha} $ (10). $({e}^x)’ = e^x $ (11). $(\\log_{\\alpha}{x})’ = \\frac{1}{x \\ln{\\alpha} } $ (12). $(\\log_{\\alpha}{x})’ = \\frac{1}{x \\ln{\\alpha} } $ (13). $(\\arcsin x)’ = \\frac{1}{\\sqrt{1-x^2} } $ (14). $(\\arccos x)’ = - \\frac{1}{\\sqrt{1-x^2} } $ (15). $(\\arctan x)’ = \\frac{1}{1 + x^2} $ (16). $(arccot x)’ = - \\frac{1}{1 + x^2} $ 二、 函数的和、差、积、商的求导法则 设$\\mu = \\mu (x)$，$\\nu = \\nu (x)$ 都可导，则 函数的和、差、积、商的求导法则 函数的和、差、积、商的求导法则 (1). $ (\\mu + \\nu)’ = {\\mu}’ + {\\nu}’ $ (2). $ (C \\mu)’ = C{\\mu}’ $ (3). $ (\\mu \\nu)’ = {\\mu}’ \\nu + \\mu {\\nu}’ $ (4). $ (\\frac{\\mu}{\\nu})’ = \\frac{ {\\mu}’ \\nu + \\mu {\\nu}’} } }\\nu}^2} $ 三、 反函数求导法则 如果函数x=f(y)在区间$I_y$内单调、可导且f’(y) $\\ne$ 0，那么他的反函数y=$f^{-1}(x)$在区间$I_x$内也可导，且：$$[f^{-1}(x)]’ = \\frac{1}{f’(y)}或 \\frac{dy}{dx}=\\frac{1}{\\frac{dx}{dy} }$$ 四、 复合函数求导法则 如果u=g(x)在点x可导，而y=f(u)在点u=g(x)可导，那么符合函数y=f[g(x)]在点x可导，且其导数为：$$\\frac{dy}{dx}=f’(u) \\cdot g’(x) 或 \\frac{dy}{dx}=\\frac{dy}{du} \\cdot \\frac{du}{dx}$$ 第三节、高阶导数没有学习 第五节、函数的微分定义： 设函数 y= f(x)在某区间内有定义，$x_0$及$x_0 + \\Delta x$在这区间内，如果函数的增量： $$\\Delta y = f(x_0 + \\Delta x) - f(x_0)$$ 可表示为： $$\\Delta y = A \\Delta x + o(\\Delta x)$$ 其中A是不依赖于$\\Delta x$的常数，那么称函数 y = f(x)在点 $x_0$处是可微的，而$A \\Delta x$叫做函数 y = f(x)在点$x_0$相应于自变量增量$\\Delta x$的微分，记作 dy 即 $$dy = A \\Delta x$$ $$dy = f’(x_)) \\Delta x$$ 微分的理解：相对于自变量的增量，因变量的变化，这个变化时微小的，理解为微分。 微分和$\\Delta y$的关系：$$ \\Delta y = dy + o(dy) $$ 微分可以近视代替因变量的增量 。微分是 $\\Delta y$的主部。 通常把自变量x的增量$\\Delta x$称为自变量微分（微小的数），记作dx，于是函数y=f(x)的微分又可记作$$dy = f’(x)dx$$ 微分的几何意义： dy 是曲线的切线上点的众坐标的相应增量。非线性函数的局部线性化。 从图中可以看出，dy = QP。当$\\Delta y$是曲线y = f（x） 上的点的众坐标的增量， dy是曲线的切线上点的众坐标的相应的增量。当$\\Delta x$很小时，$\\Delta y - dy$比 $\\Delta x$小的多，因此在点M的邻近，我们可以使用切线段来近视代替曲线段。 这就是非线性函数的局部线性化。 微分公式总结暂无","tags":[{"name":"高数","slug":"高数","permalink":"http://yoursite.com/tags/高数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"高数","slug":"数学知识/高数","permalink":"http://yoursite.com/categories/数学知识/高数/"}]},{"title":"第二章 随机变量及其分布","date":"2019-08-22T02:07:12.000Z","path":"wiki/数学知识/概率论和数理统计/第二章 随机变量及其分布/","text":"第二章学习记录。 随机变量定义： 设随机实验的样本空间为S={e},X=X(e)是定义在样本空间S上的实值单值函数，成X=X(e)为随机变量。 离散型随机变量及其分布规律有些随机变量，它全部可能取到的值是有限个或可列无限多个，这种随机变量称为离散型随机变量。 设离散型随机变量X多有可能的取值为$x_k$(k=1,2,…),X取各个可能值的概率，即事件{X=$x_k$}的概率，为$$P\\{X=x_k\\} = p_k,k=1,2,….$$ 0-1分布设随机变量X只可能取0与1两个值，它的分布律是：$$P\\{X=k\\}=p^k(1-p)^{(1-k)}. k=0,1 (0&lt;p&lt;1)$$则称X服从以p为参数的0-1分布或两点分布。 伯努利实验、二项分布设实验E只有两种可能，A 即 $\\overline A$,则称E为伯努利实验，此时P(A)= p,$P(\\overline A)=1-p$,将E独立重复的进行n次，则称这一串重复的独立实验为n重伯努利实验。 以X表示n重伯努利实验中事件A发生的次数，X是一个随机变量，我们求它的分布规律。X所有可能的取值为 0，1，2，…,n 。由于各次实验是相互独立的，因此事件A在指定的k次实验中发生，在其他n-k次实验中A不发生的概率为 $$pppp….pp(1-p)(1-p)….(1-p)=p^k(1-p)^{n-k}$$ 这种指定的方式共有$\\binom {n}{k}$种，他们是两两互不相容的，故在n次实验中A发生k次的概率为$\\binom {n}{k}p^k(1-p)^{n-k}$,记q = 1-p，即有： $$P\\{X=k\\}=\\binom{n}{k}p^kq^{n-k},k=0,1,2,…,n\\tag{2.6}$$ 显然： $$\\sum_{k=0}^{n}P\\{X=k\\}=\\sum_{k=0}^{n}\\binom{n}{k}p^kq^{n-k}=(p+q)^n=1$$ 注意到$\\binom{n}{k}p^kq^{n-k}$刚好是二项式$(p+q)^n$的展开式中出现$p^k$的那一项，我们称随机变量X服从参数n，p的二项分布，并记为$X\\sim b(n,p)$ 特别的，当n=1时，二项分布化为： $$P\\{X=k\\}=p^kq^{1-k},k=0,1$$ 就是0-1分布。 泊松分布设随机变量X所有可能的取值为0，1，2…，取而代之的概率为：$$P\\{X=k\\}=\\frac{\\lambda^ke^{-\\lambda}}{k!},k=0,1,2….$$其中$\\lambda$&gt;0是常数，则称X服从参数为$\\lambda$的泊松分布，记为X$\\sim\\pi(\\lambda)$ 泊松定理：设$\\lambda$&gt;0是一个常数，n是任意正整数，设$np_n=\\lambda$，则对于人一个固定的非负整数k，有： $$\\lim_{n\\to \\infty}\\binom{n}{k}p_n^k(1-p_n)^{n-k}=\\frac{\\lambda^ke^{-\\lambda}}{k!}$$ 随机变量的分布函数分布函数：设X是一个随机变量，x是任意实数，函数： $$F(x)=P{X&lt;=x}$$称为X的分布函数。 如果将X看成是数轴上的随机点左边，那么，分布函数F（x）在x出的函数值就表示X落在区间$(-\\infty,x)$上的概率。 分布函数F（x）满足的基本性质： 不减函数 0-1 连续型随机变量及其概率密度如果对于随机变量X的分布函数F(x)，存在非负函数f(x),对于任意实数x有 $$F(x)=\\int_{-\\infty}^xf(t)dt\\tag{4.1}$$则称x为连续型随机变量，其中函数f(x)称为X的概率密度函数，简称概率密度 三种重要的连续型随机变量 均匀分布 指数分布 正态分布 随机变量的函数分布","tags":[{"name":"概率论","slug":"概率论","permalink":"http://yoursite.com/tags/概率论/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"概率论和数理统计","slug":"数学知识/概率论和数理统计","permalink":"http://yoursite.com/categories/数学知识/概率论和数理统计/"}]},{"title":"Choosing a Specific Interface Style for Your iOS App（选择明确的界面样式）","date":"2019-08-19T02:07:12.000Z","path":"wiki/IOS/黑夜模式/选择明确的样式/","text":"Adopt a specific interface style for your views, view controllers, or app when it is inappropriate to support both light and dark variants. 当你的APP不适合light、dark模式时，为你的view，controller选择一个明确的样式。 Overview系统假设在ios13或者以后， app默认支持light、dark样式。在IOS中，你可以为window、view、controller指定明确的样式。也可以在plist中静止黑夜模式。 Override the Interface Style for a Window, View, or View Controller重写界面样式123456override func viewDidLoad() &#123; super.viewDidLoad() // Always adopt a light interface style. overrideUserInterfaceStyle = .light&#125; Override the Interface Style for Child View Controllers重写子控制器的样式1var overrideTraitCollection: UITraitCollection? &#123; get set &#125; Opt Out of Dark Mode Entirely 全部退出黑夜模式在plist中设置 UIUserInterfaceStyle的值为Light。 Supporting Dark Mode is strongly encouraged. Use the UIUserInterfaceStyle key to opt out only temporarily while you work on improvements to your app’s Dark Mode support. 参考 Choosing a Specific Interface Style for Your iOS App","tags":[{"name":"dark","slug":"dark","permalink":"http://yoursite.com/tags/dark/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"黑夜模式","slug":"IOS/黑夜模式","permalink":"http://yoursite.com/categories/IOS/黑夜模式/"}]},{"title":"Supporting Dark Mode in Your Interface（支持黑夜模式）","date":"2019-08-19T02:07:12.000Z","path":"wiki/IOS/黑夜模式/支持黑夜模式/","text":"Update colors, images, and behaviors so that your app adapts automatically when Dark Mode is active. 当黑夜模式激活后，更新颜色、图片、行为，使app自动适应黑夜模式。 OverviewStandard views and controls automatically update their appearance to match the current interface style，If you already use color and image assets, you can add dark variants without changing your code. 标准view、controls自动更新界面去匹配当前界面模式。如果你使用了color and image assets你可以不修改代码，从而添加黑夜模式的支持。 Choose Adaptive Colors for Your UI 为你的UI选择适合的颜色There are two ways to create adaptive color objects: Choose semantic colors instead of fixed color values. When configuring UI elements, choose colors with names like labelColor. These semantic colors convey the intended use of the color, rather than specific color values. When you use them for their intended purpose, they render with color values appropriate for the current settings. For a complete list of semantic color names, see NSColor and UIColor. Define custom colors in your asset catalog. When you need a specific color, create it as a color asset. In your asset, specify different color values for both light and dark appearances. You can also specify high-contrast versions of your colors. 选择UIColor类中定义的语义color,而不是固定的颜色 将自定义color定义在asset catalog中，指定dark、light中颜色。代码中使用UIColor(named: “customControlColor”) 加载颜色。 定义在asset catalog中的颜色自动适配dark、light模式。模式的变化，不需要重新加载。 Create Images for All AppearancesIf an image is difficult to see when changing appearances, provide a new image asset that looks good in the other appearance. 提供image asset 支持两种模式。 Update Custom Views Using Specific Methods 使用特定方法更新自定义view。 模式敏感的操作全部放在上面的方法里面。如果不在上面的方法里面，可能不能正常响应当前的模式变化。 Avoid Expensive Tasks During Appearance Transitions避免模式过渡时完成复杂任务。 参考 Supporting Dark Mode in Your Interface","tags":[{"name":"dark","slug":"dark","permalink":"http://yoursite.com/tags/dark/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"黑夜模式","slug":"IOS/黑夜模式","permalink":"http://yoursite.com/categories/IOS/黑夜模式/"}]},{"title":"第一章 基本知识","date":"2019-08-13T02:07:12.000Z","path":"wiki/数学知识/概率论和数理统计/第一章 概率论的基本概念/","text":"随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象 随机实验 可以在相同的条件下重复地进行 每次实验的可能结果不止一个，并且能事先明确实验的所有可能结果 进行一次实验前不能确定哪一个结果会出现 我们将具有上面三个特点的实验称为随机实验 样本空间、 随机事件一 样本空间我们将随机实验E的所有可能结果组成的集合称为E的样本空间。记作S 样本空间的每个结果称为样本点 二 随机事件一般，我们称实验E的样本空间S的子集为E 的随机事件，当且仅当这一子集中的样本点出现时，称这一事件发生。 由一个样本点组成的单点集，称为基本事件 每个实验中它总是发生的，S称为必然事件 。空集是不可能事件 事件间的关系和运算 若$A\\subset{B}$ 事件A发生必然导致事件B发生。 $A\\cup{B}$ 和事件，当且仅当A、B至少有衣蛾发生时，事件A\\cup{B}$ 发生 事件$A\\cap{B}$积事件，当且仅当A、B同时发生时，事件$A\\cap{B}$发生。 差事件，A-B 当且仅当A发生，B不发生时，事件A-B发生。 若$A\\cap{B}=\\emptyset$ ,则称事件A与时间B互不相容或互斥。事件A、B不能同时发生。 若$A\\cup{B}=s$ 且$A\\cap{B}=\\emptyset$则称事件A与时间B互为逆事件。或对立事件 频率和概率定义： 在相同条件下，进行n次试验，在这n次试验中，事件A发生的次数称为事件A的频数，比值$n_a/n$称为事件A发生的频率。并记作$f_n（A）$ 概率的性质： P($\\emptyset$)=0 有限可加性 ，$若A_1，A_2,… A_n$是两两互不相容的事件，则有P（$A_1\\cup{A_2}…\\cap{A_n}$） = $P(A_1)+P(A_2)+…+P(A_n)$ 设A、B是两个事件，若$A\\subset{B}$,则：$$P(B-A)=P(B)-P(A)$$ 对任一事件A P(A)&lt;=1 逆事件概率，对于任一事件A有$ P(\\overline A) $= 1- P(A) 加法公式： 对任意两事件 A、B 有，$ P(A\\cup B) = P(A)+P(B)-P(AB)$ 等可能概型（古典概型）若事件A包含k个基本事件 ，则$$P(A)=\\frac {k} {n} = \\frac {A包含的基本事件数} {S中基本事件的总数}$$ $$\\left ( \\frac {N}{n} \\right ) = \\frac {N(N-1)…(N-n+1)} {n!} \\text N中取n个的总数$$ $$A_N^n = N(N-1)…(N-n+1) \\text 也是N中取n个的总数 $$ 条件概率设A，B是两个事件，且P（A） &gt; 0 称 $$ P(B|A)=\\frac{P(AB)}{P(A)}$$为在事件A发生的条件下，事件B发生的条件概率。 乘法定理： $P(AB)=P(B|A)P(A)$ 全概率公式： 设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，且$P(B_i)$&gt;0,则$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+…+P(A|B_n)P(B_n)$$称为全概率公式。 个人理解：A和每个划分的积事件之和。 贝叶斯公式：设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，则$$P(B_i|A)=\\frac{P(A|B_i)P(B)}{\\sum_{j=1}^{n}{P(A|B_j)P(B_j)}}$$称为贝叶斯公式 当n=2时，全概率公式和贝叶斯公式分别为： $$P(A)=P(A|B)P(B)+P(A|\\overline B)P(\\overline B)$$ $$P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\\overline B)P(\\overline B)}$$ 独立性定义： 设A，B是两个事件，如果满足等式：$$P(AB)=P(A)P(B)$$则称事件AB是相互独立，简称A，B独立 定理1： 设A，B是两个事件，若A，B相互独立，则P(B|A) = P(B),反之亦然。 定理2：如事件A与B相互独立，则下列各事件也相互独立：$$A \\text{与} \\overline{B} , \\overline A 与B，\\overline A与\\overline B$$","tags":[{"name":"概率论","slug":"概率论","permalink":"http://yoursite.com/tags/概率论/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"概率论和数理统计","slug":"数学知识/概率论和数理统计","permalink":"http://yoursite.com/categories/数学知识/概率论和数理统计/"}]},{"title":"第一章 基本知识","date":"2019-08-13T02:07:12.000Z","path":"wiki/数学知识/概率论与数理统计(同济十二五)/第一章随机事件与概率/","text":"随机现象：个别实验中其结果呈现不确定性，在大量重复实验中其结果又具有统计规律的现象 课前导读加法原理：完成一件事，可以有n类办法，$在第一类办法中有m_1种不同的方法，在第二类办法中有m_2种不同的方法\\cdots，在第n类办法中有m_n种不同的方法，那么完成这件事共有N=m_1+m_2+…+m_n种不同方法$． 乘法原理：完成一件事，需要分成n个步骤，$做第一步时有m_1种不同的方法，做第二步时有m_2种不同的方法，\\cdots，做第n步有m_n种不同的方法，那么完成这件事共有N=m_1m_2…m_n种不同的方法$． 组合：从n个不同的元素中任取r（1≤r≤n）个不同元素，不考虑次序将它们并成一组，称之为组合．所有不同的组合种数,记为$\\binom{n}{r}$或$C_n^r$ $$\\binom{n}{r} = \\frac{n!}{r! (n-r)!} = \\frac{n(n-1)\\cdots(n-r+1)}{r!} \\text{，不考虑取出的r个元素的顺序}$$ 排列：从n个不同的元素中任取r（1≤r≤n）个不同元素，按一定的顺序排成一列，称之为排列．所有不同的排列种数记为$A_n^r$ $$A_n^r=n(n-1)\\cdots(n-r+1)=\\frac{n!}{(n-r)!} \\text{，考虑取出的r个元素的顺序}$$ 随机实验 可以在相同的条件下重复地进行 每次实验的可能结果不止一个，并且能事先明确实验的所有可能结果 进行一次实验前不能确定哪一个结果会出现 我们将具有上面三个特点的实验称为随机实验 样本空间、 随机事件一 样本空间我们将随机实验E的所有可能结果组成的集合称为E的样本空间。记作S 样本空间的每个结果称为样本点 二 随机事件样本空间的子集就是随机事件 由一个样本点组成的单点集，称为基本事件 每个实验中它总是发生的，S称为必然事件 。空集是不可能事件 事件间的关系和运算 若$A\\subset{B}$ 事件A发生必然导致事件B发生。 $A\\cup{B}$ 和事件，当且仅当A、B至少有衣蛾发生时，事件A\\cup{B}$ 发生 事件$A\\cap{B}$积事件，当且仅当A、B同时发生时，事件$A\\cap{B}$发生。 差事件，A-B 当且仅当A发生，B不发生时，事件A-B发生。 若$A\\cap{B}=\\emptyset$ ,则称事件A与时间B互不相容或互斥。事件A、B不能同时发生。 若$A\\cup{B}=s$ 且$A\\cap{B}=\\emptyset$则称事件A与时间B互为逆事件。或对立事件 频率和概率定义： 在相同条件下，进行n次试验，在这n次试验中，事件A发生的次数称为事件A的频数，比值$n_a/n$称为事件A发生的频率。并记作$f_n（A）$ 概率的性质： P($\\emptyset$)=0 有限可加性 ，$若A_1，A_2,… A_n$是两两互不相容的事件，则有P（$A_1\\cup{A_2}…\\cap{A_n}$） = $P(A_1)+P(A_2)+…+P(A_n)$ 设A、B是两个事件，若$A\\subset{B}$,则：$$P(B-A)=P(B)-P(A)$$ 对任一事件A P(A)&lt;=1 逆事件概率，对于任一事件A有$ P(\\overline A) $= 1- P(A) 加法公式： 对任意两事件 A、B 有，$ P(A\\cup B) = P(A)+P(B)-P(AB)$ 等可能概型（古典概型）若事件A包含k个基本事件 ，则$$P(A)=\\frac {k} {n} = \\frac {A包含的基本事件数} {S中基本事件的总数}$$ $$\\left ( \\frac {N}{n} \\right ) = \\frac {N(N-1)…(N-n+1)} {n!} \\text N中取n个的总数$$ $$A_N^n = N(N-1)…(N-n+1) \\text 也是N中取n个的总数 $$ 条件概率设A，B是两个事件，且P（A） &gt; 0 称 $$ P(B|A)=\\frac{P(AB)}{P(A)}$$为在事件A发生的条件下，事件B发生的条件概率。 乘法定理： $P(AB)=P(B|A)P(A)$ 全概率公式： 设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，且$P(B_i)$&gt;0,则$$P(A)=P(A|B_1)P(B_1)+P(A|B_2)P(B_2)+…+P(A|B_n)P(B_n)$$称为全概率公式。 个人理解：A和每个划分的积事件之和。 贝叶斯公式：设实验E的样本空间为S，A为E的事件，$B_1,B_2,…,B_n$为S的一个划分，则$$P(B_i|A)=\\frac{P(A|B_i)P(B)}{\\sum_{j=1}^{n}{P(A|B_j)P(B_j)}}$$称为贝叶斯公式 当n=2时，全概率公式和贝叶斯公式分别为： $$P(A)=P(A|B)P(B)+P(A|\\overline B)P(\\overline B)$$ $$P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A|B)P(B)+P(A|\\overline B)P(\\overline B)}$$ 独立性定义： 设A，B是两个事件，如果满足等式：$$P(AB)=P(A)P(B)$$则称事件AB是相互独立，简称A，B独立 定理1： 设A，B是两个事件，若A，B相互独立，则P(B|A) = P(B),反之亦然。 定理2：如事件A与B相互独立，则下列各事件也相互独立：$$A \\text{与} \\overline{B} , \\overline A 与B，\\overline A与\\overline B$$","tags":[{"name":"概率论","slug":"概率论","permalink":"http://yoursite.com/tags/概率论/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"概率论与数理统计(同济十二五)","slug":"数学知识/概率论与数理统计-同济十二五","permalink":"http://yoursite.com/categories/数学知识/概率论与数理统计-同济十二五/"}]},{"title":"第四章 向量组的线性相关性","date":"2019-08-11T02:07:12.000Z","path":"wiki/数学知识/线性代数/vector/","text":"本章讨论向量组的线性相关性，引入最大无关组和向量组的秩的概念。 向量组及其线性组合定义2 设有向量组$A:a_1，a_2，…，a_m$及任意给定的m个实数$k_1，k_2，…，k_m$，表达式： $$k_1a_1+k_2a_2+…+k_ma_m$$ 称为向量组A的一个线性组合，$k_1，k_2，…，k_m$，称为这个线性组合的系数. 若向量b等于向量组A的某一线性组合，即存在数$λ_1，λ_2，…，λ_m$，使$$b=λ_1a_1+λ_2a_2+…+λ_ma_m$$，则称向量b可由向量组A线性表示. 定理1 向量b可由向量组A:a1，a2，…，am线性表示的充分必要条件是矩阵A=（a1，a2，…，am）的秩等于矩阵B=（a1，a2，…，am，b）的秩. 定义3 若向量组B:b1，b2，…，bl的每个向量都可由向量组A:a1，a2，…，am线性表示，则称向量组B可由向量组A线性表示；若向量组A与向量组B可相互线性表示，则称向量组A与B等价. 定理2 向量组$B:b_1，b_2，…，b_l$可由向量组$A:a_1，a_2，…a_m$线性表示的充分必要条件是矩阵A＝$（a_1，a_2，…，a_m）$的秩等于矩阵$（A，B）=（a_1，…，a_m，b_1，…b_l）$的秩，即$$R（A）=R（A，B）$$ 推论 向量组$A:a_1，a_2，…，a_m$与向量组$B:b_1，b_2，…，b_l$等价的充分必要条件是$$R（A）=R（B）=R（A，B）$$，其中，A和B分别是向量组A和向量组B构成的矩阵. 定理3 设$A=（a_1，a_2，…，a_m），B=（b_1，b_2，…，b_l），$若向量组$B：b_1，b_2，…，b_l$可由向量组$A:a_1，a_2，….a_m$线性表示，则$$R（B）≤R（A）$$. 向量组的线性相关性定义4 给定向量组$A:a_1，a_2，…，a_m$，若存在不全为零的一组数$k_1，k_2，…，k_m$，使$$k_1a_1+k_2a_2+…+k_ma_m=0$$，则称向量组A是线性相关的，否则称向量组A线性无关.根据相关性的定义，易得如下结论： 对于只有一个向量a的向量组，当a=0时线性相关，当a≠0时线性无关： 含两个向量a1，a2的向量组线性相关a1，a2的分量对应成比例； 含有零向量的向量组一定线性相关. 向量组线性相关概念也可移用于线性方程组，当方程组中某个方程是其余方程的线性组合时，这个方程就是多余的，这时称方程组是线性相关的；当方程组中没有多余方程时，就称方程组是线性无关的.设$A=（a_1，a_2，…，a_m）$，则向量组$A:a_1，a_2，…，a_m$线性相关，就是齐次线性方程组 $$x_1a_1+x_2a_2+…+x_ma_m=0$$，即Ax=0有非零解.由第3章定理7，可得 定理4 向量组$A:a_1，a_2，…，a_m$线性相关的充分必要条件是矩阵$A=（a_1，a_2，…，a_m）$的秩R（A）&lt;m；线性无关的充分必要条件是R（A）=m（m为向量组A中向量的个数）. 推论 m个n维列向量构成的向量组$A:a_1，a_2，….a_m$，当m&gt;n时，一定线性相关. 定理5 向量组$A:a_1，a_2.…，a_m（m≥2）$线性相关的充分必要条件是向量组中至少有一个向量可由其余m1个向量线性表示. 若向量组$A:a_1.a_2，…，a_m$线性相关，则向量组$B:a_1，a_2，…，a_m，a_{m+1}$也线性相关；反之，若向量组$B:a_1，a_2，…，a_m，a_{m+1}$，线性无关，则向量组$A:a_1，a_2，…，a_m$也线性无关. 设向量组$A:a_1，a_2，…a_m$线性无关，而向量组$B:a_1，a_2，…，a_m，b$线性相关，则向量b必能由向量组A线性表示，且表示唯一 向量组的秩定义5 给定向量组A，若在A中能选出一个含r个向量的部分组$A0:a_1，a_2，…，a_r$，满足： 向量组A0线性无关； 向量组A中任意r+l个向量（如果A中有r+l个向量的话）都线性相关，则称向量组A0为向量组A的一个最大线性无关组，简称为最大无关组.最大无关组A0中所含向量个数：称为向量组A的秩.向量组$A:a_1，a_2，…，a_m$的秩，记作RA或$R（a_1，a_2，…，a_m）$ 只含有零向量的向量组没有最大无关组，规定它的秩为0. 由定义可知： 若向量组A线性无关，则A的最大无关组就是A本身，它的秩就等于它所含向量的个数； 向量组A线性相关的充分必要条件是向量组A的秩小于所含向量的个数； 向量组A与它的最大无关组A0等价.因为A0是A的一个部分组，故A0总能由A线性表示；在A中任取一向量a，则有$a_1，a_2，…，a_r$，a这r+1个向量线性相关，而a1.a2，…，ar，线性无关，由4.2节定理5可知a能由$a_1，a_2，…，a_r$线性表示，即A能由A0线性表示. 定理6 矩阵的秩等于它的列向量组的秩，也等于它的行向量组的秩. 线性方程组的解结构齐次线性方程组的解结构性质1 若x=ξ1，x=ξ2为Ax=0的解，则x=ξ1+ξ2也是Ax=0的解. 性质2 若X=ξ1，为Ax=0的解，k为实数，则x=kξ1，也是Ax=0的解. 定义6 若向量$ξ_1，ξ_2，…，ξ_t$为齐次线性方程组Ax=0的解向量，且满足： $ξ_1，ξ_2.…，ξ_t$线性无关； Ax=0的所有解均可由$ξ_1，ξ_2，…，ξ_t$线性表示，则称$ξ_1，ξ_2，…，ξ_t$为方程组Ax=0的一个基础解系， 称$$x=k_1ξ_1+k_2ξ_2+…+k_tξ_t，$$（其中k1，k2，…，kt为任意实数）为方程组Ax=0的通解.若把方程组Ax=0的所有解组成一个向量组S，则基础解系$ξ_1，ξ_2，…，ξ_t$为向量组S的一个最大无关组. 定理7 设A为m×n矩阵，若R（A）=r，则n元齐次线性方程组Ax=0的解集S的秩$R_S=n-r$. 非齐次线性方程组的解结构性质3 若x=η1，x=η2为Ax=b的解，则x=η1η2为对应齐次线性方程组Ax=0的解. 性质4 设x=η是方程Ax=b的解，x=ξ是方程Ax=0的解，则x=ξ+η仍是方程Ax=b的解. 由性质3可知，若求得方程Ax=b的一个特解$η^{*}$，则方程Ax=b的任一解都可表示为$$x=ξ+η*.（其中ξ为方程Ax=0的解）$$若方程Ax=0的通解为$$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}$$，则方程Ax=b的任一解都可表示为 $$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}+η^*$$.由性质4可知，方程Ax=b的通解为$$x=k_1ξ_1+k_2ξ_2+…+k_{n-r}ξ_{n-r}+η^*$$，其中，$k_1，k_2，…，k_{n-r}$为任意实数，$ξ_1，ξ_2，…，ξ_{n-r}$是方程Ax=0的基础解系. 向量空间定义7 设V是非空的n维向量的集合，若集合V对向量的加法及向量的数乘这两种运算封闭，则称集合V是一个向量空间.","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://yoursite.com/tags/线性代数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"线性代数","slug":"数学知识/线性代数","permalink":"http://yoursite.com/categories/数学知识/线性代数/"}]},{"title":"第三章 矩阵的初等变换和线性方程组","date":"2019-08-11T02:07:12.000Z","path":"wiki/数学知识/线性代数/matrixTransformation/","text":"学习线性代数的第三章。 矩阵初等变换定义1 下面3种变换称为矩阵的初等行变换： 对调矩阵的两行（对调i，j两行，记作ri↔rj）； 将某一行所有元素乘以数k≠0（第i行乘k，记作ri×k）； 把某一行所有元素的k倍加到另一行对应元素上去（第j行的k倍加到第i行上，记作ri+krj）. 矩阵的初等行变换与初等列变换统称为矩阵的初等变换. 这里，矩阵B1与B2都称为行阶梯形矩阵，其特点是：可画一条一行为一个台阶的阶梯线，线的下方元素全为0，台阶数就是非零行的行数，阶梯线的竖线（每段竖线的长度为一行）后面的第一个元素为非零元，也就是非零行的第一个非零元. 行阶梯形矩阵B2还称为行最简形矩阵，其特点是：每个非零行的第一个非零元为1，且这些非零元所在的列的其他元素都为0. 标准形，其特点是：左上角是一个单位矩阵，其余元素全为 任何矩阵A都有唯一的标准形.等价矩阵有相同的标准形.即有相同标准形的矩阵是等价的.因此所有与A等价的矩阵组成一个集合，称为一个等价类，标准形F是这个等价类中形式最简单的矩阵. 初等矩阵定义2 由单位矩阵E经过一次初等变换得到的方阵称为初等矩阵. 定理1 设A是一个m×n矩阵，则对A施行一次初等行变换，相当于用相应的m阶初等矩阵左乘A；对A施行一次初等列变换，相当于用相应的n阶初等矩阵右乘A. 定理2 方阵A可逆的充分必要条件是存在有限个初等矩阵P1，P2，…，Ps，使A=P1P2…Ps. 推论4 对于n阶矩阵A与n×s矩阵B，若，则A可逆，且X=A1B.特别地，对于n个未知数n个方程的线性方程组Ax=b，若增广矩阵，则A可逆，且x=A1b为方程组的唯一解. 矩阵的秩矩阵秩的定义定义4 设在m×n矩阵A中有一个不等于0的r阶子式D，且所有的r+1阶子式（如果存在的话）全等于0，则D称为矩阵A的最高阶非零子式.数r称为矩阵A的秩，记作R（A）=r.我们规定零矩阵的秩为0. 注意： 由行列式的展开法则可知，在A中，当所有r+l阶子式全等于0时，所有高于r+l阶的子式也全等于0，因此把r阶非零子式称为A的最高阶非零子式，而A的秩R（A）就是A中不等于0的子式的最高阶数. 若矩阵A中存在某个s阶子式不等于0，则R（A）≥s；若所有t阶子式全为0，则R（A）&lt;t. 对任意m×n矩阵A，有O≤R（A）≤min{m，n}. 对任意m×n矩阵A，有R（A）=$R(A^T)$. 对n阶方阵A，若|A|≠0，则R（A）=n，此时方阵A可逆，所以可逆矩阵又称满秩矩阵；若|A|=0，则R（A）&lt;n，此时方阵A不可逆，因此不可逆矩阵又称降秩矩阵（或奇异矩阵）. 矩阵秩与矩阵的初等变换定理3 若A～B，则R（A）=R（B）. 由定理3可知，要求矩阵的秩，只要把矩阵用初等行变换化为行阶梯形矩阵，则行阶梯形矩阵中，非零行的行数即为该矩阵的秩. 矩阵的秩的性质 性质1 0≤R（Am×n）≤min{m，n}，且R（A）=0的充分必要条件是A=O. 性质2 R（A）=R（$A^T$）. 性质3 R（A）=R（kA）（k≠0）. 性质4 若A～B，则R（A）=R（B）. 性质5 若P，Q可逆，则R（PAQ）=R（A）. 性质6 max{R（A），R（B）}≤R（A，B）≤R（A）+R（B），特别地，当B=b为列向量时，有R（A）≤R（A，b）≤R（A）+1. 性质7 R（A±B）≤R（A）+R（B） 性质8 R（AB）≤min{R（A），R（B）}. 性质9 若$A_{m×n}B_{n×l}=O$，则R（A）+R（B）≤n. 线性方程组的解消元法就是增广矩阵 变换的过程。 定理4 n元非齐次线性方程组Ax=b， 无解的充分必要条件是R（A）&lt;R（A，b）； 有唯一解的充分必要条件是R（A）=R（A，b）=n； 有无穷多解的充分必要条件是R（A）=R（A，b）&lt;n. 由定理4，可知解线性方程组Ax=b时，只需对增广矩阵B=（A，b）施行初等行变换化为行阶梯形矩阵，判别线性方程组是否有解；在有解时，继续对增广矩阵施行初等行变换化为行最简形矩阵，而后求出线性方程组的解. 定理5 矩阵方程AX=B有解的充分必要条件是R（A）=R（A，B）. 齐次线性方程组有非零解的充分必要条件： 定理7 n元齐次线性方程组Ax=0有非零解的充分必要条件是系数矩阵A的秩R（A）&lt;n；而只有零解得充分必要条件是R（A）=n. 推论1 若齐次线性方程组Ax=0中方程的个数小于未知数的个数，则它必有非零解. 推论2 n个方程n个未知数的齐次线性方程组Ax=0有非零解的充分必要条件是系数行列式|A|=0；而它只有零解的充分必要条件是系数行列式|A|≠0.定理7还可以推广到矩阵方程情形中. 定理8 矩阵方程$A_{m×n}X_{n×l}=O_{m×l}$只有零解的充分必要条件是R（A）=n.","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://yoursite.com/tags/线性代数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"线性代数","slug":"数学知识/线性代数","permalink":"http://yoursite.com/categories/数学知识/线性代数/"}]},{"title":"第五章 相似矩阵","date":"2019-08-11T02:07:12.000Z","path":"wiki/数学知识/线性代数/相似矩阵/","text":"矩阵的特征值与特征向量是线性代数中十分重要的内容，是矩阵和向量理论深层次上的发展.本章主要讨论矩阵的特征值与特征向量的概念、性质与计算及矩阵的相似对角化问题，特别是对称矩阵的正交相似对角化问题. 向量的內积和正交性向量的內积$$[x，y]=x_1y_2+x_2y_2+…+x_ny_n.$$ 内积的运算规律（其中x，y，z为n维向量，λ为实数）： [x，y]=[y，x]； [λx，y]=λ[x，y]； [x+y，z]=[x，z]+[y，z]； [x，x]≥0，当且仅当x=0时，[x，x]=0； 柯西一施瓦茨（CauchySchwarz）不等式：$[x，y]^2≤[x，x][y，y]$，当且仅当x与y线性相关时等号成立. 向量的长度定义2 设x是n维向量，称$\\sqrt{[x,x]}$为向量x的长度（或范数），记作‖x‖.即若x＝（x1，x2，…，xn）T，则有$$||x||=\\sqrt{[x,x]}=\\sqrt{x_1^2+x_2^2+x_n^2}$$ 向量的长度具有以下性质： 非负性 ‖x‖≥0，当且仅当x=0时等号成立； 齐次性 ‖λx‖=|λ|‖x‖，λ为任意实数； 三角不等式 ‖x+y‖≤‖x‖+‖y‖. 若‖x‖=1，则称x为单位向量. 设a为任意非零向量，则向量$\\frac{1}{||a||}a$为单位向量， 对于一个非零向量，用a的长度‖a‖去除a，即得到一个单位向量，这个过程称为将a单位化. 向量的夹角与正交向量组定义3 设向量x与y均是n维非零向量，称 $$\\theta=arccos\\frac{[x,y]}{||x|| ||y||}$$为向量x与y的夹角.当[x，y]=0时，称向量x与y正交.显然，零向量与任何向量都正交.两两正交的非零向量组，称为正交向量组. 定理1 若向量组$a_1，a_2，…，a_m$是正交向量组，则$a_1，a_2，…，a_m$线性无关. 定义4 设n维向量组$e_1，e_2，…，e_r$是向量空间V的一个基，若$e_1，e_2，…，e_r$两两正交，且都是单位向量，则称$e_1，e_2，…，e_r$是V的一个规范正交基 规范正交化的步骤 : 正交矩阵与正交变换 性质： 方阵的特征值与特征向量特征值和特征向量的概念定义7 设A为n阶方阵，若存在数λ和非零n维列向量x，使得$$Ax=λx（5.1）成立，$$则称数λ为方阵A的特征值，非零向量x称为A的对应于特征值λ的特征向量.式（5.1）也可写成$$（A-λE）x=0，（5.2）$$这是n个未知数n个方程的齐次线性方程组 求n阶方阵A的特征值和特征向量的步骤： 第一步：求出A的特征多项式|A-λE|； 第二步：求解特征方程|A-λE|=0，得到A的n个特征值λ1，λ2，…λn； 第三步：对于A的每一个特征值λi，求出齐次线性方程组（A-λiE）x=0的一个基础解系ξ1，ξ2，…ξs，则A的对应于特征值λi的全部特征向量为pi=c1ξ1+c2ξ2+…+csξs，其中，c1，c2，…，cs为不全为零的任意实数. 方阵的特征值和特征向量的性质性质1 一个特征向量只能属于一个特征值（相同的看成一个） 性质2 若λ是方阵A的特征值，x是属于λ的特征向量，则 μλ是μA的特征值，x是属于μλ的特征向量（μ是常数）： λk是Ak的特征值，x是属于λk的特征向量（k是正整数）； 当|A|≠0时λ1是A1的特征值，λ1|A|为$A*$的特征值，且x为对应的特征向量. φ（λ）是φ（A）的特征值（其中φ（λ）$=a_0+a_1λ+…+a_mλ^m$是λ的多项式，φ（A）=$a_0E+a_1A+…+a_mA^m$是方阵A的多项式） 性质3 A与AT有相同的特征值 性质5 设λ1，λ2，…，λm是方阵A的m个特征值，p1，p2，…，pm是依次与之对应的特征向量.若λ1，λ2，…，λm互不相等，则p1，p2，…，pm线性无关. 相似矩阵相似矩阵的定义定义8 设A，B都是n阶方阵，若存在一个n阶可逆矩阵P，使$$P^1AP=B$$ 则称A与B是相似的，或称B是A的相似矩阵.称$P^1AP$为对A作相似变换，可逆矩阵P称为把A变成B的相似变换矩阵 性质1 若A与B相似，则R（A）=R（B），且|A|=|B|. 性质2 若A可逆，且A与B相似，则B可逆，且A1与B1也相似. 性质3 若A与B相似，则$A^k$与$B^k$（k为整数）相似. 定理3 若n阶方阵A与B相似，则A与B的特征多项式相同，从而A与B的特征值也相同. 推论 若n阶方阵A与对角矩阵相似，则λ1，λ2，…，λn是A的n个特征值. 矩阵的对角化定理4 n阶方阵A与对角矩阵相似的充分必要条件是A有n个线性无关的特征向量. 推论 若n阶方阵A有n个互不相同的特征值，则A与对角矩阵相似. 定理5 若对于n阶方阵A的任一k重特征值λ，有R（A-λE）=n-k，则A可对角化. 实对称矩阵的对角化定理7 实对称矩阵不同特征值对象特征向量正交 定理8 A为n阶实对称矩阵，则必存在正交矩阵P，使得$$P^1AP=P^TAP=A$$，其中A是以A的n个特征值未对角线元素的对角矩阵 推论： 设A为n阶实对称矩阵，λ是A的k重特征值，则 R（A-λE）= n-k，从而对应特征值λ恰好有k个线性无关的特征向量","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://yoursite.com/tags/线性代数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"线性代数","slug":"数学知识/线性代数","permalink":"http://yoursite.com/categories/数学知识/线性代数/"}]},{"title":"第一章行列式","date":"2019-08-09T04:07:12.000Z","path":"wiki/数学知识/线性代数/det/","text":"第一章，行列式学习记录 1、二三阶行列式定理1 ： 一个排列进行一次对换，排列改变奇偶性一次 n阶行列式在三阶行列式中,行标固定为123，列表为123的全排列，有6中情况。所以，三阶行列式的定义如下： $$ \\sum (-1)^t a_{1p_1} a_{2p_2} a_{3p_3}$$ 定理2： n阶行列式也可以定义为： $$ D = \\sum (-1)^τ a_{p_11} a_{p_22} … a_{p_nn} \\text ，其中τ为行排列p_1p_2…p_n 的逆序数$$ 定理3 ： n阶行列式也可以定义为： $$ D = \\sum (-1)^{τ_1+τ_2} a_{p_1q_1} a_{p_2q_2} … a_{p_nq_n} \\text ，其中τ_1为行排列p_1p_2…p_n 的逆序数, τ_2为列排列的逆序数$$ 2、行列式的性质性质1： 行列式和它的转置行列式相等，即$$D = D^T$$ 性质2： 互换行列式的两行，行列式变号 推论： 若行列式有两行完全相同，则该行列式等于0 性质3： 行列式的某一行的各元素乘以同一数k，等于用数乘此行列式。 性质4： 若行列式中有两行的元素对应成比例，则该行列式等于0 性质5：若行列式的某一行的元素都是两数之和， 等于两个行列式的和 性质6： 把行列式的某一行的各元素乘以同一个数k后，加到另一行对应的元素上去，行列式的值不变。 把行列式化为上三角行列式的步骤为： 若第一列第一个元素为0，先将第一行与其他行交换，使得第一列第一个元素不为0，然后把第一行分别乘以适当的数加到其他各行，使得第一列除第一个元素外，其余元素全为0； 用同样的方法处理除去第一行和第一列后余下的低一阶的行列式，如此反复下去，直到使它变为上三角行列式，这时主对角线上元素的乘积就是所求行列式的值. 3、 行列式按行（列）展开定义2 在n阶行列式中，把元素$a_{ij}$所在的第i行和第j列划去，余下的n-1阶行列式（依原来的排法），称为元素$a_{ij}$的余子式，记作$M_{ij}$ ；记$$A_{ij}= (-1)^{i+j}M_{ij}，$$称$A_{ij}$为元素$a_{ij}$的代数余子式. 引理 一个n阶行列式D，若第i行所有元素除$a_{ij}$为全为零，则该行列式等于$a_{ij}$与它的代数余子式的乘积，即$$D=a_{ij}A_{ij}$$ 定理4 行列式等于它的任一行（列）的各元素与其对应的代数余子式的乘积之和，即$$D=a_{i1}A_{i1}+a_{i2}A_{i2}+…+a_{in}A_{in}（i=1，2，…，n），$$或$$D=a_{1j}A_{1j}+a_{2j}A_{2j}＋…＋a_{nj}A_{nj}（j=1，2，…，n）.$$ 下面是范德蒙行列式：$$D_n =\\begin{vmatrix}1 &amp; 1 &amp; \\cdots &amp; 1 \\\\x_1 &amp; x_2 &amp; \\cdots &amp; x_n \\\\x_1^2 &amp; x_2^2 &amp; \\cdots &amp; x_n^2 \\\\\\vdots &amp; \\vdots &amp; &amp; \\vdots \\\\x_1^{n-1} &amp; x_2^{n-1} &amp; \\cdots &amp; x_n^{n-1}\\end{vmatrix}=\\prod_{n\\ge{i}\\gt{j}\\ge{i}}{(x_i - x_j)}$$ 下面这个公式不明白，但是后面会使用 $$ \\sum_{k=1}^n{a_{ik}A_{jk}} = D\\delta_{ij} =\\begin{cases}D, &amp;当 i=j \\\\0, &amp; 当 i \\ne j\\end{cases} $$ 其中 $$\\delta_{ij} =\\begin{cases}1, &amp;当 i=j \\\\0, &amp; 当 i \\ne j\\end{cases} $$ 4、 克莱姆法则（Carmer）定理5 ： 线性方程组的系数行列式不为0.则线性方程组有解。 $$ x_1 = \\frac{D_1}{D} , x_2 = \\frac{D_2}{D}…. $$其中，$D_j$（j=1，2，…，n）是将D中的第j列元素换成方程组右端的常数项所得的行列式. 使用克莱姆法则必须注意： 未知量的个数与方程的个数要相等； 系数行列式不为零. 常数项全为0的方程称为齐次线性方程。 $$\\left \\{\\begin{array}{c}a_{11}x_{1}+a_{12}x_{2} + \\cdots + a_{1n}x_{n} = 0 \\\\a_{21}x_{1}+a_{22}x_{2} + \\cdots + a_{2n}x_{n} = 0 \\\\………………………….. \\\\a_{n1}x_{1}+a_{n2}x_{2} + \\cdots + a_{nn}x_{n} = 0\\end{array}\\right.$$ 定理6 如果齐次线性方程组的系数行列式D≠0，则齐次线性方程组只有零解. 定理6′ 如果齐次线性方程组有非零解，则它的系数行列式必为零. 定理6′ 说明系数行列式D=0是齐次线性方程组有非零解的必要条件.","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://yoursite.com/tags/线性代数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"线性代数","slug":"数学知识/线性代数","permalink":"http://yoursite.com/categories/数学知识/线性代数/"}]},{"title":"第二章矩阵","date":"2019-08-08T04:07:12.000Z","path":"wiki/数学知识/线性代数/matrix/","text":"矩阵学习记录 矩阵定义： 矩阵可以记作：$A=(a_{ij})_{m×s}$，也可以记作 $A_{m×n}$ 只有一行元素，这样的矩阵称为行矩阵,A=$（a_1，a_2，…，a_n）$. 若矩阵只有一列元素，这样的矩阵称为列矩阵 若n阶方阵，主对角线以外的元素全为0，这样的矩阵称为对角阵，A=$diag（λ_1，λ_2，…，λ_n）$ 对角元素相同的对角阵，称为数量阵 数量阵的元素为1，单位阵 定义2 若两个矩阵的行数与列数分别相等，则称它们为同型矩阵. 矩阵运算矩阵加法的运算规律： A+B = B + A 交换律 (A+B) + C = A + (B + C) 结合律 数与矩阵的乘法： 定义4 数λ与矩阵A的乘积记作λA. 数与矩阵相乘的运算规律： (λμ)A = λ(μA) (λ+μ)A = λA+μA λ(A+B) = λA + λB 矩阵乘法定义5 设矩阵$A=(a_{ij})_{m×s}，B=(b_{ij})_{s×n}，$则规定矩阵A与矩阵B的乘积是一个m×n矩阵$C= (c_{ij})_{m×n}$，其中 $c_{ij} = \\sum_{k=1}^{s}a_{ik}b_{kj}$. 对于两个n阶方阵A、B ，若AB = BA， 则A与B是可交换的 特别注意：若两个矩阵A，B满足AB=O，不能推出A=O或B=O的结论；若AB=AC，A≠O，也不能推出B=C的结论. 矩阵乘法的运算规律： （AB）C=A（BC）； A（B+C）=AB+AC，（B+C）A= BA+CA； λ（AB）=（λA）B=A（λB）. 对于单位矩阵E，容易验证$E_mA_{m×n}=A_{m×n}，A_{m×n}E_n=A_{m×n}$，可简记为EA=AE=A. 方阵的幂的运算规律 : $A^kA^1 = A^{k+1}$ $(A^k)^l = A^{kl}$ 特别注意： 矩阵乘法不满足交换律。 矩阵转置定义6 将m×n矩阵A的行换成同序数的列得到的一个n×m矩阵，称为A的转置矩阵，记作$A^T$. 矩阵转置的运算规律： $(A^T)^T = A$ $(A+B)^T = A^T + B^T$ $(λA)^T = λA^T$ $(AB)^T = B^TA^T$ 定义7 设A为n阶方阵，如果满足$A^T$=A，则称对称阵，特点是它的元素以主对角线为对称轴，对应相等。 反对称阵： $A^T = -A$ 方阵的行列式由n阶方阵A的元素所构成的行列式（各元素的位置不变），称为方阵A的行列式，记作|A|或detA. 注意：方阵与行列式是两个不同的概念，n阶方阵是n2个数按一定方式排成的数表，而n阶行列式则是n2个数按一定的运算法则所确定的一个数. 方阵行列式的运算规律： $|A^T| = |A|$$ $|λA| = λ^n|A| $ |AB| = |A||B| 对于n阶方阵A，B，一般来说AB≠BA，但总有|AB|=|BA|=|A|·|B|. 逆矩阵设A为n阶方阵，若存在n阶矩阵B，使得： AB = BA = E 则称方阵A是可逆的，并称B是A的逆矩阵 记作 $A^{-1} = B$,逆矩阵一定是方阵。 定理1 ： 若矩阵A可逆，则其逆矩阵唯一 定理2： 设$A^*$ 为A的伴随矩阵，就是每个元素都是对应的代数余子式。则有： $$AA^*=A^*A=|A|E$$ 定理3 ： n阶方阵A可逆的充分必要条件是|A| != 0 且有： $ A^{-1} = \\frac{1}{|A|}A^*$ 方阵的逆矩阵的性质： 若A可逆，则$(A^{-1})^{-1} = A$ 若A可逆，数λ不为0， 则λA可逆，且$(λA)^{-1} = \\frac{1}{λ}A^{-1}$ 若AB为同阶方阵，且A、B都可逆，则AB可逆，且 $(AB)^{-1} = B^{-1}A^{-1}$ 若A可逆，则$A^T$可逆，且$ (A^T)^{-1} = (A^{-1})^T$ 若A可逆，则$ |A^{-1}| = \\frac{1}{|A|} = |A|^{-1} $ 矩阵的分块","tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://yoursite.com/tags/线性代数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"},{"name":"线性代数","slug":"数学知识/线性代数","permalink":"http://yoursite.com/categories/数学知识/线性代数/"}]},{"title":"aspect源码浅析","date":"2019-08-08T02:07:12.000Z","path":"wiki/IOS/opensource/Aspects/aspect/","text":"图解aspect。 图解aspectaspect 切方法分为两种： 为实例切方法，只实例有效，类的其他实例不受影响，类似KVO，原理是交换了isa。 为类切方法： 交换了类的实例方法，所有实例都生效。 其实看过原理后，就交换了两个方法，一个是当前selector，一个是forwardInvocation。 一定要理解方法的中包含SEL、IMP，SEL理解为方法的名称，IMP是方法的代码实现，图中很多地方使用SEL、IMP后缀区分两着。 特别注意步骤9，解决的是如果向切片类发送了非切片类的方法，还走原来的消息转发流程，如不认识的方法报 not recognize selector send to instance错误。 参考无","tags":[{"name":"aspect","slug":"aspect","permalink":"http://yoursite.com/tags/aspect/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"Aspects","slug":"IOS/opensource/Aspects","permalink":"http://yoursite.com/categories/IOS/opensource/Aspects/"}]},{"title":"方法交换理解","date":"2019-08-06T03:38:11.000Z","path":"wiki/IOS/Runtime/日常总结/method_swizzing/","text":"本文理解方法交换写法的含义 方法交换源码解读下面是方法交换的常用源码： 1234567891011121314151617181920- (void)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector&#123; Class class = [self class]; Method originalMethod = class_getInstanceMethod(class, origSelector); Method swizzledMethod = class_getInstanceMethod(class, newSelector); BOOL didAddMethod = class_addMethod(class, origSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, newSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125;&#125; 要先尝试添加原 selector 是为了做一层保护，因为如果这个类没有实现 originalSelector ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法，这当然不是你想要的。所以我们先尝试添加 orginalSelector ，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。 下面分析 class_addMethod的源码： 12345678BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types)&#123; if (!cls) return NO; rwlock_writer_t lock(runtimeLock); return ! addMethod(cls, name, imp, types ?: \"\", NO);&#125; class_addMethod 内部调用了addMethod，并将addMethod的结果取反，作为返回值。其中replace参数（最后一个）传递NO，表示如果类中存在该方法（originalMethod），不替换。 1234567891011121314151617181920212223242526272829303132333435363738static IMP addMethod(Class cls, SEL name, IMP imp, const char *types, bool replace)&#123; IMP result = nil; runtimeLock.assertWriting(); assert(types); assert(cls-&gt;isRealized()); method_t *m; if ((m = getMethodNoSuper_nolock(cls, name))) &#123; // already exists if (!replace) &#123; result = m-&gt;imp; &#125; else &#123; result = _method_setImplementation(cls, m, imp); &#125; &#125; else &#123; // fixme optimize method_list_t *newlist; newlist = (method_list_t *)calloc(sizeof(*newlist), 1); newlist-&gt;entsizeAndFlags = (uint32_t)sizeof(method_t) | fixed_up_method_list; newlist-&gt;count = 1; newlist-&gt;first.name = name; newlist-&gt;first.types = strdupIfMutable(types); newlist-&gt;first.imp = imp; prepareMethodLists(cls, &amp;newlist, 1, NO, NO); cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, 1); flushCaches(cls); result = nil; &#125; return result;&#125; 该方法首先查找类是否有方法，如果有，返回方法，如果没有添加并返回空，所以addMethod的返回值可以理解为返回旧的方法。 所以进一步理解class_addMethod返回值的含义： 它取反了addMethod的结果，所以，添加成功，返回yes，没有添加成功（也就是存在方法），返回no。 方法添加成功，也就是类中没有originalMethod方法，调用了class_replaceMethod，接着看class_replaceMethod方法： 12345678IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types)&#123; if (!cls) return nil; rwlock_writer_t lock(runtimeLock); return addMethod(cls, name, imp, types ?: \"\", YES);&#125; 因为上面class_addMethod添加成功，说明原始类是没有旧方法，也就不用管我们添加的旧方法，所以直接调用class_replaceMethod将添加的方法originalMethod换为新方法即可，不需要交换，所以，传递给addMethod方法的最后一个参数是yes，直接替换。 如果没有添加成功，说明原类中有originalMethod，所以不能直接替换，如果直接替换了，调用原方法的函数就会出问题（死循环），需要交换，条用method_exchangeImplementations交换方法。 12345678910111213void method_exchangeImplementations(Method m1_gen, Method m2_gen)&#123; IMP m1_imp; old_method *m1 = oldmethod(m1_gen); old_method *m2 = oldmethod(m2_gen); if (!m1 || !m2) return; impLock.lock(); m1_imp = m1-&gt;method_imp; m1-&gt;method_imp = m2-&gt;method_imp; m2-&gt;method_imp = m1_imp; impLock.unlock();&#125; 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"日常总结","slug":"IOS/Runtime/日常总结","permalink":"http://yoursite.com/categories/IOS/Runtime/日常总结/"}]},{"title":"1. 两数之和","date":"2019-07-25T09:07:12.000Z","path":"wiki/数据结构与算法/LeetCode/top1_10/1_两数之和/","text":"题目 解法12345678910111213func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; // num = [2, 7, 11, 15] target = 9 var dict = [Int: Int]() for (i, v) in nums.enumerated() &#123; // i = 0, v = 2 if let lastIndex = dict[target - v] &#123; return [lastIndex, i] &#125;else &#123; dict[v] = i &#125; &#125; fatalError(\"NO Output\") &#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/"},{"name":"top1_10","slug":"数据结构与算法/LeetCode/top1-10","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/top1-10/"}]},{"title":"1. 两数之和","date":"2019-07-25T09:07:12.000Z","path":"wiki/数据结构与算法/LeetCode/top1_10/3_无重复字符的最长子串/","text":"题目 解法12345678910111213func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; // num = [2, 7, 11, 15] target = 9 var dict = [Int: Int]() for (i, v) in nums.enumerated() &#123; // i = 0, v = 2 if let lastIndex = dict[target - v] &#123; return [lastIndex, i] &#125;else &#123; dict[v] = i &#125; &#125; fatalError(\"NO Output\") &#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/"},{"name":"top1_10","slug":"数据结构与算法/LeetCode/top1-10","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/top1-10/"}]},{"title":"1. 两数之和","date":"2019-07-25T09:07:12.000Z","path":"wiki/数据结构与算法/LeetCode/top1_10/5_最长回文子串/","text":"题目 解法12345678910111213func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] &#123; // num = [2, 7, 11, 15] target = 9 var dict = [Int: Int]() for (i, v) in nums.enumerated() &#123; // i = 0, v = 2 if let lastIndex = dict[target - v] &#123; return [lastIndex, i] &#125;else &#123; dict[v] = i &#125; &#125; fatalError(\"NO Output\") &#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"LeetCode","slug":"数据结构与算法/LeetCode","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/"},{"name":"top1_10","slug":"数据结构与算法/LeetCode/top1-10","permalink":"http://yoursite.com/categories/数据结构与算法/LeetCode/top1-10/"}]},{"title":"4.4 最短路径","date":"2019-07-25T04:07:12.000Z","path":"wiki/数据结构与算法/算法4/第4章图/4.4 最短路径/","text":"记录最短路径相关的主要内容 最短路径： 在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中权重最小者 最短路径树： 包含了顶点s到所有可达的顶点的最短路径 加权有向图的数据结构 下面是实现的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class EdgeWeightedDigraph &#123; var _vertex: Int //顶点的个数 var _edges: Int //边的个数 var _adj: [[DirectedEdge]] //邻接表 init(vertex: Int) &#123; self._vertex = vertex self._edges = 0 self._adj = [[DirectedEdge]](repeating: [DirectedEdge](), count: vertex) &#125; convenience init?(inStream: ReadFile) &#123; let v = inStream.readInt() if v != nil &#123; self.init(vertex: v!) &#125; else &#123; return nil &#125; let edge = inStream.readInt() //读取边数 guard edge != nil else &#123; return nil &#125; for _ in 0..&lt;edge! &#123; let v = inStream.readInt() let w = inStream.readInt() let weight = inStream.readDouble() if v != nil &amp;&amp; w != nil &amp;&amp; weight != nil &#123; let edge = DirectedEdge(v: v!, w: w!, weight: weight!) self.addEdge(edge) &#125; else &#123; return nil &#125; &#125; &#125; func v() -&gt; Int &#123; //返回顶点数 return self._vertex &#125; func e() -&gt; Int &#123; //返回边数 return self._edges &#125; func addEdge(_ edge: DirectedEdge) &#123; self._adj[edge.form()].insert(edge, at: 0) self._edges += 1 &#125; func adj(_ v: Int) -&gt; [DirectedEdge] &#123; return self._adj[v] &#125; func edges() -&gt; [DirectedEdge] &#123; //枚举所有的边 var result = [DirectedEdge]() for v in 0..&lt;self._vertex &#123; for e in self.adj(v) &#123; result.insert(e, at: 0) &#125; &#125; return result &#125;&#125; 最短路径的数据结构 最短路径树中的边，由定点索引的DerectedEdge对象的数组edgeTpo[],其中edge[v]的值未树中连接v和它的父节点的边，也是从s到v的最短路径上的最后一条边 到达起点的距离： 由定点索引的数据distTo[]，其中distTo[v]为从s到v的已知最短路径的长度 边的松弛放松边v-&gt;w意味着检测从s到w的最短路径是否先从s到v，然后再由v到w，如果是，则根据这个情况，更新数据结构的内容 放松一条边，意味着将橡皮筋移到一条更短的路径上，从而缓解了橡皮筋的压力 如果relax改变了边e相关的顶点distTo[e.to()]的值，称为e的放松是成功的。 下图是松弛的示意图 下面是边的松弛代码 12345678func relax(_ edge: DirectedEdge) &#123; //边的松弛 let v = edge.form() let w = edge.to() if distTo[w] &gt; distTo[v] + edge.weight() &#123; distTo[w] = distTo[v] + edge.weight() edgeTo[w] = edge &#125;&#125; 顶点松弛 顶点松弛代码： 123456789func relax(_ graph: EdgeWeightedDigraph, v: Int) &#123; for edge in graph.adj(v) &#123; let w = edge.to() if distTo[w] &gt; distTo[v] + edge.weight() &#123; distTo[w] = distTo[v] + edge.weight() edgeTo[w] = edge &#125; &#125;&#125; 最短路径算法的理论基础最优性条件命题P：令G为一幅加权有向图，顶点s是G的起点，distTo[] 是一个由顶点索引的数组，保存的是G中路径的长度，对于从s可达的所有顶点v，distTo[v]的值是从s到v的某条路径的长度，对于从s不可达的顶点v，该值是无穷大。 当且仅当对于从v到w的任意一条边e，这些值满足distTo[w] &lt;= distTo[v] + e.weight() 命题J： distTo[s] 的初始值为0. 其他distTo[] 元素初始化为无穷大，继续如下操作： 放松G中的任意边，知道不存在有效的边为止，这里有效的含义是没有被放松过。 Dijkstra 算法思路： 首先将distTo[s] 初始化为0. distTo[] 中的其他元素初始化为无穷大，然后将distTo最小的非树顶点放松，并加入树中。 命题R： Dijkstra算法能够解决边权重非负的加权有向图的单起点最短路径问题。 Prim算法每次添加的都是离树最近的顶点，Dijkstra算法每次添加的都是离起点最近的顶点。 实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class DijkstraSP &#123; var edgeTo: [DirectedEdge] //保存路径树，只是和索引顶点连接的父节点对象 var distTo: [Double] //所以是顶点， 顶点到起点的距离 var pq: IndexMinPQ&lt;Double&gt; let s: Int init(graph: EdgeWeightedDigraph, s: Int) &#123; let vertexCount = graph.v() self.edgeTo = [DirectedEdge](repeating: DirectedEdge(), count: vertexCount) self.distTo = [Double](repeating: Double(Int.max), count: vertexCount) pq = IndexMinPQ&lt;Double&gt;(maxN: vertexCount)! self.s = s //第二阶段构造 distTo[s] = 0.0 try! pq.insert(index: s, forKey: 0.0) while !pq.isEmpty() &#123; relax(graph,try! pq.delMin()) &#125; &#125; func relax(_ edge: DirectedEdge) &#123; //边的松弛 let v = edge.form() let w = edge.to() if distTo[w] &gt; distTo[v] + edge.weight() &#123; distTo[w] = distTo[v] + edge.weight() edgeTo[w] = edge &#125; &#125; func relax(_ graph: EdgeWeightedDigraph, _ v: Int) &#123; //顶点的松弛 for edge in graph.adj(v) &#123; let w = edge.to() if distTo[w] &gt; distTo[v] + edge.weight() &#123; distTo[w] = distTo[v] + edge.weight() edgeTo[w] = edge if pq.contains(w) &#123; try! pq.changeKey(index: w, forKey: distTo[w]) &#125; else &#123; try! pq.insert(index: w, forKey: distTo[w]) &#125; &#125; &#125; &#125; func distTo(_ v: Int) -&gt; Double &#123; return distTo[v] &#125; func hasPathTo(_ v: Int) -&gt; Bool &#123; return distTo[v] &lt; Double(Int.max) &#125; func pathTo(_ v: Int) -&gt; [DirectedEdge]? &#123; if !hasPathTo(v) &#123; return nil &#125; let path = Stack&lt;DirectedEdge&gt;() var x = edgeTo[v] repeat &#123; path.push(x) x = edgeTo[x.form()] &#125; while x.form() != self.s path.push(x) //添加第一条路径 return path.iterater() &#125;&#125; 无环加权图中最短路径算法无环图处理更快，按照拓扑顺序遍历 ，不需要自己维护优先队列了 用深度优先搜索得到图的顶点的拓扑顺序5 1 3 6 4 7 0 2 将顶点5 和从他指出的所有边添加到树中 将顶点1 和边1-&gt;3 添加到树中 将顶点3和边3-&gt;6添加到树中，边3-&gt;7失效 将顶点6和6-&gt;2 6-0添加到树中，边6-&gt;4失效 将顶点4和4-&gt;0添加到树中，边4-&gt;7和6-&gt;0 已经失效 将顶点7和边7-&gt;2添加到树中， 边6-&gt;2失效 将顶底0 添加到树中，边0-&gt;2失效 将顶点2添加到树中 命题S： 按照拓扑顺序放松顶点，就能在E+V成正比的时间内解决无环加权有向图的单点最短路径问题。 最长路径命题T： 解决无环加权有向图中最长路径问题所需的事件与V+E成正比。 证明： 给定一个最长路径问题，复制原始无环加权有向图得到一个副本，并将副本中的所有权重变为负值，这样，副本中的最短路径即为原图中的最长路径，要将最短路径问题的答案转化为最长路径问题的答案，只需要将方案中权重变为正值即可。 根据命题S可得到算法的时间复杂度为E+V 最长路径的应用： 优先级限制下的并行任务调度。 也叫关键路径法 优先级限制下的并行任务调度任务如下： 解决并行任务调度问题的关键路径方法的步骤如下： 创建一幅无环加权有向图，其中包括一个起点s和一个重点t，且每个任务都对应着两个顶点，一个起始顶点和一个结束顶点。对于每个任务都有一条从他的起始顶点指向结束顶点的边，边的权重为任务所需的时间。对于每个优先级限制v-&gt;w，添加一条从v的结束顶点指向w的起始顶点的权重为0的边。我们还需要为每个任务添加一条从起点指向该任务的起始顶点的权重为0的边，以及一条从该任务的结束顶点到终点的权重为0的边。这样一个任务预计的开始时间即为从起点到它的起始顶点的最长距离。 下面讲了一个最后期限下的并行任务调度，引出了负权重可能在实际中的用处，进入下一节 一般加权有向图中的最短路径问题负权重环加权有向图中的负权重环是一个总权重为负的有向环 负权重环存在的情况下，可以构建任意小的路径，所以研究最短路径没啥意义 命题X（Bellman-ford算法）：在任意含有V个顶点的加权有向图中给定起点s ，从s无法到达任何负权重环，以下算法能够解决其中的单点点最短路径问题： 将diatTo[s]初始化为0，其他distTo[]元素初始化为无穷大，以任意顺序放松有向图中的所有边，重复V轮。证明使用归纳法 Dellman-ford： 只有上一轮中的distTo[]值发送变化的顶点指出的边才能改变其他distTo[]元素的值，为了记住这样的顶点，使用FIFO优先队列。 说明： 放松边1-3 将顶点3加入队列中 放松边3-6 将顶点6加入队列中 放松边6-4 6-0 6-2，将顶点4 0 2 加入队列中 放松边4-7 4-5 将顶点7 4 加入队列中，放松已经失效的边0-4 0 -2 软后再放松2-7 并重新为4 -7着色 放松7 -5 并重新为4-5着色，办不将顶点5加入队列中，他已经在队列中了，放松已经失效的边7-3 然后放松已经失效的边5-1 5-4 5-7 此时队列为空 参考：算法4 官网地址","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第4章图","slug":"数据结构与算法/算法4/第4章图","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第4章图/"}]},{"title":"4.3 最小生成树","date":"2019-07-23T04:07:12.000Z","path":"wiki/数据结构与算法/算法4/第4章图/4.3 最小生成树/","text":"图的生成树是它的一棵含有所有顶点的无环连通子图，一幅加权无向图的最小生成树(MST)是它的一棵权值(树中所有边的权值之后)最小的生成树 最小生成树的解决方法有： prim算法、kruskal算法 原理树的性质： 用一条边连接树中的任意两个顶点都会产生一个新的环 从树中删去一条边会得到两棵独立的树 切分定理： 图的一种切分是将图的所有顶点分为两个非空且不重复的两个集合，横切边是一条连接两个属于不同集合的顶点的边 命题j： 在一幅加权图中，给定任意的切分，它的横切边中权重最小者必然属于图的最小生成树 证明： 令e为权重最小的横切边，T为图的最小生成树，我们采用反证法：假设T不包含e，那么如果将e假如T，得到的图必要包含一条经过e的环，且这个环至少包含另一条横切边，设为f ，f的权重必然大于e，那么我们删除调f，而保留e就可以得到一颗权重更小的生成树。和我们的假设矛盾。 命题K(最小生成树的贪心算法) 下面这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下，所有边均为灰色，找到一种切分，它产生的横切边均不为黑色，将它的权重最小的横切边标记为黑色，反复，知道标记了V-1条黑色的边为止。 加权无向图的数据类型边的代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051enum EdgeError: Error &#123; case invalidEdge(egdg: Int)&#125;class Edge :Comparable &#123; let _v: Int let _w: Int let _weight: Double init(v: Int, w: Int, weight: Double) &#123; self._v = v self._w = w self._weight = weight &#125; func weight() -&gt; Double &#123; //返回权重 return self._weight &#125; func either() -&gt; Int &#123; //返回任意一个顶点 return self._v &#125; func other(_ v: Int) throws -&gt; Int &#123; //返回另一个顶点 if self._v == v &#123; return self._w &#125; else if (self._w == v) &#123; return self._v &#125; else &#123; print(\"取顶点错误\") throw EdgeError.invalidEdge(egdg: v) &#125; &#125; static func &lt; (lhs: Edge, rhs: Edge) -&gt; Bool &#123; if lhs._weight &lt; rhs._weight &#123; return true &#125; return false &#125; static func == (lhs: Edge, rhs: Edge) -&gt; Bool &#123; if lhs._weight == rhs._weight &#123; return true &#125; return false &#125; func toString() -&gt; String &#123; return String.init(format: \"%d,%d,%.2f\", self._v, self._w, self._weight) &#125;&#125; 加权图的实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class EdgeWeightedGraph &#123; var _vertex: Int //顶点的个数 var _edges: Int //边的个数 var _adj: [[Edge]] //邻接表 init(vertex: Int) &#123; self._vertex = vertex self._edges = 0 self._adj = [[Edge]](repeating: [Edge](), count: vertex) &#125; convenience init?(inStream: ReadFile) &#123; let v = inStream.readInt() if v != nil &#123; self.init(vertex: v!) &#125; else &#123; return nil &#125; let edge = inStream.readInt() if edge != nil &#123; for _ in 0..&lt;edge! &#123; let v = inStream.readInt() let w = inStream.readInt() let weight = inStream.readDouble() if v != nil &amp;&amp; w != nil &amp;&amp; weight != nil &#123; let edge = Edge(v: v!, w: w!, weight: weight!) self.addEdge(edge) &#125; else &#123; return nil &#125; &#125; &#125; else &#123; return nil &#125; &#125; func v() -&gt; Int &#123; //返回顶点数 return self._vertex &#125; func e() -&gt; Int &#123; //返回边数 return self._edges &#125; func addEdge(_ edge: Edge) &#123; let v = edge.either() let w = try! edge.other(v) self._adj[v].insert(edge, at: 0) self._adj[w].insert(edge, at: 0) self._edges += 1 &#125; func adj(_ v: Int) -&gt; [Edge] &#123; return self._adj[v] &#125; func edges() -&gt; [Edge] &#123; //枚举所有的边 var result = [Edge]() for v in 0..&lt;self._vertex &#123; for e in self.adj(v) &#123; if try! e.other(v) &gt; v &#123; result.insert(e, at: 0) &#125; &#125; &#125; return result &#125; func toString() -&gt; String &#123; var result: String = \"\"\" \\(self.v()) vertixes \\(self.e()) edges \\n \"\"\" for i in 0..&lt;self.v() &#123; result += \"\\(i) :\" for w in self.adj(i) &#123; result += \"\\(w.toString()) \" &#125; result += \"\"\" \\n \"\"\" &#125; return result &#125; static func test() &#123; let path = TinyEWG let file = ReadFile(fileName: path) guard file != nil else &#123; print(\"建立文件失败！！！\") return &#125; let edgeGraph = EdgeWeightedGraph(inStream: file!) guard edgeGraph != nil else &#123; print(\"建立图失败\") return &#125; let result = edgeGraph!.toString() print(result) &#125;&#125; 最小生成树的API 和测试用例最小生成树的表示方法： 一组边的列表 一幅加权无向图 一个以顶点为索引且包含父节点链接的数组 Prim 算法思路： 一开始，这棵树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中顶点与不在树中的顶点，且权重最小的边假如树中（即由树中顶点所定义的切分中的一条横切边）。 每当我们向树中添加一条边之后，也向树中添加一个顶点。 就要将连接这个顶点和其他所有不在树中的顶点加入到优先队列中，用marked[]来标识， 但是还有一点，连接新加入树中的顶点，与其他已经在树中的顶点的所有边都失效了。 源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class LazyPrimMST &#123; var _marked: [Bool] //标记是否加入最小生成树中 var _mst: Queue&lt;Edge&gt; var _pq: MinPQ&lt;Edge&gt; init(graph: EdgeWeightedGraph) &#123; let vertexCount = graph.v() self._marked = [Bool](repeating: false, count: vertexCount) self._mst = Queue&lt;Edge&gt;() self._pq = MinPQ&lt;Edge&gt;(priorityFunction: &#123; //优先队列，小的优先级高 return $0 &lt; $1 &#125;) //第二阶段了 ，自定义操作 visit(graph, 0) //将顶点0的邻接表添加到优先队列中 while !self._pq.isEmpty &#123; let e = self._pq.dequeue()! //从优先队列中取出一条边 let v = e.either() let w = try! e.other(v) if self._marked[v] &amp;&amp; self._marked[w] &#123; //如果两个顶点都在树上，那么边是失效的 continue &#125; self._mst.enqueue(e) if !self._marked[v] &#123; self.visit(graph, v) &#125; if !self._marked[w] &#123; self.visit(graph, w) &#125; &#125; &#125; func visit(_ graph: EdgeWeightedGraph, _ v: Int) &#123; self._marked[v] = true for edge in graph.adj(v) &#123; if !self._marked[try! edge.other(v)] &#123; _pq.equeue(edge) &#125; &#125; &#125; func edges() -&gt; [Edge] &#123; //返回最小生成树的边的列表 return self._mst.iterater() &#125;&#125; Prim算法的即时实现思路： 我们感兴趣的只有连接树顶点和非树顶点中权重最小的边，当我们将点点v添加到树中时，对于每个非树顶点w产生的变化只可能使得w到最小生成树的距离更近了，简而言之，我们不需要在优先队列中保存所有从w到树顶点的边—–而只需要保存其中权重最小的边，在将v添加到树中后，检测是否需要更新这条权重最小的边，因为，v-w可能权重更小，我们只需要遍历v的邻接表就可以完成这个任务。 核心： 我们只会在优先队列中保存每个非树顶点w的一条边，将它与树中的顶点连接起来权重最小的那条边。 上面思路理解可以参考下图： edgeTo[] 和distTo[] 的理解： 如果顶点v不在树中，但至少还有一条边和树相连，那么edgeTo[v] 是将v和树相连的最短边，distTo[v] 是这条边的权重 所有这类顶点v都保存在一条优先队列中。 每次从优先队列中出最小的边，更新其他还在优先队列中的边 已经出优先队列的，就是最小生成树的边。 图中颜色的说明： 黑色： 最小生成树中的顶点 灰色： 非最小生成树中的顶点 黑色： 最小生成树的边 红色： 优先队列中的索引对 红色： 非最小生成树顶点连接到最小生成树的最短边 实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243extension Double: RequireInit &#123;&#125;//Prim算法的即时版本class PrimMST &#123; var edgeTo: [Edge] //保存最小生成树的顶点列表，索引顶点，值到该顶点的边 var distTo: [Double] //保存边的距离 var marked: [Bool] //if true on tree var pq: IndexMinPQ&lt;Double&gt; init(graph: EdgeWeightedGraph) &#123; let vertexCount = graph.v() edgeTo = [Edge](repeating: Edge(), count: vertexCount) distTo = [Double](repeating: Double(Int.max), count: vertexCount) marked = [Bool](repeating: false, count: vertexCount) pq = IndexMinPQ&lt;Double&gt;(maxN: vertexCount)! distTo[0] = 0.0 try! pq.insert(index: 0, forKey: 0.0) while !pq.isEmpty() &#123; visit(graph: graph, v: try! pq.delMin()) &#125; &#125; func visit(graph: EdgeWeightedGraph, v:Int) &#123; marked[v] = true for edge in graph.adj(v) &#123; let w = try! edge.other(v) if marked[w] &#123; continue &#125; //跳过失效的边 if edge.weight() &lt; distTo[w] &#123; edgeTo[w] = edge // Edge e is new best connection from tree to w. distTo[w] = edge.weight() if pq.contains(w) &#123; try! pq.changeKey(index: w, forKey: distTo[w]) &#125; else &#123; try! pq.insert(index: w, forKey: distTo[w]) &#125; &#125; &#125; &#125; func edges() -&gt; [Edge] &#123; return edgeTo &#125;&#125; Kruskal思路： 按照边的权重顺序(从小到大)处理他们，将加入最小生成树中，加入的边不会和已经加入的边构成环，直到树中有V-1条边为止。 正确性证明（Kruskal能够计算任意加权无向图的最小生成树）：如果下一条被加入最小生成树的边不会和已有的黑色边构成换，那么它就跨越了由所有和树顶点相邻的顶点组成的集合 以及他们的补集构成的一个切分 参考 算法4 官网地址","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第4章图","slug":"数据结构与算法/算法4/第4章图","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第4章图/"}]},{"title":"4.1 无向图","date":"2019-07-19T04:07:12.000Z","path":"wiki/数据结构与算法/算法4/第4章图/4.1 无向图/","text":"图： 由一组顶点和一组能够将两个顶点相连的边组成的 术语表当两个顶点通过一条边相连时，我们称这两个顶点是相邻的 并称该连接依附于这两个顶点。某个顶点的度数即为依附于他的边的总数。 路径： 在图中，路径是由边顺序连接的一系列顶点。路径或环的长度为其中包含的边数 连通： 当两个顶点之间存在一条连接双方的路径时，我们称一个顶点和另一个顶点是连通的。 连通图： 如果顶点是物理存在的对象，如绳节，边是绳子， 任意顶点提起，连通图是一个整体。 树： 无环连通图 生成树： 连通图的生成树是它的一副子图，包含图中所有顶点，且是一颗树 V个顶点图的树的条件： G有V-1条边且不含有环 G有V-1条边，且是连通 G是连通的，但删除任何一条边，会使它不再连通 G是无环图，但添加任何一条边，都会产生一个环 G中任意一对顶点之间仅存在一条简单路径 密度： 连接顶点对占所有可能别连接的顶点对的比例。 （稀疏图、稠密图） 二分图： 每条边连接的两个顶点都分别属于不同部分, 表示无向图的数据类型 接口 说明 V()-&gt;Int 顶点数 E()-&gt;Int 边数 addEdge(v: Int, w: Int) 向图中添加一个边v-w adj(v: Int)-&gt;[Int] 和v相邻的所有顶点 图的表示方法： 邻接矩阵 ：V*V的矩阵，当顶点V和W之间有相邻的边时，V行和W列的元素值未true 邻接表数组 下图是邻接表内存图： 图的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Graph &#123; var vertex: Int var adj: [[Int]] var edge: Int = 0 init(vertex: Int) &#123; self.vertex = vertex adj = [[Int]](repeating: [Int](), count: vertex) &#125; convenience init?(inStream: ReadFile) &#123; let v = inStream.readInt() if v != nil &#123; self.init(vertex: v!) &#125; else &#123; return nil &#125; let edge = inStream.readInt() if edge != nil &#123; for _ in 0..&lt;edge! &#123; let v = inStream.readInt() let w = inStream.readInt() self.addEdge(v!, w!) &#125; &#125; else &#123; return nil &#125; &#125; func addEdge(_ v: Int, _ w: Int) &#123; self.adj[v].append(w) self.adj[w].append(v) self.edge += 1 &#125; func V() -&gt; Int &#123; return vertex &#125; func E() -&gt; Int &#123; return edge &#125; func toString() -&gt; String &#123; var result: String = \"\"\" \\(V) vertixes \\(E) edges \\n \"\"\" for i in 0..&lt;vertex &#123; result += \"\\(i) :\" for w in adj[i] &#123; result += \"\\(w) \" &#125; result += \"\"\" \\n \"\"\" &#125; return result &#125;&#125; 深度优先搜索图处理的一般策略：从一个顶点移动到另一个顶点 因为顶点2是0的邻接表的第一个元素，且没有标记过，dfs()递归调用自己来标记并访问顶点2 现在，顶点0是2的邻接表的第一个元素，且已经被标记了，因此，dfs跳过了他，接下来，顶点1是2的邻接表的第二个元素，且没有标记过，dfs递归调用自己，来标记并访问顶点1 对顶点1的访问和前面有所不同：因为它的邻接表中的所有顶点（0，2）都已经被标记过了，因此，不需要再递归，方法从dfs（1）返回，下一条被检查的边是2-3，因此dfs递归调用自己，来标记并访问顶点3 顶点5是3的邻接表的第一个元素且没有被标记，因此dfs递归调用自己来标记并访问顶点5 顶点5邻接表中的所有顶点（3，0）都已经被标记过了，因此不需要再递归 顶点4是3的邻接表的下一个元素，且没有被标记过，因此dfs递归调用自己，来标记并访问顶点4，这是最后一个需要被标记的顶点 深度优先能解决的问题： 单点路径，给定一个一副图和一个起点，回答“从s到给定目的顶点v是否存在一条路径？如果有，找出这条路径”等类似问题。 下面是深度优先搜索的代码： 123456789101112131415161718192021222324252627class DepthFirstSearch &#123; private var _marked: [Bool] //描述标记过的顶点 private var _count: Int = 0 //描述标记过的顶点个数 init(G: Graph, s: Int ) &#123; _marked = [Bool](repeating: false, count: G.V() ) dfs(G, s) &#125; func dfs(_ G: Graph, _ v: Int) &#123; _marked[v] = true _count += 1 for w in G.adj(v) &#123; if _marked[w] == false &#123; dfs(G, w) &#125; &#125; &#125; func marked(_ v: Int) -&gt; Bool &#123; return _marked[v] &#125; func count() -&gt; Int &#123; return _count &#125;&#125; 寻找路径在由v-w第一次访问任意w时，将edgeTo[w]设为v来记住这条路径 。所以edgeTo的理解如下： 索引是当前节点，终止节点 值是上一个节点 ，起始节点 树的特定： 以起点为根节点的树。 下面是实现代码: 1234567891011121314151617181920212223242526272829303132333435363738394041class DepthFirstPaths &#123; var _marked: [Bool] // 标记这个顶点调用过dfs了吗？ var _edgeTo: [Int] //从起点到一个顶点的已知路径上的最后一个顶点 let _s: Int // 起点 init(G: Graph, s: Int) &#123; let count = G.V() self._marked = [Bool](repeating: false, count: count) self._edgeTo = [Int](repeating: 0, count: count) self._s = s dfs(G, v: s) &#125; func dfs(_ G: Graph, v: Int) &#123; _marked[v] = true for w in G.adj(v) &#123; if self._marked[w] == false &#123; self._edgeTo[w] = v dfs(G, v: w) &#125; &#125; &#125; func hasPathTo(_ v: Int) -&gt; Bool &#123; return self._marked[v] &#125; func pathTo(_ v: Int) -&gt; [Int]? &#123; if !hasPathTo(v) &#123; return nil &#125; var path = [Int]() var x = v repeat &#123; path.insert(x, at: 0) x = self._edgeTo[x] &#125; while x != self._s path.insert(self._s, at: 0) return path &#125;&#125; 命题A(续)：使用深度优先搜索得到从给定起点到任何标记顶点的路径所需的时间与路径的长度成正比。 广度优先搜索广度优先搜索能解决单点最短路径问题。 要找从s到v的最短路径，从s开始，在所有由一条边就可以到达的点多中寻找v，如果找不到，我们就继续在于s距离两条边的所有顶点中寻找v，如此一直继续。 思路，将起点假如队列中，然后重复下面的步骤： 取出队列中的下一个顶点v，并标记它 将与v相邻的所有未被标记的顶点加入队列中 轨迹说明： 从队列中删除顶点0， 并标记相邻的顶点2，1，5，并加入队列中。并把他们的edgeTo[]设为0 从队列中删去顶点2，并检查它的相邻顶点0，1，发现两者都已经标记，将相邻的顶点3，4加入队列，标记他们，并将edgeTo[]设为2 从队列中删去顶点1，并检查他的相邻顶点0，2，发现他们都已经被标记了 从队列中删去顶点5，并检查他的相邻顶点3，0，发现他们都已经被标记了 从队列中删去顶点3，并检查他的相邻顶点5，4，2，发现他们都已经被标记了 从队列中删去顶点4，并检查他的相邻顶点3，2，发现他们都已经被标记了 下面是广度优先级查找最短路径的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class BreadthFirstPaths &#123; var _marked: [Bool] // 标记这个顶点调用过dfs了吗？ var _edgeTo: [Int] //从起点到一个顶点的已知路径上的最后一个顶点 let _s: Int // 起点 init(G: Graph, s: Int) &#123; let count = G.V() self._marked = [Bool](repeating: false, count: count) self._edgeTo = [Int](repeating: 0, count: count) self._s = s bfs(G,s) &#125; func bfs(_ G: Graph, _ s: Int) &#123; var queue = [Int]() _marked[s] = true queue.append(s) while !queue.isEmpty &#123; let v = queue.removeFirst() //取出一个顶点处理 for w in G.adj(v) &#123; if !self._marked[w] &#123; //邻接顶点没有被标记过 self._marked[w] = true self._edgeTo[w] = v queue.append(w) &#125; &#125; &#125; &#125; func hasPathTo(_ v: Int) -&gt; Bool &#123; return self._marked[v] &#125; func pathTo(_ v: Int) -&gt; [Int]? &#123; if !hasPathTo(v) &#123; return nil &#125; var path = [Int]() var x = v repeat &#123; path.insert(x, at: 0) x = self._edgeTo[x] &#125; while x != self._s path.insert(self._s, at: 0) return path &#125;&#125; 命题B： 从s可达的任意顶点v，广度优先搜索都能找到一条从s到v的最短路径。 深度和广度的相同点： 都是取出下一个顶点，并标记它 将v的所有相邻而又未被标记的顶点加入数据结构 不同之处，在于从数据结构中读取下一个顶点的规则： 对于广度优先级，是最早加入的节点(队列) 深度优先级搜索，最晚加入的节点(栈) 连通分量id数组的理解： 索引，顶点 值： 所在的连通分量标识 连通分量标识的范围为0..count-1 1234567891011121314151617181920212223242526272829303132333435363738class CC &#123; var _marked: [Bool] var _id: [Int] var _count = 0 init(G: Graph) &#123; let vertexCount = G.V() self._marked = [Bool](repeating: false, count: vertexCount) self._id = [Int](repeating: 0, count: vertexCount) for s in 0..&lt;vertexCount &#123; if !_marked[s] &#123; dfs(G, s) self._count += 1 &#125; &#125; &#125; func dfs(_ G: Graph, _ v: Int) &#123; self._marked[v] = true self._id[v] = self._count for w in G.adj(v) &#123; if !self._marked[w] &#123; dfs(G, w) &#125; &#125; &#125; func connected(_ v: Int, _ w: Int) -&gt; Bool &#123; //判断两个顶点是否连通 return self._id[v] == self._id[w] &#125; func id(_ v: Int) -&gt; Int &#123; //返回顶点属于的连通分量 return self._id[v] &#125; func count() -&gt; Int &#123; //返回连通分量的个数 return self._count &#125;&#125; 注意：图是否有环还没有理解 算法4 官网地址","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第4章图","slug":"数据结构与算法/算法4/第4章图","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第4章图/"}]},{"title":"4.2 有向图","date":"2019-07-19T04:07:12.000Z","path":"wiki/数据结构与算法/算法4/第4章图/4.2 有向图/","text":"有向图学习记录 术语有向图： 一幅有方向性的图是由一组顶点和一组有方向的边组成，每条有方向的边都连接着有序的一对顶点。 出度： 顶点指出的边的总数 入度： 指向该顶点的边的总数 有向环： 一条至少含有一条边，且起点和终点相同的有向路径 可达性： 存在v到w的路径时，我们称顶点w能够由顶点v到达 有向图数据类型有向图实现代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Digraph &#123; let _vertex: Int //顶点个数 var _edges: Int = 0 //边数 var _adj:[[Int]] //邻接表二维数组 init(v: Int) &#123; self._vertex = v self._adj = [[Int]](repeating: [Int](), count: v) &#125; func v() -&gt; Int &#123; //返回顶点的个数 return self._vertex &#125; func e() -&gt; Int &#123; //返回边的个数 return self._edges &#125; func addEdge(_ v: Int, _ w:Int ) &#123; //添加v-&gt;w的边 self._adj[v].insert(w, at: 0) self._edges += 1 &#125; func adj(_ v: Int) -&gt; [Int] &#123; //返回顶点v的邻接表 return self._adj[v] &#125; func reverse() -&gt; Digraph &#123; let r = Digraph(v: self.v()) for v in 0..&lt;self.v() &#123; for w in self.adj(v) &#123; r.addEdge(v, w) &#125; &#125; return r &#125; func toString() -&gt; String &#123; var result: String = \"\"\" \\(self.v()) vertixes \\(self.e()) edges \\n \"\"\" for i in 0..&lt;self.v() &#123; result += \"\\(i) :\" for w in self.adj(i) &#123; result += \"\\(w) \" &#125; result += \"\"\" \\n \"\"\" &#125; return result &#125;&#125; 对应的邻接表如下图所示： 有向图的可达性代码： 123456789101112131415161718192021222324252627282930class DirectedDFS &#123; var _marked: [Bool] // 标记节点是否调用过dfs， 索引是顶点 init(graph: Digraph, s: Int) &#123; self._marked = [Bool](repeating: false, count: graph.v()) dfs(graph, s) &#125; init(graph: Digraph, sources: [Int]) &#123; self._marked = [Bool](repeating: false, count: graph.v()) for s in sources &#123; if !self._marked[s] &#123; dfs(graph, s) &#125; &#125; &#125; func dfs(_ graph: Digraph,_ v: Int) &#123; self._marked[v] = true for w in graph.adj(v) &#123; if !self._marked[w] &#123; dfs(graph, w) &#125; &#125; &#125; func marked(_ v: Int) -&gt; Bool &#123; return self._marked[v] &#125;&#125; 环和有向无环图一幅有向图有环吗？ 深度优先搜索也能解决这个问题 由系统维护的递归调用的栈表示的真是“当前” 正在遍历的有向路径，一旦我们找到了一条边，v-&gt;w且w已经存在于栈中，就找到了一个环，因为栈比欧式的是一条w-&gt;v 的有向路径，而v-&gt;w正好补全了这个环。 下面是检测是否有环的检测代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class DirectedCycle &#123; var _marked: [Bool] var _edgeTo: [Int] var _cycle: Stack&lt;Int&gt;? var _onStack: [Bool] init(graph: Digraph) &#123; let vertexCount = graph.v() self._marked = [Bool](repeating: false, count: vertexCount) self._edgeTo = [Int](repeating: 0, count: vertexCount) self._onStack = [Bool](repeating: false, count: vertexCount) for v in 0..&lt;vertexCount &#123; if !self._marked[v] &#123; dfs(graph, v) &#125; &#125; &#125; func dfs(_ graph: Digraph, _ v: Int) &#123; self._onStack[v] = true self._marked[v] = true for w in graph.adj(v) &#123; if !self._marked[w] &#123; //如果没有标记，递归标记（这里不需要判断换，没有标记过，肯定不在调用栈上） self._edgeTo[w] = v dfs(graph, w) &#125; else &#123; //标记过了，可以判断这个顶点是否在栈上 if self._onStack[w] &#123; //有环 self._cycle = Stack&lt;Int&gt;() var x = v repeat &#123; self._cycle?.push(x) x = self._edgeTo[x] &#125; while x != w self._cycle?.push(w) self._cycle?.push(v) &#125; &#125; &#125; self._onStack[v] = false &#125; func hasCycle() -&gt; Bool &#123; return self._cycle != nil &#125; func cycle() -&gt; [Int] &#123; if self.hasCycle() &#123; return self._cycle!.iterater() &#125; else &#123; return [Int]() &#125; &#125;&#125; 输出深度优先搜索的遍历顺序 12345678910111213141516171819202122232425262728293031323334353637383940414243class DepthFirstOrder &#123; var _marked:[Bool] var _pre: Queue&lt;Int&gt; var _post: Queue&lt;Int&gt; var _reversePost: Stack&lt;Int&gt; init(graph: Digraph) &#123; _pre = Queue&lt;Int&gt;() _post = Queue&lt;Int&gt;() _reversePost = Stack&lt;Int&gt;() let vertexCount = graph.v() _marked = [Bool](repeating: false, count: vertexCount) for v in 0..&lt;vertexCount &#123; if !self._marked[v] &#123; dfs(graph, v) &#125; &#125; &#125; func dfs(_ graph: Digraph,_ v: Int) &#123; self._pre.enqueue(v) self._marked[v] = true for w in graph.adj(v) &#123; if !self._marked[w] &#123; dfs(graph, w) &#125; &#125; self._post.enqueue(v) self._reversePost.push(v) &#125; func pre() -&gt; [Int] &#123; return self._pre.iterater() &#125; func post() -&gt; [Int] &#123; return self._post.iterater() &#125; func reversePost() -&gt; [Int] &#123; return self._reversePost.iterater() &#125;&#125; 拓扑顺序 123456789101112131415161718class Topological &#123; var _order: [Int]? init(graph: Digraph) &#123; let cycle = DirectedCycle(graph: graph) if !cycle.hasCycle() &#123; let dfs = DepthFirstOrder(graph: graph) self._order = dfs.reversePost() &#125; &#125; func order() -&gt; [Int]? &#123; return self._order &#125; func isDAG() -&gt; Bool &#123; return self._order != nil &#125;&#125; 命题F： 一幅有向无环图的拓扑排序即为所有顶点的逆后序排序 证明： 对于任意边 v-&gt;w，在调用dfs(v)时，下面三种情况必有一种成立 dfs(w) 已经被调用过，且已经返回了(w已经标记了) dfs(w) 还没有被调用(w还未被标记)，因此v-&gt;w会直接或间接调用并返回dfs(w) ，且dfs(w) 会在dfs(v) 返回之前返回 dfs(w) 已经被调用，但还没有返回，证明的关键在于此，在有向无环图中，这种情况是不可能出现的，这是由于递归调用链意味着存在w到v的路径，但存在v-&gt;w的表示存在一个环在两种可能的情况中，dfs(w) 都会在dfs(v) 之前完成，因此在后续排列中w排列在v之前，而在逆后序中，w排在v之后，因此任意一条边v-&gt;w都如我们所愿从排名较前的顶点指向排名较后的顶点。 命题G： 使用深度优先搜索，对有向无环图进行拓扑排序，所需的时间和V+E成正比 有向图中的强连通性强连通性： 如果两个顶点v和w是相互可达的，则，他们是强连通的。 强连通分量的定义是基于顶点的，是由于： 有些边的两个顶点都在同一个连通分量中，而有限边连接的顶点在不同的强连通分量中。 kosarajuCC算法： 在给定一幅有向图G中，使用DepthFirstOrder来计算它的反向图$$G^R$$的逆后序排列 在G中进行标准的深度优先搜索，但是，要按照刚才计算得到的顺序来访问所有未标记的顶点 在构造函数中，所有在同一个递归dfs() 调用中被访问到的顶点都在同一个连通分量中，将他们按照和CC相同的方式识别出来 实现代码： 12345678910111213141516171819202122232425262728293031323334353637383940class KosarajuCC &#123; var _marked: [Bool] //已达顶点 var _id: [Int] //分量标识，索引顶点，值是连通分量标识 var _count = 0 //分量个数 init(graph: Digraph) &#123; let vertexCount = graph.v() self._marked = [Bool](repeating: false, count: vertexCount) self._id = [Int](repeating: 0, count: vertexCount) let order = DepthFirstOrder(graph: graph.reverse()) for s in order.reversePost() &#123; if !_marked[s] &#123; dfs(graph, s) self._count += 1 &#125; &#125; &#125; func dfs(_ G: Digraph, _ v: Int) &#123; self._marked[v] = true self._id[v] = self._count for w in G.adj(v) &#123; if !self._marked[w] &#123; dfs(G, w) &#125; &#125; &#125; func stronglyConnected(_ v: Int, _ w: Int) -&gt; Bool &#123; //判断两个顶点是否连通 return self._id[v] == self._id[w] &#125; func id(_ v: Int) -&gt; Int &#123; //返回顶点属于的连通分量 return self._id[v] &#125; func count() -&gt; Int &#123; //返回连通分量的个数 return self._count &#125;&#125; 参考 算法4 官网地址","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第4章图","slug":"数据结构与算法/算法4/第4章图","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第4章图/"}]},{"title":"42_动态规划实战","date":"2019-07-19T01:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/42_动态规划实战/","text":"记录动态规划思想 量化两个字符串的相似度 莱文斯坦距离 最长公共子串 如何计算 一个字符一个字符的比较，符合段阶段最优解 回溯（暴力破解） 相等： 如果a[i]和 b[i] 匹配 ，我们递归的考察a[i+1] b[j+1]如果不匹配： 可以删除a[i] 比较a[i+1] ,b[j] 可以删除b[j] 比较a[i],b[j+1] 可以在a[i] 前面添加一个和b[j] 相等的字符，比较a[i],b[j+1] 可以在b[j] 前面添加一个a[i] 想的的字符，比较a[i+1] b[j] 可以将a[i] 替换成b[j] 或者b[j] 替换a[i] 然后递归的考察a[i+1] b[j+1] 递归树，查看是否有重复的问题 状态转移公式 状态表 代码填状态表 （一定考虑前一个状态到当前状态转化的方式） 下面是莱文斯坦距离的两种计算方式，回缩法、动态规划： 123456789101112131415161718192021222324252627282930class StringDistance &#123; let a = \"mitcmu\" let b = \"mtacnu\" let n = 6 let m = 6 var minDis = Int.max func lwstBT(i: Int, j:Int , edist: Int) &#123; if i == n || j == m &#123; var minEditDidtance = edist if i &lt; n &#123; minEditDidtance += (n - i) &#125; if j &lt; m &#123; minEditDidtance += (m-j) &#125; if minEditDidtance &lt; minDis &#123; minDis = minEditDidtance &#125; return &#125; if a[a.ljIndex(i)] == b[b.ljIndex(j)] &#123; lwstBT(i: i + 1, j: j+1, edist: edist) &#125; else &#123; //两个字符不匹配 lwstBT(i: i, j: j+1, edist: edist + 1) // 删除 b[j] 或者 a[i] 前添加一个字符 lwstBT(i: i+1, j: j, edist: edist + 1) // 删除 a[i] 或者 b[j] 前添加一个字符 lwstBT(i: i+1, j: j+1, edist: edist + 1) // 将 a[i] 和 b[j] 替换为相同字符 &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536func lwstDP() -&gt; Int &#123; //初始化状态表 var status = [[Int]](repeating: [Int](repeating: 0, count: m), count: n) //初始状态 for j in 0..&lt;m &#123; // 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离 if a[a.ljIndex(0)] == b[b.ljIndex(j)] &#123; status[0][j] = j &#125; else if j != 0 &#123; status[0][j] = status[0][j-1]+1 &#125; else &#123; status[0][j] = 1 &#125; &#125; for i in 0..&lt;n &#123; // 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离 if a[a.ljIndex(i)] == b[b.ljIndex(0)] &#123; status[i][0] = i &#125; else if i != 0 &#123; status[i][0] = status[i-1][0]+1 &#125; else &#123; status[i][0] = 1 &#125; &#125; for i in 1..&lt;n &#123; // 按行填表 for j in 1..&lt;m &#123; if a[a.ljIndex(i)] == b[b.ljIndex(j)] &#123; status[i][j] = min(status[i-1][j],status[i][j-1],status[i-1][j-1]) &#125; else &#123; status[i][j] = min(status[i-1][j],status[i][j-1],status[i-1][j-1]) + 1 &#125; &#125; &#125; return status[n-1][m-1]&#125; 下面是最长公共子串的动态规划代码： 123456789101112131415161718192021222324252627282930313233343536func lcs() -&gt; Int &#123; //初始化状态表 var status = [[Int]](repeating: [Int](repeating: 0, count: m), count: n) //初始状态 for j in 0..&lt;m &#123; // 初始化第 0 行:a[0..0] 与 b[0..j] 的编辑距离 if a[a.ljIndex(0)] == b[b.ljIndex(j)] &#123; status[0][j] = 1 &#125; else if j != 0 &#123; status[0][j] = status[0][j-1] &#125; else &#123; status[0][j] = 0 &#125; &#125; for i in 0..&lt;n &#123; // 初始化第 0 列:a[0..i] 与 b[0..0] 的编辑距离 if a[a.ljIndex(i)] == b[b.ljIndex(0)] &#123; status[i][0] = 1 &#125; else if i != 0 &#123; status[i][0] = status[i-1][0] &#125; else &#123; status[i][0] = 0 &#125; &#125; for i in 1..&lt;n &#123; // 按行填表 for j in 1..&lt;m &#123; if a[a.ljIndex(i)] == b[b.ljIndex(j)] &#123; status[i][j] = max(status[i-1][j],status[i][j-1],status[i-1][j-1]+1) &#125; else &#123; status[i][j] = max(status[i-1][j],status[i][j-1],status[i-1][j-1]) &#125; &#125; &#125; return status[n-1][m-1]&#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"41_动态规划理论","date":"2019-07-18T03:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/41_动态规划理论/","text":"记录动态规划思想 一个模型、三个特征一个模型：多阶段决策最优模型。解决最优问题，在解决的过程中，需要经历多个决策阶段，每个决策阶段对应一组状态，然后我们寻找一组决策序列，经过这组决策序列，产生最终期望的最优解。 最优子结构：问题的最优解包含子问题的最优解，反过来说，我们可以通过子问题的最优解，推导出问题的最优解。也就是后阶段的状态可以通过前阶段的状态推导出来。 无后效性：推导后面，只需要关心前面状态值，不关心状态怎么推导出来。某阶段的状态一旦确定，就不会受之后阶段的决策影响。 重复子问题：达到某个相同阶段时，可能产生重复的状态 两种动态规划的解决思路 状态转移表法，：回溯算法实现- 定义状态 - 画递归树、找重复子问题、 话状态转移表- 将填表过程翻译为代码 状态转移方程法：找最优子结构- 写状态转移方程- 将状态转移方程翻译为代码。 思考题的答案1234567891011121314151617181920212223242526272829303132333435363738394041424344struct Money &#123; func payMoney() &#123; //定义输入数据 let values = [1,3,5] //钱币的种类 let pm = 9 //支付金额payMoney //定义自动变量 let step = pm/values[0] + 1 //定义最大步数 var states = [[Int]](repeating: [Int](repeating: 0, count: pm+1), count: step) //定义状态图 //初始化第一行 for i in 0..&lt;values.count &#123; states[0][values[i]] = values[i] &#125; //每步选择一种钱币，翻译状态图 for i in 1..&lt;step &#123; for k in 0..&lt;values.count &#123; for j in 0...pm-values[k] &#123; //行 if states[i-1][j] &gt; 0 &#123; states[i][j+values[k]] = values[k] &#125; &#125; &#125; &#125; for i in 0..&lt;step &#123; if states[i][pm] &gt; 0 &#123; //找到了 print(\"找到了一种方案： 使用的币的个数：\\(i+1)\") var column = pm for j in stride(from: i, through: 0, by: -1) &#123; let currentMoney = states[j][column] print(currentMoney) //当前币的大小 column -= currentMoney &#125; break //退出打印最少币种的方式，不退出打印所有方式。 &#125; &#125; &#125; static func testPayMoney() &#123; let ins = Money() ins.payMoney() &#125;&#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"39_回溯思想","date":"2019-07-17T03:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/39_回溯思想/","text":"记录回溯思想 回溯思想遇到分岔路口时， 随意选择一条路，当发现一条路不通时，回到上一个岔路口。 八皇后问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Queen8 &#123; var count = 0 var result = Array(repeating: 0, count: 8) func cal8Queens(row:Int) &#123; if row == 8 &#123; printQueens(result: result) return &#125; for column in 0..&lt;8 &#123; //每一行都有8种方法 if isOK(row: row, column: column) &#123; result[row] = column cal8Queens(row: row + 1) &#125; &#125; &#125; func isOK(row: Int, column: Int) -&gt; Bool &#123; var leftUp = column - 1 var rightUp = column + 1 for i in stride(from: row-1, through: 0, by: -1) &#123; if result[i] == column &#123; return false &#125; if leftUp &gt;= 0 &amp;&amp; result[i] == leftUp &#123; return false &#125; if rightUp &lt; 8 &amp;&amp; result[i] == rightUp &#123; return false &#125; leftUp -= 1 rightUp += 1 &#125; return true &#125; func printQueens(result: [Int]) &#123; for i in 0..&lt;8 &#123; for j in 0..&lt;8 &#123; if result[i] == j &#123; print(\"Q \", terminator: \"\") &#125; else &#123; print(\"* \", terminator: \"\") &#125; &#125; print(\" \") &#125; print(\"一种方案完成---------\") count += 1 &#125; static func testQueen8() &#123; let queen = Queen8() queen.cal8Queens(row: 0) print(queen.count) //92种方案 &#125;&#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"分治思想","date":"2019-07-17T03:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/38_分治思想/","text":"记录分治思想 分治思想分治，分而治之。分治是一种处理问题的思想，递归是一种编程技巧。 步骤： 分解：将源问题分解成一系列子问题 解决：递归的求解各个子问题，若子问题足够小，直接求解 合并：将子问题的结果合并成源问题 满足的条件： 原问题与分解的小问题具有相同的模式 原问题分解的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法和动态规划的明显区别 具有分解终止条件，也就是说，当问题足够小时，可以直接求解 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高 下面是分治求解逆序度的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Division &#123; var num = 0 func count(a: inout [Int], count: Int) -&gt; Int &#123; num = 0 mergeSortCounting(a: &amp;a, p: 0, r: count - 1 ) return num &#125; func mergeSortCounting(a: inout [Int], p: Int, r: Int) &#123; if p &gt;= r &#123; return &#125; let q = (p + r) / 2 mergeSortCounting(a: &amp;a, p: p, r: q) mergeSortCounting(a: &amp;a, p: q+1, r: r) merge(a: &amp;a, p: p, q: q, r: r) &#125; func merge(a: inout [Int], p: Int, q: Int, r: Int) &#123; var i = p var j = q + 1 var k = 0 var temp: [Int] = Array(repeating: 0, count: r-p+1) while i &lt;= q &amp;&amp; j &lt;= r &#123; if a[i] &lt;= a[j] &#123; temp[k] = a[i] i += 1 &#125; else &#123; num += (q - i + 1) temp[k] = a[j] j += 1 &#125; k += 1 &#125; while i &lt;= q &#123; temp[k] = a[i] i += 1 k += 1 &#125; while j &lt;= r &#123; temp[k] = a[j] j += 1 k += 1 &#125; for i in 0 ... r-p &#123; a[p+i] = temp[i] &#125; &#125; static func testDivision() &#123; var a = [2,4,3,1,5,6] let division = Division() print(division.count(a: &amp;a, count: 6)) &#125;&#125; 可以解决的问题分治可以解决耗时问题、大内存问题。","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"40_初识动态规划","date":"2019-07-17T03:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/40_初识动态规划/","text":"记录动态规划思想 0-1 背包问题在满足最大重量的限制前提下，背包中总重量的最大值是多少? 回溯方式解决代码： 12345678910111213141516171819202122232425class Problem01_BackTrace &#123; var maxW = Int.min // 结果放到 maxW 中 let weight = [2,2,4,6,3] var n = 5 var w = 9 func maxWeight(i: Int, cw: Int) &#123; if cw == w || i == n &#123; //cw==w 表示装满了，i==n 表示物品都考察完了 if cw &gt; maxW &#123; maxW = cw //更新最大值 &#125; return &#125; maxWeight(i: i + 1, cw: cw) ;//选择不装i个物品 if cw + weight[i] &lt;= w &#123; maxWeight(i: i + 1, cw: weight[i] + cw) &#125; &#125; static func testMaxWeight() &#123; let problem01Instance = Problem01_BackTrace() problem01Instance.maxWeight(i: 0, cw: 0) print(problem01Instance.maxW) &#125;&#125; 下面是动态规划方式解决 1234567891011121314151617181920212223242526272829303132333435363738class Problem0_1 &#123; func knapsack(weight: [Int], n: Int, w: Int) -&gt; Int &#123;//weight: 物品重量，n: 物品个数，w: 背包可承载重量 var states = [[Bool]](repeating: [Bool](repeating: false, count: w+1), count: n) states[0][0] = true if weight[0] &lt; w &#123; states[0][weight[0]] = true &#125; for i in 1..&lt;n &#123; for j in 0...w &#123; if states[i-1][j] == true &#123; states[i][j] = states[i-1][j] &#125; &#125; for j in 0...w - weight[i] &#123; if states[i-1][j] == true &#123; states[i][j+weight[i]] = true &#125; &#125; &#125; for i in stride(from: w, through: 0, by: -1) &#123; if states[n-1][i] == true &#123; return i &#125; &#125; return 0 &#125; static func testKnapsack() &#123; let problem01 = Problem0_1() let weight = [2,2,4,6,3] let n = 5 let w = 9 let result = problem01.knapsack(weight: weight, n: n, w: w) print(result) &#125;&#125; 我们把上一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。 下面是思考题杨辉三角的答案 12345678910111213141516171819202122232425262728293031323334class YangHuiTriangle &#123; let matrix = [[5],[7,8],[2,3,4],[4,9,6,1],[2,7,9,4,5]] func yanghuiTirangle(_ matrix: [[Int]]) -&gt; Int &#123; var states = [[Int]](repeating: [Int](repeating: matrix.count, count: 5), count: matrix.count) states[0][0] = matrix[0][0] for i in 1..&lt;matrix.count &#123; for j in 0..&lt;matrix[i].count &#123; if j == 0 &#123; states[i][j] = states[i-1][j] + matrix[i][j] &#125; else if j == matrix[i].count - 1 &#123; states[i][j] = states[i-1][j-1] + matrix[i][j] &#125; else &#123; let top1 = states[i-1][j-1] let top2 = states[i-1][j] states[i][j] = min(top1, top2) + matrix[i][j] &#125; &#125; &#125; var minDis = Int.max for i in 0..&lt;matrix[matrix.count-1].count &#123; let distance = states[matrix.count-1][i] if distance &lt; minDis &#123; minDis = distance &#125; &#125; return minDis &#125; static func testTirangle() &#123; let triangle = YangHuiTriangle() let result = triangle.yanghuiTirangle(triangle.matrix) print(result) &#125;&#125; 总结 贪心：一条路走到黑，就一次机会，只能哪边看着顺眼走哪边 回溯：一条路走到黑，无数次重来的机会，还怕我走不出来 (Snapshot View) 动态规划：拥有上帝视角，手握无数平行宇宙的历史存档， 同时发展出无数个未来 (Versioned Archive View)","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"swift 使用经验","date":"2019-07-17T01:07:12.000Z","path":"wiki/IOS/swift语言/swift使用经验/","text":"列举swift使用经验 Swift 数组Array作为函数参数时如何在函数内部改变其值？Swift中我们可以在参数类型的前面加上一个 inout 关键字，并在调用函数时在参数前加个取地址符 &amp;，如下所示： 123456func doSomething(numArr: inout [String])&#123; numArr.append(\"4\")&#125;var numbers = [\"1\",\"2\",\"3\"]doSomething(numArr: &amp;numbers)print(numbers) 注意，inout 修饰参数时采用的是拷入拷出模式，即在函数内部使用的是参数的copy，函数结束后，又对参数重新赋值。 由此，可以延伸一下，当一个类的属性被设置了 willSet 和 didSet 观察器时，如果该属性被作为函数参数，同时被 inout 修饰，那么当调用此函数时，会触发 willSet 和 didSet 观察器。 for循环倒序1234567for i in (0...10).reversed() &#123; print(i)&#125;for i in stride(from:3,through:0,by: -1) &#123; print(i)&#125; Swift的stride函数返回一个任意可变步长类型值的序列。可变步长类型是可以设置偏移量的一维标量。他有两个变种: from，to，最后一个值将会严格小(大)于to的值stride(from:3, to:0, by:-1) 表示3，2，1 from，through，最后一个值将会小(大)于等于through的值stride(from:3, through:0, by:-1) 表示3，2，1，0","tags":[],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"}]},{"title":"AC自动机多模式匹配","date":"2019-07-16T04:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/36_AC自动机/","text":"记录AC算法的主要思想 失效指针计算计算失效指针的过程，看起来复杂，其实，如果我们把树中深度相同的节点放到同一层，那么某个节点的失败指针只能出现在上一层。 说白了，当前点相同， 找后缀的最长前缀 12345678910111213141516171819202122232425262728293031func buildFailurePoint() &#123; var queue:[ACNode] = Array() root.fail = nil queue.append(root) while !queue.isEmpty &#123; let p = queue.removeFirst() for i in 0..&lt;26 &#123; let pc = p.children[i] //p的子节点 if pc == nil &#123; //如果当前节点没有值，当然没有必要求失败指针了 continue &#125; if p == root &#123; //如果父节点，第二层，没必要循环了，直接设置为root pc!.fail = root &#125; else &#123; var q:ACNode? = p.fail while q != nil &#123; let qc = q?.children[pc!.data.toInt() - Character(\"a\").toInt()] if qc != nil &#123; //处理相等的情况，最长后缀加长 pc?.fail = qc break &#125; q = q!.fail //循环的根节点吧 ，退而求其，找个短的 &#125; if q == nil &#123; pc?.fail = root &#125; &#125; queue.append(pc!) &#125; //end for &#125;//end while&#125; 其中ACNode定义如下： 123456789101112131415161718class ACNode &#123; var data: Character //节点的key var children : [ACNode?] // 指向子节点的数组，字符集只包含 a~z 这 26 个字符 var isEndingChar = false //结尾字符为true var length = -1 //当isEndingChar= true时，记录模式串的长度 var fail:ACNode? // 失败指针 init(data:Character) &#123; self.data = data self.children = Array(repeating: nil, count: childrenCount) &#125; static func == (lhs: ACNode, rhs: ACNode) -&gt; Bool &#123; if lhs.data == rhs.data &#123; return true &#125; return false &#125;&#125; 12345678910111213func insert(text: String) &#123; var p = root for i in 0..&lt;text.count &#123; let index:Int = text[text.index(text.startIndex, offsetBy: i)].toInt() - Character(\"a\").toInt() if p.children[index] == nil &#123; let newNode = ACNode(data: text[text.index(text.startIndex, offsetBy: i)]) p.children[index] = newNode &#125; p = p.children[index]! &#125; p.isEndingChar = true; p.length = text.count&#125; 12345678910111213141516171819202122232425func mach(text: String) &#123; let n = text.count var p: ACNode? = root for i in 0..&lt;n &#123; //for里面p不可能为nil let index = text[text.index(text.startIndex, offsetBy: i)].toInt() - Character(\"a\").toInt() while p?.children[index] == nil &amp;&amp; p !== root &#123; //向树根节点移动，找最长后缀 p = p?.fail! // 失败指针发挥作用的地方 &#125; //下面逻辑处理匹配情况， p增加 p = p?.children[index] if p == nil &#123; p = root // 如果没有匹配的，从 root 开始重新匹配 &#125; var tmp = p! while tmp !== root &#123; if tmp.isEndingChar == true &#123; let pos = i - tmp.length + 1 print(\"匹配的起始下标 \\(pos) length=\\(tmp.length)\") &#125; tmp = tmp.fail!; &#125; &#125;&#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"KMP字符串查找","date":"2019-07-12T10:07:12.000Z","path":"wiki/数据结构与算法/数据结构和算法之美/34_KMP/","text":"记录KMP算法的主要思想 思想模式串和主串匹配的过程，当遇到不匹配的字符的时候，我们希望找到一种规律，可以往后多滑动几位。 模式串和主串匹配的过程中，存在相等和不相等的可能。 不相等的处理：拿好前缀本身，在它的后缀子串中，查找最长的那个可以和好前缀的前缀子串匹配。 1234567891011121314151617181920func kmp(a: String, n: Int, b: String, m:Int) -&gt; Int &#123; let next = getNexts(b: b, m: m) var j = 0 for i in 0..&lt;n &#123; while j &gt; 0 &amp;&amp; a[a.index(a.startIndex, offsetBy: i)] != b[b.index(b.startIndex, offsetBy: j)] &#123; //处理不等于的情况，i不动，j尽量移动多位 j = next[j-1] + 1 &#125; //相等，继续往后比较 if a[a.index(a.startIndex, offsetBy: i)] == b[b.index(b.startIndex, offsetBy: j)] &#123; j += 1 &#125; //查找到了结果 if j == m &#123; return i - m + 1 &#125; &#125; return -1;&#125; 失效函数计算方法next说明： 下标：每个前缀结尾的下标 值： 这个前缀的最长可以匹配的前缀子串的结尾下标 next[i-1] = k-1,则next[i] = k 查找b[0,i-1]的次长可匹配后缀子串，这个问题变成， 查找b[0,y]的最长匹配后缀子串的问题 12345678910111213141516/*失效函数： b 表示模式串，m表示模式串的长度*/func getNexts(b: String, m: Int) -&gt; [Int] &#123; var next:[Int] = Array(repeating: -1, count: m) //定义失效函数 var k = -1 for i in 0..&lt;m &#123; while k != -1 &amp;&amp; b[b.index(b.startIndex, offsetBy: k+1)] != b[b.index(b.startIndex, offsetBy: i)] &#123; k = next[k] &#125; if b[b.index(b.startIndex, offsetBy: k+1)] == b[b.index(b.startIndex, offsetBy: i)] &#123; k += 1 &#125; next[k] = k &#125; return next&#125;","tags":[],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"数据结构和算法之美","slug":"数据结构与算法/数据结构和算法之美","permalink":"http://yoursite.com/categories/数据结构与算法/数据结构和算法之美/"}]},{"title":"理解OAuth","date":"2019-07-11T04:11:35.000Z","path":"wiki/编程理论/OAuth 2.0/OAuth/","text":"理解OAuth 原理分析 参考资料 理解OAuth 2.0","tags":[],"categories":[{"name":"编程理论","slug":"编程理论","permalink":"http://yoursite.com/categories/编程理论/"},{"name":"OAuth 2.0","slug":"编程理论/OAuth-2-0","permalink":"http://yoursite.com/categories/编程理论/OAuth-2-0/"}]},{"title":"Swift新特性","date":"2019-07-02T04:07:12.000Z","path":"wiki/IOS/swiftUI/swiftUI/","text":"本文按照自己的思路理解swift的新特性 function Builder 新特性单表达式隐式返回计算属性、函数语句、闭包表达式，如果只有一个表达式，可以省略return关键字 123456struct Rectangle &#123; var width = 0.0, height = 0.0 var area1: Double &#123; width * height &#125; func area2() -&gt; Double &#123; width * height &#125;&#125; 根据结构体默认成员合成默认初始化器12345678910struct Dog &#123; var name = \"Generic dog name\" var age = 0&#125;let boltNewborn = Dog()let daisyNewborn = Dog(name: \"Daisy\", age: 0)// before swift 5.0 ❎let benjiNewborn = Dog(name: \"Benji\")// after switft 5.1 ✅let benjiNewborn = Dog(name: \"Benji\") 属性包装器 不透明返回类型协议中有关联类型，不是一个完全类型，编译时，无法推断类型，使用some 修饰协议返回值，就是不透明返回类型，使用者不知道类型， 编译器知道具体的类型。 123456// after switft 5.1 ✅struct ContentView: View &#123; var body: some View &#123; Text(\"\") &#125;&#125; Swift Style DSL / Function Builder 值类型和引用类型优先使用值类型，在栈上分配，COW 协议还是泛型使用协议时，尽量优先抽取功能，使用组合协议 抽象数据访问@Binding @State @EnviromentObject @Enviroment。 View链式调用的理解 参考 官方教程 SwiftUI 的一些初步探索 (一) 系列文章深度解读|SwiftUI 背后那些事儿","tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://yoursite.com/tags/SwiftUI/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swiftUI","slug":"IOS/swiftUI","permalink":"http://yoursite.com/categories/IOS/swiftUI/"}]},{"title":"SwiftUI 数据流理解","date":"2019-07-02T04:07:12.000Z","path":"wiki/IOS/swiftUI/swiftUI_DataFlow/","text":"对于不变的常量直接传递给 SwiftUI 即可。 对于控件上需要管理的状态使用 @State 管理。 对于外部的事件变化使用 BindableObject 发送通知。 对于需要共享的视图可变数据使用 @ObjectBinding 管理。 不要出现多个状态同步管理，使用 @Binding 共享一个 Source of truth。 对于系统环境使用 @Enviroment 管理。 对于需要共享的不可变数据使用 @EnviromemntObject 管理。 @Binding 具有引用语义，可以很好的和 @Binding @objectBinding @State 协作，避免出现多个数据不同步。 State Binding(引用语义) BindingConvertible（state转化为引用语义的Binding） BindableObject（接受外部通知） ObjectBinding(多个界面共用一个数据，内部包装多个界面) EnvionmentObject(环境对象) 参考 官方教程 SwiftUI 的一些初步探索 (一) 系列文章深度解读|SwiftUI 背后那些事儿","tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://yoursite.com/tags/SwiftUI/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swiftUI","slug":"IOS/swiftUI","permalink":"http://yoursite.com/categories/IOS/swiftUI/"}]},{"title":"SwiftUI 分享内容","date":"2019-07-02T04:07:12.000Z","path":"wiki/IOS/swiftUI/swiftUI_Share/","text":"介绍SwiftUI 跨平台技术演变史 H5+原生（Cordova） JavaScript开发+原生渲染 （React Native、Weex） 自绘UI+原生功能(Flutter、SwiftUI) H5+原生 缺点： webview渲染存在性能瓶颈、复杂任务无法胜任 调用原生功能需要封装插件，麻烦 JavaScript开发+原生渲染 分析： 解决了Webview渲染性能问题，相比较于原生，多了从Vue到原始的翻译过程。 调用原生功能需要封装插件，也比较麻烦 自绘UI+原生功能 flutter Dart语言开发, Skia渲染。Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API 分析： 解决了JS到Native的翻译过程，自渲染。 调用原生功能需要封装插件，也比较麻烦 SwiftUI简介 声明式语法（SwiftUI），内部黑盒完成渲染 响应式编程，数据变化，监控、通知SwiftUI刷新数据 无缝调用原始功能 一个例子—体验SwiftUI现代编程语言的魅力代码 12345678910111213141516171819202122232425struct LandmarkList: View &#123; @EnvironmentObject var userData: UserData var body: some View &#123; NavigationView &#123; List &#123; Toggle(isOn: $userData.showFavoritesOnly) &#123; Text(\"Show Favorites Only\") &#125; ForEach(userData.landmarks) &#123; landmark in if !self.userData.showFavoritesOnly || landmark.isFavorite &#123; NavigationButton( destination: LandmarkDetail(landmark: landmark) .environmentObject(self.userData) ) &#123; LandmarkRow(landmark: landmark) &#125; &#125; &#125; &#125; .navigationBarTitle(Text(\"Landmarks\"), displayMode: .large) &#125; &#125;&#125; 12345678910111213141516171819202122struct LandmarkRow: View &#123; var landmark: Landmark var body: some View &#123; HStack &#123; landmark.image(forSize: 50) Text(verbatim: landmark.name) Spacer() if landmark.isFavorite &#123; VStack &#123; Image(systemName: \"star.fill\") .imageScale(.medium) .foregroundColor(.yellow) Text(\"sdfsdf\") &#125; &#125; &#125; &#125;&#125; SwiftUI原理浅析View的运作原理体会了SwiftUI的简洁用法，强大的功能后，分析下背后的原理： 定义了View的协议，所有的控件都准守View协议，View协议只定义了一个属性body，由于有了body属性，所以可以对body做对应的操作，这些操作封装在View的扩展中。这些扩展称为modifier。modifer作用于一个元素后，返回一个modified对象，这个对象也准守View协议，可以链式调用。 声明了控件的样式（内存看是链式结构）， 传入渲染引擎渲染。开发者只声明，不用管复杂的渲染机制，大大简化了开发难度 按需添加modifer，避免子类内存暴涨（性能） 基于协议式，底层可以任意修改，底层预留可非常大的扩展空间 HStack/ZStackHStack 和 ZStack 的非常类似安卓的 LinerLayout，算法也同 Flex 布局比较相似。 对于如下的布局, 苹果都会在控件之间添加上符合苹果人机交互指南的间距，保证 UI 的优雅和一致性。 对于如上的 Stack 是怎么计算的？设 Stack 主轴方向长度为 W1。 根据人机交互指南的预留出边距 S, 边距根据元素的排列可能有多个 得到剩余的主轴宽度 W2= W1 - N * S 平均分配一个预估宽度 计算一些具备明确宽高的元素 如 Image 设置了 Frame的元素的等。 沿主轴方向从前到后计算，，如果计算出来的宽度小于预估宽度则正常显示，不够则截断。 最后的元素为剩余宽度，如果不够显示则阶段 默认的交叉轴对齐方式为 Center，Stack 占据包括最大元素的边界。 默认的计算是顺序计算布局，如果某些元素比较重要，可以使用 LayoutPriority Modifier 提高布局优先级避免出现视图截断。 总结 基于声明式，底层做了大量工作，上层开发者开发更简单 响应式也简化了内部状态的维护 苹果生态系统的无缝衔接，无缝调用原生功能 内部人性化精细的设计，苹果的大力推广，不久的几年后，苹果开发的主要方式？ 参考 官方教程 SwiftUI 的一些初步探索 (一) 系列文章深度解读|SwiftUI 背后那些事儿","tags":[{"name":"SwiftUI","slug":"SwiftUI","permalink":"http://yoursite.com/tags/SwiftUI/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swiftUI","slug":"IOS/swiftUI","permalink":"http://yoursite.com/categories/IOS/swiftUI/"}]},{"title":"AFNetworking 源码浅析","date":"2019-06-05T10:07:12.000Z","path":"wiki/IOS/opensource/AFNetworking/AFNetworking/","text":"本文学习了AFNetworking，画了几个图，当做学习的成绩，留作以后复习使用。 发送请求 接收到响应 进度条模块 认证模块 参考 验证 HTTPS 请求的证书（五） 11.第三方源码-AFNetworking解析","tags":[{"name":"AFNetworking","slug":"AFNetworking","permalink":"http://yoursite.com/tags/AFNetworking/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"AFNetworking","slug":"IOS/opensource/AFNetworking","permalink":"http://yoursite.com/categories/IOS/opensource/AFNetworking/"}]},{"title":"iOS App 签名的原理([抄袭的，有问题请联系](http://wereadteam.github.io/2017/03/13/Signature/))","date":"2019-06-03T04:07:12.000Z","path":"wiki/IOS/暂无分类/ios_sign/","text":"iOS 签名机制挺复杂，各种证书，Provisioning Profile，entitlements，CertificateSigningRequest，p12，AppID，概念一堆，也很容易出错，本文尝试从原理出发，一步步推出为什么会有这么多概念，希望能有助于理解 iOS App 签名的原理和流程。 目的先来看看苹果的签名机制是为了做什么。在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。 非对称加密通常我们说的签名就是数字签名，它是基于非对称加密算法实现的。对称加密是通过同一份密钥加密和解密数据，而非对称加密则有两份密钥，分别是公钥和私钥，用公钥加密的数据，要用私钥才能解密，用私钥加密的数据，要用公钥才能解密。 简单说一下常用的非对称加密算法 RSA 的数学原理，理解简单的数学原理，就可以理解非对称加密是怎么做到的，为什么会是安全的： 选两个质数 p 和 q，相乘得出一个大整数n，例如 p=61，q=53，n=pq=3233 选 1-n 间的随便一个质数 e，例如 e = 17 经过一系列数学公式，算出一个数字 d，满足：a. 通过 n 和 e 这两个数据一组数据进行数学运算后，可以通过 n 和 d 去反解运算，反过来也可以。b. 如果只知道 n 和 e，要推导出 d，需要知道 p 和 q，也就是要需要把 n 因数分解。 上述的 (n,e) 这两个数据在一起就是公钥，(n,d) 这两个数据就是私钥，满足用公钥加密，私钥解密，或反过来公钥加密，私钥解密，也满足在只暴露公钥（只知道 n 和 e）的情况下，要推导出私钥 (n,d)，需要把大整数 n 因数分解。目前因数分解只能靠暴力穷举，而n数字越大，越难以用穷举计算出因数 p 和 q，也就越安全，当 n 大到二进制 1024 位或 2048 位时，以目前技术要破解几乎不可能，所以非常安全。 若对数字 d 是怎样计算出来的感兴趣，可以详读这两篇文章：RSA 算法原理（一）（二） 数字签名现在知道了有非对称加密这东西，那数字签名是怎么回事呢？ 数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。 有了上述非对称加密算法，就可以实现这个需求： 首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。 生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。 对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。 用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。 之所以要有第一步计算摘要，是因为非对称加密的原理限制可加密的内容不能太大（不能大于上述 n 的位数，也就是一般不能大于 1024 位/ 2048 位），于是若要对任意大的数据签名，就需要改成对它的特征值签名，效果是一样的。 好了，有了非对称加密的基础，知道了数字签名是什么，怎样可以保证一份数据是经过某个地方认证的，来看看怎样通过数字签名的机制保证每一个安装到 iOS 上的 APP 都是经过苹果认证允许的。 最简单的签名要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。 如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。 但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App： 开发 App 时可以直接把开发中的应用安装进手机进行调试。 In-House 企业内部分发，可以直接安装企业证书签名后的 APP。 AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。 苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。 新的需求我们先来看第一个，开发时安装APP，它有两个个需求： 安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。 苹果必须对这里的安装有控制权，包括 a.经过苹果允许才可以这样安装。 b.不能被滥用导致非开发app也能被安装。 为了实现这些需求，iOS 签名的复杂度也就开始增加了。 苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的： 在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple 把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。 在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。 在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。 验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。） 加点东西上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。 怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。 可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。 最终流程到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。 实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。 所以整个流程稍微变一下，就变成这样了： 因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程： 在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local 苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple 把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。 在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。 在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。 在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。 确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。 概念和操作上面的步骤对应到我们平常具体的操作和概念是这样的： 第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。 第 2 步苹果处理，不用管。 第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。 第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。 第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。 第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。 这里再总结一下这些概念： 证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。 Entitlements：包含了 App 权限开关列表。 CertificateSigningRequest：本地公钥。 p12：本地私钥，可以导入到其他电脑。 Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。 其他发布方式前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。 而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。 据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。 那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。 所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。 到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。 AppStore 加密另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。 本地私钥我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest 和 p12 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？ 能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。 mobileprovision 格式调研(这点是自己的)","tags":[{"name":"iOS App 签名的原理","slug":"iOS-App-签名的原理","permalink":"http://yoursite.com/tags/iOS-App-签名的原理/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"暂无分类","slug":"IOS/暂无分类","permalink":"http://yoursite.com/categories/IOS/暂无分类/"}]},{"title":"单词查找数","date":"2019-05-30T02:07:12.000Z","path":"wiki/数据结构与算法/算法4/第5章字符串/5_2_search/","text":"算法4 官网地址 单词查找树每个节点都有R条连接，其中R为字母表的大小 每个键所关联的值保存在该键的最后一个字母所对应的节点中。值为空的节点在符号表中没有对应的键，他们的存在是为了简化单词查找树中的查找操作。 查找以被查找的键中的字符为导向，单词查找树中的每个节点都包含了下一个可能出现的所有字符的链接。 查找结果： 尾字符对应的节点中的值非空，查找一次命中，键所对应的值就是尾字符所对应的节点中保存的值。 键的尾字符所对应的节点中值为空，未命中，符号表中不存在被查找的键 查找结束于一条空链接，这也是一次未命中的查找 查找过程就是在单词查找树中从根节点开始检查某条路径上所有节点。 插入 在到达键尾部前就遇到了一个空链接，需要为键中还未被检查的每个字符创建一个对应的节点，并将键对应的值保存在最后一个节点中。 在遇到空链接前就到达了健的尾部，将该节点中值设为键对应的值。 节点的表示每个节点都含有一个值和26个链接 在单词查找树中，键是由从根节点到含有非空值的节点的路径隐式表示的。数据节点并不会保存字符串或字符，它保存了链接数组和值。基于含有R个字符的字母表的单词查找数称为R向单词查找树。 大小size的延时实现： 12345678910111213141516private int size()&#123; return size(root);&#125;private int size(Node x)&#123; if(null == x) return 0; int cnt = 0; if(x.val) ++cnt; for(int i =0 ;i&lt;R, ++i) &#123; cnt += size(next[i]); &#125; return cnt;&#125; get1234567891011121314151617private Node get(Node x,String key, int d)&#123; if(x == null) return null; if(d== key.length()) return x; //开始递归 char c = key.charAt(d++); Node next = x.next[c]; return get(next, key,d)&#125;public Value get(String key)&#123; Node node = get(root,key,0); if(node == null) return null; return node.val;&#125; put1234567891011private Node put(Node x, String key, Value val, int d) &#123; if(x == null) x= new Node(); if(d == key.length()) &#123;x.val = val, return x;&#125; char c = key.charAt(d); x.next[c] = put(x.next[c],key,val,d+1); return x;&#125;public void put(String key, Value val) &#123; root = put(root,key,val,0);&#125; 查找所有键123456789101112private void collect(Node x, String pre, Queue&lt;String&gt;) &#123; if(x== null) return; if(x.val != null) q.enqueue(pre); for(char c=0; c&lt;R; c++) &#123; collect(x.next[c],pre+c,q); &#125;&#125;public Iterable&lt;String&gt; keysWithPrefix(String pre) &#123; Queue&lt;String&gt; q = new Queue&lt;Sting&gt;(); collect(get(root,pre,0),pre,q); return q;&#125; 通配符匹配","tags":[{"name":"单词查找数","slug":"单词查找数","permalink":"http://yoursite.com/tags/单词查找数/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第5章字符串","slug":"数据结构与算法/算法4/第5章字符串","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第5章字符串/"}]},{"title":"字符串排序","date":"2019-05-30T02:07:12.000Z","path":"wiki/数据结构与算法/算法4/第5章字符串/5_1_sort/","text":"算法4 官网地址 键索引排序说明： a[] 中存储待排序的数据，字符串名字，组号（我们作为键），组号在0~R-1，取出组号的方式：a[i].key() 计算各组的频率count[r+1]++; 频率转索引 count[r] = count[r-1] + count[r] 数据分类 回写 低位优先的字符串排序如果字符串的长度均为W，那就从右向左以每个字符作为键，用键索引计数法将字符串排序W遍。 理解的方法是向前看：如果有两个键，他们中还没有被检查过的字符都完全相同，不同之处取决于已经检查过的字符，因为两个键已经排序，有序。另外，如果还没有被检查过的部分不同，那么已经被检查过的字符对于两者的最终顺序没有意义。之后的某轮会保证有序。 高位优先的字符串排序首先用键索引计数法将所有字符串按照首字母排序，然后递归的再将每个首字母所对于的子数组排序。","tags":[{"name":"字符串排序","slug":"字符串排序","permalink":"http://yoursite.com/tags/字符串排序/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第5章字符串","slug":"数据结构与算法/算法4/第5章字符串","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第5章字符串/"}]},{"title":"子字符串查找","date":"2019-05-30T02:07:12.000Z","path":"wiki/数据结构与算法/算法4/第5章字符串/5_3_findSubString/","text":"算法4 官网地址 暴力子字符串查找算法12345678910111213141516public static int search(String pat,String txt)&#123; int M = pat.length(); int N = txt.length(); for(int i=0;i&lt;=N-M;j++) &#123; int j = 0; for(int j=0; j&lt; M ;j++) &#123; if(txt.charAt(i+j) != pat.charAt(j)) break; &#125; if(j==M) return i; &#125; return N;&#125; 在最坏情况下，暴力子字符串查找算法在长度为N的文本中查找长度为M的模式需要NM次比较。 KMP算法主要思想：提前判断如何重新开始查找。","tags":[{"name":"子字符串查找","slug":"子字符串查找","permalink":"http://yoursite.com/tags/子字符串查找/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"},{"name":"第5章字符串","slug":"数据结构与算法/算法4/第5章字符串","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/第5章字符串/"}]},{"title":"JLRoute学习","date":"2019-05-13T04:07:12.000Z","path":"wiki/IOS/opensource/JLRoute/JLRoute/","text":"注册流程 route流程","tags":[{"name":"JLRoute","slug":"JLRoute","permalink":"http://yoursite.com/tags/JLRoute/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"JLRoute","slug":"IOS/opensource/JLRoute","permalink":"http://yoursite.com/categories/IOS/opensource/JLRoute/"}]},{"title":"NSScanner","date":"2019-05-13T01:35:49.000Z","path":"wiki/IOS/foundation使用记录/NSScaner/","text":"A string parser that scans for substrings or characters in a character set, and for numeric values from decimal, hexadecimal, and floating-point representations. NSScanner是一个string的解析器。 An NSScanner object interprets and converts the characters of an NSString object into number and string values. NSScanner对象将 NSString对象的字符 解析转化为 数字或string。 NSScanner是个类族。 初始化方法： 1+ scannerWithString: 扫描字符或string 1- scanCharactersFromSet:intoString: 扫描一个数字 1- scanDecimal:","tags":[{"name":"NSScanner","slug":"NSScanner","permalink":"http://yoursite.com/tags/NSScanner/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"foundation使用记录","slug":"IOS/foundation使用记录","permalink":"http://yoursite.com/categories/IOS/foundation使用记录/"}]},{"title":"NSURL记录","date":"2019-05-10T07:35:49.000Z","path":"wiki/IOS/foundation使用记录/NSURL记录/","text":"url是什么？url是（ Uniform Resource Locator ）统一资源定位符的缩写。 完整格式&amp;语法1scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment] scheme: 传送协议。 层级URL标记符号(为[//],固定不变) user、password：访问资源需要的凭证信息（可省略） host：服务器。（通常为域名，有时为IP地址） port：端口号。（以数字方式表示，若为HTTP的默认值“:80”可省略） path：路径。（以“/”字符区别路径中的每一个目录名称） query：查询。（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突的问题） fragment：片段。以“#”字符为起点 NSURLComponents Accessing Components in Native Format 包括：fragment、host、path、query、queryItems、scheme等 Accessing Components in URL-Encoded Format 包括：percentEncodedFragment、percentEncodedHost等 Locating Components in the URL String Representation 包括：rangeOfFragment、rangeOfHost等","tags":[{"name":"NSURL","slug":"NSURL","permalink":"http://yoursite.com/tags/NSURL/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"foundation使用记录","slug":"IOS/foundation使用记录","permalink":"http://yoursite.com/categories/IOS/foundation使用记录/"}]},{"title":"appledoc生成文档实践","date":"2019-05-05T02:18:26.000Z","path":"wiki/工具/use_appledoc/","text":"安装第一步，下载appledoc，安装： 123git clone git://github.com/tomaz/appledoc.gitcd ./appledocsudo sh install-appledoc.sh 第二步，验证appledoc是否安装成功： 1appledoc --help 第三步， touch命令创建脚本，复制下面代码到脚本，然后添加执行权限，执行脚本： 1234567891011appledoc \\--output ./apiDoc \\-i *.m \\--project-name \"GSecretKey\" \\--project-company \"com.Gome\" \\--no-create-docset \\--keep-undocumented-objects \\--keep-undocumented-members \\--no-warn-undocumented-object \\--no-warn-undocumented-member \\./ 这样就可以将./目录下所有头文件中的注释自动生成出对应的文档到./apiDoc目录下。实际使用中，可以根据需要修改源文件路径、生成文件的路径、project-name、project-company。 上面的脚本是可以运行的，但是少了注释，难以理解。不添加注释的原因是：上面的命令太长，使用多行显示，使用 \\实现多行功能，如果在 \\ 后直接添加注释，脚本会运行报错，没有地方添加注释。所以，可执行的脚本没有注释，下面将有注释的脚本单独列出来，方便理解: 12345678910111213141516171819202122#!/bin/bashappledoc \\#文档输出目录--output ./apiDoc \\ #忽略.m文件，因.m中均为私有api和属性，开源的接口文档中理应忽略掉-i *.m \\ #工程的名字--project-name \"GSecretKey\" \\#公司的名字--project-company \"com.Gome\" \\#不生成docset，直接输出html--no-create-docset \\#没有注释的文件也输出html --&gt;目的是看到所有的文件--keep-undocumented-objects \\#没有注释的属性和方法也输出到html --&gt;目的是看到所有的属性和方法--keep-undocumented-members \\#没有注释的文件不提示警告--no-warn-undocumented-object \\#没有注释的属性和方法不提示警告--no-warn-undocumented-member \\#需要输出的文件路径 --&gt;这里推荐最好直接为当前工程路径平级输出，便于维护和使用./ 问题 实际使用上问题挺多，尤其Xcode9之后，普遍的方法会出现此错误：ERROR | !&gt; xcrun: error: unable to find utility “docsetutil”, not a developer tool or in PATH 解决办法：终端-&gt;编写脚本-&gt;运行脚本-&gt;更新脚本从而规避docsetutil找不到等错误，经过验证，将命令放在脚本中，确实解决了这个问题。 参考 iOS 开发_编写接口文档（appledoc实用篇）","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"ABTest IOS SDK设计","date":"2019-03-22T06:18:26.000Z","path":"wiki/IOS/ABTest/ABTest/ABTest/","text":"阅读目录： ABTest使用场景分析 SDK设计图 附录：XX App AB效果 ABTest使用场景分析下图说明ABTest使用场景的分析。 依据上图的分析，设计出下面的SDK流程。 SDK设计图下图说明SDK的设计图。 附录：XX App AB效果经过反编译XX APP，分析XX客户端的AB实现原理，然后修改XX的代码，对比底部Bar的AB效果。","tags":[{"name":"ABTest","slug":"ABTest","permalink":"http://yoursite.com/tags/ABTest/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"ABTest","slug":"IOS/ABTest","permalink":"http://yoursite.com/categories/IOS/ABTest/"},{"name":"ABTest","slug":"IOS/ABTest/ABTest","permalink":"http://yoursite.com/categories/IOS/ABTest/ABTest/"}]},{"title":"24. 自动引用计数器","date":"2019-01-30T03:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/24__自动引用计数器/","text":"官方目录： How ARC Works ARC in Action Strong Reference Cycles Between Class Instances Resolving Strong Reference Cycles Between Class Instances Strong Reference Cycles for Closures Resolving Strong Reference Cycles for Closures 引用计数只适用于实例对象。结构体和枚举是值类型，不是引用类型，并且不通过引用存储和传递的。 ARC ⼯作机制解决实例之间的强引用循环Swift 提供了两种方法解决你在使用类的属性而产生的强引用循环:弱引用( weak )和 无主引用( unowned )。 当一个实例的生命周期比较引用它的实例短，也就是这个实例可能会先于引用它的实例释放的时候，需要使用弱引用( weak )。对与一栋公寓来说在它的生命周期中是完全可以没有住户的，所以在这种情况下，上例中 Apartment 类使用弱引用来打断强引用循环是合 适的。相反，当一个实例拥有和引用它的实例相同的生命周期或是比引用它的实例更长的生命周期的时候，需要使用无主引用(unowned)。 由于弱引用需要能在运行过程中设置为 nil ,所以必需要声明为可选类型的变量而不是常量。 注意当 ARC 设置弱引用为 nil 的时候，属性观察不会被调用。 无主引用总是有值的。因而，ARC也不会将无主引用的值设置为 nil ，这也意味着无主引用要被定义为非可选类型。 总结来说：三种情况， 都可以为nil，weak 一个可为nil，unowned 都不能为nil, unowned和隐式解包可选值 其中第三种比较经典，下面列出代码： 1234567891011121314151617class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125;&#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125;&#125; 解决闭包引起的强引⽤循环捕获列表：在闭包内部捕获一个或多个引用类型的规则 捕获列表中的每一项都是由 weak 或 unowned 关键字和实例的引用(如 self ) 或是由其他值初始化的变量(如 delegate = self.delegate! )成组构成的。它们每 一组都写在方括号中，组之间用逗号隔开。 捕获列表放在闭包的参数和返回值(如果有返回值的话)前面: 1234lazy var someClosure: (Int, String) -&gt; String = &#123; [unowned self, weak delegate = self.delegate!] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125;","tags":[{"name":"自动引用计数器","slug":"自动引用计数器","permalink":"http://yoursite.com/tags/自动引用计数器/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"23. 泛型","date":"2019-01-29T03:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/23__泛型/","text":"官方目录： The Problem That Generics Solve Generic Functions Type Parameters Naming Type Parameters Generic Types Extending a Generic Type Type Constraints Associated Types Generic Where Clauses Extensions with a Generic Where Clause Associated Types with a Generic Where Clause Generic Subscripts 泛型解决的问题泛型解决某些功能，例如交换两个数，由于参数类型不同，需要重复编写代码的问题。 泛型函数12345func swapTwoValues&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let temporaryA = a a=b b = temporaryA&#125; 泛型版本的函数使用占位符类型名，而不是一个真正的类型名称。调用泛型函数的时候，从实参中推断类型T。 类型参数类型参数指定并命名一个占位类型，并紧挨着函数名称后面，使用一对尖括号括起来(例如 )。类型参数在调用时被一个真实的类型所替换。你可以通过在尖括号内写多个类型参数名来提供多个类型参数，用逗号隔开。 类型参数：将类型作为参数 泛型类型除了泛型函数外，Swift可以定义你自己的泛型类型 。这些自定义的类、结构体、枚举可以和任何类型一起使用，方式类似于数组、字典 。 123456789struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(_ item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; &#125; 扩展泛型类型扩展泛型类型时，你不需要提供类型参数列表作为扩展定义的一部分。 相反，原始类型定义中的类型参数列表在扩展的主体内依旧可用，并且原始类型参数名称会被用于引用原始定义中的类型参数。 类型约束有时候，对泛型函数和泛型类型进行类型约束是很有用的。类型约束指定参数类型必须继承自特定的类、遵循特定的协议、特定的协议组。 ###类型约束语法 类型约束的写法:在类型参数名后跟上一个类或协议来进行约束，使用冒号进行分割，作为类型参数列表的一部分。泛型函数的类型约束语法如下(泛型类型的语法与此相同) 123func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这⾥里里写函数体的内容&#125; 第一个类型参数T，类型约束要求T的类型必须是SomeClass的子类。第二个类型参数U，类型约束要求U必须遵循SomeProtocol协议 为啥需要类型约束？想想字典的key，必须可哈希，不是所有的类型都能作为字典的key，所以需要约束。 关联类型当定义一个协议时，有时候定义一个或多个关联类型作为协议的一部分是很有用的。关联类型作为协议的一部分，并为一种类型提供占位符名称。在实现该协议之前不会指定关联类型的实际类型。关联类型使用 associatedtype 关键字来指定。 123456protocol Container &#123; associatedtype Item mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125; item 可以通过类型推断得到。或者显式的指定： 1typealias Item = Int 将约束添加到关联类型123456protocol Container &#123; associatedtype Item: Equatable mutating func append(_ item: Item) var count: Int &#123; get &#125; subscript(i: Int) -&gt; Item &#123; get &#125;&#125; 为了遵循这个版本的 Container ，容器的 Item 类型必须符合 Equatable 协议。 泛型 Where ⼦句对关联类型定义一些规定通常也很有用。你可以通过定义泛型where子句 来完成此操作。泛型 where 子句使你能够要求关联类型必须符合某个协议，或者某些类型参数和相关类型必须相同。泛型 where子句以where 关键字开头，后跟关联类型的约束条件或类型和关联类型之间的相等关系。 where的位置：你需要在一个类型或函数体的起始大括号之前写一个泛型where子句。 在扩展中使⽤泛型Where⼦句1associatedtype Iterator: IteratorProtocol where Iterator.Element == Item 泛型下标标也可以用泛型表示，同时也可以包含泛型 where 子句。 可以在下标括号之后的尖括号内写一个类型占位符，在下标主体的起始大括号之前写一个泛型 where子句。","tags":[{"name":"泛型","slug":"泛型","permalink":"http://yoursite.com/tags/泛型/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"22. 协议","date":"2019-01-29T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/22__协议/","text":"Protocol Syntax Property Requirements Method Requirements Mutating Method Requirements Initializer Requirements Protocols as Types Delegation Adding Protocol Conformance with an Extension Collections of Protocol Types Protocol Inheritance Class-Only Protocols Protocol Composition Checking for Protocol Conformance Optional Protocol Requirements Protocol Extensions 协议可以作为方法、属性或者其他的一些特定的任务和功能块的设计蓝图。协议可以适用于类、结构体、枚举,并为它们提供具体的实现或满足特定的需求。任意类型只要满足一个协议的要求，那么我们便称这个类型遵循这个协议。 除了要求遵循协议的类型必须提供对应的实现以外，还可以通过协议扩展来为协议的遵循者提供默认的或者对其有利的实现。 协议语法123protocol SomeProtocol &#123; // 协议的定义写在这⾥&#125; 123struct SomeStructure: FirstProtocol, AnotherProtocol &#123; // 结构体的定义写在这⾥&#125; 需要注意的是，在为子类适配协议时，父类的名称需要写在协议名之前，分隔符不变。 属性要求协议可以要求遵循者提供特定名称的实例属性、类型属性。协议只指定属性的名称和类型，而不指定属性是储存属性还是计算属性。此外，协议中也可以指定属性是可读的还是可读可写的。 协议可以指定属性的名称、类型、读写性 协议属性通常会以var关键字来声明变量属性。在类型声明后加上{ get set }来表示属性是可读可写的，用{ get }来表示可读属性。 在协议中定义类型属性时，始终使用static关键字作为前缀。即使该类型属性在类实现时以以 class 或 static 关键字作为前缀，这个规则也适用。 方法要求我们无法为协议中定义的方法的参数指定默认值。 与类型属性一样，当在协议中定义类型方法时，始终使用static 关键字作为前缀。即使该类型方法要求在由类实现时以 class 或 static 关键字为前缀，也是如此。 异变方法要求 注意：如果将协议实例方法要求标记为mutating，则在为类编写该方法的实现时，不需要写mutating关键字。 mutating关键字仅由结构体和枚举使用。 构造器要求协议可能要求通过遵循类型来实现指定构造器。和普通构造器写法一样，你可以将构造器定义写在协议中，只是不用写大括号和构造器实现。 类实现协议构造器的要求你可以通过实现指定构造器、便利构造器来使遵循协议的类满足协议的构造器要求。在这两种情况下，你必须使用 required 修饰符标记构造器实现。 可失败的构造器的要求遵循类型可以用可失败或非可失败的构造器来满足可失败的构造器要求。非可失败的构造器要求必须用非可失败的构造器或隐式展开的可失败的构造器来满足。 将协议作为类型协议本身并不实现任何功能。不过，你创建的任何协议都可以变为一个功能完备的类型在代码中使用。因为它是一种类型，所以你可以在允许其他类型的许多地方使用协议，包括: 作为函数、方法或构造器的参数类型或返回类型 作为常量、变量或属性的类型 作为数组、字典或其他容器的元素类型 委托委托是一种设计模式，它使类或结构体能够将其某些职责交给(或委托)到另一种类型的实例。通过定义封装委托职责的协议来实现此设计模式，从而保证遵循协议的类型(称为委托)提供被委托的功能。 扩展添加遵循某协议extension Dice: TextRepresentable { var textualDescription: String { return &quot;A \\(sides)-sided dice&quot; } } 有条件地遵循协议泛型类型可能只能在特定条件下满足协议的要求，例如类的泛型参数遵循一个协议。你可以通过在扩展类型时列出条件约束，让泛型类型有条件的遵循一个协议。通过编写一个泛型where分句，在遵循的协议名称后面写上约束条件。 通过扩展申明类采纳了协议如果一个类型已经满足遵循一个协议的所有要求，但它没有申明遵循了这个协议，你可以通过一个空的扩展遵循该协议。 注意：类型不会自动遵循一个协议，即便已经满足这个协议的要求。它们必须显示的申明它们遵循了这个协议。 协议类型的集合协议可以用作诸如数组或字典之类的集合类型的元素类型。 协议继承协议可以继承一个或多个协议，并且可以在其继承的协议的基础上添加更多的要求。协议继承的语法类似于类继承的语法，但是协议继承支持同时继承多个协议，并用逗号隔开。 类的专属协议你可以通过将AnyObject协议添加到协议的继承列表中，来将协议限定为仅类类型(而不是结构体或枚举)可用。 注意： 当协议的要求遵循者必须符合引用语义而不是值语义时，请使用类专属协议。 协议组合某些场合下，要求类型可以同时遵循多个协议是很有用的。您可以使用协议组合将多个协议组合到单个需求中。协议组合的行为就像你定义了一个临时本地协议，该协议具有组合中所有协议的要求。协议组合不定义任何新的协议类型。 协议组合使用SomeProtocol &amp; AnotherProtocol的形式。你可以根据需要，列出尽可能多的协议，用&amp;符号分隔它们。除了协议列表之外，协议组合还可以包含一个类类型，你可以使用它来指定继承的父类。 检查协议的遵循情况你可以使用类型转换中描述的 is 和 as 运算符来检查协议遵循、转换成特定协议。检查和转换协议与检查和转换类型的语法相同: 如果实例遵循协议，则is运算符返回true ，如果不遵循则返回false 。 向下转换运算符as?返回协议类型的可选值，如果实例不遵循该协议，则该值为nil 。 向下转换运算符的as!强制向下转换为协议类型，如果向下转换不成功则触发运行时错误。 可选协议要求你可以为协议定义可选要求，这些要求不强制遵循者必须实现。可选要求以 optional修饰符为前缀，作为协议定义的一部分。 可选要求允许你的代码与Objective-C交互。协议和可选要求都必须用@objc 属性标记。请注意：@objc协议只能由继承自Objective-C类或其他@objc类的类遵循。结构体或枚举不能遵循它们。 在可选要求中使用方法或属性时，其类型将自动变为可选。例如，类型 (Int) -&gt;String 的方法变为 ((Int) -&gt; String)? 。请注意：整个函数类型变成了可选项， 而不是方法的返回值。 考虑到遵循协议的类型可能未实现要求，你应该使用可选链来调用可选协议。你通过在调用方法名称后面写一个问号来检查可选方法是否实现，例如 someOptionalMethod? (someArgument) 。 协议扩展–协议上创建扩展通过在协议上创建扩展，所有遵循者都将自动获得此方法的实现，而无需任何其他修改。 协议扩展可以为符合协议的类型添加实现，但无法扩展协议本身或是继承其他协议。 协议继承始终在协议自身的声明中指定。 提供默认实现你可以使用协议扩展来为任何方法或计算属性提供默认实现。如果一个遵循者本身就实现了协议中要求的方法或属性，那么这个实现会代替协议扩展中的默认实现。 注意：由协议扩展提供默认实现和可选协议不同。尽管符合的类型不需要提供任何一种协议的实现，但默认的实现在被调用时不需要可选链。 为协议扩展添加条件约束当我们定义一个协议扩展时，我们可以通过where关键字在被扩展的协议名称后指定一个约束条件。 注意：如果一个类型遵循了多个具有同名方法或属性的扩展协议，那么 Swift会优先调用约束条件较多一方的属性或方法。","tags":[{"name":"协议","slug":"协议","permalink":"http://yoursite.com/tags/协议/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"21. 扩展","date":"2019-01-29T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/21__扩展/","text":"Extension Syntax Computed Properties Initializers Methods Subscripts Nested Types Extensions :为已存在的类、结构体、枚举或者协议类型增添了一个新的功能。这项功 能包括在对你无法访问源码的情况下进行类的扩展的能力(例如“追溯模型”)。Swift 中的Extensions 与 Objective-C 中的 Categories 类似。(但与 Objective-C 中 Categories 有所不同的是，Swift 中的 Extensions 并没有一个具体的命名)在 Swift 中 Extensions 可以做到: 添加计算实例属性和计算类型属性 定义实例方法和类方法 提供新的初始化方法 定义下标脚本 定义和使用新的嵌套类型 使现有类型符合协议 注意: Extensions 可以为类增添一个新的功能，但却不能重写之前已经存在的功能。 Extension 语法使用关键字 Extension 来声明一个扩展: 123extension SomeType &#123;//编写 SomeType 的新功能&#125; 注意：如果你想为一个已经存在的类型的进行扩展并添加一个新的功能，那么这个功能将会被 该类所有的实例使用，即使在这个 Extension 被定义之前。 计算属性Extensions 可以将计算实例属性与计算类型属性添加到现有类中去。 注意：Extensions 可以添加一个新的属性，但是他们不能存储这些属性，也不能为现有类 型添加属性观察者。 初始化器Extensions 可以给类添加一个便利初始化器，但它们不能够提供指定初始化器、反初始化器。指定初始化器和反初始化器都必须由原始类去提供。 注意： 如果你声明了一个带有扩展的新的初始化器，那么你仍然有责任去确认在这个初始化器完成之后，每一个实例都已经被初始化完成。 方法扩展可以向已经存在的类型添加实例方法或类方法。 可变实例方法 我们可以通过在扩展中添加实例方法来实现修改变量。 下标 Extensions 能够对已经存在的类型添加下标。 嵌套类型我们可以通过扩展 Extensions 来向任何已经存在的类、结构体或枚举添加新的嵌套类 型。","tags":[{"name":"扩展","slug":"扩展","permalink":"http://yoursite.com/tags/扩展/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"19. 类型转换","date":"2019-01-29T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/19__类型转换/","text":"Defining a Class Hierarchy for Type Casting Checking Type Downcasting Type Casting for Any and AnyObject Swift 中的类型转换是通过 is 和 as 运算符实现的。 这两个运算符提供了一种简单 而直观的方法来检查值的类型，或将值转换为其他类型。 定义一个类结构作为类型转换示例你可以使用类型转换连同类和子类的层次结构来检查特定类的实例类型，并将该实例强制转 换为同一层次结构中的另一个类。 类型检查使用 类型检查运算符( is )来检查实例是否属于某个特定子类型。 如果实例属于该子类型，则类型检查运算符将返回 true ，否则，将返回 false 。 强制转型实际上某个类型的常量或变量可能本来就是某个子类的实例。当确认是这种情况情况时，你 可以尝试使用 类型强制转换运算符 ( as? 或 as! )将该常量或变量 强制转换 成子 类型。 由于强制转换可能会失败，因该类型转换运算符有两种不同的形式。条件形式 as? 会返 回你尝试强制转换的类型的可选值。强制形式 as! 则会尝试强制转换，并同时将结果强 制解包。 当你不确定强制转换是否成功时，请使用类型转换运算符的条件形式( as? )。这种形 式的运算符将始终返回一个可选值，如果无法进行强制转换，该值将为 nil 。这使得你 可以检查强制转换是否成功。仅当你确定强制转换会始终成功时，才使用类型转换运算符的强制形式( as! )。如果 你尝试强制转换为不正确的类型，此形式的运算符将触发运行时错误。 转换实际上不会变更实例或修改其值。原本的实例保持不变;我们仅仅把它看作是它类型的实例，对其进行简单地处理和访问。 对Any和AnyObject做类型转换Swift 提供了两种特殊的类型来处理非特定类型: Any 可以表示任何类型的实例，包括函数类型。 AnyObject 可以表示任何类类型的实例。 只有在明确需要 Any 或 AnyObject 所提供的行为和功能时才使用他们。 最好在你 的代码中明确需要使用的类型。 注意Any 类型表示任何类型的值，包括可选类型。 如果程序需要一个类型为 Any 的 值，而你却使用了可选类型，Swift 会向你发出警告。 如果你确实需要将可选值作为Any 使用，可以使用 as 操作符将可选类型显式地转换为 Any 类型，如下所 示。 12let optionalNumber: Int? = 3 things.append(optionalNumber) // 警告 things.append(optionalNumber as Any) // 没有警告","tags":[{"name":"类型转换","slug":"类型转换","permalink":"http://yoursite.com/tags/类型转换/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"20. 嵌套类型","date":"2019-01-29T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/20__嵌套类型/","text":"Nested Types in Action Referring to Nested Types 通常我们会创建枚举来支持特定的类或结构体的功能。类似地，为了可以方便地定义在更复杂类型上下文中使用的实用 工具类和结构，Swift 允许你定义 嵌套类型 ，从而实现在枚举、类和结构体中的定义嵌套类型。 如果要将一个类型嵌套在另一个类型中，只需在支持类型的大括号内定义嵌套类型即可。类型支持多层嵌套。 嵌套类型的使用引⽤嵌套类型要在其定义上下文之外使用嵌套类型，需要在其名称前面加上嵌套在其中的类型的名称。","tags":[{"name":"嵌套类型","slug":"嵌套类型","permalink":"http://yoursite.com/tags/嵌套类型/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"17. 可选链","date":"2019-01-28T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/17__可选链/","text":"Optional Chaining as an Alternative to Forced Unwrapping Defining Model Classes for Optional Chaining Accessing Properties Through Optional Chaining Calling Methods Through Optional Chaining Accessing Subscripts Through Optional Chaining Linking Multiple Levels of Chaining Chaining on Methods with Optional Return Values 可选链 是在当前可能为 nil的可选值上查询和调用属性、方法、下标的过程。如果可选值有值，则属性、方法或下标调用成功;如果可选值为 nil ，则属性、方法或下标调用 返回 nil 。多个查询可以链接在一起，如果链中的任何一个节点为 nil ，整个链会 返回失败。 可选链作为强制展开的代替品为了反映可选链可以对 nil 值进行调用这一事实，可选链调用的结果总是一个可选值， 即使正在查询的属性、方法或下标返回一个不可选值。 为可选链定义模型类你可以使用可选链来调用超过一级深度的属性、方法和下标。 这使你可以深入查看相互关联 类型的复杂模型中的子属性，并检查是否可以访问这些子属性上的属性、方法和下标。 通过可选链访问属性赋值是可选链的一部分，也就意味着 = 操作符的右操作数不会被计算。 任何通过可选链给属性赋值的尝试都会返回一个 Void? 类型的值。这样你可以和 nil 比较来检查赋值是否成功: 通过可选链调⽤方法你可以使用可选链来调用一个可选值的方法，以及检查调用是否成功。即使那个方法没有返回值你依然可以这样做。 通过可选链访问下标访问可选类型的下标如果下标返回一个可选类型的值，例如 Swift 中 Dictionary 的键下标，在下标的右括 号 后面 放置一个问号来链接其可选的返回值 多级链表关联 如果要检索的类型不是可选的，通过可选链，它将成为可选的。 如果您要检索的类型已经是可选的，那么它将保持原状。 在方法的可选返回值上进行可选链式调用如果要在该方法的返回值上进行可选链式调用，在方法的圆括号后面加上问号即可。","tags":[{"name":"可选链","slug":"可选链","permalink":"http://yoursite.com/tags/可选链/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"18. 错误处理","date":"2019-01-28T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/18__错误处理/","text":"Representing and Throwing Errors Handling Errors Specifying Cleanup Actions 表示和抛出错误在 Swift 中，错误是遵循 Error 协议的值。Error 是一个空协议，表明遵循该协议的类型 可以用于错误处理。 处理错误在 Swift 中有四种处理错误的方式： 您可以将错误从函数传递给调用该函数的代码 可以使 用 do - catch 语句处理错误， 可以通过可选值处理错误 通过断言保证错误不会 发生 使⽤抛出函数传递错误为了让函数、方法或者初始化程序可以抛出错误，您需要在函数声明的参数后面添写 throws 关键字。标有 throws 的函数称为抛出函数。如果函数指定了返回类型，则在返回箭头 ( -&gt; ) 之前添写 throws 关键字。 1func canThrowErrors() throws -&gt; String 注意:只有抛出函数才能传递错误。任何在非抛出函数中抛出错误都必须在函数内部进行处理。 使⽤ Do-Catch 处理错误在可抛出函数中，封闭的do - catch 子句或调用者必须处理错误。 如果错误传播到顶级作用域而未被处理， 则会出现运行时错误。 将错误转换为可选值你可以使用 try? 将错误转换为可选值来处理错误。 如果在执行 try? 表达式时抛出 错误，表达式的值将为 nil 。 禁⽤错误传播有时你知道可抛出函数或方法实际上不会在运行时抛出错误。 在这种情况下，你可以在表达 式之前添加 try! 来禁用错误传播，并把调用过程包装在运行时断言中，从而禁止其抛出 错误。 而如果实际运行时抛出了错误，你将收到运行时错误。 指定清理操作当代码执行到即将离开当前代码块之前，可以使用 defer 语句来执行一组语句。无论是 因为错误而离开 — 抑或是因为诸如 return 或 break 等语句而离开， defer 语句都可以让你执行一些必要的清理。例如，你可以使用 defer 语句来关闭文件描述符 或释放手动分配的内存。 defer 语句会推迟执行，直到退出当前作用域。该语句由 defer 关键字和稍后要执 行的语句组成。延迟语句可能不包含任何将控制转移出语句的代码，例如 break 或 return 语句，或抛出错误。延迟操作的执行顺序与它们在源代码中编写的顺序相反。也 就是说，第一个 defer 语句中的代码最后一个执行，第二个 defer 语句中的代码倒 数第二个执行，依此类推。源代码中的最后一个 defer 语句最先执行。 注意： 即使没有涉及错误处理代码，也可以使用 defer 语句。","tags":[{"name":"错误处理","slug":"错误处理","permalink":"http://yoursite.com/tags/错误处理/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"16. 析构过程","date":"2019-01-28T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/16__析构过程/","text":"ow Deinitialization Works Deinitializers in Action 析构器 会在类的实例销毁之前被立即调用。使用deinit关键字来表示析构器，类似于使用init关键字标示构造器，析构器仅适用于class类型。 析构器是如何运作的在类的定义中, 类最多只能有一个析构器。 析构器不接受任何参数，并且没有括号。 在实例销毁之前，会自动调用析构器。你不能自己调用析构器。父类的析构器由其子类继承，父类析构器会在子类析构器实现的末尾自动调用。即使子类不提供自己的析构器，父类析构器也会被调用。","tags":[{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"15. 构造过程","date":"2019-01-28T02:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/15__构造过程/","text":"Setting Initial Values for Stored Properties（设置存储属性的初始值） Customizing Initialization Default Initializers Initializer Delegation for Value Types Class Inheritance and Initialization Failable Initializers Required Initializers Setting a Default Property Value with a Closure or Function Swift 的构造器不用返回值。它们主要的作用就是确保在第一次使用前某类型 的实例都能正确的初始化。 设置存储属性的初始值类和结构体在其创建实例时必须为它们所有的存储属性设置适当的初始值。存储属性不能处于未知状态。你可以在构造器中为存储属性设置初始值，或是作为定义属性时的一部分设置其默认值。 注意：当你为存储属性设置默认值时，或是在构造器中设置其初始值，属性值是直接设置的，并不会调用任何属性观察器。 构造函数中改变计算属性，setter会调用， 存储属性的didset 不会调用. 亲自测试 。原因分析：个人感觉观察器作用是观察变化，构造器设置是初始化操作，不是赋值操作，不算变化 构造器构造器在创建某类实例时调用。其最简单的形式用 init 数的实例方法 默认属性值你可以在构造器中设置一个存储属性的初始值。或指定一个 默认属性值 作为声明 属性的一部分。指定默认属性值你可以通过在属性定义时为其赋一个初始值。 注意：如果一个属性总是相同的初始值，与其在构造器中设置一个值不如提供一个默认值。其效果是相同的，但是默认值与属性构造器的联系更紧密一些。它使构造器更简短，更清晰，并且可以通过默认值推断属性类型。默认值也使你更易使用默认构造器和构造器继承， 如果属性的初始值总是相同，推荐使用默认值， 这样跟简洁，合理使用类型推断。 自定义构造过程参数名：如果你在构造器中没有为每一个参数提供外部参数名，Swift 就会自动为其提供外部参数名。 注意如果不使用外部参数名是无法调用这些构造器的。如果在构造器中定义了外部参数名就必须使用，忽略它将会触发编译错误。 可选属性类型可选类型的属性会自动被初始化为nil ，表示属性在构造过程期间故意设置为『没有 值』。 在构造过程期间给常量赋值构造过程期间你可以在任何时间点给常量属性赋值，只要构造完成时设置了确定值即可。一旦常量属性被赋值，就不能再次修改。 注意：对于类的实例来说，常量属性只能在定义常量属性类的构造器中修改。不能在派生类中修改。 默认构造器Swift 为属性均有默认值和没有构造器的结构体或类提供了一个默认构造器 。默认构造器创 建了一个所有属性都有默认值的新实例。 默认构造器的条件：所有存储属性都有默认值，且没有定义构造函数。 结构体类型的成员构造器如果结构体没有任何自定义构造器，那么结构体类型会自动接收一个成员构造器。不同于默认构造器，即使结构体的存储属性没有默认值，它也会接收成员构造器。 逐一成员构造器的条件：没有定义构造函数。 比默认构造器少了一个默认值的条件 值类型的构造器代理构造器可以调用其他构造器来执行实例的部分构造过程。这个过程称之为 构造器代理 ，以避免多个构造器之间的重复代码。 对于值类型，在自定义构造器中使用 self.init 来引用同一类型中的其他构造器。你只能在构造器中调用 self.init 。 如果你为值类型定义了一个自定义构造器，你将无法再访问该类型的默认构造器( 如果是结构体就是成员构造器 ) &gt; 注意：如果你想让你的自定义类型可以使用默认构造器，成员构造器，自定义构造器来进行初始化，就把自定义构造器写在扩展中，而不是作为值类型原始实现的一部分。 类的继承和构造过程类的所有存储属性 — 包括任何从父类继承而来的属性 — 必须在构造过程期间赋值。Swift 给类类型定义了两种构造器以确保所有存储属性都能接收到初始值。它们分别是指定构造器和便利构造器。 指定构造器和便利构造器指定构造器是类的主要构造器。一个指定构造器初始化该类引入的所有属性，并调用合适的父类构造器以继续父类链上的构造过程。 便利构造器有着相同风格的写法，但是在 init 关键字之前需要放置 convenience 修饰符，并使用空格来分隔。 类的构造代理为了简化指定构造器和便利构造器之间的关系。Swift 对构造器之间的代理采用了如下三条规则： 指定构造器必须调用其直系父类的指定构造器。 便利构造器必须调用同一类中的其他构造器。 便利构造器最后必须调用指定构造器。 简单的记忆方法: 1. 指定构造器必须 向上 代理。2. 便利构造器必须 横向 代理。 两段式构造器过程Swift 中类的构造过程是两段式处理。第一阶段，为类引入的每个存储属性赋一个初始值。一旦确定了所有存储属性的初始状态，第二阶段开始，在新的实例被认为可以使用前，每个类都有机会进一步定制其存储属性。 Swift 的编译器执行了四个有帮助的安全检查以确保两段式构造过程无误完成:1. 安全检查 1：指定构造器必须确保其类引入的所有属性在向上代理父类构造器之前完成初始化。如上所述，一个对象的内存只在其所有存储属性初始状态已知时才被认为完全初始化。为了符合此规则，指定构造器必须确保其所属类拥有的属性在向上代理前完成初始化。2. 安全检查 2：指定构造器必须在继承属性赋值前向上代理父类构造器，否则，便利构造器赋予的新值将被父类构造过程的一部分重写。3. 安全检查 3：便利构造器必须在任何属性(包括同一类中定义的属性)赋值前代理另一个构造器。否则便利构造器赋予的新值将被其所属类的指定构造器重写。4. 安全检查 4：构造器在第一阶段构造过程完成前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用 self 作为一个值。以下是基于以上四个安全检查的两段式构造过程的流程:阶段 1：1. 在类中调用指定或便利构造器。2. 对一个新实例分配内存，但内存没还没有初始化。 指定构造器确认其所属类的所有存储属性都有值。现在那些存储属性的内存初始化完成。3. 指定构造器移交给父类构造器以为其存储属性执行相同的任务。4. 这个过程沿着类的继承链持续向上，直到到达继承链的顶端。5. 一旦到达链的顶端，并且链中最后的类确保其所有存储属性都有值，则认为实例的内 存已经完全初始化，至此阶段 1 完成。阶段 2：1. 从链顶端往下，链中每个指定构造器都可以选择进一步定制实例，构造器现在可以访问 self 并修改它的属性，调用实例方法，等等。2. 最终，在链中的任何便利构造器也都可以选择定制实例以及使用 self 。### 构造器的继承和重写与 Objective-C 的派生类不同，Swift 的派生类默认不继承其父类构造器。Swift 这种机制防止了更定制化的派生类继承父类的简单构造器，也防止将简单构造器用于创建不完全初始化或是错误初始化的派生类实例。当你在写一个与父类 指定构造器相匹配的派生类构造器时，你是在有效的重写指定构造器。 因此，你必须在派生类构造器的定义前写上修饰符 override 。即使你重写的是一个自动提供的默认构造器，也要写上 override 。相反的，如果你写一个与父类便利构造器相匹配的派生类构造器，根据类的构造器代理规则，派生类是不能直接调用父类便利构造器的。因此，你的派生类(严格来说)没有重写父类构造器。所以，在提供与父类便利构造器相匹配的实现时，无需编写修饰符 override 默认构造器(在可用时)总是类中的指定构造器。派生类可在构造过程期间可修改变量继承属性，但不能修改常量继承属性。### 自动构造器的继承如上所述，派生类默认不继承其父类构造器。然而，如果满足某些特定条件，父类构造器是可以被自动继承的。实际上，这意味着很多常见场景中你不需要重写构造器，并且可以安全的以最小代价继承父类构造器。假设你为派生类引入的所有属性提供了默认值，请应用以下两条规则以达到自动继承的目的:1. 规则 1:如果你的派生类没有定义任何指定构造器，它会自动继承其父类的所有指定构造器。2. 规则 2:如果你的派生类为其父类的所有指定构造器都提供了实现 — 无论是按照规则 1 继承而来， 或是定义时提供了自定义实现 — 它都会自动继承父类的所有便利构造器。甚至在派生类进一步添加便利构造器时，这些规则仍然适用。 自动继承的条件和默认构造器的条件是多么的相似，有默认值，没有定义指定构造函数 。 可失败构造器为了应对可能失败的构造过程，你可以为类、结构体，或是枚举定义一个或是多个可失败构造器。编写可失败构造器的语法就是在 init 关键字后面添加问号( init? )。 注意:你不能使用相同的参数类型或参数名定义一个可失败构造器后又定义一个非失败构造器。 可失败构造器会创建一个关联值类型是自身构造类型的可选类型。在可失败构造器中编写 return nil 以表示可以在任何情况下触发失败。 注意:严格来说，构造器没有返回值。它们的作用是确保构造过程结束时 self 可以完全并正确的初始化。虽然你写 return nil 是用于触发构造器失败，但表示构造成功是不会使用 return 关键字的。 枚举的可失败构造器带有原始值枚举的可失败构造器构造失败的传递类、结构体或枚举的可失败构造器可以横向代理同一类型中的其他可失败构造器。类似的，派生类的可失败构造器可以向上代理其父类的可失败构造器。 注意：一个可失败构造可以代理一个非失败构造器。如果你需要添加一个可能失败的状态到现有构造过程，请使用这个办法，否则将会构造失败。 重写可失败构造器你可以在派生来中重写父类的可失败构造器，就像其他构造器那样。或是你可以用派生类的 非失败 构造器重写父类的可失败构造器。这允许你定义一个不会构造失败的派生类，即使父 类的构造过程允许失败。 注意如果你使用非失败的派生类构造器重写了可失败的父类构造器，向上代理父类构造器的唯一的方法就是强制解包(force-unwrap)可失败父类构造器的结果。 你可以使用非失败构造器重写可失败构造器，但是反过来不行。 init! 可失败构造器通常使用在关键字 init 后面放置问号( init? )的方式来定义一个可失败构造器， 用于创建一个适当的可选类型实例。你也可以定义一个可失败构造器，将其用于创建一个适 当的隐式解包可选类型的实例。为了定义这个可失败构造器，在关键字 init 后面用叹号 来替代问号( init! )。 必要构造器在类构造器的定义前写修饰符 required 以指明该类的每个派生类必须实现此构造器。 在每个派生类实现必要构造器时也必须在构造器前面写修饰符 required ，以指明构造器要求应用于继承链中所有派生类。重写一个必要指定构造器时无需写修饰符 override 。 使用闭包或函数设置默认属性值123456class SomeClass &#123; let someProperty: SomeType = &#123; // 在闭包中创建⼀一个带有默认值的 someProperty // someValue 的类型必须是 SomeType return someValue &#125;() &#125; 注意那个闭包的结束是在大括号后面尾随一对空括号。这告诉 Swift 立即执行闭包。如果你 忽略了这对括号，则为试图将闭包本身赋值给属性，而不是闭包的返回值。 注意：如果你使用闭包初始化属性，记住在闭包执行时其他实例还未初始化。这意味着无法在闭包中访问其他属性值，即使那些属性有默认值。你也不能隐式使用 self 属性，或 是调用实例方法。","tags":[{"name":"构造过程","slug":"构造过程","permalink":"http://yoursite.com/tags/构造过程/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"14. 继承","date":"2019-01-28T01:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/14__继承/","text":"定义一个基类 子类生成 重写 防止重写 一个类可以继承另一个类的方法、属性以及其他特性。当一个类继承另一个类时，继承类称为子类，被继承类称为父类。在 Swift中，继承是类类型区别于其他类型的基本特性。 也就是说类的主要特性是继承. Swift中的子类可以调用和访问父类的方法、属性和下标。还可以重写这些方法、属性和下标来优化或修改它们的行为。Swift会通过检查重写的定义和父类的定义是否匹配来帮助确保重写是正确的。 子类还可以给继承的属性添加属性观察器，以便在属性值发生变化时得到通知。属性观察器可以被添加到任何属性，不管它原始定义是储存属性还是计算属性。 定义一个基类Swift 中的类并不继承自一个统一的类。定义类时如果不指定父类，那么该类自动成为基类。 子类化子类化：是在已有类的基础上创建新类的行为。 重写一个子类可以对实例方法、类方法、实例属性、类属性和下标进行自定义实现，如果没有自定义，则会从超类继承，这就是所谓的重写。 重写从父类继承的特性，你需要在定义重写时添加 override 前缀。这表明你打算重写一个特性并且没有使用错误的匹配定义。意外的重写会导致不可预料的行为，且任何没有使 用 override 关键词修饰的重写声明在编译代码时会被标记为错误。 override 关键词也提醒 Swift 编译器去检查你重写的这个类的超类(或它的某个父类) 是否有匹配重写版本的声明。这个检查确保你的重写定义是正确无误的。 override 关键字很重要，帮你检查重写是否正确。 访问⽗类的⽅法、属性和下标当你在子类中重写方法、属性或下标时，有时把父类的实现作为重写的一部分是很有用的。例如，你可以优化现有的实现，或将修改后的值存储在现有的继承变量中。在适当的情况下，应该用 super 前缀访问父类的方法、属性或下标: 一个名为 someMethod() 的重写方法可以在实现中通过 super.someMethod() 来调用父类的 someMethod() 方法。 一个名为 someProperty 的属性可以在重写 getter 或 setter 的实现中通过 super.someProperty 访问父类的 someProperty 属性。 一个 someIndex 的重写下标可以在重写下标的实现中通过 super[someIndex] 访问父类的相同下标。 访问父类，使用supper。 重写属性的Getters和Setters无论继承的属性原来是存储属性还是计算属性，都可以提供自定义的 getter(如果setter适用，也包括 setter)来重写任何继承属性。子类不知道继承的属性是存储属性还是计算属性，子类只知道继承的属性具有特定的名称和类型。你必须始终声明要重写的属性的名称和类型，以使编译器能够检查你重写的属性是否与具有相同名称和类型的父类属性匹配。通过在子类属性中重写 getter 和 setter，可以将继承的只读属性重写为读写属性，但是，你不能将继承的读写属性重写为只读属性。 注意如果你重写属性的 setter 就必须同时重写属性的 getter。如果你不想在重写 getter 中修改继承属性的值，你可以简单地在 getter 中返回 super.someProperty ，其中someProperty 是你想要重写的属性名称。 重写setter，一定重写getter？为什么。 重写属性观察者你可以用“属性重写特性”给一个继承属性增加属性观察者。 无论这个属性的初始值是多少，当它的值改变时你将会收到通知。更多有关属性观察者的信息，参阅属性观察者. 注意：你不能给常量存储属性或只读属性增加属性观察者。 因为这些属性值不能被修改，所以它是不能提供 willSet 或 didSet 的重写实现。当然，你不能为同一个属性同时提供 setter 重写和 didSet 观察者。 如果你想观察这个属性值的改变，并且你已经为这个属性提供了一个重写的 setter 方法，那么你能在这个自定义 setter 方法里观察到它任何值的改变。 防⽌止重写你可以通过标记方法、属性或下标为final来防止它被重写。通过在方法、属性或下标前添加关键字 final (比如 final var 、 final func 、 final class func 和final subscript )来完成此操作","tags":[{"name":"继承","slug":"继承","permalink":"http://yoursite.com/tags/继承/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"2. 基础","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/2__基础/","text":"Constants and Variables Comments Semicolons Integers Floating-Point Numbers Type Safety and Type Inference Numeric Literals Numeric Type Conversion Type Aliases Booleans Tuples Optionals Error Handling Assertions and Preconditions","tags":[{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/基础/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"枚举","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/视频学习记录/3/","text":"————补充 @inline(never) 永远不会内联 @inline(__always) 代码很长也能内联（递归、动态派发除外） 枚举使用场景：只有几种固定情况","tags":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"视频学习记录","slug":"IOS/swift语言/视频学习记录","permalink":"http://yoursite.com/categories/IOS/swift语言/视频学习记录/"}]},{"title":"7. 函数","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/7__函数/","text":"Defining and Calling Functions Function Parameters and Return Values Function Argument Labels and Parameter Names Function Types Nested Functions","tags":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"7. 函数","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/8__闭包/","text":"Closure Expressions Trailing Closures Capturing Values Closures Are Reference Types Escaping Closures Autoclosures","tags":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"1. 枚举","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/9__枚举/","text":"Enumeration Syntax Matching Enumeration Values with a Switch Statement Iterating over Enumeration Cases Associated Values Raw Values Recursive Enumerations","tags":[{"name":"枚举","slug":"枚举","permalink":"http://yoursite.com/tags/枚举/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"10. 类和结构体","date":"2019-01-24T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/10__类和结构体/","text":"Comparing Structures and Classes Structures and Enumerations Are Value Types Classes Are Reference Types","tags":[{"name":"类和结构体","slug":"类和结构体","permalink":"http://yoursite.com/tags/类和结构体/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"12. 方法","date":"2019-01-18T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/12__方法/","text":"Instance Methods 实例方法 Type Methods 类型方法 实例方法self 属性： 类型的每个实例都有一个名为 self 的隐式属性，它与实例本身完全等效。你可以使用self 属性来调用自己的实例方法。 在实例例⽅方法中修改值类型： 结构体和枚举是值类型 。默认情况下，无法在其实例方法中修改值类型的属性。你可以通过在方法的 func 关键字前放置 mutating 关键字。 你不能在常量结构体类型上调用异变方法，因为它的属性不能更改，即使它们是变量属性。 在可变方法中给self赋值：可变方法能给隐性的self属性赋以一个全新的实例 类型方法为了明确一个方法是类型方法，你可以在这个方法 的 func 关键词前加上 static 关键词。在类中，也可以使用 class 关键词来声明一个类型方法。与 static 关键词不同的是，用 class 关键词声明的类型方法允许它的子类重写其父类对类型方法的实现。","tags":[{"name":"方法","slug":"方法","permalink":"http://yoursite.com/tags/方法/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"13. 下标","date":"2019-01-18T04:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/13__下标/","text":"Subscript Syntax Subscript Usage Subscript Options 你可以为单个类型定义多个下标，并根据传递给下标的索引值的类型，选择要使用的相应下 标进行重载。 下标不限于单个维度，你可以定义具有多个输入参数的下标以满足你自定义类 型的需求。 下标语法使用下标, 让你可以通过在实例名称后面的方括号中写入一个或多个值来查询类的实例。它们 的语法类似于实例方法和计算属性语法。使用 subscript 关键字定义下标，并且和实例 方法类似，可以指定一个或多个输入参数和返回类型。与实例方法不同，下标可以是读写或 只读。和计算属性类似, 读写是由 getter 和 setter 方法实现的 12345678subscript(index: Int) -&gt; Int &#123; get &#123; // 在这⾥里里返回⼀一个对应下标的值 &#125; set(newValue) &#123; // 在这⾥里里执⾏行行对应的赋值操作 &#125; &#125; 与只读计算属性一样，你可以通过删除 get 关键字以及大括号来简化只读下标的声明 123subscript(index: Int) -&gt; Int &#123; // 在这⾥里里返回⼀一个对应下标的值&#125; 下标用法下标通常被用来作为访问集合、列表或序列中的元素的快捷方式. Swift 的 Dictionary 类型将其键值作为下标实现并返回一个可选类型 下标选项下标可以设置任意数量的输入参数，这些输入参数也可以是任意类型。 同时，下标也可以返 回任何类型。 下标可以使用可变参数，但它们不能使用输入输出参数或是提供默认参数值。","tags":[{"name":"下标","slug":"下标","permalink":"http://yoursite.com/tags/下标/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"11. 属性","date":"2019-01-18T03:07:12.000Z","path":"wiki/IOS/swift语言/swift学习摘要/11__属性/","text":"Stored Properties 存储属性 Computed Properties 计算属性 Property Observers 属性观察器 Global and Local Variables Type Properties 类型属性 存储属性将常量和变量值存储为实例 的一部分，而计算属性则是通过计算得到一个值(而不是存储值)。计算属性适用于类、结 构体和枚举类型，而存储属性只适用于类和结构体类型。 存储属性常量结构体实例的存储属性：当值类型的实例声明为常量时，其所有属性也都被标记为常量。如果将引用类型的实例声明为常量时，你仍可以修改该实例的变量属性。 延迟存储属性：第一次使用时才进行计算。lazy标识，你必须始终将延迟属性声明为变量(使用 var 关键字)，因为延迟属性的初始值可能在实例初始化完成之后，仍然没有被赋值。而常量属性必须在实例初始化完成 之前 就 获得一个值，因此不能声明为延迟。lazy和let是天敌啊 lazy属性必须是var，因为后面会修改 存储属性和实例变量： swift属性没有相应的实例变量，并且属性的底层存储不能直接访问。 计算属性除了存储属性之外，类、结构体和枚举还可以定义 计算属性。它们会提供了一个 getter 方法和一个可选的 setter 方法来间接读取和设置其他属性和 值。 只读计算属性：只有 getter 方法但没有 setter 方法的计算属性称为 只读计算属性 。 你必须使用 var 关键字来声明计算属性(包括只读计算属性)，这是因为它们的值 是不固定。 let 关键字仅用于常量属性，这种属性一旦被初始化以后，就不能再更 改它们的值。 计算属性必须有显示的类型， 同时get、set 后面没有冒号。计算属性必须是var，因为你的值不固定 只读计算属性可以去掉get和花括号 属性观察器属性观察器会观察并对属性值的变化做出反应。每次设置属性值时都会调用属性观察器，即使新值与属性的当前值相同。 你可以将属性观察器添加到你定义的任何存储属性上，但延迟存储属性除外。你还可以通过在子类中重写属性来为任何继承的属性(无论是存储还是计算)添加属性观察器。你并不需 要为非重写的计算属性定义属性观察器，因为你可以在计算属性的 setter 方法中观察并响应其值的更改。 你可以选择在属性上定义一个或两个观察器: 在存储值之前调用 willSet 。 存储新值后立即调用 didSet 。 在调用父类初始化方法之后，在子类中给父类属性赋值时，将会调用父类属性的 willSet 和 didSet 观察器。如果在调用父类初始化方法之前，在子类中给父类属性赋值，则不会调用父类的观察器。 didSet 观察器不会为旧值提供自定义参数名称，而是使用默认名称 oldValue 。 1. 对于计算属性，父类有setter， 子类有didset，设置子类的属性，父类的setter也会调用2. 对于存储属性，父类有didSet， 子类有didset，设置子类的属性，父类的didSet也会调用3. 如果有setter，必须有getter， 因为如果没有getter，你取不出来，这个属性还有什么意义？ 全局和局部变量上面描述的用于计算和观察属性的功能也可用于 全局变量 和 局部变量 。全局变量是指在任何函数、方法、闭包或类型上下文之外定义的变量。局部变量是指在函数、方法或闭包上下文中定义的变量。 全局常量和变量总是被延迟计算，与 延迟存储属性 类似。与延迟存储属性不同的是，全局常量和变量不需要使用 lazy 修饰符进行标记。 局部常量和变量永远不会被延迟计算。 类型属性实例属性是属于特定类型的实例的属性。每次创建该类型的新实例时，它都有自己的一组属性值，与任何其他实例不同。 类型属性用于定义一个对某个类型的所有实例都可见的值 存储类型属性可以是变量或常量。计算类型属性始终是变量属性，与声明计算实例属性的方式相同。 与存储实例属性不同，你必须始终为存储类型属性提供默认值。这是因为类型本身没有初始化方法来给存储类型属性赋值。存储类型属性在首次访问时被初始化。它们会被保证只初始化一次，即使同时由多个线程访问。请注意你并不需要用 lazy 修饰符标记它们。 类型属性的语法: 你可以使用static关键字定义类型属性，对于类类型的计算属性，可以使用class关键字来允许子类覆盖超类的实现。 类型属性第一次使用的时候初始化， 没必要搞lazy, 第一次访问再初始化，提高了效率","tags":[{"name":"属性","slug":"属性","permalink":"http://yoursite.com/tags/属性/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swift语言","slug":"IOS/swift语言","permalink":"http://yoursite.com/categories/IOS/swift语言/"},{"name":"swift学习摘要","slug":"IOS/swift语言/swift学习摘要","permalink":"http://yoursite.com/categories/IOS/swift语言/swift学习摘要/"}]},{"title":"","date":"2019-01-17T02:25:31.320Z","path":"wiki/IOS/ABTest/ABTest/about/","text":"说明","tags":[],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"ABTest","slug":"IOS/ABTest","permalink":"http://yoursite.com/categories/IOS/ABTest/"},{"name":"ABTest","slug":"IOS/ABTest/ABTest","permalink":"http://yoursite.com/categories/IOS/ABTest/ABTest/"}]},{"title":"学习计划&资源","date":"2019-01-14T04:07:12.000Z","path":"wiki/资料收集/learn/学习资源/","text":"学习资源记录 英语语法其实蛮简单 学习计划 swift 第三方源码-AFNetworking解析 afn 模块化吧 LeetCodeAnimation Star 28897 leetcode Star 8961 ios 开发好多书 算法类 【图解数据结构】 一组动画彻底理解二叉树遍 每天一算：Binary Tree Preorder Traversal 每天一算：二叉树的中序遍历 五分钟学算法：二叉树的后序遍历 IOS面试类 iOS-InterviewQuestion-collection iOS高级开发面试题整理 IOS有用的文章GCD iOS 多线程：『GCD』详尽总结 GCD源码吐血分析(1)——GCD Queue GCD源码吐血分析(2)——dispatch_async/dispatch_sync/dispatch_once/dispatch group 浅谈iOS多线程(源码) iOS 多线程：『NSOperation、NSOperationQueue』详尽总结 数学类 等差数列和等比数列的求和运算方法 对数及运算法则 牛顿的数学成就（之一）——二项式定理 排列组合详解 暂无分类 正则表达式学习","tags":[],"categories":[{"name":"资料收集","slug":"资料收集","permalink":"http://yoursite.com/categories/资料收集/"},{"name":"learn","slug":"资料收集/learn","permalink":"http://yoursite.com/categories/资料收集/learn/"}]},{"title":"logan 源码浅析","date":"2018-12-19T04:07:12.000Z","path":"wiki/IOS/opensource/logan/logan/","text":"本文旨在通过logan源码，分析logan的整体结构、存储结构、内部的数据结构、主要的C接口、优点、存在的问题。 mmap 其实主要作用就是多个进程共享内存，所以本文有时候将mmap叫做共享内存 基本使用方法123456789///初始化NSData *keydata = [@\"0123456789012345\" dataUsingEncoding:NSUTF8StringEncoding];NSData *ivdata = [@\"0123456789012345\" dataUsingEncoding:NSUTF8StringEncoding];uint64_t file_max = 10 * 1024 * 1024;loganInit(keydata, ivdata, file_max);/// 写入日志NSString *strLog = @\"日志\";logan(LoganTypeAction, strLog); 使用方法非常简单 loganInit 初始化logan系统，logan 写入日志。 整体结构我相信，对应任何一个三方库，你如果想了解它，第一个想知道的问题是：这个库的整体结构是什么结构？ 下面来解密logan整体结构： 就画了一个非常简单的图，但是我觉得能将logan整个日志存储的机制表达出来了。 当程序有日志(命名为data) 需要写入的时候，我们将data做系列处理：格式化(附加上线程、时间等有用的信息)、 压缩、DES加密、 最后追加到mmap中。 mmap 据说能提高写日志的效率，防止丢失， mmap中，如果日志达到了5K，就构成一个压缩单元，如果有后续的日志，就新开始一个压缩单元。 当mmap中的日志超过容量(初始指定10M)的1/3就写入日志文件中。 当日志文件满了，不知道怎么处理了，上传，还是上传？ logan没实现！！！！ 下面贴出了logan本地文件的结构 2018-12-19 是日志文件。 logan.mmap2是共享内存的映射文件。 logan本质–存储结构如果你通过上节，了解了logan的整体结构，有没有它的感觉设计也很平凡？那么你现在有没有好奇logan到底哪里出色？值得美团去开源它？ 我觉得核心的就是大量日志的组织结构，也就是如何高效的将大量日志组织在本地存储，你也可以想想。如果自己做，怎么组织？ logan用简单的方式实现了海量日志的本地存储，本质是自己设计了一套日志存储格式，它就是logan的本质，理解了本质，就理解了logan。 通过查阅源码，整理的日志格式如下 ： 图的阅读方式：下面部分是对上面部分的展开。分为两部分，日志头、日志体（图中左右两部分）。 日志头日志头以0x0D标志位表示header开始，紧接着用两个字节表示头内容的长度、接着是头内容、最后用0x0E标志位表示header结束。 头内容数据如下： 1234&#123; \"logan_version\":3, \"file\":\"2018-12-19\"&#125; logan_version 表示logan的版本，file字段存储日志文件的文件名。 也就是你如果拿到了共享内存，就能通过读取头信息，将共享内存中的数据写入到file表示的日志文件中。 日志体日志体由长度(total_len，占用三字节、小端模式存储)、协议组成。 协议由协议起始标志位(1字节、值为0x01)、内容、协议结束标志位(1字节、值为0x00)。我自己理解，所谓协议就是一个压缩单元，超过5K开始下一个压缩单元。 内容由内容长度(4字节，大端模式存储)、各个log组成。 先睹为快、窥探日志数据如果看懂了上节内容，你有没有想窥探下logan内存结构的欲望？ 0x0D 头起始标志 0x0028 = 40 头长度 0x7B ~0x7D00 头内容 0x0E 头结束标志 —这里是分割线， 表示头结束，下面是日志体— 0x000055 tatal_len 日志体总长度 0x01 协议起始标志位 0x00000050 内容长度 0x14D7~0x465C 多个压缩加密后的日志 0x00 协议结束标志位 看了logan日志存储格式，我自己总结了下，其实就是一个三级结构： 你可以回头想想，所有的字段都服务于这个三级结构，如果你按照三级结构的思路理解，这里就没有多余的信息。 我首次看，就觉得怎么这么多len信息，是否是多余的呢。 日志追加机制追加机制下面我们就可以进一步深入logan日志增加的机制了，其实，追加日志主要靠四个指针就完成了。 说明下这四个指针的作用： buffer_point 标记mmap的起始地址，基本固定不变。 total_point日志体的起始位置指针 ，这个指针目的是当有新日志添加的时候，更新total_point后面的total_len属性。位置也不变化。 content_lent_point内容起始位置指针，一个压缩单元完事后，前进一次。它的主要作用是，当增加log后，更新后面的content_len的内容。其实就是指向上面三级结构中的第二级结构 last_point 添加日志起始指针 ,每次新的日志都追加到last_point处，追加完后，更新last_point为下一个追加位置。 上面多次提到了压缩单元，我们用下面的图说明下压缩单元递增的思路： 上面是一个压缩单元完成后，开始新压缩单元的示意图。我们可以观察content_lent_point、last_point两个指针移动的情况。(箭头从 蓝色-&gt; 蓝色-&gt; 绿色 的变化过程) 关键节点通过上面我们了解了三个基本的关键节点： 5k 一个压缩单元的大小 1LOGAN_MAX_GZIP_UTIL 5 * 1024 //压缩单元的大小 容量(初始指定10M)的1/3 写文件的节点 12LOGAN_WRITEPROTOCOL_DEVIDE_VALUE 3 //多少分之一写入buffer_length / LOGAN_WRITEPROTOCOL_DEVIDE_VALUE 10M 日志文件总大小 1uint64_t file_max = 10 * 1024 * 1024 小结感觉也不是很复杂，就是用四个指针标记修改的位置，有新的日志来了，就追加到last_point处。 核心数据结构logan的结构、存储本质、追加日志机制都讲完了，接着看看代码是怎么实现的。logan用一个全局的数据结构管理所有的数据，这个数据结构定义如下 ： 123456789101112131415161718192021222324252627typedef struct logan_model_struct &#123; int total_len; //数据长度 char *file_path; //文件路径 int is_malloc_zlib; z_stream *strm; int zlib_type; //压缩类型 char remain_data[16]; //剩余空间 int remain_data_len; //剩余空间长度 int is_ready_gzip; //是否可以gzip int file_stream_type; //文件流类型 FILE *file; //文件流 long file_len; //文件大小 unsigned char *buffer_point; //缓存的指针 (不变) unsigned char *last_point; //最后写入位置的指针 unsigned char *total_point; //总数的指针 (可能变) , 给c看,低字节 unsigned char *content_lent_point;//协议内容长度指针 , 给java看,高字节 int content_len; //内容的大小 unsigned char aes_iv[16]; //aes_iv int is_ok;&#125; cLogan_model; 感觉定义的很乱，我整理了下 ： 日志文件相关的：有日志文件的路径file_path、文件流状态file_stream_type、文件流file、文件内容的大小file_len。其中文件流状态file_stream_type可选的取值： 123#define LOGAN_FILE_NONE 0 #define LOGAN_FILE_OPEN 1 #define LOGAN_FILE_CLOSE 2 压缩相关的： is_malloc_zlib 表示strm是否申请空间 ,zlib_type 压缩状态，is_ready_gzip压缩是否准备好。 zlib_type可以的取值如下： 12345#define LOGAN_ZLIB_NONE 0#define LOGAN_ZLIB_INIT 1#define LOGAN_ZLIB_ING 2#define LOGAN_ZLIB_END 3#define LOGAN_ZLIB_FAIL 4 mmap操作相关的，记录日志的长度信息、四个指针的信息。 下面是加密相关的，DES加密是16字节为一个单元，如果日志压缩后，长度取余，不足16字节的内容就不参与加密了，等着下次日志，一起加密。所以remain_data、remain_data_len表示剩下的未加密的压缩过的日志数据。aes_iv 表示DES加密的初始向量。 is_ok 表示整个logan是否是正常状态。 我将上面的数据分类主要的5类，到了哪一步，关注哪一步就ok了。分类后，就很好理解了。 核心接口下面我列举了logan C语言层的4个核心接口： 1234567int clogan_init(const char *cache_dirs, const char *path_dirs, int max_file, const char *encrypt_key16, const char *encrypt_iv16)int clogan_open(const char *pathname)int clogan_write(int flag, char *log, long long local_time, char *thread_name, long long thread_id,int is_main) int clogan_flush(void) 下面一一讲解下，所有的代码都是缩减代码。方便理解函数完成的主体工作。 clogan_initclogan_init 主要功能是： 打开映射内存 如果存在上次程序结束后没有写入文件的日志，将上次日志写入到文件中。使本次以一个干净的环境开始。 12345678910111213141516171819202122232425262728293031intclogan_init(const char *cache_dirs, const char *path_dirs, int max_file, const char *encrypt_key16, const char *encrypt_iv16) &#123; ///保存秘钥、初始向量 aes_init_key_iv(encrypt_key16, encrypt_iv16); /// 构建内存映射文件路径 char *cache_path = malloc(total); if (NULL != cache_path) &#123; _mmap_file_path = cache_path; &#125; /// 构建日志目录 if (NULL != dirs) &#123; _dir_path = dirs; //日志写入的文件目录 &#125; /// 打开内存映射 if (NULL == _logan_buffer) &#123; if (NULL == _cache_buffer_buffer) &#123; flag = open_mmap_file_clogan(cache_path, &amp;_logan_buffer, &amp;_cache_buffer_buffer); &#125; ///读取内存映射中的日志，写入到文件中，准备开始一个干净的日志环境。 if (is_init_ok) &#123; if (flag == LOGAN_MMAP_MMAP) //MMAP的缓存模式,从缓存的MMAP中读取数据 read_mmap_data_clogan(_dir_path); &#125; &#125; clogan_openclogan_open 主要工作是： 初始化zlib 初始化加密模块 初始化全局数据logan_model 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142int clogan_open(const char *pathname) &#123; is_open_ok = 0; ///全局的logan_model 初始化 if (NULL != logan_model) &#123; //回写到日志中 &#125; else &#123; logan_model = malloc(sizeof(cLogan_model)); if (NULL != logan_model) &#123; memset(logan_model, 0, sizeof(cLogan_model)); &#125; &#125; logan_model-&gt;file_path = temp_file; logan_model-&gt;buffer_point = _logan_buffer; /// zlib 的初始化 init_zlib_clogan(logan_model) ///添加头信息 add_mmap_header_clogan(back_data, logan_model); logan_model-&gt;last_point = logan_model-&gt;total_point + LOGAN_MMAP_TOTALLEN; logan_model-&gt;total_point = _logan_buffer; logan_model-&gt;total_len = 0; logan_model-&gt;last_point = logan_model-&gt;total_point + LOGAN_MMAP_TOTALLEN; ///设置关键指针信息，长度信息 restore_last_position_clogan(logan_model); /// 加密信息初始化 init_encrypt_key_clogan(logan_model); logan_model-&gt;is_ok = 1; if (is_open_ok) &#123; back = CLOGAN_OPEN_SUCCESS; &#125; return back;&#125; clogan_open 主要完成：初始化全局的logan_model、init_zlib_clogan、init_encrypt_key_clogan 三个工作。 clogan_write代码clogan_write 顾名思义，就是写入日志，这里用简单的树形结构描述它的过程。 1234567891011121314151617181920├── clogan_write│ └── clogan_write_section分片写入│ └── clogan_write2│ ├── 1. clogan_zlib_compress│ │ └── clogan_zlib│ │ ├── aes_encrypt_clogan│ │ └── deflate│ ├── 2. update_length_clogan(logan_model);///写完日志，更新长度信息│ ├── 3. 如果一个压缩单元完事，结束这个压缩单元│ │ ├── clogan_zlib_end_compress(logan_model)│ │ ├── aes_encrypt_clogan 加密剩余部分│ │ └── update_length_clogan(logan_model)│ ├── 4. 如果mmap的大小大于总容量的1/3│ │ └── write_flush_clogan();写入文件│ └── 5. 如果一个单元完事，还要做下面工作，开始下一个压缩单元│ ├── init_encrypt_key_clogan(logan_model)│ ├── init_zlib_clogan(logan_model)│ ├── logan_model-&gt;content_len = 0│ ├── logan_model-&gt;remain_data_len = 0│ └── restore_last_position_clogan(logan_model) 协议分析 clogan_flushclogan_flush 将mmap中的日志强制写入到文件中。 123int clogan_flush(void) &#123; write_flush_clogan();&#125; clogan_flush 调用了write_flush_clogan。 123456789void write_flush_clogan() &#123; if (logan_model-&gt;total_len &gt; LOGAN_WRITEPROTOCOL_HEAER_LENGTH) &#123; unsigned char *point = logan_model-&gt;total_point; point += LOGAN_MMAP_TOTALLEN; write_dest_clogan(point, sizeof(char), logan_model-&gt;total_len, logan_model); clear_clogan(logan_model); &#125;&#125; write_flush_clogan调用write_dest_clogan将mmap中的数据写入到文件中，同时调用clear_clogan清空全局数据logan_model的状态。 1234567//文件写入磁盘、更新文件大小void write_dest_clogan(void *point, size_t size, size_t length, cLogan_model *loganModel) &#123; fwrite(point, sizeof(char), logan_model-&gt;total_len, logan_model-&gt;file);//写入到文件中 fflush(logan_model-&gt;file); loganModel-&gt;file_len += loganModel-&gt;total_len; //修改文件大小&#125; 优点美团的Logan：美团点评移动端基础日志库揭秘说，有下面的缺点： 卡顿，影响性能 日志丢失 安全性 日志分散 我看了logan的源码，logan确实解决了上面的问题，反过来，logan有下面的优点： 不卡顿，性能好 日志不丢失 安全 日志集中 目前存在的问题logan主要实现了日志的本地存储功能，考虑的很多边界情况，我觉得应该可以使用，但是还存在下面的问题 ： 没有日志回捞功能(没有开源，这个工作主要在服务端，客户端也没发现对应的接口) 没有主动上报功能(主动上报有简单的实现，这个应该也归结为使用者的功能吧) 日志大于10M的情况没有处理，需要自己完善。 没有写的证据在这里： 12345678if (is_file_exist_clogan(logan_model-&gt;file_path)) &#123; if (logan_model-&gt;file_len &gt; max_file_len) &#123; printf_clogan(\"clogan_write &gt; beyond max file , cant write log\\n\"); back = CLOAGN_WRITE_FAIL_MAXFILE; return back; &#125;&#125; 如果文件的大小超过了10M，直接返回了 ，不在写入日志。 胡思乱想 参考 Logan：美团点评移动端基础日志库揭秘","tags":[{"name":"logan","slug":"logan","permalink":"http://yoursite.com/tags/logan/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"logan","slug":"IOS/opensource/logan","permalink":"http://yoursite.com/categories/IOS/opensource/logan/"}]},{"title":"mmap原理之详解(转载)","date":"2018-12-19T01:07:12.000Z","path":"wiki/编程理论/mmap/union定义的副本/","text":"主要内容 mmap基础概念 mmap内存映射原理 mmap和常规文件操作的区别 mmap优点总结 mmap相关函数 mmap使用细节 在上面的知识前提下我们下面看看如果大小不是页的整倍数的具体情况 文章出处：mmap原理之详解 mmap基础概念mmap是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示：","tags":[{"name":"mmap","slug":"mmap","permalink":"http://yoursite.com/tags/mmap/"}],"categories":[{"name":"编程理论","slug":"编程理论","permalink":"http://yoursite.com/categories/编程理论/"},{"name":"mmap","slug":"编程理论/mmap","permalink":"http://yoursite.com/categories/编程理论/mmap/"}]},{"title":"6. 如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门(转载)","date":"2018-12-13T04:18:26.000Z","path":"wiki/IOS/crash/6_increase_Wild_Pointer/","text":"本文终于可以利用OC Runtime的特性，让OC野指针对象主动抛出自己的信息，某些情况下秒杀某些全系统栈Crash 为什么错误地址是0x55555561？前文介绍了在内存释放后填充0x55使野指针出现后数据不能访问，从而使野指针变成了必现的方法，那这里会有一个比较奇怪的问题：我们在释放的内存上填上了0x55，但为什么大部分时候野指针Crash了，出错的地址却是0x55555561？ 为了解答这个问题，我们可以先看看Crash栈，就会发现这些Crash都是在objc_msgSend上。我们知道Obj-C的对象方法调用是通过objc_msgSend进行的，我们通过野指针访问一个对象的方法也一样，其实是通过objc_msgSend给已经释放的对象发了一条消息。 而objc_msgSend的函数签名是这样： id objc_msgSend(id self, SEL op, …)我们再来看看objc_msgSend的代码: 12345678910111213141516171819202122libobjc.A.dylib`objc_msgSend: 0x2f879f40 &lt;+0&gt;: cbz r0, 0x2f879f7e ; &lt;+62&gt; 0x2f879f42 &lt;+2&gt;: ldr.w r9, [r0] 0x2f879f46 &lt;+6&gt;: ldrh.w r12, [r9, #0xc] 0x2f879f4a &lt;+10&gt;: ldr.w r9, [r9, #0x8] 0x2f879f4e &lt;+14&gt;: and.w r12, r12, r1 0x2f879f52 &lt;+18&gt;: add.w r9, r9, r12, lsl #3 0x2f879f56 &lt;+22&gt;: ldr.w r12, [r9] 0x2f879f5a &lt;+26&gt;: teq.w r12, r1 0x2f879f5e &lt;+30&gt;: bne 0x2f879f66 ; &lt;+38&gt; 0x2f879f60 &lt;+32&gt;: ldr.w r12, [r9, #0x4] 0x2f879f64 &lt;+36&gt;: bx r12 0x2f879f66 &lt;+38&gt;: cmp.w r12, #0x1 0x2f879f6a &lt;+42&gt;: blo 0x2f879f78 ; &lt;+56&gt; 0x2f879f6c &lt;+44&gt;: it eq 0x2f879f6e &lt;+46&gt;: ldreq.w r9, [r9, #0x4] 0x2f879f72 &lt;+50&gt;: ldr r12, [r9, #8]! 0x2f879f76 &lt;+54&gt;: b 0x2f879f5a ; &lt;+26&gt; 0x2f879f78 &lt;+56&gt;: ldr.w r9, [r0] 0x2f879f7c &lt;+60&gt;: b 0x2f87a1c0 ; _objc_msgSend_uncached 0x2f879f7e &lt;+62&gt;: mov.w r1, #0x0 0x2f879f82 &lt;+66&gt;: bx lr 我们可以结合Obj-C类的内存布局再来解读一下上面的汇编代码（节选于Obj-C类的源代码）： 12345678910111213141516171819202122232425262728struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; uintptr_t data_NEVER_USE; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return (class_rw_t *)(data_NEVER_USE &amp; ~CLASS_FAST_FLAG_MASK); &#125; void setData(class_rw_t *newData) &#123; uintptr_t flags = (uintptr_t)data_NEVER_USE &amp; CLASS_FAST_FLAG_MASK; data_NEVER_USE = (uintptr_t)newData | flags; &#125;……..struct cache_t &#123; struct bucket_t *buckets; mask_t shiftmask; mask_t occupied;…….. struct bucket_t &#123; cache_key_t key; IMP imp;…...typedef uintptr_t cache_key_t; 根据苹果的函数调用约定，objc_msgSend被调用的时候，寄存器对应关系：r0是对象本身self，r1是sel，r2和r3是参数。根据objc_class的声明，我们可以知道： 12345678910110x2f879f40 &lt;+0&gt;: cbz r0, 0x2f879f7e //如果self为0就跳转到0x2f879f7e。给nil发消息的话就什么都不做0x2f879f42 &lt;+2&gt;: ldr.w r9, [r0] //取对象的类到r90x2f879f46 &lt;+6&gt;: ldrh.w r12, [r9, #0xc] //取类的偏移#0xc的数据到r12，也就是shiftmask的值0x2f879f4a &lt;+10&gt;: ldr.w r9, [r9, #0x8] //取类的偏移#0x8的成员到r9，也即是cache0x2f879f4e &lt;+14&gt;: and.w r12, r12, r1 //r1和shiftmask与，放到r12,r1是参数一，也就是sel，用来计算sel的index0x2f879f52 &lt;+18&gt;: add.w r9, r9, r12, lsl #3 //左移3位就是乘8，8是索引项 bucket_t的宽度，r12是cache索引，r9就cache的位置，r9+r12*8，就是当前sel对应的bucket_t缓存0x2f879f56 &lt;+22&gt;: ldr.w r12, [r9] //取缓存bucket_t0x2f879f5a &lt;+26&gt;: teq.w r12, r1 //判断缓存项是不是要找的sel key==sel？0x2f879f5e &lt;+30&gt;: bne 0x2f879f66 //不是的话就要查找sel0x2f879f60 &lt;+32&gt;: ldr.w r12, [r9, #0x4] //是的话就取出imp0x2f879f64 &lt;+36&gt;: bx r12 //调sel的实现，跳到imp里面去执行 其实上面的代码就是从缓存中找sel的实现的过程，而错误地址之所以是0x55555561是因为ldrh.w r12, [r9, #0xc]这行指令。我们用0x55555555覆盖了对象的isa指针，当发生OC调用查找缓存0x55555555+0xc取shiftmask的时候，发现这个地址不可读，于是CPU抛出了异常。 怎么获取野指针的更多异常数据？弄清楚上述问题后，又有一个问题：既然0x55555555是被当成了类的指针使用，那假如我们用指定的类覆盖这个指针，是不是就可以执行我们指定类的方法呢？ 进一步说就是在发生野指针调用的时候，我们是不是可以控制CPU的行为？说起来有点像溢出攻击，利用shellcode覆盖函数返回值，一旦我们在出错的时候控制了CPU就可以获取更多异常信息，比如是哪个类，调了什么方法，对象的地址之类。 先解决几个关键问题： 覆盖成什么？我们需要自己写一个类，用它的isa来替换已经释放的对象的isa。如果不出我们所料，我们用自己的类覆盖之后，之前调用的sel就换成了调用我们自己的类的某个sel。这样，只要我们指定的类也实现这个方法，就可以执行我们需要执行的代码，然后在里面获取我们需要的信息。当然，我们无法预料野指针对象会在调用哪个函数时发生Crash，好在我们可以利用runtime的重定向特性了转到我们自己的代码里面去。 怎么覆盖isa？object_setClass可以替换一个类的isa，但是试了一下，发生死锁！根据Obj-C对象的内存布局，对象的第一个数据就是isa，这里我们可以直接用自己的类指针替换它，反正是已经释放的内存，随便我们怎么玩。总之，还是很简单，这个类就是下面这样: 123456789101112131415161718192021222324@interface DPCatcher : NSObject@property (readwrite,assign,nonatomic) Class origClass;@end@implementation DPCatcher- (id)forwardingTargetForSelector:(SEL)aSelector&#123; NSLog(@\"发现objc野指针:%s::%p=&gt;%@\",class_getName(self.origClass),self,NSStringFromSelector(aSelector)); abort(); return nil;&#125;-(void)dealloc&#123; NSLog(@\"发现objc野指针:%s::%p=&gt;%@\",class_getName(self.origClass),self,@\"dealloc\"); abort();&#125;-(oneway void)release&#123; NSLog(@\"发现objc野指针:%s::%p=&gt;%@\",class_getName(self.origClass),self,@\"release\"); abort();&#125;- (instancetype)autorelease&#123; NSLog(@\"发现objc野指针:%s::%p=&gt;%@\",class_getName(self.origClass),self,@\"autorelease\"); abort();&#125;@end 注意：对象的release、dealloc等函数要特殊处理一下，因为任何对象都有这些方法，不会执行重定向。 然后，我们的free函数改成下面这样（去掉了一些多余代码）： 123456789101112131415161718192021static void DPFree(void* p)&#123; size_t memSiziee=malloc_size(p); if (memSiziee&gt;sDPCatchSize) &#123;//有足够的空间才覆盖 id obj=(id)p; Class origClass=object_getClass(obj); //判断是不是objc对象 ，registeredClasses里面有所有的类，如果可以查到，说明是objc类 if (origClass &amp;&amp; CFSetContainsValue(registeredClasses, origClass)) &#123; memset(obj, 0x55, memSiziee); memcpy(obj, &amp;sDPCatchIsa, sizeof(void*));//把我们自己的类的isa复制过去 DPCatcher* bug=(DPCatcher*)p; bug.origClass=origClass; &#125;else&#123; memset(p, 0x55, memSiziee); &#125; &#125;else&#123; memset(p, 0x55, memSiziee); &#125; return;&#125; 初始化的时候获取所有类信息，获取填充类的的大小: 12345678910111213registeredClasses = CFSetCreateMutable(NULL, 0, NULL); unsigned int count = 0; Class *classes = objc_copyClassList(&amp;count); for (unsigned int i = 0; i &lt; count; i++) &#123; CFSetAddValue(registeredClasses, (__bridge const void *)(classes[i])); &#125; free(classes); classes=NULL; sDPCatchIsa=objc_getClass(\"DPCatcher\"); sDPCatchSize=class_getInstanceSize(sDPCatchIsa); 用下面简单的代码试一下： 123UIView* testObj=[[UIView alloc] init];[testObj release];[testObj setNeedsLayout]; 发生野指针的类、对象地址和访问的方法就这样可以被打印出来！ 上面这两个Crash如果不能重现几乎是无解！但是，加上我们的野指针定位神器之后再看看，类名和地址都可以打出来了，解决起来就不是什么问题了。 说明： 我们打印出了野指针对象的名字和地址，当这个类的对象比较少时，对查找问题有很大的用处（如果是自定义的类出现野指针，一般还是比较容易找到问题），但是如果是一些经常出现的类，比如nsarray，定位起来还是比较麻烦。这个时候建议试一下xcode的malloc history工具，或者可以自己实现一个类似记录内存使用记录的工具，因为有内存申请和释放的记录，只要重现一次就可以精确定位野指针。 如果出现dealloc的使用错误，例如先[super dealloc]，然后release成员变量，那么就会出现崩溃的现象，且此时对象的地址为0x55555555。这是因为[super dealloc]只会释放对应的内存，但其成员的内存不会被release而变成了0x555555。 这种问题场景比较简单，一旦发生绝对是必现的，修复也比较容易。 后记 写到这里，关于iOS野指针随机问题定位的三篇文章就写完了，特别说一下，文中提到的方法虽然可以提高野指针的曝光率和定位精度，但并不是万能，比如下面这几种情况，可能并不一定适用： 未触发出现野指针的逻辑：比如说一个有问题的代码，只有在特殊的逻辑下才会有野指针问题，如果我们没有触发这个逻辑，肯定也是无法暴露出这个问题的。这种情况建议还是提高测试的场景覆盖。 产生野指针和使用野指针的时间间隔太长：时间太长的话，很可能我们保留的指针已经被释放了。 APP内存消耗大，会降低曝光率。因为内存消耗大的时候，我们保留的指针数量必然减少，而且保留的时间也会更短。 free之前先填上 0x55 ，这个0x55有什么具体含义吗？答：实际上填写数据的关键在于填写数据后其地址指向不可读的内存。而填写0x55，和前面提到的出现异常情况的对象地址0x555555连接起来被当成指针使用的话，就会被识别为0x55555555，而CPU访问这个地址就会抛出异常。另外一点，就是方便区分野指针，例如在Xcode启用Enable Scribble时，指定alloc之后填写的地址为0xaa，防止内存初始化就使用，也是为了方便和free之后的内存做区分。 这个方法对于arc和非arc是否都可以用？答：都可以，不过都是arc的话应该比较少出现野指针吧。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"7. Scribble& NSZombieEnabled","date":"2018-12-13T04:18:26.000Z","path":"wiki/IOS/crash/7_increase_Wild_Pointer/","text":"主要内容： 定位野指针的方法。 野指针分析方法(Enable Malloc Scribble)因为野指针的原因发生崩溃是常常出现的事，而且比较随机。所以我们要提高野指针的崩溃率,从而帮我们快速找到有问题的代码。 对象释放后，只有出现被随机填入的数据是不可访问的时候才会必现Crash。 这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。 僵尸模式(NSZombieEnabled)启用了NSZombieEnabled的话，它会用一个僵尸来替换默认的dealloc实现，也就是在引用计数降到0时，该僵尸实现会将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。 所以当启用NSZombieEnabled时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接受到得信息，然后跳入调试器，这样你就可以查看到底是哪里出了问题。 所以这时一般崩溃的原因是：调用了已经释放的内存空间，或者说重复释放了某个地址空间。 如何找出问题 NSZombieEnabled打开NSZombieEnabled之后，如果遇到对应的崩溃类型既调用了已经释放的内存空间，或者说重复释放了某个地址空间。那么就能在GDB中看到对应的输出信息。 比如会出现如下这样的问题：[__NSArrayM addObject:]: message sent to deallocated instance 0x7179910 MallocStackLoggingNoCompact如果崩溃是发生在当前调用栈，通过上面的做法，系统就会把崩溃原因定位到具体代码中。但是，如果崩溃不在当前调用栈，系统就仅仅只能把崩溃地址告诉我们，而没办法定位到具体代码，这样我们也没法去修改错误。这时就可以修改scheme，让xcode记录每个地址alloc的历史，这样我们就可以用命令把这个地址还原出来。如图：(跟设置NSZombieEnabled一样，添加MallocStackLoggingNoCompact，并且设置为YES) 这样，当出现崩溃原因是message sent to deallocated instance 0x7179910，我们可以使用以下命令，把内存地址还原： (gdb) nfo malloc-history 0x7179910 也可以使用下面的命令(gdb) shell malloc_history {pid/partial-process-name} {address} Enable Address Sanitizer（地址消毒剂）设置这个参数后就能看到一些更详细的错误信息提示，甚至会有内存使用情况的展示。 C语言是一门危险的语言，内存安全是一个主要的问题。C语言中根本没有内存安全可言。像下面的代码，会被正常的编译，而且可能正常运行：char *ptr = malloc(5);ptr[12] = 0;对于内存安全的验证已经有一些解决方案了。如Clang的静态代码分析，可以从代码中查找特定类型的内存安全问题。如Valgrind之类的程序可以在运行时检测到不安全的内存访问。 Address Sanitizer是另外一种解决方案。它使用了一种新的方法，有利有弊。但仍不失为一个查找代码问题的有力工具。 这类工具的理论依据是：访问内存时，通过比较访问的内存和程序实际分配的内存，验证内存访问的有效性，从而在bug发生时就检测到它们，而不会等到副作用产生时才有所察觉。 malloc函数总是最少分配16个字节。为了储存针对标准malloc的内存的保护，需要分配内存到16字节的范围内，因此，若分配的内存大小不是16字节的整数倍，余出的几个字节将不受保护。 Address Sanitizer会追踪受限内存，使用了一种简单但是很巧妙的方法：它在进程的内存空间上保存了一个固定的区域，叫做“影子内存区”。用内存消毒剂的术语来说，一个被标记为受限的内存被称作“中毒”内存。“影子内存区”会记录哪些内存字节是中毒的。通过一个简单的公式，可以将进程中的内存空间映射到“影子内存区”中，即：每8字节的正常内存块映射到一个字节的影子内存上。在影子内存上，会跟踪这8字节的“中毒状态”。 Static Analyzer（静态分析）Static Analyzer是一个非常好的工具去发现编译器警告不会提示的问题和一些个人的内错泄露和死存储（不会用到的赋了值的变量）错误。这个方法可能大大的提高内存使用和性能，以及提升应用的整体稳定性和代码质量。 打开方式：Xcode-&gt;Product-Analyze然后我们就能看到如下蓝色箭头所示的一些有问题的代码。 unrecognized selector send to instancd 快速定位在debug navigator的断点栏里添加Create Symbolic Breakpoint。 在Symbolic中填写如下方法签名：-[NSObject(NSObject) doesNotRecognizeSelector:] 设置完成后再遇到类似的错误就会定位到具体的代码。 参考的源码FJFZombieSnifferDemo 参考iOS崩溃crash大解析iOS 野指针定位:野指针嗅探器","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"5. 如何定位Obj-C野指针随机Crash(二):让非必现Crash变成必现(转载)","date":"2018-12-13T02:18:26.000Z","path":"wiki/IOS/crash/5_increase_Wild_Pointer/","text":"本文主要内容如下： 注：本文主要介绍一种延迟内在释放的技术，继续上一篇提到的如何提高野指针Crash的概率（可以文章底部点击“阅读原文”，查看上一篇文章）。另外，本文探讨的环境是在非arc情况下。 只有小概率Crash肿么办？之前介绍了一种在内存释放后填充0x55使野指针后数据不能访问，从而使某些野指针从不必现Crash变成了必现。然而，我们早就看穿了一切，这个事情不会那么顺利的。 加上上次的代码之后，再试试下面的代码： 其实这就是上一篇文中留下了几个问题之一，如果我们填充0x55后内存又被别的内存覆盖了，最终还是会出现随机Crash。而在真实环境中，这种情况是非常常见的。 我们再梳理一下这个过程： 我们在即将要释放的填了0x55，之后调用了free真正释放，内存被系统回收。 这个时候系统随时可能把这片内存给别的代码使用，也就是说我们的0x55被再次写上随机的数据（在这里再强调一下，访问野指针是不会Crash的，只有野指针指向的地址被写上了有问题的数据才会引发Crash）。 假如释放的内存上又填上了另一个对象的指针，而那个对象也有同样的一个方法，那很可能只是逻辑上有问题，并不会直接Crash，甚至悄无声息地像什么事情都没发生一样。（这个地方可能会发生多种情况，可以参考之上一篇文章中的图） 没有发生Crash可不是好事，因为这种情况如果后续再Crash，问题就非常难查，因为你看到的Crash栈很可能和出错的代码完全没有关联。既然这个问题这么棘手，最好还是和之前一样，让这个Crash提前暴露。 继续提高Crash率沿着上次的思路，首先，我们要解决的问题就是怎么让系统不再往这片释放的内存上乱放东西。 要控制底层内存管理机制让它不使用这些内存可能很困难。但是，我们变通一下，简单粗暴地，我们干脆就不释放这片内存了。也就是当free被调用的时候我们不真的调用free，而是自己保留着内存，这样系统不知道这片内存已经不需要用了，自然就不会被再次写上别的数据（偷笑)。 为了防止系统内存过快耗尽，还需要额外多做几件事： 自己保留的内存大于一定值的时候就释放一部分，防止被系统杀死。 系统内存警告的时候，也要释放一部分内存。 主要代码还是很简单的： 在safe_free以及它调用的函数里面尽量不要再用带锁的函数，不然很容易导致死锁。 加上这个代码之后APP的内存占用会增大不少，拿过来测试可以，但万万不能放在正式的发布版本中。 关于性能问题，我的机器是iPhone5，跑在App里面运行，还算流畅（不同App性能可能会有些不同）。 可能由于锁的存在，会使cpu线程切换变得频繁，这样多线程的问题Crash率也可能会提升（最近遇到一个多线程引起的Crash很难重现，但我加了这个代码后就变成了必现Crash） 做完这些之后拿到项目中实际验证一下，验证的版本可以是经过测试，且遗留Crash问题已经很少，但还没有对外灰度或发布的版本。 但以上代码只是雏形，其实还有很多地方可以优化，大家在试用时可以参考着优化： 最好是根据机器的情况来决定偷偷保留内存的数量。 由于内存申请太过频繁，其实我们保留的内存很快就会耗尽，对于大片的内存，可以适当放过，这样可以提高保存指针的数量，防止消耗的内存过多。 有的APP自己写的都是Obj-C代码，想忽略c、c++对象的话可以过滤掉（会有办法判断的）。 如果觉得某些Obj-C类有问题，可以只保留指定的类对象，如果数量不是特别大，甚至可以干脆不释放。 …… 总结一下理论上，机器的内存越大，我们就可以瞒着系统不释放更多内存，野指针Crash的概率也就越大。 提前暴露问题并解决，避免事后再补，是一个很好的习惯，希望大家都能试试。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"4.如何定位Obj-C野指针随机Crash(一):先提高野指针Crash率(转载)","date":"2018-12-13T01:18:26.000Z","path":"wiki/IOS/crash/4_increase_Wild_Pointer/","text":"本文主要内容如下： 欲让其灭亡先让其疯狂，我们当然不是人为制造Crash，准确地说，是使隐藏的随机性Crash暴露出来，提高测试时的Crash率，从而降低版本发布后的Crash率。 写C、C++代码的同学应该都清楚，Crash最多的原因通常有两种，一种是多线程，一种是野指针。这两种Crash都带随机性，而且这两种Crash有相当一部分都很难区分，甚至大量的Crash只有系统栈，如果不能根据日志重现，几乎是无解，让人非常蛋疼。 本文主要讨论的方向是Obj-C的野指针。Obj-C的野指针最常见的一种栈是objc_msgSend，从Bugly上报的Crash数据来看，objc_msgSend的量占了五分之一，这其中大多数是Obj-C野指针。当然也有相当多的Obj-C野指针不是这种表现，所以野指针的Crash体量非常惊人。 为什么Obj-C野指针的Crash那么多？我们有这么多自动化和人工测试流程，而且还有几轮的灰度过程，其实很多Crash场景都应该已经覆盖到了，但随机性意味着，测试的时候它没有问题，等用户用了才有问题，这种情况该怎么办？！ 我觉得关键在于它的随机性，随机性问题我初略地分为两类： 第一类是跑不进出错的逻辑，执行不到出错的代码，这种可以提高测试场景覆盖度来解决。 第二类是跑进了有问题的逻辑，但是野指针指向的地址并不一定会导致Crash，这好像要看人品了？ 一说到人品就头疼啊有木有，由于上辈子做了太多善事，人品太好每次自测的时候根本不Crash有木有！ 野指针的随机性野指针是指指向一个已删除的对象或未申请访问受限内存区域的指针。本文说的Obj-C野指针，说的是Obj-C对象释放之后指针未置空，导致的野指针（Obj-C里面一般不会出现为初始化对象的常识性错误）。 既然是访问已经释放的对象为什么不是必现Crash呢？ 因为dealloc执行后只是告诉系统，这片内存我不用了，而系统并没有就让这片内存不能访问。 现实大概是下面几种可能的情况： 对象释放后内存没被改动过，原来的内存保存完好，可能不Crash或者出现逻辑错误（随机Crash）。 对象释放后内存没被改动过，但是它自己析构的时候已经删掉某些必要的东西，可能不Crash、Crash在访问依赖的对象比如类成员上、出现逻辑错误（随机Crash）。 对象释放后内存被改动过，写上了不可访问的数据，直接就出错了很可能Crash在objc_msgSend上面（必现Crash，常见）。 对象释放后内存被改动过，写上了可以访问的数据，可能不Crash、出现逻辑错误、间接访问到不可访问的数据（随机Crash）。 对象释放后内存被改动过，写上了可以访问的数据，但是再次访问的时候执行的代码把别的数据写坏了，遇到这种Crash只能哭了（随机Crash，难度大，概率低）！！ 对象释放后再次release（几乎是必现Crash，但也有例外，很常见）。 参考下面的这张图： 看看下面的代码，明显有问题，但是大部分时候是不会Crash的。 123UIView* testObj=[[UIView alloc] init];[testObj release];[testObj setNeedsLayout]; 但是这个放在用户那边或者不是UIView这个类就不好说了，Crash率可能飕飕就上去了！ 让随机变成不随机从上面列的情况来看，出现随机Crash的情况有很多种！这是得多蛋疼呢！或许最好的办法让他们全都立马Crash，然后把野指针都找出来！ 仔细看看上面的关键路径只有出现被随机填入的数据是不可访问的时候才会必现Crash。 这个地方我们可以做一下手脚，把这一随机的过程变成不随机的过程。对象释放后在内存上填上不可访问的数据，其实这种技术其实一直都有，xcode的Enable Scribble就是这个作用。 下面我们就拿刚刚的代码试一下。 1scheme=&gt;diagnostics=&gt;Enable Scribble 果然，必现了，0x5555561！！ 但是有个问题：这货不能放在测试同学那边用！因为总不能让测试同学装了xcode来测试吧？ 于是我们自己动手实现一个，这个过程中我们要解决几个问题： 怎么在内存释放后填上不可访问的数据？内存释放很可能不在我们的代码中。为此我们需要hook对象释放的接口，内存时候之后马上执行我们的破坏工作。 我们要重写对象释放的接口，重写哪个呢？NSObject的dealloc、runtime的 object_dispose，C的free应该都是可以，但是各有优点，我选择的是覆盖面最广的free，free是C的函数，重写了它之后还可以顺带解决一部分C的野指针问题。 怎么重写？重写C的接口场景的有两种： 替换系统动态库 hook 替换动态库太麻烦，还不知道行不行得通；hook我们就找现成的fishhook，github里面找的，但现成的代码需要防止代码冲突。 填充的不可访问的数据的长度怎么确定？获取内存长度的接口不在标准库中，好在在Mac和iOS中可以用malloc_size就可以。 填什么？和xcode一样，填0x55。 上hook后的free代码： 12345678910void safe_free(void* p)&#123; size_tmemSiziee=malloc_size(p); memset(p,0x55, memSiziee); orig_free(p); return;&#125; 测试一下，出现了和Enable Scribble一样的Crash！ 重复造了这个xcode的轮子之后，以后编包给测试，终于在某些情况下不需要那么拼人品了。但是这仅仅覆盖了众多野指针中的一部分，还有大量的疑问等着继续解答。比如： 由于内存已经被释放了，很可能我们的0x55又被别的数据覆盖，这种情况还是无能为力。 为什么我们的0x55555555变成了0x55555561。 如果释放后访问野指针的是系统代码，虽然提前发现了Crash，但是离解决问题还是很远。 如果野指针指向的数据没有被当成指针使用，还是可能不立即Crash。 参考如何定位Obj-C野指针随机Crash(一):先提高野指针Crash率","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"NSInvocation的基本使","date":"2018-12-11T07:35:49.000Z","path":"wiki/IOS/小码哥视频/ios_jalebroke/","text":"小码哥视频学习记录 第一天ssh 链接iphone手机12ssh root@ 10.144.32.27alpine ifunbox 第二天ssh 版本：SSH-2 查看SSH版本： 123cd /etc/sshlscat ssh_config or cat sshd_config SSH 通信过程： 建立安全链接 客户端认证(基于密码类型的、基于秘钥的认证（免密码，优先选择 ）) 数据传输 服务器公钥： 1/etc/ssh/ssh_host_rs_key.pub 重新生成秘钥 1ssh-keygen -R 10.144.36.206 自动拷贝公钥到服务器 12ssh-keygen ssh-copy-id 手动拷贝公钥到服务器 12scp ~/.ssh/id_rsa.pub root@10.144.36.206:~/.sshcat id_rsa.pub &gt;&gt; authorized_keys 22 端口 通过usb进行ssh链接 usbmuxd 端口映射python ~/Documents/ios/usbmuxd/tcprelay.py -t 22:10010ssh root@localhost -p 10010 sh bash 子进程中执行source 当前进程中执行 cycript 是C++、JavaScript、java 混合物， 调试某个APP cycript 命令进入cycript环境cycript -p 进程名称adv-cmds 执行ps命令 UIApp= [UIApplication sharedApplication] 定义变量 :var app = UIApp.keyWindow 1#地址 可以访问对象 1* 对象 访问对象的成员变量 1递归打印视图： view.recursiveDescription().toString() 1筛选某种类型的视图： choose(UITableViewCell) 第四天拆分胖二进制文件 12lipo test -thin -armv7 -o test_armv7lipo -crate test_armv7 test_arm64 -o test file命令查看文件格式 XNU源码中有loader.h文件，定义了文件的格式 otool命令 dyld 只能加载MH_EXECUTE、MH_DYLIB|MH_BUNFLE类型的Mach-O文件","tags":[{"name":"小码哥视频","slug":"小码哥视频","permalink":"http://yoursite.com/tags/小码哥视频/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"小码哥视频","slug":"IOS/小码哥视频","permalink":"http://yoursite.com/categories/IOS/小码哥视频/"}]},{"title":"18. @synchronized","date":"2018-12-06T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/18_syncsize/","text":"@synchronized 内幕揭秘 @synchronized揭秘123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; AXPerson * p = [AXPerson new]; @synchronized (p) &#123; NSLog(@\"p is @synchronized\"); &#125; &#125; return 0;&#125; 重写为C++： 12345678910111213141516171819int main(int argc, const char * argv[]) &#123; &#123; __AtAutoreleasePool __autoreleasepool; AXPerson * p = ((AXPerson *(*)(id, SEL))(void *)objc_msgSend)((id)objc_getClass(\"AXPerson\"), sel_registerName(\"new\")); &#123; id _sync_obj = (id)p; objc_sync_enter(_sync_obj); struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125; // 构造函数 ~_SYNC_EXIT() &#123; // 析构函数，析构的时候会自动释放锁 objc_sync_exit(sync_exit); &#125; id sync_exit; // 成员变量 &#125; _sync_exit(_sync_obj); NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_cp_sc2q63f937j88dcxp23f471w0000gn_T_main_3c34e3_mi_0); &#125; &#125; return 0;&#125; 下面一步步分析代码 12id _sync_obj = (id)p;objc_sync_enter(_sync_obj); 将上锁的对象p赋值给_sync_obj ， 调用objc_sync_enter函数，实参传递_sync_obj, objc_sync_enter函数就相当于上锁。后面详细分析 12345678struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125; // 构造函数 ~_SYNC_EXIT() &#123; // 析构函数，析构的时候会自动释放锁 objc_sync_exit(sync_exit); &#125; id sync_exit; // 成员变量&#125;_sync_exit(_sync_obj); 这不是一个单独的语句，注意看结构体的右大括号后面并没有分号，所以 _sync_exit(_sync_obj) 是跟在 _SYNC_EXIT 结构体后面的，即它声明了一个名为 _sync_exit 的结构体对象。 _sync_exit对象的的析构函数里面调用了objc_sync_exit函数。这个函数相当于解锁。 析构函数在_sync_exit释放的时候调用。也就是作用域结束的时候调用。 所以， @synchronized (p) 相当于 新建了一个作用域，在作用域开始的时候，调用objc_sync_enter函数，实参是p，作用域结束的时候，自动调用析构函数objc_sync_exit，解锁。 @synchronized数据结构@synchronized 相关的数据结构，安装存储的位置划分，有两种： 线程内部存储的数据。 全局数据，用来线程间共享。 后面会分析这两种数据的相互关系。 线程内部： 12345678910111213141516171819typedef struct SyncData &#123; // 同步数据结构体 struct SyncData* nextData; // 指向下一个 SyncData，看来是链表 DisguisedPtr&lt;objc_object&gt; object; // 锁住的对象 int32_t threadCount; // 使用这个block(???)的线程数 number of THREADS using this block recursive_mutex_t mutex; // 递归锁&#125; SyncData;typedef struct &#123; SyncData *data; unsigned int lockCount; // number of times THIS THREAD locked this block&#125; SyncCacheItem;typedef struct SyncCache &#123; unsigned int allocated; unsigned int used; SyncCacheItem list[0];&#125; SyncCache; 全局数据定义如下： 123456struct SyncList &#123; SyncData *data; spinlock_t lock; // 自旋锁 SyncList() : data(nil) &#123; &#125;&#125;; @synchronized源码分析@synchronized 相关的API有两个： 12int objc_sync_enter(id obj)int objc_sync_exit(id obj) objc_sync_enter12345678910111213141516171819int objc_sync_enter(id obj)&#123; int result = OBJC_SYNC_SUCCESS; // 用来记录结果，默认成功 if (obj) &#123; // obj 必须非空， SyncData* data = id2data(obj, ACQUIRE); // 为 obj 对象绑定一个递归锁 assert(data); data-&gt;mutex.lock(); // 递归锁加锁 &#125; else &#123; // 否则 @synchronized 啥也不干 // @synchronized(nil) does nothing if (DebugNilSync) &#123; _objc_inform(\"NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug\"); &#125; objc_sync_nil(); &#125; return result;&#125; 内部调用了id2data函数，取出所对象，上锁。 objc_sync_exit123456789101112131415161718192021int objc_sync_exit(id obj)&#123; int result = OBJC_SYNC_SUCCESS; if (obj) &#123; SyncData* data = id2data(obj, RELEASE); // 为 obj 解绑递归锁 if (!data) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; // 压根儿没有 objc_sync_enter 过 &#125; else &#123; bool okay = data-&gt;mutex.tryUnlock(); // 尝试解锁 if (!okay) &#123; result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR; // 解锁失败 &#125; &#125; &#125; else &#123; // @synchronized(nil) does nothing &#125; return result;&#125; 通过id2data取出锁对象，解锁。 所以关键锁对象建模都在id2data函数中。这个函数顾名思义，就是将id类型的对象转化为锁数据。 id2data123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112static SyncData* id2data(id object, enum usage why)&#123; spinlock_t *lockp = &amp;LOCK_FOR_OBJ(object); SyncData **listp = &amp;LIST_FOR_OBJ(object); SyncData* result = NULL; // Check per-thread cache of already-owned locks for matching object SyncCache *cache = fetch_cache(NO); if (cache) &#123; unsigned int i; for (i = 0; i &lt; cache-&gt;used; i++) &#123; SyncCacheItem *item = &amp;cache-&gt;list[i]; if (item-&gt;data-&gt;object != object) continue; // Found a match. result = item-&gt;data; if (result-&gt;threadCount &lt;= 0 || item-&gt;lockCount &lt;= 0) &#123; _objc_fatal(\"id2data cache is buggy\"); &#125; switch(why) &#123; case ACQUIRE: item-&gt;lockCount++; break; case RELEASE: item-&gt;lockCount--; if (item-&gt;lockCount == 0) &#123; // remove from per-thread cache cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used]; // atomic because may collide with concurrent ACQUIRE OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); &#125; break; case CHECK: // do nothing break; &#125; return result; &#125; &#125; // Thread cache didn't find anything. // Walk in-use list looking for matching object // Spinlock prevents multiple threads from creating multiple // locks for the same new object. // We could keep the nodes in some hash table if we find that there are // more than 20 or so distinct locks active, but we don't do that now. lockp-&gt;lock(); &#123; SyncData* p; SyncData* firstUnused = NULL; for (p = *listp; p != NULL; p = p-&gt;nextData) &#123; if ( p-&gt;object == object ) &#123; result = p; // atomic because may collide with concurrent RELEASE OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount); goto done; &#125; if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) ) firstUnused = p; &#125; // no SyncData currently associated with object if ( (why == RELEASE) || (why == CHECK) ) goto done; // an unused one was found, use it if ( firstUnused != NULL ) &#123; result = firstUnused; result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; goto done; &#125; &#125; // malloc a new SyncData and add to list. // XXX calling malloc with a global lock held is bad practice, // might be worth releasing the lock, mallocing, and searching again. // But since we never free these guys we won't be stuck in malloc very often. result = (SyncData*)calloc(sizeof(SyncData), 1); result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; new (&amp;result-&gt;mutex) recursive_mutex_t(); result-&gt;nextData = *listp; *listp = result; done: lockp-&gt;unlock(); if (result) &#123; // Only new ACQUIRE should get here. // All RELEASE and CHECK and recursive ACQUIRE are // handled by the per-thread caches above. if (why == RELEASE) &#123; // Probably some thread is incorrectly exiting // while the object is held by another thread. return nil; &#125; if (why != ACQUIRE) _objc_fatal(\"id2data is buggy\"); if (result-&gt;object != object) _objc_fatal(\"id2data is buggy\"); &#123; // Save in thread cache if (!cache) cache = fetch_cache(YES); cache-&gt;list[cache-&gt;used].data = result; cache-&gt;list[cache-&gt;used].lockCount = 1; cache-&gt;used++; &#125; &#125; return result;&#125; 123#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock#define LIST_FOR_OBJ(obj) sDataLists[obj].datastatic StripedMap&lt;SyncList&gt; sDataLists; 整个代码可以分为2种情况： 当前线程的TLS已经有对象object的数据 ：直接对锁的次数lockCount累加. 当前的线程里面没有，说明object在这个线程第一次上锁，那么也分两种情况，一种情况是：这个对象在所有线程中第一次上锁，那么，新建锁对象数据SyncData，然后将线程数threadCount赋值为1. 数据另一种情况是，这个对象在其他的线程中上过锁，那么从全局数据sDataLists中取出锁数据listp，将线程数累加。 因为这两种情况都是第一次进入这个线程，所以，执行完上面的操作，需要将锁数据result添加到线程TLS中。 下面放置了一张图，方便理解 。图的上面是全局数据结构，是个链表，因为全局的数据比较多。所以使用高效的链表作为基本数据结构。中间是线程内部的数据结构，对于某个线程，锁没有全局的多，所以使用简单的数据结构数组。下面部分是这段代码的基本逻辑。 拆分理解三种情况： 12345678910111213141516171819202122232425262728293031323334 SyncCache *cache = fetch_cache(NO);if (cache) &#123; unsigned int i; for (i = 0; i &lt; cache-&gt;used; i++) &#123; SyncCacheItem *item = &amp;cache-&gt;list[i]; if (item-&gt;data-&gt;object != object) continue; // Found a match. result = item-&gt;data; if (result-&gt;threadCount &lt;= 0 || item-&gt;lockCount &lt;= 0) &#123; _objc_fatal(\"id2data cache is buggy\"); &#125; switch(why) &#123; case ACQUIRE: item-&gt;lockCount++; break; case RELEASE: item-&gt;lockCount--; if (item-&gt;lockCount == 0) &#123; // remove from per-thread cache cache-&gt;list[i] = cache-&gt;list[--cache-&gt;used]; // atomic because may collide with concurrent ACQUIRE OSAtomicDecrement32Barrier(&amp;result-&gt;threadCount); &#125; break; case CHECK: // do nothing break; &#125; return result; &#125;&#125; 上面的代码是第一种情况，上锁情况累加lockCount，解锁情况递减lockCount。如果lockCount为0 ，清楚数据。如果符合这种情况，就直接返回了。 下面的代码都属于第二种情况。 123456789101112SyncData* p;SyncData* firstUnused = NULL;for (p = *listp; p != NULL; p = p-&gt;nextData) &#123; if ( p-&gt;object == object ) &#123; result = p; // atomic because may collide with concurrent RELEASE OSAtomicIncrement32Barrier(&amp;result-&gt;threadCount); goto done; &#125; if ( (firstUnused == NULL) &amp;&amp; (p-&gt;threadCount == 0) ) firstUnused = p;&#125; 这个代码是对象的锁数据在全局数据中找到了。直接递增threadCount。 1234567 // an unused one was found, use itif ( firstUnused != NULL ) &#123; result = firstUnused; result-&gt;object = (objc_object *)object; result-&gt;threadCount = 1; goto done;&#125; 这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，但是在全局数据中找到了空的result，直接赋值threadCount为1。 123456result = (SyncData*)calloc(sizeof(SyncData), 1);result-&gt;object = (objc_object *)object;result-&gt;threadCount = 1;new (&amp;result-&gt;mutex) recursive_mutex_t();result-&gt;nextData = *listp;*listp = result; 这种情况是对象在全局数据中没有找到对应的锁数据，也就是第一对对象加锁，并且在全局数据中没有找到空的SyncData。直接创建，添加到链表中。 1234if (!cache) cache = fetch_cache(YES);cache-&gt;list[cache-&gt;used].data = result;cache-&gt;list[cache-&gt;used].lockCount = 1;cache-&gt;used++; 这段代码是第二种情况的最后一步，以为第二种情况都是第一次进入改线程，所以需要将创建或者以后的锁数据result添加到线程数据TLS中。 总结@synchronized 就是在作用开始的时候，调用objc_sync_enter 函数，用对象创建出了锁数据SyncData，并上锁 。 当作用域结束的时候，调用objc_sync_exit 解锁，使用的锁是递归锁，在同一个线程中可以重入。所以，对同一个对象嵌套使用@synchronized，不会死锁。","tags":[{"name":"synchronized","slug":"synchronized","permalink":"http://yoursite.com/tags/synchronized/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"17. weak 相关源码分析","date":"2018-12-04T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/17_weak/","text":"weak相关源码分析 __weak探究程序中添加了一个__weak变量，查看调用堆栈，看到下一个调用的是objc_initWeak函数。 所以我们就objc_initWeak函数作为入口，探究weak。 数据结构首先了解以下的变量，这些变量在这章的数据结构、函数形参中使用： 1234__weak id weakPtr = olocation newObjrefferer reffenent引用着 被引用者 StripedMap下面从SideTables() 函数为入口，了解weak相关的数据结构。 123static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; 这个函数返回StripedMap 结构，StripedMap 是一个模板类，函数体内将SideTableBuf强制转换为StripedMap&lt;SideTable&gt;*： StripedMap 定义如下： 12345678template&lt;typename T&gt;class StripedMap &#123; struct PaddedT &#123; T value alignas(64); &#125;; PaddedT array[64];&#125;; 上面代码是StripedMap的简化定义，StripedMap是个模板类，根据模板参数T生成实例类，我们给模板参数传递的实参是SideTable，StripedMap内部只定义了一个数据成员PaddedT array[64]，PaddedT就是64位对齐后的SideTable。 进一步简化： 1SideTable array[64]; 所以StripedMap就是SideTable型的数组，数组有64个成员。 SideTable的结构如下： 1234struct SideTable &#123; spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; 可以看出SideTable的大小是62，64位对齐后是64。其中weak_talbe存储着weak相关的内容。其他的两个成员refcnts、slock不在本文的研究范围内。 所以数组SideTable array[64] 中元素的大小就是64。整个array 共占用64*64=4096字节。回到没有简化前的版本，StripedMap&lt;SideTable&gt;本质是一个数组，数组的元素是模板参数类型 —SideTable。大小为64。 函数SideTables()是将SideTableBuf转化为StripedMap&lt;SideTable&gt;的。所以下面了解SideTableBuf的定义。 SideTableBufSideTableBuf的定义： 12alignas(StripedMap&lt;SideTable&gt;) static uint8_t SideTableBuf[sizeof(StripedMap&lt;SideTable&gt;)]; 前面的alignas(StripedMap)是对齐的。sizeof(StripedMap&lt;SideTable&gt;)根据上面分析是4096，所以上面的代码简化为： 1static uint8_t SideTableBuf[4096]; 所以SideTableBuf 就是一个包含 4096个uint8_t的数组 。 所以,函数SideTables() 就相当将uint8_t SideTableBuf[4096] 重新解释为SideTable array[64]。 123static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125; weak_table_t1234567// 全局的弱引用表struct weak_table_t &#123; weak_entry_t *weak_entries; size_t num_entries; // 实体的数量 uintptr_t mask; uintptr_t max_hash_displacement;&#125;; weak_entries一个数组，数组每个元素是 weak_entry_t 结构体，一个weak_entry_t结构存储了一个reffenent，以及指向reffenent的弱引用者们。 num_entries 是实体（weak_entry_t）的数量 mask是容量减1. weak_entry_t12345678910111213141516struct weak_entry_t &#123; DisguisedPtr&lt;objc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; // 变量名是 out_of_line ，占 1 个 bit uintptr_t num_refs : PTR_MINUS_1; // 数组中有几个元素，即 referent 有几个弱引用 uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;;&#125;; 这个结构看着比较复杂： referent存储被弱引用的对象。 第二个成员是一个union，存储若引用者（refferer）。如果referent的弱引用者小于四个，也就是out_of_line为0时，弱引用者就存储在inline_referrers数组中。 否则，就存储在referrers中，这是out_of_line 为1，referrers是个二级指针，里面存的是指向referent 的对象们的地址。num_refs 是弱引用着的个数。mask是容量减1。 小结上面分析了weak相关的结构，现在花一张总图： 上面是详细的数据结构，比较复杂，下面列出我认为核心的结构，核心结构就是三级hash表。 函数接口123id objc_storeWeakOrNil(id *location, id newObj);id objc_initWeak(id *location, id newObj);void objc_destroyWeak(id *location); 下面章节的代码只是简化的代码，为了方便理解，可能缺失部分细节。 objc_initWeak1234567891011idobjc_initWeak(id *location, id newObj)&#123; if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125; objc_initWeak内部只调用了storeWeak函数。 objc_storeWeak123456789idobjc_storeWeak(id *location, id newObj)&#123; return storeWeak&lt;true/*old*/, true/*new*/, true/*crash*/&gt; (location, (objc_object *)newObj);&#125; objc_destroyWeak12345objc_destroyWeak(id *location)&#123; (void)storeWeak&lt;true/*old*/, false/*new*/, false/*crash*/&gt; (location, nil);&#125; 可以看出objc_initWeak 、 objc_storeWeak 、objc_destroyWeak 的关键内容都是调用storeWeak函数，只是模板参数传递的不一样。 storeWeak下面讲解storeWeak函数，下面只关注添加的过程。删除的过程没有关注。 12345678910111213141516171819202122232425262728template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj)&#123; assert(haveOld || haveNew); if (!haveNew) assert(newObj == nil); Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // Assign new value, if any. if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); &#125; return (id)newObj;&#125; 12345if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; 就是根据newObj 找到存储newObj的地址对应的SideTable。 123456789static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#125;public: T&amp; operator[] (const void *p) &#123; return array[indexForPointer(p)].value; &#125; StripedMap重载了[] 操作符，内部调用了indexForPointer ，indexForPointer就是将对象的地址做某些操作，相当于hash。然后将hash的结果和64取余，得到0~63的值，这个值就可以当做数组的索引使用。 storeWeak函数接着调用了 weak_register_no_lock函数： 123456789101112131415161718192021222324252627282930313233id weak_register_no_lock(weak_table_t *weak_table, id referent_id, id *referrer_id, bool crashIfDeallocating)&#123; objc_object *referent = (objc_object *)referent_id; objc_object **referrer = (objc_object **)referrer_id; weak_entry_t *entry; // now remember it and where it is being stored weak_entry_t *entry; // 找到 referent 所在的 entry if ((entry = weak_entry_for_referent(weak_table, referent))) &#123; // 将 referrer 添加进这个 entry 中，这样 referrer 就成为 referent 的弱引用之一了 append_referrer(entry, referrer); &#125; // 如果没有找到对应的 entry ，那么说明 referent 还没有弱引用，就为其新建一个 entry else &#123; weak_entry_t new_entry; new_entry.referent = referent; new_entry.out_of_line = 0; new_entry.inline_referrers[0] = referrer; // 数组中 4 个referrer全部初始化为 nil for (size_t i = 1; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_entry.inline_referrers[i] = nil; &#125; // 检查一下需不需要扩容 weak_grow_maybe(weak_table); // 将新建的 entry 插入 weak table 中 weak_entry_insert(weak_table, &amp;new_entry); &#125; return referent_id;&#125; 这个函数的功能就是讲referrer_id 插入到正确的位置，分为两种情况： 如果根据referent_id可以找到一个weak_entry_t类型的实体entry ，就调用将append_referrer 将referrer_id插入到entry（相当于三级hash表）中。 如果没有，就需要新建一个weak_entry_t类型的实体new_entry。然后调用weak_entry_insert将new_entry插入到二级hash表中。 123456789101112131415161718192021222324252627static weak_entry_t *weak_entry_for_referent(weak_table_t *weak_table, objc_object *referent)&#123; // 不能是 nil assert(referent); // weak_table 中存的实体数组 weak_entry_t *weak_entries = weak_table-&gt;weak_entries; if (!weak_entries) &#123; return nil; &#125; // 通过 Hash 的方法找到 referent 所在的索引，不过实在看不懂 size_t index = hash_pointer(referent) &amp; weak_table-&gt;mask; size_t hash_displacement = 0; while (weak_table-&gt;weak_entries[index].referent != referent) &#123; index = (index+1) &amp; weak_table-&gt;mask; hash_displacement++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123; return nil; &#125; &#125; // 返回找到的 weak_entry_t，这里可以证明 weak_entries 确实是一个数组 return &amp;weak_table-&gt;weak_entries[index];&#125; weak_entry_for_referent 根据给的的referent 在weak_table-&gt;weak_entries中遍历，是否有相同的，如果相同就返回对应的weak_entry_t类型的实体，如果没有nil。 hash_pointer 就是对对象referent的地址做个hash，然后和weak_table-&gt;mask 做与操作，返回的结果小于weak_table-&gt;mask，当做数组的索引。 hash_displacement记录的就是最佳位置和实际存储位置的便宜距离。 1234567891011121314151617181920212223static void weak_entry_insert(weak_table_t *weak_table, weak_entry_t *new_entry)&#123; weak_entry_t *weak_entries = weak_table-&gt;weak_entries; assert(weak_entries != nil); // 通过 hash 决定 索引 size_t index = hash_pointer(new_entry-&gt;referent) &amp; (weak_table-&gt;mask); size_t hash_displacement = 0; // 如果该索引中已经有 entry，那么这个索引就不能用了，就找下一个索引 while (weak_entries[index].referent != nil) &#123; index = (index+1) &amp; weak_table-&gt;mask; hash_displacement++; &#125; // 将 new_entry 放入指定的索引中 weak_entries[index] = *new_entry; weak_table-&gt;num_entries++; if (hash_displacement &gt; weak_table-&gt;max_hash_displacement) &#123; weak_table-&gt;max_hash_displacement = hash_displacement; &#125;&#125; weak_entry_insert 就是在二级hash表中插入一个新的实体new_entry。通过hash_pointer找到一个最佳位置index，如果最佳位置已经有内容了，就接着查找下一个位置，直到找到空位置。记录下index。在index处插入new_entry。同时将num_entries累加1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void append_referrer(weak_entry_t *entry, objc_object **new_referrer)&#123; // out_of_line == 0 的情况 if (! entry-&gt;out_of_line) &#123; // Try to insert inline. // inline_referrers 还放得下，就放在 inline_referrers 里 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125; &#125; weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中 for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i]; &#125; entry-&gt;referrers = new_referrers; entry-&gt;num_refs = WEAK_INLINE_COUNT; entry-&gt;out_of_line = 1; entry-&gt;mask = WEAK_INLINE_COUNT-1; entry-&gt;max_hash_displacement = 0; &#125; assert(entry-&gt;out_of_line); if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer); &#125; size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask); size_t hash_displacement = 0; // 找到可以存放 new_referrer 的索引位置 while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++; &#125; if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement; &#125; // 将 index 处的对象替换成 new_referrer weak_referrer_t &amp;ref = entry-&gt;referrers[index]; ref = new_referrer; // 总数加一 entry-&gt;num_refs++;&#125; append_referrer 是在三级hash表entry中出入一个新的弱引用着new_referrer。 分为三种情况： 如果inline_referrers没有存储满，直接存储到inline_referrers中 如果inline_referrers个数是4个了，在插入，就需要将inline_referrers拷贝到referrers，然后进入第三步。 如果inline_referrers存储满了，判断是否需要扩容，然后将数据存储到referrers中。 存储到inline_referrers的代码是： 123456for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; if (entry-&gt;inline_referrers[i] == nil) &#123; entry-&gt;inline_referrers[i] = new_referrer; return; &#125;&#125; 存储完成后，直接返回了，所以后面的代码就是存储在referrers的情况。 12345678910111213weak_referrer_t *new_referrers = (weak_referrer_t *) calloc(WEAK_INLINE_COUNT, sizeof(weak_referrer_t)); // 将 inline_referrers 存的 4 个对象拷贝到 new_referrers 中for (size_t i = 0; i &lt; WEAK_INLINE_COUNT; i++) &#123; new_referrers[i] = entry-&gt;inline_referrers[i];&#125;entry-&gt;referrers = new_referrers;entry-&gt;num_refs = WEAK_INLINE_COUNT;entry-&gt;out_of_line = 1;entry-&gt;mask = WEAK_INLINE_COUNT-1;entry-&gt;max_hash_displacement = 0; 这段代码的功能是inline_referrers正好4个，如果再次添加，肯定放不下了，所以将inline_referrers中的数据移到referrers中。 123if (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * 3/4) &#123; return grow_refs_and_insert(entry, new_referrer);&#125; 如果使用超过 3/4，就先扩容，然后再插入。 123456789101112131415size_t index = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);size_t hash_displacement = 0;// 找到可以存放 new_referrer 的索引位置while (entry-&gt;referrers[index] != NULL) &#123; index = (index+1) &amp; entry-&gt;mask; hash_displacement++;&#125;if (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123; entry-&gt;max_hash_displacement = hash_displacement;&#125;// 将 index 处的对象替换成 new_referrerweak_referrer_t &amp;ref = entry-&gt;referrers[index];ref = new_referrer;// 总数加一entry-&gt;num_refs++; 上面的代码是通过弱引用着new_referrer找到index。然后从index开始，寻址空位置，将new_referrer插入到entry-&gt;referrers[index]位置处。同时将entry-&gt;num_refs累加 总结weak即使一个三级hash表。 第一级用来提高效率的，可以想象，很多多选，放到一个hash表中，降低了效率。所有将多有的对象散列到64个表中。 二级缓存存储被弱引用的对象。 三级缓存存储某个对象的所有的弱引用着。","tags":[{"name":"retain 和 release","slug":"retain-和-release","permalink":"http://yoursite.com/tags/retain-和-release/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"16. retain 和 release（转载)","date":"2018-12-04T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/16_retain_release/","text":"在接口设计时，我们经常要考虑某些意义上的平衡。在内存管理中也是这样，Objective-C 同时为我们提供了增加引用计数的 retain 和减少引用计数的 release 方法。 这篇文章会在源代码层面介绍 Objective-C 中 retain 和 release 的实现，它们是如何达到平衡的。 从 retain 开始如今我们已经进入了全面使用 ARC 的时代，几年前还经常使用的 retain 和 release 方法已经很难出现于我们的视野中了，绝大多数内存管理的实现细节都由编译器代劳。 在这里，我们还要从 retain 方法开始，对内存管理的实现细节一探究竟。 下面是 retain 方法的调用栈： 12345678910- [NSObject retain]└── id objc_object::rootRetain() └── id objc_object::rootRetain(bool tryRetain, bool handleOverflow) ├── uintptr_t LoadExclusive(uintptr_t *src) ├── uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout) ├── uintptr_t bits │ └── uintptr_t has_sidetable_rc ├── bool StoreExclusive(uintptr_t *dst, uintptr_t oldvalue, uintptr_t value) └── bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc) └── uintptr_t addc(uintptr_t lhs, uintptr_t rhs, uintptr_t carryin, uintptr_t *carryout) 调用栈中的前两个方法的实现直接调用了下一个方法： 1234567- (id)retain &#123; return ((id)self)-&gt;rootRetain();&#125;id objc_object::rootRetain() &#123; return rootRetain(false, false);&#125; 而 id objc_object::rootRetain(bool tryRetain, bool handleOverflow) 方法是调用栈中最重要的方法，其原理就是将 isa 结构体中的 extra_rc 的值加一。 extra_rc 就是用于保存自动引用计数的标志位，下面就是 isa 结构体中的结构： 接下来我们会分三种情况对 rootRetain 进行分析。 正常的 rootRetain这是简化后的 rootRetain 方法的实现，其中只有处理一般情况的代码： 1234567891011121314id objc_object::rootRetain(bool tryRetain, bool handleOverflow) &#123; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); &#125; while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); return (id)this;&#125; 在这里我们假设的条件是 isa 中的 extra_rc 的位数足以存储 retainCount。 使用 LoadExclusive 加载 isa 的值 调用 addc(newisa.bits, RC_ONE, 0, &amp;carry) 方法将 isa 的值加一 调用 StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits) 更新 isa 的值 返回当前对象 有进位版本的 rootRetain在这里调用 addc 方法为 extra_rc 加一时，8 位的 extra_rc 可能不足以保存引用计数。 1234567891011id objc_object::rootRetain(bool tryRetain, bool handleOverflow) &#123; transcribeToSideTable = false; isa_t oldisa = LoadExclusive(&amp;isa.bits); isa_t newisa = oldisa; uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry &amp;&amp; !handleOverflow) return rootRetain_overflow(tryRetain);&#125; extra_rc 不足以保存引用计数，并且 handleOverflow = false。 当方法传入的 handleOverflow = false 时（这也是通常情况），我们会调用 rootRetain_overflow 方法： 123id objc_object::rootRetain_overflow(bool tryRetain) &#123; return rootRetain(tryRetain, true);&#125; 这个方法其实就是重新执行 rootRetain 方法，并传入 handleOverflow = true。 有进位版本的 rootRetain（处理溢出）当传入的 handleOverflow = true 时，我们就会在 rootRetain 方法中处理引用计数的溢出。 12345678910111213141516171819202122id objc_object::rootRetain(bool tryRetain, bool handleOverflow) &#123; bool sideTableLocked = false; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; uintptr_t carry; newisa.bits = addc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry) &#123; newisa.extra_rc = RC_HALF; newisa.has_sidetable_rc = true; &#125; &#125; while (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); sidetable_addExtraRC_nolock(RC_HALF); return (id)this;&#125; 当调用这个方法，并且 handleOverflow = true 时，我们就可以确定 carry 一定是存在的了， 因为 extra_rc 已经溢出了，所以要更新它的值为 RC_HALF： 1#define RC_HALF (1ULL&lt;&lt;7) extra_rc 总共为 8 位，RC_HALF = 0b10000000。 然后设置 has_sidetable_rc 为真，存储新的 isa 的值之后，调用 sidetable_addExtraRC_nolock 方法。 12345678910111213141516171819bool objc_object::sidetable_addExtraRC_nolock(size_t delta_rc) &#123; SideTable&amp; table = SideTables()[this]; size_t&amp; refcntStorage = table.refcnts[this]; size_t oldRefcnt = refcntStorage; if (oldRefcnt &amp; SIDE_TABLE_RC_PINNED) return true; uintptr_t carry; size_t newRefcnt = addc(oldRefcnt, delta_rc &lt;&lt; SIDE_TABLE_RC_SHIFT, 0, &amp;carry); if (carry) &#123; refcntStorage = SIDE_TABLE_RC_PINNED | (oldRefcnt &amp; SIDE_TABLE_FLAG_MASK); return true; &#125; else &#123; refcntStorage = newRefcnt; return false; &#125;&#125; 这里我们将溢出的一位 RC_HALF 添加到 oldRefcnt 中，其中的各种 SIDE_TABLE 宏定义如下： 1234567#define SIDE_TABLE_WEAKLY_REFERENCED (1UL&lt;&lt;0)#define SIDE_TABLE_DEALLOCATING (1UL&lt;&lt;1)#define SIDE_TABLE_RC_ONE (1UL&lt;&lt;2)#define SIDE_TABLE_RC_PINNED (1UL&lt;&lt;(WORD_BITS-1))#define SIDE_TABLE_RC_SHIFT 2#define SIDE_TABLE_FLAG_MASK (SIDE_TABLE_RC_ONE-1) 因为 refcnts 中的 64 为的最低两位是有意义的标志位，所以在使用 addc 时要将 delta_rc 左移两位，获得一个新的引用计数 newRefcnt。 如果这时出现了溢出，那么就会撤销这次的行为。否则，会将新的引用计数存储到 refcntStorage 指针中。 也就是说，在 iOS 的内存管理中，我们使用了 isa 结构体中的 extra_rc 和 SideTable 来存储某个对象的自动引用计数。 更重要的是，如果自动引用计数为 1，extra_rc 实际上为 0，因为它保存的是额外的引用计数，我们通过这个行为能够减少很多不必要的函数调用。 到目前为止，我们已经从头梳理了 retain 方法的调用栈及其实现。下面要介绍的是在内存管理中，我们是如何使用 release 方法平衡这个方法的。 以 release 结束与 release 方法相似，我们看一下这个方法简化后的调用栈： 123- [NSObject release]└── id objc_object::rootRelease() └── id objc_object::rootRetain(bool performDealloc, bool handleUnderflow) 前面的两个方法的实现和 retain 中的相差无几，这里就直接跳过了。 同样，在分析 release 方法时，我们也根据上下文的不同，将 release 方法的实现拆分为三部分，说明它到底是如何调用的。 正常的 release这一个版本的方法调用可以说是最简版本的方法调用了： 1234567891011121314bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) &#123; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; uintptr_t carry; newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); &#125; while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); return false;&#125; 使用 LoadExclusive 获取 isa 内容 将 isa 中的引用计数减一 调用 StoreReleaseExclusive 方法保存新的 isa 从 SideTable 借位接下来，我们就要看两种相对比较复杂的情况了，首先是从 SideTable 借位的版本： 123456789101112131415161718192021222324252627282930313233bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) &#123; isa_t oldisa; isa_t newisa; do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; uintptr_t carry; newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry) goto underflow; &#125; while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); ... underflow: newisa = oldisa; if (newisa.has_sidetable_rc) &#123; if (!handleUnderflow) &#123; return rootRelease_underflow(performDealloc); &#125; size_t borrowed = sidetable_subExtraRC_nolock(RC_HALF); if (borrowed &gt; 0) &#123; newisa.extra_rc = borrowed - 1; bool stored = StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits); return false; &#125; &#125;&#125; 这里省去了使用锁来防止竞争条件以及调用 StoreExclusive 失败后恢复现场的代码。我们会默认这里存在 SideTable，也就是 has_sidetable_rc = true。 你可以看到，这里也有一个 handleUnderflow，与 retain 中的相同，如果发生了 underflow，会重新调用该 rootRelease 方法，并传入 handleUnderflow = true。 在调用 sidetable_subExtraRC_nolock 成功借位之后，我们会重新设置 newisa 的值 newisa.extra_rc = borrowed - 1 并更新 isa。 release 中调用 dealloc如果在 SideTable 中也没有获取到借位的话，就说明没有任何的变量引用了当前对象（即 retainCount = 0），就需要向它发送 dealloc 消息了。 123456789101112131415161718192021222324252627282930bool objc_object::rootRelease(bool performDealloc, bool handleUnderflow) &#123; isa_t oldisa; isa_t newisa; retry: do &#123; oldisa = LoadExclusive(&amp;isa.bits); newisa = oldisa; uintptr_t carry; newisa.bits = subc(newisa.bits, RC_ONE, 0, &amp;carry); if (carry) goto underflow; &#125; while (!StoreReleaseExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)); ... underflow: newisa = oldisa; if (newisa.deallocating) &#123; return overrelease_error(); &#125; newisa.deallocating = true; StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits); if (performDealloc) &#123; ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc); &#125; return true;&#125; 上述代码会直接调用 objc_msgSend 向当前对象发送 dealloc 消息。 不过为了确保消息只会发送一次，我们使用 deallocating 标记位。 获取自动引用计数在文章的最结尾，笔者想要介绍一下 retainCount 的值是怎么计算的，我们直接来看 retainCount 方法的实现： 123456789101112- (NSUInteger)retainCount &#123; return ((id)self)-&gt;rootRetainCount();&#125;inline uintptr_t objc_object::rootRetainCount() &#123; isa_t bits = LoadExclusive(&amp;isa.bits); uintptr_t rc = 1 + bits.extra_rc; if (bits.has_sidetable_rc) &#123; rc += sidetable_getExtraRC_nolock(); &#125; return rc;&#125; 根据方法的实现，retainCount 有三部分组成： 1 extra_rc 中存储的值 sidetable_getExtraRC_nolock 返回的值 这也就证明了我们之前得到的结论。 小结我们在这篇文章中已经介绍了 retain 和 release 这一对用于内存管理的方法是如何实现的，这里总结一下文章一下比较重要的问题。 extra_rc 只会保存额外的自动引用计数，对象实际的引用计数会在这个基础上 +1 Objective-C 使用 isa 中的 extra_rc 和 SideTable 来存储对象的引用计数 在对象的引用计数归零时，会调用 dealloc 方法回收对象 有关于自动释放池实现的介绍，可以看自动释放池的前世今生。 Follow: Draveness · Github","tags":[{"name":"retain 和 release","slug":"retain-和-release","permalink":"http://yoursite.com/tags/retain-和-release/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"15. 自动释放池的前世今生（转载)","date":"2018-12-03T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/15_autoreleasepool/","text":"由于 Objective-C 中的内存管理是一个比较大的话题，所以会分为两篇文章来对内存管理中的一些机制进行剖析，一部分分析自动释放池以及 autorelease 方法，另一部分分析 retain、release 方法的实现以及自动引用计数。 写在前面这篇文章会在源代码层面介绍 Objective-C 中自动释放池，以及方法的 autorelease 的具体实现。 从 main 函数开始main 函数可以说是在整个 iOS 开发中非常不起眼的一个函数，它很好地隐藏在 Supporting Files 文件夹中，却是整个 iOS 应用的入口。 main.m 文件中的内容是这样的： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 在这个 @autoreleasepool block 中只包含了一行代码，这行代码将所有的事件、消息全部交给了 UIApplication 来处理，但是这不是本文关注的重点。 需要注意的是：整个 iOS 的应用都是包含在一个自动释放池 block 中的。 @autoreleasepool@autoreleasepool 到底是什么？我们在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件： 1$ clang -rewrite-objc main.m 在生成了一大堆警告之后，当前目录下多了一个 main.cpp 文件 这里删除了 main 函数中其他无用的代码。 在这个文件中，有一个非常奇怪的 __AtAutoreleasePool 的结构体，前面的注释写到 /* @autoreleasepool */。也就是说 @autoreleasepool {} 被转换为一个 __AtAutoreleasePool 结构体： 123&#123; __AtAutoreleasePool __autoreleasepool;&#125; 想要弄清楚这行代码的意义，我们要在 main.cpp 中查找名为 __AtAutoreleasePool 的结构体： 12345struct __AtAutoreleasePool &#123; __AtAutoreleasePool() &#123;atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasePool() &#123;objc_autoreleasePoolPop(atautoreleasepoolobj);&#125; void * atautoreleasepoolobj;&#125;; 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 这表明，我们的 main 函数在实际工作时其实是这样的： 12345678910int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; @autoreleasepool 只是帮助我们少写了这两行代码而已，让代码看起来更美观，然后要根据上述两个方法来分析自动释放池的实现。 AutoreleasePool 是什么这一节开始分析方法 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现： 1234567void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 上面的方法看上去是对 AutoreleasePoolPage 对应静态方法 push 和 pop 的封装。 这一小节会按照下面的顺序逐步解析代码中的内容： AutoreleasePoolPage 的结构 objc_autoreleasePoolPush 方法 objc_autoreleasePoolPop 方法 AutoreleasePoolPage 的结构AutoreleasePoolPage 是一个 C++ 中的类： 它在 NSObject.mm 中的定义是这样的： 123456789class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;; magic 用于对当前 AutoreleasePoolPage 完整性的校验 thread 保存了当前页所在的线程 每一个自动释放池都是由一系列的 AutoreleasePoolPage 组成的，并且每一个 AutoreleasePoolPage 的大小都是 4096 字节（16 进制 0x1000） 12#define I386_PGBYTES 4096#define PAGE_SIZE I386_PGBYTES 双向链表自动释放池中的 AutoreleasePoolPage 是以双向链表的形式连接起来的： parent 和 child 就是用来构造双向链表的指针。 自动释放池中的栈如果我们的一个 AutoreleasePoolPage 被初始化在内存的 0x100816000 ~ 0x100817000 中，它在内存中的结构如下： 其中有 56 bit 用于存储 AutoreleasePoolPage 的成员变量，剩下的 0x100816038 ~ 0x100817000 都是用来存储加入到自动释放池中的对象。 begin() 和 end() 这两个类的实例方法帮助我们快速获取 0x100816038 ~ 0x100817000 这一范围的边界地址。 next 指向了下一个为空的内存地址，如果 next 指向的地址加入一个 object，它就会如下图所示移动到下一个为空的内存地址中： 关于 hiwat 和 depth 在文章中并不会进行介绍，因为它们并不影响整个自动释放池的实现，也不在关键方法的调用栈中。 POOL_SENTINEL（哨兵对象）到了这里，你可能想要知道 POOL_SENTINEL 到底是什么，还有它为什么在栈中。 首先回答第一个问题： POOL_SENTINEL 只是 nil 的别名。 1#define POOL_SENTINEL nil 在每个自动释放池初始化调用 objc_autoreleasePoolPush 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL 哨兵对象。 12345678910int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 上面的 atautoreleasepoolobj 就是一个 POOL_SENTINEL。 而当方法 objc_autoreleasePoolPop 调用时，就会向自动释放池中的对象发送 release 消息，直到第一个 POOL_SENTINEL： objc_autoreleasePoolPush 方法了解了 POOL_SENTINEL，我们来重新回顾一下 objc_autoreleasePoolPush 方法： 123void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125; 它调用 AutoreleasePoolPage 的类方法 push，也非常简单： 123static inline void *push() &#123; return autoreleaseFast(POOL_SENTINEL);&#125; 在这里会进入一个比较关键的方法 autoreleaseFast，并传入哨兵对象 POOL_SENTINEL： 1234567891011static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法分三种情况选择不同的代码执行： 有 hotPage 并且当前 page 不满 调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 有 hotPage 并且当前 page 已满 调用 autoreleaseFullPage 初始化一个新的页 调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 无 hotPage 调用 autoreleaseNoPage 创建一个 hotPage 调用 page-&gt;add(obj) 方法将对象添加至 AutoreleasePoolPage 的栈中 最后的都会调用 page-&gt;add(obj) 将对象添加到自动释放池中。 hotPage 可以理解为当前正在使用的 AutoreleasePoolPage。 page-&gt;add 添加对象id *add(id obj) 将对象添加到自动释放池页中： 123456id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125; 笔者对这个方法进行了处理，更方便理解。 这个方法其实就是一个压栈的操作，将对象加入 AutoreleasePoolPage 然后移动栈顶的指针。 autoreleaseFullPage（当前 hotPage 已满）autoreleaseFullPage 会在当前的 hotPage 已满的时候调用： 123456789static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) &#123; do &#123; if (page-&gt;child) page = page-&gt;child; else page = new AutoreleasePoolPage(page); &#125; while (page-&gt;full()); setHotPage(page); return page-&gt;add(obj);&#125; 它会从传入的 page 开始遍历整个双向链表，直到： 查找到一个未满的 AutoreleasePoolPage 使用构造器传入 parent 创建一个新的 AutoreleasePoolPage 在查找到一个可以使用的 AutoreleasePoolPage 之后，会将该页面标记成 hotPage，然后调动上面分析过的 page-&gt;add 方法添加对象。 autoreleaseNoPage（没有 hotPage)如果当前内存中不存在 hotPage，就会调用 autoreleaseNoPage 方法初始化一个 AutoreleasePoolPage： 12345678910static id *autoreleaseNoPage(id obj) &#123; AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); if (obj != POOL_SENTINEL) &#123; page-&gt;add(POOL_SENTINEL); &#125; return page-&gt;add(obj);&#125; 既然当前内存中不存在 AutoreleasePoolPage，就要从头开始构建这个自动释放池的双向链表，也就是说，新的 AutoreleasePoolPage 是没有 parent 指针的。 初始化之后，将当前页标记为 hotPage，然后会先向这个 page 中添加一个 POOL_SENTINEL 对象，来确保在 pop 调用的时候，不会出现异常。 最后，将 obj 添加到自动释放池中。 objc_autoreleasePoolPop 方法同样，回顾一下上面提到的 objc_autoreleasePoolPop 方法： 123void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中传入其它的指针也是可行的，会将自动释放池释放到相应的位置。 我们一般都会在这个方法中传入一个哨兵对象 POOL_SENTINEL，如下图一样释放对象： 对 objc_autoreleasePoolPop 行为的测试在继续分析这个方法之前做一个小测试，在 objc_autoreleasePoolPop 传入非哨兵对象，测试一下这个方法的行为。 下面是 main.m 文件中的源代码： 1234567891011#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSString *s = @\"Draveness\"; [s stringByAppendingString:@\"-Suffix\"]; &#125; return 0;&#125; 在代码的这一行打一个断点，因为这里会调用 autorelease 方法，将字符串加入自动释放池： 当代码运行到这里时，通过 lldb 打印出当前 hotPage 中的栈内容： 通过 static 方法获取当前 hotPage 打印 AutoreleasePoolPage 中的内容 打印当前 next 指针指向的内容，以及之前的内容，-2时已经到了 begin() 位置 使用 print()和 printAll()打印自动释放池中内容 然后将字符串 @&quot;Draveness-Suffix&quot; 的指针传入 pop 方法，测试 pop 方法能否传入非哨兵参数。 再次打印当前 AutoreleasePoolPage 的内容时，字符串已经不存在了，这说明向 pop 方法传入非哨兵参数是可行的，只是我们一般不会传入非哨兵对象。 让我们重新回到对 objc_autoreleasePoolPop 方法的分析，也就是 AutoreleasePoolPage::pop 方法的调用： 1234567891011121314static inline void pop(void *token) &#123; AutoreleasePoolPage *page = pageForPointer(token); id *stop = (id *)token; page-&gt;releaseUntil(stop); if (page-&gt;child) &#123; if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125; &#125;&#125; 在这个方法中删除了大量无关的代码，以及对格式进行了调整。 该静态方法总共做了三件事情： 使用 pageForPointer 获取当前 token 所在的 AutoreleasePoolPage 调用 releaseUntil 方法释放栈中的对象，直到 stop 调用 child 的 kill 方法 我到现在也不是很清楚为什么要根据当前页的不同状态 kill 掉不同 child 的页面。 12345if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill();&#125; else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill();&#125; pageForPointer 获取 AutoreleasePoolPagepageForPointer 方法主要是通过内存地址的操作，获取当前指针所在页的首地址： 123456789101112131415static AutoreleasePoolPage *pageForPointer(const void *p) &#123; return pageForPointer((uintptr_t)p);&#125;static AutoreleasePoolPage *pageForPointer(uintptr_t p) &#123; AutoreleasePoolPage *result; uintptr_t offset = p % SIZE; assert(offset &gt;= sizeof(AutoreleasePoolPage)); result = (AutoreleasePoolPage *)(p - offset); result-&gt;fastcheck(); return result;&#125; 将指针与页面的大小，也就是 4096 取模，得到当前指针的偏移量，因为所有的 AutoreleasePoolPage 在内存中都是对齐的： 123p = 0x100816048p % SIZE = 0x48result = 0x100816000 而最后调用的方法 fastCheck() 用来检查当前的 result 是不是一个 AutoreleasePoolPage。 通过检查 magic_t 结构体中的某个成员是否为 0xA1A1A1A1。 releaseUntil 释放对象releaseUntil 方法的实现如下： 123456789101112131415161718192021void releaseUntil(id *stop) &#123; while (this-&gt;next != stop) &#123; AutoreleasePoolPage *page = hotPage(); while (page-&gt;empty()) &#123; page = page-&gt;parent; setHotPage(page); &#125; page-&gt;unprotect(); id obj = *--page-&gt;next; memset((void*)page-&gt;next, SCRIBBLE, sizeof(*page-&gt;next)); page-&gt;protect(); if (obj != POOL_SENTINEL) &#123; objc_release(obj); &#125; &#125; setHotPage(this);&#125; 它的实现还是很容易的，用一个 while 循环持续释放 AutoreleasePoolPage 中的内容，直到 next 指向了 stop 。 使用 memset 将内存的内容设置成 SCRIBBLE，然后使用 objc_release 释放对象。 kill() 方法到这里，没有分析的方法就只剩下 kill 了，而它会将当前页面以及子页面全部删除： 12345678910111213141516void kill() &#123; AutoreleasePoolPage *page = this; while (page-&gt;child) page = page-&gt;child; AutoreleasePoolPage *deathptr; do &#123; deathptr = page; page = page-&gt;parent; if (page) &#123; page-&gt;unprotect(); page-&gt;child = nil; page-&gt;protect(); &#125; delete deathptr; &#125; while (deathptr != this);&#125; autorelease 方法我们已经对自动释放池生命周期有一个比较好的了解，最后需要了解的话题就是 autorelease 方法的实现，先来看一下方法的调用栈： 123456789101112- [NSObject autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2() └── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 在 autorelease 方法的调用栈中，最终都会调用上面提到的 autoreleaseFast 方法，将当前对象加到 AutoreleasePoolPage 中。 这一小节中这些方法的实现都非常容易，只是进行了一些参数上的检查，最终还要调用 autoreleaseFast 方法： 123456789101112131415inline id objc_object::rootAutorelease() &#123; if (isTaggedPointer()) return (id)this; if (prepareOptimizedReturn(ReturnAtPlus1)) return (id)this; return rootAutorelease2();&#125;__attribute__((noinline,used)) id objc_object::rootAutorelease2() &#123; return AutoreleasePoolPage::autorelease((id)this);&#125;static inline id autorelease(id obj) &#123; id *dest __unused = autoreleaseFast(obj); return obj;&#125; 由于在上面已经分析过 autoreleaseFast 方法的实现，这里就不会多说了。 小结整个自动释放池 AutoreleasePool 的实现以及 autorelease 方法都已经分析完了，我们再来回顾一下文章中的一些内容： 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的 当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息 参考资料 What is autoreleasepool? - Objective-C Using Autorelease Pool Blocks NSAutoreleasePool 黑幕背后的 Autorelease Follow: Draveness · Github","tags":[{"name":"autorelease","slug":"autorelease","permalink":"http://yoursite.com/tags/autorelease/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"14. 关联对象 AssociatedObject 完全解析（转载)","date":"2018-12-02T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/14_AssociatedObject /","text":"我们在 iOS 开发中经常需要使用分类（Category），为已经存在的类添加属性的需求，但是使用 @property 并不能在分类中正确创建实例变量和存取方法。 不过，通过 Objective-C 运行时中的关联对象，也就是 Associated Object，我们可以实现上述需求。 这篇文章包含了两方面的内容： 使用关联对象为已经存在的类中添加属性 关联对象在底层 Objective-C 中的实现 注：如果你刚刚入门 iOS 开发，笔者相信了解第一部分的内容会对你的日常开发中有所帮助，不过第二部分的内容可能有些难以理解。 如果你对关联对象的使用非常熟悉，可以直接跳过第一部分的内容，从这里开始深入了解其底层实现。 关联对象的应用关于关联对象的使用相信已经成为了一个老生常谈的问题了，不过为了保证这篇文章的完整性，笔者还是会在这里为各位介绍这部分的内容的。 分类中的 @property@property 可以说是一个 Objective-C 编程中的“宏”，它有元编程的思想。 12345@interface DKObject : NSObject@property (nonatomic, strong) NSString *property;@end 在使用上述代码时会做三件事： 生成实例变量 _property 生成 getter 方法 - property 生成 setter 方法 - setProperty: 12345678910111213@implementation DKObject &#123; NSString *_property;&#125;- (NSString *)property &#123; return _property;&#125;- (void)setProperty:(NSString *)property &#123; _property = property;&#125;@end 这些代码都是编译器为我们生成的，虽然你看不到它，但是它确实在这里，我们既然可以在类中使用 @property 生成一个属性，那么为什么在分类中不可以呢？ 我们来做一个小实验：创建一个 DKObject 的分类 Category，并添加一个属性 categoryProperty： 12345@interface DKObject (Category)@property (nonatomic, strong) NSString *categoryProperty;@end 看起来还是很不错的，不过 Build 一下这个 Demo，会发现有这么一个警告： 在这里的警告告诉我们 categoryProperty 属性的存取方法需要自己手动去实现，或者使用 @dynamic 在运行时实现这些方法。 换句话说，分类中的 @property 并没有为我们生成实例变量以及存取方法，而需要我们手动实现。 使用关联对象Q：我们为什么要使用关联对象？ A：因为在分类中 @property 并不会自动生成实例变量以及存取方法，所以一般使用关联对象为已经存在的类添加『属性』。 上一小节的内容已经给了我们需要使用关联对象的理由。在这里，我们会介绍 ObjC 运行时为我们提供的与关联对象有关的 API，并在分类中实现一个伪属性： 1234567891011121314#import \"DKObject+Category.h\"#import &lt;objc/runtime.h&gt;@implementation DKObject (Category)- (NSString *)categoryProperty &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setCategoryProperty:(NSString *)categoryProperty &#123; objc_setAssociatedObject(self, @selector(categoryProperty), categoryProperty, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 这里的 _cmd 代指当前方法的选择子，也就是 @selector(categoryProperty)。 我们使用了两个方法 objc_getAssociatedObject 以及 objc_setAssociatedObject 来模拟『属性』的存取方法，而使用关联对象模拟实例变量。 在这里有必要解释两个问题： 为什么向方法中传入 @selector(categoryProperty)？ OBJC_ASSOCIATION_RETAIN_NONATOMIC 是干什么的？ 关于第一个问题，我们需要看一下这两个方法的原型： 12id objc_getAssociatedObject(id object, const void *key);void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); @selector(categoryProperty) 也就是参数中的 key，其实可以使用静态指针 static void * 类型的参数来代替，不过在这里，笔者强烈推荐使用 @selector(categoryProperty) 作为 key 传入。因为这种方法省略了声明参数的代码，并且能很好地保证 key 的唯一性。 OBJC_ASSOCIATION_RETAIN_NONATOMIC 又是什么呢？如果我们使用 Command 加左键查看它的定义： 1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 从这里的注释我们能看到很多东西，也就是说不同的 objc_AssociationPolicy 对应了不通的属性修饰符： objc_AssociationPolicy modifier OBJC_ASSOCIATION_ASSIGN assign OBJC_ASSOCIATION_RETAIN_NONATOMIC nonatomic, strong OBJC_ASSOCIATION_COPY_NONATOMIC nonatomic, copy OBJC_ASSOCIATION_RETAIN atomic, strong OBJC_ASSOCIATION_COPY atomic, copy 而我们在代码中实现的属性 categoryProperty 就相当于使用了 nonatomic 和 strong 修饰符。 关于属性修饰符的区别，并不是这篇文章的主要内容，如果你需要了解它们的区别，Google 是一个很好的选择。 到这里，我们已经完成了对关联对象应用的介绍，再来回顾一下小节的内容。 @property` 其实有元编程的思想，它能够为我们自动生成实例变量以及存取方法，而这三者构成了属性这个类似于语法糖的概念，为我们提供了更便利的点语法来访问属性： 12self.property &lt;=&gt; [self property]self.property = value &lt;=&gt; [self setProperty:value] 在分类中，因为类的实例变量的布局已经固定，使用 @property 已经无法向固定的布局中添加新的实例变量（这样做可能会覆盖子类的实例变量），所以我们需要使用关联对象以及两个方法来模拟构成属性的三个要素。 如果你是一个 iOS 开发方面的新手，我相信这篇文章的前半部分对已经足够使用了，不过，如果你还对关联对象的实现非常感兴趣，也可以尝试阅读下面的内容。 关联对象的实现 探索关联对象的实现一直是我想要做的一件事情，直到最近，我才有足够的时间来完成这篇文章，希望能够对各位读者有所帮助。 这一部分会从三个 objc 运行时的方法为入口来对关联对象的实现一探究竟，其中两个方法是上一部分使用到的方法： 123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);id objc_getAssociatedObject(id object, const void *key);void objc_removeAssociatedObjects(id object); 三个方法的作用分别是： 以键值对形式添加关联对象 根据 key 获取关联对象 移除所有关联对象 而接下来的内容自然就是围绕这三个方法进行的，我们会对它们的实现进行分析。 objc_setAssociatedObject首先是 objc_setAssociatedObject 方法，这个方法的调用栈并不复杂： 123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) └── void objc_setAssociatedObject_non_gc(id object, const void *key, id value, objc_AssociationPolicy policy) └── void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) 调用栈中的 _object_set_associative_reference 方法实际完成了设置关联对象的任务： 1234567891011void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); ObjectAssociationMap *refs = i-&gt;second; ... &#125; if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 在这里的实现省略了大多的实现代码，而且忽略了很多逻辑上的顺序，不过不要在意这里的代码能否执行。 我们需要注意其中的几个类和数据结构，因为在具体分析这个方法的实现之前，我们需要了解其中它们的作用： AssociationsManager AssociationsHashMap ObjcAssociationMap ObjcAssociation AssociationsManagerAssociationsManager 在源代码中的定义是这样的： 12345678910111213141516class AssociationsManager &#123; static spinlock_t _lock; static AssociationsHashMap *_map;public: AssociationsManager() &#123; _lock.lock(); &#125; ~AssociationsManager() &#123; _lock.unlock(); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;;spinlock_t AssociationsManager::_lock;AssociationsHashMap *AssociationsManager::_map = NULL; 它维护了 spinlock_t 和 AssociationsHashMap 的单例，初始化它的时候会调用 lock.lock() 方法，在析构时会调用 lock.unlock()，而 associations 方法用于取得一个全局的 AssociationsHashMap 单例。 也就是说 AssociationsManager 通过持有一个自旋锁 spinlock_t 保证对 AssociationsHashMap 的操作是线程安全的，即每次只会有一个线程对 AssociationsHashMap 进行操作。 如何存储 ObjcAssociationObjcAssociation 就是真正的关联对象的类，上面的所有数据结构只是为了更好的存储它。 首先，AssociationsHashMap 用与保存从对象的 disguised_ptr_t 到 ObjectAssociationMap 的映射： 12345class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123;public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; 而 ObjectAssociationMap 则保存了从 key 到关联对象 ObjcAssociation 的映射，这个数据结构保存了当前对象对应的所有关联对象： 12345class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123;public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; 最关键的 ObjcAssociation 包含了 policy 以及 value： 123456789101112class ObjcAssociation &#123; uintptr_t _policy; id _value;public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125; ObjcAssociation() : _policy(0), _value(nil) &#123;&#125; uintptr_t policy() const &#123; return _policy; &#125; id value() const &#123; return _value; &#125; bool hasValue() &#123; return _value != nil; &#125;&#125;; 举一个简单的例子来说明关联对象在内存中以什么形式存储的，以下面的代码为例： 123456789int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *obj = [NSObject new]; objc_setAssociatedObject(obj, @selector(hello), @\"Hello\", OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return 0;&#125; 这里的关联对象 ObjcAssociation(OBJC_ASSOCIATION_RETAIN_NONATOMIC, @&quot;Hello&quot;) 在内存中是这么存储的： 接下来我们可以重新回到对 objc_setAssociatedObject 方法的分析了。 在这里会将方法的执行分为两种情况： new_value != nil 设置/更新关联对象的值 new_value == nil 删除一个关联对象 new_value != nil先来分析在 new_value != nil 的情况下，该方法的执行是什么样的： 123456789101112131415161718192021222324252627void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 使用 old_association(0, nil) 创建一个临时的 ObjcAssociation 对象（用于持有原有的关联对象，方便在方法调用的最后释放值） 调用 acquireValue 对 new_value 进行 retain 或者 copy 123456789static id acquireValue(id value, uintptr_t policy) &#123; switch (policy &amp; 0xFF) &#123; case OBJC_ASSOCIATION_SETTER_RETAIN: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); case OBJC_ASSOCIATION_SETTER_COPY: return ((id(*)(id, SEL))objc_msgSend)(value, SEL_copy); &#125; return value;&#125; 初始化一个 AssociationsManager，并获取唯一的保存关联对象的哈希表 AssociationsHashMap 12AssociationsManager manager;AssociationsHashMap &amp;associations(manager.associations()); 先使用 DISGUISE(object) 作为 key 寻找对应的 ObjectAssociationMap 如果没有找到，初始化一个 ObjectAssociationMap，再实例化 ObjcAssociation 对象添加到 Map 中，并调用 setHasAssociatedObjects 方法，表明当前对象含有关联对象 1234ObjectAssociationMap *refs = new ObjectAssociationMap;associations[disguised_object] = refs;(*refs)[key] = ObjcAssociation(policy, new_value);object-&gt;setHasAssociatedObjects(); 如果找到了对应的 ObjectAssociationMap，就要看 key 是否存在了，由此来决定是更新原有的关联对象，还是增加一个 12345678ObjectAssociationMap *refs = i-&gt;second;ObjectAssociationMap::iterator j = refs-&gt;find(key);if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value);&#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value);&#125; 最后的最后，如果原来的关联对象有值的话，会调用 ReleaseValue() 释放关联对象的值 1234567891011struct ReleaseValue &#123; void operator() (ObjcAssociation &amp;association) &#123; releaseValue(association.value(), association.policy()); &#125;&#125;;static void releaseValue(id value, uintptr_t policy) &#123; if (policy &amp; OBJC_ASSOCIATION_SETTER_RETAIN) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_release); &#125;&#125; 到这里，该条件下的方法实现就结束了。 new_value == nil如果 new_value == nil，就说明我们要删除对应 key 的关联对象，实现如下： 1234567891011121314151617181920void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 这种情况下方法的实现与前面的唯一区别就是，我们会调用 erase 方法，擦除 ObjectAssociationMap 中 key 对应的节点。 setHasAssociatedObjects()其实上面的两种情况已经将 objc_setAssociatedObject 方法的实现分析得很透彻了，不过，这里还有一个小问题来等待我们解决，setHasAssociatedObjects() 方法的作用是什么？ 1234567891011inline void objc_object::setHasAssociatedObjects() &#123; if (isTaggedPointer()) return; retry: isa_t oldisa = LoadExclusive(&amp;isa.bits); isa_t newisa = oldisa; if (!newisa.indexed) return; if (newisa.has_assoc) return; newisa.has_assoc = true; if (!StoreExclusive(&amp;isa.bits, oldisa.bits, newisa.bits)) goto retry;&#125; 它会将 isa 结构体中的标记位 has_assoc 标记为 true，也就是表示当前对象有关联对象，在这里我还想祭出这张图来介绍 isa 中的各个标记位都是干什么的。 如果想要了解关于 isa 的知识，可以阅读从 NSObject 的初始化了解 isa objc_getAssociatedObject我们既然已经对 objc_setAssociatedObject 的实现已经比较熟悉了，相信对于 objc_getAssociatedObject 的理解也会更加容易。 方法的调用栈和 objc_setAssociatedObject 非常相似： 123id objc_getAssociatedObject(id object, const void *key)└── id objc_getAssociatedObject_non_gc(id object, const void *key); └── id _object_get_associative_reference(id object, void *key) 而 _object_get_associative_reference 相比于前面方法的实现更加简单。 123456789101112131415161718192021222324id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); &#125; return value;&#125; 代码中寻找关联对象的逻辑和 objc_setAssociatedObject 差不多： 获取静态变量 AssociationsHashMap 以 DISGUISE(object) 为 key 查找 AssociationsHashMap 以 void *key 为 key 查找 ObjcAssociation 根据 policy 调用相应的方法 12345if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain);if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease);&#125; 返回关联对象 ObjcAssociation 的值 objc_removeAssociatedObjects关于最后的 objc_removeAssociatedObjects 方法，其实现也相对简单，这是方法的调用栈： 12void objc_removeAssociatedObjects(id object)└── void _object_remove_assocations(id object) 这是简化版本的 objc_removeAssociatedObjects 方法实现： 12345void objc_removeAssociatedObjects(id object) &#123; if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; _object_remove_assocations(object); &#125;&#125; 为了加速移除对象的关联对象的速度，我们会通过标记位 has_assoc 来避免不必要的方法调用，在确认了对象和关联对象的存在之后，才会调用 _object_remove_assocations 方法移除对象上所有的关联对象： 12345678910111213141516171819void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; delete refs; associations.erase(i); &#125; &#125; for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 方法会将对象包含的所有关联对象加入到一个 vector 中，然后对所有的 ObjcAssociation 对象调用 ReleaseValue() 方法，释放不再被需要的值。 小结关于应用本来在这个系列的文章中并不会涉及关联对象这个话题，不过，有人问过我这么一个问题：在分类中到底能否实现属性？其实在回答这个问题之前，首先要知道到底属性是什么？而属性的概念决定了这个问题的答案。 如果你把属性理解为通过方法访问的实例变量，我相信这个问题的答案是不能，因为分类不能为类增加额外的实例变量。 不过如果属性只是一个存取方法以及存储值的容器的集合，那么分类是可以实现属性的。 分类中对属性的实现其实只是实现了一个看起来像属性的接口而已。 关于实现关联对象又是如何实现并且管理的呢： 关联对象其实就是 ObjcAssociation 对象 关联对象由 AssociationsManager 管理并在 AssociationsHashMap 存储 对象的指针以及其对应 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中 ObjectAssociationMap 则是用于存储关联对象的数据结构 每一个对象都有一个标记位 has_assoc 指示对象是否含有关联对象 Follow: Draveness · Github","tags":[{"name":"AssociatedObject","slug":"AssociatedObject","permalink":"http://yoursite.com/tags/AssociatedObject/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"12. 懒惰的 initialize 方法（转载）","date":"2018-12-01T03:38:11.000Z","path":"wiki/IOS/Runtime/objc/12_initialize/","text":"这篇文章可能是对 Objective-C 源代码解析系列文章中最短的一篇了，在 Objective-C 中，我们总是会同时想到 load、initialize 这两个类方法。而这两个方法也经常在一起比较。 本文会主要介绍： initialize 方法的调用为什么是惰性的。 这货能干啥。 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。 initialize 的调用栈在分析其调用栈之前，首先来解释一下，什么是惰性的。 这是 main.m 文件中的代码： 12345678910111213141516#import &lt;Foundation/Foundation.h&gt;@interface XXObject : NSObject @end@implementation XXObject+ (void)initialize &#123; NSLog(@\"XXObject initialize\");&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#125; return 0;&#125; 主函数中的代码为空，如果我们运行这个程序： 你会发现与 load 方法不同的是，虽然我们在 initialize 方法中调用了 NSLog。但是程序运行之后没有任何输出。 如果，我们在自动释放池中加入以下代码： 123456int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; __unused XXObject *object = [[XXObject alloc] init]; &#125; return 0;&#125; 再运行程序： 你会发现，虽然我们没有直接调用 initialize 方法。但是，这里也打印出了 XXObject initialize 字符串。 initialize 只会在对应类的方法第一次被调用时，才会调用。 我们在 initialize 方法中打一个断点，来查看这个方法的调用栈： 12345670 +[XXObject initialize]1 _class_initialize2 lookUpImpOrForward3 _class_lookupMethodAndLoadCache34 objc_msgSend5 main6 start 直接来看调用栈中的 lookUpImpOrForward 方法，lookUpImpOrForward 方法只会在向对象发送消息，并且在类的缓存中没有找到消息的选择子时才会调用，具体可以看这篇文章，从源代码看 ObjC 中消息的发送。 在这里，我们知道 lookUpImpOrForward 方法是 objc_msgSend 触发的就够了。 在 lldb 中输入 p sel 打印选择子，会发现当前调用的方法是 alloc 方法，也就是说，initialize 方法是在 alloc 方法之前调用的，alloc 的调用导致了前者的执行。 其中，使用 if (initialize &amp;&amp; !cls-&gt;isInitialized()) 来判断当前类是否初始化过： 123bool isInitialized() &#123; return getMeta()-&gt;data()-&gt;flags &amp; RW_INITIALIZED;&#125; 当前类是否初始化过的信息就保存在元类的 class_rw_t 结构体中的 flags 中。 这是 flags 中保存的信息，它记录着跟当前类的元数据，其中第 16-31 位有如下的作用： flags 的第 29 位 RW_INITIALIZED 就保存了当前类是否初始化过的信息。 _class_initialize 方法在 initialize 的调用栈中，直接调用其方法的是下面的这个 C 语言函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void _class_initialize(Class cls)&#123; Class supercls; BOOL reallyInitialize = NO; // 1. 强制父类先调用 initialize 方法 supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125; &#123; // 2. 通过加锁来设置 RW_INITIALIZING 标志位 monitor_locker_t lock(classInitLock); if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES; &#125; &#125; if (reallyInitialize) &#123; // 3. 成功设置标志位，向当前类发送 +initialize 消息 _setThisThreadIsInitializingClass(cls); ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); // 4. 完成初始化，如果父类已经初始化完成，设置 RW_INITIALIZED 标志位， // 否则，在父类初始化完成之后再设置标志位。 monitor_locker_t lock(classInitLock); if (!supercls || supercls-&gt;isInitialized()) &#123; _finishInitializing(cls, supercls); &#125; else &#123; _finishInitializingAfter(cls, supercls); &#125; return; &#125; else if (cls-&gt;isInitializing()) &#123; // 5. 当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回 if (_thisThreadIsInitializingClass(cls)) &#123; return; &#125; else &#123; monitor_locker_t lock(classInitLock); while (!cls-&gt;isInitialized()) &#123; classInitLock.wait(); &#125; return; &#125; &#125; else if (cls-&gt;isInitialized()) &#123; // 6. 初始化成功后，直接返回 return; &#125; else &#123; _objc_fatal(\"thread-safe class init in objc runtime is buggy!\"); &#125;&#125; 方法的主要作用自然是向未初始化的类发送 +initialize 消息，不过会强制父类先发送 +initialize。 强制未初始化过的父类调用 initialize 方法 123if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls);&#125; 通过加锁来设置 RW_INITIALIZING 标志位 12345monitor_locker_t lock(classInitLock);if (!cls-&gt;isInitialized() &amp;&amp; !cls-&gt;isInitializing()) &#123; cls-&gt;setInitializing(); reallyInitialize = YES;&#125; 成功设置标志位、向当前类发送 +initialize 消息 1((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize); 完成初始化，如果父类已经初始化完成，设置 RW_INITIALIZED 标志位。否则，在父类初始化完成之后再设置标志位 123456monitor_locker_t lock(classInitLock);if (!supercls || supercls-&gt;isInitialized()) &#123; _finishInitializing(cls, supercls);&#125; else &#123; _finishInitializingAfter(cls, supercls);&#125; 如果当前线程正在初始化当前类，直接返回，否则，会等待其它线程初始化结束后，再返回，保证线程安全 123456789if (_thisThreadIsInitializingClass(cls)) &#123; return;&#125; else &#123; monitor_locker_t lock(classInitLock); while (!cls-&gt;isInitialized()) &#123; classInitLock.wait(); &#125; return;&#125; 初始化成功后，直接返回 1return; 管理初始化队列因为我们始终要保证父类的初始化方法要在子类之前调用，所以我们需要维护一个 PendingInitializeMap 的数据结构来存储当前的类初始化需要哪个父类先初始化完成。 这个数据结构中的信息会被两个方法改变： 12345if (!supercls || supercls-&gt;isInitialized()) &#123; _finishInitializing(cls, supercls);&#125; else &#123; _finishInitializingAfter(cls, supercls);&#125; 分别是 _finishInitializing 以及 _finishInitializingAfter，先来看一下后者是怎么实现的，也就是在父类没有完成初始化的时候调用的方法： 12345678static void _finishInitializingAfter(Class cls, Class supercls)&#123; PendingInitialize *pending; pending = (PendingInitialize *)malloc(sizeof(*pending)); pending-&gt;subclass = cls; pending-&gt;next = (PendingInitialize *)NXMapGet(pendingInitializeMap, supercls); NXMapInsert(pendingInitializeMap, supercls, pending);&#125; 因为当前类的父类没有初始化，所以会将子类加入一个数据结构 PendingInitialize 中，这个数据结构其实就类似于一个保存子类的链表。这个链表会以父类为键存储到 pendingInitializeMap 中。 1NXMapInsert(pendingInitializeMap, supercls, pending); 而在父类已经调用了初始化方法的情况下，对应方法 _finishInitializing 的实现就稍微有些复杂了： 12345678910111213141516171819static void _finishInitializing(Class cls, Class supercls)&#123; PendingInitialize *pending; cls-&gt;setInitialized(); if (!pendingInitializeMap) return; pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls); if (!pending) return; NXMapRemove(pendingInitializeMap, cls); while (pending) &#123; PendingInitialize *next = pending-&gt;next; if (pending-&gt;subclass) _finishInitializing(pending-&gt;subclass, cls); free(pending); pending = next; &#125;&#125; 首先，由于父类已经完成了初始化，在这里直接将当前类标记成已经初始化，然后递归地将被当前类 block 的子类标记为已初始化，再把这些当类移除 pendingInitializeMap。 小结到这里，我们对 initialize 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性： initialize 的调用是惰性的，它会在第一次调用当前类的方法时被调用 与 load 不同，initialize 方法调用时，所有的类都已经加载到了内存中 initialize 的运行是线程安全的 子类会继承父类的 initialize 方法 而其作用也非常局限，一般我们只会在 initialize 方法中进行一些常量的初始化。 参考资料 What is a meta-class in Objective-C? NSObject +load and +initialize - What do they do?","tags":[{"name":"initialize","slug":"initialize","permalink":"http://yoursite.com/tags/initialize/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"11. 你真的了解 load 方法么？","date":"2018-12-01T03:38:11.000Z","path":"wiki/IOS/Runtime/objc/11_load/","text":"__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。 写在前面 文章的标题与其说是问各位读者，不如说是问笔者自己：我真的了解 + load 方法么？ + load 作为 Objective-C 中的一个方法，与其它方法有很大的不同。它只是一个在整个文件被加载到运行时，在 main 函数调用之前被 ObjC 运行时调用的钩子方法。其中关键字有这么几个： 文件刚加载 main 函数之前 钩子方法 我在阅读 ObjC 源代码之前，曾经一度感觉自己对 + load 方法的作用非常了解，直到看了源代码中的实现，才知道以前的以为，只是自己的以为罢了。 这篇文章会假设你知道： 使用过 + load 方法 知道 + load 方法的调用顺序（文章中会简单介绍） 在这篇文章中并不会用大篇幅介绍 + load 方法的作用其实也没几个作用，关注点主要在以下两个问题上： + load 方法是如何被调用的 + load 方法为什么会有这种调用顺序 load 方法的调用栈首先来通过 load 方法的调用栈，分析一下它到底是如何被调用的。 下面是程序的全部代码： 1234567891011121314151617// main.m#import &lt;Foundation/Foundation.h&gt;@interface XXObject : NSObject @end@implementation XXObject+ (void)load &#123; NSLog(@\"XXObject load\");&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; &#125; return 0;&#125; 代码总共只实现了一个 XXObject 的 + load 方法，主函数中也没有任何的东西： 虽然在主函数中什么方法都没有调用，但是运行之后，依然打印了 XXObject load 字符串，也就是说调用了 + load 方法。 使用符号断点使用 Xcode 添加一个符号断点 +[XXObject load]： 注意这里 + 和 [ 之间没有空格 为什么要加一个符号断点呢？因为这样看起来比较高级。 重新运行程序。这时，代码会停在 NSLog(@&quot;XXObject load&quot;); 这一行的实现上： 左侧的调用栈很清楚的告诉我们，哪些方法被调用了： 1234560 +[XXObject load]1 call_class_loads()2 call_load_methods3 load_images4 dyld::notifySingle(dyld_image_states, ImageLoader const*)11 _dyld_start dyld 是 the dynamic link editor 的缩写，它是苹果的动态链接器。 在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作。本文不会对其进行解释 每当有新的镜像加载之后，都会执行 3 load_images 方法进行回调，这里的回调是在整个运行时初始化时 _objc_init 注册的（会在之后的文章中具体介绍）： 1dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images); 有新的镜像被加载到 runtime 时，调用 load_images 方法，并传入最新镜像的信息列表 infoList： 12345678910111213141516171819202122232425262728const char *load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; bool found; found = false; for (uint32_t i = 0; i &lt; infoCount; i++) &#123; if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123; found = true; break; &#125; &#125; if (!found) return nil; recursive_mutex_locker_t lock(loadMethodLock); &#123; rwlock_writer_t lock2(runtimeLock); found = load_images_nolock(state, infoCount, infoList); &#125; if (found) &#123; call_load_methods(); &#125; return nil;&#125; 什么是镜像这里就会遇到一个问题：镜像到底是什么，我们用一个断点打印出所有加载的镜像： 从控制台输出的结果大概就是这样的，我们可以看到镜像并不是一个 Objective-C 的代码文件，它应该是一个 target 的编译产物。 123456789101112131415161718192021...(const dyld_image_info) $52 = &#123; imageLoadAddress = 0x00007fff8a144000 imageFilePath = 0x00007fff8a144168 \"/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices\" imageFileModDate = 1452737802&#125;(const dyld_image_info) $53 = &#123; imageLoadAddress = 0x00007fff946d9000 imageFilePath = 0x00007fff946d9480 \"/usr/lib/liblangid.dylib\" imageFileModDate = 1452737618&#125;(const dyld_image_info) $54 = &#123; imageLoadAddress = 0x00007fff88016000 imageFilePath = 0x00007fff88016d40 \"/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation\" imageFileModDate = 1452737917&#125;(const dyld_image_info) $55 = &#123; imageLoadAddress = 0x0000000100000000 imageFilePath = 0x00007fff5fbff8f0 \"/Users/apple/Library/Developer/Xcode/DerivedData/objc-dibgivkseuawonexgbqssmdszazo/Build/Products/Debug/debug-objc\" imageFileModDate = 0&#125; 这里面有很多的动态链接库，还有一些苹果为我们提供的框架，比如 Foundation、 CoreServices 等等，都是在这个 load_images 中加载进来的，而这些 imageFilePath 都是对应的二进制文件的地址。 但是如果进入最下面的这个目录，会发现它是一个可执行文件，它的运行结果与 Xcode 中的运行结果相同： 准备 + load 方法我们重新回到 load_images 方法，如果在扫描镜像的过程中发现了 + load 符号： 123456for (uint32_t i = 0; i &lt; infoCount; i++) &#123; if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123; found = true; break; &#125;&#125; 就会进入 load_images_nolock 来查找 load 方法： 1234567891011121314151617bool load_images_nolock(enum dyld_image_states state,uint32_t infoCount, const struct dyld_image_info infoList[])&#123; bool found = NO; uint32_t i; i = infoCount; while (i--) &#123; const headerType *mhdr = (headerType*)infoList[i].imageLoadAddress; if (!hasLoadMethods(mhdr)) continue; prepare_load_methods(mhdr); found = YES; &#125; return found;&#125; 调用 prepare_load_methods 对 load 方法的调用进行准备（将需要调用 load 方法的类添加到一个列表中，后面的小节中会介绍）： 12345678910111213141516171819202122void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertWriting(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class realizeClass(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125; 通过 _getObjc2NonlazyClassList 获取所有的类的列表之后，会通过 remapClass 获取类对应的指针，然后调用 schedule_class_load 递归地安排当前类和没有调用 + load 父类进入列表。 123456789101112static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; 在执行 add_class_to_loadable_list(cls) 将当前类加入加载列表之前，会先把父类加入待加载的列表，保证父类在子类前调用 load 方法。 调用 + load 方法在将镜像加载到运行时、对 load 方法的准备就绪之后，执行 call_load_methods，开始调用 load 方法： 123456789101112131415void call_load_methods(void)&#123; ... do &#123; while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; more_categories = call_category_loads(); &#125; while (loadable_classes_used &gt; 0 || more_categories); ...&#125; 方法的调用流程大概是这样的： 其中 call_class_loads 会从一个待加载的类列表 loadable_classes 中寻找对应的类，然后找到 @selector(load) 的实现并执行。 1234567891011121314151617181920static void call_class_loads(void)&#123; int i; struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; (*load_method)(cls, SEL_load); &#125; if (classes) free(classes);&#125; 这行 (*load_method)(cls, SEL_load) 代码就会调用 +[XXObject load] 方法。 我们会在下面介绍 loadable_classes 列表是如何管理的。 到现在，我们回答了第一个问题： Q：load 方法是如何被调用的？ A：当 Objective-C 运行时初始化的时候，会通过 dyld_register_image_state_change_handler 在每次有新的镜像加入运行时的时候，进行回调。执行 load_images 将所有包含 load 方法的文件加入列表 loadable_classes ，然后从这个列表中找到对应的 load 方法的实现，调用 load 方法。 加载的管理ObjC 对于加载的管理，主要使用了两个列表，分别是 loadable_classes 和 loadable_categories。 方法的调用过程也分为两个部分，准备 load 方法和调用 load 方法，我更觉得这两个部分比较像生产者与消费者： add_class_to_loadable_list 方法负责将类加入 loadable_classes 集合，而 call_class_loads 负责消费集合中的元素。 而对于分类来说，其模型也是类似的，只不过使用了另一个列表 loadable_categories。 “生产” loadable_class在调用 load_images -&gt; load_images_nolock -&gt; prepare_load_methods -&gt; schedule_class_load -&gt; add_class_to_loadable_list 的时候会将未加载的类添加到 loadable_classes 数组中： 123456789101112131415161718192021void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); method = cls-&gt;getLoadMethod(); if (!method) return; if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125; 方法刚被调用时： 会从 class 中获取 load 方法： method = cls-&gt;getLoadMethod(); 判断当前 loadable_classes 这个数组是否已经被全部占用了：loadable_classes_used == loadable_classes_allocated 在当前数组的基础上扩大数组的大小：realloc 把传入的 class 以及对应的方法的实现加到列表中 另外一个用于保存分类的列表 loadable_categories 也有一个类似的方法 add_category_to_loadable_list。 12345678910111213141516171819202122void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); if (!method) return; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; 实现几乎与 add_class_to_loadable_list 完全相同。 到这里我们完成了对 loadable_classes 以及 loadable_categories 的提供，下面会开始消耗列表中的元素。 “消费” loadable_class调用 load 方法的过程就是“消费” loadable_classes 的过程，load_images -&gt; call_load_methods -&gt; call_class_loads 会从 loadable_classes 中取出对应类和方法，执行 load。 12345678910111213141516171819202122232425void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; more_categories = call_category_loads(); &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 上述方法对所有在 loadable_classes 以及 loadable_categories 中的类以及分类执行 load 方法。 12345678do &#123; while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; more_categories = call_category_loads();&#125; while (loadable_classes_used &gt; 0 || more_categories); 调用顺序如下： 不停调用类的 + load 方法，直到 loadable_classes 为空 调用一次 call_category_loads 加载分类 如果有 loadable_classes 或者更多的分类，继续调用 load 方法 相比于类 load 方法的调用，分类中 load 方法的调用就有些复杂了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // 1. 获取当前可以加载的分类列表 struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; // 2. 如果当前类是可加载的 `cls &amp;&amp; cls-&gt;isLoadable()` 就会调用分类的 load 方法 (*load_method)(cls, SEL_load); cats[i].cat = nil; &#125; &#125; // 3. 将所有加载过的分类移除 `loadable_categories` 列表 shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // 4. 为 `loadable_categories` 重新分配内存，并重新设置它的值 new_categories_added = (loadable_categories_used &gt; 0); for (i = 0; i &lt; loadable_categories_used; i++) &#123; if (used == allocated) &#123; allocated = allocated*2 + 16; cats = (struct loadable_category *) realloc(cats, allocated * sizeof(struct loadable_category)); &#125; cats[used++] = loadable_categories[i]; &#125; if (loadable_categories) free(loadable_categories); if (used) &#123; loadable_categories = cats; loadable_categories_used = used; loadable_categories_allocated = allocated; &#125; else &#123; if (cats) free(cats); loadable_categories = nil; loadable_categories_used = 0; loadable_categories_allocated = 0; &#125; return new_categories_added;&#125; 这个方法有些长，我们来分步解释方法的作用： 获取当前可以加载的分类列表 如果当前类是可加载的 cls &amp;&amp; cls-&gt;isLoadable() 就会调用分类的 load 方法 将所有加载过的分类移除 loadable_categories 列表 为 loadable_categories 重新分配内存，并重新设置它的值 调用的顺序你过去可能会听说过，对于 load 方法的调用顺序有两条规则： 父类先于子类调用 类先于分类调用 这种现象是非常符合我们的直觉的，我们来分析一下这种现象出现的原因。 第一条规则是由于 schedule_class_load 有如下的实现： 123456789101112static void schedule_class_load(Class cls)&#123; if (!cls) return; assert(cls-&gt;isRealized()); if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125; 这里通过这行代码 schedule_class_load(cls-&gt;superclass) 总是能够保证没有调用 load 方法的父类先于子类加入 loadable_classes 数组，从而确保其调用顺序的正确性。 类与分类中 load 方法的调用顺序主要在 call_load_methods 中实现： 12345678do &#123; while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; more_categories = call_category_loads();&#125; while (loadable_classes_used &gt; 0 || more_categories); 上面的 do while 语句能够在一定程度上确保，类的 load 方法会先于分类调用。但是这里不能完全保证调用顺序的正确。 如果分类的镜像在类的镜像之前加载到运行时，上面的代码就没法保证顺序的正确了，所以，我们还需要在 call_category_loads 中判断类是否已经加载到内存中（调用 load 方法）： 1234if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; (*load_method)(cls, SEL_load); cats[i].cat = nil;&#125; 这里，检查了类是否存在并且是否可以加载，如果都为真，那么就可以调用分类的 load 方法了。 load 的应用load 可以说我们在日常开发中可以接触到的调用时间最靠前的方法，在主函数运行之前，load 方法就会调用。 由于它的调用不是惰性的，且其只会在程序调用期间调用一次，最最重要的是，如果在类与分类中都实现了 load 方法，它们都会被调用，不像其它的在分类中实现的方法会被覆盖，这就使 load 方法成为了方法调剂的绝佳时机。 但是由于 load 方法的运行时间过早，所以这里可能不是一个理想的环境，因为某些类可能需要在在其它类之前加载，但是这是我们无法保证的。不过在这个时间点，所有的 framework 都已经加载到了运行时中，所以调用 framework 中的方法都是安全的。 参考资料 NSObject +load and +initialize - What do they do? Method Swizzling Objective-C Class Loading and Initialization","tags":[{"name":"load","slug":"load","permalink":"http://yoursite.com/tags/load/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"13. _class_initialize 源码分析","date":"2018-12-01T03:38:11.000Z","path":"wiki/IOS/Runtime/objc/13_class_initialize/","text":"本文是我自己理解_class_initialize的记录 _class_initialize 源码分析_class_initialize 干什么_class_initialize 主要功能是调用+initialize方法。简化代码如下： 123456void _class_initialize(Class cls)&#123; // 调用 +initialize，主要的初始化工作，就是调用这个方法 // 注意：如果 cls 没有实现 +initialize 方法的话，它会被发给父类 ((void(*)(Class, SEL))objc_msgSend)(cls, SEL_initialize);&#125; 多线程调用_class_initialize的问题假如有下面的示例： 调用的顺序如下 1234567891011线程 1 ： 初始化 OWAddressEntry 类 -&gt; 初始化 OFObject 类 -&gt; 初始化 OBObject 类 -&gt; [OBObject initialize] 中用了 OBPostLoader 类，里面需要初始化好多类 -&gt; 初始化 OWConsoleController 类 -&gt; 初始化 OWController 类，发现线程2正在初始化 OWController 类，就阻塞等待线程2完成对 OWController 的初始化工作 .... 线程 2 ： 初始化 OWController 类 -&gt; 初始化 OFObject 类，发现线程1正在初始化 OFObject 类，就阻塞等待线程1完成对 OFObject 类的初始化工作....： 上面这种多线程场景，就会出现死锁的问题。 解决办法： 父类一定比子类先开始初始化。因为 OWController的父类 OFObject 还没有初始化，所以它也不会开始初始化，而是等到父类在同一线程开始初始化，或者在另一线程完成初始化后，才会进行初始化。所以线程2并没有在初始化OWController，线程1也并不需要等待，也就是没有了竞争和死锁。 保证父类的initialize如何比子类的调用早（早进入）父类的initialize如何比子类的调用早 通过下面的代码实现： 1234if (supercls &amp;&amp; !supercls-&gt;isInitialized())///父类递归调用本函数&#123; _class_initialize(supercls);&#125; 如何等待父类调用完成假如：有下面一个例子，如何保证父类比子类调用早呢 ？ 调用的顺序如下： 首先进入OWAddressEntry 找父类 OFObject 找父类 OBObject 执行initialize方法 [OBObject initialize] 中用了 OBPostLoader 类，里面需要初始化好多类 初始化 OWController 类 找父类 再次进入OFObject 这里就重复进入了， 解决办法，查看父类正在RW_INITIALIZING，就不能在进入，直接开始OFObject的初始化。 这样就出现了一个问题，OFObject会比父类OBObject早结束initialize方法，这样是一个不完全的初始化，所以先将OFObject保持起来，等到父类完成了，然后在设置OFObject为初始哈完成状态。 这里就用到了一个数据结构： 1234typedef struct PendingInitialize &#123; Class subclass; // 子类 struct PendingInitialize *next; // 下一个，看来是一个链表&#125; PendingInitialize; 保存方法如下： 123456789101112static void _finishInitializingAfter(Class cls, Class supercls)&#123; PendingInitialize *pending; ..... pending-&gt;subclass = cls; // pending 记录子类 cls // next 指向下一个 pending，因为类会多个子类，所以还是才用了树的结构，next 指向的是兄弟节点 pending-&gt;next = (PendingInitialize *) NXMapGet(pendingInitializeMap, supercls); // 将 pending 插入 pendingInitializeMap 中，key 是父类 NXMapInsert(pendingInitializeMap, supercls, pending);&#125; 如果OFObject比OBObject先初始化完成，就调用_finishInitializingAfter将OFObject保存起来，等到父类OBObject初始化完成，在调用_finishInitializing从pendingInitializeMap中删除，同时置OFObject为初始化完成状态。 123456789static void _finishInitializing(Class cls, Class supercls)&#123; cls-&gt;setInitialized(); pending = (PendingInitialize *)NXMapGet(pendingInitializeMap, cls); // 利用 key cls 将 pending链表 从 pendingInitializeMap 中移除 NXMapRemove(pendingInitializeMap, cls);&#125; 小结到这里，我们对 initialize 方法的研究基本上已经结束了，这里会总结一下关于其方法的特性： initialize 的调用是惰性的，它会在第一次调用当前类的方法时被调用 与 load 不同，initialize 方法调用时，所有的类都已经加载到了内存中 initialize 的运行是线程安全的 子类会继承父类的 initialize 方法 而其作用也非常局限，一般我们只会在 initialize 方法中进行一些常量的初始化。 参考资料 What is a meta-class in Objective-C? NSObject +load and +initialize - What do they do?","tags":[{"name":"initialize","slug":"initialize","permalink":"http://yoursite.com/tags/initialize/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"10.load_images 函数分析","date":"2018-11-30T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/10_load_images/","text":"本文分析load_images 函数,该函数完成+load方法的调用。 load_images 相关的数据结构在_objc_init 函数中，dyld_register_image_state_change_handler 将 load_images 作为回调函数注册给dylib，所以，当镜像的状态变化时，会回调load_images函数。 12345void _objc_init(void)&#123; ... dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; 在分析load_images前，先介绍相关的数据结构： 1234567891011121314151617181920212223typedef void(*load_method_t)(id, SEL); // 用于 +load 方法的 imp 类型struct loadable_class &#123; // 需要被调用 +load 方法的类 Class cls; // may be nil IMP method; // +load 方法对应的 imp&#125;;struct loadable_category &#123; // 需要被调用 +load 方法的分类 Category cat; // may be nil IMP method; // +load 方法对应的 imp&#125;;// List of classes that need +load called (pending superclass +load)// This list always has superclasses first because of the way it is constructedstatic struct loadable_class *loadable_classes = nil; // 这个列表中存放所有需要调用 +load 方法的类static int loadable_classes_used = 0; // loadable_classes 列表中已经被使用了多少个位置static int loadable_classes_allocated = 0; // loadable_classes 列表开辟了多少位置，如果位置不够用了，会进行扩容// List of categories that need +load called (pending parent class +load)static struct loadable_category *loadable_categories = nil; // 这个列表中存放所有需要执行 +load 方法的分类static int loadable_categories_used = 0; // loadable_categories 列表中已经被使用了多少个位置static int loadable_categories_allocated = 0; // loadable_categories 列表开辟了多少位置，如果位置不够用了，会进行扩容 可load 的class相关的数据结构： 可load 的category相关的数据结构： load_images 源码分析12345678910111213141516171819202122232425262728293031323334353637383940const char *load_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; bool found; found = false; for (uint32_t i = 0; i &lt; infoCount; i++) &#123; // 快速扫描镜像中是否有 +load 方法 (其实只查找了镜像中是否有类或分类） // imageLoadAddress 是镜像加载的内存地址 if (hasLoadMethods((const headerType *)infoList[i].imageLoadAddress)) &#123; found = true; break; &#125; &#125; if (!found) return nil; // 如果没有找到，就直接返回 nil // Discover load methods &#123; // 加上括号，是为了 runtimeLock 锁，可以在这个块内自动释放，否则下次重入该函数时，会死锁 rwlock_writer_t lock2(runtimeLock); // runtimeLock 加写锁 // 做一些准备工作，将需要 +load 的类和分类分别存储到 loadable_classes、loadable_categories 中， // 在 call_load_methods() 中才有类可以调 +load // 并进一步确认是否真的有类或分类需要调用 +load found = load_images_nolock(state, infoCount, infoList); &#125; // Call +load methods (without runtimeLock - re-entrant) // 不加 runtimeLock 锁，是因为 runtimeLock 与递归锁不一样，它是不可重入的， // 因为 load_images 中调用 +load 时，会导致其他镜像被 load， // 即 load_images 函数会在一个线程上被接连调用多次，如果加上 runtimeLock，就会造成死锁 if (found) &#123; // 确实有类或分类需要 +load call_load_methods(); // 就调用 +load &#125; return nil;&#125; 这个函数分为三部分工作： hasLoadMethods 判断是否有load函数 load_images_nolock 将load的信息添加到全局数据结构中 call_load_methods 调用load方法 判断是否含有load方法123456789bool hasLoadMethods(const headerType *mhdr)&#123; size_t count; // 扫描类列表 if (_getObjc2NonlazyClassList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; // 扫描分类列表 if (_getObjc2NonlazyCategoryList(mhdr, &amp;count) &amp;&amp; count &gt; 0) return true; return false;&#125; 如果累有load方法，就会被放入objc_nlclslist section，如果分类有load方法，分类就会被放入objc_nlcatlist section，所以判断是否有这两个section，就判断出了是否有load方法 存储含有load方法的类、分类到全局数据中12345678910111213141516171819202122232425bool load_images_nolock(enum dyld_image_states state,uint32_t infoCount, const struct dyld_image_info infoList[])&#123; bool found = NO; uint32_t i; i = infoCount; // 从后往前遍历 infoList 中所有镜像，如果镜像中有 +load 方法（其实只查找了镜像中是否有类或分类） // 就对镜像调用 prepare_load_methods， // 并且记录下有 +load 方法，只要有一个镜像有 +load ，就返回 YES while (i--) &#123; const headerType *mhdr = (headerType*)infoList[i].imageLoadAddress; if (!hasLoadMethods(mhdr)) continue; // 为 +load 做一些准备工作 // 将需要 +load 的类添加到 loadable_classes 列表， // 将需要 +load 的分类添加到 loadable_categories 列表 prepare_load_methods(mhdr); found = YES; &#125; return found;&#125; 调用prepare_load_methods 保存信息。 prepare_load_methods(const headerType *mhdr)12345678910111213141516171819202122232425262728&#123; size_t count, i; runtimeLock.assertWriting(); // runtimeLock 需要事先加好写锁（是在 load_images() 中加的锁） // 获得镜像中所有 objective-2.0 且是非惰性的 类的 列表 classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); // 遍历类列表，先取得重映射的类，然后调用 schedule_class_load 函数将其添加到 loadable_classes 列表中 for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; // 取得分类列表 category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); // 遍历分类列表 for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); // 取得 分类所属的类 所对应的 重映射类 if (!cls) continue; // category for ignored weak-linked class // cls == nil，即 cat-&gt;cls 是 ignored weak-linked 类，就跳过 realizeClass(cls); // 将 cls 类 realize 了，里面当然也会一并 realize 了 cls 的祖宗类和元类 assert(cls-&gt;ISA()-&gt;isRealized()); // 确认 realizeClass 是否已经将 cls 的元类也一并 realize 了， // 见 realizeClass() add_category_to_loadable_list(cat); // 将分类 cat 添加到 loadable_categories 列表中 &#125;&#125; 这个函数完成的功能有两个： 调用schedule_class_load 将含有 +load 的类添加到 loadable_classes 列表； 调用add_category_to_loadable_list 将含有 +load 的分类添加到 loadable_categories 列表 保存含有load方法的类到loadable_classes123456789101112131415161718// 保证 loadable_classes 列表中，父类在前，子类在后，父类的 +load 先被调用static void schedule_class_load(Class cls)&#123; if (!cls) return; // cls 为 nil，这会出现在根类的时候，结束递归 assert(cls-&gt;isRealized()); // cls 必须已经是 realize 的，即 realize 在 load 之前， // realize 是在 _read_images() 中做的 if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // 如果该类已经被 load 过了，就直接返回，结束递归 // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); // 递归，确保在 loadable_classes 列表中父类排在前面 add_class_to_loadable_list(cls); // 将 cls 类添加到 loadable_classes 列表中 // 其中会检查 cls 类是否确实有 +load 方法，只有拥有 +load 方法，才会将其添加到 loadable_classes 列表 cls-&gt;setInfo(RW_LOADED); // 将 cls 类设置为已经 load&#125; schedule_class_load 将含有 +load 的类添加到 loadable_classes 列表，需要注意的是：，父类在前，子类在后，父类的 +load 先被调用。内部调用add_class_to_loadable_list 添加到loadable_classes列表中。 12345678910111213141516171819202122232425262728293031323334void add_class_to_loadable_list(Class cls)&#123; IMP method; loadMethodLock.assertLocked(); // loadMethodLock 需要事先加锁 method = cls-&gt;getLoadMethod(); // 取得 cls 类的 +load 方法的 imp if (!method) return; // Don't bother if cls has no +load method // 如果 cls 类压根儿就没有 +load 方法，那也没有将其添加到 loadable_classes 列表的必要 // 直接返回 if (PrintLoading) &#123; _objc_inform(\"LOAD: class '%s' scheduled for +load\", cls-&gt;nameForLogging()); &#125; // 如果 loadable_classes 列表已经满了 if (loadable_classes_used == loadable_classes_allocated) &#123; // 重新计算一下新的大小 loadable_classes_allocated = loadable_classes_allocated*2 + 16; // 重新开辟新的内存空间，并将原来的数据拷贝过去 loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; // cls 插入到列表末尾 loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++; // 元素数量 +1&#125; 调用getLoadMethod 获取cls 的load方法的函数指针。然后将cls、method 放入到loadable_classes中。 123456789101112131415161718192021222324IMP objc_class::getLoadMethod()&#123; runtimeLock.assertLocked(); // runtimeLock 需要事先加锁 const method_list_t *mlist; assert(isRealized()); // 该类必须是 realized 过的 assert(ISA()-&gt;isRealized()); // 元类也必须是 realized 过的 assert(!isMetaClass()); // 该类不能是元类 assert(ISA()-&gt;isMetaClass()); // 该类的 isa 必须是元类 mlist = ISA()-&gt;data()-&gt;ro-&gt;baseMethods(); // +load 是类方法，所以存在了元类中，取出元类的 ro 中的方法列表 if (mlist) &#123; for (const auto&amp; meth : *mlist) &#123; // 遍历元类的方法列表， const char *name = sel_cname(meth.name); if (0 == strcmp(name, \"load\")) &#123; // 寻找名字叫 \"load\" 的方法 return meth.imp; // 如果找到了，就返回该方法的 imp &#125; &#125; &#125; return nil; // 找不到就返回 nil&#125; getLoadMethod 函数循环比较元类中ro中的baseMethods，如果方法名称一样，就返回对应的IMP。 保存含有load方法的分类到loadable_categories1234567891011121314151617181920212223242526272829// 将分类 cat 添加到 loadable_categories 列表中void add_category_to_loadable_list(Category cat)&#123; IMP method; loadMethodLock.assertLocked(); method = _category_getLoadMethod(cat); // Don't bother if cat has no +load method if (!method) return; if (PrintLoading) &#123; _objc_inform(\"LOAD: category '%s(%s)' scheduled for +load\", _category_getClassName(cat), _category_getName(cat)); &#125; if (loadable_categories_used == loadable_categories_allocated) &#123; loadable_categories_allocated = loadable_categories_allocated*2 + 16; loadable_categories = (struct loadable_category *) realloc(loadable_categories, loadable_categories_allocated * sizeof(struct loadable_category)); &#125; loadable_categories[loadable_categories_used].cat = cat; loadable_categories[loadable_categories_used].method = method; loadable_categories_used++;&#125; 调用_category_getLoadMethod 获取分类中load方法的IMP，然后将cat、method放入到loadable_categories 1234567891011121314151617181920// 取得分类的 +load 方法对应的 imp，如果没有 +load 方法，就返回 nilIMP _category_getLoadMethod(Category cat)&#123; runtimeLock.assertLocked(); // runtimeLock 需要事先加锁 const method_list_t *mlist; mlist = cat-&gt;classMethods; // 取得分类的类方法列表，因为 +load 也是类方法，位于类方法列表中 if (mlist) &#123; for (const auto&amp; meth : *mlist) &#123; // 遍历类方法列表，查找名为 \"load\" 的方法 const char *name = sel_cname(meth.name); if (0 == strcmp(name, \"load\")) &#123; return meth.imp; // 如果找到了，就将方法的 imp 返回 &#125; &#125; &#125; return nil; // 没有 +load 方法，就返回 nil&#125; call_load_methods 获取分类classMethods中方法列表，循环比较方法名称，如果一致，返回方法的IMP。 调用load方法123456789101112131415161718192021222324252627282930// 这个函数中调用类的 +load 方法void call_load_methods(void)&#123; static bool loading = NO; bool more_categories; loadMethodLock.assertLocked(); // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; 调用类的load方法12345678910111213141516171819202122232425static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; // 先将列表暂存起来，即另一个指针指向列表的内存 int used = loadable_classes_used; // 暂存列表中类的数量 loadable_classes = nil; // loadable_classes 指向指向 nil，与原来的列表脱离关系 loadable_classes_allocated = 0; // 容量清零 loadable_classes_used = 0; // 类的个数清零 // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; // 遍历暂存的列表 Class cls = classes[i].cls; // 取得该类的 +load 方法的 imp load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; // 如果 imp 不存在，没得玩，跳过 // 一般情况下，不会这么糟糕，因为 add_class_to_loadable_list() 中对 // 没有 +load imp 的类进行了排除 (*load_method)(cls, SEL_load); // 直接调用 +load 的 imp 函数，跳过 objc_msgSend 速度更快 &#125; // Destroy the detached list. if (classes) free(classes); // 将暂存的列表销毁释放&#125; load方法的调用时直接执行函数指针，所以不存在runtime中的消息转发，对子类发送load消息，不会执行父类中的load方法。这样保证每个类的load方法都只调用一次。 调用分类的load方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// 调用分类中的 +load 方法// 调用者：call_load_methods()static bool call_category_loads(void)&#123; int i, shift; bool new_categories_added = NO; // Detach current loadable list. struct loadable_category *cats = loadable_categories; int used = loadable_categories_used; int allocated = loadable_categories_allocated; loadable_categories = nil; loadable_categories_allocated = 0; loadable_categories_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Category cat = cats[i].cat; load_method_t load_method = (load_method_t)cats[i].method; Class cls; if (!cat) continue; cls = _category_getClass(cat); if (cls &amp;&amp; cls-&gt;isLoadable()) &#123; (*load_method)(cls, SEL_load); cats[i].cat = nil; &#125; &#125; // Compact detached list (order-preserving) shift = 0; for (i = 0; i &lt; used; i++) &#123; if (cats[i].cat) &#123; cats[i-shift] = cats[i]; &#125; else &#123; shift++; &#125; &#125; used -= shift; // Copy any new +load candidates from the new list to the detached list. new_categories_added = (loadable_categories_used &gt; 0); for (i = 0; i &lt; loadable_categories_used; i++) &#123; if (used == allocated) &#123; allocated = allocated*2 + 16; cats = (struct loadable_category *) realloc(cats, allocated * sizeof(struct loadable_category)); &#125; cats[used++] = loadable_categories[i]; &#125; // Destroy the new list. if (loadable_categories) free(loadable_categories); // Reattach the (now augmented) detached list. // But if there's nothing left to load, destroy the list. if (used) &#123; loadable_categories = cats; loadable_categories_used = used; loadable_categories_allocated = allocated; &#125; else &#123; if (cats) free(cats); loadable_categories = nil; loadable_categories_used = 0; loadable_categories_allocated = 0; &#125; return new_categories_added;&#125; 首先将全局中的信息拷贝处理啊，调用分类的load方法。 调用完成之后就将cats[i]中的cat 置位 nil， 对于那些不符合调用load方法的分类不做处理， 这样就会剩下一部分分类。 下面就是整合剩下的分类和新添加到loadable_categories的分类为新的结构。 上面说明的了分类中的load方法也会调用。并且分类中的load方法不会覆盖本类中的load方法。 总体的流程图 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer Xcode 10 下如何调试objc4-723","tags":[{"name":"load_images","slug":"load-images","permalink":"http://yoursite.com/tags/load-images/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"9. _read_images 从二进制文件中读取类信息","date":"2018-11-27T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/9__read_images/","text":"_read_images从镜像文件中读取所有类信息、方法信息、分类信息。这篇文章就介绍具体读取了什么信息。 背景Mach-O 运行的时候，通过dylb加载到内存，须进一步提取出详细的信息，进而使用Mach-O中的类、方法。dylb加载完Mach-O文件后，通知runtime，调用_read_images ，_read_images就是将Mach-O文件中的DATA segment中的数据读入到对应的数据结构中，方便使用。 读取的所有section： _read_images函数 代码分析读取Mach-O指定Section的基础设施首先登场的是GETSECT，位于objc-file.mm文件中，GETSECT宏可以生成不同的函数。函数名为name，这些函数完成读取Mach-O文件指定Section的内容。 1234567#define GETSECT(name, type, sectname) \\type *name(const headerType *mhdr, size_t *outCount) &#123; \\ return getDataSection&lt;type&gt;(mhdr, sectname, nil, outCount); \\&#125; \\type *name(const header_info *hi, size_t *outCount) &#123; \\ return getDataSection&lt;type&gt;(hi-&gt;mhdr, sectname, nil, outCount); \\&#125; 内部会调用getDataSection 函数。 12345678910111213141516template &lt;typename T&gt;T* getDataSection(const headerType *mhdr, const char *sectname, size_t *outBytes, size_t *outCount)&#123; unsigned long byteCount = 0; T* data = (T*)getsectiondata(mhdr, \"__DATA\", sectname, &amp;byteCount); if (!data) &#123; data = (T*)getsectiondata(mhdr, \"__DATA_CONST\", sectname, &amp;byteCount); &#125; if (!data) &#123; data = (T*)getsectiondata(mhdr, \"__DATA_DIRTY\", sectname, &amp;byteCount); &#125; if (outBytes) *outBytes = byteCount; if (outCount) *outCount = byteCount / sizeof(T); return data;&#125; getDataSection 函数会读取DATA、DATA_CONST、__DATA_DIRTY Segement中名为sectname的section。 下面是使用GETSECT定义的函数列表。 1234567891011// function name content type section nameGETSECT(_getObjc2SelectorRefs, SEL, \"__objc_selrefs\"); GETSECT(_getObjc2MessageRefs, message_ref_t, \"__objc_msgrefs\"); GETSECT(_getObjc2ClassRefs, Class, \"__objc_classrefs\");GETSECT(_getObjc2SuperRefs, Class, \"__objc_superrefs\");GETSECT(_getObjc2ClassList, classref_t, \"__objc_classlist\");GETSECT(_getObjc2NonlazyClassList, classref_t, \"__objc_nlclslist\");GETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");GETSECT(_getObjc2NonlazyCategoryList, category_t *, \"__objc_nlcatlist\");GETSECT(_getObjc2ProtocolList, protocol_t *, \"__objc_protolist\");GETSECT(_getObjc2ProtocolRefs, protocol_t *, \"__objc_protorefs\"); 上面10行代码定了了10个函数，分别读取10种section的内容。例如_getObjc2ClassList 函数，会读取 __objc_classlist section，也就是读取镜像中的所有类的列表。 这些函数下面都会用到，是这篇文章的基础。 首次执行任务—申请存放类的映射表_read_images 定义如下： 1void _read_images(header_info **hList, uint32_t hCount) 入参是map_images_nolock函数处理过的、非重复的、镜像列表和个数。下面只介绍重要的代码段，有部分代码会被忽略，全部代码请看OBJC4源码库。 12345678910111213141516171819202122232425262728293031 if (!doneOnce) &#123; // 这个块里的代码只会执行一次 doneOnce = YES; .... // Count classes. Size various table based on the total. // 计算类的总数 int total = 0; // 总数 int unoptimizedTotal = 0; // 未优化的类的总数，不包括处于 shared cache 中的类 for (EACH_HEADER) &#123; // 遍历 hList if (_getObjc2ClassList(hi, &amp;count)) &#123; // 获得 header 中所有 objective-2.0 类的列表 total += (int)count; // 总数累加 if (!hi-&gt;inSharedCache) &#123; // 如果 header 不在 shared cache 的话，未优化的类的总数累加 unoptimizedTotal += count; &#125; &#125; &#125; // gdb_objc_realized_classes 中装的是不在 shared cache 中的类，所以如果经过了预优化， // 那么就只考虑未优化的那些类，即 unoptimizedTotal，否则考虑全部类 total int namedClassesSize = (isPreoptimized() ? unoptimizedTotal : total) * 4 / 3; gdb_objc_realized_classes = NXCreateMapTable(NXStrValueMapPrototype, namedClassesSize); // realizedClasses and realizedMetaclasses - less than the full total realized_class_hash = NXCreateHashTable(NXPtrPrototype, total / 8, nil); realized_metaclass_hash = NXCreateHashTable(NXPtrPrototype, total / 8, nil);&#125; 1GETSECT(_getObjc2ClassList, classref_t, \"__objc_classlist\"); 1234#define EACH_HEADER \\ hIndex = 0; \\ crashlog_header_name(nil) &amp;&amp; hIndex &lt; hCount &amp;&amp; (hi = hList[hIndex]) &amp;&amp; crashlog_header_name(hi); \\ hIndex++ 上面代码完成的工作： 这段代码只有第一次进入_read_images才执行，只能执行一次； 通过_getObjc2ClassList函数获取__objc_classlist section中的所有类的总数 total、不在shared cache中的类的个数unoptimizedTotal； 创建gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个hash表， 容量由total、unoptimizedTotal 决定。 gdb_objc_realized_classes、realized_class_hash、realized_metaclass_hash三个表的结构如下： 读取__objc_classlist（所有类列表，存储到gdb_objc_realized_classes map中12345678910111213141516171819202122232425262728293031323334///代码位于objc-runtime-new文件中for (EACH_HEADER) &#123; // 遍历 hList bool headerIsBundle = hi-&gt;isBundle(); // header 是否是 bundle 类型 bool headerIsPreoptimized = hi-&gt;isPreoptimized(); // header 是否经过预优化 // 取出 header 中的所有的 objective-c 2.0 的类 classref_t *classlist = _getObjc2ClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; // 遍历类列表 Class cls = (Class)classlist[i]; // 读取该类，会做一些处理，取得新类(逻辑很复杂，完全懵圈) Class newCls = readClass(cls, headerIsBundle, headerIsPreoptimized); // 如果获得的是一个非空的新类 if (newCls != cls &amp;&amp; newCls) &#123; // Class was moved but not deleted. Currently this occurs // only when the new class resolved a future class. // Non-lazily realize the class below. // 类被移动了，但是没有被删除， // 这只会发生在新类 resolve 了一个 future 类的情况下 // 下面以非惰性的方法 realize 了 newCls // 为 resolvedFutureClasses 数组重新开辟一块更大的空间，并将原来的数据拷贝进来 resolvedFutureClasses = (Class *) realloc(resolvedFutureClasses, (resolvedFutureClassCount+1) * sizeof(Class)); // 将 newCls 添加到数组的末尾，resolvedFutureClassCount 加 1 resolvedFutureClasses[resolvedFutureClassCount++] = newCls; &#125; &#125;&#125;GETSECT(_getObjc2ClassList, classref_t, \"__objc_classlist\"); 这段代码循环所有镜像，通过_getObjc2ClassList函数，读取每个镜像中的__objc_classlist section中的所有类，然后对每个类调用readClass函数。readClass如果返回的类是future类，存储到resolvedFutureClasses数组中，后面会实现这些future类。 __objc_classlist 理解首先创建一个命令行程序，添加如下代码： 123456789101112131415161718@interface LJPersion : NSObject@end@implementation LJPersion+ (NSString*) classMethod&#123; return nil;&#125;- (NSString *) instanceMethod&#123; return nil;&#125;@end 编译完成后，使用mashOView 查看__objc_classlist内容： __objc_classlist 就是这个镜像中所有的类的列表，我新建的程序只有一个类LJPersion，根据图所示，LJPersion 应该存储在0x0000000100001150中， 然后用hopper 查看0x0000000100001150处的内容，验证存储的内容是否是LJPersion类。 可以确定0x0000000100001150地址存储的内容就是LJPersion类，同时可以看出类的数据中保存着instanceMethod方法，元类中保存着classMethod方法。 readClass代码分析通过classref_t *classlist = _getObjc2ClassList(hi, &amp;count);将 hi表示的镜像中的所有类读取到classlist中，然后对classlist中的每个类调用readClass函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/*********************************************************************** 读取一个编译器写的 类 或 元类， 返回新类的指针，有可能是： - cls - nil (cls 有一个 missing weak-linked 的父类) - 同名的 future 类，该 future 类填充了 cls 类的信息 调用者：_read_images() / objc_readClassPair()**********************************************************************/Class readClass(Class cls, bool headerIsBundle/*是否是 bundle*/, bool headerIsPreoptimized/*是否被预优化过，即是否来自 shared cache*/)&#123; const char *mangledName = cls-&gt;mangledName(); // 取得 cls 的重整后的名字 if (missingWeakSuperclass(cls)) &#123; // 查看 cls 类的祖宗类中是否有类是 weak-linked 的，并且已经 missing // 祖宗类里有 missing weak-linked 的 // 则 cls 的所有信息也是不可信的，所以将其添加到重映射表里，映射为nil，即 cls -&gt; nil addRemappedClass(cls, nil); // 将其添加到重映射表里，映射为nil cls-&gt;superclass = nil; // 父类指针指向 nil return nil; &#125; Class replacing = nil; // 记录被代替的类 // 尝试将 mangledName 对应的 future 的类从 future_named_class_map 中弹出 // 如果返回的 newCls 有值，则 newcls 类是以前开辟的一个同名的 future 类， // 这个 future 类现在得到了兑现，因为有一个同名的新类 cls 进来了， // future 类里的信息会由 cls 中的信息填充（原来 future 类只开辟了内存，里面其实是啥都没的） // 并将 cls 代替 if (Class newCls = popFutureNamedClass(mangledName)) &#123; // This name was previously allocated as a future class. // Copy objc_class to future class's struct. // Preserve future's rw data block. // 但是 newcls 不能是 swift 类，因为太大了？啥意思？swift类能有多大 if (newCls-&gt;isSwift()) &#123; _objc_fatal(\"Can't complete future class request for '%s' \" \"because the real class is too big.\", cls-&gt;nameForLogging()); &#125; class_rw_t *rw = newCls-&gt;data(); // 取得 newCls 中的 rw，rw 中除了 ro 外的其他数据是需要保留的 const class_ro_t *old_ro = rw-&gt;ro; // 旧的 ro memcpy(newCls, cls, sizeof(objc_class)); // 将 cls 中的数据完整得拷贝到 newCls 中 rw-&gt;ro = (class_ro_t *)newCls-&gt;data(); // rw 中使用新的 ro newCls-&gt;setData(rw); // 将 rw 赋给 newCls，那么 newCls 中使用的还是原来的 rw，只是其中的 ro 变了 free((void *)old_ro-&gt;name); // 旧 ro 中的 name 是在堆上分配的，所以需要释放 free((void *)old_ro); // 将旧 ro 释放 addRemappedClass(cls, newCls); // 将 cls -&gt; newCls 的重映射添加到映射表中 replacing = cls; // 记录下 cls 类被代替 cls = newCls; // 新类 newCls 赋给 cls &#125; if (headerIsPreoptimized &amp;&amp; !replacing) &#123; // 预优化过，且没有被代替 assert(getClass(mangledName)); &#125; else &#123; // 否则将 mangledName -&gt; cls 的映射添加到 gdb_objc_realized_classes 表中 // 如果上 cls 被 newCls 代替了，那么 replacing 就是老的 cls，即在 gdb_objc_realized_classes 中 // 也会将老的 cls 代替 addNamedClass(cls, mangledName, replacing); &#125; // for future reference: shared cache never contains MH_BUNDLEs if (headerIsBundle) &#123; cls-&gt;data()-&gt;flags |= RO_FROM_BUNDLE; cls-&gt;ISA()-&gt;data()-&gt;flags |= RO_FROM_BUNDLE; &#125; return cls;&#125; 主要的完成的任务用下图表示： 其中missingWeakSuperclass 确定cls的祖宗类是否缺失： 123456789101112131415161718192021222324// 判断 cls 类的祖宗类中是否有类是 weak-linked 的，或者说已经 missing(丢失)// 这是一个递归函数static bool missingWeakSuperclass(Class cls)&#123; assert(!cls-&gt;isRealized()); // cls 不能是已经 realized 的类，因为 realized 的类一定是正常的 if (!cls-&gt;superclass) &#123; // 如果没有父类，则看它是否是根类，若是根类，那么就是正常的，否则它的父类就是丢了 // 结束递归 // superclass nil. This is normal for root classes only. return (!(cls-&gt;data()-&gt;flags &amp; RO_ROOT)); &#125; else &#123; // superclass not nil. Check if a higher superclass is missing. // 如果有父类，则递归调用一直向上查找祖宗类，看是否有丢的了 Class supercls = remapClass(cls-&gt;superclass); // 取得重映射的父类，如果父类是 weak-link 的， // 则 remapClass 会返回 nil assert(cls != cls-&gt;superclass); // 这两个断言很奇怪，完全想不到什么奇葩情况下这两个断言会不成立 assert(cls != supercls); if (!supercls) return YES; // 如果父类是 weak-link 的，则 supercls 为 nil，返回 YES，结束递归 if (supercls-&gt;isRealized()) return NO; // 如果父类已经被 realized，则直接返回 NO，因为 realized 的类一定是正常的 // 结束递归 return missingWeakSuperclass(supercls); // 否则递归寻找祖宗类们 &#125;&#125; 在重映射表中查找key为cls的类： 1234567891011121314151617181920212223// 返回 cls 类的 live class（活动的类）指针，这个指针可能指向一个已经被 reallocated 的结构体（#疑问：什么意思？？）// 若 cls 是 weak linking（弱连接），则 cls 会被忽略，而返回 nil// 调用者 ：_class_remap() / missingWeakSuperclass() / realizeClass() /// remapClass() / remapClassRef()static Class remapClass(Class cls)&#123; runtimeLock.assertLocked(); Class c2; // 这里没有初始化为 nil，有没有可能指向一块垃圾内存？？ if (!cls) return nil; // 如果 cls 是 nil，则直接返回 nil NXMapTable *map = remappedClasses(NO); // 取得 remapped_class_map 映射表，若为空，不创建 // 如果 map 非空，或者 cls 不是一个 key，NX_MAPNOTAKEY(not a key)，即 cls 压根儿不在 remapped_class_map 映射表里 // 则将 cls 返回 if (!map || NXMapMember(map, cls, (void**)&amp;c2) == NX_MAPNOTAKEY) &#123; return cls; &#125; else &#123; return c2; // 1. 如果 map 是空，则返回的 c2 == nil（#疑问：有没有可能是垃圾内存？？），因为 || 的断路特点，后面的代码不会执行 // 2. 如果 map 不为空，并且 cls 确实是 remapped_class_map 中的 key，则 c2 就是取得的 value // 但是其中 key 如果是 ignored weak-linked class 的话，c2 就是 nil &#125;&#125; remapClass 函数功能是： 从remapped_class_map表中取key为cls的内容。 如果表位空，或者表中没有，直接返回cls，否则返回表中内容。 addRemappedClass 添加成员到重映射表： 12345678910111213// 添加一个 remapped 的类到 remapped_class_map 映射表中// newcls 是一个已经被 realized 的 future 类，oldcls 是老的 future 类// 或者 newcls 是 nil，oldcls 是 ignored weak-linked 类static void addRemappedClass(Class oldcls, Class newcls)&#123; .... void *old; // 将 oldcls 为 key，newcls 为 value 插入到 remapped_class_map 映射表 中， // remappedClasses(YES) 中 YES 是指定如果 remapped_class_map 为空的话，就创建一个 old = NXMapInsert(remappedClasses(YES), oldcls, newcls); assert(!old); // old 不能为空&#125; 将oldcls：newcls 添加到 重映射remapped_class_map表中。 popFutureNamedClass 函数定义如下: 12345678910111213141516171819202122232425// 将指定 name 对应的 future 类从 future_named_class_map 中移除// 因为 这个类 已经被 realized 过了，它已经不再处于 future 状态// 返回 name 对应的 future class，如果没有对应的 future class，就返回 nil// caller : readClass()static Class popFutureNamedClass(const char *name)&#123; runtimeLock.assertWriting(); Class cls = nil; if (future_named_class_map) &#123; // 如果 future_named_class_map 非空 // 利用 key name 将 future class 从 future_named_class_map 移除 // NXMapKeyFreeingRemove 与 NXMapRemove 功能一样，但是会释放 key，因为 key 是在堆中分配的，原因见 NXMapKeyCopyingInsert() cls = (Class)NXMapKeyFreeingRemove(future_named_class_map, name); // 如果 name 确实有对应的 future class，并且当前 future_named_class_map 已经空了 // 就将 future_named_class_map 释放 if (cls &amp;&amp; NXCountMapTable(future_named_class_map) == 0) &#123; NXFreeMapTable(future_named_class_map); future_named_class_map = nil; // 防止野指针 &#125; &#125; return cls;&#125; 从future_named_class_map中弹出指定名称的类。 123456789101112131415161718192021222324252627282930313233/************************************************************************ addNamedClass* Adds name =&gt; cls to the named non-meta class map.* Warns about duplicate class names and keeps the old mapping.* Locking: runtimeLock must be held by the caller 添加 name -&gt; cls 对到 named non-meta class map（gdb_objc_realized_classes）中 警告有副本，但是会保持老的映射，即会有多份， 新的映射被存在了 secondary metaclass map(二级元类映射表) 表中，见 addNonMetaClass()， replacing : 被代替的老的 cls (见 readClass()) 如果有旧映射，但是与 replacing 不符合，还是会保留旧映射， 否则新值会将 gdb_objc_realized_classes 中的旧映射覆盖 调用者：objc_duplicateClass() / objc_registerClassPair() / readClass()**********************************************************************/static void addNamedClass(Class cls, const char *name, Class replacing = nil)&#123; runtimeLock.assertWriting(); Class old; // 先根据 name 查找是否有对应的旧类，如果有，并且 old 与 replacing 不同 // 则报警告，但是会保持老的映射，插入新的映射 if ((old = getClass(name)) &amp;&amp; old != replacing) &#123; inform_duplicate(name, old, cls); // 给出警告：名字为 name 的类有两份实现，但只有一份会被使用 // getNonMetaClass uses name lookups. Classes not found by name // lookup must be in the secondary meta-&gt;nonmeta table. addNonMetaClass(cls); // 将 cls 存入 matacls-&gt;cls 的二级映射表中 &#125; else &#123; // 如果没有旧值，或者指定要覆盖旧值（replacing == old），就将新的 name-&gt;cls 对插入 gdb_objc_realized_classes NXMapInsert(gdb_objc_realized_classes, name, cls); &#125; assert(!(cls-&gt;data()-&gt;flags &amp; RO_META)); // cls 不能是元类&#125; 将类添加到一级或者二级缓存中。 readClass 做了下面三件事： 如果class的祖宗类丢失，将类添加到NXMapTable *remapped_class_map表中，key是cls，value是nil。 最后直接返回 nil。 从future_named_class_map中查找cls是否是future类，如果是，通过cls实现future类，然后将结果添加到remapped_class_map中，key是cls，value是实现完成的future类——newCls。 同时调用addNamedClass函数，将newCls添加到gdb_objc_realized_classes或 nonmeta_class_map表中。 其他情况，直接调用addNamedClass函数，将类添加到gdb_objc_realized_classes或nonmeta_class_map表中。 返回cls。 一般代码走这一步。 下面是这段代码使用的几个新表: 将类读取到gdb_objc_realized_classes的意义为了说明读取类到gdb_objc_realized_classes的意义，举个例子，objc_getClass函数就是通过名字获取对应的类： 1234567Class objc_getClass(const char *aClassName)&#123; if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES);&#125; 内部调用 look_up_class 函数： 123456789101112131415161718192021Class look_up_class(const char *name, bool includeUnconnected __attribute__((unused)), bool includeClassHandler __attribute__((unused)))&#123; if (!name) return nil; // 类名不能为 nil，否则不能查 Class result; bool unrealized; &#123; // 加函数块是为了能实现自动释放 runtimeLock 锁，下面也一样 rwlock_reader_t lock(runtimeLock); // 加读锁 result = getClass(name); // 利用 getClass 函数查找类 unrealized = result &amp;&amp; !result-&gt;isRealized(); // 如果找到了类，且类没有被 realize，就标记为 unrealized &#125; if (unrealized) &#123; // 类存在，且没有被 realize rwlock_writer_t lock(runtimeLock); // 加写锁 realizeClass(result); // 将类 realize 了 &#125; return result;&#125; 内部调用 getClass函数 123456789101112131415161718192021222324// 根据 name 查找类，实际上调用的还是 getClass_impl，但是需要对 swift 的类做一些处理static Class getClass(const char *name)&#123; runtimeLock.assertLocked(); // 必须事先被加锁 // Try name as-is Class result = getClass_impl(name); // 先直接用 name 查找 if (result) &#123; return result; // 找到直接返回 &#125; // 如果找不到，就处理成 swift 类的 mangled name 试试 // Try Swift-mangled equivalent of the given name. if (char *swName = copySwiftV1MangledName(name)) &#123; // 尝试转成 swift mangled name，函数里判断 name 是否符合 // swift unmangled name(重整前的名字) 的格式，如果符合就返回 mangled name， // 否则返回 nil result = getClass_impl(swName); // 用 mangled name 再去找 free(swName); // 将 swName 释放，原因见 copySwiftV1MangledName() return result; // 不用再判断 result 是否有值，直接将它返回 &#125; return nil; // 如果连 swift 类都不是，就返回 nil&#125; 内部调用getClass_impl 函数 1234567891011121314151617181920// 根据名字查找类，这个类可能没有被 realize 过// 该函数被 getClass() 函数调用static Class getClass_impl(const char *name)&#123; runtimeLock.assertLocked(); // 必须事先被加锁 // allocated in _read_images assert(gdb_objc_realized_classes); // gdb_objc_realized_classes 是在 _read_images() 函数中被初始化的(分配内存) // Try runtime-allocated table // 从 gdb_objc_realized_classes 根据 key 即 name 查找类 Class result = (Class)NXMapGet(gdb_objc_realized_classes, name); if (result) &#123; return result; // 找到了，就将其返回 &#125; // Try table from dyld shared cache // 如果在 gdb_objc_realized_classes 中找不到，就去预优化的类中找找看（跟 dyld shared cache 有关） return getPreoptimizedClass(name);&#125; 这里面就是使用了gdb_objc_realized_classes。 读取_getObjc2ClassRefs、_getObjc2SuperRefs（使用的类、父类），修正重映射类表12345678910111213141516171819202122// Fix up remapped classes// Class list and nonlazy class list remain unremapped.// Class refs and super refs are remapped for message dispatching. // 如果 remapped_class_map 不是空的if (!noClassesRemapped()) &#123; for (EACH_HEADER) &#123; // 遍历 hList // 取得 header 中所有的类引用 Class *classrefs = _getObjc2ClassRefs(hi, &amp;count); // 遍历这些类引用，fix-up 类引用，从重映射类表中取出新类，如果旧类新类不一致，就将新类赋给这个类引用 for (i = 0; i &lt; count; i++) &#123; remapClassRef(&amp;classrefs[i]); &#125; // fixme why doesn't test future1 catch the absence of this? // 取得镜像中所有类的父类引用 classrefs = _getObjc2SuperRefs(hi, &amp;count); // 遍历父类引用，将其 fix-up 了 for (i = 0; i &lt; count; i++) &#123; remapClassRef(&amp;classrefs[i]); &#125; &#125;&#125; 通过_getObjc2ClassRefs、_getObjc2SuperRefs读取objc_classrefs、objc_superrefs， 也就是读取程序中引用的类、父类，将classrefs分别调用remapClassRef，修正重映射表——–remapped_class_map。 12345678910111213141516171819/************************************************************************ remapClassRef* Fix up a class ref, in case the class referenced has been reallocated * or is an ignored weak-linked class.* Locking: runtimeLock must be read- or write-locked by the caller**********************************************************************/// fix-up 一个类引用，万一这个类引用指向的类已经被 reallocated(重新分配？) 或者它是一个 ignored weak-linked 类// 从重映射类表中用 *clsref 为 key 取出新类，如果 *clsref 不等于新类，则将新类赋给 *clsref// clsref 是一个二级指针，它指向一个类的指针// 调用者 ：_read_images()static void remapClassRef(Class *clsref)&#123; runtimeLock.assertLocked(); Class newcls = remapClass(*clsref); // 用 *clsref 为 key 从重映射类表中取出新类 if (*clsref != newcls) &#123; // 如果 *clsref 不等于新类，则将新类赋给 *clsref *clsref = newcls; &#125;&#125; __objc_classrefs在Mach-O的结构如下。 读取__objc_selrefs（方法列表）–将读取的方法注册到namedSelectors表中12345678910111213141516// Fix up @selector references fixup @selector 引用static size_t UnfixedSelectors; // 记录 hList 中所有镜像中一共有多少 unfixed 的 selectorsel_lock(); // selLock 上写锁for (EACH_HEADER) &#123; // 遍历 hList // 只处理没有预优化的，被预优化过的就跳过 if (hi-&gt;isPreoptimized()) continue; bool isBundle = hi-&gt;isBundle(); // 是否是 bundle // 取得镜像中所有的 selector 引用 SEL *sels = _getObjc2SelectorRefs(hi, &amp;count); UnfixedSelectors += count; // 累加 for (i = 0; i &lt; count; i++) &#123; // 遍历刚才取出的 selector const char *name = sel_cname(sels[i]); // 转为char * 字符串 sels[i] = sel_registerNameNoLock(name, isBundle); // 注册这个 selector 的名字 &#125;&#125; 读取Mach-O中的__objc_selrefs section，调用sel_registerNameNoLock方法注册。 1234567891011121314151617181920212223242526272829// 注册 SEL 的名字，不加锁SEL sel_registerNameNoLock(const char *name, bool copy) &#123; return __sel_registerName(name, 0, copy); // NO lock, maybe copy&#125;/ 注册 SEL 的名字，能决定是否加锁和拷贝，拷贝即是否深拷贝 name，见 sel_alloc()// 调用者：sel_getUid() / sel_registerName() / sel_registerNameNoLock()static SEL __sel_registerName(const char *name, int lock, int copy) &#123; SEL result = 0; ... if (!namedSelectors) &#123; namedSelectors = NXCreateMapTable(NXStrValueMapPrototype, (unsigned)SelrefCount); &#125; if (lock) &#123; // Rescan in case it was added while we dropped the lock result = (SEL)NXMapGet(namedSelectors, name); &#125; if (!result) &#123; result = sel_alloc(name, copy); // fixme choose a better container (hash not map for starters) NXMapInsert(namedSelectors, sel_getName(result), result); &#125; if (lock) selLock.unlockWrite(); return result;&#125; sel_registerNameNoLock 内部调用了__sel_registerName方法，将(sel Name：SEL) 对插入到namedSelectors表中。 为啥注册，下面有一段说明 1234* @note You must register a method name with the Objective-C runtime system to obtain the* method’s selector before you can add the method to a class definition. If the method name* has already been registered, this function simply returns the selector.* 这里有一个新的表，结构如下： 读取的Mach-O 中__objc_selrefs 的内容如下： 将SEL存储到namedSelectors Hash表的意义123456789101112/** * Identifies a selector as being valid or invalid. * * @param sel The selector you want to identify. * * @return YES if selector is valid and has a function implementation, NO otherwise. * * @warning On some platforms, an invalid reference (to invalid memory addresses) can cause * a crash. */OBJC_EXPORT BOOL sel_isMapped(SEL sel) __OSX_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); rumtime 提供了这样一个API，判断SEL 是否被映射，可能其他的系统库会调用。 读取__objc_msgrefs（OBJC的消息），修正部分SEL的IMP123456789101112for (EACH_HEADER) &#123; message_ref_t *refs = _getObjc2MessageRefs(hi, &amp;count); if (count == 0) continue; if (PrintVtables) &#123; _objc_inform(\"VTABLES: repairing %zu unsupported vtable dispatch \" \"call sites in %s\", count, hi-&gt;fname); &#125; for (i = 0; i &lt; count; i++) &#123; fixupMessageRef(refs+i); &#125; &#125; 通过 _getObjc2MessageRefs 读取Mach-O文件中的 __objc_msgrefs section。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 修复一个老的 vtable 调度// 调用者：_read_images()static void fixupMessageRef(message_ref_t *msg)&#123; // 注册消息的 sel msg-&gt;sel = sel_registerName((const char *)msg-&gt;sel); if (ignoreSelector(msg-&gt;sel)) &#123; // 如果 sel 是需要被忽略的，就将其 imp 设为 _objc_ignored_method // ignored selector - bypass dispatcher msg-&gt;imp = (IMP)&amp;_objc_ignored_method; &#125; else if (msg-&gt;imp == &amp;objc_msgSend_fixup) &#123; // 如果消息的 imp 是 objc_msgSend_fixup，即指定了需要将 imp fixup if (msg-&gt;sel == SEL_alloc) &#123; msg-&gt;imp = (IMP)&amp;objc_alloc; &#125; else if (msg-&gt;sel == SEL_allocWithZone) &#123; msg-&gt;imp = (IMP)&amp;objc_allocWithZone; &#125; else if (msg-&gt;sel == SEL_retain) &#123; msg-&gt;imp = (IMP)&amp;objc_retain; &#125; else if (msg-&gt;sel == SEL_release) &#123; msg-&gt;imp = (IMP)&amp;objc_release; &#125; else if (msg-&gt;sel == SEL_autorelease) &#123; msg-&gt;imp = (IMP)&amp;objc_autorelease; &#125; else &#123; msg-&gt;imp = &amp;objc_msgSend_fixedup; // 如果上面都不符合，就将它设置为已经 fixed-up 了 &#125; &#125; else if (msg-&gt;imp == &amp;objc_msgSendSuper2_fixup) &#123; msg-&gt;imp = &amp;objc_msgSendSuper2_fixedup; &#125; else if (msg-&gt;imp == &amp;objc_msgSend_stret_fixup) &#123; msg-&gt;imp = &amp;objc_msgSend_stret_fixedup; &#125; else if (msg-&gt;imp == &amp;objc_msgSendSuper2_stret_fixup) &#123; msg-&gt;imp = &amp;objc_msgSendSuper2_stret_fixedup; &#125; #if defined(__i386__) || defined(__x86_64__) else if (msg-&gt;imp == &amp;objc_msgSend_fpret_fixup) &#123; msg-&gt;imp = &amp;objc_msgSend_fpret_fixedup; &#125; #endif#if defined(__x86_64__) else if (msg-&gt;imp == &amp;objc_msgSend_fp2ret_fixup) &#123; msg-&gt;imp = &amp;objc_msgSend_fp2ret_fixedup; &#125; #endif&#125; fixupMessageRef 函数的作用是修正部分SEL的IMP。 读取__objc_protolist（协议列表），添加到protocol_map表中__objc_protolist 理解编写下面代码，展示协议的结构： 12345678910111213141516@protocol LJProtocal &lt;NSObject&gt;@required-(NSString *) instanceMethod;+ (NSString *) calssMethod;@optional-(NSString *) instanceOptMethod;+ (NSString *) calssOptMethod;@property(nonatomic,strong) NSString * strProperty;@end 用machoview查看： 用hopper 查看地址0x 0000000100004260： 源码分析123456789101112131415// Discover protocols. Fix up protocol refs. 取得镜像中的协议，读出协议for (EACH_HEADER) &#123; extern objc_class OBJC_CLASS_$_Protocol; Class cls = (Class)&amp;OBJC_CLASS_$_Protocol; assert(cls); NXMapTable *protocol_map = protocols(); bool isPreoptimized = hi-&gt;isPreoptimized(); bool isBundle = hi-&gt;isBundle(); protocol_t **protolist = _getObjc2ProtocolList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; readProtocol(protolist[i], cls, protocol_map, isPreoptimized, isBundle); &#125;&#125; 通过_getObjc2ProtocolList 读取__objc_protolist section. 将读取的结果分别调用readProtocol函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 读取一个编译器写的协议// 调用者：_read_images()static voidreadProtocol(protocol_t *newproto, Class protocol_class, NXMapTable *protocol_map, bool headerIsPreoptimized, bool headerIsBundle)&#123; // This is not enough to make protocols in unloaded bundles safe, // but it does prevent crashes when looking up unrelated protocols. // 如果镜像是 bundle，就使用 NXMapKeyCopyingInsert 函数，否则使用 NXMapInsert // NXMapKeyCopyingInsert 会在堆中拷贝 key auto insertFn = headerIsBundle ? NXMapKeyCopyingInsert : NXMapInsert; // 根据新协议的重整名称，去 protocol_map 映射表中查找老的协议 protocol_t *oldproto = (protocol_t *)getProtocol(newproto-&gt;mangledName); if (oldproto) &#123; // 如果存在老的协议，就只报个警告，因为不允许有重名的协议 &#125; else if (headerIsPreoptimized) &#123; // 如果不存在老的协议，但是镜像是经过预优化的 // Shared cache initialized the protocol object itself, // but in order to allow out-of-cache replacement we need // to add it to the protocol table now. // 根据新协议的重整名称 查找 预优化的缓存协议 // 但是 getPreoptimizedProtocol 现在一直返回 nil protocol_t *cacheproto = (protocol_t *) getPreoptimizedProtocol(newproto-&gt;mangledName); protocol_t *installedproto; if (cacheproto &amp;&amp; cacheproto != newproto) &#123; // Another definition in the shared cache wins (because // everything in the cache was fixed up to point to it). installedproto = cacheproto; &#125; else &#123; // 因为 cacheproto 永远是 nil，所以一直走 else 分支 // This definition wins. installedproto = newproto; &#125; assert(installedproto-&gt;getIsa() == protocol_class); assert(installedproto-&gt;size &gt;= sizeof(protocol_t)); // 将 新协议的重整名称 -&gt; 新协议 的映射插入 protocol_map 映射表中 insertFn(protocol_map, installedproto-&gt;mangledName, installedproto); &#125; else if (newproto-&gt;size &gt;= sizeof(protocol_t)) &#123; // 如果不存在老的协议，且没有经过预优化，且新协议的大小 // 比 protocol_t 的标准尺寸要大 // New protocol from an un-preoptimized image // with sufficient storage. Fix it up in place. // fixme duplicate protocols from unloadable bundle newproto-&gt;initIsa(protocol_class); // fixme pinned insertFn(protocol_map, newproto-&gt;mangledName, newproto); // 就将 新协议的重整名称 -&gt; 新协议 的映射插入 // protocol_map 映射表中 &#125; else &#123; // 如果不存在老的协议，且没有经过预优化，且新协议的大小比 protocol_t 的标准尺寸要小 // New protocol from an un-preoptimized image // with insufficient storage. Reallocate it. // fixme duplicate protocols from unloadable bundle // 取大的 size，这里按照上面的逻辑，应该是 sizeof(protocol_t) size_t size = max(sizeof(protocol_t), (size_t)newproto-&gt;size); // 新建一个 installedproto 协议，在堆中分配内存，并清零 protocol_t *installedproto = (protocol_t *)calloc(size, 1); // 将 newproto 内存上的内容 拷贝到 installedproto 中 memcpy(installedproto, newproto, newproto-&gt;size); // 将 installedproto-&gt;size 设为新的 size installedproto-&gt;size = (__typeof__(installedproto-&gt;size))size; installedproto-&gt;initIsa(protocol_class); // 设置 isa // fixme pinned // 将 installedproto 插入 protocol_map 映射表中 insertFn(protocol_map, installedproto-&gt;mangledName, installedproto); &#125;&#125; readProtocol 将读取的协议，存储到protocol_map 表中。 存储协议的hash表的介绍如下： 将协议存储到表的作用这里也是举个例子，例如， NSObject的conformsToProtocol 方法，判断当前类是否遵守协议protocol： 1234567- (BOOL)conformsToProtocol:(Protocol *)protocol &#123; if (!protocol) return NO; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (class_conformsToProtocol(tcls, protocol)) return YES; &#125; return NO;&#125; 循环所有当前类–&gt;超类，调用 class_conformsToProtocol方法。 1234567891011121314151617181920BOOL class_conformsToProtocol(Class cls, Protocol *proto_gen)&#123; protocol_t *proto = newprotocol(proto_gen); if (!cls) return NO; if (!proto_gen) return NO; rwlock_reader_t lock(runtimeLock); assert(cls-&gt;isRealized()); for (const auto&amp; proto_ref : cls-&gt;data()-&gt;protocols) &#123; protocol_t *p = remapProtocol(proto_ref); if (p == proto || protocol_conformsToProtocol_nolock(p, proto)) &#123; return YES; &#125; &#125; return NO;&#125; 取出类cls中所有准守的协议，循环调用protocol_conformsToProtocol_nolock，判断两个协议是否一致。 12345678910111213141516171819202122232425262728293031**********************************************************************/static bool protocol_conformsToProtocol_nolock(protocol_t *self, protocol_t *other)&#123; runtimeLock.assertLocked(); if (!self || !other) &#123; return NO; &#125; // protocols need not be fixed up if (0 == strcmp(self-&gt;mangledName, other-&gt;mangledName)) &#123; return YES; &#125; if (self-&gt;protocols) &#123; uintptr_t i; for (i = 0; i &lt; self-&gt;protocols-&gt;count; i++) &#123; protocol_t *proto = remapProtocol(self-&gt;protocols-&gt;list[i]); if (0 == strcmp(other-&gt;mangledName, proto-&gt;mangledName)) &#123; return YES; &#125; if (protocol_conformsToProtocol_nolock(proto, other)) &#123; return YES; &#125; &#125; &#125; return NO;&#125; 如果协议的整合名称mangledName一样，认为协议一致，否则循环self中剩下的协议，只要有一个相同，就认为是遵守。 12345678static protocol_t *remapProtocol(protocol_ref_t proto)&#123; runtimeLock.assertLocked(); protocol_t *newproto = (protocol_t *) getProtocol(((protocol_t *)proto)-&gt;mangledName); return newproto ? newproto : (protocol_t *)proto;&#125; remapProtocol 根据协议的引用在表中找到协议。 1234567891011121314151617static Protocol *getProtocol(const char *name)&#123; runtimeLock.assertLocked(); // Try name as-is. Protocol *result = (Protocol *)NXMapGet(protocols(), name); if (result) return result; // Try Swift-mangled equivalent of the given name. if (char *swName = copySwiftV1MangledName(name, true/*isProtocol*/)) &#123; result = (Protocol *)NXMapGet(protocols(), swName); free(swName); return result; &#125; return nil;&#125; getProtocol 通过协议名称找到协议。 读取__objc_nlclslist（none lazy类），并实现类__objc_nlclslist section中存储着这样的类： 类中还有+load方法 类有静态实例 这样的类会马上使用，所以需要立马初始化。 __objc_nlclslist 介绍 上图说明 如果类中有+load方法，这个类在编译的时候就会放置到__objc_nlclslist section中。 图中上面部分是测试代码，中间部分是machoview查看结果，下面部分是使用hopper查看反汇编地址，证明40e0处存储的是persion类。 源码解析123456789101112// Realize non-lazy classes (for +load methods and static instances)for (EACH_HEADER) &#123; classref_t *classlist = _getObjc2NonlazyClassList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; Class cls = remapClass(classlist[i]); if (!cls) continue; realizeClass(cls); &#125;&#125; 当类中有+load方法、或者类有静态实例，编译器会将类添加到objc_nlclslist section中。 上面代码读取objc_nlclslist 中的所有类，将读出的类调用realizeClass函数实现类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107static Class realizeClass(Class cls)&#123; runtimeLock.assertWriting(); // 看 runtimeLock 是否正确得加了写锁 const class_ro_t *ro; class_rw_t *rw; Class supercls; Class metacls; bool isMeta; if (!cls) return nil; // 如果类已经被 realize 过，就不用 realize 了 if (cls-&gt;isRealized()) &#123; return cls; &#125; assert(cls == remapClass(cls)); // remapClass(cls) 得到的是 cls 对应的重映射类， // 如果 cls 不存在于 remapped_class_map 映射表，得到的才是 cls 本身， // 所以这里断言 cls == remapClass(cls) 就是看 cls 是否存在于 remapped_class_map 映射表 // 不存在，就是正确；存在，就是错误 // 不存在，则 cls 既不是 realized future class，也不是 ignored weak-linked class // 见 remappedClasses() // fixme verify class is not in an un-dlopened part of the shared cache?// 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针// 初始化一个 class_rw_t 结构体// 设置结构体中 ro 的值以及 flag// 最后设置正确的 data。 ro = (const class_ro_t *)cls-&gt;data(); // 因为在 realized 之前，objc_class 中的 class_data_bits_t bits 里 // 本质上存的是 class_ro_t，所以这里只需要转成 class_ro_t 类型就可以了 // 但 future 的类是例外!!! if (ro-&gt;flags &amp; RO_FUTURE) &#123; // 如果 ro 的 flag 里记录了这是一个 future 的类，那么 objc_class 中的 class_data_bits_t bits 里存的是 class_rw_t // rw 数据已经被分配好内存了，现在要做的就是填充信息 // This was a future class. rw data is already allocated. rw = cls-&gt;data(); // 取出 rw ro = cls-&gt;data()-&gt;ro; // 取出 ro cls-&gt;changeInfo(RW_REALIZED|RW_REALIZING, RW_FUTURE); // 清除 future 状态，RW_FUTURE 位的值置为 0 // 设置为 realized + realizing 状态 &#125; else &#123; // RW_REALIZED 和 RW_REALIZING 位的值置为 1 // Normal class. Allocate writeable class data. // 正常的类的话，就需要开辟内存 rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1); rw-&gt;ro = ro; // 将原来的 ro 赋给新 rw 中的 ro 字段 rw-&gt;flags = RW_REALIZED|RW_REALIZING; // 设置为 realized + realizing 状态 cls-&gt;setData(rw); // 将新的 rw 替换老的 rw &#125; isMeta = ro-&gt;flags &amp; RO_META; // cls 类是否是元类 rw-&gt;version = isMeta ? 7 : 0; // old runtime went up to 6 // 版本，元类是 7，普通类是 0 // Realize superclass and metaclass, if they aren't already. // This needs to be done after RW_REALIZED is set above, for root classes. // remapClass() 函数是如果参数是一个已经 realized 的 future 类，则返回的是新类，否则返回的是自己 // 查看 cls 的父类对应的重映射的类，将其 realize 了 supercls = realizeClass(remapClass(cls-&gt;superclass)); // 查看 cls 的元类对应的重映射的类，将其 realize 了 metacls = realizeClass(remapClass(cls-&gt;ISA())); // Update superclass and metaclass in case of remapping cls-&gt;superclass = supercls; // 更新 cls 的父类 cls-&gt;initClassIsa(metacls); // 和元类 // Reconcile instance variable offsets / layout. // This may reallocate class_ro_t, updating our ro variable. if (supercls &amp;&amp; !isMeta) &#123; // 根据父类，调整 cls 类 ro 中实例变量的偏移量和布局 // 可能重新分配 class_ro_t，更新 ro reconcileInstanceVariables(cls, supercls, ro); &#125; // Set fastInstanceSize if it wasn't set already. cls-&gt;setInstanceSize(ro-&gt;instanceSize); // 设置成员变量的新的大小 // Copy some flags from ro to rw // 从 ro 拷贝一些 flag 到 rw 中，可能是为了加快查找速度 if (ro-&gt;flags &amp; RO_HAS_CXX_STRUCTORS) &#123; // 是否有 C++ 构造器/析构器 cls-&gt;setHasCxxDtor(); // 设置有 C++ 析构器 if (! (ro-&gt;flags &amp; RO_HAS_CXX_DTOR_ONLY)) &#123; // 不只有 C++ 析构器，那么就是也有 C++ 构造器，真绕啊 cls-&gt;setHasCxxCtor(); &#125; &#125; ..... // Connect this class to its superclass's subclass lists if (supercls) &#123; addSubclass(supercls, cls); &#125; // 调用 methodizeClass 函数来将分类中的方法列表、属性列表、协议列表加载到 methods、 properties 和 protocols 列表数组中 // Attach categories methodizeClass(cls); if (!isMeta) &#123; // 如果不是元类 addRealizedClass(cls); // 就把它添加到 realized_class_hash 哈希表中 &#125; else &#123; addRealizedMetaclass(cls); // 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中 &#125; return cls;&#125; realizeClass realize(实现) 指定的 cls 类： 包括开辟它的 read-write data，也就是 rw，见 class_rw_t 结构体； 设置类的类型，元类or 普通类； 递归超类、元类，调用realizeClass。确保超类全部实现过； 设置superclass指针、元类指针； reconcileInstanceVariables ； addSubclass 构建类继承体系的链表； methodizeClass 调整方法 ； 添加到全局表中。 realizeClass 的总体流程如下图： 开辟rw 开辟RW的工作就是：将class_data_bits_t结构中bits的3-&gt;47位指定的RO切断，创建新的class_rw_t结构，3-&gt;47位 重新存储新的class_rw_t结构地址，然后将class_rw_t结构中的ro指针指向原始的class_ro_t结构。 reconcileInstanceVariables（没看）这部分我也不会，没看。 addSubclass构建出的链表如下： methodizeClassmethodizeClass代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 1. fix-up cls 类的方法列表、协议列表、属性列表（但是看代码，被 fix-up 的只有方法列表啊）// 将 cls 类的所有没有被 attach 的分类 attach 到 cls 上// 2. 即将分类中的方法、属性、协议添加到 methods、 properties 和 protocols 中// runtimeLock 读写锁必须被调用者上写锁，保证线程安全static void methodizeClass(Class cls)&#123; runtimeLock.assertWriting(); // 看调用者是否已经正确地将 runtimeLock 上了写锁 bool isMeta = cls-&gt;isMetaClass(); // 记录 cls 类是否是元类 auto rw = cls-&gt;data(); // 取得 cls 中的 rw，因为在 realizeClass() 中已经处理好了 cls-&gt;data()， // 所以里面现在存的确定是 rw，而不是 ro auto ro = rw-&gt;ro; // 取得 rw-&gt;ro // Methodizing for the first time if (PrintConnecting) &#123; _objc_inform(\"CLASS: methodizing class '%s' %s\", cls-&gt;nameForLogging(), isMeta ? \"(meta)\" : \"\"); &#125; // Install methods and properties that the class implements itself. // 取得 ro 中的 baseMethodList，在将其 prepare 后，插入 rw 的方法列表数组中 method_list_t *list = ro-&gt;baseMethods(); if (list) &#123; prepareMethodLists(cls, &amp;list, 1, YES, isBundleClass(cls)); rw-&gt;methods.attachLists(&amp;list, 1); &#125; // 将 ro 中的 baseProperties 插入 rw 中的属性列表数组中 property_list_t *proplist = ro-&gt;baseProperties; if (proplist) &#123; rw-&gt;properties.attachLists(&amp;proplist, 1); &#125; // 将 ro 中的 baseProtocols 插入 rw 中的协议列表数组中 protocol_list_t *protolist = ro-&gt;baseProtocols; if (protolist) &#123; rw-&gt;protocols.attachLists(&amp;protolist, 1); &#125; // Root classes get bonus method implementations if they don't have // them already. These apply before category replacements. if (cls-&gt;isRootMetaclass()) &#123; // 如果是根元类 // root metaclass // 给根元类的 SEL_initialize 指定了对应的 IMP - objc_noop_imp // 即给根元类发送 SEL_initialize 消息，不会走到它的 +initialize，而是走 objc_noop_imp，里面啥也不干 addMethod(cls, SEL_initialize, (IMP)&amp;objc_noop_imp, \"\", NO); &#125; // Attach categories. // 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类 category_list *cats = unattachedCategoriesForClass(cls, true /*realizing 其实这个参数压根没用*/); // 从分类列表中添加方法列表、属性和协议到 cls 类中 // attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？ // 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的 // 所以压根儿不用再另外排序 attachCategories(cls, cats, false /*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/); if (cats) &#123; free(cats); // 将分类列表释放，见 unattachedCategoriesForClass， // 里面着重强调了调用方需要负责释放分类列表 &#125;&#125; 上面的代码完成的四个工作用图中的4条虚线表示： 接下来的工作是是分类的处理，这里需要详细的讲下，所以在分出一节 分类 处理分类的数据结构12345678// 存放 locstamped_category_t 的列表struct locstamped_category_list_t &#123; uint32_t count; // 数组有几个元素#if __LP64__ uint32_t reserved;#endif locstamped_category_t list[0]; // 数组的起始地址&#125;; 12345// 本地的盖了戳的 category，即已经被添加进了 unattachedCategoriesstruct locstamped_category_t &#123; category_t *cat; // category struct header_info *hi; // 所属的 header，即所属的镜像&#125;; 12345678struct category_t &#123; const char *name; // 分类的名字 classref_t cls; // 分类所属的类，classref_t 专门用于 unremapped 的类 struct method_list_t *instanceMethods; // 实例方法列表 struct method_list_t *classMethods; // 类方法列表 struct protocol_list_t *protocols; // 遵循的协议列表 struct property_list_t *instanceProperties; // 属性列表，但是并没有卵用... 唉....&#125; 存储所有分类的Map结构 向category_map中添加新的分类向category_map中添加新的分类 调用addUnattachedCategoryForClass方法： 123456789101112131415161718192021222324static void addUnattachedCategoryForClass(category_t *cat, Class cls, header_info *catHeader)&#123; runtimeLock.assertWriting(); // DO NOT use cat-&gt;cls! cls may be cat-&gt;cls-&gt;isa instead NXMapTable *cats = unattachedCategories(); // 取得存储所有没有被 attached 的分类的列表 category_list *list; // 从所有 unattached 的分类列表中取得 cls 类对应的所有没有被 attach 的分类列表 list = (category_list *)NXMapGet(cats, cls); if (!list) &#123; // 如果 cls 没有未 attach 的分类 // 就开辟出一个单位的空间，用来放新来的这个分类 list = (category_list *) calloc(sizeof(*list) + sizeof(list-&gt;list[0]), 1); &#125; else &#123; // 否则开辟出比原来多一个单位的空间，用来放新来的这个分类，因为 realloc ，所以原来的数据会被拷贝过来 list = (category_list *) realloc(list, sizeof(*list) + sizeof(list-&gt;list[0]) * (list-&gt;count + 1)); &#125; // 将新来的分类 cat 添加刚刚开辟的位置上 list-&gt;list[list-&gt;count++] = (locstamped_category_t)&#123;cat, catHeader&#125;; // 将新的 list 重新插入 cats 中，会覆盖老的 list NXMapInsert(cats, cls, list);&#125; 将分类附着（attachCategories）到类中12345678// Attach categories.// 给 cls 类附加分类，unattachedCategoriesForClass 会返回 cls 类的没有被附加的类category_list *cats = unattachedCategoriesForClass(cls, true /*realizing 其实这个参数压根没用*/);// 从分类列表中添加方法列表、属性和协议到 cls 类中// attachCategories 要求分类列表中是排好序的，老的分类排前面，新的排后面，那么排序是在哪里做的呢？？？？// 自问自答：见 addUnattachedCategoryForClass() 函数，新的 unattached 的分类本来就是插入到列表末尾的// 所以压根儿不用再另外排序attachCategories(cls, cats, false /*不清空缓存 因为这时候压根连缓存都没有 don't flush caches*/); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071static void attachCategories(Class cls, category_list *cats, bool flush_caches)&#123; if (!cats) return; // 如果列表是 nil，直接返回 // 打印一些信息 if (PrintReplacedMethods) &#123; printReplacements(cls, cats); &#125; bool isMeta = cls-&gt;isMetaClass(); // 记录 cls 类是否是元类 // fixme rearrange to remove these intermediate allocations // 在堆中为方法列表数组、属性列表数组、协议列表数组分配足够大内存，注意，它们都是二维数组 // 后面会将所有分类中的方法列表、属性列表、协议列表的首地址放到里面 method_list_t **mlists = (method_list_t **) malloc(cats-&gt;count * sizeof(*mlists)); property_list_t **proplists = (property_list_t **) malloc(cats-&gt;count * sizeof(*proplists)); protocol_list_t **protolists = (protocol_list_t **) malloc(cats-&gt;count * sizeof(*protolists)); // Count backwards through cats to get newest categories first int mcount = 0; // 记录方法的数量 int propcount = 0; // 记录属性的数量 int protocount = 0; // 记录协议的数量 int i = cats-&gt;count; // 从后开始，保证先取最新的分类 bool fromBundle = NO; // 记录是否是从 bundle 中取的 while (i--) &#123; // 从后往前遍历 auto&amp; entry = cats-&gt;list[i]; // 分类，locstamped_category_t 类型 // 取出分类中的方法列表；如果是元类，取得的是类方法列表；否则取得的是实例方法列表 method_list_t *mlist = entry.cat-&gt;methodsForMeta(isMeta); if (mlist) &#123; mlists[mcount++] = mlist; // 将方法列表放入 mlists 方法列表数组中 fromBundle |= entry.hi-&gt;isBundle(); // 分类的头部信息中存储了是否是 bundle，将其记住 &#125; // 取出分类中的属性列表，如果是元类，取得是nil property_list_t *proplist = entry.cat-&gt;propertiesForMeta(isMeta); if (proplist) &#123; proplists[propcount++] = proplist; // 将属性列表放入 proplists 属性列表数组中 &#125; // 取出分类中遵循的协议列表 protocol_list_t *protolist = entry.cat-&gt;protocols; if (protolist) &#123; protolists[protocount++] = protolist; // 将协议列表放入 protolists 协议列表数组中 &#125; &#125; auto rw = cls-&gt;data(); // 取出 cls 的 class_rw_t 数据 // 准备 mlists 中的方法列表们 prepareMethodLists(cls, mlists, mcount/*方法列表的数量*/, NO/*不是基本方法*/, fromBundle/*是否来自bundle*/); rw-&gt;methods.attachLists(mlists, mcount); // 将准备完毕的新方法列表们添加到 rw 中的方法列表数组中 free(mlists); // 释放 mlists if (flush_caches &amp;&amp; mcount &gt; 0) &#123; // 如果需要清空方法缓存，并且刚才确实有方法列表添加进 rw 中， // 不然没有新方法加进来，就没有必要清空，清空是为了避免无法命中缓存的错误 // 因为缓存位置是按照 hash 的方法确定的，详情见 cache_t::find() 函数 flushCaches(cls); // 清空 cls 类 / cls 类的元类 / cls 类的子孙类 的方法缓存 &#125; rw-&gt;properties.attachLists(proplists, propcount); // 将新属性列表添加到 rw 中的属性列表数组中 free(proplists); // 释放 proplists rw-&gt;protocols.attachLists(protolists, protocount); // 将新协议列表添加到 rw 中的协议列表数组中 free(protolists); // 释放 protolists&#125; 上面代码将 category_list *cats 中的list成员表示的方法列表转化为数组mlists： 转化完成后，调用attachLists方法，附着到类上： 123456789101112131415161718192021222324252627282930 void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 将List** 中的内容附着到method_array_t 上,原理如图： 添加全局表添加的到全局表的代码如下： 12345if (!isMeta) &#123; // 如果不是元类 addRealizedClass(cls); // 就把它添加到 realized_class_hash 哈希表中&#125; else &#123; addRealizedMetaclass(cls); // 否则是元类，就把它添加到 realized_metaclass_hash 哈希表中&#125; 根据类的类型，元类还是普通类，调用不同的方法。 12345678910static void addRealizedClass(Class cls)&#123; runtimeLock.assertWriting(); void *old; old = NXHashInsert(realizedClasses(), cls); // 将 cls 插入 realized_class_hash 哈希表中 objc_addRegisteredClass(cls); // 将 cls 添加到已注册类的哈希表中(objc-auto.mm 中的 AllClasses) assert(!cls-&gt;isMetaClass()); // cls 不能是元类 assert(!old); // 不能有旧值&#125; 普通类调用addRealizedClass方法，将类添加到realizedClasses()表中。 12345// 取得存有所有经过 realized 的非元类的哈希表static NXHashTable *realizedClasses(void)&#123; return realized_class_hash;&#125; 直接返回realized_class_hash hash表。 12345678static void addRealizedMetaclass(Class cls)&#123; runtimeLock.assertWriting(); void *old; old = NXHashInsert(realizedMetaclasses(), cls); // 将 cls 元类添加到 realized_metaclass_hash 哈希表中 assert(cls-&gt;isMetaClass()); // cls 必须是元类 assert(!old); // 不能有旧值&#125; 元类调用addRealizedMetaclass 将类添加到 realizedMetaclasses()表中 123456// 取得存有所有经过 realized 的元类的哈希表// 该函数被 addRealizedMetaclass()/flushCaches()/removeRealizedMetaclass()函数调用static NXHashTable *realizedMetaclasses(void)&#123; return realized_metaclass_hash;&#125; 读取分类，remethodize类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// Discover categories.for (EACH_HEADER) &#123; // 遍历 hList // 取得 hi 镜像中的所有分类 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; // 遍历所有分类 category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 得到分类所属的类的 live class if (!cls) &#123; // 如果 cls 为空 // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. // 分类所属的类丢了，很多可能是 weak-linked 了 // 这个分类就是不可信的，完全没有什么鸟用了 catlist[i] = nil; // 将这个分类从列表中删除 continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) // 如果分类中存在实例方法 or 协议 or 实例属性 &#123; // 添加分类到所属的 cls 类上，即把这个分类添加到 cls 对应的所有 unattached 的分类的列表中 addUnattachedCategoryForClass(cat, cls, hi); // 如果 cls 类已经被 realized if (cls-&gt;isRealized()) &#123; // 就重新 methodize 一下 cls 类，里面会重新 attachCategories 一下所有未被 attach 的分类 // 即把这些分类中的方法、协议、属性添加到 cls 类中 remethodizeClass(cls); classExists = YES; // 标记类存在 &#125; &#125; // 如果分类中存在类方法 or 协议 if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; // 添加分类到所属类 cls 的元类中 addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); // 如果 cls 的元类已经 realized 过了 if (cls-&gt;ISA()-&gt;isRealized()) &#123; // 就重新 methodize 一下 cls 类的元类 remethodizeClass(cls-&gt;ISA()); &#125; &#125; &#125;&#125; 这个代码发现所有的分类， 如果分类中包含实例方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls：(cat：hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到类中。 如果分类中包含类方法、协议、属性，调用addUnattachedCategoryForClass， 以（cls-&gt;ISA()：(cat： hi)） 键值对 添加到category_map表中，添加完成后调用remethodizeClass函数，将分类属性添加到元类中。 remethodizeClass 实现如下： 1234567891011121314151617static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertWriting(); // 看 runtimeLock 是否已经被正确得加上了写锁 isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories // 取得 cls 类的未被 attach 的分类列表 if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; // 将分类列表 attach 附加到 cls 类上，因为这不是第一次 methodize，所以需要清空缓存，因为原来的缓存也已经废了 attachCategories(cls, cats, true /* 清空方法缓存 flush caches*/); free(cats); // 将 cats 释放，原因见 unattachedCategoriesForClass() &#125;&#125; remethodizeClass 调用unattachedCategoriesForClass 取得类所属的分类，调用attachCategories将分类中的方法、协议、属性添加的类中。这个方面和上面的methodizeClass 功能基本相同。methodizeClass比remethodizeClass多一个操作————处理base相关的信息。 总结_read_images 主要是读取Mach-O中下面的section ，存储到内存中 12345678910GETSECT(_getObjc2SelectorRefs, SEL, \"__objc_selrefs\"); GETSECT(_getObjc2MessageRefs, message_ref_t, \"__objc_msgrefs\"); GETSECT(_getObjc2ClassRefs, Class, \"__objc_classrefs\");GETSECT(_getObjc2SuperRefs, Class, \"__objc_superrefs\");GETSECT(_getObjc2ClassList, classref_t, \"__objc_classlist\");GETSECT(_getObjc2NonlazyClassList, classref_t, \"__objc_nlclslist\");GETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\");GETSECT(_getObjc2NonlazyCategoryList, category_t *, \"__objc_nlcatlist\");GETSECT(_getObjc2ProtocolList, protocol_t *, \"__objc_protolist\");GETSECT(_getObjc2ProtocolRefs, protocol_t *, \"__objc_protorefs\"); 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"_read_images","slug":"read-images","permalink":"http://yoursite.com/tags/read-images/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"8. objc4入口函数","date":"2018-11-26T03:38:11.000Z","path":"wiki/IOS/Runtime/objc/8__objc_init/","text":"__objc_init函数是objc4库的入口函数。该函数里面注册了dyld_image_state_bound、dyld_image_state_dependents_initialized两种状态， 当Dyld bind 操作结束之后，会发出 dyld_image_state_bound 通知，然后执行与之绑定的回调函数 map_2_images，当调用Objc 的 + load的时候发送dyld_image_state_dependents_initialized消息，执行load_images函数。 _objc_init12345678910111213141516void _objc_init(void)&#123; .... // Register for unmap first, in case some +load unmaps something // 首先第一步，注册 unmap 函数，万一有的类的 +load 方法需要 unmap 一些东西 // unmap，即 un-memory-mapped，这里应该就是取消内存映射，移除镜像的意思 _dyld_register_func_for_remove_image(&amp;unmap_image); // 注册镜像状态改变时的回调函数 dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch 是否批处理*/, &amp;map_2_images); // 注册镜像状态改变时的回调函数，镜像加载完成后，需要调用 +load 时会回调 load_images 函数 // 不进行批处理，所以 load_images 会被调用多次，每次有新的镜像进来时，都会被调用 dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; 首先看map_2_images函数，load_images后面一遍介绍。 12345678910111213// 处理给定的镜像，这些镜像被 dyld库 映射// 这个函数其实是一个回调函数，被 dyld 库调用，参数中的镜像信息也是 dyld 库传进来的，详情见 _objc_init()const char *map_2_images(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; rwlock_writer_t lock(runtimeLock); // runtimeLock 加写锁 // 在 map_images_nolock 函数中，完成所有 class 的注册、fixup等工作， // 还包括初始化自动释放池、初始化 side table 等等工作 return map_images_nolock(state, infoCount, infoList);&#125; map_2_images内部调用了map_images_nolock函数。 123456789101112131415161718192021222324252627282930313233343536373839// 映射镜像，在这个函数中，完成所有 class 的注册、fixup等工作，// 还包括初始化自动释放池、初始化 side table 等工作const char *map_images_nolock(enum dyld_image_states state, uint32_t infoCount, const struct dyld_image_info infoList[])&#123; static bool firstTime = YES; static bool wantsGC = NO; uint32_t i; header_info *hi; header_info *hList[infoCount]; uint32_t hCount; size_t selrefCount = 0; .... // Find all images with Objective-C metadata. hCount = 0; i = infoCount; while (i--) &#123; const headerType *mhdr = (headerType *)infoList[i].imageLoadAddress; hi = addHeader(mhdr); if (!hi) &#123; // no objc data in this entry continue; &#125; if (mhdr-&gt;filetype == MH_EXECUTE) &#123; // Size some data structures based on main executable's size _getObjcSelectorRefs(hi, &amp;selrefCount); &#125; hList[hCount++] = hi &#125; .... _read_images(hList, hCount); return NULL;&#125; map_images_nolock对所有的镜像列表执行addHeader，主要过滤重复的镜像。 接着调用_read_images函数。_read_images比较复杂，后面文章分析。下面看看addHeader的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142static header_info * addHeader(const headerType *mhdr)&#123; header_info *hi; if (bad_magic(mhdr)) return NULL; &#123; // Didn't find an hinfo in the dyld shared cache. // Weed out duplicates for (hi = FirstHeader; hi; hi = hi-&gt;next) &#123; if (mhdr == hi-&gt;mhdr) return NULL; &#125; // Locate the __OBJC segment size_t info_size = 0; unsigned long seg_size; const objc_image_info *image_info = _getObjcImageInfo(mhdr,&amp;info_size); const uint8_t *objc_segment = getsegmentdata(mhdr,SEG_OBJC,&amp;seg_size); if (!objc_segment &amp;&amp; !image_info) return NULL; // Allocate a header_info entry. hi = (header_info *)calloc(sizeof(header_info), 1); // Set up the new header_info entry. hi-&gt;mhdr = mhdr; hi-&gt;info = image_info; hi-&gt;fname = dyld_image_path_containing_address(hi-&gt;mhdr); hi-&gt;loaded = true; hi-&gt;inSharedCache = false; hi-&gt;allClassesRealized = NO; &#125; // dylibs are not allowed to unload // ...except those with image_info and nothing else (5359412) if (hi-&gt;mhdr-&gt;filetype == MH_DYLIB &amp;&amp; _hasObjcContents(hi)) &#123; dlopen(hi-&gt;fname, RTLD_NOLOAD); &#125; appendHeader(hi); return hi;&#125; addHeader将传入的headerType参数mhdr 构造出header_info类型，最后调用appendHeader函数： 1234567891011121314151617181920void appendHeader(header_info *hi)&#123; // Add the header to the header list. // The header is appended to the list, to preserve the bottom-up order. HeaderCount++; hi-&gt;next = NULL; if (!FirstHeader) &#123; // list is empty FirstHeader = LastHeader = hi; &#125; else &#123; if (!LastHeader) &#123; // list is not empty, but LastHeader is invalid - recompute it LastHeader = FirstHeader; while (LastHeader-&gt;next) LastHeader = LastHeader-&gt;next; &#125; // LastHeader is now valid LastHeader-&gt;next = hi; LastHeader = hi; &#125;&#125; appendHeader 将hi放入FirstHeader的列表中。其中FirstHeader、LastHeader的定义如下。 123header_info *FirstHeader = 0; // NULL means empty list 第一个 image(镜像)header_info *LastHeader = 0; // NULL means invalid; recompute itint HeaderCount = 0; 总结map_2_images 主要完成的工作如下： 镜像去重复 对于每个镜像，从dyld_image_info 构造出header_info结构 将header_info结构添加到列表FirstHeader中，LastHeader 指向列表的最后一个元素。 执行_read_images，后续讲解。 转化的header_info结构如下： FirstHeader 的链表结构如下图所示,这里记录了objc库加载的所有的镜像。 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"__objc_init","slug":"objc-init","permalink":"http://yoursite.com/tags/objc-init/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"7. NXMapTable数据结构","date":"2018-11-22T16:38:11.000Z","path":"wiki/IOS/Runtime/objc/7_NXMapTable/","text":"这篇文章介绍NXMapTable数据结构 NXMapTable 数据结构1234567typedef struct _NXMapTable &#123; /* private data structure; may change */ const struct _NXMapTablePrototype *prototype; unsigned count; unsigned nbBucketsMinusOne; void *buckets;&#125; NXMapTable OBJC_MAP_AVAILABILITY; count 存储的个数， nbBucketsMinusOne 容量减1， buckets 存储数据。 _NXMapTablePrototype定义如下 123456typedef struct _NXMapTablePrototype &#123; unsigned (*hash)(NXMapTable *, const void *key); int (*isEqual)(NXMapTable *, const void *key1, const void *key2); void (*free)(NXMapTable *, void *key, void *value); int style; /* reserved for future expansion; currently 0 */&#125; NXMapTablePrototype OBJC_MAP_AVAILABILITY; _NXMapTablePrototype 结构存储三个函数指针hash、 isEqual、 free。 类图如下: 主要的接口123456789101112131415161718NXMapTable *NXCreateMapTableFromZone(NXMapTablePrototype prototype, unsigned capacity, void *z) OBJC_MAP_AVAILABILITY;NXMapTable *NXCreateMapTable(NXMapTablePrototype prototype, unsigned capacity) OBJC_MAP_AVAILABILITY;void NXFreeMapTable(NXMapTable *table) OBJC_MAP_AVAILABILITY;void NXResetMapTable(NXMapTable *table) OBJC_MAP_AVAILABILITY;BOOL NXCompareMapTables(NXMapTable *table1, NXMapTable *table2) OBJC_MAP_AVAILABILITY;unsigned NXCountMapTable(NXMapTable *table) OBJC_MAP_AVAILABILITY; void *NXMapMember(NXMapTable *table, const void *key, void **value) OBJC_MAP_AVAILABILITY; void *NXMapGet(NXMapTable *table, const void *key) OBJC_MAP_AVAILABILITY; void *NXMapInsert(NXMapTable *table, const void *key, const void *value) OBJC_MAP_AVAILABILITY; void *NXMapRemove(NXMapTable *table, const void *key) OBJC_MAP_AVAILABILITY; NXCreateMapTableFromZone1234567891011121314151617181920212223NXMapTable *NXCreateMapTableFromZone(NXMapTablePrototype prototype, unsigned capacity, void *z) &#123; NXMapTable *table = (NXMapTable *)malloc_zone_malloc((malloc_zone_t *)z, sizeof(NXMapTable)); NXMapTablePrototype *proto; if (! prototypes) prototypes = NXCreateHashTable(protoPrototype, 0, NULL); if (! prototype.hash || ! prototype.isEqual || ! prototype.free || prototype.style) &#123; _objc_inform(\"*** NXCreateMapTable: invalid creation parameters\\n\"); return NULL; &#125; proto = (NXMapTablePrototype *)NXHashGet(prototypes, &amp;prototype); if (! proto) &#123; proto = (NXMapTablePrototype *)malloc(sizeof(NXMapTablePrototype)); *proto = prototype; (void)NXHashInsert(prototypes, proto); &#125; table-&gt;prototype = proto; table-&gt;count = 0; table-&gt;nbBucketsMinusOne = exp2u(log2u(capacity)+1) - 1; table-&gt;buckets = allocBuckets(z, table-&gt;nbBucketsMinusOne + 1); return table;&#125;NXMapTable *NXCreateMapTable(NXMapTablePrototype prototype, unsigned capacity) &#123; return NXCreateMapTableFromZone(prototype, capacity, malloc_default_zone());&#125; NXCreateMapTableFromZone 主要工作： 创建table 处理proto，如果先前没有prototype，存储在prototypes全局hash表中。 赋值成员。 NXFreeMapTable12345678910111213141516171819void NXFreeMapTable(NXMapTable *table) &#123; NXResetMapTable(table); freeBuckets(table-&gt;buckets); free(table);&#125;void NXResetMapTable(NXMapTable *table) &#123; MapPair *pairs = (MapPair *)table-&gt;buckets; void (*freeProc)(struct _NXMapTable *, void *, void *) = table-&gt;prototype-&gt;free; unsigned index = table-&gt;nbBucketsMinusOne + 1; while (index--) &#123; if (pairs-&gt;key != NX_MAPNOTAKEY) &#123; freeProc(table, (void *)pairs-&gt;key, (void *)pairs-&gt;value); pairs-&gt;key = NX_MAPNOTAKEY; pairs-&gt;value = NULL; &#125; pairs++; &#125; table-&gt;count = 0;&#125; 循环调用free函数， 删除存储的数据。 NXCountMapTable1unsigned NXCountMapTable(NXMapTable *table) &#123; return table-&gt;count; &#125; 获取table中存储数据的个数。返回NXMapTable的count成员。 NXMapMember12345678910111213141516171819202122232425static INLINE void *_NXMapMember(NXMapTable *table, const void *key, void **value) &#123; MapPair *pairs = (MapPair *)table-&gt;buckets; unsigned index = bucketOf(table, key); MapPair *pair = pairs + index; if (pair-&gt;key == NX_MAPNOTAKEY) return NX_MAPNOTAKEY; if (isEqual(table, pair-&gt;key, key)) &#123; *value = (void *)pair-&gt;value; return (void *)pair-&gt;key; &#125; else &#123; unsigned index2 = index; while ((index2 = nextIndex(table, index2)) != index) &#123; pair = pairs + index2; if (pair-&gt;key == NX_MAPNOTAKEY) return NX_MAPNOTAKEY; if (isEqual(table, pair-&gt;key, key)) &#123; *value = (void *)pair-&gt;value; return (void *)pair-&gt;key; &#125; &#125; return NX_MAPNOTAKEY; &#125;&#125;void *NXMapMember(NXMapTable *table, const void *key, void **value) &#123; return _NXMapMember(table, key, value);&#125; NXMapMember 获取给定key对应的值，该函数首先通过bucketOf取出索引： 1234static INLINE unsigned bucketOf(NXMapTable *table, const void *key) &#123; unsigned hash = (table-&gt;prototype-&gt;hash)(table, key); return hash &amp; table-&gt;nbBucketsMinusOne;&#125; bucketOf 函数通过key计算出hash值，然后将hash值和table-&gt;nbBucketsMinusOne按位与，执行的结果一定小于等于 table-&gt;nbBucketsMinusOne，也就是一定小于容量，不会产生一个超出容量的索引。 1MapPair *pair = pairs + index; 通过索引找到存储的内容pair，类型是MapPair。 接着根据pair的内容，分三种情况： 索引位置位的内容为空，直接返回NX_MAPNOTAKEY,value值不设置。 索引位置的内容不空，但是key一样，返回key，设置value的内容为当前pair的value。 索引位置内容不空，并且key不一样，循环查找下一个位置，直到找到一个位置，这个位置的key和传入的key相等。返回key，设置value的内容为当前pair的value。 1if (pair-&gt;key == NX_MAPNOTAKEY) return NX_MAPNOTAKEY; 如果找到的位置没有内容，直接返回NX_MAPNOTAKEY。 1234if (isEqual(table, pair-&gt;key, key)) &#123; *value = (void *)pair-&gt;value; return (void *)pair-&gt;key; &#125; 如果索引位置的key相同，传出key对应的内容。 12345678910else &#123; unsigned index2 = index; while ((index2 = nextIndex(table, index2)) != index) &#123; pair = pairs + index2; if (pair-&gt;key == NX_MAPNOTAKEY) return NX_MAPNOTAKEY; if (isEqual(table, pair-&gt;key, key)) &#123; *value = (void *)pair-&gt;value; return (void *)pair-&gt;key; &#125; &#125; 如果索引的位置有值，且key不相等，循环查找下一个位置，直到找到相同的key，或者循环完成。 其中nextIndex 函数计算出下一个索引。 123static INLINE unsigned nextIndex(NXMapTable *table, unsigned index) &#123; return (index + 1) &amp; table-&gt;nbBucketsMinusOne;&#125; 所以递增的示意图如下： NXMapInsert12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152void *NXMapInsert(NXMapTable *table, const void *key, const void *value) &#123; MapPair *pairs = (MapPair *)table-&gt;buckets; unsigned index = bucketOf(table, key); MapPair *pair = pairs + index; if (key == NX_MAPNOTAKEY) &#123; _objc_inform(\"*** NXMapInsert: invalid key: -1\\n\"); return NULL; &#125; unsigned numBuckets = table-&gt;nbBucketsMinusOne + 1; if (pair-&gt;key == NX_MAPNOTAKEY) &#123; pair-&gt;key = key; pair-&gt;value = value; table-&gt;count++; if (table-&gt;count * 4 &gt; numBuckets * 3) _NXMapRehash(table); return NULL; &#125; if (isEqual(table, pair-&gt;key, key)) &#123; const void *old = pair-&gt;value; if (old != value) pair-&gt;value = value;/* avoid writing unless needed! */ return (void *)old; &#125; else if (table-&gt;count == numBuckets) &#123; /* no room: rehash and retry */ _NXMapRehash(table); return NXMapInsert(table, key, value); &#125; else &#123; unsigned index2 = index; while ((index2 = nextIndex(table, index2)) != index) &#123; pair = pairs + index2; if (pair-&gt;key == NX_MAPNOTAKEY) &#123; pair-&gt;key = key; pair-&gt;value = value; table-&gt;count++; if (table-&gt;count * 4 &gt; numBuckets * 3) _NXMapRehash(table); return NULL; &#125; if (isEqual(table, pair-&gt;key, key)) &#123; const void *old = pair-&gt;value; if (old != value) pair-&gt;value = value;/* avoid writing unless needed! */ return (void *)old; &#125; &#125; /* no room: can't happen! */ _objc_inform(\"**** NXMapInsert: bug\\n\"); return NULL; &#125;&#125; 这个代码有几个关键的地方： 容量大于3/4 就扩容，扩大为原来的2倍。 添加分为三种情况： 索引位置为空，直接插入、索引位置不空，key相同，替换新的内容、索引位置内容不空，key不相同，循环查找下一个内容为空的位置，如果找到，插入，否则什么页不做。 下面两图分别说明上面的三种情况 。 NXMapRemove123456789101112131415161718192021222324252627282930313233343536373839404142void *NXMapRemove(NXMapTable *table, const void *key) &#123; MapPair *pairs = (MapPair *)table-&gt;buckets; unsigned index = bucketOf(table, key); MapPair *pair = pairs + index; unsigned chain = 1; /* number of non-nil pairs in a row */ int found = 0; const void *old = NULL; if (pair-&gt;key == NX_MAPNOTAKEY) return NULL; mapRemove ++; /* compute chain */ &#123; unsigned index2 = index; if (isEqual(table, pair-&gt;key, key)) &#123;found ++; old = pair-&gt;value; &#125; while ((index2 = nextIndex(table, index2)) != index) &#123; pair = pairs + index2; if (pair-&gt;key == NX_MAPNOTAKEY) break; if (isEqual(table, pair-&gt;key, key)) &#123;found ++; old = pair-&gt;value; &#125; chain++; &#125; &#125; if (! found) return NULL; if (found != 1) _objc_inform(\"**** NXMapRemove: incorrect table\\n\"); /* remove then reinsert */ &#123; MapPair buffer[16]; MapPair *aux = (chain &gt; 16) ? (MapPair *)malloc(sizeof(MapPair)*(chain-1)) : buffer; unsigned auxnb = 0; int nb = chain; unsigned index2 = index; while (nb--) &#123; pair = pairs + index2; if (! isEqual(table, pair-&gt;key, key)) aux[auxnb++] = *pair; pair-&gt;key = NX_MAPNOTAKEY; pair-&gt;value = NULL; index2 = nextIndex(table, index2); &#125; table-&gt;count -= chain; if (auxnb != chain-1) _objc_inform(\"**** NXMapRemove: bug\\n\"); while (auxnb--) NXMapInsert(table, aux[auxnb].key, aux[auxnb].value); if (chain &gt; 16) free(aux); &#125; return (void *)old;&#125; 删除指定key的内容分为下面几步： 通过key找到索引 如果key对于的MapPair为空，直接返回 计算key存储数据的实际位置和应该存储位置的距离chain。这段距离内的元素的存储位置可能不是按照对应位置存储的。 删除chain内的元素，重新插入chain-1 个元素。 用下面图理解删除的代码。 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"list_array_tt","slug":"list-array-tt","permalink":"http://yoursite.com/tags/list-array-tt/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"6. 上古时代 Objective-C 中哈希表的实现(转载)","date":"2018-11-22T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/6_NXHashTable/","text":"因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。 文章会介绍上古时代 Objective-C 哈希表，也就是 NXHashTable ： NXHashTable 的实现 NXHashTable 的性能分析 NXHashTable 的作用 NXHashTable 的实现有着将近 30 年的历史，不过仍然作为重要的底层数据结构存储整个应用中的类。 文中会涉及一些数据结构方面的简单知识，例如拉链法。 注意：文章中分析的不是 NSHashTable 而是 NXHashTable。 NXHashTableNXHashTable 的实现位于 hashtable2.mm 文件，我们先来看一下 NXHashTable 的结构以及重要的接口： 1234567typedef struct &#123; const NXHashTablePrototype *prototype; unsigned count; unsigned nbBuckets; void *buckets; const void *info;&#125; NXHashTable; 对于结构体中的 NXHashTablePrototype 属性暂且不说，其中的 buckets 是真正用来存储数据的数组。 123456NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z);unsigned NXCountHashTable (NXHashTable *table);int NXHashMember (NXHashTable *table, const void *data);void *NXHashGet (NXHashTable *table, const void *data);void *NXHashInsert (NXHashTable *table, const void *data);void *NXHashRemove (NXHashTable *table, const void *data); 我们会以上面的这些方法作为切入点，分析 NXHashTable 的实现。 NXCreateHashTableFromZoneNXHashTable 使用 NXCreateHashTableFromZone 方法初始化： 123456789101112131415161718192021222324NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123; NXHashTable *table; NXHashTablePrototype *proto; table = ALLOCTABLE(z); if (! prototypes) bootstrap (); if (! prototype.hash) prototype.hash = NXPtrHash; if (! prototype.isEqual) prototype.isEqual = NXPtrIsEqual; if (! prototype.free) prototype.free = NXNoEffectFree; proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype); if (! proto) &#123; proto = (NXHashTablePrototype *) malloc(sizeof (NXHashTablePrototype)); bcopy ((const char*)&amp;prototype, (char*)proto, sizeof (NXHashTablePrototype)); (void) NXHashInsert (prototypes, proto); proto = (NXHashTablePrototype *)NXHashGet (prototypes, &amp;prototype); &#125;; table-&gt;prototype = proto; table-&gt;count = 0; table-&gt;info = info; table-&gt;nbBuckets = GOOD_CAPACITY(capacity); table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets); return table;&#125; 在这个方法中，绝大多数代码都是用来初始化 table-&gt;prototype 的，我们先把这部分全部忽略，分析一下简略版本的实现。 1234567891011121314NXHashTable *NXCreateHashTableFromZone (NXHashTablePrototype prototype, unsigned capacity, const void *info, void *z) &#123; NXHashTable *table; NXHashTablePrototype *proto; table = ALLOCTABLE(z); ... table-&gt;count = 0; table-&gt;info = info; table-&gt;nbBuckets = GOOD_CAPACITY(capacity); table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets); return table;&#125; 其中 ALLOCTABLE、GOOD_CAPACITY 以及 ALLOCBUCKETS 都是用来辅助初始化的宏： 123#define ALLOCTABLE(z) ((NXHashTable *) malloc_zone_malloc ((malloc_zone_t *)z,sizeof (NXHashTable)))#define GOOD_CAPACITY(c) (exp2m1u (log2u (c)+1))#define ALLOCBUCKETS(z,nb) ((HashBucket *) malloc_zone_calloc ((malloc_zone_t *)z, nb, sizeof (HashBucket))) ALLOCTABLE 和 ALLOCBUCKETS 只是调用了 malloc_zone_calloc 来初始化相应的结构体，而 GOOD_CAPACITY 有一些特殊，我们来举个例子说明： 12345c binary result1 1 1 2 10 3(0b11)6 110 7(0b111)100 1100100 127(0b111 1111) c 表示传入参数，binary 表示二进制下的参数，而 result 就是 GOOD_CAPACITY 返回的结果。 每次返回当前位数下的二进制最大值。 获得 table-&gt;nbBuckets 之后，再初始化 table-&gt;nbBuckets * sizeof (HashBucket) 大小的内存空间。 NXHashTablePrototype在继续分析其它方法之前，我们需要先知道 NXHashTablePrototype 是什么： 123456typedef struct &#123; uintptr_t (*hash)(const void *info, const void *data); int (*isEqual)(const void *info, const void *data1, const void *data2); void (*free)(const void *info, void *data); int style; /* reserved for future expansion; currently 0 */&#125; NXHashTablePrototype; NXHashTablePrototype 中存储了 hash、isEqual 和 free 的函数指针（用于获取数据的哈希、判断两个数据是否相等以及释放数据）。 在 hashtable2.mm 文件中有一个宏 ISEQUAL 就是用了 NXHashTablePrototype 中的 isEqual 来判断两个数据是否相等： 1#define ISEQUAL(table, data1, data2) ((data1 == data2) || (*table-&gt;prototype-&gt;isEqual)(table-&gt;info, data1, data2)) 可以说，NXHashTablePrototype 中存储了一些构建哈希表必要的函数指针。 因为 NXHashTable 使用拉链法来实现哈希表，在存入表前对数据执行 hash，然后找到对应的 buckets，如果与 buckets 中的数据相同（使用 isEqual 判断），就替换原数据，否则将数据添加到链表中。 HashBucket在这里另一个需要注意的数据结构就是 HashBucket： 1234typedef struct &#123; unsigned count; oneOrMany elements;&#125; HashBucket; oneOrMany 是一个 union 结构体： 1234typedef union &#123; const void *one; const void **many;&#125; oneOrMany; 这么设计的主要原因是提升性能。 如果 HashBucket 中只有一个元素，那么就直接访问 one，否则访问 many，遍历这个 many 列表。 NXCountHashTableNXCountHashTable 方法应该是我们要介绍的方法中的最简单的一个，它会直接返回 NXHashTable 结构体中的 count。 123unsigned NXCountHashTable (NXHashTable *table) &#123; return table-&gt;count;&#125; NXHashMemberNXHashMember 的函数签名虽然会返回 int，其实它是一个布尔值，会判断当前的 NXHashTable 中是否包含传入的数据： 12345678910111213141516int NXHashMember (NXHashTable *table, const void *data) &#123; HashBucket *bucket = BUCKETOF(table, data); unsigned j = bucket-&gt;count; const void **pairs; if (! j) return 0; if (j == 1) &#123; return ISEQUAL(table, data, bucket-&gt;elements.one); &#125;; pairs = bucket-&gt;elements.many; while (j--) &#123; if (ISEQUAL(table, data, *pairs)) return 1; pairs ++; &#125;; return 0;&#125; 使用 BUCKETOF 对 data 进行 hash，将结果与哈希表的 buckets 数取模，返回 buckets 数组中对应的 NXHashBucket。 1#define BUCKETOF(table, data) (((HashBucket *)table-&gt;buckets)+((*table-&gt;prototype-&gt;hash)(table-&gt;info, data) % table-&gt;nbBuckets)) 在获取了 bucket 之后，根据其中元素个数的不同，选择不同的分支： 123456789if (! j) return 0;if (j == 1) &#123; return ISEQUAL(table, data, bucket-&gt;elements.one);&#125;;pairs = bucket-&gt;elements.many;while (j--) &#123; if (ISEQUAL(table, data, *pairs)) return 1; pairs ++;&#125;; count == 0，直接返回 count == 1，使用 ISEQUAL 比较查找的数据与 bucket-&gt;elements.one count &gt; 1，依次与 bucket-&gt;elements.many 中的值进行比较 你可能觉得到这里的时间复杂度比较糟糕，然而这个列表并不会很长，具体会在 NXHashInsert 中解释。 NXHashGet 其实我一直觉得这个方法可能用处不是很大，尤其是在使用默认的 NXHashTablePrototype 时，因为默认的 NXHashTablePrototype 中的 isEqual 函数指针只是比较两个数据的指针是否相同。 其最大作用就是查看当前 data 是不是在表中。 如果当前数据在表中，那么这个方法只会返回一个相同的指针，没有太多的意义。 它的实现跟上面的 NXHashMember 区别并不大，这里就不过多介绍了： 1234567891011121314151617void *NXHashGet (NXHashTable *table, const void *data) &#123; HashBucket *bucket = BUCKETOF(table, data); unsigned j = bucket-&gt;count; const void **pairs; if (! j) return NULL; if (j == 1) &#123; return ISEQUAL(table, data, bucket-&gt;elements.one) ? (void *) bucket-&gt;elements.one : NULL; &#125;; pairs = bucket-&gt;elements.many; while (j--) &#123; if (ISEQUAL(table, data, *pairs)) return (void *) *pairs; pairs ++; &#125;; return NULL;&#125; NXHashInsertNXHashInsert 是 NXHashTable 中比较重要的方法，其作用就是向表中插入数据： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void *NXHashInsert (NXHashTable *table, const void *data) &#123; HashBucket *bucket = BUCKETOF(table, data); unsigned j = bucket-&gt;count; const void **pairs; const void **newt; if (! j) &#123; bucket-&gt;count++; bucket-&gt;elements.one = data; table-&gt;count++; return NULL; &#125;; if (j == 1) &#123; if (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123; const void *old = bucket-&gt;elements.one; bucket-&gt;elements.one = data; return (void *) old; &#125;; newt = ALLOCPAIRS(z, 2); newt[1] = bucket-&gt;elements.one; *newt = data; bucket-&gt;count++; bucket-&gt;elements.many = newt; table-&gt;count++; if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table); return NULL; &#125;; pairs = bucket-&gt;elements.many; while (j--) &#123; if (ISEQUAL(table, data, *pairs)) &#123; const void *old = *pairs; *pairs = data; return (void *) old; &#125;; pairs ++; &#125;; newt = ALLOCPAIRS(z, bucket-&gt;count+1); if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE); *newt = data; FREEPAIRS (bucket-&gt;elements.many); bucket-&gt;count++; bucket-&gt;elements.many = newt; table-&gt;count++; if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table); return NULL;&#125; 虽然这里的实现比上面的两个方法复杂得多，但是脉络仍然很清晰，我们将插入的过程分为三种情况： bucket-&gt;count == 0 bucket-&gt;count == 1 bucket-&gt;count &gt; 1 如果对应的 bucket 为空： 123456if (! j) &#123; bucket-&gt;count++; bucket-&gt;elements.one = data; table-&gt;count++; return NULL;&#125;; 将数据直接填入 bucket，增加 bucket 中元素的数目，以及 table 中存储的元素的数目：6_NXHashTable/ 如果原来的 buckets 中有一个元素，它会替换或者使用 many 替换原来的 one： 1234567891011121314151617if (j == 1) &#123; if (ISEQUAL(table, data, bucket-&gt;elements.one)) &#123; const void *old = bucket-&gt;elements.one; bucket-&gt;elements.one = data; return (void *) old; &#125;; newt = ALLOCPAIRS(z, 2); newt[1] = bucket-&gt;elements.one; *newt = data; bucket-&gt;count++; bucket-&gt;elements.many = newt; table-&gt;count++; ... return NULL;&#125;; 当前数据 data 如果与 bucket 中存储的数据相同，就会更新这个数据，否则就会使用 ALLOCPAIRS 初始化一个新的数组，然后将 data 和原来的数据传入。 但是如果原来的 bucket 中存储的元素大于 1，那么会在链表的头部追加一个新的元素： 123456789101112131415while (j--) &#123; if (ISEQUAL(table, data, *pairs)) &#123; const void *old = *pairs; *pairs = data; return (void *) old; &#125;; pairs ++;&#125;;newt = ALLOCPAIRS(z, bucket-&gt;count+1);if (bucket-&gt;count) bcopy ((const char*)bucket-&gt;elements.many, (char*)(newt+1), bucket-&gt;count * PTRSIZE);*newt = data;FREEPAIRS (bucket-&gt;elements.many);bucket-&gt;count++;bucket-&gt;elements.many = newt;table-&gt;count++; 上面的代码使用 bcopy 将原链表中元素拷贝到新的数组 newt 中。 在每次添加完一个元素之后，都会进行下面的判断： 1if (table-&gt;count &gt; table-&gt;nbBuckets) _NXHashRehash (table); 上面的这行代码会保证哈希表中的元素数据小于等于表中的 bucket 数量。 这就是 buckets 后面的列表非常短的原因，在理想情况下，每一个 buckets 中都只存储一个或零个元素。 _NXHashRehash如果哈希表在添加元素后，其中的数据多于 buckets 数量，就会对 NXHashTable 进行 _NXHashRehash 操作。 123static void _NXHashRehash (NXHashTable *table) &#123; _NXHashRehashToCapacity (table, MORE_CAPACITY(table-&gt;nbBuckets));&#125; 它调用 _NXHashRehashToCapacity 方法来扩大 NXHashTable 的容量（HashBucket 的个数）。 1#define MORE_CAPACITY(b) (b*2+1) 而 MORE_CAPACITY 会将当前哈希表的容量翻倍，并将新的容量传入 _NXHashRehashToCapacity 中： 12345678910111213141516171819void _NXHashRehashToCapacity (NXHashTable *table, unsigned newCapacity) &#123; NXHashTable *old; NXHashState state; void *aux; __unused void *z = ZONE_FROM_PTR(table); old = ALLOCTABLE(z); old-&gt;prototype = table-&gt;prototype; old-&gt;count = table-&gt;count; old-&gt;nbBuckets = table-&gt;nbBuckets; old-&gt;buckets = table-&gt;buckets; table-&gt;nbBuckets = newCapacity; table-&gt;count = 0; table-&gt;buckets = ALLOCBUCKETS(z, table-&gt;nbBuckets); state = NXInitHashState (old); while (NXNextHashState (old, &amp;state, &amp;aux)) (void) NXHashInsert (table, aux); freeBuckets (old, NO); free (old-&gt;buckets); free (old);&#125; 创建一个 NXHashTable 的指针指向原哈希表 改变哈希表的 nbBuckets，并重新初始化哈希表的 buckets 数组 重新将元素插入到哈希表中 释放原哈希表 old 以及 buckets NXHashState在将元素重新插入到哈希表中涉及了一个非常奇怪的结构体 NXHashState，这个结构体主要作用是遍历 NXHashTable 中的元素。 1234typedef struct &#123; int i; int j;&#125; NXHashState; 我们可以使用如下的代码对哈希表中的元素进行遍历： 123456unsigned count = 0;MyData *data;NXHashState state = NXInitHashState(table);while (NXNextHashState(table, &amp;state, &amp;data)) &#123; count++;&#125; 代码片段中调用了两个方法，分别是 NXInitHashState 以及 NXNextHashState： 1234567NXHashState NXInitHashState (NXHashTable *table) &#123; NXHashState state; state.i = table-&gt;nbBuckets; state.j = 0; return state;&#125;; NXInitHashState 会将 NXHashState 指向哈希表的最末端： 这个位置其实并不属于 NXHashTable，它一定会为空。 而每次调用 NXNextHashState 都会向『前』移动一次： 12345678910111213int NXNextHashState (NXHashTable *table, NXHashState *state, void **data) &#123; HashBucket *buckets = (HashBucket *) table-&gt;buckets; while (state-&gt;j == 0) &#123; if (state-&gt;i == 0) return NO; state-&gt;i--; state-&gt;j = buckets[state-&gt;i].count; &#125; state-&gt;j--; buckets += state-&gt;i; *data = (void *) ((buckets-&gt;count == 1) ? buckets-&gt;elements.one : buckets-&gt;elements.many[state-&gt;j]); return YES;&#125;; 下面的 gif 为我们展示了每一次调用 NXNextHashState 方法之后当前的 NXHashState： NXHashRemove这里的 NXHashRemove在某种意义上是 NXHashInsert 的逆操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445void *NXHashRemove (NXHashTable *table, const void *data) &#123; HashBucket *bucket = BUCKETOF(table, data); unsigned j = bucket-&gt;count; const void **pairs; const void **newt; __unused void *z = ZONE_FROM_PTR(table); if (! j) return NULL; if (j == 1) &#123; if (! ISEQUAL(table, data, bucket-&gt;elements.one)) return NULL; data = bucket-&gt;elements.one; table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.one = NULL; return (void *) data; &#125;; pairs = bucket-&gt;elements.many; if (j == 2) &#123; if (ISEQUAL(table, data, pairs[0])) &#123; bucket-&gt;elements.one = pairs[1]; data = pairs[0]; &#125; else if (ISEQUAL(table, data, pairs[1])) &#123; bucket-&gt;elements.one = pairs[0]; data = pairs[1]; &#125; else return NULL; FREEPAIRS (pairs); table-&gt;count--; bucket-&gt;count--; return (void *) data; &#125;; while (j--) &#123; if (ISEQUAL(table, data, *pairs)) &#123; data = *pairs; /* we shrink this bucket */ newt = (bucket-&gt;count-1) ? ALLOCPAIRS(z, bucket-&gt;count-1) : NULL; if (bucket-&gt;count-1 != j) bcopy ((const char*)bucket-&gt;elements.many, (char*)newt, PTRSIZE*(bucket-&gt;count-j-1)); if (j) bcopy ((const char*)(bucket-&gt;elements.many + bucket-&gt;count-j), (char*)(newt+bucket-&gt;count-j-1), PTRSIZE*j); FREEPAIRS (bucket-&gt;elements.many); table-&gt;count--; bucket-&gt;count--; bucket-&gt;elements.many = newt; return (void *) data; &#125;; pairs ++; &#125;; return NULL;&#125; 它的实现也分为三种情况，不过在这里就不多说了。 NXHashTable 的性能在已经熟悉了 NXHashTable 的具体实现之后，我们要分析插入不同数据量级的情况下，所需要的时间，这里是主程序的代码，分别测试了在 100, 1000, 10000, 100000, 1000000, 2000000, 3000000, 5000000, 10000000 数据下 NXHashTable 的性能表现： 12345678910111213141516171819202122232425262728293031323334#import &lt;Foundation/Foundation.h&gt;#import \"hashtable2.h\"int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSArray&lt;NSNumber *&gt; *capacities = @[ @100, @1000, @10000, @100000, @1000000, @2000000, @3000000, @5000000, @10000000 ]; for (NSNumber *capacity in capacities) &#123; NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, 0, NULL); NSDate *methodStart = [NSDate date]; for (NSInteger i = 0; i &lt; capacity.integerValue; i++) &#123; NSString *value = [NSString stringWithFormat:@\"%ld\", (long)i]; NXHashInsert(hashTable, (__bridge void *)value); &#125; NSDate *methodFinish = [NSDate date]; NSTimeInterval executionTime = [methodFinish timeIntervalSinceDate:methodStart]; NSLog(@\"Capacities: %@, executionTime = %f, meanTime = %.10f\", capacity, executionTime, executionTime / capacity.integerValue); free(hashTable); &#125; &#125; return 0;&#125; 代码中初始化了一个 capacities 存储需要测量的数据量级，然后调用 NXHashInsert 方法将相当数量级的数据添加到哈希表中： Capacities Execution Time Mean Time 100 0.000334 0.0000033402 1000 0.001962 0.0000019619 10000 0.022001 0.0000022001 100000 0.349998 0.0000035000 1000000 2.622551 0.0000026226 2000000 4.165023 0.0000020825 3000000 6.973098 0.0000023244 5000000 13.179743 0.0000026359 10000000 53.387356 0.0000053387 在对 NXHashTable 的性能测试中，当数据量小于 5000000 时，执行时间的增长还是线性的，平均时间也基本稳定，但是一旦数据量达到了千万级，执行时间就会出现显著的增长。 如果仅仅在哈希表中插入数据，相信其时间增长应该都是线性的，这里出现问题的原因推测是在对哈希表进行 Rehash 的时候，迁移原数据至新的数组所造成的。 如何避免哈希表的 Rehash 呢，重新回顾一下创建哈希表的函数： 1NXHashTable *NXCreateHashTable (NXHashTablePrototype prototype, unsigned capacity, const void *info); 这个函数的签名中包含一个 capacity 的参数，我们在上面的代码中传入了 0，也就是最开始的 buckets 数为 0，但是它的数目并不是固定的，它会随着哈希表中数据的增多，逐渐变大。 capacity 只是一个提示，帮助 NXHashTable 了解其中会存储多少数据。 如果在创建 NXHashTable 时传入 capacity.integerValue： 1NXHashTable *hashTable = NXCreateHashTable(NXPtrPrototype, capacity.integerValue, NULL); 重新运行代码，测量性能： Capacities Execution Time Mean Time 100 0.000740 0.0000073999 1000 0.003442 0.0000034420 10000 0.023341 0.0000023341 100000 0.215209 0.0000021521 1000000 1.836802 0.0000018368 2000000 3.683246 0.0000018416 3000000 5.474610 0.0000018249 5000000 10.576254 0.0000021153 10000000 46.725459 0.0000046725 虽然在测试 10,000,000 数据时其平均时间依然是 5,000,000 时的二倍，不过整体的性能都有所提升，然而这部分性能的损耗暂时还不是很清楚原因。 如果我们使用 Instrument 对有无 capacity 的情况进行比较（这是在使用 2,000,000 数据时进行的测试）： 没有传入 capacity 的哈希表会在多次插入之后出现一个峰值（由于 Rehash 引起的，其宽度就是 Rehash 使用的时间），而传入 capacity 的哈希表会在代码刚运行时就初始化足够大的数组。 NSMutableArray 性能 这部分只算是一个小插曲，你可以选择跳过这一小节的内容。 NSMutableArray 的构造器 - (instancetype)initWithCapacity:(NSUInteger)numItems 也有一个参数 capacity，虽然数组和哈希表是两种数据结构。 不过我们这里主要研究的是：传入 capacity 是否会对性能造成影响。 首先是使用 init 创建的 NSMutableArray 数组，也就是没有传入 capacity： Capacities Execution Time Mean Time 100 0.000539 0.0000053900 1000 0.003185 0.0000031850 10000 0.074033 0.0000074033 100000 0.370899 0.0000037090 1000000 1.504855 0.0000015049 2000000 2.852519 0.0000014263 3000000 3.995536 0.0000013318 5000000 6.833879 0.0000013668 10000000 14.444605 0.0000014445 下面是使用 initWithCapacity: 创建的数组： Capacities Execution Time Mean Time 100 0.000256 0.0000025600 1000 0.001775 0.0000017750 10000 0.015906 0.0000015906 100000 0.174376 0.0000017438 1000000 1.650481 0.0000016505 2000000 2.802310 0.0000014012 3000000 4.451261 0.0000014838 5000000 7.093753 0.0000014188 10000000 14.598415 0.0000014598 你可以在表格中看到，两者在执行效率上并没有显著的差异或者区别。 但是如果使用 instrument 来查看两者的内存分配，可以很明显的看到，没有传入 capacity 的 NSMutableArray 会在可变数组内存占用增加前出现一个短暂的内存分配峰值。 导致这一现象的原始可能是：在将原数组中的内容移入新数组时，临时变量申请了大量的内存空间。 在之后关于 CoreFoundation 源代码分析的文中会介绍它们是怎么实现的。 NXHashTable 的应用在整个 objc/runtime 中，作为私有的数据结构 NXHashTable，直接使用了它的就是存储所有类或者元类的哈希表（在这里会忽略对元类的存储，因为实现几乎完全相同）： 1static NXHashTable *realized_class_hash = nil; 我们可以使用 objc_copyClassList 获取类的数组： 12345678910111213141516171819202122232425Class *objc_copyClassList(unsigned int *outCount)&#123; rwlock_writer_t lock(runtimeLock); realizeAllClasses(); Class *result = nil; NXHashTable *classes = realizedClasses(); unsigned int count = NXCountHashTable(classes); if (count &gt; 0) &#123; Class cls; NXHashState state = NXInitHashState(classes); result = (Class *)malloc((1+count) * sizeof(Class)); count = 0; while (NXNextHashState(classes, &amp;state, (void **)&amp;cls)) &#123; result[count++] = cls; &#125; result[count] = nil; &#125; if (outCount) *outCount = count; return result;&#125; 调用 realizedClasses 返回 realized_class_hash 哈希表 使用 NSHashState 遍历 realized_class_hash 中的类，并将所有的类存入 result 接下来使用上面的方法，打印出 realized_class_hash 中存储的所有类： 小结 NXHashTable 在 OS X 10.1 中就已经标记为弃用了，但是依旧支持着 runtime 底层的工作。 NXHashTable 可以说有着非常非常久远的历史了，最早可以追溯到将近 30 多年前 NeXT 时代： 12345// hashtable2.mm 文件中hashtable2.mCopyright 1989-1996 NeXT Software, Inc.Created by Bertrand Serlet, Feb 89 NSHashTable 对哈希表的实现还是非常优雅的，可以说非常标准的使用了拉链法实现哈希表。 不过现在，我们会使用 NSHashTable 来取代这个上古时代的产物。 Follow: Draveness · Github 参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer","tags":[{"name":"list_array_tt","slug":"list-array-tt","permalink":"http://yoursite.com/tags/list-array-tt/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"5. list_array_tt 结构详解","date":"2018-11-20T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/5list_array_tt/","text":"list_array_tt 是个模板类，可以实例化出method_array_t，method_array_t在class_rw_t中使用，存储多个分类中的方法列表。 list_array_tt 总的源码和类图下面是list_array_tt的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203/*********************************************************************** Element 是元数据类型，比如 method_t List 是元数据的列表类型，比如 method_list_t 一个 list_array_tt 的值可能有三种情况： - 空的 - 一个指针指向一个单独的列表 - 一个数组，数组中都是指针，每个指针分别指向一个列表 * countLists/beginLists/endLists iterate the metadata lists* count/begin/end iterate the underlying metadata elements**********************************************************************/template &lt;typename Element, typename List&gt;class list_array_tt &#123; struct array_t &#123; uint32_t count; /// 有多少个List* List* lists[0]; static size_t byteSize(uint32_t count) &#123; return sizeof(array_t) + count*sizeof(lists[0]); &#125; size_t byteSize() &#123; return byteSize(count); &#125; &#125;; protected: class iterator &#123; List **lists; List **listsEnd; typename List::iterator m, mEnd; public: iterator(List **begin, List **end) : lists(begin), listsEnd(end) &#123; if (begin != end) &#123; m = (*begin)-&gt;begin(); mEnd = (*begin)-&gt;end(); &#125; &#125; const Element&amp; operator * () const &#123; return *m; &#125; Element&amp; operator * () &#123; return *m; &#125; bool operator != (const iterator&amp; rhs) const &#123; if (lists != rhs.lists) return true; if (lists == listsEnd) return false; // m is undefined if (m != rhs.m) return true; return false; &#125; const iterator&amp; operator ++ () &#123; assert(m != mEnd); m++; if (m == mEnd) &#123; assert(lists != listsEnd); lists++; if (lists != listsEnd) &#123; m = (*lists)-&gt;begin(); mEnd = (*lists)-&gt;end(); &#125; &#125; return *this; &#125; &#125;; private: union &#123; List* list; uintptr_t arrayAndFlag; &#125;; bool hasArray() const &#123; return arrayAndFlag &amp; 1; &#125; array_t *array() &#123; return (array_t *)(arrayAndFlag &amp; ~1); &#125; void setArray(array_t *array) &#123; arrayAndFlag = (uintptr_t)array | 1; &#125; public: /// 所有的list的所有元素总数 uint32_t count() &#123; uint32_t result = 0; for (auto lists = beginLists(), end = endLists(); lists != end; ++lists) &#123; result += (*lists)-&gt;count; &#125; return result; &#125; iterator begin() &#123; return iterator(beginLists(), endLists()); &#125; iterator end() &#123; List **e = endLists(); return iterator(e, e); &#125; uint32_t countLists() &#123; if (hasArray()) &#123; return array()-&gt;count; &#125; else if (list) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; List** beginLists() &#123; if (hasArray()) &#123; return array()-&gt;lists; &#125; else &#123; return &amp;list; &#125; &#125; List** endLists() &#123; if (hasArray()) &#123; return array()-&gt;lists + array()-&gt;count; &#125; else if (list) &#123; return &amp;list + 1; &#125; else &#123; return &amp;list; &#125; &#125; void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; void tryFree() &#123; if (hasArray()) &#123; for (uint32_t i = 0; i &lt; array()-&gt;count; i++) &#123; try_free(array()-&gt;lists[i]); &#125; try_free(array()); &#125; else if (list) &#123; try_free(list); &#125; &#125; template&lt;typename Result&gt; Result duplicate() &#123; Result result; if (hasArray()) &#123; array_t *a = array(); result.setArray((array_t *)memdup(a, a-&gt;byteSize())); for (uint32_t i = 0; i &lt; a-&gt;count; i++) &#123; result.array()-&gt;lists[i] = a-&gt;lists[i]-&gt;duplicate(); &#125; &#125; else if (list) &#123; result.list = list-&gt;duplicate(); &#125; else &#123; result.list = nil; &#125; return result; &#125;&#125;; 由图可以看出，list_array_tt结构的成员是一个匿名的union，或者存储单个类型为List*的list,或者存储多个列表，多个list使用arrayAndFlag表示，arrayAndFlag是个符合结构，低1位存储标志，高63位存储多个列表的地址，低位为1，表示多个列表，为0表示一个列表。 arrayAndFlag 高位存储一个地址，指向的类型是array_t，array_t有两个成员，第一个count表示列表的个数，lists存储List*类型的指针数组。 list_array_tt 部分源码分析下面看最基本的三个方法： 1234567891011bool hasArray() const &#123; return arrayAndFlag &amp; 1;&#125;array_t *array() &#123; return (array_t *)(arrayAndFlag &amp; ~1);&#125;void setArray(array_t *array) &#123; arrayAndFlag = (uintptr_t)array | 1;&#125; hasArray 判断存储的是一个列表，还是多个列表。 array返回多个列表的地址，返回类型是array_t * setArray设置多个列表。将多个列表的地址和1与操作，存储在arrayAndFlag中。 下面首先看beginLists、endLists方法： 1234567891011121314151617List** beginLists() &#123; if (hasArray()) &#123; return array()-&gt;lists; &#125; else &#123; return &amp;list; &#125;&#125;List** endLists() &#123; if (hasArray()) &#123; return array()-&gt;lists + array()-&gt;count; &#125; else if (list) &#123; return &amp;list + 1; &#125; else &#123; return &amp;list; &#125;&#125; beginLists 返回列表的首元素的地址，endLists返回列表尾后元素的地址。为了方便理解，画了下图： 图中需要注意命名规则，list表示单个列表，lists表示多个列表。 如上图所示，当list_array_tt存储一个List*时，beginLists返回list的地址、当list_array_tt存储多个List*时，beginLists返回lists的地址，返回类型是List**。 同理，当list_array_tt存储一个List*时，endLists返回list尾后地址、当list_array_tt存储多个List*时，endLists返回lists的尾后地址，就是最后一个List的末尾。返回类型是`List*` 图中红色的线表示beginLists、endLists指向的地址。 下面在来看countLists方法。123456789uint32_t countLists() &#123; if (hasArray()) &#123; return array()-&gt;count; &#125; else if (list) &#123; return 1; &#125; else &#123; return 0; &#125;&#125; countLists返回List*的个数，如果是单个列表，返回1，多个列表返回array()-&gt;count。 下面看最关键的函数attachLists，这个函数个将分类的方法列表添加到原始类的方法列表上面。 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125;&#125; 这个函数分为三部分，分别处理： 多个列表添加新的列表 单个列表添加新的列表 空列表添加新的列表 多个列表时： 首先计算所有列表的总数，申请大的空间，将原有列表和新addedLists添加到新的空间中。 else if是处理在空列表中添加一个新元素的列表addedLists。 else 分支处理在空列表中添加多个元素的列表、或者在原来一个元素的列表(list)中添加新列表addedLists，添加的结果列表中存储多个列表。所以一起处理。处理的流程和第一个分支类似。 下面是部分在原有5个元素的列中中添加两个元素的列表addedLists的示意图。 list_array_tt 迭代器下面看begin、end方法： 12345678iterator begin() &#123; return iterator(beginLists(), endLists());&#125;iterator end() &#123; List **e = endLists(); return iterator(e, e);&#125; begin、end方法返回list_array_tt的首元素迭代器和尾后元素迭代器。 迭代器有四个元素： 123List **lists;List **listsEnd;typename List::iterator m, mEnd; 首迭代器四个成员指向的位置如图所示： 根据上图可以容易的理解迭代器的各个成员的指向。那么迭代器重要的操作++就比较容易理解了。代码如下： 12345678910111213const iterator&amp; operator ++ () &#123; assert(m != mEnd); m++; if (m == mEnd) &#123; assert(lists != listsEnd); lists++; if (lists != listsEnd) &#123; m = (*lists)-&gt;begin(); mEnd = (*lists)-&gt;end(); &#125; &#125; return *this;&#125; 首先在是类别的元素的（method_t）的迭代器指向++操作，即m执行++，如果元素的迭代器迭代完成，即，m==mEnd,退出到外部，指向lists的++操作,然后在继续内部元素的迭代器操作。以此类推。 参考资料 Classes and Metaclasses Tagged Pointer 类型编码 Type Encodings","tags":[{"name":"list_array_tt","slug":"list-array-tt","permalink":"http://yoursite.com/tags/list-array-tt/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"4. 方法列表entsize_list_tt结构","date":"2018-11-03T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/4entsize_list_tt/","text":"本文讲解entsize_list_tt方法列表的数据结构。本节代码位于objc-runtime-new.h头文件中 entsize_list_tt 简单介绍类的编译后的数据存储在class_ro_t结构中，其中各种方法列表、变量列表、属性列表的类型分别是method_list_t、ivar_list_t、property_list_t，这些类型全部继承于entsize_list_tt。class_ro_t的定义如下： 12345678// RO 就是 Read Onlystruct class_ro_t &#123; ... method_list_t * baseMethodList; // 基本方法列表，存储编译期确定的方法 const ivar_list_t * ivars; // 类的成员变量列表，存储编译期确定的成员变量 property_list_t *baseProperties; // 基本属性列表，存储编译期确定的属性 ...&#125;; method_list_t 继承于entsize_list_tt 的源码如下： 1234struct method_list_t : entsize_list_tt&lt;method_t, method_list_t, 0x3&gt; &#123; // 0x3 就是 0b11 // 即 flag 占 2 个 bit，用来放 fixedup markers ....&#125;; 下面就开始学习entsize_list_tt数据结构。 entsize_list_tt 详细分析entsize_list_tt其实就是一个列表，用来存储编译完成后类的属性。由于位于class_ro_t结构中，所以这个结构是只读的，没有写方法，只有访问的相关方法，定义如下，只包含了部分代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// entsize_list_tt 可以理解为一个容器，拥有自己的迭代器用于遍历所有元素。// Element 表示元素类型，List 用于指定容器类型，// 最后一个参数为标记位, 用来在 entsize field 里存放一些额外的 bits，也就是 flagstemplate &lt;typename Element, typename List, uint32_t FlagMask&gt;struct entsize_list_tt &#123; // entsize 和 flags 存在了一起，需要用 FlagMask 进行区分哪些 bits 里存的是 flags // entsize 就是每个元素的大小 uint32_t entsizeAndFlags; uint32_t count; // 元素的总数 Element first; // 第一个元素，其他的元素紧跟在其后面 // 取出 entsize 单个元素的大小 uint32_t entsize() const &#123; return entsizeAndFlags &amp; ~FlagMask; &#125; // 取出 flags uint32_t flags() const &#123; return entsizeAndFlags &amp; FlagMask; &#125; // 取得指定 索引 处的元素，i &lt;= count // 如果 i 等于 count，取得的就是最后一个元素的末尾地址 Element&amp; getOrEnd(uint32_t i) const &#123; assert(i &lt;= count); // 从第一个元素开始，加上偏移量 i * 单个元素的大小 // 就是 i 索引处的元素 return *(Element *)((uint8_t *)&amp;first + i*entsize()); &#125; // 取得指定 索引 处的元素 // i 必须小于总数 Element&amp; get(uint32_t i) const &#123; assert(i &lt; count); return getOrEnd(i); &#125; // 取得整个 entsize_list_tt 对象以及其保存的所有元素占多少内存 size_t byteSize() const &#123; // sizeof(*this) 计算是对象本身占的大小，其中还包括了第一个元素 // (count-1)*entsize() 计算的是除了第一个元素外，其他所有元素占的大小 return sizeof(*this) + (count-1)*entsize(); &#125; // 向前声明 struct iterator; // 取得指向容器的第一个元素的迭代器，返回值是变量，可以变 iterator begin() &#123; return iterator(*static_cast&lt;const List*&gt;(this), 0); &#125; // 取得指向容器尾部的迭代器，注意是尾部，也就是最后一个元素的末尾，并不是最后的一个元素 iterator end() &#123; return iterator(*static_cast&lt;const List*&gt;(this), count); &#125; // 向前声明 struct iterator &#123; uint32_t entsize; // 元素的大小 uint32_t index; // 当前的索引 // keeping track of this saves a divide in operator- Element* element; // 指向当前的元素的指针 // 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上 // start 是当前的索引 iterator(const List&amp; list, uint32_t start = 0) : entsize(list.entsize()) // 记录 List 中单个元素的大小 , index(start) // 记录当前的索引 , element(&amp;list.getOrEnd(start)) // 保存当前的元素的地址 &#123; &#125; // 迭代器向后移动 delta 个位置 const iterator&amp; operator += (ptrdiff_t delta) &#123; // 计算出新元素的地址，保存起来 element = (Element*)((uint8_t *)element + delta*entsize); // 索引也加上 delta index += (int32_t)delta; return *this; &#125; .... &#125;;&#125;; entsize_list_tt 是个模板，可以实例化出method_list_t、ivar_list_t、property_list_t三种类型。有三个数据成员，entsizeAndFlags 是个复合成员，高位表示元素的大小，低位是个标志位，entsize、Flags具体占用多少位，根据模板参数FlagMask决定。例如： 12345678//0x3 就是 0b11,即 flag 占 2 个 bitstruct method_list_t : entsize_list_tt&lt;method_t, method_list_t, 0x3&gt;//flag 占 0 个 bitstruct ivar_list_t : entsize_list_tt&lt;ivar_t, ivar_list_t, 0&gt;// flag 占 0 个 bitstruct property_list_t : entsize_list_tt&lt;property_t, property_list_t, 0&gt; method_list_t 实例化时，递给FlagMask的模板实参是0x3，转化为二进制为0b11，占用两位。那么在method_list_t结构中，entsizeAndFlags 表示的entsize占用30位，Flags占用2位。 count 表示列表中存储元素的个数，first 表示首元素。注意他不是个指针，只是一个首元素，后面的元素会挨着first顺序存储。 method_list_t 的方法基本都是访问属性的。慢慢看着注释应该嫩看懂。 类图以方法列表method_list_t为例，里面存储的元素是method_t类型： entisize_list_tt 内存布局为了进一步理解这个结构，我用hopper抓了一个这样的结构，如图所示， 我们将这个数据放入内存，内存结构大致如下： entsizeAndFlags 的值是0x18，转化为二进制，为0b1,1000，那么entsize的值去高20位，还是0b1,1000，十进制为24表示元素的大小是24，然后继续看元素，元素的类型是method_t，大小为24，验证了entsize的含义。flag取低二位，为0 。 接下来的count的值是3，表示有三个元素。后面紧跟着三个元素。 迭代器既然entsize_list_tt是一个列表，那么就需要一个迭代器，从而枚举列表内部的元素。迭代器是个内部类，重载了很多方法，迭代器类主要的方法是构造函数，剩下的全部是重载运算符，大致雷同。 1234567891011uint32_t entsize; // 元素的大小uint32_t index; // 当前的索引 // keeping track of this saves a divide in operator-Element* element; // 指向当前的元素的指针// 真正有用的构造函数，参数 list 是迭代器用在哪个 List 上// start 是当前的索引iterator(const List&amp; list, uint32_t start = 0) : entsize(list.entsize()) // 记录 List 中单个元素的大小 , index(start) // 记录当前的索引 , element(&amp;list.getOrEnd(start)) // 保存当前的元素的地址&#123; &#125; 下面是迭代器的示意图。 示意图中列出指向首元素的迭代器begin、尾后迭代器end、和begin+2的内存结构。","tags":[{"name":"entsize_list_tt","slug":"entsize-list-tt","permalink":"http://yoursite.com/tags/entsize-list-tt/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"3. NSObject 基本完整类图","date":"2018-11-02T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/3NSObject/","text":"本文保存了NSObject的基本完整类图。方便以后理解。 NSObject 完整类图NSObject 基本完整类图如下： objc_class 有四个成员，本图说明两个非常重要的成员- isa、bits。 isa指向对象的类（或者类的元类）；bits定义了类的数据，包括类的属性、方法、协议、ivar 。 它的类型是class_data_bits_t，class_data_bits_t 有一个成员，类型是uintptr_t，64位。其中1~3位表示一个属性，3~47位表示一个指针，如果class还没有实现，这个指针指向class_ro_t类型，表示类编译完后的只读属性。当类实现后，这个指针指向了class_rw_t类型，表示runtime实现完class后类的数据，这是，数据里面已经包括了分类的方法信息。 使用hopper查看类结构首先定义类LJObject，头文件如下： 12345678910111213141516//LJObject.h@interface LJObject : NSObject@property(nonatomic, strong) NSString *strName;@property(nonatomic, strong)NSString *strVale;-(NSString *) funcName:(NSString *) strName;-(NSString *) funcValue:(NSString *)strValue;+(NSString*) printDefaultName:(NSString *) strName;+(NSString *)printDefaultValue:(NSString *)strValue;@end 实现文件如下 ： 12345678910111213141516171819202122232425#import \"LJObject.h\"@implementation LJObject-(NSString *) funcName:(NSString *) strName&#123;return nil;&#125;-(NSString *) funcValue:(NSString *)strValue&#123;return nil;&#125;+(NSString*) printDefaultName:(NSString *) strName&#123;return nil;&#125;+(NSString *)printDefaultValue:(NSString *)strValue&#123;return nil;&#125;@end 使用hopper查看的结构如下： 五小结构method_t方法的定义如下 ： 123456// 方法结构体struct method_t &#123; SEL name; // 方法名，就是 SEL const char *types; // 方法类型字符串，有的地方又称 method signature 方法签名 IMP imp; // 指向方法的函数实现的指针&#125; 类图如下： hopper查看的结果如下： 总结method_t值包含三个属性，方法名字、方法签名、方法的实现。 ivar_t定义如下： 123456789// 成员变量结构体struct ivar_t &#123; int32_t *offset; // 偏移量 用 __OFFSETOFIVAR__ 计算 const char *name; // 成员变量名 比如 \"_name\" const char *type; // 成员变量的类型 比如 \"@\\\"NSString\\\"\" // alignment is sometimes -1; use alignment() instead uint32_t alignment_raw; // 对齐 uint32_t size; // 成员变量占多少内存&#125;; 类图如下： property_t定义如下： 123456// 属性结构体struct property_t &#123; const char *name; // 属性名，堆中分配 const char *attributes; // 属性的特性字符串，标识了属性有哪些特性 // 该字符串是在堆中分配的&#125;; 类图如下： protocol_t定义如下 123456789101112131415161718192021222324252627282930313233343536// 协议结构体，继承自 objc_objectstruct protocol_t : objc_object &#123; const char *mangledName; // 重整后的协议名称，为了兼容 swift 协议而准备的， // 它在 objc_allocateProtocol() 中被赋值， // 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样， // 重整名字是编译器给出的，加了 swift 复杂前缀的，用于混编时区分 oc协议 和 swift协议， // 而 demangledName 取消重整的名称，应该就是去掉前缀的正常的名字 struct protocol_list_t *protocols; // 子协议列表，见 protocol_addProtocol() // 又可以称为 incorporated protocols 合并的协议 method_list_t *instanceMethods; // 必选(required)的实例方法 method_list_t *classMethods; // 必选(required)的类方法 method_list_t *optionalInstanceMethods; // 可选(optional)的实例方法 method_list_t *optionalClassMethods; // 可选(optional)的类方法 property_list_t *instanceProperties; // 实例属性，当前协议只支持 required 的实例属性， // 协议中也是可以添加属性的， // 不知道会不会生成成员变量，但生成 set 和 get 方法是一定有的 // 比如 NSObject 协议，就有几个 readonly 的属性 uint32_t size; // 这个协议的大小，其中也包括了 extendedMethodTypes 整个数组的大小 uint32_t flags; // 标记 跟 PROTOCOL_FIXED_UP_1 / PROTOCOL_FIXED_UP_2 有关系 // Fields below this point are not always present on disk. // 这句话的意思，好像是下面这几个成员变量不一定有， // 所以用到它们的时候都检查了下 size 是否足够大，比如 hasExtendedMethodTypesField() 和 protocol_t::demangledName() const char **extendedMethodTypes; // 扩展方法类型数组，每个元素是一个扩展类型字符串 const char *_demangledName; // 取消重整的协议名称，为了兼容 swift 协议而准备的， // 普通 oc 的协议重整前后的名字是一样的，而 swift 的协议重整前后名字不一样 // 见 demangledName() // demangledName 取消重整的名称，应该就是去掉 swift 前缀的正常的名字&#125; 类图如下： category_t定义如下： 12345678struct category_t &#123; const char *name; // 分类的名字 classref_t cls; // 分类所属的类，classref_t 专门用于 unremapped 的类 struct method_list_t *instanceMethods; // 实例方法列表 struct method_list_t *classMethods; // 类方法列表 struct protocol_list_t *protocols; // 遵循的协议列表 struct property_list_t *instanceProperties; // 属性列表，但是并没有卵用... 唉....&#125; 类图如下： 五小结构总图","tags":[{"name":"NSObject","slug":"NSObject","permalink":"http://yoursite.com/tags/NSObject/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"2. class_data_bits_t 结构","date":"2018-11-01T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/2_NSObject_objc_object/","text":"因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。 在上一篇分析 isa 的文章从 NSObject 的初始化了解 isa 中曾经说到过实例方法被调用时，会通过其持有 isa 指针寻找对应的类，然后在其中的 class_data_bits_t 中查找对应的方法，在这一篇文章中会介绍方法在 ObjC 中是如何存储方法的。 这篇文章的首先会根据 ObjC 源代码来分析方法在内存中的存储结构，然后在 lldb 调试器中一步一步验证分析的正确性。 方法在内存中的位置先来了解一下 ObjC 中类的结构图： isa 是指向元类的指针，不了解元类的可以看 Classes and Metaclasses super_class 指向当前类的父类 cache 用于缓存指针和 vtable，加速方法的调用 bits 就是存储类的方法、属性和遵循的协议等信息的地方 class_data_bits_t 结构体这一小结会分析类结构体中的 class_data_bits_t bits。其中只含有一个 64 位的 bits 用于存储与类有关的信息，它的定义如下 ： 1234567struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits; // 只有这个一个成员变量，所有数据都存在这里，包括 rw 的地址和一些 flag // 1. 在 realized 之前，bits 存的是 ro 的地址， // 2. realized 后，bits 存 rw 的地址，rw 里的存有 ro 的地址&#125; 从定义可以看出，这只用一个成员，但是也类似位域，不同的位有不同的作用，bit不像isa使用位域定义，他使用移位定义，如下: 123456789// class is a Swift class#define FAST_IS_SWIFT (1UL&lt;&lt;0) // 用于判断 Swift 类// class or superclass has default retain/release/autorelease/retainCount/// _tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;1) // 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法// class's instances requires raw isa#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;2) // 当前类的实例需要 raw isa// data pointer#define FAST_DATA_MASK 0x00007ffffffffff8UL // 存 rw 的地址的位置 全部是FAST开头，说明可以快速取到，而不用去次级对象中取。还有以RW、RO开头的宏，表示在次级的class_rw_t、class_ro_t结构的标志位。class_data_bits_t的类图如下： 在 objc_class 结构体中的注释写到 class_data_bits_t 相当于 class_rw_t 指针加上 rr/alloc 的标志。 1class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags 它为我们提供了便捷方法用于返回其中的 class_rw_t * 指针： 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; 将 bits 与 FAST_DATA_MASK 进行位运算，只取其中的 [3, 47] 位转换成 class_rw_t * 返回。 在 x86_64 架构上，Mac OS 只使用了其中的 47 位来为对象分配地址。而且由于地址要按字节在内存中按字节对齐，所以掩码的后三位都是 0。 因为 class_rw_t * 指针只存于第 [3, 47] 位，所以可以使用最后三位来存储关于当前类的其他信息： 1234#define FAST_IS_SWIFT (1UL&lt;&lt;0)#define FAST_HAS_DEFAULT_RR (1UL&lt;&lt;1)#define FAST_REQUIRES_RAW_ISA (1UL&lt;&lt;2)#define FAST_DATA_MASK 0x00007ffffffffff8UL isSwift() FAST_IS_SWIFT 用于判断 Swift 类 hasDefaultRR() FAST_HAS_DEFAULT_RR 当前类或者父类含有默认的 retain/release/autorelease/retainCount/_tryRetain/_isDeallocating/retainWeakReference/allowsWeakReference 方法 requiresRawIsa() FAST_REQUIRES_RAW_ISA 当前类的实例需要 raw isa 执行 class_data_bits_t 结构体中的 data() 方法或者调用 objc_class 中的 data() 方法会返回同一个 class_rw_t * 指针，因为 objc_class 中的方法只是对 class_data_bits_t 中对应方法的封装。 12345678910111213// objc_class 中的 data() 方法class_data_bits_t bits;class_rw_t *data() &#123; return bits.data();&#125;// class_data_bits_t 中的 data() 方法uintptr_t bits;class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; class_rw_t 和 class_ro_tObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中： 12345678910111213struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass;&#125;; 其中还有一个指向常量的指针 ro，其中存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。 12345678910111213141516struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; uint32_t reserved; const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;; 在编译期间类的结构中的 class_data_bits_t *data 指向的是一个 class_ro_t * 指针： 然后在加载 ObjC 运行时的时候调用 realizeClass 方法： 从 class_data_bits_t 调用 data 方法，将结果从 class_rw_t 强制转换为 class_ro_t 指针 初始化一个 class_rw_t 结构体 设置结构体 ro 的值以及 flag 最后设置正确的 data。 12345const class_ro_t *ro = (const class_ro_t *)cls-&gt;data();class_rw_t *rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw); 下图是 realizeClass 方法执行过后的类所占用内存的布局，你可以与上面调用方法前的内存布局对比以下，看有哪些更改： 但是，在这段代码运行之后 class_rw_t 中的方法，属性以及协议列表均为空。这时需要 realizeClass 调用 methodizeClass 方法来将类自己实现的方法（包括分类）、属性和遵循的协议加载到 methods、 properties 和 protocols 列表中。 XXObject下面，我们将分析一个类 XXObject 在运行时初始化过程中内存的更改，这是 XXObject 的接口与实现： 1234567891011121314151617181920// XXObject.h 文件#import &lt;Foundation/Foundation.h&gt;@interface XXObject : NSObject- (void)hello;@end// XXObject.m 文件#import \"XXObject.h\"@implementation XXObject- (void)hello &#123; NSLog(@\"Hello\");&#125;@end 这段代码是运行在 Mac OS X 10.11.3 (x86_64)版本中，而不是运行在 iPhone 模拟器或者真机上的，如果你在 iPhone 或者真机上运行，可能有一定差别。 这是主程序的代码： 12345678910#import &lt;Foundation/Foundation.h&gt;#import &quot;XXObject.h&quot;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Class cls = [XXObject class]; NSLog(@&quot;%p&quot;, cls); &#125; return 0;&#125; 编译后内存中类的结构因为类在内存中的位置是编译期就确定的，先运行一次代码获取 XXObject 在内存中的地址。 10x100001168 接下来，在整个 ObjC 运行时初始化之前，也就是 _objc_init 方法中加入一个断点： 然后在 lldb 中输入以下命令： 1234567891011121314151617181920212223(lldb) p (objc_class *)0x100001168(objc_class *) $0 = 0x0000000100001168(lldb) p (class_data_bits_t *)0x100001188(class_data_bits_t *) $1 = 0x0000000100001188(lldb) p $1-&gt;data()warning: could not load any Objective-C class information. This will significantly reduce the quality of type information available.(class_rw_t *) $2 = 0x00000001000010e8(lldb) p (class_ro_t *)$2 // 将 class_rw_t 强制转化为 class_ro_t(class_ro_t *) $3 = 0x00000001000010e8(lldb) p *$3(class_ro_t) $4 = &#123; flags = 128 instanceStart = 8 instanceSize = 8 reserved = 0 ivarLayout = 0x0000000000000000 &lt;no value available&gt; name = 0x0000000100000f7a \"XXObject\" baseMethodList = 0x00000001000010c8 baseProtocols = 0x0000000000000000 ivars = 0x0000000000000000 weakIvarLayout = 0x0000000000000000 &lt;no value available&gt; baseProperties = 0x0000000000000000&#125; 现在我们获取了类经过编译器处理后的只读属性 class_ro_t： 12345678910111213(class_ro_t) $4 = &#123; flags = 128 instanceStart = 8 instanceSize = 8 reserved = 0 ivarLayout = 0x0000000000000000 &lt;no value available&gt; name = 0x0000000100000f7a \"XXObject\" baseMethodList = 0x00000001000010c8 baseProtocols = 0x0000000000000000 ivars = 0x0000000000000000 weakIvarLayout = 0x0000000000000000 &lt;no value available&gt; baseProperties = 0x0000000000000000&#125; 可以看到这里面只有 baseMethodList 和 name 是有值的，其它的 ivarLayout、 baseProtocols、 ivars、weakIvarLayout 和 baseProperties 都指向了空指针，因为类中没有实例变量，协议以及属性。所以这里的结构体符合我们的预期。 通过下面的命令查看 baseMethodList 中的内容： 12345678910111213(lldb) p $4.baseMethodList(method_list_t *) $5 = 0x00000001000010c8(lldb) p $5-&gt;get(0)(method_t) $6 = &#123; name = \"hello\" types = 0x0000000100000fa4 \"v16@0:8\" imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13)&#125;(lldb) p $5-&gt;get(1)Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line 110.error: Execution was interrupted, reason: signal SIGABRT.The process has been returned to the state before expression evaluation.(lldb) 使用 $5-&gt;get(0) 时，成功获取到了 -[XXObject hello] 方法的结构体 method_t。而尝试获取下一个方法时，断言提示我们当前类只有一个方法。 realizeClass这篇文章中不会对 realizeClass 进行详细的分析，该方法的主要作用是对类进行第一次初始化，其中包括： 分配可读写数据空间 返回真正的类结构 1static Class realizeClass(Class cls) 上面就是这个方法的签名，我们需要在这个方法中打一个条件断点，来判断当前类是否为 XXObject： 这里直接判断两个指针是否相等，而不使用 [NSStringFromClass(cls) isEqualToString:@&quot;XXObject&quot;] 是因为在这个时间点，这些方法都不能调用，在 ObjC 中没有这些方法，所以只能通过判断类指针是否相等的方式来确认当前类是 XXObject。 直接与指针比较是因为类在内存中的位置是编译期确定的，只要代码不改变，类在内存中的位置就会不变（已经说过很多遍了）。 这个断点就设置在这里，因为 XXObject 是一个正常的类，所以会走 else 分支为可写的类数据分配内存。 运行代码时，因为每次都会判断当前类指针是不是指向的 XXObject，所以会等一会才会进入断点。 在这时打印类结构体中的 data 的值，发现其中的布局依旧是这样的： 在运行完这段代码之后: 我们再来打印类的结构: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970(lldb) p (objc_class *)cls // 打印类指针(objc_class *) $262 = 0x0000000100001168(lldb) p (class_data_bits_t *)0x0000000100001188 // 在类指针上加 32 的 offset 打印 class_data_bits_t 指针(class_data_bits_t *) $263 = 0x0000000100001188(lldb) p *$263 // 访问 class_data_bits_t 指针的内容(class_data_bits_t) $264 = (bits = 4302315312)(lldb) p $264.data() // 获取 class_rw_t(class_rw_t *) $265 = 0x0000000100701f30(lldb) p *$265 // 访问 class_rw_t 指针的内容，发现它的 ro 已经设置好了(class_rw_t) $266 = &#123; flags = 2148007936 version = 0 ro = 0x00000001000010e8 methods = &#123; list_array_tt&lt;method_t, method_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; properties = &#123; list_array_tt&lt;property_t, property_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; protocols = &#123; list_array_tt&lt;unsigned long, protocol_list_t&gt; = &#123; = &#123; list = 0x0000000000000000 arrayAndFlag = 0 &#125; &#125; &#125; firstSubclass = nil nextSiblingClass = nil demangledName = 0x0000000000000000 &lt;no value available&gt;&#125;(lldb) p $266.ro // 获取 class_ro_t 指针(const class_ro_t *) $267 = 0x00000001000010e8(lldb) p *$267 // 访问 class_ro_t 指针的内容(const class_ro_t) $268 = &#123; flags = 128 instanceStart = 8 instanceSize = 8 reserved = 0 ivarLayout = 0x0000000000000000 &lt;no value available&gt; name = 0x0000000100000f7a \"XXObject\" baseMethodList = 0x00000001000010c8 baseProtocols = 0x0000000000000000 ivars = 0x0000000000000000 weakIvarLayout = 0x0000000000000000 &lt;no value available&gt; baseProperties = 0x0000000000000000&#125;(lldb) p $268.baseMethodList // 获取基本方法列表(method_list_t *const) $269 = 0x00000001000010c8(lldb) p $269-&gt;get(0) // 访问第一个方法(method_t) $270 = &#123; name = \"hello\" types = 0x0000000100000fa4 \"v16@0:8\" imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13)&#125;(lldb) p $269-&gt;get(1) // 尝试访问第二个方法，越界error: Execution was interrupted, reason: signal SIGABRT.The process has been returned to the state before expression evaluation.Assertion failed: (i &lt; count), function get, file /Users/apple/Desktop/objc-runtime/runtime/objc-runtime-new.h, line 110.(lldb) 最后一个操作实在是截取不到了 12345const class_ro_t *ro = (const class_ro_t *)cls-&gt;data();class_rw_t *rw = (class_rw_t *)calloc(sizeof(class_rw_t), 1);rw-&gt;ro = ro;rw-&gt;flags = RW_REALIZED|RW_REALIZING;cls-&gt;setData(rw); 在上述的代码运行之后，类的只读指针 class_ro_t 以及可读写指针 class_rw_t 都被正确的设置了。但是到这里，其 class_rw_t 部分的方法等成员的指针 methods、 protocols 和 properties 均为空，这些会在 methodizeClass 中进行设置： 在这里调用了 method_array_t 的 attachLists 方法，将 baseMethods 中的方法添加到 methods 数组之后。我们访问 methods 才会获取当前类的实例方法。 方法的结构说了这么多，到现在我们可以简单看一下方法的结构，与类和对象一样，方法在内存中也是一个结构体。 12345struct method_t &#123; SEL name; const char *types; IMP imp;&#125;; 其中包含方法名，类型还有方法的实现指针 IMP： 上面的 -[XXObject hello] 方法的结构体是这样的： 123name = \"hello\"types = 0x0000000100000fa4 \"v16@0:8\"imp = 0x0000000100000e90 (method`-[XXObject hello] at XXObject.m:13 方法的名字在这里没有什么好说的。其中，方法的类型是一个非常奇怪的字符串 &quot;v16@0:8&quot; 这在 ObjC 中叫做类型编码(Type Encoding)，你可以看这篇官方文档了解与类型编码相关的信息。 对于方法的实现，lldb 为我们标注了方法在文件中实现的位置。 小结在分析方法在内存中的位置时，笔者最开始一直在尝试寻找只读结构体 class_ro_t 中 baseMethods 第一次设置的位置（了解类的方法是如何被加载的）。尝试从 methodizeClass 方法一直向上找，直到 _obj_init 方法也没有找到设置只读区域的 baseMethods 的方法。 而且在 runtime 初始化之后，realizeClass 之前，从 class_data_bits_t 结构体中获取的 class_rw_t 一直都是错误的，这个问题在最开始非常让我困惑，直到后来在 realizeClass 中发现原来在这时并不是 class_rw_t 结构体，而是class_ro_t，才明白错误的原因。 后来突然想到类的一些方法、属性和协议实在编译期决定的（baseMethods 等成员以及类在内存中的位置都是编译期决定的），才感觉到豁然开朗。 类在内存中的位置是在编译期间决定的，在之后修改代码，也不会改变内存中的位置。 类的方法、属性以及协议在编译期间存放到了“错误”的位置，直到 realizeClass 执行之后，才放到了 class_rw_t 指向的只读区域 class_ro_t，这样我们即可以在运行时为 class_rw_t 添加方法，也不会影响类的只读结构。 在 class_ro_t 中的属性在运行期间就不能改变了，再添加方法时，会修改 class_rw_t 中的 methods 列表，而不是 class_ro_t 中的 baseMethods，对于方法的添加会在之后的文章中分析。 参考资料 Classes and Metaclasses Tagged Pointer 类型编码 Type Encodings Follow: @Draveness","tags":[{"name":"NSObject","slug":"NSObject","permalink":"http://yoursite.com/tags/NSObject/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"1. 从 NSObject 的初始化了解 isa（转载)","date":"2018-11-01T02:38:11.000Z","path":"wiki/IOS/Runtime/objc/1_NSObject_isa/","text":"本文讲解Runtime中的isa指针，本文全部抄袭， 代码位于《objc-private.h》文件 因为 ObjC 的 runtime 只能在 Mac OS 下才能编译，所以文章中的代码都是在 Mac OS，也就是 x86_64 架构下运行的，对于在 arm64 中运行的代码会特别说明。 OC的类是一个结构体所有的OC类其实都是一个c语言的结构体，我们可以通过clang -rewrite-objc 命令重写OC类为C++类。来理解OC的类就是一个C语言的结构体。下面是重写的实例，类的定义如下： 123456789101112131415161718192021@interface LJObjc:NSObject@property(nonatomic, strong) NSString *strName;@property(nonatomic, strong)NSString *strVale;-(NSString *) funcName:(NSString *) strName;-(NSString *) funcValue:(NSString *)strValue;+(NSString*) printDefaultName:(NSString *) strName;+(NSString *)printDefaultValue:(NSString *)strValue;@end@implementation LJObjc@end 在从重写后的输出文件中，我们找到LJObjc的定义，定义如下： 1typedef struct objc_object LJObjc; 可以看出，OC类就是一个C的结构体。 既然所有的OC对都是一个结构体，这个结构体就是struct objc_object。定义如下： 123struct objc_object &#123; isa_t isa;&#125;; objc_object结构中只有一个 isa_t类型成员。所以我们可以说含有isa的结构体都是一个对象。 所有继承自 NSObject 的类实例化后的对象都会包含一个类型为 isa_t 的结构体。 虽然上面重写LJObjc后的C语言结构体是一个objc_object对象，但实际上他是一个objc_class结构体，由于objc_class继承与objc_object， 所以本质上objc_class 也是一个objc_object结构。objc_class定义如下： 123456struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; 由于 objc_class 结构体是继承自 objc_object 的，所以在这里显式地写出了 isa_t isa 这个成员变量。 到这里，我们就明白了：Objective-C 中类也是一个对象。 isa 指针的作用与元类 isa 包含了什么呢？回答这个问题之前，要引入了另一个概念 元类(meta class)，我们先了解一些关于元类的信息。 因为在 Objective-C 中，对象的方法并没有存储于对象的结构体中（如果每一个对象都保存了自己能执行的方法，那么对内存的占用有极大的影响）。 当实例方法被调用时，它要通过自己持有的 isa 来查找对应的类，然后在这里的 class_data_bits_t 结构体中查找对应方法的实现。同时，每一个 objc_class 也有一个指向自己的父类的指针 super_class 用来查找继承的方法。 关于如何在 class_data_bits_t 中查找对应方法会在之后的文章中讲到。这里只需要知道，它会在这个结构体中查找到对应方法的实现就可以了。深入解析 ObjC 中方法的结构 但是，这样就有一个问题，类方法的实现又是如何查找并且调用的呢？这时，就需要引入元类来保证无论是类还是对象都能通过相同的机制查找方法的实现。 让每一个类的 isa 指向对应的元类，这样就达到了使类方法和实例方法的调用机制相同的目的： 实例方法调用时，通过对象的 isa 在类中获取方法的实现 类方法调用时，通过类的 isa 在元类中获取方法的实现 下面这张图介绍了对象，类与元类之间的关系，笔者认为已经觉得足够清晰了，所以不在赘述。 图片来自 objc_explain_Classes_and_metaclasses 有关与介绍类与元类之间的关系的文章实在是太多了，因为这篇文章主要介绍 isa，在这一小节只是对其作用以及元类的概念进行介绍。如果想要了解更多关于类与元类的信息，可以看 What is a meta-class in Objective-C? 结构体 isa_t其实 isa_t 是一个定义得非常”奇怪”的结构体，在 ObjC 源代码中可以看到这样的定义： 12345678910111213141516171819202122232425#define ISA_MASK 0x00007ffffffffff8ULL#define ISA_MAGIC_MASK 0x001f800000000001ULL#define ISA_MAGIC_VALUE 0x001d800000000001ULL#define RC_ONE (1ULL&lt;&lt;56)#define RC_HALF (1ULL&lt;&lt;7)union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;&#125;; 这是在 __x86_64__ 上的实现，对于 iPhone5s 等架构为 __arm64__ 的设备上，具体结构体的实现和位数可能有些差别，不过这些字段都是存在的，可以看这里的 arm64 上结构体的实现 在本篇文章中, 我们会以 __x86_64__ 为例进行分析，而不会对两种架构下由于不同的内存布局方式导致的差异进行分析。在我看来，这个细节不会影响对 isa 指针的理解，不过还是要知道的。 下面是一张isa_t的类图，便于理解 笔者对这个 isa_t 的实现声明顺序有一些更改，更方便分析和理解。 123union isa_t &#123; ...&#125;; isa_t 是一个 union 类型的结构体，对 union 不熟悉的读者可以看这个 stackoverflow 上的回答. 也就是说其中的 cls、 bits 还有结构体共用同一块地址空间。而 isa 总共会占据 64 位的内存空间（决定于其中的结构体） 1234567891011struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;&#125;; isa 的初始化我们可以通过 isa 初始化的方法 initIsa 来初步了解这 64 位的 bits 的作用： 123456789101112131415161718///定义位于objc-object.h文件inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)&#123; initIsa(cls, true, hasCxxDtor);&#125;inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; indexed 和 magic当我们对一个 ObjC 对象分配内存时，其方法调用栈中包含了上述的两个方法，这里关注的重点是 initIsa 方法，由于在 initInstanceIsa 方法中传入了 indexed = true，所以，我们简化一下这个方法的实现： 123456inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;&#125; 对整个 isa 的值 bits 进行设置，传入 ISA_MAGIC_VALUE： 1#define ISA_MAGIC_VALUE 0x001d800000000001ULL 我们可以把它转换成二进制的数据，然后看一下哪些属性对应的位被这行代码初始化了（标记为红色）： 从图中了解到，在使用 ISA_MAGIC_VALUE 设置 isa_t 结构体之后，实际上只是设置了 indexed 以及 magic 这两部分的值。 其中 indexed 表示 isa_t 的类型 0 表示 raw isa，也就是没有结构体的部分，访问对象的 isa 会直接返回一个指向 cls 的指针，也就是在 iPhone 迁移到 64 位系统之前时 isa 的类型。 1234567union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125;; 1 表示当前 isa 不是指针，但是其中也有 cls 的信息，只是其中关于类的指针都是保存在 shiftcls 中。 12345678910111213141516171819union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8; &#125;;&#125;; magic 的值为 0x3b 用于调试器判断当前对象是真的对象还是没有初始化的空间 has_cxx_dtor在设置 indexed 和 magic 值之后，会设置 isa 的 has_cxx_dtor，这一位表示当前对象有 C++ 或者 ObjC 的析构器(destructor)，如果没有析构器就会快速释放内存。 1isa.has_cxx_dtor = hasCxxDtor; shiftcls在为 indexed、 magic 和 has_cxx_dtor 设置之后，我们就要将当前对象对应的类指针存入 isa 结构体中了。 1isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。 绝大多数机器的架构都是 byte-addressable 的，但是对象的内存地址必须对齐到字节的倍数，这样可以提高代码运行的性能，在 iPhone5s 中虚拟地址为 33 位，所以用于对齐的最后三位比特为 000，我们只会用其中的 30 位来表示对象的地址。 而 ObjC 中的类指针的地址后三位也为 0，在 _class_createInstanceFromZone 方法中打印了调用这个方法传入的类指针： 可以看到，这里打印出来的所有类指针十六进制地址的最后一位都为 8 或者 0。也就是说，类指针的后三位都为 0，所以，我们在上面存储 Class 指针时右移三位是没有问题的。 1isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 如果再尝试打印对象指针的话，会发现所有对象内存地址的后四位都是 0，说明 ObjC 在初始化内存时是以 16 个字节对齐的, 分配的内存地址后四位都是 0。 使用整个指针大小的内存来存储 isa 指针有些浪费，尤其在 64 位的 CPU 上。在 ARM64 运行的 iOS 只使用了 33 位作为指针(与结构体中的 33 位无关，Mac OS 上为 47 位)，而剩下的 31 位用于其它目的。类的指针也同样根据字节对齐了，每一个类指针的地址都能够被 8 整除，也就是使最后 3 bits 为 0，为 isa 留下 34 位用于性能的优化。 Using an entire pointer-sized piece of memory for the isa pointer is a bit wasteful, especially on 64-bit CPUs which don’t use all 64 bits of a pointer. ARM64 running iOS currently uses only 33 bits of a pointer, leaving 31 bits for other purposes. Class pointers are also aligned, meaning that a class pointer is guaranteed to be divisible by 8, which frees up another three bits, leaving 34 bits of the isa available for other uses. Apple’s ARM64 runtime takes advantage of this for some great performance improvements.from ARM64 and You 我尝试运行了下面的代码将 NSObject 的类指针和对象的 isa 打印出来，具体分析一下 12object_pointer: 0000000001011101100000000000000100000000001110101110000011111001 // 补全至 64 位class_pointer: 100000000001110101110000011111000 编译器对直接访问 isa 的操作会有警告，因为直接访问 isa 已经不会返回类指针了，这种行为已经被弃用了，取而代之的是使用 ISA()) 方法来获取类指针。 代码中的 object 对象的 isa 结构体中的内容是这样的： 其中红色的为类指针，与上面打印出的 [NSObject class] 指针右移三位的结果完全相同。这也就验证了我们之前对于初始化 isa 时对 initIsa 方法的分析是正确的。它设置了 indexed、magic 以及 shiftcls。 ISA() 方法因为我们使用结构体取代了原有的 isa 指针，所以要提供一个方法 ISA() 来返回类指针。 其中 ISA_MASK 是宏定义，这里通过掩码的方式获取类指针： 123456#define ISA_MASK 0x00007ffffffffff8ULLinline Class objc_object::ISA() &#123; return (Class)(isa.bits &amp; ISA_MASK);&#125; 其它 bits在 isa_t 中，我们还有一些没有介绍的其它 bits，在这个小结就简单介绍下这些 bits 的作用 has_assoc 对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 weakly_referenced 对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating 对象正在释放内存 has_sidetable_rc 对象的引用计数太大了，存不下 extra_rc 对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc 的值就为 9 1234567891011struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;&#125;; arm64 架构中的 isa_t 结构体123456789101112131415161718192021222324#define ISA_MASK 0x0000000ffffffff8ULL#define ISA_MAGIC_MASK 0x000003f000000001ULL#define ISA_MAGIC_VALUE 0x000001a000000001ULL#define RC_ONE (1ULL&lt;&lt;45)#define RC_HALF (1ULL&lt;&lt;18)union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19; &#125;;&#125;; 要点 对象： 含有isa指针的结构都是对象，包括类，实例。 isa指针的作用之一，统一类方法和实例方法的调用机制 参考资料 Objective-C Runtime Programming Guide What is a meta-class in Objective-C? objc_explain_Classes_and_metaclasses Storing things in isa Why do we need C Unions? objc_explain_Non-pointer_isa Tagged Pointer ARM64 and You 64位与Tagged Pointer Follow: @Draveness","tags":[{"name":"isa","slug":"isa","permalink":"http://yoursite.com/tags/isa/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"0. 参考资料","date":"2018-10-31T16:38:11.000Z","path":"wiki/IOS/Runtime/objc/0_refer/","text":"参考资料 Draveness git地址 Classes and Metaclasses 类型编码 Type Encodings Tagged Pointer Xcode 10 下如何调试objc4-723","tags":[{"name":"list_array_tt","slug":"list-array-tt","permalink":"http://yoursite.com/tags/list-array-tt/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"objc","slug":"IOS/Runtime/objc","permalink":"http://yoursite.com/categories/IOS/Runtime/objc/"}]},{"title":"关键字使用的位置","date":"2018-09-20T04:07:12.000Z","path":"wiki/C++语言/C++Primer/附录/关键字使用的位置/","text":"关键字 说明 static static关键字只能出现在类内部的声明语句中，不能出现在类的外部定义中 explicit explicit只对一个实参的构造函数有效，只能在类内声明构造函数时使用explicit关键字，在类外定义时不应该重复使用 =default 当我们在类内用=default修饰成员声明时，合成的函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default =delete 必须出现在函数第一次声明的时候 virtual 只能出现在类内部的声明语句中之前，不能用于类外部的函数定义 override final 类的名字后面，防止继承 =0 只能出现在类内部的虚函数声明语句处","tags":[{"name":"关键字使用的位置","slug":"关键字使用的位置","permalink":"http://yoursite.com/tags/关键字使用的位置/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"附录","slug":"C-语言/C-Primer/附录","permalink":"http://yoursite.com/categories/C-语言/C-Primer/附录/"}]},{"title":"动态内存","date":"2018-09-13T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/","text":"主要内容： 动态内存和智能指针 动态数组 到目前为止，我们程序只使用静态内存和栈内存，静态内存用来保存局部static对象、类static成员、以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非static对象。分配在静态或者栈内存中的对象由编译器自动创建和销毁，对于栈对象，仅在其定义的程序块运行时才存在。static对象在使用前分配，在程序结束是销毁。 动态内存和智能指针shareed_ptr允许多个指针指向同一个对象；unique_ptr则独占所指的对象。weak_ptr伴随类。 shared_ptr类智能指针也是模板，当我们创建一个智能指针时，必须提供额外的信息–指针指向的类型。 shared_ptr和unique_ptr都支持的操作 说明 shared_ptr sp unique_ptr up 空智能指针，可以指向类型为T的对象 p 将p作为一个条件判断，若p指向一个对象，则为true *p 解引用p，获取它指向的对象 p-&gt;mem 等价于(*p)-&gt;mem p.get 返回p中保存的指针，若智能指针释放了其对象，返回的指针所指的对象也消失了 swap(p,q) 交换pq中的指针 p.swap(q) share_ptr独有的操作 make_shared(args) 返回一个shared_ptr，指向动态分配的类型为T的对象，使用args初始化对象 shared_ptrp(q) p 是shared_ptr q的拷贝，此操作会递q中的计算器q中的指针必须能转换为T* p = q pq 都是shared_ptr，所保存的指针必须能相互转化，次操作会递减p的引用计数器，递增q的引用计数器，若p的引用计数器为0，则将其管理的源内存释放 p.unique() 若p.user_count为1，返回true，否则，返回false p.use_count() 返回与p共享对象的智能指针数量，可能很慢，组要用于调试 shared_ptr的拷贝和赋值 shared_ptr自动销毁所管理的对象 使用动态内存处于以下三个原因： 程序不知道自己需要使用多少对象，典型例子，容器 程序不知道所需对象的准确类型 程序需要在多个对象间空闲数据 一般而言，如果。两个对象共享底层的数据，当讴歌对象被销毁时，我们不能单方面的销毁底层数据。 使用动态内存的一个常见原因是允许多个对象共享相同的状态。 直接管理内存使用new动态分配和初始化对象： 1int * pi = new int; 默认情况下，动态分配的对象是默认初始化的，这意味着，内置类型、组合类型的对象是未定义的，而类类型的对象使用默认构造函数进行初始化。 我们可以使用直接初始化方式来初始化一个动态分配的对象 1string *sp = new string(10,'9'); 也可以对动态分配的对象进行值初始化，只需要要类型名后跟一对圆括号即可。 对于定义了自己的构造函数的类类型来说，不论是值初始化还是默认初始化，都是使用默认构造函数， 但是对于内置类型来说，值初始化的内置类型对象有着良好定义的值，而默认初始化的对象的对象的值是未定义的。 动态分配的const对象：使用new分配const对象是合法的。一个动态分配的const对象必须初始化。 内存耗尽： 这里讲了定位new delete之后重置指针：在delete之后，指针就变成了人们所说的空悬指针（danglind pointer）。 shared_ptr和new结合使用接受指针参数的智能指针构造函数是explicit的，因此，我们将一个内置指针隐式转化为一个智能指针，必须使用直接初始化形式来初始化一个智能指针。 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用delete释放她所关联的对象。 定义和改变shared_ptr的其他方法 shared_ptrp(q) p管理内置指针q所指向的对象，q必须指向new分配的内存，且能转化为T*类型 shared_ptrp(u) p从unique_ptr哪里接管了对象的所有权，将U置位空 shared_ptep(q,d) p接管了内置指针q所指向的对象的所有权，p将使用可调用对象d来代替delete shared_ptrp(p2,d) p是shared_ptr p2的拷贝，唯一的区别是p将用可调用对象d来代替delete p.reset() 若p是唯一指向其对象的shared_ptr，reset将会是否次对象。 p.reset(q) 若传递了可选的参数内置指针q，会令p指向q，负责会将p置位空 p.reset(q,d) 若还传递了参数d，将会调用d而不是delete来是否q 智能指针和异常智能指针使用规范 不能使用相同的内置指针初始化多个智能指针 不delete get()返回的指针 不适用get() 初始化或者reset另一个智能指针 如果你使用get()返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效的指针了。 如果使用智能指针管理的资源不是new分配的内存，记住传递一个删除器。 unique_ptr一个unique_ptr拥有它所指向的对象，与shared_ptr不同，某个时刻只能有一个unique_ptr指向一个给定的对象。 unique_ptr操作 说明 unique_ptr u1 空unique_ptr，可以指向类型为T的对象，u1会使用delete来释放他的指针，u2 会使用一个类型为D的可调用对象来释放他的指针 unique_ptr u2 unique_ptru(d) 空的unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete u = nullptr 释放u所指的对象，将u置位空 u.release() u放弃对指针的控制权，返回指针，并将u置为空 u.reset() 释放u指向的对象 u.reset(q) 如果提供了内置指针q，令u指向这个对象，否则u置为空 u.reset(nullptr) 传递unique_ptr参数和返回unique_ptr： 不能拷贝unique_ptr的规则有一个例外：我们可以拷贝或者赋值一个将要被销毁的unique_ptr。 weak_ptrweak_ptr是一种不控制所指对象声明周期的指针。它指向由一个shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数器。 weak_ptr操作 说明 weak_ptr w 空的weak_ptr，可以指向类型为T的对象 weak_ptr w(sp) 与shared_ptr sp指向相同对象的weak_ptr，T必须能转化为sp指向的类型 w = p p 可以是一个shared_ptr 或一个weak_ptr。赋值后，w与p共享对象 w.reset() 将w置位空 w.use_count() 与w共享对象的shared_ptr的数量 w.expired() 若w.use_count()为0，返回true，否则返回false w.lock() 如果expired为true，返回一个空的shared_ptr；否则返回一个指向w的对象的shared_ptr 动态数组C++语言和标准库提供了一次分配一个对象数组的方法，C++中定义了另一种new表达式，可以分配并初始化一个对象数组。标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。 new和数组分配一个数组得到一个元素类型的指针： 由于分配的内存不是一个数组类型，因此不能对数组调用begin和end ，我们必须记住，动态数组并不是数组类型。 初始化动态分配数组：默认情况下使用默认初始化，可以使用圆括号进行值初始化。 allocator","tags":[{"name":"动态内存","slug":"动态内存","permalink":"http://yoursite.com/tags/动态内存/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十二章 动态内存","slug":"C-语言/C-Primer/第十二章-动态内存","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十二章-动态内存/"}]},{"title":"泛型算法","date":"2018-09-12T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/","text":"主要内容： 概述 初始泛型算法 定制操作 再探迭代器 泛型算法结构 特定容器算法 概述一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。 算法永远不会执行容器操作：泛型算法本身不执行容器操作，他们只会运行于迭代器之上，执行迭代器的操作。这个特性带来一个非常惊人的编程假定：算法永远不会改变容器的大小。算法可能改变容器中元素的内容，可能在容器内移动元素，但永远不会添加或者删除元素。标准库定义定义了特殊的迭代器，插入迭代器。当算法操作这样的迭代器时迭代器可以完成向容器添加元素的效果，但算法永远不会做这种操作。 只读算法find accumulate equal 除了少数算法外，标准库算法都对一个范围内的元素进行操作。我们将此元素的范围称为输入范围。接收输入范围的算法总是使用前两个参数来表示范围。两个参数分别表示第一个要处理的元素、尾元素之后位置的迭代器。 那些只接收一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。 写容器元素算法fill copy back_inserter replace_copy 重排元素的算法定制操作向算法传递函数谓词：是一个可调用表达式，其返回结果是一个能用作条件的值。 一元谓词：接受单一参数二元谓词：接受两个参数 stable_sort算法：维持相等元素的原有顺序 lambda表达式find_if算法对输入序列中的每个元素调用这个谓词，它返回第一个使谓词返回非0的元素，如果不存在这样的元素，则返回尾迭代器。 可调用对象（cllable object）。对于一个对象或者一个表达式，如果可以对其使用调用运算符，则它为可调用对象。 可调用对象： 函数 函数指针 重载了函数调用运算符的类 lambda表达式 可调用对象可以理解为是一个未命名的内联函数 一个lambda表达式具有一个返回类型、一个参数列表、一个函数体，单与函数不同，lambda表达式可以定义在函数内部，一个lambda表达式的一般形式 1[capture list](parameter list)-&gt; return type &#123;function body&#125; 与普通函数不同，lambda表达式使用尾置返回指定返回类型。 可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。如果忽略返回类型，lambda根据函数体重的代码推断出返回类型。 与普通函数不同，lambda不能有默认实参。 一个lambda通过将局部变量包含在其捕获列表中来指出将会使用这些局部变量。 一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。 for_each算法接受一个可调用对象，并对输入序列中每个元素调用次对象。 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量、它所在函数之外声明的名字。 lambda捕获和返回当向一个函数传递一个lambda时，同时定义了一个类型和该类型的对象：类似的，当使用auto定义一个用lambda初始化变量时，定义了一个从lambda生产的类型的对象。 值捕获：与参数不同，被捕获的变量的值在lambda创建时拷贝。而不是调用时拷贝。 引用捕获：必须确保被引用的对象在lambda执行的时候是存在的。 隐式捕获： &amp;搞事编译器采用引用捕获，=告诉编译器使用值捕获。混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是&amp;或者=。 可变lambda：默认情况下，对于一个值被拷贝的变量，lambda不会改变其值，如果我们希望改变一个被捕获的变量的值。就必须在参数列表首加上关键字mutable。 参数绑定bind标准函数 定义在functional中，可以将bind函数看做一个通用的函数适配器，他接受一个可调用对象，生成一个新的可调用对象来适应原来对象的参数。 bind的一般形式： 1auto newCallable = bind(callable,arglist); 使用placeholders名字 _n定义在一个名为placeholders的命名空间。而这个命名空间定义在std命名空间中。 再探迭代器 插入迭代器 流迭代器 反向迭代器 移动迭代器 插入迭代器接受一个容器，生成一个迭代器，他实现向容器添加元素。当我们通过一个插入迭代器进行赋值时，改迭代器调用容器操作来向给定容器指定的位置插入一个元素。 back_inserter front_inserter inserter iostream迭代器泛型算法结构5种迭代器 输入迭代器 输出迭代器 前向迭代器 双向迭代器 随机访问迭代器 算法形参模式","tags":[{"name":"泛型算法","slug":"泛型算法","permalink":"http://yoursite.com/tags/泛型算法/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十章 泛型算法","slug":"C-语言/C-Primer/第十章-泛型算法","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十章-泛型算法/"}]},{"title":"空间配置器","date":"2018-08-29T04:07:12.000Z","path":"wiki/C++语言/STL源码剖析/第二章/空间配置器/","text":"主要内容 空间配置器的标准接口 具备次配置能力的SGI 空间配置器 内存基本处理工具 空间配置器的标准接口1allocator::","tags":[{"name":"空间配置器","slug":"空间配置器","permalink":"http://yoursite.com/tags/空间配置器/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"STL源码剖析","slug":"C-语言/STL源码剖析","permalink":"http://yoursite.com/categories/C-语言/STL源码剖析/"},{"name":"第二章","slug":"C-语言/STL源码剖析/第二章","permalink":"http://yoursite.com/categories/C-语言/STL源码剖析/第二章/"}]},{"title":"deque","date":"2018-08-28T04:07:12.000Z","path":"wiki/C++语言/STL源码剖析/第四章/deque/","text":"主要内容 deque 概述 deque中控器 deque的迭代器 deque的数据结构 deque的构造与内存管理 deque的元素操作 deque 概述vector是单向开口的连续性空间，deque则是一种双向开口的连续性空间，所谓双向开口，意思是头尾两端分别做元素的插入和删除操作. deque和vector的最大差异，一、在于deque允许常数时间内对起始头端进行元素的插入或移除操作。二、deque没有容量的概念，因为他是动态的以分段连续空间组合而成，随时可以增加一段空间并连接起来。换句话说，像vector那样“因旧空间不足而重新分配一块更大空间，然后复制元素，再释放旧空间”这样的事情在deque是不会发生的。也因此，deque没有必要提供所谓的空间保留功能。 虽然，deque也提供了random access iterator，但他的迭代器并不是普通指针。其复杂度和vector不可以道里计，这当然影响了各个运算层面，因此，除非必要，我们应该尽可能选择vector而非deque。对deque进行的排序操作，为了最高效率，可将deque先完整的复制到一个vector身上，将vector排序后，再复制回deque。 deque中控器deque是连续空间（至少逻辑上看如此），连续线性空间总令我们联想到array和vector。array无法生长，vector虽可以生长，却只能向尾端成长。而且其所为成长是个假象，事实上是： 另觅更大空间 将原数据赋值过去 释放原空间 如果不是vector每次配置新空间时留下一些富裕，其成长假象所带来的代价相当昂贵。 deque系由一段一段的定量连续空间构成。一旦有必要在前端或者尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复制的带带器框架。 收到分段连续性空间的字面影响，我们可能以为，deque的实现复杂度和vector相比，虽不中亦不远矣，其实不然。主要以为，即曰分段连续线性空间，就必须有中央控制，为了维持整体连续的假象，数据结构的设计及迭代器前进后退操作都颇为繁琐。deque的实现代码分量远比vector或list多得多。 deque采用一块所谓map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处层位一个节点，node）都是指针，指向另一段较大的连续线性空间，称为缓冲区。缓冲区才是deque的存储空间主体。SGI STL 允许我们制定缓存区的大小，默认是0，表示将使用512bytes缓存区。 12345678910111213141516template&lt;class T, class Alloc=alloc, size_t BufSize = 0&gt;class deque&#123; public: typedef T value_type; typedef value_type* pointer; ... protected: ///元素的指针的指针 typedef pointer* map_pointer; protected: map_poiner map;//指向map，map是快连续空间，其内的每个元素都是一个指针，指向一块缓存区 size_type map_size; //map内可容纳多少指针&#125; 令人头皮发麻的各种类型整理下，我们可发现，map其实是一个T**，也就是说他是一个指针，所指之物又是一个指针，指向类型为T的空间，如下图所示： deque的迭代器deque的分段连续空间，维持其“整体连续”假象的任务，落在了迭代器operator++、 operator– 两个运算子身上。","tags":[{"name":"deque","slug":"deque","permalink":"http://yoursite.com/tags/deque/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"STL源码剖析","slug":"C-语言/STL源码剖析","permalink":"http://yoursite.com/categories/C-语言/STL源码剖析/"},{"name":"第四章","slug":"C-语言/STL源码剖析/第四章","permalink":"http://yoursite.com/categories/C-语言/STL源码剖析/第四章/"}]},{"title":"顺序容器","date":"2018-08-27T10:07:12.000Z","path":"wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/","text":"主要内容 顺序容器概述 容器库概览 顺序容器操作 vector对象是如何生长的 额外的string操作 容器适配器 顺序容器概述容器在以下方面都有不同的性能折中： 向容器添加或者删除元素的代价 非顺序访问容器中元素的代价 容器类型 性能 vector 可变大小数组，支持快速随机访问，在尾部之外的位置插入或删除元素可能很慢 deque 双端队列，支持快速随机访问，在头尾位置插入、删除速度快 list 双向链表，只支持双向顺序访问，在list中任何位置插入、删除操作熟读都很快 forward_list 单向链表。只支持单向顺序访问，在链表任何位置插入、删除操作都非常快 array 固定大小数组，支持快速随机访问，不能添加或删除元素 string 与vector相似的容器，但专门用于保存字符，随机访问快，在尾部插入、删除快 string、vector将元素保存在连续的内存空间，由于元素是连续存储的，由元素的下标计算其地址非常快。 list、forword_list两个容器的设计目的是令容器容器的任何位置添加、删除操作都很快 容器概览 类型 说明 类型别名 iterator 容器的迭代器类型 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型，与value_type&amp;含义相同 const_reference 元素的const左值类型(const value_type &amp;) 构造函数 C c; 默认构造函数，构造空的容器 C c1(c2) 构造出c2的拷贝c1 C c(b,e) 构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持） C c{a,b,c …} 列表初始化 赋值与swap c1= c2 将c1中的元素地换为c2中的元素 c1 = {a,b,c …} 将c1中的元素退换为列表中的元素（array不适用） a.swap(b) 交换a和b的元素 swap(a,b) 与a.swap(b)等价 大小 c.size() c中元素的书面（forward_list不支持） c.max_size() c可保存的最大元素数目 c.empty() c中存储了元素，返回false，否则返回true 添加删除元素（不适用array） 在不同的容器中，这些操作的接口都不同 c.insert(args) 将args中的元素拷贝进c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中的所有元素，返回void 关系运算符 ==， != 所有容器都支持相等（不等于）运算符 &lt;,&lt;=,&gt;,&gt;= 无序关联容器不支持 获取迭代器 c.begin(), c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(),c.cend() 返回const_iterator 反向容器的额外成员（不支持forward_list） reverse_iterator 逆序寻址元素的迭代器 const_reverse_iterator 不修改元素的逆序迭代器 c.rbegin(),c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(),c.crend 返回const_reverse_iterator 迭代器forword list 不支持递减运算符 迭代器范围中的元素包括first所表示的元素以及从first开始，直至last（但不包括last）之间的所有元素，左闭合区间。 1[begin end) 使用左闭合范围蕴含的编程假定 如果begin和end相等，则范围为空 如果begin和end不相等，则范围至少包含一个元素，且begin指向范围中的第一个元素 我们可以对begin递增若干次，使得begin==end 容器类型成员 1list&lt;string&gt;\"\"iterator iter; begin和end成员 begin和end操作生成指向容器中第一个元素和尾元素之后的迭代器。 容器的定义和初始化 容器的定义和初始哈 C c 默认构造函数，如果C是一个array，则c中元素默认初始化，否则c为空 C c1()c2 C c1 = c2 c1初始化为c2的拷贝，c1和c2必须类型相同,对于arrary，大小相同 C c{a,b,c,…} C c = {a,b,c,…} c初始化为初始化列表中元素的拷贝 C c(b,e) c初始化为迭代器b，e指定范围中的元素的拷贝 C seq(n) C seq(n,t) seq 包含n个元素，这些元素进行了值初始化，此构造函数是explicit的 容器的拷贝： 两种方式 直接拷贝整个容器 拷贝迭代器指定的元素范围 当将一个容器初始化为另一个容器的拷贝时，两个容器类型和元素类型必须相同。 列表初始化：对于除了array之外的容器类型，初始化列表还隐含地指定了容器的大小：容器将包含与初始值一样多的元素。 标准库array具有固定大小：标准库array的大小是类型的一部分， array与内置数组的区别：array可以进行拷贝和对象赋值。 赋值和swap赋值运算符将其左边容器中全部元素替换为右边容器中元素的拷贝。 容器的大小操作 size empty max_size 关系运算符只有当其元素的类型定义了关系运算符，我们才可以使用关系运算符比较容器 顺序容器的操作向顺序容器添加元素|操作|说明||—|—||这些操作不支持会改版容器的大小，array不支持这些操作|||forward_list有专有版本的insert和emplace|||forward_list不支持push_back和emplace_back，由于没有位指针，算法复杂度是o(n)|||vector和string不支持push_font和emplace_font，也是算法复杂度的原因，整个元素需要移动，单可以通过inser做到|||c.push_back(t)|在C的尾部创建一个值为t或由args创建的创建的元素，返回void||c.emplace_back(args)||||||c.push_font(t)|在C的首部创建一个值为t或由args创建的创建的元素，返回void||c.emplace_font(args)||||||c.insert(p,t)|在迭代器p指向的元素之前创建一个值为t或由args创建的元素， 前插||c.emplace(p,args)||||||c.insert(p,n,t)|在迭代器p指向的元素之前插入n个值为t的元素，返回指向新添加的第一个元素的迭代器，若n为0，则指向p||c.insert(p,b,e)|将迭代器b，e指定的范围内的元素插入到迭代器p指向的元素之前，b和e不能指向c中的元素，返回指向新添加的第一个元素的迭代器||c.insert(p,il)|il是花括号包围的元素值列表||向一个vector、string、deque插入元素，会使所有指向容器的迭代器、引用、指针失效| 使用push_back：除了array、forward_list之外，每个顺序容器都支持push_back。 当我们用一个对象初始化容器时，或将一个对象插入到容器中，实际上，放入到容器中的是对象的一个拷贝，二不是对象本身。 使用push_font：和vector一样，在deque首位之外的位置插入元素会很耗时。 在容器中的特定位置插入元素：insert提供了更一般的功能，它允许在容器中的任何位置插入0个或者多个元素。每个insert函数，都接受一个迭代器作为其第一个参数，迭代器指出了在容器的什么位置插入元素。 为什么是前插：因为迭代器可能只需容器外部之后不存在的元素的位置，所以只能前插。另外，在容器开始位置插入元素是很有用的功能。 我们可以使用insert将元素插入容器的开始位置，不用担心是否支持push_font。 如果我们传递给insert一对迭代器，他们不能指向添加元素的目标容器。 使用insert的返回值：通过使用insert的返回值，可以在容器中的一个特定位置反复插入元素。 emplace操作：新标准引入了三个成员：emplace、emplace_font 、emplace_back，这些操作构造而不是拷贝元素。 emplace函数在容器中直接构造元素，传递给emplace函数的参数必须与元素类型的构造函数相匹配。 访问元素包括array在内的所有容器都有一个font函数，而除了forword_list之外的所有容器都有一个back成员函数。这两个成员函数分别返回首元素和尾元素的索引。 |容器的访问操作|说明||—|—|||at和下标操作只使用于string、vector、deque、和array|||back不适用forward_list，算法复杂度的问题||c.back()|返回c的尾元素的引用||c.font()|返回c的首元素的引用||c[n]|返回c中下表为n的元素的引用||c.at(n)|返回下标为n的元素的引用。| 提供快速随机访问的容器（string、vector、deque、array）都提供下标运算符 at成员函数类似下标运算符，但如果下标越界，at会抛出一个out_of_range的异常。 删除元素 删除操作 说明 这些操作会给变容器的大小，不适用于array forward_list有特殊版本的erase forward_list不支持pop_back，string、vector不支持pop_font c.pop_font() 删除c中的首元素 c.pop_back() 删除c中的尾元素 c.erase(p) 删除迭代器p所指定的元素 c.erase(b,e) 删除迭代器be所指范围内的元素 c.clear() 删除c中的所有元素 ###特殊的forward_list操作 特殊操作的原因：删除或者插入操作，我们需要访问它的前驱，以便改变前驱的链接，但是forward_list中，没有简单的方法获取一个元素的前驱。forward_list定义了insert_after、emplace_after、erase_after操作。before_begain，返回一个首前。 |forward_list操作|说明||lst.before_begain()|返回指向链表首元素之前不存在的元素的迭代器，此迭代器不能解引用||lst.cbefore_begain()|||lst.insert_after(p,t)|在迭代器之后插入一个元素||lst.insert_after(p,n,t)|||lst.insert_after(p,b,e)|||lst.insert_after(p,il)|||emplace_after(p,args)|||lst.erase_after(p)|||lst.erase_after(b,e)|| 改变容器的大小容器操作可能使迭代器失效vector对象是如何生长的 |容器大小操作|说明| ||shrink_to_fit 只适用于vector、string、deque| ||capacity和reserve只适用于vector、string| |c.shrink_to_fit|请将capacity（）减少为size相同大小| |c.capacity()|不重新分配内存空间的话，c可以保存多少元素| |c.reserve（）|分配至少容纳那n个元素的内存空间| 额为的string操作构造string的其他方法 构造string的其他方法 说明 string s(cp,n) s是cp指向的数组中前n个字符的拷贝，此数组至少应该包含n个字符 string s(s2,pos2) s是string s2从下标POS2开始的字符的拷贝，若pos2&gt;s2.size()，构造函数的行为未定义 string s(s2,pos2,len2)","tags":[{"name":"顺序容器","slug":"顺序容器","permalink":"http://yoursite.com/tags/顺序容器/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第九章顺序容器","slug":"C-语言/C-Primer/第九章顺序容器","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第九章顺序容器/"}]},{"title":"IO库","date":"2018-08-27T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第八章io库/IO库/","text":"主要内容 IO类 文件输入输出 string流 IO类IO对象无拷贝或赋值进行IO操作的函数通常以引用方式传递、返回流。读写一个IO对象会改变其状态，因此，传递和返回的引用不能是const的。 条件状态 状态 说明 strm::iostate strm是一种IO类型，iostate是一种机器相关的类型，提供了表达条件状态的完整功能 strm::badbit 指出输出流已崩溃 strm::faillbit 一个IO操作失败 strm::eofbit 流达到了文件结尾 strm::goodbit 流未处于错误状态，此值保证为0 s.eof() 若流s的eofbit置位，则返回true s.fail() 若流s的failbit置位，则返回true s.bad() 若流s的badbit置位，则返回true s.good() 若流处于有效状态，则返回true s.clear() 将流的所有状态复位 s.clear(flags) 根据给定的flags标志位，将流s中对应的条件状态位复位 s.setstate(flags)将流s中对应条件状态位置位 s.rdstate() 返回流s的当前条件状态 一个流一旦发生错误状态，其后续的IO操作都失败。只有流处于无错状态是，我们才可以从它读取数据、写入数据。 属性缓存区： endl， 换行并刷新缓冲区 flush ，刷新缓存区，不输出任何额为的字符 ends，向缓冲区插入一个空字符，然后刷新缓冲区 unitbuf 操纵符：如果每次输出操作后，都属性缓存区，我们可以使用unitbuf操纵符。 如果程序崩溃，输出缓冲区不会被刷新。 tie： 如果本对象关联到一个输出流，则返回的就是这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。 文件输入输出 操作 说明 fstream fstrm 创建一个未绑定的文件流 fstream fstrm(s) 创建一个fstream，并打开名为s的文件。 s可以是string类型，或者是一个指向C风格字符串类型 fstream fstrm(s,mode) 安装mode打开文件 fstrm.open(s) 打开名为s的文件，并将文件与fstrm绑定，返回void fstrm.close() 关闭于fstrm绑定的文件，返回void fstrm.is_open 返回一个bool，指出与fstrm关联的文件是否成功打开且尚未关闭 创建文件流对象时，我们可以提供文件名，如果提供了一个文件名，则open自动被调用。 文件模式 文件模式 说明 in 以读方式打开 out 以写方式打开 app 每次写操作前均定位到文件末尾 ate 打开文件后，立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行IO stirng流 操作 说明 sstream strm strm是未绑定的stringstream对象 sstram strm(s) strm 是一个sstream对象，保存string的一个拷贝，此构造函数是explicit的 strm.str() 返回strm中保存的string的拷贝 strm.str(s) 将string s 拷贝到strm中，返回void","tags":[{"name":"IO库","slug":"IO库","permalink":"http://yoursite.com/tags/IO库/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第八章io库","slug":"C-语言/C-Primer/第八章io库","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第八章io库/"}]},{"title":"IOS12 兼容","date":"2018-08-22T04:07:12.000Z","path":"wiki/IOS/IOS12/IOS12-compatibility/","text":"主要遇到的问题： Xcode10移除了libstdc++库，由libc++这个库取而代之，苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。 CocoaPods 1.3.1 版本不能将pod中的资源文件拷贝到APP中 libstdc++问题 现象是无法找到libstdc++，编译报错如下： 1library not found for -lstdc++.6.0.9 临时解决方案 临时解决办法—-从Xcode9中复制libstdc++库到Xcode10中，命令如下： 123cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/libstdc++.* /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/usr/lib/cp /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/libstdc++.* /Applications/Xcode-beta.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/usr/lib/ 最终解决办法： 需要联系第三方公司，将GMThirdParty/BestPay 、GMF_EaseMobSDK2.2.9更新。 模拟器无法启动的解决方案报错如下： 1234dyld: Library not loaded: /usr/lib/libstdc++.6.dylib Referenced from: /Users/lijian/Library/Developer/CoreSimulator/Devices/6CB2CF98-149C-43A1-8A93-516FE4243C8C/data/Containers/Bundle/Application/2C25BADD-A36F-4B11-9885-34E8AEE826AC/GomeStaff.app/GomeStaff Reason: no suitable image found. Did find: /usr/lib/libstdc++.6.dylib: mach-o, but not built for iOS simulator 原因分析： 上面的错误的含义是动态链接器无法加载到libstdc++.6.dylib，但是真机上是可以加载出来，所以，推测模拟器的运行环境去掉了这个库，那么，我们如果将模拟器的运行环境中添加上这个库，是不是就可以了？ 答案是肯定的。 下面的问题是：我么如何找到模拟器运行环境加载库的路径呢？ 我的思路是使用xcode9运行模拟器，然后打印系统库的加载路径，这个路径就是我们要找的路径。 查找系统库的方法如下,用xcode9运行下面的代码： 123456789#include &lt;mach-o/dyld.h&gt;#include &lt;mach/mach.h&gt;for(int i = 0; i &lt; _dyld_image_count(); i++)&#123; const char* aa = _dyld_get_image_name(i); NSString *str = [NSString stringWithUTF8String:aa]; LOG_LJ_(@\"~~~~~~~~~~~~~~~~~~~~~~~~%@\",str);&#125; 输出如下： 1~/Users/lijian/Downloads/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/libiconv.2.dylib 上面的路径就是模拟器的系统库路径。所以，将xcode9对应目录下的三个libstdc++复制到xcode10的对应目录即可。 CocoaPods无法复制资源到app中现象：登录界面没有图标，或者启动时 NSBundle的initWithUrl方法崩溃。 解决办法： 升级CocoaPods到1.4.0，命令是：sudo gem install -n /usr/local/bin cocoapods -v 1.4.0 。 移除Build Phases 中的 [cp]Copy Pods Resources 。 重新pod install。 info 重复问题报错如下： 123Multiple commands produce '/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist':1) Target 'GomeStaff' (project 'GomeStaff') has copy command from '/Users/lijian/Desktop/GomeGit/GomeStaff/GomeStaff/Supporting Files/Info.plist' to '/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist'2) Target 'GomeStaff' (project 'GomeStaff') has process command with output '/Users/lijian/Library/Developer/Xcode/DerivedData/GomeStaff-eccvobvclqelmrgkhibvvrxbftdz/Build/Products/Debug-iphonesimulator/GomeStaff.app/Info.plist' 原因分析：Xcode自动会将Info.plist复制到GomeStaff.app中，但是在Build Phases-&gt; Copy Bundle Resources中也包含复制Info.plist的功能，这样就两次复制，第二次复制失败。 解决方法： 将Build Phases-&gt; Copy Bundle Resources 中的info.plist 去掉。 参考 Xcode10和iOS12踩坑 libstdc++适配Xcode10与iOS12","tags":[{"name":"IOS12 兼容","slug":"IOS12-兼容","permalink":"http://yoursite.com/tags/IOS12-兼容/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"IOS12","slug":"IOS/IOS12","permalink":"http://yoursite.com/categories/IOS/IOS12/"}]},{"title":"类","date":"2018-08-20T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第七章类/类/","text":"主要内容： 定义抽象数据类型 访问控制与封装 类的其他特性 类的作用域 构造函数再探 类的静态成员 数据抽象能帮助我们将对象的具体实现和对象所能执行的操作分离开来。 定义抽象数据类型一、设计Sales_data类 一个isbn成员函数，返回对象的ISBN编号 一个combine成员函数，用于将一个Sales_data对象加到另一个对象上 一个名为add的函数，执行两个Sales_data对象的加法 一个read函数，将数据从istream读入到Sales_data对象中 一个print函数，将Sales_data对象的值输入到ostream 二、定义改进的Sales_data类定义在类内部的函数隐式的inline函数。 成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。对我们调用一个成员函数时，用请求该函数的对象地址初始化this。如果调用： 1total.isbn() 则编译器负责把total的地址传给isbn的隐式参数this，可以等价的认为编译器将该调用重写成如下形式 1Sales_data::isbn(&amp;total); this是常量指针，我们不允许改变this中保存的地址。 const成员函数： 紧随参数列表后面的const关键字表示const成员函数。这里的const的所用是修改隐式this指针的类型。 默认情况下，this的类型是指向类类型非常量版本的常量指针。这也意味着我们不能把this绑定到一个常量对象上。不能在一个常量对象上调用普通成员函数。 常量对象以及常量对象的引用或者指针都只能调用常量成员函数。 类的作用域和成员函数： 返回类型、参数列表、函数名都得于类内部的声明一样 如果成员被定义成常量成员函数，那么他的定义也必须在参数列表后明确指定const属性。 类外部定义的成员的名字必须包含所属的类名 三、定义类相关的非成员函数IO类属于不能拷贝的类型，所以只能通过引用来传递他们，而且，因为读取和写入的操作会改变流的内容，所以两个函数接受都是普通引用，而非对常量的引用。 四、构造函数类通过特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。构造函数的任务是初始化类对象的数据成员，无论何时，只要类的对象被创建，就会执行构造函数。 构造函数的名字和和类名相同，和其他函数不一样的是，构造函数没有返回类型。 构造函数不能声明为const的，当我们创建一个const对象时，直到构造函数完成初始化过程，对象才能真正取得常量属性，所以构造函数在const对象构造的过程中，是可以向其写值的。 合成的默认构造函数：类通过特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数，默认构造函数无需任何实参。编译器创建的构造函数又被称为合成的默认构造函数（synthesized default constructor）。合成默认构造函数初始化规则： 如果存在类内初始值，用它初始化 否则，默认初始化 某些类不能依赖合成的默认构造函数，原因有三： 只有当类内没有声明任何构造函数时，编译器才会自动的生产默认构造函数。 如果累内部有内置类型或者符合类型成员，则只有当这些成员全部被赋予了类内初始值时，这个类才适合使用合成的默认构造函数。 有些类不能合成默认的构造函数 =default： 如果我们定义了其他的构造函数，同时，也需要默认构造函数，并且默认构造函数的功能等同于合成的默认构造函数，使用=default来要求编译器生成构造函数。如果=default在类的内部，则是内联的。 构造函数初始值列表： 1Sales_data(const std::string &amp; s,unsinged n, double p):bookNo(s),unit_sold(n),revenue(p*n)&#123;&#125;; 冒号和花括号之间的代码称为构造函数初始值列表。当某个数据成员被构造函数初始值列表忽略时，他将以合成默认构造函数相同的方式隐式初始化。 拷贝、赋值、析构拷贝、赋值、析构发生的场景 拷贝：初始化变量、以值的方式传递、返回一个对象。（用同类型的对象或者自己类型的对象） 赋值：使用赋值运算符时发送。 析构：当对象不存在时销毁，超出作用域、vector容器销毁时存储在其中的对象销毁 构造： 用成员的值创建（不是自己的类型） 如果我们不主动定义这些操作。编译器将替我们合成默认的。编译器生成的版本将对对象的每个成员执行拷贝、赋值、销毁操作。 某些类不能依赖合成的版本：例如动态类型。vector、string能避免分配和释放内存带来的复杂性。如果类中包含vector、string，合成的版本能正常工作 访问控制与封装使用访问说明符（access specifiers）控制类的封装性 定义在public说明符后面的成员在整个程序内可以被访问。public成员定义类的接口 定义在private说明符之后的成员可以被类的成员访问，但不能被类的使用者访问。private部分封装了类的实现细节。 使用class、struct关键字：class和struct定义的唯一区别是默认的访问权限。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的。如果是class，则是private。 友元类可以允许其他的类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元（friend），如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。 友元声明只能出现在类定义的内部，但是在类内部出现的位置不限，友元不是类的成员，也不受它所在区域访问控制级别的约束。 封装的优点： 用户代码不会无意间破坏封装对象的状态 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。 友元的声明：友元的声明仅仅指定了访问权限，而非一个通常意义上的声明，如果我们需要类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。 类的其他特性这些特性包括：类型成员、类的成员的类内初始值、可变数据成员、从成员返回this* 、关于如何定义并使用类类型及友元类。 类成员再探类型成员： 某种类型在类中的别名。类定义的类型名字和其他成员一样，存在访问控制。 12345678class Screen&#123;public: typedef std::string::size_type pos;private: pos cursor = 0; pos height = 0, width = 0; std::string contents;&#125; 类型成员必须先定义后使用。 和类的其他成员的区别 因为我们已经提供了一个构造函数，所以编译器将不会自动生成默认构造函数，如果我们的类需要默认构造函数，必须显示的把他声明出来。 令成员作为内联函数：定义在类内部的成员函数自动是inline的。 我们无需在声明和定义的地方同时说明inline，单这么做是合法的。不过最好只在类的外部定义的地方说明inline，这样可以使类更容易理解。 inline成员函数也应该与相应的类定义在同一个头文件中。 重载成员函数：和普通成员函数一样。 可变数据成员： 有时，我们希望能修改类的某个数据成员，即使是在一个const成员函数。可以通过在变量的声明中加入mutable关键字做到这一点。一个可变数据成员永远不会是const的，即使const对象的成员。 类内初始值：必须使用等号或者花括号 返回*this的成员函数从const成员函数返回this，一个const成员函数如果以引用的形式返回this，那么他的返回类型将是常量引用。 基于const的重载：通过成员函数是否是const的，我们可以对其进行重载。 类类型类的声明： class Screen 对于类型Screen来说，在它的声明之后定义之前，是一个不完全类型（incomlete type）。也就是说，此时我们已知Screen是一个类类型，但是不清楚他到底包含哪些成员。 不完全类型只能在非常有限的情景下使用，可以定义指向这种类型的指针或引用，也可以声明（但不是定义）以不完全类型作为参数或者返回类型的函数 友元再探类可以把其他的类定义成友元，也可以把其他类（之前定义过的）的成员函数定义成友元 类之间的友元：如果一个类定义了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。友元不存在传递性 令成员函数作为友元： 类的作用域一旦遇到了类名，定义的剩余部分就在类的作用域之内了。这里的剩余部分包括参数列表、函数体。 函数的返回类型通常出现在函数名之前，因此，当成员杉树定义在类的外部，返回类型中使用的名字都位于类的作用域之外。 名字查找和类的作用域名字查找（name lookup） 普通名字查找： 在名字所在的块中寻找其声明语句，只考虑名字的使用之前出现的声明 如果没有找到，继续查找外层作用域 如果最终没有找到匹配的声明，则程序报错 类的定义步骤： 首先，编译成员的声明 知道类全部可见后，编译函数体 编译器处理完类中的全部声明后，才会处理成员函数的定义 用于类成员声明的名字查找：上面两阶段的处理方式只适用于成员函数中适用的名字，声明中使用的名字，包括返回类型、参数列表中使用的名字，都必须在使用前确保可见。 123456789typedef double Money;string bal;class Account &#123; Money balance() &#123; return bal;&#125;; Money bal;&#125; Money 出现在声明中，所有从使用处开始找名字，找到了外层的double。 balance 函数体，等成员声明编译完后，处理，所以bal是成员。不是外层的string。 类型名需要特殊处理：类内部不能重新定义外层作用域中的类型名字，类内部的类型名字定义放在类的开始处， 成员定义中的普通块作用域中的名字查找： 首先在成员函数内查找名字的声明，只有在函数使用前面出现的声明才被考虑 如果在成员函数内没有找到，则在类内继续查找，这是类的所有成员都可以考虑 如果类内也没有该名字的声明，在成员函数定义之前的作用域内继续查找。 不建议成员的名字作为某个成员函数的参数。 类作用域之后，在外围作用域中查找： 可以使用::访问隐藏的外层中的名字 。 构造函数再探构造函数初始值列表如果没有在构造函数的初始值列表中显示的初始化成员，则该成员在构造函数体之前执行默认初始化。 构造函数的初始值有时必不可少：有时候我们可以忽略数据成员的初始化和赋值之间的差异，单并非总是这样，如果成员有const或者引用的话，必须将其初始哈。 随着构造函数体的开始执行，初始化就完成了，我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值。 成员是const、引用或者属于某种未提供默认构造函数的类型。我们必须通过构造函数初始值列表为这些成员提供初始值。 成员初始化顺序：成员的初始化顺序与他们在类定义中的出现顺序一致，构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。 委托构造函数一个委托构造函数使用它所属类的其他构造函数执行他自己的初始化过程，或者把他自己的一些职责委托给了其他构造函数 。 12Sales_data(std::string s, unsigned cnt , double price ):bookNo(s), units_sold(cnt),revenue(cnt*price)&#123;&#125;Sales_data():Sales_data(\"\",0,0)&#123;&#125; 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体一次被执行，然后将控制权交给委托函数体。 默认构造函数的作用当对象被默认初始化或者值初始化时，自动执行默认构造函数。 默认初始化发送的场景： 当我们在快作用域内，不适用任何初始值定义一个非静态变量。 当一个类本身还有一个类类型的成员，且使用合成的默认构造函数。 当类类型成员没有在构造函数初始值列表中显示的初始化时。 值初始化发生的场景： 在数组初始化的过程中，如果我们提供的初始值数量少于数组的大小时。 当我们不适用初始值定义一个局部静态变量时 当我们通过书写形如T()的表达式显示的请求值初始化时。 实际中，如果定义了其他的构造函数，那么最好定义一个默认构造函数。 12Sales_data obj(); ///声明了一个函数，而非对象Sales_data obj2; ///obj2是一个对象，默认初始化 隐式的类类型转化如果构造函数只接受一个实参，则它实际上定义了转换为此类型的隐式转化机制，有时候，我们把这样的构造函数称为转换构造函数。 能通过一个实参调用的构造函数，定义了一条从构造函数的参数类型向类类型隐式转化的规则。 只允许一步类型转换 1item.combine(\"9-999-9999\"); //错误，两步转化，1、char * -&gt;string 2. string-&gt;Sales_data 抑制构造函数定义的隐式转化： 我们可以通过将构造函数声明成explicit加以阻止。 关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式类型转换，所以无需将这些构造函数指定为explicit，只能在类内声明构造函数时使用explicit关键字，在类外部定义时，不应该重复。 explicit构造函数只能用于直接初始化：不能将explicit构造函数用于拷贝形式的初始化过程。当我们用explicit关键字声明构造函数时，它将只能以直接初始化的形式使用，而且，编译器不会再自动类型转换过程中使用该构造函数。 显示类型转换可以使用explicit构造函数。 标准库中含有显示构造函数的类： 接受一个参数const char*的string的构造函数不是explicit的 接受一个容量参数的vector的构造函数是explicit的。 聚合类特定： 所有成员都是public 没有定义任何构造函数 没有类内初始值 没有基类、virturl函数。 可以提供一个花括号括起来的成员初始值列表。列表中成员的顺序和聚合类的成员的顺序一直， 如果初始值列表的元素的个数少于成员数量，后面的被值初始化。 字面值常量类类的静态成员声明静态成员类的静态成员和类本身直接相关。静态函数没有this，静态成员函数不能声明成const的。而且我们也不能再static函数体内使用this指针 使用类的静态成员 使用作用域访问静态成员 通过对象访问静态成员 成员函数可以不通过作用域直接访问静态成员。 定义静态成员我们可以在类的内部、外部定义静态成员函数。在类的外部定义静态成员时，不能重复static关键字，该关键字只能在类的内部声明语句中。静态成员不属于任何一个对象，他们不是在类创建的时候定义的，这意味着不能由类的构造函数初始化。 静态成员类内初始值通常情况下，静态成员不应该在类的内部初始化，然而，我们可以为静态成员提供const整数类型的类内初始值。 即使一个常量静态数据成员在类内部被初始化了，通常情况下，他们也应该在类外部定义下该成员。 静态数据成员的特殊功能 可以是不完全类型 可以作为默认实参。","tags":[{"name":"类","slug":"类","permalink":"http://yoursite.com/tags/类/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第七章类","slug":"C-语言/C-Primer/第七章类","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第七章类/"}]},{"title":"表达式","date":"2018-08-14T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第四章 表达式/表达式/","text":"主要内容： 基础 算术运算符 逻辑和关系运算符 赋值运算符 递增和递减运算符 成员访问运算符 条件运算符 位运算符 sizeof运算符 逗号运算符 类型转换运算符 运算符优先级 运算符优先级大概层级： 作用域运算符 成员选择、下标、函数调用 后置加加减减、类型id，类型转化 一元运算符 乘法 加法 移位 关系 位 逻辑 条件 赋值 逗号 基础 优先级（precedence） 结合律（asscociativity） 求值顺序 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存的位置）。 赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也是一个左值。 取地址运算符作用域左值运算对象，返回一个指向改运算对象的指针，这个指针是一个右值。 内置解引用、下标运算符、迭代器解引用求值结果是左值. 内置类型、迭代器递增运算符作用域左值，前置版本结果左值. 使用关键字decltype的时候，左值和右值有所不同，如果表达式的求值结果是左值，decltype作用于该表达式（不是变量）得到一个引用类型。 优先级 结合律 求值顺序 有4种表达式明确规定了求值顺序 逻辑与&amp;&amp; 逻辑或|| 条件运算符？： 逗号表达式 算术运算符(-m)/n = m/(-n) = -(m/n) m%(-n) = m%n (-m)%n = -(m%n) m%n的符号和m的相同 逻辑和关系运算符逻辑与、逻辑或求值短路 几个关系运算符链子一起会产生意想不到的结果 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。 赋值运算符赋值运算符的结果是左侧运算对象，并且是左值。如果赋值运算符的两个运算对象类型不同，右侧对象将转换为左侧运行对象类型。 赋值运算符满足右结合律，这个和其他的二元运算符不太一样。 赋值运算符的优先级低于关系运算符 递增递减运算符为啥有？ 某些迭代器不支持算术运算 前置版本递增：首先将运算对象加1，然后将改变后的对象作为求值结果。 后置版本的递增：将运算对象加1，但是求值结果是运算对象改变之前的那个值的副本。 优先使用前置版本，前置版本的递增运算符避免了不必要的功过，把加1后的对象直接返回，相反：后置版本需要将原始值存储下来，以便返回未修改的内容，对于复杂的迭代器，这种额外的工作消耗巨大。 12345678*iter++ //这种写法比较普遍，后置++的优先级高,等价于下面两行代码*iter;++iterauto pbeg = v.begin();while(pbeg != v.end() )&#123; cout &lt;&lt; *pbeg++ &lt;&lt; end ; //输出当前值，并将pbeg向前移动一个元素&#125; 1234567while (begin != v.end &amp;&amp; !isspace(*begin))&#123; *begin = toupper(*begin++); //错误：该语句未定义&#125;///可以解释为下面的任何一种*begin = toupper(*begin);*(begin+1) = touper(*begin) 所以，如果一条子表达式改变了某个运算对象的值，另一个表达式又要使用该值的话，运算符的求值顺序非常关键。 成员访问运算符表达式ptr-&gt;mem 等价于 (*ptr).mem。 箭头运算符作用于一个指针类型的运算对象，结果是一个左值。点运算符分成两种两种情况：如果成员所属的对象是左值，结果是左值，反之，如果成员所属的对象是右值，那么结果是右值。 条件运算符条件运算符将简单的if else 逻辑切入到单个表达式当中。基本形式 1cond? expr1: expr2 移位运算符二进制移位，移出边界之外的位就被舍弃掉了 位求反运算符~ 将运算对象逐位求反。 如果运算对象是小整数，它的值会被自动提升。 位于 &amp; 位或 | 位异或 ^ sizeof 运算符sizeof返回一个表达式或者一个类型名字所占的字节数，满足右结合律，返回值类型是size_t类型。sizeof并不计算运算对象的值。 12sizeof(type)sizeof expr sizeof *p sizeof不需要解引用指针也能知道它所指对象的类型，所以即使p是无效指针也不会有什么影响。 对char或者类型是char的表达式执行sizeof运算，结果是1. 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 对指针执行sizeof运算，得到指针本身所占内存的大小 对解引用指针指向sizeof运算，得到指针所指对象所占空间的大小，指针不需要有效 对数组执行sizeof运算，得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算，并求和。sizeof不会把数组转化为指针。 对string、vector对象执行sizeof运算，只返回该类型固定部分大小。不会计算对象中元素所占空间。 逗号运算符对于逗号运算符，首先对左侧的表达式求值，然后将求值结果丢弃，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么求值结果是左值。 类型转换C++语言不会直接将两个不同类型的值相加，而是先根据类型转换规则，设法将运算对象的类型统一后再求值。 隐式类型转换发生场景 在大多数表达式中，比int类型小的整数值首先提升为较大的整数类型。 在条件中，非布尔类型转换为布尔类型。 初始化过程中，初始值转换为变量的类型。在赋值语句中，右侧对象转换为左侧运算对象类型 算术或者关系运算对象有多种类型，需要转换为同一种类型 函数调用时会发生类型转换 算术转换整数提示：char signed char、 unsigned char、 short 、unsigned short 、bool 一般会提升为int 有符号的转化为无符号的（大小相等）整数转化为浮点数转化为宽类型 其他隐式类型转换 数组转成指针： 在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作decltyoe关键字参数，或者取地址&amp;，sizeof及typeid等运算对象时，上述转化不会发生。如果用引用初始化数组，也不会发生转化。 指针的转化：常量整数0或者字面值nullptr能转化成任意指针类型。指向任何非常量指针能转换成void 指向任何对象的指针能转化成const void 转换成布尔类型：存在一种从算术类型或者指针类型向布尔类型自动转化的机制，如果指针或算术类型值为0，转换结果是false，否则转换结果是true。 转换成常量：允许冲非常量类型的指针转化为常量类型的指针。 命名的强制类型转换。 static_cast：任何具有明确定义的类型转化，只要不包含底层const，都可以使用const_cast：只能改变运算对象的底层constreinterpret_cast: 通常为运算对象的位模式提供较底层次上的重新解释。 运算符优先级 结合律 运算符 功能 用法 左 :: 全局作用域 ::name 左 :: 类作用域 class::name 左 :: 命名空间作用域 namespace::name 左 . 成员选择 object.member 左 -&gt; 成员选择 pointer-&gt;member 左 [] 下标 expr[expr] 左 () 函数调用 name(expr_lit) 左 () 类型构造 type(expr_lit) 右 ++ 后置递增运算 lvalue++ 右 – 后置递减运算 lvalue– 右 typeid 类型ID typeid(type) 右 typeid 运行时类型ID typeid(expr) 右 explicit cast 类型转换 cast_name(expr) 右 ++ 前置递增运算 ++lvalue 右 – 前置递减运算 –lvalue 右 ~ 位求反 ~expr 右 ! 逻辑非 !expr 右 - 一元负号 -expr 右 + 一元正号 +expr 右 * 解引用 *expr 右 &amp; 取地址 &amp;lvalue 右 () 类型转换 (type)expr 右 sizeof 对象大小 sizeof expr 右 sizeof 类型大小 sizeof(type) 右 Sizeof… 参数包的大小 sizeof…(name) 右 new 创建对象 new type 右 new [] 创建数组 new type[size] 右 delete 释放对象 delete expr 右 delete [] 释放数组 delete [] expr 右 noexcept 能否抛出异常 noexcept(expr) 左 -&gt;* 指向成员选择的指针 ptr-&gt;*prt_to_member 左 .* 指向成员选择的指针 obj.*prt_to_member 左 * 乘法 expr*expr 左 / 除法 expr/expr 左 % 取模（取余） expr%expr 左 + 加法 expr + expr 左 - 减法 expr -expr 左 &lt;&lt; 向左移位 expr &lt;&lt; expr 左 &gt;&gt; 向右移位 expr &gt;&gt; expr 左 &lt; 小于 expr &lt; expr 左 &lt;= 小于等于 expr &lt;=expr 左 &gt; 大于 expr &gt; expr 左 &gt;= 大于等于 expr &gt;= expr 左 == 相等 expr == expr 左 != 不相等 expr != expr 左 &amp; 位与 expr &amp; expr 左 ^ 位异或 expr ^ expr 左 ` ` 位或 `expr expr` 左 &amp;&amp; 逻辑与 expr &amp;&amp; expr 左 ` ` 逻辑或 `expr expr` 左 ?: 条件 expr?expr:expr 左 = 赋值 lvalue = expr 左 *=,/-,%= 符合赋值 lvalue+=expr等 左 +=,-= 符合赋值 左 &lt;&lt;=,&gt;&gt;= 符合赋值 左 &amp;=,` =`,^= 符合赋值 右 throw 抛出异常 throw expr 左 , 逗号 expr,expr","tags":[{"name":"表达式","slug":"表达式","permalink":"http://yoursite.com/tags/表达式/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第四章 表达式","slug":"C-语言/C-Primer/第四章-表达式","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第四章-表达式/"}]},{"title":"字符串、向量、数组","date":"2018-08-10T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/","text":"主要内容： 命令空间的using声明 标准库类型string 标准库类型vector 迭代器介绍 数组 多维数组 基本类型体现了大多数计算机硬件本身具备的能力。标准库定义了另外一组具有更高级性质的类型。他们尚未直接实现到计算机硬件中。 命名空间的using声明std::cin中作用域运算符的含义：编译器从操作符左侧的名字所示的作用域中寻找右侧那个名字。 using声明的形式如下： 1using namespace::name; using 声明每次只能引入一个名字。using 声明必须以分号结束。 头文件不应该包括using声明。 标准库stringC++标准一方面对库类型所提供的操作做了详细的规定、另一方面也对库的实现者做了性能的要求。 定义和初始化string对象如何初始化对象由类的本身决定的。 初始化sting对象的方式 初始化形式 说明 string s1 默认初始化，s1是空串 string s2(s1) s2是s1的一个副本 string s2= s1 等价于s2(s1) string s3(“value”) s3是字面值value的副本，除了字面值最后的那个空字符外 string s3 = “value” 等价于s3(“value”) string s4(n,’c’) 初始化为连续n个字符c组成的字符串 直接初始化和拷贝初始化 拷贝初始化（copy initialization）：使用等号（=）初始化一个变量 直接初始化：不用等号 当初始值只有一个时，使用直接初始化和拷贝初始化都行，如果用到多个初始值，一般来说只能直接初始化。如果非要用拷贝初始化也可以，需要显示的创建一个临时对象用于拷贝。 string对象上的操作一个类除了规定初始化对象的方式外，还要定义对象上所能执行的操作。 操作示例 说明 os&lt;&lt;s 将s写到输出流os当中，返回os is&gt;&gt;s 从is中读取字符串赋给s，字符串以空白介绍，返回s getline(is,s) 从is中读取一行赋给s，返回is s.empty s为空返回true，否则返回false s.size 返回s中字符的个数 s[n] 返回s中第n个字符的引用 s1+s2 返回s1、s2连接后的结果 s1=s2 用s2的副本代替s1中原来的字符 s1 == s2 如果s1和s2所含的字符完全一样，则他们相等 s1 != s2 &lt;,&lt;=,&gt;,&gt;= 利用字符在字典中的顺序进行比较 读取string对象string对象会自动忽略开头的空白（空格，换行、制表符）并从第一个真正的字符开始算起，知道遇到下一处空白为止。 sting对象的此类输入输出操作返回运算符左侧的运算对象，所以，如果多个输入或者多个输出可以连在一起写。 使用getline读取一行getline函数从给定的输入流中读入内容，直到遇到换行符为止，换行符的内容也被读入进来。然后将所读的内容从存入到string中。 触发getline函数返回的那个换行符实际上被丢弃了，得到的string对象中不包含该换行符。 string的empty、size操作size返回的是string:size_type string的相等意味着长度相同，且所包含的字符也完全相等。 当把string对象和字符字面值及字符串字面值混在一条语句使用时，必须确保每个加法的两侧的运算符对象至少有一个是string。 处理string对象中的字符cctype头文件中定义了一组标准函数处理字符： 函数 说明 isalnum(c) 当c是字母或数字时为真 isalpha(c) 当c是字母时为真 iscntrl(c) 当c是控制字符时为真 isdigit(c) 当c是数字时为真 isgraph(c) 当c不为空格，单可打印时为真 islower(c) 当c是小写字母时为真 isprint(c) 当c是可打印字符时为真，空格，可视字符 ispunct(c) 当c是标点符号时为真 isspace(c) 当c是空白时为真(空格、制表符、回车、换行、进制符) issupper(c) 当c是大写字母时为真 isxdigit(c) 当c是十六进制数字时为真 tolower(c) 如果c是大写字母，输出对应的小写字母，否则原样输出 toupper(c) 如果c是小写字母，输出对应的大小字母，否则原因输出 c语言的头文件形如name.h，在C++中将这些文件命名为cname，也就是去掉了.h后缀，在name名字前添加了字母c，这里的c表示是一个属于c语言标准库的头文件。cnmae的头文件中定义的明智属于命名空间std。而定义在.h的名字则不在。 范围for语句（range for）12for (declaration : expression) statement 其中expression部分是一个对象，表示序列。declaration是定义一个变量，用于访问序列中的基础元素。每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值。 12345for ( auto c : str)&#123; cout&lt;&lt; c &lt;&lt; endl;&#125;///对字符串c的每个字符c做某种操作 如果想改变string对象中的字符的值，必须把循环变量定义成引用类型。这个变量实际上绑定到序列中的每个元素。 下标运算符：通过位置，返回该位置上字符的引用。 使用超出下标范围将引发不可预知的结果，使用下标访问空string也引发不可预知结果。 不管什么时候，只要对string对象使用下标，都要确认在那个位置上确实有值。 只要字符串不为常量，就能为下标运算符返回的字符串赋新值。 标准库vector标准库类型vector表示对象的集合，其中所有对象的类型都相同，集合中每个对象都有一个与之对应的索引，索引可以访问对象。因为vector“容纳着”其他对象，所以，所以他被称为容器（container）。 模板本身不是类或者函数，相反，可以看做是编译器生成类或者函数编写的一份说明。编译器根据模板创建类或者函数的过程称为实例化（instantiation），当使用模板时，需要指出编译器应把类或者函数实例化成何种形式。 提供信息的方式：即在类模板名字后面跟一对尖括号，括号内放类型信息。 vector是模板，而不是类。 定义、初始化vector对象|初始化示例|说明||vector v1| v1是一个空vector，他潜在的元素是T类型，执行默认初始化||vector v2(v1)|v2中包含v1所有元素副本||vector v2 = v1|等价于v2(v1)||vector v3(n,val)|v3包含那个重复的元素。每个元素的值是val||vector v4(n)|v4 包含了n个重复的执行了值初始化的元素||vector v5{a,b,c,…}|v5包含了初始值个数的元素，每个元素被赋予相应的初始值||vector v5 = {a,b,c,…}|等价于v5{a,b,c,…}| 列表初始化vector对象。 值初始化：通常情况下，可以只提供vector对象容纳元素数量，而略去初始值，此时，库会创建一个值初始化的元素初值，并且把它赋值给容器中所有元素。这个初始值由vector元素类型决定。 如果是内置类型，如int，元素初始值自动设置为0，如果是类类型，比如string，元素由类默认初始化。 如果只提供元素的数量而没有设定初始值，只能使用直接初始化。不让就是将数量拷贝给string对象了。 初始化过程中，尽可能地把花括号内的值当做是元素初始值列表处理，但是如果花括号形式所提供的值不能进行列表初始化，就要考虑用这样的值构造vector对象。 1234vector&lt;string&gt; v5&#123;\"hi\"&#125; //列表初始化，v5有一个元素vector&lt;string&gt; v6(\"hi\"); //错误不能构建vector&lt;string&gt; v7&#123;10&#125;; //v7有10个默认初始化的元素vector&lt;string&gt; v8&#123;10,\"hi\"&#125;; //v8有10个值为“hi” 的元素 在确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。 向vector对象中添加元素vector对象能高效的增长，如果初始化的时候指定大小，可能效率会低。 范围for循环体内不应改变其所遍历序列的大小。 其他vector操作 vector操作 说明 v.empty() 如果v不含有任何元素，返回真，否则，返回假 v.size() 返回v中元素个数 v.push_back(t) 向v的尾部添加一个值为t的元素 v[n] 返回v中第n个位置上元素的引用 v1 = v2 用v2中元素的拷贝替换v1中的元素 v1 = {a,b,c…} 用列表中元素的拷贝替换v1中的元素 v1== v2 元素数目相同、对应位置上的元素值相同 v1 != v2 &lt; ,&lt;=, &gt; ,&gt;= 以字典的顺序进行比较 vector对象的类型总是包含元素的类型。只有当元素的类型可以比较时，vector对象才能比较。vector可以使用下标读写元素，不能通过下标添加元素。只能对已经存在的元素 缓冲区溢出（buffer overflow） 就是指的下标越界这类错误。 迭代器类似指针类型，迭代器提供了对对象的间接访问。就迭代器而言，其对象是容器中元素或者string对象中的字符。 和指针不同，获取迭代器不是使用取地址符，有迭代器的类型，同时拥有返回迭代器的成员。比如begin、end成员。 begin成员负责返回指向第一个元素的迭代器。 end成员负责返回指向容器 尾元素的下一个位置的迭代器。 end成员返回的迭代器通常称为尾后迭代器。 如果容器为空，则begin、end返回的是同一个迭代器。都是尾后迭代器。 使用迭代器迭代器的运算符如下： 运算符 说明 *iter 返回迭代器所指元素的引用 iter-&gt;mem 解引用iter并获取该元素的名为mem的成员，等价于(*iter)-&gt;mem ++iter 令iter指示容器的下一个元素 –iter 令iter指示容器的上一个元素 iter1 == iter2 判断两个元素是否相等，如果两个迭代器指示的是同一个元素，或者他们是同一个容器的尾后迭代器，则他们相等，否则不行等 iter1 != iter2 指针和迭代器的相同点： 可以解引用来获取它所指元素 也有有效和无效之分，有效：迭代器指向某个元素，或者指向容器中尾元素的下一个位置，其他所有情况都无效 提供了对对象的间接访问 都可以移动到下一个元素、上一个元素 视图解引用非法迭代器或者尾后迭代器都是未定义的， 解引用非法指针也是非法的 指针和迭代器的不同点： 获取方式不同，指针：取地址； 迭代器：通过容器的成员。 迭代器使用实例 123456string s(\"some string\");if(s.begin() != s.end())&#123; auto it = s.begin(); *it = touper(*it);&#125; 因为end返回的迭代器并不实际指示元素，所以不能对其进行递增或者解引用的操作。 1234for(auto it = s.begin(); it != s.end() &amp;&amp; !isspace(*it); ++it)&#123; *it = toupper(*ite);&#125; 只有string、vector等一些标准库类型有下标运算符，而并非全部如此，与之类似，所有标准库的迭代器都定义了==、!=，但是他们中的大多数没有定义&lt; 运算符，因此， 我们要养成使用迭代器和!=运算符的习惯。 实际上，那些拥有迭代器的标准库使用iterator、const_iterator表示迭代器类型。 const_iterator和常量指针差不多。能读取，不能修改。 如果vector、string对象是一个常量，只能使用const_iterator，如果vector、string不是常量，既能使用iterator，也能使用const_iterator begin和end运算符： begin和end返回的具体类型由对象是否常量觉得，如果对象是常量，begin和end返回const_iterator，如果不是，返回iterator。 1234vector&lt;int&gt; v1;const vector&lt;int &gt; v2;auto iter1 = v1.begin(); //iter1的类型是vector&lt;int&gt;::iteratorauto iter2 = v2.begin(); //iter2 的类型是vector&lt;int&gt;::const_iterator cbegin()、cend() 返回const_iterator类型迭代器。 箭头-&gt;运算符将解引用和成员访问两个操作结合在一起。也就是it-&gt;mem和(*it).mem表达式的意思相同。 凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。 迭代器运算 迭代器运算 说明 iter + n 迭代器加上整数值，扔是一个迭代器类型。迭代器指示的新位置与原来的位置相比，向前移动了n个元素。结果迭代器或者指向容器的下一个元素，或者指向容器尾元素的下一个位置 iter - n iter += n iter1= n iter 1 - iter2 &lt;, &lt;=, &gt;,&gt;= 两个迭代器的间距的类型是diffrence 类型。带符号的。 数组定义、初始化内置数组数组中元素的个数也属于数组类型的一部分，编译的时候纬度应该已知。 1int *parr[10] ; //含有10个整形指针的数组。 默认情况下，数组的元素被默认初始化。和内置类型的变量一样， 如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型。不允许使用auto关键字由初始值的列表来推断类型。 可以对数组的元素进行列表初始化，此时，允许忽略数组的纬度。如果声明时没有指定纬度，编译器会根据初始值的数量计算并推断出来，如果指定了维度，那么初始值的总数量不应该超过指定的大小。 字符数组的特殊性： 一定要注意，字符串字面值的结尾还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。 1char a[] = \"C++\" ; // 容量4 不能讲数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值 123int a[] = &#123;1,2,3&#125;;int a2[] = a; //错误不能用一个数组初始化另一个数组a2 =a; //错误不能把一个数组赋值给另一个数组 理解复杂数组声明 1234int *ptrs[10]; //ptrs是含有10个整数指针的数组int &amp;refs[10]; //错误，不存在引用的数组int (*parray)[10]; //parray指向一个含有10个整数的数组int (&amp;arrRef)[10];//parray引用一个含有10个整数的数组 对数组而言，由内向外阅读比较合适。parray是一个指针，指向一个含有10个元素的数组，数组的元素类型是整形。 访问数组元素大多数常见的安全问题都源于缓冲区溢出错误，当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。 指针和数组数组的特性：在很多用到数组名字的地方，编译器都会自动的将其替换为一个指向数组首元素的指针。当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。 decltype不会执行数组到指针的转化。 指针也是迭代器 标注库函数begin、end。由于数组不是类类型，因此这两个函数不是成员函数。begin函数返回指向数组首元素的指针，end函数返回指向数组尾元素下一个位置的指针。 尾后迭代器不能执行解引用和递增操作。 两个指针递减的结果类型是一种名为ptrdiff_t的标准库类型。定义在cstddef头文件中。 很多情况下，使用数组的名字，其实用的是一个指向数组首元素的指针。 内置下标运算符所用的索引值不是无符号类型，这一点和vector和string不一样。 C分格字符串 c分格字符串的函数 说明 strlen() 返回p的长度，空字符不计算在内 strcmp(p1,p2) 比较p1、p2的相等性，如果p1==p2 返回0，如果p1&gt;p2，返回一个正值，如果p1&lt;p2,返回一个负值 strcat(p1,p2) 将p2附加到p1之后，返回p1 strcpy(p1,p2) 将p2拷贝给P1，返回p1 当使用数组的时候其实真正用的是指向数组首元素的指针。所以比较字符串实际上比较的是指针。 与旧代码的接口 允许使用 以空字符结束的字符数组来初始哈动态string对象或者为string对象赋值 在string对象的加法运算中，允许使用空字符结束的字符数组作为其中一个运算对象。 string对象的c_str函数返回一个C风格的字符串。 可以使用数组初始化vector对象。 多维数组严格来说，C++语言没有多维数组，通常所说的多维数组其实是数组的数组。 要使用范围for语句处理多维数组，除了内层的循环外，其他所有循环的控制变量都应该是引用类型。类型别名简化多维数组指针 12using int_ary = int[4]; //int_ary 是含有4个整型元素的数组typedef int int_ary[4];","tags":[{"name":"字符串","slug":"字符串","permalink":"http://yoursite.com/tags/字符串/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第三章 字符串、向量、数组","slug":"C-语言/C-Primer/第三章-字符串、向量、数组","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第三章-字符串、向量、数组/"}]},{"title":"特殊工具和技术","date":"2018-08-02T01:07:12.000Z","path":"wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/","text":"控制内存重载new和delete当我们使用new表达式时 12string * sp = new string(\"a string\");string * arr = new string[10]; 实际执行了三步： new 表达式调用 operator new 或operator new [] 标准库，分配一块足够大、原始的、未命名的内存空间。 编译器运行相应的构造函数，并传入初始值。 返回一个指向该对象的指针。 当我们使用delete表达式时 12delete sp;delete [] arr; 调用析构函数 调用名为operator delete 或者operator delete [] 释放空间。 发现new、delete表达式，如果对象是类类型，首先在类类型中查找，然后是全局作用域。也可以使用::new直接使用全局作用域的。 1234void * operator new(size_t);void * operator new[](size_t);void operator delete(void*) noexcept;void operator delete[](void*) noexcept; 类作用域的new、delete是静态的。因为operator new 用在对象构造之前，operator delete 用在对象销毁后。而且不能操作类的任何成员。 new表达式和 operator new 函数：不能改变new表达式、delete表达式的含义。 malloc函数接受一个表示带分配字节数的size_t，返回指向分配空间的指针。 123456789101112131415void * operator new(size_t size)&#123; if(void* mem = malloc(size)) &#123; return mem; &#125; else &#123; throw bad_alloc(); &#125;&#125;void operator delete(void* mem) noexcept &#123; free(mem);&#125; 定位new表达式1234new (place_address) typenew (place_address) type (initializers)new (place_address) type [size]new (place_address) type [size] &#123;braced initializer list&#125; 定位new 使用 operation new (size_t ,void *)函数定位new 可以构造对象，单不分配内存 申请释放空间 构造销毁对象 allcator allocate construct destroy deallocate 申请释放空间 构造销毁对象 new的形式 operator new 构造函数（定位new可以只构造对象，不申请空间） free 析构函数（可以直接调用） 运行时类型识别 typeid 运算符，返回表达式的类型 dynamic_cast运算符 用于将基类指针或引用安全的转化为派生类的指针或者引用 当操作被定义为虚函数时，编译器将根据对象的动态类型自动的选择正确的版本 。 dynamic_cast (e) dynamci_cast (e) dynamic_cast (e) 当typeid作用于指针时（而非指针所指的对象），返回的结果是该指针的静态编译时类型。 type_info 类的name成员函数返回一个C风格的字符串，表示对象的类型名字。type_info 只能通过typeid运算符创建。 枚举类型枚举类型使我们可以将一组整形常量组织在一起。 限定作用域 不限定作用域 1enum class 枚举名 &#123; 逗号分隔的枚举列表&#125;; 枚举值可以不唯一，枚举成员是常量表达式。 和类一样，枚举也定义新的类型，也能定义变量。enum对象赋值必须使用该类型的一个枚举成员，或该类型的另一个对象。 指定enum的大小 12enum intValue : unsigned long long &#123;&#125;; 枚举类型的前置声明 类成员指针成员指针，是指可以指向类的非静态成员的指针。一般情况下，指针指向一个对象，但是成员指针指示的是类的成员。 成员指针的类型囊括了类的类型、成员的类型。当初始化一个这样的指针时，我们另其指向类的某个成员，但是不指定该成员所属的对象。直到使用成员指针时，才提供成员所属的对象。 数据成员指针声明成员指针时，必须包含成员所属的类 12const string className:: * pdata;pdata = &amp;Screen::contents //指向某个非特定Screen对象的contents成员 当我们初始化一个成员指针或为成员指针赋值时，该指针并没有指向任何数据。成员指针指定了成员，而非该成员所属的对象。只有当解引用成员指针时，我们才提供对象的信息。 也就是解引用时候绑定到特定的对象上。 12345static const std::string Screen::* data()&#123; retrun &amp;Screen::contents;&#125;// data 指向Screen类const string 成员指针。 成员函数指针char (Screen::*pmf2)(int,int ) const; 将成员函数用作可调用对象成员函数指针不是可调用对象，调用前必须使用.或者-&gt;绑定到特定对象上。所以不能直接将成员函数指针传递给算法。 以下内容无法理解：1. 可以使用function生成一个可调用对象。2. 可以使用mem_fn生成一个可调用对象。3. 使用bind 生成一个可调用对象。 嵌套类一个类可以定义在另一个类的内部，前者称为嵌套类（nested class） ，后者称为嵌套类型（nested type）。 嵌套类是一个独立的类，与外层基本没有什么关系，特别是，外层类对象和嵌套类对象是相互独立的，嵌套类的对象不能包括任何外层类定义的成员；类似的，在外层类的对象也不能报考任何嵌套类定义的成员。嵌套类的名字在外层作用域内是可见的。之外不可见。 嵌套类对外层类的成员也没有特殊的访问权限。 union 一种节省空间的类union可以定义多个数据成员，但在任何时刻，只有一个数据成员可以有值。union可以定义包括构造函数和析构函数在内的成员函数。但union不能继承自其它类，也不能作为基类使用。 不能有虚函数。","tags":[{"name":"特殊工具和技术","slug":"特殊工具和技术","permalink":"http://yoursite.com/tags/特殊工具和技术/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十九章特殊工具和技术","slug":"C-语言/C-Primer/第十九章特殊工具和技术","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十九章特殊工具和技术/"}]},{"title":"模板和泛型编程","date":"2018-07-25T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/","text":"定义模板 模板实参推断 重载与模板 可变参数模板 模板的特例化 面向对象编程和泛型编程都能处理程序在不知道类型的情况，不同之处在于： OOP能处理类型在运行之前未知的情况，而在泛型编程中，在编译器时就能获知类型了。 一个模板就是一个创建类或函数的蓝图或者公式。当我们提足够的信息，将蓝图转化为特定的类或函数。这种转化发生在编译期。 定义模板函数模板12template &lt;typename T&gt;int compare(const T &amp;v1, const T &amp;v2); 模板定义以template开始，后跟一个模板参数列表。 函数参数： 调用时，实参初始化形参。 模板参数表示类、函数定义中用到的类型或值。使用模板时，指定模板实参，绑定到模板形参上。 函数实参推断模板实参。 模板类型参数 ： 非类型参数：是常量，必须能字编译时处理。使用场景：数组的大小 模板编译：当编译器遇到一个模板时，他并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用模板时，编译器才生成代码。 函数模板和类模板成员函数的定义放在头文件中 类模板 类模板实例化：必须提供模板实参，由于没法推断出来。 一个类模板的每个实例都形成一个独立的类。类型Blob 与任何其他Blob类型都没有关联。 类模板作用域中引用模板类型： 定义在类模板之外的成员函数必须以关键字 template开始。 （由于每个实例都以自己版本的成员函数） template ret-type Blob::memberName(param) 构造函数的定义以模板参数开始 类模板成员函数实例化：一个类模板的成员函数只有当程序用到它时才进行实例化。如果一个函数没有调用，则它不会实例化。 在类内部代码简化模板类名的使用。当我们使用类模板类型时必须提供实参，但这一规则有一个例外。在类模板的作用域中，可以指向使用模板名，不提供实参 在类模板外使用类模板名：在类模板外定义其成员时，必须记住，我们并不在类的作用域中。知道遇到类名，才表示进入作用域。返回值在类的作用域外。","tags":[{"name":"模板和泛型编程","slug":"模板和泛型编程","permalink":"http://yoursite.com/tags/模板和泛型编程/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十六章 模板和泛型编程","slug":"C-语言/C-Primer/第十六章-模板和泛型编程","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十六章-模板和泛型编程/"}]},{"title":"变量和基本类型","date":"2018-07-25T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/","text":"C++ 是静态数据类型语言，类型检查发生在编译时。数据类型是程序的基础，他告诉我们数据的意义以及我们能在数据上执行的操作。 主要内容 ： 基本内置类型 变量 复合类型 const限定符 处理类型 自定义数据类型 基本内置类型C++ 定义了一套包括算术类型和空类型的基本数据类型。 算术类型： 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode字符 16 char32_t Unicode字符 32 short 短整形 16 int 整形 16 long 长整形 32 long long 长整形 64 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10 位有效数字 寻址的最小内存块为 字节(byte) 大多数的字节由8个bit构成。 存储的基本单元称为 字(word) 一般32或64bit。 通常，float一个字，double两个字，long double4个字，类型float和double 分别有7个和16个有效位。 与其他类型不同，字符型被分为三种：char、signed char 、 unsigned char。char 和signed char 并不是一种，尽管类型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种的一种，具体由编译器决定。 如何选择类型： 在算术表达式中不要使用char 、bool 只有在存放字符或者bool值时候才使用它们，因为类型char在一些机器上有符号，而在另外一些机器上又是无符号的，所以，如果使用char 进行运算特别容易出问题。如果使用一个不大的整数，那么明确指定它的类型是signed char 或者 unsigned char。 执行浮点运算选用double，这是因为float通常进度不够。对于某些机器，双精度运算甚至比单精度还快。 类型转换当给某种类型的对象强制赋予了另一种类型的值时，到底发生了什么？ 12bool b = 42;int i = b ; ///i的值时1 当把一个非布尔类型的算术值赋给布尔类型时，初始值0是false，否则为true。 当把一个布尔值赋值给非布尔类型时，初始值false 是0，true是1. 浮点数赋值给整数类型时，进行近似处理，保留小数部分之前的。 将超出范围的值赋值给无符号类型：结果是初始值对无符号类型表示的总数取模后的余数。 将超出范围的值赋给带符号类型，结果未定义。 含有无符号类型的表达式1. 无符号数递减不能是负值，如果为负值，会是取模的余数。2. 切勿混用带符号和无符号类型。如果表达式里面既有带符号的，又有无符号的，带符号的数会转化为无符号的数。### 字面值常量|字面常量|进制||—|—||20|十进制||024|八进制||0x14|十六进制|1. 字面值常量的类型是能容纳该数值的尺寸最小的那个（int long， long long），默认是带符号的。类型short没有对应的字面值。浮点型字面值类型是double。2. 字符串字面值的类型实际上是由常量字符构成的数组，末尾添加‘\\0’。3. 如果两个字符串字面值位置紧邻且仅由空格，缩进、换行符分隔，则他们实际上是一个整体12std::cout &lt;&lt; \"a really\" \"that spans\";有两种类型字符不能直接使用，需要转义：1. 不可打印2. 特殊含义字符：单引号、双引号、问号、反斜杠### 指定字面值的类型指定字符和字符串字面值：指定的方法如下表：|前缀|含义|类型||—|—|—||u|Unicode 16字符|char16_t||U|Unicode 32 字符|char32_t||L|宽字符|wchar_t||u8|UTF-8(仅用于字符串字面常量)|char|指定整数字面值|后缀|类型||—|—||u U|unsigned||l L|long||ll LL|long long|指定浮点字面值|后缀|类型||—|—||f F|float||l L|long double|## 变量变量提供具名的、可供程序操作的存储空间。C++每个变量都有数据类型，数据类型决定着变量所占内存空间的大小、布局方式、该空间能存储的值的范围、以及变量能参与的运算。### 变量定义基本形式：类型说明符（type specifier） + 变量名string表示可变长字符序列 的数据类型对象是指能存储数据并具有某种类型的存储空间。当一次定义了两个或多个变量时，对象的名字随着定义也马上可以使用了。因此在同一条语句中，可以用先定义的变量去初始化后定义的其他变量。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。而赋值的含义是把对象的当前值擦除，而以一个新值来代替。 初始化的四种形式： 1234int a = 0;int a = &#123;0&#125;;int a&#123;0&#125;;int a(0); 花括号的初始化形式称为初始化列表。 初始化列表用于内置类型的变量时：如果初始值存在丢失信息的风险，编译器报错。 如果定义变量时没有指定值，则变量被默认初始化（default initialized），此时变量被赋予了默认值。 函数体之外的内置变量被初始化为0；函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显示初始化，则其值由类确定。 变量声明和定义的关系声明：规定了变量的类型和名字，这一点和定义相同。定义：除了规定变量的类型和名字，还申请存储空间、为变量赋一个初始值。 声明代码： 12extern int i; //声明i，而非定义i，extern double pi = 3.14; 任何包含了显示初始化的声明既变为定义。 变量能且只能被定义一次，但是可以被多次声明。 这相当于为分离式编程提供了支持 C++是一种静态类型语言，其含义是在编译阶段检查类型。其中检查类型的过程称为类型检查。 编译器知道每一个实体对象的类型是通过类型声明。 标识符用户定义的标识符不能连续出现两个下划线、不能以下划线紧连大写字母开头、定义在函数体外的标识符不能以下划线开头。 变量命名规范： 标识符要能体现实际含义 变量一般用小写字母 用户定义的类名一般以大写字母开头 标识符由多个单词组成，则单词间应该有明显区分 名字的作用域名字的有效区域始于名字的声明语句，以声明语句所在的作用域未端为结束。 第一次使用变量时再定义变量，这样好处： 更容易找到变量的定义 容易赋值合理的初始值 全局作用域 块作用域 嵌套作用域 内层作用域可以访问外层作用域中的名字 内层作用域中可以重新定义外层作用域中的名字 使用作用域运算符可以直接访问外层作用域中的名字 复合类型（引用、指针）复合类型是基于其他类型定义的类型（compound type） 基本数据类型 + 声明符 声明符命令了一个变量，并指定该变量的相关类型。 引用引用（reference） 为对象起了另一个名字。 12int ival = 0;int &amp;refVal = ival; 一般在初始化变量时，初始值会被拷贝到新建的对象中，然而，定义引用时，程序把引用和它的初始值绑定在一起。而不是将初始值拷贝给引用。一旦初始化完成，引用将和他的初始值一直绑定在一起。因为无法令引用重新绑定到另一个对象，因此，引用必须初始化。 定义一个引用后，对其进行的所有操作都是在与之绑定的对象进行的。 获取引用的值：实际上是获取了与引用绑定的对象的值。 以引用为初始值： 实际上是以与引用绑定的对象作为初始值。 因为引用本身不是一个对象，所以不能定义引用的引用。 用于在一条语句中定义多个引用，其中每个引用标识符都必须以符号&amp;开头。 引用的类型要和与之绑定的对象严格匹配。引用只能绑定在一个对象上，而不能与字面值或某个表达式的计算结果绑定在一起。 指针与引用类型相同，指针也实现了对其他对象的间接访问。 指针和引用的区别： 指针本身也是对象，允许对指针赋值和拷贝，而且在指针的生命周期内，它可以先后指向几个不同的对象。 指针无需在定义的时候赋值。 指针存放某个对象的地址。要想获取该地址，使用取地址符 12int ival = 42;int *p = &amp;ival;//p存放变量ival的地址。 或者说p是指向变量ival的指针。 指针的类型都要和它所指向的对象严格匹配。 指针值：指针的值（即地址）应属于下列4中状态之一： 指向一个对象。 指向紧邻对象所占空间的下一个位置 空指针，意味着指针没有指向任何对象。 无效指针，也就是上述情况之外的其他值。 解引用来访问该对象，解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针使用nullptr，新标准使用NULL，NULL是预处理变量。 如果使用了未经初始化的指针，则该指针所占内存空间的当前内容被看做是一个地址值，访问该指针，相当于去访问一个本不存在的位置。 指针和引用都能自动对其他对象间接访问，然而，在具体实现细节上，二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象。之后每次使用这个引用都是访问它最初绑定的那个对象。 给指针赋值，就是令其存放一个新地址。 如果两个指针存放的地址值相同，则他们相等。 void 是一种特殊的指针类型，可用于存放任何对象的地址。一个`void指针存放着一个地址。这一点和其他指针类似。不同的是，我们对该地址中到底是什么类型的对象不了解。 不能直接操作void*` 指针所指的对象。因为我们不知道这个对象到底是什么类型。 理解复合类型12//p是int型指针、r是一个int型引用int i = 1024, *p = &amp;i, &amp;r = i; 指向指针的指针123int ival = 1024;int *pi = &amp;ival;int **ppi = &amp;pi; ///ppi指向一个int型的指针 ppi -&gt; pi -&gt; ival (1024) 指向指针的引用12345int i = 42;int *p;int *&amp;r = p ;//r是一个对指针p的引用r = &amp;i; //r 引用了一个指针，因此给r赋值，就是令p指向i*r = 0; //解引用r得到i，也就是p指向的对象，将i的值改为0 离变量名最近的符号对变量类型有最直接的影响。所以r是引用。 const限定符默认情况下，const对象仅仅在文件内有效。如果想在多个文件中共享const对象，就对const变量不管是声明还是定义都添加extern关键字。这样只需定义一次就可以了。 const 引用可以把引用绑定到const 对象上，我们称为对常量的引用（refernce to const） 。一定要记住， 初始化和对const的引用引用的类型必须和其所引用对象的类型一致，但是有两个例外，第一种例外情况是初始化常量引用时允许用任何表达式作为初始值，只要改表达式的结果能转化成引用的类型即可。尤其，允许为一个常量引用绑定非常量对象、字面值，甚至是一般表达式。 12345int i = 42;const int &amp;r1 = i; //允许将const int&amp;绑定到一个普通int对象上const int &amp;r2 = 42; //正确const int &amp;r3 = r1*2 //正确int &amp;r4 = r1* 2; //错误 对const的引用可能引用一个并非const的对象必须认识到：常量引用仅对引用可参与的操作做出了限定，对引用的对象本身是不是一个常量未作限定。 指针和const指向常量的指针（pointer to const） 不能用于改变其所指对象的值，要想存放常量对象的地址，只能使用指向常量的指针。 1234const double pi = 3.14; //pi是个常量，它的值不能改变double *ptr = &amp;pi; // 错误：ptr是一个普通指针const double *cptr = &amp;pi; //正确：cptr可以指向一个双精度常量*cptr = 42; //错误：不能给*cptr赋值 指针的类型必须与其所指对象的类型一致，但是有两个例外，其中一个是：允许一个指向常量的指针指向一个非常量对象。 试试这样想吧：所谓指向常量的指针和引用，不过是指针或引用“自以为是”罢了，他们觉得自己指向了常量，所以自觉的不去改变所指对象的值。 const指针指针是对象而引用不是，所以就像其他对象类型一样，允许指针本身定为常量。常量指针必须初始化，而且一旦初始化完成，它的值就不能改变了。把*放在const关键字之前用以说明指针是一个常量。即不能改变指针本身的值，而非指向的那个值。 1234int errNumb = 0;int *const curErr = &amp;errNumb; //curErr将一直指向errNumbconst double pi = 3.14; const double * const pip //pip 是一个指向常量对象的常量指针 要想弄清楚这些声明的含义，最行之有效的方法是从右向左阅读 顶层const指针本身是一个对象，它又可以指向另外一个对象，因此，指针本身是不是常量以及指针所指的是不是一个常量，是两个相互独立的问题，用名词顶层const表示指针本身是一个常量，而用名词底层const 表示指针所指的对象是一个常量。 更一般的，顶层const可以表示任意的对象是常量，这一点对任何类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const，也可以是底层const。 当执行对象的拷贝操作时，常量的顶层const还是底层const区别明显，其中顶层const不受影响： 123const int ci = 42;const int *p2 = &amp;ci //允许改变p2的值，底层constconst int *const p3 = p2; //正确，底层一样 另一方面，底层const的限制不能忽视 1int *p = p3; //错误，p指向的值可以通过p改变，但p指向的值是常量，所以错误 constexpr 和常量表达式常量表达式（const expression） 是指值不会改变并且在编译过程就能得到计算结果的表达式。用常量表达式初始化的const对象也是常量表达式 constexpr变量：如果认定变量是一个常量表达式，那就把它声明为constexpr类型 字面值类型字面值类型： 比较简单，值也显而易见，容易得到，算术类型、引用类型、指针都属于字面值类型。 string 不属于，也就不能被定义成constexpr。 函数体内定义的变量，一般来说并非存放固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象，其地址固定不变，能用来初始哈constexpr指针。 指针和constexpr在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指对象无关 12const int * p = nullptr //p是一个指向整型常量的 指针constexpr int *q = nullptr; //q是一个指向整形的向量指针。 处理类型为了简化复杂类型的定义 类型别名（type alias）123typedef double wages; //wages是double的同义词typedef wage base,*p ;// base 是double的同义词，p是double*的同义词using SI = Sales_item; //SI 是sales_item的同义词 using 把等号左侧的名字规定成等号右侧类型的别名。 指针、常量和类型别名12typedef char* pstring;const pstring cstr = 0;// cstr 是指向char的常量指针 pstring 的基本数据类型是指针 。 不能展开，如果展开就错了 1const char * cstr = 0; 展开就成了底层常量了 auto类型说明符auto让编译器通过初始值来推断变量的类型，显然，auto的定义必须有初始值。 引用： 编译器以引用对象的类型作为auto的类型，希望推断引用，需要 auto &amp; 顶层const常量： 忽略，希望推断顶层const常量，需要用const auto 底层const常量： 保留 decltype 类型指示符场景：希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。decltype不实际计算表达式的值。 decltype处理顶层const和引用的方式与auto有些不同，如果decltyoe使用的表达式时一个变量，则decltype返回该变量的类型，包括顶层const和引用在内。 需要注意的是：引用从来都作为其所指对象的同义词出现，只有用在decltype处是个例外。 如果表达式的内容是解引用操作，则decltype将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此，decltype（*p）的结果类型就是int&amp;，而非int。（表达式的值是左值，结果为引用） decltype的表达式如果是加上括号的变量，结果是引用。 自定义数据结构类体右侧表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名，以表示该类型对象的定义，所以分号必不可少。 可以为数据成员提供一个类内初始值，创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。 头文件通常包含哪些只能被定义一次的实体。例如类、const、constexpr变量等。 确保头文件多次包含仍能安全工作的技术是预处理器，预处理器是在编译之前执行的一段程序。#include就是预处理，当预处理器看到#include标记时，就会用指定的头文件内容替换#include C++程序还会用到的一项预处理功能是头文件保护符（header guard），头文件保护符依赖于预处理变量，预处理变量有两种状态：已定义、未定义。#define指令把一个名字设定为预处理变量。另外两个指令则分别检查某个指定的预处理变量是否已经定义。#ifdef、#ifndef、#endif。 预处理变量无视C++语言中关于作用域的规则。","tags":[{"name":"变量和基本类型","slug":"变量和基本类型","permalink":"http://yoursite.com/tags/变量和基本类型/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第二章变量和基本类型","slug":"C-语言/C-Primer/第二章变量和基本类型","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第二章变量和基本类型/"}]},{"title":"linux shell下的特殊用法及参数的说明","date":"2018-07-20T04:07:12.000Z","path":"wiki/linux命令/特殊参数/","text":"记录下linux shell下的特殊用法及参数的说明. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647变量说明:$$ Shell本身的PID（ProcessID） $! Shell最后运行的后台Process的PID $? 最后运行的命令的结束代码（返回值） $- 使用Set命令设定的Flag一览 $* 所有参数列表。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $@ 所有参数列表。如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $# 添加到Shell的参数个数 $0 Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。我们先写一个简单的脚本，执行以后再解释各个变量的意义 # touch variable # vi variable 脚本内容如下： #!/bin/sh echo \"number:$#\" echo \"scname:$0\" echo \"first :$1\" echo \"second:$2\" echo \"argume:$@\" 保存退出 赋予脚本执行权限 # chmod +x variable 执行脚本 # ./variable aa bb number:2 scname:./variable first: aa second:bb argume:aa bb 通过显示结果可以看到： $# 是传给脚本的参数个数 $0 是脚本本身的名字 $1是传递给该shell脚本的第一个参数 $2是传递给该shell脚本的第二个参数 $@ 是传给脚本的所有参数的列表","tags":[{"name":"set","slug":"set","permalink":"http://yoursite.com/tags/set/"}],"categories":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/categories/linux命令/"}]},{"title":"set命令","date":"2018-07-20T04:07:12.000Z","path":"wiki/linux命令/set命令/","text":"set -e 语句告诉bash如果任何语句的执行结果不是true则应该退出 123456789#!/bin/bashset -ecommand 1command 2...exit 0 Every script you write should include set -e at the top. This tells bash that it should exit the script if any statement returns a non-true return value. The benefit of using -e is that it prevents errors snowballing into serious issues when they could have been caught earlier. Again, for readability you may want to use set -o errexit. 你写的每个脚本都应该在文件开头加上set -e,这句语句告诉bash如果任何语句的执行结果不是true则应该退出。这样的好处是防止错误像滚雪球般变大导致一个致命的错误，而这些错误本应该在之前就被处理掉。如果要增加可读性，可以使用set -o errexit，它的作用与set -e相同。 Using -e gives you error checking for free. If you forget to check something, bash will do it for you. Unfortunately it means you can’t check $? as bash will never get to the checking code if it isn’t zero. There are other constructs you could use: 使用-e帮助你检查错误。如果你忘记检查（执行语句的结果），bash会帮你执行。不幸的是，你将无法检查$?，因为如果执行的语句不是返回0，bash将无法执行到检查的代码。你可以使用其他的结构： 123456commandif [ \"$?\"-ne 0]; then echo \"command failed\"; exit 1; fi could be replaced with 能够被代替为 1234567command || &#123; echo \"command failed\"; exit 1; &#125; or或者if ! command; then echo \"command failed\"; exit 1; fi What if you have a command that returns non-zero or you are not interested in its return value? You can use command || true, or if you have a longer section of code, you can turn off the error checking, but I recommend you use this sparingly. 如果你有一个命令返回非0或者你对语句执行的结果不关心，那你可以使用command || true，或者你有一段很长的代码，你可以关闭错误检查（不使用set -e），但是我还是建议你保守地使用这个语句。","tags":[{"name":"set","slug":"set","permalink":"http://yoursite.com/tags/set/"}],"categories":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/categories/linux命令/"}]},{"title":"export命令","date":"2018-07-20T04:07:12.000Z","path":"wiki/linux命令/export命令/","text":"export命令设置或显示环境变量。 Linux export 命令功能说明：设置或显示环境变量。（比如我们要用一个命令，但这个命令的执行文件不在当前目录，这样我们每次用的时候必须指定执行文件的目录，麻烦，在代码中先执行export，这个相当于告诉程序，执行某某东西时，需要的文件或什么东东在这些目录里） 语 法：export [-fnp][变量名称]=[变量设置值] 补充说明：在shell中执行程序时，shell会提供一组环境变量。 export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅及于该此登陆操作。 参 数： -f 代表[变量名称]中为函数名称。 -n 删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 -p 列出所有的shell赋予程序的环境变量。 一个变量创建时，它不会自动地为在它之后创建的shell进程所知。而命令export可以向后面的shell传递变量的值。当一个shell脚本调用并执行时，它不会自动得到原为脚本（调用者）里定义的变量的访问权，除非这些变量已经被显式地设置为可用。export命令可以用于传递一个或多个变量的值到任何后继脚本。 —-《UNIX教程》 在 linux 里设置环境变量的方法 （ export PATH ） 一般来说，配置交叉编译工具链的时候需要指定编译工具的路径，此时就需要设置环境变量。例如我的mips-linux-gcc编译器在“/opt/au1200_rm /build_tools/bin”目录下，build_tools就是我的编译工具，则有如下三种方法来设置环境变量： 1、直接用export命令： #export PATH=$PATH:/opt/au1200_rm/build_tools/bin 查看是否已经设好，可用命令export查看： [root@localhost bin]#export declare -x BASH_ENV=”/root/.bashrc” declare -x G_BROKEN_FILENAMES=”1” declare -x HISTSIZE=”1000” declare -x HOME=”/root” declare -x HOSTNAME=”localhost.localdomain” declare -x INPUTRC=”/etc/inputrc” declare -x LANG=”zh_CN.GB18030” declare -x LANGUAGE=”zh_CN.GB18030:zh_CN.GB2312:zh_CN” declare -x LESSOPEN=”|/usr/bin/lesspipe.sh %s” declare -x LOGNAME=”root” declare -x LS_COLORS=”no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=01;05;37;41:mi=01;05;37;41:ex=01;32:.cmd=01;32:.exe=01;32:.com=01;32:.btm=01;32:.bat=01;32:.sh=01;32:.csh=01;32:.tar=01;31:.tgz=01;31:.arj=01;31:.taz=01;31:.lzh=01;31:.zip=01;31:.z=01;31:.Z=01;31:.gz=01;31:.bz2=01;31:.bz=01;31:.tz=01;31:.rpm=01;31:.cpio=01;31:.jpg=01;35:.gif=01;35:.bmp=01;35:.xbm=01;35:.xpm=01;35:.png=01;35:.tif=01;35:” declare -x MAIL=”/var/spool/mail/root” declare -x OLDPWD=”/opt/au1200_rm/build_tools” declare -x PATH=”/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/root/bin:/opt/au1200_rm/build_tools/bin” declare -x PWD=”/opt/au1200_rm/build_tools/bin” declare -x SHELL=”/bin/bash” declare -x SHLVL=”1” declare -x SSH_ASKPASS=”/usr/libexec/openssh/gnome-ssh-askpass” declare -x SSH_AUTH_SOCK=”/tmp/ssh-XX3LKWhz/agent.4242” declare -x SSH_CLIENT=”10.3.37.152 2236 22” declare -x SSH_CONNECTION=”10.3.37.152 2236 10.3.37.186 22” declare -x SSH_TTY=”/dev/pts/2” declare -x TERM=”linux” declare -x USER=”root” declare -x USERNAME=”root” 可以看到灰色部分有设置的路径，说明环境变量已经设好，PATH里面已经有了我要加的编译器的路径。 2、修改profile文件： #vi /etc/profile 在里面加入: export PATH=”$PATH:/opt/au1200_rm/build_tools/bin” 3. 修改.bashrc文件： # vi /root/.bashrc 在里面加入： export PATH=”$PATH:/opt/au1200_rm/build_tools/bin” 后两种方法一般需要重新注销系统才能生效，最后可以通过echo命令测试一下： # echo $PATH 看看输出里面是不是已经有了 /my_new_path这个路径了。 另有：4. 修改/etc/re.local文件： # vi /etc/re.local 在里面加入： export PATH=”$PATH:/opt/au1200_rm/build_tools/bin” ———————————————————————————————————————– “/bin”、“/sbin”、“ /usr/bin”、“/usr/sbin”、“/usr/local/bin”等路径已经在系统环境变量中了，如果可执行文件在这几个标准位置，在终端命令行输入该软件可执行文件的文件名和参数(如果需要参数)，回车即可。 如果不在标准位置，文件名前面需要加上完整的路径。不过每次都这样跑就太麻烦了，一个“一劳永逸”的办法是把这个路径加入环境变量。命令 export $PATH=”路径”(或“PATH=$PATH:路径”) ($PATH为环境变量名，如DVSDK；调用时用$DVSDK)可以把这个路径加入环境变量，但是退出这个命令行就失效了。要想永久生效，需要把这行添加到环境变量文件里。有两个文件可选：“/etc/profile”和用户主目录下的“.bash_profile”，“/etc/profile”对系统里所有用户都有效，用户主目录下的“.bash_profile”只对这个用户有效。 export $PATH=”$PATH:路径1:路径2:…:路径n” （或“PATH=$PATH:路径1:路径2:…:路径n” ），意思是可执行文件的路径包括原先设定的路径，也包括从“路径1”到“路径n”的所有路径。当用户输入一个一串字符并按回车后，shell会依次在这些路径里找对应的可执行文件并交给系统核心执行。那个“$PATH”表示原先设定的路径仍然有效，注意不要漏掉。某些软件可能还有“PATH”以外类型的环境变量需要添加，但方法与此相同，并且也需要注意“$”。 注意，与DOS/Window不同，UNIX类系统环境变量中路径名用冒号分隔，不是分号。另外，软件越装越多，环境变量越添越多，为了避免造成混乱，建议所有语句都添加在文件结尾，按软件的安装顺序添加。 格式如下()： # 软件名-版本号 PATH=$PATH:路径1:路径 2:…:路径n 其他环境变量=$其他环境变量:… 在“profile”和“.bash_profile”中，“#”是注释符号，写在这里除了视觉分隔外没有任何效果。 设置完毕，注销并重新登录，设置就生效了。如果不注销，直接在shell里执行这些语句，也能生效，但是作用范围只限于执行了这些语句的shell。 相关的环境变量生效后，就不必老跑到软件的可执行文件目录里去操作了。 ———————————————————————————————————————– 执行一个脚本时，会先开启一个子shell环境（不知道执行其它程序是不是这样），然后将父shell中的所有系统环境变量复制过来，这个脚本中的语句就在子shell中执行。（也就是说父shell的环境变量在子shell中可以调用，但反过来就不行，如果在子shell中定义了环境变量，则只对该shell或者它的子shell有效，当该子shell结束时，也可以理解为脚本执行完时，变量消失。）为了证明这一点，请看脚本内容： test=’value’ export test 这样的脚本执行完后，test实际上是不存在的。接着看下面的： test=’value’ export test bash 这里在脚本最后一行再开一个子shell，该shell应该是脚本文件所在shell的子shell，这个脚本执行完后，是可以看到test这个变量的，因为现在是处于它的子shell中，当用exit退出子shell后，test变量消失。 如果用source对脚本进行执行时，如果不加export，就不会在子shell中看到这个变量，因为它还不是一个系统环境变量呀，如脚本内容是： test=’value’ 用source执行后，在shell下是能看到这个变量，但再执行bash开一个子shell时，test是不会被复制到子shell中的，因为执行脚本文件其实也是在一个子shell中运行，所以我再建另一个脚本文件执行时，是不会输入任何东西的，内容如：echo $test。所以这点特别注意了，明明在提示符下可以用echo $test输出变量值，为什么把它放进脚本文件就不行了呢？ 所以得出的结论是：1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；2、一个shell中的系统环境变量才会被复制到子shell中（用export定义的变量）；3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。3、不用export定义的变量只对该shell有效，对子shell也是无效的。 后来根据版主的提示，整理了一下贴子：为什么一个脚本直接执行和用source执行不一行呢？这也是我自己碰到的一个问题。manual原文是这样的：Read and execute commands from filename in the current shell environment and return the exit status of the last command executed from filename.明白了为什么不一样了吧？直接执行一个脚本文件是在一个子shell中运行的，而source则是在当前shell环境中运行的。","tags":[{"name":"export","slug":"export","permalink":"http://yoursite.com/tags/export/"}],"categories":[{"name":"linux命令","slug":"linux命令","permalink":"http://yoursite.com/categories/linux命令/"}]},{"title":"组件化-库","date":"2018-07-20T04:07:12.000Z","path":"wiki/IOS/库/组件化-库/","text":"组件化-动态库实战 iOS开发——创建你自己的Framework iOS - Umbrella Header在framework中的应用 iOS 开发中的『库』(一)","tags":[{"name":"组件化","slug":"组件化","permalink":"http://yoursite.com/tags/组件化/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"库","slug":"IOS/库","permalink":"http://yoursite.com/categories/IOS/库/"}]},{"title":"static关键字作用总结(转载)","date":"2018-07-17T10:07:12.000Z","path":"wiki/C++语言/C++关键字理解/static/","text":"在平时经常会遇到static关键字，有时候不理解为什么使用这个关键字，这里总结了static关键字的作用。 隐藏1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可） 当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。举例来说明。同时编译两个源文件，一个是a.c，另一个是main.c。 123456789101112131415//a.cchar a = 'A'; // global variablevoid msg()&#123; printf(\"Hello\\n\");&#125;//main.cint main()&#123; extern char a; // extern variable must be declared before use printf(\"%c \", a); (void)msg(); return 0;&#125; 程序的运行结果是 1A Hello 为什么在a.c中定义的全局变量a和函数msg能在main.c中使用？前面说过，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。此例中，a是全局变量，msg是函数，并且都没有加static前缀，因此对于另外的源文件main.c是可见的。如果加了static，就会对其它源文件隐藏。例如在a和msg的定义前加上static，main.c就看不到它们了。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏. 内容持久化（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。虽然这种用法不常见 PS：如果作为static局部变量在函数内定义，它的生存期为整个源程序，但是其作用域仍与自动变量相同，只能在定义该变量的函数内使用该变量。退出该函数后， 尽管该变量还继续存在，但不能使用它。 程序举例： 1234567891011121314151617＃include &lt;stdio.h&gt; int fun()&#123; static int count = 10; //在第一次进入这个函数的时候，变量a被初始化为10！并接着自减1，以后每次进入该函数，a return count--; //就不会被再次初始化了，仅进行自减1的操作；在static发明前，要达到同样的功能，则只能使用全局变量： &#125; int count = 1; int main(void)&#123; printf(\"global\\t\\tlocal static\\n\"); for(; count &lt;= 10; ++count) printf(\"%d\\t\\t%d\\n\", count, fun()); return 0;&#125; 程序的运行结果是： 123456789101112131415161718192021global local static1 102 93 84 75 66 57 48 39 210 1 —基于以上两点可以得出一个结论：把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域， 限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。 默认初始化为0其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置0，然后把不是0的几个元素赋值。如果定义成静态的，就省去了一开始置0的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加‘\\0’;太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是‘\\0’;不妨做个小实验验证一下。 1234567891011＃include &lt;stdio.h&gt; int a; int main()&#123; int i; static char str[10]; printf(\"integer: %d; string: (begin)%s(end)\", a, str); return 0;&#125; 程序的运行结果是： 12integer: 0; string: (begin) (end) 最后对static的三条作用做一句话总结。首先static的最主要功能是隐藏，其次因为static变量存放在静态存储区，所以它具备持久性和默认值0. C++中的类成员声明static 在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用： 类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。 不能将静态成员函数定义为虚函数。 由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。 由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过） static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。 静态数据成员在&lt;定义或说明&gt;时前面加关键字static。 静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） 静态成员初始化与一般数据成员初始化不同: 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；初始化时不加该成员的访问权限控制符private，public等；初始化时使用作用域运算符来标明它所属类； 所以我们得出静态数据成员初始化的格式： &lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt; 为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。 转载地址C++中static关键字作用总结","tags":[{"name":"static","slug":"static","permalink":"http://yoursite.com/tags/static/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++关键字理解","slug":"C-语言/C-关键字理解","permalink":"http://yoursite.com/categories/C-语言/C-关键字理解/"}]},{"title":"explicit实例浅析(转载)","date":"2018-07-16T01:07:12.000Z","path":"wiki/C++语言/C++关键字理解/explicit-learn/","text":"在C++程序中很少有人去使用explicit关键字，不可否认，在平时的实践中确实很少能用的上。再说C++的功能强大，往往一个问题可以利用好几种C++特性去解决。但稍微留心一下就会发现现有的MFC库或者C++标准库中的相关类声明中explicit出现的频率是很高的。了解explicit关键字的功能及其使用对于我们阅读使用库是很有帮助的，而且在编写自己的代码时也可以尝试使用。既然C++语言提供这种特性，我想在有些时候这种特性将会非常有用。 初识按默认规定，只用传一个参数的构造函数也定义了一个隐式转换。举个例子：（下面这个CExample没有什么实际的意义，主要是用来说明问题） 123456789101112131415161718192021222324252627282930313233343536373839//Example.h#pragma onceclass CExample&#123;public:CExample(void);public:~CExample(void);public:int m_iFirst;int m_iSecond;public:CExample(int iFirst, int iSecond = 4);&#125;;//Example.cpp#include \"StdAfx.h\"#include \"Example.h\"CExample::CExample(void): m_iFirst(0)&#123;&#125;CExample::~CExample(void)&#123;&#125;CExample::CExample(int iFirst, int iSecond):m_iFirst(iFirst), m_iSecond(iSecond)&#123;&#125;//TestExplicitKey.cpp...//其它头文件#include \"Example.h\"int _tmain(int argc, _TCHAR* argv[])&#123;CExample objOne; //调用没有参数的构造函数CExample objTwo(12, 12); //调用有两个参数的构造函数CExample objThree(12); //同上，可以传一个参数是因为该构造函数的第二个参数有默认值CExample objFour = 12; //执行了隐式转换,等价于CExample temp(12);objFour(temp);注意这个地方调用了//编译器为我们提供的默认复制构造函数return 0;&#125; 如果在构造函数声明中加入关键字explicit，如下 1explicit CExample(int iFirst, int iSecond = 4); 那么CExample objFour = 12; 这条语句将不能通过编译。在vs05下的编译错误提示如下 12error C2440: 'initializing' : cannot convert from 'int' to 'CExample' Constructor for class 'CExample' is declared 'explicit' explicit意义对于某些类型，这一情况非常理想。但在大部分情况中，隐式转换却容易导致错误（不是语法错误，编译器不会报错）。隐式转换总是在我们没有察觉的情况下悄悄发生，除非有心所为，隐式转换常常是我们所不希望发生的。通过将构造函数声明为explicit（显式）的方式可以抑制隐式转换。也就是说，explicit构造函数必须显式调用。引用一下Bjarne Stroustrup的例子: 12345678910111213141516class String&#123; explicit String(int n); String(const char *p);&#125;;String s1 = 'a'; //错误：不能做隐式char-&gt;String转换String s2(10); //可以：调用explicit String(int n);String s3 = String(10);//可以：调用explicit String(int n);再调用默认的复制构造函数String s4 = \"Brian\"; //可以：隐式转换调用String(const char *p);再调用默认的复制构造函数String s5(\"Fawlty\"); //可以：正常调用String(const char *p);void f(String);String g()&#123; f(10); //错误：不能做隐式int-&gt;String转换 f(\"Arthur\"); //可以：隐式转换，等价于f(String(\"Arthur\")); return 10; //同上&#125; 在实际代码中的东西可不像这种故意造出的例子。发生隐式转换，除非有心利用，隐式转换常常带来程序逻辑的错误，而且这种错误一旦发生是很难察觉的。原则上应该在所有的构造函数前加explicit关键字，当你有心利用隐式转换的时候再去解除explicit，这样可以大大减少错误的发生。 原文链接：http://blog.csdn.net/chollima/article/details/3486230","tags":[{"name":"explicit","slug":"explicit","permalink":"http://yoursite.com/tags/explicit/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++关键字理解","slug":"C-语言/C-关键字理解","permalink":"http://yoursite.com/categories/C-语言/C-关键字理解/"}]},{"title":"重载运算与类型转换","date":"2018-07-13T09:07:12.000Z","path":"wiki/C++语言/C++Primer/第十四章/重载运算与类型转换/","text":"基本概念 输入输出运算符 算术和关系运算符 赋值运算符 下标运算符 递增和递减运算符 成员访问运算符 函数调用运算符 重载、类型转换、运算符 当运算符被用于类类型时，C++语言允许为其指定新的含义。同时我们能自定义类类型之间的转化规则。 基本概念重载运算符是具有特殊名字的函数：他们的名字由关键字operator和其后要定义的运算符共同组成。和其他函数一样，重载运算符也包含返回类型、参数列表、以及函数体。除了重载的函数调用运算符operator()之外，其他的重载运算符不能还有默认实参。 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的this指针上，因此，成员运算符函数的显示参数数量比运算符的运算对象少一个。 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。 直接调用一个重载的运算符函数12345data1+data2;operator+(data1,data2); ///非成员函数data1+=data2;data1.operator+=(data2) ///成员运算符函数的直接调用 某些运算符不能被重载某些运算符定义了求值顺序，因为重载的运算符本质上是函数调用，所以不能应用求值顺序的规则，所以这些运算符不能被重载。例如逻辑与，逻辑或的短路求值顺序。 逗号表达式和取地址运算符也不能被重载，因为已经定义了作用域类类型的含义。 使用内置类型一致的含义只有当操作的含义对用户来说，清晰明了了时才使用运算符。 赋值和符合赋值运算符有算法运算符或者位运算符，则最后提供赋值运算符 选择作为成员或者非成员 赋值、下标、调用、成员访问必须是成员函数 改变对象状态的运算符或者密切相关的运算符，如递增、递减、解引用，通常定义为成员 具有对称的运算符可能转化为任意一端的运算符对象，如算术、相等、关系和位运算符 通常应该定义为非成员函数。 如果我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。 输入和输出运算符通常情况下，输出运算符的第一个形参是一个非常量ostream对象引用，之所以ostream是非非常，因为向流写入内容会改变流的状态。而形参是引用是因为我们无法直接复制一个一个ostream对象。 第二个形参一般是一个常量引用，引用避免复制，常量表示不修改对象 1234ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)&#123; return os;&#125; 输出输入运算符必须是非成员函数。 重载输入运算符 1234istream &amp; operator&gt;&gt;(istream&amp; is, Salses_data)&#123; return is;&#125; 算术和关系运算符通常情况下，我们把算术和关系运算符定义为非成员函数以允许左侧和右侧的运算对象进行转换。因为这些运算对象一般不需要改变运算对象的状态，所以形参都是常量引用 如果类同时定义了算法运算符和相关的复合赋值运算符，则，通常情况下应该使用复合赋值来实现算术运算符。 相等运算符12345678910111213///加法运算符Sales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; Sales_data sum = lhs; sum+= rhs; return sum;&#125;///相等运算符bool operater==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.units_sold == rhs.units.sold;&#125; 相等运算符和不等运算符中的一个应该把工作委托给另外一个。 关系运算符如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类以&lt;运算符。如果累同时还包含==，则当且仅当&lt; 的定义和==阐述的结果一直时，才定义&lt; 运算符。 赋值运算符 拷贝赋值 移动赋值 初始值列表赋值 12345678910v = &#123;\"a\",\"an\",\"the\"&#125;;StrVec &amp; operator=(initializer_list&lt;string&gt; il)&#123; auto data = alloc_n_copy(il.begin(),il.end()); free(); elemests = data.first; fisrs_free = cap = data.second; return *this;&#125; 复合赋值运算符赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做，这两类运算符都应该返回左侧运算对象的引用。 下标运算符下标运算符必须定义成成员函数，下标运算符通常以访问元素的引用作为返回值，这样的好处是下标运算符可以出现在赋值运算符的任意一端。 如果一个类包含下标运算符符，则通常会定义两个版本，一个返回普通引用，另一个是类的常量成员，并返回常量引用。 123456789std::string&amp;&amp; operator[](std::size_t n)&#123; return elements[n];&#125;const std::string&amp;&amp; operator[](std::size_t n) const&#123; return elements[n];&#125; 递增和递减运算符递增和递减运算符改变所操作对象的状态，所以建议将其定义为成员函数。 123456789101112131415/// 前置递增版本StrBolbPtr &amp; StrBlobPtr::operator++()&#123; check(curr,\"increment past end of StrBlobPtr\"); ++cur; return *this;&#125;///后置版本StrBolbPtr &amp; StrBlobPtr::operator++(int)&#123; StrBolbPtr ret = *this; ++*this; return ret;&#125; 为了区分前置和后置版本，后置运算符接受一个额外的（不被使用的）int类型参数。后置版本调用了前置版本运算符。 成员访问运算符 解引用运算符 * 箭头运算符 -&gt; 12345678910std::string&amp; operator*() const&#123; auto p = check(curr,\"\"); return (*p)[curr];&#125;std::string* operator*() const&#123; return &amp;this-&gt;operator*();&#125; 箭头运算符必须是类的成员。解引用通常也是类的成员。 函数调用运算符如果一个类重载了函数调用运算符，则我们可以像使用函数一样使用该类对象。因为这样的类能存储状态，所以比普通函数相比，更加灵活。 函数调用运算符必须是成员函数。一个类可以定义多个版本的调用运算符，相互之间应该在参数数量或类型上有所区别。 如果类定义了调用运算符，则该类对象称为函数对象（function object） 函数对象常常作为泛型算法的实参。 lambda是函数对象当我们编写一个lambda后，编译器将表达式翻译成一个未命名的对象。 123456789101112stable_sort(words.begin(), words.end(),[](const string &amp;a, const string &amp;b))&#123;return a.size()&lt;b.size();&#125;);class ShorterString&#123; public: bool operator(const string &amp;s1, const string &amp;s2) const &#123; return s1.size()&lt;s2.size(); &#125;&#125;stable_sort(words.begin(), words.end(),ShorterString()); 默认情况下，lambda不能改变捕获的变量。因此默认情况下，由lambda产生的类当中的函数调用运算符是一个const成员函数。 如果lambda是可变的，则调用运算符就不是const的了 表示lambda及相应捕获行为的类当一个lambda表达式通过引用捕获变量时，将由程序负责确保lambda执行时引用所引用的对象确实存在。通过值捕获的变量，必须为类建立对应的数据成员。同时创建构造函数。 lambda表达式产生的类不含有默认构造函数、赋值运算符、默认析构函数。 标准库定义的函数对象 plus类定义了一个函数调用运算符用于对运算对象执行+操作 modules类定义了一个调用运算符执行二元的%操作 equal_to类执行== 算术 plus&lt;Type&gt; minus&lt;Type&gt; multiplies&lt;Type&gt; divides&lt;Type&gt; modulus&lt;Type&gt; negate&lt;Type&gt; 关系 qual_to&lt;Type&gt; no_equal_to&lt;Type&gt; greater&lt;Type&gt; greater_equal&lt;Type&gt; less&lt;Type&gt; less_qual&lt;Type&gt; 逻辑 logic_and&lt;Type&gt; logic_or&lt;Type&gt; logic_not&lt;Type&gt; 在算法中使用标准函数对象表示运算符的函数对象通常用来替换算法中的默认运算符。 可调用对象和function可调用对象： 函数 函数指针 lambda表达式 bind创建的对象 重载了调用运算符符的类 不同类型可能具有相同的调用形式调用形式指明了调用返回的类型以及传递给调用的类型参数。 lambda表达式有他自己的类型，虽然调用形式一样，但是类型不同。 标准库function类型 function的操作 说明 function f f是一个用来存储可调用对象的空function，这些可调用对象的调用形式应该与函数类型T相同 T是returntype(args) function f(nullptr) 显示的构造一个空function function(obj) f中存储可调用对象obj的副本 f 将f作为条件，当f包含一个可调用对象是为真，否则为假 f(args) 调用f中的对象，参数是args 定义为function的成员类型 result_type argument_type first_argument_type second_argument_type 重载、类型转换、运算符由一个实参调用的非显式构造函数定义了一种隐式类型转换，这种构造函数将实参类型的对象转换为类类型。我们同样能定义对于类类型的类型转换，通过定义类型转换运算符可以做到这一点。转换构造函数和类型转换运算符共同定义了类型转换。 类型转换运算符1234operator type() const&#123; return val;&#125; 一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空，类型转换函数通常应该const。 类型转换运算符可能产生意外结果对于类来说，定义向bool的类型转换还是比较普遍的现象。 显示类型转换12345explicit operator int() const &#123; return val;&#125;static_cast&lt;int&gt;(si) + 3; 当表达式出现在下列位置时，显示的类型转化将被隐式的执行： if、for、do 语句的条件 for语句的条件表达式 逻辑非、逻辑或、逻辑与的运算对象 条件运算符 转化为bool向bool的类型转换通常用在条件部分，因此operator bool 一般定义成exlicit的。 避免有二义性的类型转换如果类中有一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式，否则的话，我们编写的代码将很可能具有二义性。 例如A接受B的构造函数 B定义了一个转换目标是A的转化运算符 对于某个给定的类来说，最好只定义最多一个算术类型相关的转化规则。 如果两个或多个类型转换提供了同一种可行匹配，则这些类型转换一样好。 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型时才有用，如果所需的用户类型不止一个，则该调用具有二义性。 函数匹配和重载运算符在表达式运算符的候选函数既应该包括成员函数，也应该包括成员函数。 普通的函数就不需要这样，因为他们的调用形式不同。","tags":[{"name":"重载运算与类型转换","slug":"重载运算与类型转换","permalink":"http://yoursite.com/tags/重载运算与类型转换/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十四章","slug":"C-语言/C-Primer/第十四章","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十四章/"}]},{"title":"函数","date":"2018-07-13T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第六章函数/函数/","text":"主要内容： 函数基础 参数传递 函数类型和return语句 函数重载 特殊用途语言特性 函数匹配 函数指针 函数是一个命名了的代码块，我们通过调用函数执行响应的代码。 函数基础函数的组成部分： 返回类型 函数名字 形参列表 函数体 我们通过调用运算符来执行函数，调用运算符的形式是一对圆括号。 函数调用完成的工作： 用实参初始化函数对应的形参 将控制权转移给被调函数，此时主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行 return语句完成的工作： 返回return语句中的值 将控制权从被调函数转移回主调函数。 函数的形参：即使两个形参的类型一样，也必须把两个类型都写出来。任何两个形参都不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。 函数返回类型：函数的返回类型不能是数组类型、函数类型，但是可以是指向数组或者函数的指针。为啥？ 局部对象名字有作用域，对象有生命周期。 名字的作用域是程序文本的一部分，名字在其中可见 对象的生命周期是程序执行过程中该对象存在的一段时间 形参和函数体内部定义的变量统称为局部变量。局部变量会隐藏在外层作用域中同名的其他所有声明。 在所有函数体之外定义的对象，存在于程序的整个过程中，此类对象在程序启动的时候被创建，直到程序结束才会销毁。 自动对象:当函数的控制路径经过变量定义语句时，创建该对象，当达到定义语句所在的快末尾时销毁，我们把只存在于快执行期间的对象称为自动对象。 形参是自动变量，函数开始执行时为形参申请空间，因为形参定义在函数作用域内，所以一旦函数终止，形参就被销毁。 局部静态对象：生命周期贯穿函数调用及之后的时间，在程序执行路径第一次经过对象的定义语句时初始化对象。并且直到程序终止才被销毁。 如果局部静态变量没有显示的初始化，执行值初始化，内置类型的局部静态变量初始化为0. 函数声明函数的声明不包括函数体，所以他无需形参名字。 参数传递 引用传递：引用形参是他对象实参的别名 值传递：值拷贝，形参和实参是两个相互独立的对象 传值参数当初始化一个非引用类型的变量时，初始值被拷贝给变量。对变量的改动不会影响初始值。 指针形参：指针的行为和其他非引用类型一样，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。因为指针使我们可以间接的访问他所指的对象，所以通过指针可以修改它所指对象的值。 传引用参数对引用的操作实际上是作用在引用所引用对象上。 优点吧： 使用引用避免拷贝：拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本不支持拷贝操作，当某种类型不支持拷贝操作时，函数只能通过引用参数访问该类型对象。 使用引用形参返回额外信息。 const形参和实参当形参有顶层const时，传给它常量或非常量对象都可以。 我们可以使用非常量初始化一个底层const对象。C++允许字面值初始化常量引用。 常量引用接收的实参范围大，可以接收非常量、常量、字面值、需要类型转换的对象。 数组形参数组的特点： 内置类型。 不允许拷贝，所以不能以值传递方式使用数组。 使用数组时，大部分情况会转换为指向数组首元素的指针。 管理指针形参，标记数组的大小： 使用标记指定数组的大小，就是数组本身包含一个结束标记，典型的例子是C风格的字符串 使用标准库，需要传入两个指针，一个指向数组首元素，另一个指向尾元素的下一个位置。 显示传递一个表示数组大小的形参 数组引用形参：引用绑定到数组实参上。纬度也是类型的一部分，但是这样限制只能传递数组大小为10 的实参，函数模板可以实现传递任何大小的数组。 传递多维数组： 数组真正传递的是首元素的地址，因为，多维数组时数组的数组，所以首元素本身是一个数组，就是指向数组的指针，可以想象，数组的第二纬的大小是数组类型的一部分。 1int (*matrix)[10] ; //第二个纬度是类型的一部分。 main：处理命令行选项argv中的可选实参从argv[1]开始，argv[0]保存程序的名字，而非用户的输入。 含有可变形参的函数可变参数的的实现方式： 传递initializer——list标准库类型，所有实参类型相同 可变参数模板，参数类型不同 特殊的形参类型——省略号，一般用于和C交互的程序 initializer_list实参数量未知，类型相同。 initializer_list提供的操作 说明 initializer_list&lt;T&gt; lst; 默认初始化，T类型元素的空列表 initializer_list&lt;T&gt; lst{a,b,c...} list2 = list lst的元素数量和初始值一样多，lst元素是对应初始值的副本，列表中的元素是const lst2(lst) 拷贝或者赋值一个initializer_list对象，不会拷贝列表中的元素，拷贝后，原始列表和副本共享元素 list.size() 列表中元素数量 list.begin() list中首元素指针 list.end() list中尾元素下一个位置 如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一个或括号中。 省略符形参省略符形参是为了便于C++程序访问某些特殊的C代码设置的。这些代码使用名为varargs的C标准库。大多数类类型对象在传递给省略符形参时，都无法正确拷贝。省略符形参只能出现在形参列表的最后一个位置。省略符形参对应的实参无需进行类型检查。省略符前面的逗号可以省略。 返回类型和return语句无返回值函数返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐式的执行return。。 强行令void函数返回其他类型的表达式将产生编译错误。 有返回值的函数return语句的返回值类型必须与函数的返回类型形同，或者可以隐式转换。 值是如何被返回的返回一个值，和初始化一个变量或者形参的方式完全一样。 不要返回局部对象的指针或者引用因为局部对象释放了，引用或者指针无效 返回类类型的函数和调用运算符为啥点运算符和箭头运算符、调用运算符优先级形同呢？如果调用一个函数，返回一个对象，我么可以直接通过点运算符访问对象的属性。他们是左结合律 引用返回左值我们能为返回类型是非常量引用的函数的结果赋值。就是把函数调用放在赋值语句的左侧。 列表初始化返回值主函数main的返回值main可以不写返回值，编译器帮插入 返回数组指针因为数组不能拷贝，所以函数不能返回数组，不过函数可以返回数组的指针或者引用。 12typedef int arrT[10];using arrT = int[10]; //arrT是是一个类型别名，表示类型是10个整数的数组。 基本形式]、示例： ``type (*function(parameter_list))[demension] int (*func(int i))[10];123456789理解的方式：1. func(int i) 表示条用func函数时需要一个int类型的实参2. (* func(int i)) 意味着我们可以对函数调用的结果执行解引用操作3. (* func(int i))[10] 表示解引用func的调用将得到一个大小是10的数组4. int (*func(int i))[10] 表示数组中的元素类型是int类型使用尾置返回类型： C++新标准中可以还有一种简化上述func声明的方法，就是使用位置返回类型。任何函数定义都能使用位置返回，位置返回类型跟在新参列表后面，并以-&gt;开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto。 auto func(int i) -&gt; int(*)[10];123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657使用decltype： 如果我们知道函数返回的指针指向哪个数组，就可以使用decltype关键字声明返回类型。decltype并不负责把数组类型转换为对应的指针。所以decltype的结果是数组。## 函数重载对于重载的函数来说，他们应该在形参数量或形参类型上有所不同。返回类型不能当做重载的判断依据。重载和const：顶层const不构成重载。底层const构成重载const_cast和重载：const_cast在重载函数的场景最有用。### 重载与作用域如果在内存作用域中声明名字，他将隐藏外层作用域中声明的同名实体。在不同的作用域无法重载函数名。在C++中，名字查找发生在类型检查之前## 特殊用途语言特殊### 默认实参某些函数有这样一种形参，在函数的很多次调用中，他们都被赋予一个相同的值。此时，我们吧这个反复出现的值称为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略改实参。默认实参作为形参的初始值出现在形参列表中，我们可以为一个或多个形参定义默认值，不过注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。函数调用时，实参按位置解析，默认实参负责填补函数调用缺少的尾部实参。当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面。而让那些经常使用默认值的形参出现在后面。#### 默认实参声明对于函数的声明，通常的习惯是将其放在头文件中，并且一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点注意：在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参。而且该形参的右侧的所有形参必须有默认值。通常，应该在函数声明中指定默认实参，并将声明放在合适的头文件中。默认实参的初始值：用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程烦死在函数调用时。### 内联函数 和constexpr函数内联函数可以避免函数调用的开销： 通常在调用点内联的展开。在函数的返回类型前面加上关键字inline，可以将函数声明为内联的。内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。一般来说：内联机制用于优化规模较小、流程直接、频繁调用的函数。constexpr函数：是指 能用于常量表达式的函数。需要满足两个条件1. 函数的返回类型和所有形参类型都是字面值类型2. 函数体内必须有且只有一条return语句。为了能在编译过程中随时展开，constexpr函数被隐式的指定为内联函数。constexpr函数不一定返回常量表达式。由编译器确定是不是常量。### 调试帮组#### assert预处理宏 assert(expr)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455首先对expr求值，如果表达式的值为假（0），assert输出信息并终止程序执行，如果表达式为真，assert什么页不做。预处理名字由预处理器而非编译器管理，所以使用assert无需使用using声明。宏名字在程序内必须唯一。#### NDEBUG 预处理变量assert的行为依赖于一个名为NDEUBG的预处理变量的状态。如果定义了NDEBUG，则assert什么页不做。除了C++编译器定义的__func__之外，预处理器还定义了另外4个对于程序调试很有用的名字。1. `__FILE__` 存放文件名的字符串字面值2. `__LINE__ `存放当前行号的整形字面值3. `__TIME__` 存放文件编译时间的字符串字面值4. `__DATW__ `存放文件编译日志的字符串字面值。## 函数匹配### 确定候选函数、可行函数函数匹配的第一步是选定本次调用对象的重载函数集，集合中的函数称为候选函数（candidate function）。候选函数具备两个特征：1. 于被调用函数同名2. 其声明在调用点可见第二步：考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数（viable function）。可行函数的特征1. 其形参数量与本次调用提供的实参数量相等2. 每个实参的类型与对象的形参类型相同或者能转化为形参类型。第三步： 寻找最佳匹配最佳的条件：1. 该函数每个实参的匹配都不劣于其他可行函数的匹配2. 至少有一个实参的匹配优于其他可行函数提供的匹配。### 实参类型转换编译器将实参类型到形参类型的转化划分为几个等级：具体的排序如下：1. 精确匹配： 类型完全相同、实参从数组类型或函数类型转换成对应的指针类型、向实参类型添加顶层const或者从实参中删除顶层const2. 通过const转化实现的匹配3. 通过类型提升实现的匹配4. 通过算术类型转换实现的匹配5. 通过类类型转换实现的匹配### 函数匹配和const实参如果两个函数的唯一区别是他的指针形参指向常量或者非常量。则编译器通过实参是否常量来决定需用那个函数。如果实参是指向常量的指针，调用形参是const*的函数。否则，调用普通版本函数。## 函数指针函数指针指向的是函数，而非对象，和其他指针一样，函数指针指向某种特定的类型。函数的类型是由它的返回类型和形参类型共同决定的。于函数名无关。要想声明一个可以指向函数的指针，只需要用指针代替函数名即可： bool (*pf)(const string&amp;, const string &amp;);12当我们把函数名当一个值使用时，函数自动的转化为指针。我们还可以直接使用函数指针调用改函数，无需提前解引用指针。不同函数类型的指针间不存在类型转换 pf = lengthCompara;pf = &amp; lengthCompara; //等价的赋值语句1234567重载函数的指针：指针类型必须与重载函数中的某一个精确匹配。函数指针形参：虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。形参如果是函数类型，会自动转化为函数指针类型。decltype作用于函数，只返回函数类型，如果需要函数指针，需要单加*返回指向函数的指针：和数组类型，不能返回一个函数，但能返回指向函数类型的指针，我们必须把返回类型写成指针形式，编译器不会自动将函数类型转换为指针类型 typedef bool Func(const string&amp;, const string &amp;); //函数类型using Func = bool(const string&amp;, const string &amp;) //函数类型 typedef bool (Func1)(const string&amp;, const string &amp;); //函数指针类型using Func1 = bool()(const string&amp;, const string &amp;) //函数指针类型12 int (f1(int))( int , int)``` f1 有形参列表，所以f1是个函数，f1前面有个* 所以f1 返回一个指针 指针的类型本身也包含了形参列表。因此，指针直线函数 改函数的返回类型是int","tags":[{"name":"函数","slug":"函数","permalink":"http://yoursite.com/tags/函数/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第六章函数","slug":"C-语言/C-Primer/第六章函数","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第六章函数/"}]},{"title":"拷贝控制","date":"2018-07-13T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第十三章/拷贝控制/","text":"拷贝、赋值、销毁 拷贝控制和资源管理 交换操作 拷贝控制示例 动态内存管理 对象移动 我们将学到：拷贝、赋值、移动、销毁做什么？下面是拷贝操作的几个函数： 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数 函数类–初始化：拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么运算符类—赋值：拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象是做什么。 如果一个类没有定义所有的拷贝控制成员，编译器会自动定义缺失的操作。 拷贝、赋值、销毁拷贝构造函数如果一个函数的第一个参数是自身类型的引用，且任何额为的参数都有默认值，则，此构造函数是拷贝构造函数。 12345class Foo&#123; plublic: Foo(canst Foo&amp;); // 拷贝构造函数&#125;; 合成拷贝构造函数如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。这个拷贝构造函数称为合成拷贝构造函数。合成的拷贝构造函数会将其参数逐个拷贝到正在创建的对象中。除了静态成员。 合成拷贝构造函数如何拷贝： 类类型：使用其拷贝构造函数来拷贝 内置类型：直接拷贝 数组：逐个拷贝数组成员 例子： 12345Sales_data::Sales_data(const Sales_data&amp; orig):bookNO(orig.bookNO),units_sold(orig.units_sold),revenue(orig.revenue)&#123;&#125; 拷贝初始化示例： 12345string dots(10,'.'); ///直接初始化string s(dots); ///直接初始化string s2 = dots; ///拷贝初始化string null_book = \"999999-999\" ///拷贝初始化string nines = string(100,'9'); ///拷贝初始化 直接初始化：我们实际上要求编译器用普通的函数匹配，来选择与我们提供的参数最匹配的构造函数。 拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话，还进行类型转换。 ，拷贝初始化是通过拷贝构造函数或者移动构造函数完成的。拷贝初始化发生的场景： 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 insert 、push（emplace 直接初始化） 使用=定义变量 参数和返回值当一个函数具有非引用的返回值类型时，返回值会被用来初始化调用方的结果。为什么拷贝构造函数的参数必须是引用： 如果参数不是引用类型，则调用永远不能成功—为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数。如此无限循环。 拷贝初始化的限制如果我们的初始值要求通过一个explicit的构造函数来进行类型转换，那么使用拷贝初始化和拷贝初始化就有区别了 12vector&lt;int&gt; v1(10); ///正确，直接初始化vector&lt;int&gt; v2 = 10; 错误，接受大小数的构造函数是explicit的。 拷贝赋值运算符与类控制其对象如何初始化一样，类也可以控制其对象如何赋值。 赋值运算符就是一个名为opertor =的函数，类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式this参数。 1Foo&amp; operator=(const Foo &amp;); 赋值运算符通常应该返回一个指向其左侧运算对象的引用。 1234567Sales_data&amp; Sales_data::operator=(const Sales_data &amp;rhs)&#123; booNO = rhs.bookNO; units_sold = rhs.units_sold; revenue = rhs.revenue; return *this;&#125; 析构函数 构造函数初始化对象的非static数据成员。 析构函数释放对象使用的资源，并销毁对象的非静态成员。 析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，不接受参数。，所以不能重载，对于给定的类，只会有唯一一个析构函数。 1~Foo(); 在构造函数中，成员的初始化是在函数体执行前完成的，且按照他们在类中出现的顺序进行初始化。 在析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。 隐式销毁一个内置指针类型的成员不会delete它所指向的对象。智能指针是类类型，所以具有析构函数，所以销毁的时候会销毁其指向的对象。 什么时候会调用析构函数： 变量在离开其作用域时 对象被销毁，其成员被销毁 容器被销毁，其成员被销毁 动态分配的对象，delete 运算符时会被销毁 对于临时对象，当创建他的完整表达式结束时被销毁 析构函数自身并不直接销毁成员，成员实在析构函数体之后隐含的析构阶段中被销毁的 三五法则 需要析构函数的类也需要拷贝和赋值。 需要拷贝操作的类也需要赋值操作。 使用=default可以通过将拷贝控制成员定义为=default来显示的要求编译器生产合成的版本。合成函数将隐式的声明为内联的，如果不希望合成的成员函数是内联函数，应该只对成员的类外定义使用=default。 我们只能对具有合成版本的成员函数函数使用=default。 阻止拷贝应用场景：iostream类阻止了拷贝，以避免多个对象写入或读取相同的io缓存。 定义删除的函数我们可以将拷贝构造函数和拷贝赋值运算符定义为删除的函数，来阻止拷贝。删除函数是这样一种函数：我们虽然声明了他们，单不能以任何方式使用他们。在函数的参数列表后面加上=delete来指出我们希望将它定义为删除的函数。 =default 、=delete区别： =delete必须在函数第一次声明的时候。=default直到编译器生产代码的时候才需要。 可以对任何函数指定=delete，只能对编译器可以合成的默认构造函数或者拷贝控制成员使用=default。 析构函数不能是删除的析构函数不能是删除的，如果析构函数被删除了，就无法消化此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或者创建该类的临时变量。如果一个类的某个成员的类型删除了析构函数，我们不能定义该类的变量或者临时对象。因为如果一个成员的析构函数是删除的，则改成员无法被销毁，而如果一个成员无法被销毁，则对象整体也就无法被销毁了。 对于析构函数已删除的类型，不能定义改类型的变量或释放指向改类型动态分配对象的指针。 对于删除了析构函数的类型，虽然不能定义这种类型的变量或者成员，但可以动态分配这种类型的对象。但是不能释放这些对象。 合成的拷贝成员可能是删除的： 析构函数：如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的 拷贝构造函数：如果类的某个成员的拷贝构造函数是删除的或者不可访问的，则类的合成拷贝构造函数被定义为删除的，如果类的某个成员的析构函数是删除的或者不可访问的，则类合成的拷贝构造函数也被定义为删除的。 拷贝赋值运算符：如果类的某个成员的拷贝赋值运算符是删除的，或者不可访问的，或类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。 构造函数：如果类的某个成员的析构函数是删除的或者不可访问的，或类有一个引用成员，他没有类内初始化器，或是类有一个const成员，它没有类内初始化器且类未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。 如果一个类有数据成员不能默认构造、拷贝、赋值、销毁。则对应的成员函数将被定义为删除的。 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。原因是：如果没有这条规则，我们可能创建出无法销毁的对象。 对于据用引用成员或者无法默认构造的const成员的类。编译器不会为其合成默认构造函数。如果一个类有const成员，则他不能使用合成的拷贝赋值运算符，毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。这种行为看起来不是我们期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。 private控制就版本使用private来阻止拷贝。 拷贝控制和资源管理管理类外资源的类必须定义拷贝控制函数。 类值拷贝：意味着类有自己的状态。当我们拷贝一个像值的对象时，副本和原对象完全独立的，改变副本不会对原对象有任何印象。 类指针拷贝：副本和原对象使用相同的底层数据，改变副本也会改变原对象。 行为像值的类赋值运算符通常组合了析构函数和构造函数的操作： 类型析构函数，赋值操作会销毁左侧运算对象的资源。 类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。 12345678HasPtr&amp; HasPtr::operator=(const HasPtr &amp;rhs)&#123; auto newp = new string(*rhs.ps); //拷贝底层String delete ps; //是否旧内存 ps = newp; i=rhs.i; return *this; //返回本对象&#125; 对于一个赋值运算符来说，正确工作非常重要的，即使将一个对象赋予它自身，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。 定义行为像指针的类引用计数的工作方式： 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1。 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝析构函数递增共享的计数器。指出给定对象的状态又被一个新用户共享。 析构函数递减计数器。指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态。 拷贝赋值运算符递增右侧运算对象的计算器。递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。 简洁版： 除了拷贝构造函数外，其他的构造函数创建引用计数器，为1 拷贝构造函数–拷贝计数器，并递增引用计数器 析构函数递减引用计数器，为0，释放 拷贝赋值运算符– 递减左侧，递增右侧 交换操作如果一个类定义了自己的swap，那么算法将使用类自定义版本，否则算法将使用标准定义的swap。 swap函数应该调用swap，而不是std::swap在赋值运算符中使用swap拷贝控制示例虽然通常来说分配资源的类需要拷贝控制，但资源管理并不是一个类需要定义自己拷贝控制成员的唯一原因。一些类也需要拷贝控制成员的帮助来进行其他操作。 动态内存管理类对象移动标准容器、string、shared_ptr即支持移动，也支持拷贝；IO类和unique_ptr可以移动，不能拷贝。 右值引用右值引用：就是必须绑定到右值的引用，通过&amp;&amp;获取右值引用。右值引用有一个重要的特性—只能绑定到将要销毁的对象。因此，我们可以自由的将一个右值引用的资源移动到另一个对象。 一个左值表达式表示一个对象的身份，一个右值表达式表示的是对象的值。 左值持久；右值短暂 所引用的对象将要销毁 该对象没有其他用户 上面的特性意味着：使用右值引用可以自由的接管所引用的对象的资源。 右值引用指向将要销毁的对象，因此，我们可以从绑定到右值引用的对象窃取状态。 ###变量是左值 变量表达式是左值，带来的结果是，我们不能将右值引用绑定一个右值引用类型的变量上 12int &amp;&amp; rr1 = 42;int &amp;&amp;rr2 = rr1; //错误，表达式rr1是左值 变量时左值，因为变量时持久的，知道离开作用域才被销毁。 变量时左值，因此，我们不能将一个右值引用绑定到一个变量上，即使这个变量时右值引用类型也不行。 标准库move函数虽然不能将一个右值引用绑定到左值上，但我们可以显示的将一个左值转化为对应的右值引用类型。我们可以通过调用一个名为move的新标准函数来获得绑定到左值上的右值引用。 调用move意味着承诺：除了对rr1赋值或销毁外，我们不再使用它。在调用move后，我们不能对移后源对象的值做任何的假设。 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 移动构造函数和移动赋值运算符移动构造函数和移动赋值运算符类似拷贝操作，但他们从给定对象窃取资源，而不是拷贝资源。 类似拷贝构造函数，移动构造函数的第一个参数是该类型的一个引用，不同于拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用，与拷贝构造函数一样，任何额为的参数必须有默认实参。 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一种状态—销毁它是无害的。一旦资源完成移动，对象就不再指向被移动的资源。—-这些资源的所有权已经归属新创建的对象。 1234StrVec::StrVec(StrVec &amp;&amp;s)noexcept :elments(s.elements),first_free(s.first_free),cpa(s.cap)&#123; s.elements=s.first_free=s.cap=nullptr;&#125; 移动操作、标准容器和异常我们必须在头文件的声明和定义中都指定noexcept。 移动赋值运算符移动赋值运算符执行与析构函数和移动构造函数相同的工作。 12345678910111213StrVec::StrVec::operator=(StrVec &amp;&amp; rhs) noexcept&#123; if(this != rhs) &#123; free(); elements = rhs.elements; first_free = rhs.first_free; cap = rhs.cap; rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125; return *this;&#125; 处理了自赋值的情况。判断是否是this，我们不能再使用右侧对象的资源之前就释放左侧运算对象的资源。 移动对象必须可析构除了将移后源对象置位析构安全的状态之外，移动操作还必须保证对象任然是有效状态。一般来说，对象有效是指可以安全的为其赋值，或者可以安全的使用，而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何期望。 合成的移动操作如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符、析构函数，编译器就不会为他们合成移动构造函数和移动赋值运算符。 只有一个类没有定义任何版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才为它合成移动构造函数和移动拷贝赋值运算符。与拷贝操作不同，移动操作永远不会隐式的定义为删除函数，但是如果我们现实的要求编译器生产=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除函数。 与拷贝构造函数不同，移动构造函数被定义为删除函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数或者是有类成员未定义自己的拷贝构造函数，且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。 如果类成员的移动构造函数或移动赋值运算符被定义为删除的或者不可访问的，则类的移动构造函数或者移动赋值运算符被定义为删除的 类似拷贝构造函数，如果了类的析构函数定义为删除的或不可访问的，则类的移动构造函数被定义为删除的 类似拷贝赋值运算符，如果类成员是const或引用，则类的移动赋值运算符被定义为删除的。 如果一个类定义了移动构造函数和移动赋值运算符，则类的合成拷贝构造函数和拷贝赋值运算符被定义为删除的。 移动右值，拷贝左值如果没有移动构造函数，右值也被拷贝移动迭代器移动迭代器解引用生成右值引用，我么通过标准库的make_move_iterator函数将普通迭代器转换为移动迭代器。次函数接受一个迭代器参数，返回一个移动迭代器。 右值引用和成员函数我们指出this的左值、右值属性的方式与定义const成员函数相同，即，在参数表后面防止一个引用限定符 1Foo &amp; operator=(const Foo&amp;) &amp;; 引用限定符必须同时出现在函数的声明和定义中。 重载和引用函数就像一个成员函数可以根据是否是const来区分其重载版本，引用限定符也可以区分重载版本。","tags":[{"name":"拷贝控制","slug":"拷贝控制","permalink":"http://yoursite.com/tags/拷贝控制/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十三章","slug":"C-语言/C-Primer/第十三章","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十三章/"}]},{"title":"面向对象程序设计","date":"2018-07-13T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/","text":"OOP概述 定义基类和派生类 虚函数 抽象基类 访问控制和继承 继承中的类作用域 构造函数和拷贝控制 容器与继承 文本查询程序 面向对象程序设计的基本概念： 数据抽象 继承 动态绑定 OOP 概述面向对象程序设计（object oriened programming）的核心思想是数据抽象、继承、动态绑定。通过使用数据抽象，我们可以将接口和实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定程度上忽略类型的区别，而以统一的方式使用它们的对象。 继承基类负责定义层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。 基类将类型相关的函数声明为虚函数。 派生类通过使用派生列表明确指出它是从哪个基类继承而来的。每个基类前面可以有访问说明符。 动态绑定函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有事又称为运行时绑定（runtime binding）。 在C++语言中，当我们使用基类的指针或者引用调用一个虚函数时将发生动态绑定。 定义基类和派生类定义基类基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也该如此。 成员函数与继承派生类可以继承其基类的成员，然而遇到与类型相关的操作时，派生类必须对其重新定义。换句话说：派生类需要对这些操作提供自己的新定义以覆盖（override）从基类继承而来的旧定义。 任何构造函数之外的非静态函数都可以是虚函数。关键字virtual只能出现字类内部声明语句之前，而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式的也是虚函数。 访问控制基类希望它的派生类有权限访问该成员，同时禁止其他用户访问，我们用受保护的访问说明符来说明这样的成员。 定义派生类派生类将其基类继承而来的成员函数中需要覆盖的那些重新声明。 在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。 因为在派生类对象中，含有基类部分，所以我们能把派生类的对象当成基类对象使用。而且我们也能将基类的指针和引用绑定到派生类对象中的基类部分上。这种转化通常称为派生类到基类的类型转换。 派生类构造函数 尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员，和其他创建了基类的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。每个类控制它自己的成员初始化。 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 派生类使用基类的成员 派生类可以访问基类的公有成员和受保护成员 派生类的作用域嵌套在基类的作用域中。 继承和静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义，不论从基类中派生出多少个派生类，对于每个静态成员来说，都只存在唯一的实例。 静态成员遵循通用的访问控制，如果基类中的成员是private的，则派生类无权访问它，假设某静态成员是可访问的，则我们既能通过基类使用它，也能通过派生类使用它。 派生类的声明 派生类的声明不能包含派生列表 被用作基类的类如果我们想将某个类用作基类，则该类必须已经定义，而非仅仅声明 防止继承final 类型转换和继承 通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型与对象的类型一样 我们可以将基类的指针或引用绑定到派生类的对象上。 静态类型 动态类型 静态类型：它是变量声明时的类型或表达式生产的类型，编译时是已知的 动态类型：变量或表达式内存中的对象类型，运行时才可知 如果表达式既不是指针，也不是引用，则它的动态类型和静态类型一样 不存在从基类向派生类的隐式类型转换 之所以存在从派生类向基类的类型转换，是因为每个派生类对象中包含一个基类部分 基类的对象可能是派生类也可能不是，所以不存在从基类向派生类的自动类型转换 在对象之间不存在类型转换 派生类向基类的自动类型转换只对指针和引用有效，对象之间不存在这样的转化。 因为构造函数不能是虚函数，当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类定义的那个，显然，构造函数只能处理基类自己的成员，类似的，如果我们将一个派生类对象赋值给一个基类对象，则它实际运行的赋值运算符也是基类中定义的那个。该运算符同样只能处理基类自己的成员。 虚函数当我们使用基类的引用或者指针调用一个虚函数时将发生动态绑定。我们必须为每一个虚函数提供定义，而不管它是否会用到，这是因为编译器也无法确定到底会使用哪个虚函数。 ###对虚函数的调用可能在运行时才被解析 当某个虚函数通过指针或者引用调用时，编译器产生的代码知道运行时才确定应该调用那个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那个。 成员函数如果没用被声明为虚函数，解析过程发生在编译时候（当且仅当使用指针调用或引用调用的时候） 成员函数声明为虚函数，根据调用指针在运行的时候确定调用的版本。 派生类中的虚函数 一旦某个函数声明成虚函数，则在所有派生类中都是虚函数 一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它被覆盖的基类函数完全一致。 虚函数的返回类型是类本身的指针或引用，可以是本身类。 final和override使用override来说明派生类的虚函数，这么做的好处： 使得程序员的意图更加明确 同时让编译器帮我们发现一些错误 虚函数和默认实参如果某次函数调用使用了默认实参，则该实参由本次调用的静态类型决定。 回避虚函数机制使用作用域运算符可以不对虚函数动态绑定。 抽象基类 我们在函数体（即在声明语句的分号之前）加上=0就可以将一个虚函数声明为纯虚函数，其中=0只能出现在类内部的虚函数声明处。 纯虚函数的目的是不希望用户创建类型的对象。 可以为纯虚函数提供定义，必须在类的外部 含有纯虚函数的类是抽象基类抽象基类负责接口的定义，后续的其他类可以覆盖该接口，不能直接创建一个抽象基类的对象。 派生类构造函数只能初始化它的直接基类1234Bulk_quote(const std::string&amp; book,double price,std::size_t qty,double disc): Disk_quote(book,price,qty,disc) &#123; &#125; 派生类显示的著名他使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后面增加一个override关键字。 回避虚函数使用：在函数名前加作用域运算符。 访问控制与继承 protected用来声明希望与派生类共享、但不被共有访问的成员。 派生类成员和友元只能通过派生类对象访问基类的受保护的成员。 protected成员对于派生类和友元来说可以访问。 protected对于类的用户来说不可访问。 共有、私有、受保护继承某个类对其继承而来的成员的访问权限收到两个因素的影响： 基类中该成员的访问说明符 派生列表中派生访问说明符 派生访问说明符对于派生类的成员（及友元）能否访问直接基类的成员没什么影响，对基类成员的访问权限只与基类的访问说明符有关 派生访问说明符的目的是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限 派生类向基类转化的可行性假设D继承自B 只有D共有继承B时，用户代码才能使用派生类向基类转换，如果D继承B的方式是受保护的或私有的，则用户代码不能转化 不论以什么方式继承B，D的成员函数和友元都能使用派生类向基类转化，派生类向其直接基类的类型转换对于派生类的成员和友元来说，永远可以访问 如果D继承B的方式是共有、受保护继承，则D的派生类的成员或友元可以使用D向B的转化，反之，如果D继承B的方式是私有的，则不能。 对于代码的某个节点，如果基类的共有成员是可访问的，则派生类向基类的类型转换也是可访问的，反之不行。 ###友元和继承 爸爸受保护的属性，儿子的小三（友元）想通过儿子窃取，不行（友元不能传递） 爸爸受保护的属性，爸爸的小三想通过儿子获取，可以（谁的小三就能获取到谁的保护属性，小三具有破坏性）（因为儿子有爸爸的基因） 不能继承友元关系，每个类负责控制各个成员的访问权限。 改变个别成员的可访问性有时我们需要改变派生类继承的某个名字的访问权限，通过使用using声明。 可以将类的直接基类或间接基类找那个的任何可访问成员（例如非私有）标记出来，using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。 派生类只能为那些它可以访问的名字提供using声明 默认的继承保护级别 class的访问说明符、派生访问说明符默认都是private struct的访问说明符、派生访问说明符默认都是public的 两个角度理解访问控制： 普通用户 实现者 继承中类的作用域派生类的作用域位于基类的作用域内，所以在派生类中，可以像使用自己成员一样，使用基类成员。 在编译时进行名字查找一个对象、引用、指针的静态类型决定了该对象的那些成员是可见的。搜索名字从对象静态类型的类开始。 名字冲突和继承和其他作用域一样，派生类也能重新定义在其直接基类或间接基类中的名字，此时，定义在内层作用域的名字将隐藏定义在外层作用（即基类）的名字 通过作用域运算符来使用隐藏的成员假设饿哦们调用p-&gt;mem(): 首先确定p的静态类型 从静态类型对应的类开始查找，知道继承的顶端，如果没有找到名字，则编译器报错 如果找到，就进行常规的类型检查 如果类型检查合法。 如果mem是虚函数且通过指针或引用调用，则编译器产生代码将在运行时确定到底运行那个版本，依据对象的动态类型 反之，编译器产生常规函数调用 一如既往，名字查找优先于类型检查声明在内层作用域的函数并不会重载在外层作用域的函数，定义在派生类中的函数不会重载基类中的成员。和其他作用域一样，定义在派生类的成员和基类的某个成员同名，则派生类将在其作用域内隐藏该基类成员，即使派生类成员和基类成员的形参列表不一致。基类成员任然会被隐藏。 虚函数和作用域构造函数与拷贝控制虚析构函数析构函数定义成虚函数，确保删除指针能执行正确的版本。主要防止删除指向派生类的基类指针，删除错误。 虚析构函数将阻止合成移动操作 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上virtual关键字，但是并不是非得这么做。C++11新标准允许派生类显示的注明它将使用哪个成员函数改写基类的虚函数，具体的措施是在该函数的形参列表之后增加一个关键字override关键字。 合成拷贝控制与继承大多数基类都会定义一个虚析构函数，因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。 派生类的拷贝控制成员在默认情况下，基类默认构造函数初始化派生类对象的基类部分，如果我们想拷贝或移动基类部分，则必须在派生类的构造函数初始值列表中显示的使用基类的拷贝或移动构造函数。 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示的为其基类部分赋值。 123456789101112131415///拷贝构造函数D(const D &amp; d):Base(d),/*D成员的初始值*/&#123;&#125;// 赋值运算符D&amp; D::operator=(const D &amp;rhs)&#123; Base::operator=(rhs); ///派生类 return *this;&#125;///析构函数 Base::~Base被自动调用~D(); 派生类的析构函数派生类的析构函数首先执行，然后是基类的析构函数。 在构造函数和析构函数中继承的构造函数派生类能够重用直接基类定义的构造函数，类不能继承默认、拷贝和移动构造函数，如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。派生类继承基类构造函数的方式是提供一条注明了基类名的using声明语句 1using Disc_quote::Disc_quote; 通常情况下，using声明语句令某个名字在当前作用域内可见，而当作用域构造函数时，using声明语句令编译器产生代码。对于基类的每个构造函数，编译器生成一个与之对应的派生类构造函数。一个构造函数的using声明不会改变构造函数的访问级别。 当一个基类构造函数含有默认时才能时，这些实参不会继承，相反，派生类将获得多个继承的构造函数。 容器与继承当我们使用容器存放继承体系中的对象时，通常必须采用间接存储方式，因为不允许在容器中保存不同类型的元素。","tags":[{"name":"面向对象程序设计","slug":"面向对象程序设计","permalink":"http://yoursite.com/tags/面向对象程序设计/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第十五章 面向对象程序设计","slug":"C-语言/C-Primer/第十五章-面向对象程序设计","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第十五章-面向对象程序设计/"}]},{"title":"为什么`forward_list`不支持`push_back`操作？","date":"2018-06-27T02:07:12.000Z","path":"wiki/C++语言/container/forward_list不支持push_back操作/","text":"为什么forward_list不支持push_back操作？由于forward_list是单向链表，所以我们如果想要访问尾元素，都要从首元素开始跌代，算法复杂度为O(n)。而对于list为双向链表，直接通过尾指针可以访问尾元素，实现在尾元素添加元素，函数复杂度为O(1)，而vector，string,deque,也可以通过尾指针来添加元素，函数复杂度为O(1)。 同样的原因也有forward_list不支持pop_back。由于类似原因(算法的复杂度)，有vector，string，不支持push_front，pop_front，但是通过insert，和erase操作仍然可以完成添加/删除首元素。","tags":[{"name":"forward_list","slug":"forward-list","permalink":"http://yoursite.com/tags/forward-list/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"container","slug":"C-语言/container","permalink":"http://yoursite.com/categories/C-语言/container/"}]},{"title":"容器基本操作","date":"2018-06-26T08:07:12.000Z","path":"wiki/C++语言/container/容器基本操作/","text":"本文列举C++中容器的通用操作。来源于C++ primer 类型 说明 类型别名 iterator 容器的迭代器类型 const_iterator 可以读取元素，但不能修改元素的迭代器类型 size_type 无符号整数类型，足够保存此种容器类型最大可能大小 difference_type 带符号整数类型，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型，与value_type&amp;含义相同 const_reference 元素的const左值类型(const value_type &amp;) 构造函数 C c; 默认构造函数，构造空的容器 C c1(c2) 构造出c2的拷贝c1 C c(b,e) 构造c，将迭代器b和e指定的范围内的元素拷贝到c （array不支持） C c{a,b,c …} 列表初始化 赋值与swap c1= c2 将c1中的元素地换为c2中的元素 c1 = {a,b,c …} 将c1中的元素退换为列表中的元素（array不适用） a.swap(b) 交换a和b的元素 swap(a,b) 与a.swap(b)等价 大小 c.size() c中元素的书面（forward_list不支持） c.max_size() c可保存的最大元素数目 c.empty() c中存储了元素，返回false，否则返回true 添加删除元素（不使用array） 在不同的容器中，这些操作的接口都不同 c.insert(args) 将args中的元素拷贝进c c.emplace(inits) 使用inits构造c中的一个元素 c.erase(args) 删除args指定的元素 c.clear() 删除c中的所有元素，返回void 关系运算符 ==， != 所有容器都支持相等（不等于）运算符 &lt;,&lt;=,&gt;,&gt;= 无序关联容器不支持 获取迭代器 c.begin(), c.end() 返回指向c的首元素和尾元素之后位置的迭代器 c.cbegin(),c.cend() 返回const_iterator 反向容器的额外成员（不支持forward_list） reverse_iterator 逆序寻址元素的迭代器 const_reverse_iterator 不修改元素的逆序迭代器 c.rbegin(),c.rend() 返回指向c的尾元素和首元素之前位置的迭代器 c.crbegin(),c.crend 返回const_reverse_iterator","tags":[{"name":"容器操作","slug":"容器操作","permalink":"http://yoursite.com/tags/容器操作/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"container","slug":"C-语言/container","permalink":"http://yoursite.com/categories/C-语言/container/"}]},{"title":"C++标准库中的list的实现原理","date":"2018-06-26T07:07:12.000Z","path":"wiki/C++语言/container/list/C++标准库中的list的实现原理/","text":"本文抄袭至C++标准库中的list的实现原理 在C++中采用了大量的标志模板库（STL）实现程序的设计，这种设计方式使得不同类型的对象都能通用，而不再是C语言中的通常对于不同的类型需要重新设计或者或者比较采用间接的指针操作。C++中的这种方式简化了写代码的复杂度，但是增加了编译器的复杂度和难度。 在数据结构中链表是比较基本的类型，在C++中链表是基于模板的类，因此在实际的使用过程中需要涉及到实际的类型。 12#include&lt;list&gt;list&lt;int&gt; lint; 在C++中关于list的接口比较丰富，主要是关于大小，数据的插入、删除等。但是在C++中引入了迭代器的概念，这个迭代器是关于关于容器中比较重要的一部分，因为这种迭代器使得算法等问题与容器独立开来，迭代器实质上还是指针，准确的将是一个封装了指针的类。 迭代器类的创建应该包含下面的操作，首先应该支持的操作符至少包括如下（operator*()，operator++()，operator++(int)，operator==()， operator!=()）,当然也会存在const_iterator这样的常迭代器，也就是只允许访问，不能修改对象的迭代器，当然存在迭代器的构造函数、复制控制函数，这些函数都是必须要存在的，因为设计到了指针的操作问题，构造函数应该存在参数是链表节点指针的定义，只有存在这个定义才能间接的访问节点对象。当然在类中至少存在返回迭代器的begin()和end()函数，这两个函数返回的迭代器分别指向链表的开始和链表结束的下一个地址，这是迭代器中经常容易理解错误的地方。 在C++中通常创建const_iterator类，然后iterator直接继承const_iterator。 下面说说list类设计的基本思路：首先、创建链表节点对象，实质上是完成对传递进来的类型的封装操作，同时构成一个双向链表的基本要素（prev、next指针）。节点肯定要存在构造函数，而且是直接初始化三个成员变量。其次、创建迭代器类，实质上就是封装一个节点指针，通过节点指针实现操作，至少要实现的操作符已说明。这两个类都要设置List为友元类，因为这样才能用List直接操作迭代器的相关操作。最后、依靠上面的迭代器类和节点类，创建一个List类，该类中主要完成一些基本操作。其中需要注意的就是迭代器的操作，比如删除元素和插入元素以后迭代器的变化问题等。 需要注意的是在List中采用了哨兵节点，这个哨兵节点并不算实际的操作对象，也就是为了保证肯定有目标所指向，存在一个head对象，这个对象的next就是实际的数据，而tail是迭代器所能到达的最后一个对象，但是这个对象并不是合理的区域，实际上end()实际上就是指向了tail节点，这两个节点head和tail就是哨兵节点。具体的参看代码。 源码解读实现的基本形式如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305#ifndef __MYLIST_H_H_#define __MYLIST_H_H_#include&lt;iostream&gt;namespace myspace&#123; templateObject&gt; class List &#123; private: /*封装对象，形成链表节点*/ struct Node &#123; Object data; struct Node *prev; struct Node *next; /*节点构造函数*/ Node(const Object &amp;d = Object(), Node *p = NULL, Node *n = NULL) :data(d), prev(p), next(n)&#123;&#125; &#125;; public: /*创建一个常量迭代器类，这是容器设计的关键*/ class const_iterator &#123; public: const_iterator():current(NULL) &#123;&#125; /*重载迭代器的值*/ const Object &amp; operator*()const &#123; return retrieve(); &#125; /*重载前向++操作符*/ const_iterator &amp; operator++ () &#123; current = current-&gt;next; return *this; &#125; /*重载后向++操作符，因为是一个局部对象不能返回引用*/ const_iterator operator++(int) &#123; const_iterator old = *this; ++(*this); return old; &#125; /*判断迭代器是否相同，实质上就是判断指向的节点是否相同*/ bool operator==(const const_iterator &amp;rhs) const &#123; return current == rhs.current; &#125; /*调用==操作符*/ bool operator!=(const const_iterator &amp;rhs)const &#123; return (!(*this == rhs)); &#125; protected: /*迭代器实质就是一个节点指针*/ Node *current; /*获得链表中的内容*/ Object &amp; retrieve() const &#123; return current-&gt;data; &#125; /*基于指针参数的迭代器构造函数，保证只有List使用*/ const_iterator(Node *p):current (p) &#123;&#125; /*友元类，可以调用迭代器的私有成员*/ friend class List&lt;Object&gt;; &#125;; /*一般迭代器，直接继承const_iterator*/ class iterator : public const_iterator &#123; public: iterator():const_iterator() &#123;&#125; /*得到对象的值*/ Object &amp;operator*() &#123; return retrieve(); &#125; /*基于const的重载*/ const Object&amp; operator*()const &#123; return const_iterator::operator*(); &#125; /*前向++操作符*/ iterator &amp;operator++() &#123; current = current-&gt;next; return *this; &#125; /*后向++操作符*/ iterator operator++(int) &#123; iterator *old = *this; ++(*this); return old; &#125; protected: /*基于节点的迭代器构造函数*/ iterator(Node *p):const_iterator(p) &#123;&#125; friend class List&lt;Object&gt;; &#125;; public: List() &#123; init(); &#125; ~List() &#123; clear(); delete head; delete tail; &#125; List(const List &amp;rhs) &#123; /*创建哨兵节点*/ init(); /*复制数据*/ *this = rhs; &#125; const List &amp; operator=(const List &amp;rhs) &#123; if(this == &amp;rhs) return *this; /*清除原有的信息*/ clear(); /*添加新的对象*/ for(const_iterator itr = rhs.begin(); itr != rhs.end(); ++ itr) push_back(*itr); return *this; &#125; /*得到迭代器，实质上就是得到节点指针*/ iterator begin() &#123; /*iterator()是构造函数*/ return iterator(head-&gt;next); &#125; const_iterator begin()const &#123; return const_iterator(head-&gt;next); &#125; iterator end() &#123; return iterator(tail); &#125; const_iterator end()const &#123; return const_iterator(tail); &#125; int size()const &#123; return theSize; &#125; bool empty()const &#123; return size() == 0; &#125; void clear() &#123; while( !empty()) pop_front(); &#125; /*得到第一个元素*/ Object &amp; front() &#123; /*采用了迭代器begin()*/ return *begin(); &#125; const Object &amp;front()const &#123; return *begin(); &#125; Object &amp;back() &#123; /*end()指向最后一个对象的下一个地址，因此需要--*/ return *--end(); &#125; const Object &amp;back()const &#123; return *--end(); &#125; /*********************************************** *从头插入新的节点，这时候的begin已经不再是begin *因此插入操作会导致迭代器出错 ***********************************************/ void push_front(const Object &amp;x) &#123; insert(begin(), x); &#125; /*从后插入新的节点，这时候会将end后移*/ void push_back(const Object &amp;x) &#123; insert(end(), x); &#125; /*从头弹出一个对象*/ void pop_front() &#123; erase(begin()); &#125; void pop_back() &#123; erase(--end()); &#125; /*插入对象，参数是迭代器和数据*/ iterator insert(iterator itr, const Object &amp;x) &#123; /*得到当前迭代器的指针*/ Node *p = itr.current; theSize ++; /* *Node *np = Node(x,p-&gt;prev,p); this means that np-&gt;prev = p-&gt;prev, and np-&gt;next = p; update the p-&gt;prev and p-&gt;prev-&gt;next; *p-&gt;prev-&gt;next = np; *p-&gt;prev = np; */ return iterator(p-&gt;prev=p-&gt;prev-&gt;next= new Node(x,p-&gt;prev, p)); &#125; /*删除迭代器处的对象,因此删除也会导致迭代器破坏*/ iterator erase(iterator itr) &#123; /*得到当前迭代器的指针*/ Node *p = itr.current; /*得到新的迭代器，并初始化*/ iterator retVal(p-&gt;next); /*更新链表的链接关系*/ p-&gt;prev-&gt;next = p-&gt;next; p-&gt;next-&gt;prev = p-&gt;prev; /*删除对象*/ delete p; /*使得对象数减少*/ theSize --; /*返回新的迭代器*/ return retVal; &#125; /*删除迭代器指向的对象*/ iterator erase(iterator start, iterator end) &#123; /*for中不使用++itr的原因是erase之后 *就是下一个迭代器，因此不需要++操作*/ for(iterator itr = start; itr != end; ) &#123; /*该操作会导致迭代器更新到下一个*/ itr = erase(itr); &#125; return itr; &#125; private: /*链表中的数据成员*/ int theSize; Node *head; Node *tail; /*初始化函数*/ void init() &#123; theSize = 0; /*create two sentinel node*/ /*构建两个哨兵节点，也就是两个并不算在结构体中的对象*/ head = new Node; tail = new Node; /*绑定起来*/ head-&gt;next = tail; tail-&gt;prev = head; &#125; &#125;;&#125;#endif","tags":[{"name":"list","slug":"list","permalink":"http://yoursite.com/tags/list/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"container","slug":"C-语言/container","permalink":"http://yoursite.com/categories/C-语言/container/"},{"name":"list","slug":"C-语言/container/list","permalink":"http://yoursite.com/categories/C-语言/container/list/"}]},{"title":"deque的实现原理和使用方法详解","date":"2018-06-26T02:07:12.000Z","path":"wiki/C++语言/container/deque/deque的实现原理和使用方法详解/","text":"本文抄袭至STL源码剖析——deque的实现原理和使用方法详解。只用于本人学习。 Deque 简介 deque是“double—ended queue”的缩写，和vector一样都是STL的容器，deque 是双端数组，而 vector 是单端的。 deque 在接口上和 vector 非常相似，在许多操作的地方可以直接替换。 deque 可以随机存取元素（支持索引值直接存取，用[]操作符或at()方法，这个等下会详讲）。 deque 头部和尾部添加或移除元素都非常快速。但是在中间插入元素或移除元素比较费时。 使用时需要包含头文件 #include 。 Deque 实现原理deque 的中控器deque是连续空间（至少逻辑上看来如此），连续线性空间总令我们联想到array或vector。array无法成长，vector虽可成长，却只能向尾端成长，而且其所谓的成长原是个假象，事实上是（1）另觅更大空间；（2）将原数据复制过去；（3）释放原空间三部曲。如果不是vector每次配置新空间时都有留下一些余裕，其成长假象所带来的代价将是相当高昂。 deque系由一段一段的定量连续空间构成。一旦有必要在deque的前端或尾端增加新空间，便配置一段定量连续空间，串接在整个deque的头端或尾端。deque的最大任务，便是在这些分段的定量连续空间上，维护其整体连续的假象，并提供随机存取的接口。避开了“重新配置、复制、释放”的轮回，代价则是复杂的迭代器架构。受到分段连续线性空间的字面影响，我们可能以为deque的实现复杂度和vector相比虽不中亦不远矣，其实不然。主要因为，既是分段连续线性空间，就必须有中央控制，而为了维持整体连续的假象，数据结构的设计及迭代器前进后退等操作都颇为繁琐。deque的实现代码分量远比vector或list都多得多。deque采用一块所谓的map作为主控。这里所谓map是一小块连续空间，其中每个元素（此处称为一个节点，node）都是指针，指向另一段（较大的）连续线性空间，称为缓冲区。缓冲区才是deque的储存空间主体。SGI STL 允许我们指定缓冲区大小，默认值0表示将使用512 bytes 缓冲区。 deque的整体架构如下图所示： deque 的迭代器让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针，分别为cur, first, last, node。 指针结构如下图所示： 在上面介绍中我们大致了解了deque 的基本概念和实现原理，现在我就开始介绍如何使用 deque。 deque 使用deque 对象的默认构造deque 采用模板类实现，deque 对象的默认构造形式：deque dequeT； 1234deque&lt;int&gt; deqInt; //一个存放int的deque容器。 deque&lt;float&gt; deqFloat; //一个存放float的deque容器。 deque&lt;string&gt; deqString; //一个存放string的deque容器。 ... 尖括号内还可以设置指针类型或自定义类型。 deque 元素添加移除操作1234deque.push_back(elem); //在容器尾部添加一个数据 deque.push_front(elem); //在容器头部插入一个数据 deque.pop_back(); //删除容器最后一个数据 deque.pop_front(); //删除容器第一个数据 deque 的数据存取1234deque.at(idx); //返回索引idx所指的数据，如果idx越界，抛出out_of_range。 deque[idx]; //返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。 deque.front(); //返回第一个数据。 deque.back(); //返回最后一个数据 deque 与迭代器1234deque.begin(); //返回容器中第一个元素的迭代器。 deque.end(); //返回容器中最后一个元素之后的迭代器。 deque.rbegin(); //返回容器中倒数第一个元素的迭代器。 deque.rend(); //返回容器中倒数最后一个元素之后的迭代器。 deque 对象的带参数构造123deque(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。注意该区间是左闭右开的区间。 deque(n,elem); //构造函数将n个elem拷贝给本身。 deque(const deque &amp;deq); //拷贝构造函数。 deque 的赋值1234deque.assign(beg,end); //将[beg, end)区间中的数据拷贝赋值给本身。注意该区间是左闭右开的区间。 deque.assign(n,elem); //将n个elem拷贝赋值给本身。 deque&amp; operator=(const deque &amp;deq); //重载等号操作符 deque.swap(deq); // 将deq与本身的元素互换 1234567891011121314deque&lt;int&gt; deqIntA,deqIntB,deqIntC,deqIntD; deqIntA.push_back(1); deqIntA.push_back(3); deqIntA.push_back(5); deqIntA.push_back(7); deqIntA.push_back(9); deqIntB.assign(deqIntA.begin(),deqIntA.end()); // 1 3 5 7 9 deqIntC.assign(5,8); //8 8 8 8 8 deqIntD = deqIntA; //1 3 5 7 9 deqIntC.swap(deqIntD); //互换 deque 的大小123456deque.size(); //返回容器中元素的个数 deque.empty(); //判断容器是否为空 deque.resize(num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 deque.resize(num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除。 deque 的插入123deque.insert(pos,elem); //在pos位置插入一个elem元素的拷贝，返回新数据的位置。 deque.insert(pos,n,elem); //在pos位置插入n个elem数据，无返回值。 deque.insert(pos,beg,end); //在pos位置插入[beg,end)区间的数据，无返回值。 deque 的删除123deque.clear(); //移除容器的所有数据 deque.erase(beg,end); //删除[beg,end)区间的数据，返回下一个数据的位置。 deque.erase(pos); //删除pos位置的数据，返回下一个数据的位置。 源码 让我们思考一下，deque的迭代器应该具备什么结构，首先，它必须能够指出分段连续空间（亦即缓冲区）在哪里，其次它必须能够判断自己是否已经处于其所在缓冲区的边缘，如果是，一旦前进或后退就必须跳跃至下一个或上一个缓冲区。为了能够正确跳跃，deque必须随时掌握管控中心（map）。所以在迭代器中需要定义：当前元素的指针，当前元素所在缓冲区的起始指针，当前元素所在缓冲区的尾指针，指向map中指向所在缓区地址的指针。在进行迭代器的移动时，需要考虑跨缓冲区的情况。 重载前加(减)，在实现后加(减)时，调用重载的前加(减)。重载+=,实现+时，直接调用+=,实现-=时，调用+=负数，实现-时，调用-=.//当需要实现新的功能时，最好使用已经重载好的操作，即方便有安全。。。。 另外，deque在效率上来说是不够vector好的，因此有时候在对deque进行sort的时候，需要先将元素移到vector再进行sort，然后移回来。 构造函数：根据缓冲区设置大小和元素个数，决定map的大小；给map分配空间，根据缓冲区的个数，分配缓冲区，默认指定一个缓冲区； 设置start和finish迭代器，满足左闭右开的原则。 push_back:如果空间满足，直接插入；不满足，调用push_back_aux。 push_back_aux:先调用reverse_map_at_back,若符合某种条件，重换一个map；分配空间。 reserve_map_at_back:看看map有没有满，满的话，调用reallocate_map。 reallocate_map:如果前端或后端pop过多，就会导致大量的空闲空间，如果是这种情况，则不用新分配空间，调整一下start的位置即可； 如果不够，则需要重新申请空间。 pop：析构元素，如果是最后一块还需要删除空间。 erase：需要判断，前面的元素少还是后面的元素少，移动较少的部分。 insert：判断位置，如果为前端或后端直接调用push操作，否则，移动较少的一端。 deque的构造与内存管理： 由于deque的设计思想就是由一块块的缓存区连接起来的，因此它的内存管理会比较复杂。插入的时候要考虑是否要跳转缓存区、是否要新建map节点（和vector一样，其实是重新分配一块空间给map，删除原来空间）、插入后元素是前面元素向前移动还是后面元素向后面移动（谁小移动谁）。而在删除元素的时候，考虑是将前面元素后移覆盖需要移除元素的地方还是后面元素前移覆盖（谁小移动谁）。移动完以后要析构冗余的元素，释放冗余的缓存区。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764// deque的特性: // 对于任何一个迭代器i // i.node是map array中的某元素的地址. i.node的内容是一个指向某个结点的头的指针 // i.first == *(i.node) // i.last == i.first + node_size // i.cur是一个指向[i.first, i.last)之间的指针 // 注意: 这意味着i.cur永远是一个可以解引用的指针, // 即使其是一个指向结尾后元素的迭代器 // // 起点和终点总是非奇异(nonsingular)的迭代器. // 注意: 这意味着空deque一定有一个node, 而一个具有N个元素的deque // (N是Buffer Size)一定有有两个nodes // // 对于除了start.node和finish.node之外的每一个node, 每一个node中的元素 // 都是一个初始化过的对象. 如果start.node == finish.node, // 那么[start.cur, finish.cur)都是未初始化的空间. // 否则, [start.cur, start.last)和[finish.first, finish.cur)都是初始化的对象, // 而[start.first, start.cur)和[finish.cur, finish.last)是未初始化的空间 // // [map, map + map_size)是一个合法的非空区间 // [start.node, finish.node]是内含在[map, map + map_size)区间的合法区间 // 一个在[map, map + map_size)区间内的指针指向一个分配过的node, // 当且仅当此指针在[start.node, finish.node]区间内 inline size_t __deque_buf_size(size_t n, size_t sz) &#123; return n != 0 ? n : (sz &lt; 512 ? size_t(512 / sz) : size_t(1)); &#125; // __deque_iterator的数据结构 template &lt;class T, class Ref, class Ptr, size_t BufSiz&gt; struct __deque_iterator &#123; typedef __deque_iterator&lt;T, T&amp;, T*&gt; iterator; typedef __deque_iterator&lt;T, const T&amp;, const T*&gt; const_iterator; static size_t buffer_size() &#123;return __deque_buf_size(0, sizeof(T)); &#125; typedef random_access_iterator_tag iterator_category; typedef T value_type; typedef Ptr pointer; typedef Ref reference; typedef size_t size_type; typedef ptrdiff_t difference_type; typedef T** map_pointer; typedef __deque_iterator self; // 保持与容器的联结 T* cur; // 此迭代器所指之缓冲区中的现行元素 T* first; // 此迭代器所指之缓冲区的头 T* last; // 此迭代器所指之缓冲区的尾（含备用空间） map_pointer node; // 指向管控中心 //////////////////////////////////////////////////////////////////////////////// // 这个是deque内存管理的关键, 其模型如下 //////////////////////////////////////////////////////////////////////////////// // // --------------------------------------------- // map--&gt;| | | | | | | ..... | | | |&lt;------------------ // --------------------------------------------- | // | | // | | // | node | // | 缓冲区buffer, 这里实际存储元素 | // | --------------------------------------------- | // ---&gt;| | | | | | | ..... | | | X | | // --------------------------------------------- | // ↑ ↑ ↑ | // ------ | | | // | | | | // | ----------- --------------------------- | // ----|----- | | // | | | | // | | | | // | | | | // --------------------------- | // | cur | first | end | map |------------------------------ // --------------------------- // 迭代器, 其内部维护着一个缓冲区状态 //////////////////////////////////////////////////////////////////////////////// __deque_iterator(T* x, map_pointer y) : cur(x), first(*y), last(*y + buffer_size()), node(y) &#123;&#125; __deque_iterator() : cur(0), first(0), last(0), node(0) &#123;&#125; __deque_iterator(const iterator&amp; x) : cur(x.cur), first(x.first), last(x.last), node(x.node) &#123;&#125; reference operator*() const &#123; return *cur; &#125; // 判断两个迭代器间的距离 difference_type operator-(const self&amp; x) const &#123; return difference_type(buffer_size()) * (node - x.node - 1) + (cur - first) + (x.last - x.cur); &#125; //////////////////////////////////////////////////////////////////////////////// // 下面重载的这些运算符是让deque从外界看上去维护的是一段连续空间的关键!!! // 前缀自增 //////////////////////////////////////////////////////////////////////////////// // 如果当前迭代器指向元素是当前缓冲区的最后一个元素, // 则将迭代器状态调整为下一个缓冲区的第一个元素 //////////////////////////////////////////////////////////////////////////////// // 不是当前缓冲区最后一个元素 // // 执行前缀自增前的状态 // first cur end // ↓ ↓ ↓ // --------------------------------------------- // | | | | | | | ..... | | | X | &lt;----- 当前缓冲区 // --------------------------------------------- // // 执行完成后的状态 // first cur end // ↓ ↓ ↓ // --------------------------------------------- // | | | | | | | ..... | | | X | &lt;----- 当前缓冲区 // --------------------------------------------- // //////////////////////////////////////////////////////////////////////////////// // 当前元素为当前缓冲区的最后一个元素 // // 执行前缀自增前的状态 // first cur end // ↓ ↓ ↓ // --------------------------------------------- // | | | | | | | ..... | | | X | &lt;----- 当前缓冲区 // --------------------------------------------- // // 执行完成后的状态 // first end // ↓ ↓ // --------------------------------------------- // | | | | | | | ..... | | | X | &lt;----- 下一缓冲区 // --------------------------------------------- // ↑ // cur // //////////////////////////////////////////////////////////////////////////////// self&amp; operator++() &#123; ++cur; // 切换至下一个元素 if (cur == last) // 如果已达到缓冲区的尾端 &#123; set_node(node + 1); // 就切换至下一节点（亦即缓冲区） cur = first; // 的第一个元素 &#125; return *this; &#125; // 后缀自增 // 返回当前迭代器的一个副本, 并调用前缀自增运算符实现迭代器自身的自增 self operator++(int) &#123; self tmp = *this; ++*this; return tmp; &#125; // 前缀自减, 处理方式类似于前缀自增 // 如果当前迭代器指向元素是当前缓冲区的第一个元素 // 则将迭代器状态调整为前一个缓冲区的最后一个元素 self&amp; operator--() &#123; if (cur == first) // 如果已达到缓冲区的头端 &#123; set_node(node - 1); // 就切换至前一节点（亦即缓冲区） cur = last; // 的最后一个元素 &#125; --cur; return *this; &#125; self operator--(int) &#123; self tmp = *this; --*this; return tmp; &#125; //////////////////////////////////////////////////////////////////////////////// // 将迭代器向前移动n个元素, n可以为负 //////////////////////////////////////////////////////////////////////////////// // operator+=(difference_type n) // ↓ // offset = n + (cur - first) // | // |---------- offset &gt; 0 ? &amp;&amp; // | 移动后是否超出当前缓冲区? // ---------------------------- // No | | Yes // | | // ↓ |---------- offset &gt; 0? // cur += n; | // ---------------------------- // Yes | | No // | | // ↓ | // 计算要向后移动多少个缓冲区 | // node_offset = | // offset / difference_type | // (buffer_size()); ↓ // | 计算要向前移动多少个缓冲区 // | node_offset = -difference_type // | ((-offset - 1) / buffer_size()) - 1; // | | // ---------------------------- // | // | // ↓ // 调整缓冲区 // set_node(node + node_offset); // 计算并调整cur指针 //////////////////////////////////////////////////////////////////////////////// // 以下实现随机存取。迭代器可以直接跳跃n个距离 self&amp; operator+=(difference_type n) &#123; difference_type offset = n + (cur - first); if (offset &gt;= 0 &amp;&amp; offset &lt; difference_type(buffer_size())) cur += n; // 目标位置在同一缓冲区内 else &#123; // 目标位置不在同一缓冲区内 difference_type node_offset = offset &gt; 0 ? offset / difference_type(buffer_size()) : -difference_type((-offset - 1) / buffer_size()) - 1; // 切换至正确的节点（亦即缓冲区） set_node(node + node_offset); // 切换至正确的元素 cur = first + (offset - node_offset * difference_type(buffer_size())); &#125; return *this; &#125; self operator+(difference_type n) const &#123; self tmp = *this; // 这里调用了operator +=()可以自动调整指针状态 return tmp += n; &#125; // 将n变为-n就可以使用operator +=()了, self&amp; operator-=(difference_type n) &#123; return *this += -n; &#125; self operator-(difference_type n) const &#123; self tmp = *this; return tmp -= n; &#125; reference operator[](difference_type n) const &#123; return *(*this + n); &#125; bool operator==(const self&amp; x) const &#123; return cur == x.cur; &#125; bool operator!=(const self&amp; x) const &#123; return !(*this == x); &#125; bool operator&lt;(const self&amp; x) const &#123; return (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node); &#125; void set_node(map_pointer new_node) &#123; node = new_node; first = *new_node; last = first + difference_type(buffer_size()); &#125; &#125;; // deque的数据结构 template &lt;class T, class Alloc = alloc, size_t BufSiz = 0&gt; class deque &#123; public: // Basic types typedef T value_type; typedef value_type* pointer; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; public: // Iterators typedef __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt; iterator; protected: // Internal typedefs typedef pointer* map_pointer; // 这个提供STL标准的allocator接口, 见&lt;stl_alloc.h&gt; typedef simple_alloc&lt;value_type, Alloc&gt; data_allocator; typedef simple_alloc&lt;pointer, Alloc&gt; map_allocator; // 获取缓冲区最大存储元素数量 static size_type buffer_size() &#123; return __deque_buf_size(BufSiz, sizeof(value_type)); &#125; static size_type initial_map_size() &#123; return 8; &#125; protected: // Data members iterator start; // 起始缓冲区 iterator finish; // 最后一个缓冲区 // 指向map, map是一个连续的空间, 其每个元素都是一个指针，指向一个节点（缓冲区） map_pointer map; size_type map_size; // map容量 public: iterator begin() &#123; return start; &#125; iterator end() &#123; return finish; &#125; // 提供随机访问能力, 其调用的是迭代器重载的operator [] // 其实际地址需要进行一些列的计算, 效率有损失 reference operator[](size_type n) &#123; return start[difference_type(n)]; &#125; reference front() &#123; return *start; &#125; reference back() &#123; iterator tmp = finish; --tmp; return *tmp; &#125; // 当前容器拥有的元素个数, 调用迭代器重载的operator - size_type size() const &#123; return finish - start;; &#125; size_type max_size() const &#123; return size_type(-1); &#125; // deque为空的时, 只有一个缓冲区 bool empty() const &#123; return finish == start; &#125; public: // Constructor, destructor. deque() : start(), finish(), map(0), map_size(0) &#123; create_map_and_nodes(0); &#125; deque(size_type n, const value_type&amp; value) : start(), finish(), map(0), map_size(0) &#123; fill_initialize(n, value); &#125; deque(int n, const value_type&amp; value) : start(), finish(), map(0), map_size(0) &#123; fill_initialize(n, value); &#125; ~deque() &#123; destroy(start, finish); // &lt;stl_construct.h&gt; destroy_map_and_nodes(); &#125; deque&amp; operator= (const deque&amp; x) &#123; // 其实我觉得把这个操作放在if内效率更高 const size_type len = size(); if (&amp;x != this) &#123; // 当前容器比x容器拥有元素多, 析构多余元素 if (len &gt;= x.size()) erase(copy(x.begin(), x.end(), start), finish); // 将x所有超出部分的元素使用insert()追加进去 else &#123; const_iterator mid = x.begin() + difference_type(len); copy(x.begin(), mid, start); insert(finish, mid, x.end()); &#125; &#125; return *this; &#125; public: void push_back(const value_type&amp; t) &#123; // 最后缓冲区尚有两个（含）以上的元素备用空间 if (finish.cur != finish.last - 1) &#123; construct(finish.cur, t); // 直接在备用空间上构造元素 ++finish.cur; // 调整最后缓冲区的使用状态 &#125; // 容量已满就要新申请内存了 else push_back_aux(t); &#125; void push_front(const value_type&amp; t) &#123; if (start.cur != start.first) // 第一缓冲区尚有备用空间 &#123; construct(start.cur - 1, t); // 直接在备用空间上构造元素 --start.cur; // 调整第一缓冲区的使用状态 &#125; else // 第一缓冲区已无备用空间 push_front_aux(t); &#125; void pop_back() &#123; if (finish.cur != finish.first) // 最后缓冲区有一个（或更多）元素 &#123; --finish.cur; // 调整指针，相当于排除了最后元素 destroy(finish.cur); // 将最后元素析构 &#125; else // 最后缓冲区没有任何元素 pop_back_aux(); // 这里将进行缓冲区的释放工作 &#125; void pop_front() &#123; if (start.cur != start.last - 1) // 第一缓冲区有两个（或更多）元素 &#123; destroy(start.cur); // 将第一元素析构 ++start.cur; //调整指针，相当于排除了第一元素 &#125; else // 第一缓冲区仅有一个元素 pop_front_aux(); // 这里将进行缓冲区的释放工作 &#125; public: // Insert //////////////////////////////////////////////////////////////////////////////// // 在指定位置前插入元素 //////////////////////////////////////////////////////////////////////////////// // insert(iterator position, const value_type&amp; x) // | // |---------------- 判断插入位置 // | // ----------------------------------------------- // deque.begin() | deque.emd() | | // | | | // ↓ ↓ | // push_front(x); push_back(x); | // ↓ // insert_aux(position, x); // 具体剖析见后面实现 //////////////////////////////////////////////////////////////////////////////// iterator insert(iterator position, const value_type&amp; x) &#123; // 如果是在deque的最前端插入, 那么直接push_front()即可 if (position.cur == start.cur) &#123; push_front(x); return start; &#125; // 如果是在deque的末尾插入, 直接调用push_back() else if (position.cur == finish.cur) &#123; push_back(x); iterator tmp = finish; --tmp; return tmp; &#125; else &#123; return insert_aux(position, x); &#125; &#125; iterator insert(iterator position) &#123; return insert(position, value_type()); &#125; // 详解见实现部分 void insert(iterator pos, size_type n, const value_type&amp; x); void insert(iterator pos, int n, const value_type&amp; x) &#123; insert(pos, (size_type) n, x); &#125; void insert(iterator pos, long n, const value_type&amp; x) &#123; insert(pos, (size_type) n, x); &#125; void resize(size_type new_size) &#123; resize(new_size, value_type()); &#125; public: // Erase iterator erase(iterator pos) &#123; iterator next = pos; ++next; // 清除点之前的元素个数 difference_type index = pos - start; // 如果清除点之前的元素个数比较少, 哪部分少就移动哪部分 if (index &lt; (size() &gt;&gt; 1)) &#123; // 就移动清除点之前的元素 copy_backward(start, pos, next); pop_front(); // 移动完毕，最前一个元素冗余，去除之 &#125; else // 如果清除点之后的元素个数比较少 &#123; copy(next, finish, pos); // 就移动清除点之后的元素 pop_back(); // 移动完毕，最后一个元素冗余，去除之 &#125; return start + index; &#125; iterator erase(iterator first, iterator last); void clear(); protected: // 详解见实现部分 void push_back_aux(const value_type&amp; t); void push_front_aux(const value_type&amp; t); void pop_back_aux(); void pop_front_aux(); iterator insert_aux(iterator pos, const value_type&amp; x); void insert_aux(iterator pos, size_type n, const value_type&amp; x); // 分配内存, 不进行构造 pointer allocate_node() &#123; return data_allocator::allocate(buffer_size()); &#125; // 释放内存, 不进行析构 void deallocate_node(pointer n) &#123; data_allocator::deallocate(n, buffer_size()); &#125; &#125;; //////////////////////////////////////////////////////////////////////////////// // 清除[first, last)区间的所有元素 //////////////////////////////////////////////////////////////////////////////// // erase(iterator first, iterator last) // | // |---------------- 是否要删除整个区间? // | // ------------------------------------------ // Yes | | No // | | // ↓ | --- 判断哪侧元素少 // clear(); ↓ // ----------------------------------------------------------------- // 左侧少 | 右侧少 | // | | // ↓ ↓ // copy_backward(start, first, last); copy(last, finish, first); // new_start = start + n; new_finish = finish - n; // 析构多余的元素 析构多余的元素 // destroy(start, new_start); destroy(new_finish, finish); // 释放多余内存空间 释放多余内存空间 // for (...) for (...) // ... ... // 更新map状态 更新map状态 //////////////////////////////////////////////////////////////////////////////// template &lt;class T, class Alloc, size_t BufSize&gt; deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::erase(iterator first, iterator last) &#123; if (first == start &amp;&amp; last == finish) // 如果清除区间是整个deque &#123; clear(); // 直接调用clear()即可 return finish; &#125; else &#123; difference_type n = last - first; // 清除区间的长度 difference_type elems_before = first - start; // 清除区间前方的元素个数 if (elems_before &lt; (size() - n) / 2) // 如果前方的元素个数比较少 &#123; copy_backward(start, first, last); // 向后移动前方元素（覆盖清除区间） iterator new_start = start + n; // 标记deque的新起点 destroy(start, new_start); // 移动完毕，将冗余的元素析构 // 以下将冗余的缓冲区释放 for (map_pointer cur = start.node; cur &lt; new_start.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); start = new_start; // 设定deque的新起点 &#125; else // 如果清除区间后方的元素个数比较少 &#123; copy(last, finish, first); // 向前移动后方元素（覆盖清除区间） iterator new_finish = finish - n; // 标记deque的新尾点 destroy(new_finish, finish); // 移动完毕，将冗余的元素析构 // 以下将冗余的缓冲区释放 for (map_pointer cur = new_finish.node + 1; cur &lt;= finish.node; ++cur) data_allocator::deallocate(*cur, buffer_size()); finish = new_finish; // 设定deque的新尾点 &#125; return start + elems_before; &#125; &#125; template &lt;class T, class Alloc, size_t BufSize&gt; void deque&lt;T, Alloc, BufSize&gt;::clear() &#123; // 以下针对头尾以外的每一个缓冲区 for (map_pointer node = start.node + 1; node &lt; finish.node; ++node) &#123; // 将缓冲区内的所有元素析构 destroy(*node, *node + buffer_size()); // 释放缓冲区内存 data_allocator::deallocate(*node, buffer_size()); &#125; if (start.node != finish.node) // 至少有头尾两个缓冲区 &#123; destroy(start.cur, start.last); // 将头缓冲区的目前所有元素析构 destroy(finish.first, finish.cur); // 将尾缓冲区的目前所有元素析构 // 以下释放尾缓冲区。注意：头缓冲区保留 data_allocator::deallocate(finish.first, buffer_size()); &#125; else // 只有一个缓冲区 destroy(start.cur, finish.cur); // 将此唯一缓冲区内的所有元素析构 // 注意：并不释放缓冲区空间，这唯一的缓冲区将保留 finish = start; // 调整状态 &#125; // 只有当finish.cur == finish.last - 1 时才会被调用 // 也就是说，只有当最后一个缓冲区只剩下一个备用元素空间时才会被调用 template &lt;class T, class Alloc, size_t BufSize&gt; void deque&lt;T, Alloc, BufSize&gt;::push_back_aux(const value_type&amp; t) &#123; value_type t_copy = t; reserve_map_at_back(); *(finish.node + 1) = allocate_node(); // 配置一个新节点（缓冲区） __STL_TRY &#123; construct(finish.cur, t_copy); // 针对标的元素设值 finish.set_node(finish.node + 1); // 改变finish，令其指向新节点 finish.cur = finish.first; // 设定finish的状态 &#125; __STL_UNWIND(deallocate_node(*(finish.node + 1))); &#125; // Called only if start.cur == start.first. template &lt;class T, class Alloc, size_t BufSize&gt; void deque&lt;T, Alloc, BufSize&gt;::push_front_aux(const value_type&amp; t) &#123; value_type t_copy = t; reserve_map_at_front(); *(start.node - 1) = allocate_node(); __STL_TRY &#123; start.set_node(start.node - 1); // 改变start，令其指向新节点 start.cur = start.last - 1; // 设定start的状态 construct(start.cur, t_copy); // 针对标的元素设值 &#125; catch(...) &#123; start.set_node(start.node + 1); start.cur = start.first; deallocate_node(*(start.node - 1)); throw; &#125; &#125; // 只有当 finish.cur == finish.first 时才会被调用 template &lt;class T, class Alloc, size_t BufSize&gt; void deque&lt;T, Alloc, BufSize&gt;:: pop_back_aux() &#123; deallocate_node(finish.first); // 释放最后一个缓冲区 finish.set_node(finish.node - 1); // 调整finish状态，使指向 finish.cur = finish.last - 1; // 上一个缓冲区的最后一个元素 destroy(finish.cur); // 将该元素析构 &#125; // 只有当 start.cur == start.last - 1 时才会被调用 template &lt;class T, class Alloc, size_t BufSize&gt; void deque&lt;T, Alloc, BufSize&gt;::pop_front_aux() &#123; destroy(start.cur); // 将第一个缓冲区的第一个（也是最后一个、唯一一个）元素析构 deallocate_node(start.first); // 释放第一缓冲区 start.set_node(start.node + 1); // 调整start状态，使指向 start.cur = start.first; // 下一个缓冲区的第一个元素 &#125; //////////////////////////////////////////////////////////////////////////////// // 在指定位置前插入元素 //////////////////////////////////////////////////////////////////////////////// // insert_aux(iterator pos, const value_type&amp; x) // | // |----------- 判断pos前端元素少还是后端元素少 // | // ----------------------------------------------- // 前端少 | 后端少 | // | | // ↓ | // 进行相关操作 进行相关操作 //////////////////////////////////////////////////////////////////////////////// // 下面以pos前面元素少的情形进行说明, 为了简化, 假设操作不会超过一个缓冲区区间 // // 插入前状态 // start pos end // ↓ ↓ ↓ // --------------------------------------------------------------------- // | | | | | | | | | | | | | | | | | X | // --------------------------------------------------------------------- // // 需要进行操作的区间 // 需要拷贝的区间 // ------------- // start | | end // ↓ ↓ ↓ ↓ // --------------------------------------------------------------------- // | | | | | | | | | | | | | | | | | X | // --------------------------------------------------------------------- // ↑ ↑ ↑ ↑ // front1 | | | // | | | // front2 | | // | | // pos | // | // pos1 // 拷贝操作完成后 // // 这是[front2, pos1) // ------------- --------- 这里是给待插入元素预留的空间 // start | | | end // ↓ ↓ ↓ ↓ ↓ // --------------------------------------------------------------------- // | | | | | | | | | | | | | | | | | X | // --------------------------------------------------------------------- // ↑ // 这里存储的是原来的front() // //////////////////////////////////////////////////////////////////////////////// template &lt;class T, class Alloc, size_t BufSize&gt; typename deque&lt;T, Alloc, BufSize&gt;::iterator deque&lt;T, Alloc, BufSize&gt;::insert_aux(iterator pos, const value_type&amp; x) &#123; difference_type index = pos - start; // 插入点之前的元素个数 value_type x_copy = x; // 前面的时候用的移位操作, 这里怎么不用了呢^_^? if (index &lt; size() / 2) // 如果插入点之前的元素个数比较少 &#123; push_front(front()); // 在最前端加入与第一元素同值的元素 iterator front1 = start; // 以下标示记号，然后进行元素移动 ++front1; iterator front2 = front1; ++front2; pos = start + index; iterator pos1 = pos; ++pos1; copy(front2, pos1, front1); // 元素移动 &#125; else // 插入点之后的元素个数比较少 &#123; push_back(back()); // 在最尾端加入与最后元素同值的元素 iterator back1 = finish; // 以下标示记号，然后进行元素移动 --back1; iterator back2 = back1; --back2; pos = start + index; copy_backward(pos, back2, back1); // 元素移动 &#125; *pos = x_copy; // 在插入点上设定新值 return pos; &#125; 源网址 STL源码剖析——deque的实现原理和使用方法详解 STL源码剖析—deque","tags":[{"name":"deque","slug":"deque","permalink":"http://yoursite.com/tags/deque/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"container","slug":"C-语言/container","permalink":"http://yoursite.com/categories/C-语言/container/"},{"name":"deque","slug":"C-语言/container/deque","permalink":"http://yoursite.com/categories/C-语言/container/deque/"}]},{"title":"Markdown公式编辑","date":"2018-06-25T04:11:12.000Z","path":"wiki/工具/markdowm/Markdown公式编辑学习笔记/","text":"Markdown中使用LaTEX 编写含有数学公式的博客。 如何插入公式 行中公式（放在文中与其他文字编辑）：可以用如下方法表示：$数学公式$ 独立公式可以用下面的方法表示：$$数学公式$$ 自动编号的公式可以用如下的方法表示：12345\\begin&#123;equation&#125;数学公式\\label&#123;eq:当前公式名&#125;\\end&#123;equation&#125;自动编号后的公式可在全文任意处使用 \\eqref&#123;eq:公式名&#125; 语句引用。 例子 1$ J_\\alpha(x) = \\sum_&#123;m=0&#125;^\\infty \\frac&#123;(-1)^m&#125;&#123;m! \\gamma (m + \\alpha + 1)&#125; &#123;\\left(&#123; \\frac&#123;x&#125;&#123;2&#125; &#125;\\right)&#125;^&#123;2m + \\alpha&#125; \\text &#123;，not one line &#125; $ 显示$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，not one line } $ 例子 1$$ J_\\alpha(x) = \\sum_&#123;m=0&#125;^\\infty \\frac&#123;(-1)^m&#125;&#123;m! \\gamma (m + \\alpha + 1)&#125; &#123;\\left(&#123; \\frac&#123;x&#125;&#123;2&#125; &#125;\\right)&#125;^&#123;2m + \\alpha&#125; \\text &#123;，独立公式示例&#125;$$ 显示 $$ J_\\alpha(x) = \\sum_{m=0}^\\infty \\frac{(-1)^m}{m! \\gamma (m + \\alpha + 1)} {\\left({ \\frac{x}{2} }\\right)}^{2m + \\alpha} \\text {，独立公式示例} $$ 下标^ 表示上标， _ 表示下标。如果上下标的内容多于一个字符，需要用{}将这些内容括成一个整体。上下标可以嵌套，也可以同时使用。 例子 1$$ x^&#123;y^z&#125;=(1+&#123;\\rm e&#125;^x)^&#123;-2xy^w&#125; $$ 显示 $$ x^{y^z}=(1+{\\rm e}^x)^{-2xy^w} $$ 另外，如果要在左右两边都有上下标，可以用\\sideset 命令 例子： 1$$ \\sideset&#123;^1_2&#125;&#123;^3_4&#125;\\bigotimes $$ 显示 $$ \\sideset{^1_2}{^3_4}\\bigotimes $$ 括号和分隔符()、[]和|表示符号本身，使用 \\{\\} 来表示 {}。当要显示大号的括号或分隔符时，要用 \\left 和 \\right 命令。一些特殊的括号： 输入 显示 $$\\langle表达式\\rangle$$ $$\\langle表达式\\rangle$$ $$\\lceil表达式\\rceil$$ $$\\lceil表达式\\rceil$$ $$\\lfloor表达式\\rfloor$$ $$\\lfloor表达式\\rfloor$$ $$\\lbrace表达式\\rbrace$$ $$\\lbrace表达式\\rbrace$$ 例子 1$$ f(x,y,z) = 3y^2z \\left( 3+\\frac&#123;7x+5&#125;&#123;1+y^2&#125; \\right) $$ 显示$$ f(x,y,z) = 3y^2z \\left( 3+\\frac{7x+5}{1+y^2} \\right) $$ 分数通常使用 \\frac {分子} {分母}命令产生一个分数\\frac {分子} {分母}，分数可嵌套。便捷情况可直接输入 \\frac ab来快速生成一个\\frac ab。如果分式很复杂，亦可使用 分子 \\over 分母 命令，此时分数仅有一层。 例子： 1$$\\frac&#123;a-1&#125;&#123;b-1&#125; \\quad and \\quad &#123;a+1\\over b+1&#125;$$ 显示 $$\\frac{a-1}{b-1} \\quad and \\quad {a+1\\over b+1}$$ 开方使用 \\sqrt [根指数，省略时为2] {被开方数}命令输入开方。 例子： $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ 显示 $$\\sqrt{2} \\quad and \\quad \\sqrt[n]{3}$$ 省略号数学公式中常见的省略号有两种，\\ldots 表示与文本底线对齐的省略号，\\cdots 表示与文本中线对齐的省略号。 例子： 1$$f(x_1,x_2,\\underbrace&#123;\\ldots&#125;_&#123;\\rm ldots&#125; ,x_n) = x_1^2 + x_2^2 + \\underbrace&#123;\\cdots&#125;_&#123;\\rm cdots&#125; + x_n^2$$ 显示： $$f(x_1,x_2,\\underbrace{\\ldots}_{\\rm ldots} ,x_n) = x_1^2 + x_2^2 + \\underbrace{\\cdots}_{\\rm cdots} + x_n^2$$ 矢量使用 \\vec{矢量}来自动产生一个矢量。也可以使用 \\overrightarrow等命令自定义字母上方的符号。 例子： 1$$\\vec&#123;a&#125; \\cdot \\vec&#123;b&#125;=0$$ 显示： 例子： 1$$\\overleftarrow&#123;xy&#125; \\quad and \\quad \\overleftrightarrow&#123;xy&#125; \\quad and \\quad \\overrightarrow&#123;xy&#125;$$ 显示：$$\\overleftarrow{xy} \\quad and \\quad \\overleftrightarrow{xy} \\quad and \\quad \\overrightarrow{xy}$$ 积分使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 例子： 1$$\\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x$$ 显示： $$\\int_0^1 {x^2} \\,{\\rm d}x$$ 字体 输入 说明 显示 \\rm 罗马体 $$\\rm Sample$$ \\it 意大利体 $$\\it Sample $$ \\bf 粗体 $$\\bf Sample $$ \\sf 等线体 $$\\sf Sample $$ \\tt 打字机体 $$\\tt Sample $$ \\frak 旧德式字体 $$\\frak Sample $$ \\cal 花体 $$\\cal Sample $$ \\Bbb 黑板粗体 $$\\Bbb Sample $$ \\mit 数学斜体 $$\\mit Sample $$ \\scr 手写体 $$\\scr Sample$$ 积分使用 \\int_积分下限^积分上限 {被积表达式} 来输入一个积分。 例子： 1$$\\int_0^1 &#123;x^2&#125; \\,&#123;\\rm d&#125;x$$ 显示$$\\int_0^1 {x^2} \\,{\\rm d}x$$ 极限使用\\lim_{变量 \\to 表达式} 表达式 来输入一个极限。如有需求，可以更改 \\to 符号至任意符号。 例子： 1$$ \\lim_&#123;n \\to +\\infty&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; \\quad and \\quad \\lim_&#123;x\\leftarrow&#123;示例&#125;&#125; \\frac&#123;1&#125;&#123;n(n+1)&#125; $$ 显示： $$ \\lim_{n \\to +\\infty} \\frac{1}{n(n+1)} \\quad and \\quad \\lim_{x\\leftarrow{示例}} \\frac{1}{n(n+1)} $$ 参考 Cmd Markdown 公式指导手册 markdown中公式编辑教程","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://yoursite.com/tags/Markdown/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"markdowm","slug":"工具/markdowm","permalink":"http://yoursite.com/categories/工具/markdowm/"}]},{"title":"数学知识一对数指数","date":"2018-06-25T04:07:12.000Z","path":"wiki/数学知识/数学基础知识/","text":"对数解换底公式为： $$ \\log_ab = \\frac {\\log_cb}{\\log_ca} \\quad \\quad \\text{(c＞0，c≠1)} $$ loga（b）=logc（b）/logc（a）（c＞0，c≠1）推导过程 令 $ \\log_a{b} = t $ 即 $ a^t = b$ 即a^t=b 两边取以c（c＞0，c≠1）的对数 即 $ \\log_c(a^t) =\\log_cb $ 即 $t\\log_c{a}=log_cb 由a≠1，即 $ \\log_c{a}≠0$ 所以 $t=\\frac{log_cb}{log_ca} $ 所以： $log_ab= \\frac{log_cb}{log_ca}$","tags":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/tags/数学知识/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"}]},{"title":"运算符优先级表","date":"2018-06-23T04:07:12.000Z","path":"wiki/C++语言/C++Primer/第四章 表达式/运算符优先级表/","text":"C++ 运算符优先级 结合律 运算符 功能 用法 左 :: 全局作用域 ::name 左 :: 类作用域 class::name 左 :: 命名空间作用域 namespace::name 左 . 成员选择 object.member 左 -&gt; 成员选择 pointer-&gt;member 左 [] 下标 expr[expr] 左 () 函数调用 name(expr_lit) 左 () 类型构造 type(expr_lit) 右 ++ 后置递增运算 lvalue++ 右 – 后置递减运算 lvalue– 右 typeid 类型ID typeid(type) 右 typeid 运行时类型ID typeid(expr) 右 explicit cast 类型转换 cast_name(expr) 右 ++ 前置递增运算 ++lvalue 右 – 前置递减运算 –lvalue 右 ~ 位求反 ~expr 右 ! 逻辑非 !expr 右 - 一元负号 -expr 右 + 一元正号 +expr 右 * 解引用 *expr 右 &amp; 取地址 &amp;lvalue 右 () 类型转换 (type)expr 右 sizeof 对象大小 sizeof expr 右 sizeof 类型大小 sizeof(type) 右 Sizeof… 参数包的大小 sizeof…(name) 右 new 创建对象 new type 右 new [] 创建数组 new type[size] 右 delete 释放对象 delete expr 右 delete [] 释放数组 delete [] expr 右 noexcept 能否抛出异常 noexcept(expr) 左 -&gt;* 指向成员选择的指针 ptr-&gt;*prt_to_member 左 .* 指向成员选择的指针 obj.*prt_to_member 左 * 乘法 expr*expr 左 / 除法 expr/expr 左 % 取模（取余） expr%expr 左 + 加法 expr + expr 左 - 减法 expr -expr 左 &lt;&lt; 向左移位 expr &lt;&lt; expr 左 &gt;&gt; 向右移位 expr &gt;&gt; expr 左 &lt; 小于 expr &lt; expr 左 &lt;= 小于等于 expr &lt;=expr 左 &gt; 大于 expr &gt; expr 左 &gt;= 大于等于 expr &gt;= expr 左 == 相等 expr == expr 左 != 不相等 expr != expr 左 &amp; 位与 expr &amp; expr 左 ^ 位异或 expr ^ expr 左 ` ` 位或 `expr expr` 左 &amp;&amp; 逻辑与 expr &amp;&amp; expr 左 ` ` 逻辑或 `expr expr` 左 ?: 条件 expr?expr:expr 左 = 赋值 lvalue = expr 左 *=,/-,%= 符合赋值 lvalue+=expr等 左 +=,-= 符合赋值 左 &lt;&lt;=,&gt;&gt;= 符合赋值 左 &amp;=,` =`,^= 符合赋值 右 throw 抛出异常 throw expr 左 , 逗号 expr,expr","tags":[{"name":"运算符优先级","slug":"运算符优先级","permalink":"http://yoursite.com/tags/运算符优先级/"}],"categories":[{"name":"C++语言","slug":"C-语言","permalink":"http://yoursite.com/categories/C-语言/"},{"name":"C++Primer","slug":"C-语言/C-Primer","permalink":"http://yoursite.com/categories/C-语言/C-Primer/"},{"name":"第四章 表达式","slug":"C-语言/C-Primer/第四章-表达式","permalink":"http://yoursite.com/categories/C-语言/C-Primer/第四章-表达式/"}]},{"title":"mach-o Viewer 源码学习","date":"2018-06-22T04:07:12.000Z","path":"wiki/IOS/MachO/machoviewer/","text":"本文是 mach-o Viewer 源码学习记录。","tags":[{"name":"macho","slug":"macho","permalink":"http://yoursite.com/tags/macho/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"MachO","slug":"IOS/MachO","permalink":"http://yoursite.com/categories/IOS/MachO/"}]},{"title":"图解fishhook","date":"2018-06-21T04:07:12.000Z","path":"wiki/IOS/opensource/fishhook/fishHookPicture/","text":"本文尝试9图片解释fishhook原理 图1. load command中_DATA segement中__la_symbol_ptr section结构图,说明该section和动态符号表对应的起始索引是146 图2.数据区域中__la_symbol_ptr的结构,可以看出该section的起始地址是0x00240B0，图2和图3是为了找malloc函数指针的位置 图3.数据区域中__la_symbol_ptr的结构, 偏移了一定的位置。文件0x000242B0地址出存储的是malloc函数指针。 计算偏移数量的方法：0x242B0 - 0x240B0 = 0x200每个条目占用8个字节0x200/0x8 = 0x40 = 64得出：在符号表中，malloc偏移64个条目 图4 .转到数据区域中动态符号表的起始位置处，该图说明动态符号表的起始地址是0x3B0A4 图5 。 计算la_symbol_ptr 对应的符号在动态符号表中的位置： 0x3B060 + 146*4 = 0x3B060 + 0x248 = 0x3B2A8，地址0x0003B2A8处后面的符号和la_symbol_ptr中的条目对应。 图6 . 查找64个偏移后的动态符号表的地址：0x3B2A8 + 0x40*x4 = 0x3B3A8，地址0x3B3A8中存储的值是符号表中的索引，为0xb32。由于machoviewer看不到符号表，所以用代码查看符号表中索引为0xB32 的符号信息。 查看代码：struct nlist_64 const * mallocNlist =[self getSymbol64ByIndex:0xB32]; 图7 .代码查看符号表示意图。符号表的索引为0xB32的符号的信息。可以看出n_strx的值是0x2B07，这个值指的是string表中的偏移量 图8 .string 表，string表的起始地址是0x3B498 图9 .string 表， 偏移0x2B07 后的结果—— 0x3B498 + 0x2B07 = 0x3DF9F， 这个地址存储的字符串就是图3中 地址为0x10001ef10的函数指针的名称，名称是malloc。这个名称和我么要替换的名称一致，所以替换图3中的0x10001ef10，替换成新指定函数指针地址。实现替换。","tags":[{"name":"图解fishhook","slug":"图解fishhook","permalink":"http://yoursite.com/tags/图解fishhook/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"fishhook","slug":"IOS/opensource/fishhook","permalink":"http://yoursite.com/categories/IOS/opensource/fishhook/"}]},{"title":"fishhook学习记录","date":"2018-06-20T04:07:12.000Z","path":"wiki/IOS/opensource/fishhook/learn_fishhook/","text":"fishhook是一个可以替换C函数的开源库，官网的readme讲解了重新绑定的原理。本文从源码的角度去学习fishhook。 源码示意图先给个简单的源码示意图。循序渐进理解啊。直接上源码有点懵，几个函数名称太相似了。不过呢，看图，好像就四个函数、247行代码而已。 源码解读源码使用OOMDetector，OOMDetector使用fishhook替换malloc函数。使用OOMDetector的目的是顺便可以学习fishhook api的调用方式，同时也能学习fishhook源码。 首先，fishhook定义了一个结构体，存储绑定的数据。定义如下： 12345struct rebinding &#123; const char *name; //替换的函数名字 void *replacement; //替换后的函数指针 void **replaced; //原始的方法&#125;; 下面的替换malloc等函数的入口函数，该函数调用了fishhook的rebind_symbols_for_imagename函数。 123456789101112131415161718192021222324252627void hookMalloc()&#123; if(!isPaused)&#123; beSureAllRebindingFuncBeenCalled(); orig_malloc = malloc; orig_calloc = calloc; orig_valloc = valloc; orig_realloc = realloc; orig_block_copy = _Block_copy; rebind_symbols_for_imagename( (struct rebinding[5])&#123; &#123;\"realloc\",(void*)new_realloc,(void**)&amp;orig_realloc&#125;, &#123;\"malloc\", (void*)new_malloc, (void **)&amp;orig_malloc&#125;, &#123;\"valloc\",(void*)new_valloc,(void**)&amp;orig_valloc&#125;, &#123;\"calloc\",(void*)new_calloc,(void**)&amp;orig_calloc&#125;, &#123;\"_Block_copy\",(void*)new_block_copy,(void**)&amp;orig_block_copy&#125;&#125;, 5, getImagename()); &#125; else&#123; isPaused = false; &#125;&#125; hookMalloc替换了realloc、malloc、valloc、calloc、_Block_copy这几个函数。 下面是新的new_malloc函数定义： 1234567891011void *new_malloc(size_t size)&#123; void *ptr = orig_malloc(size); if(!isPaused)&#123; global_leakChecker-&gt;recordMallocStack((vm_address_t)ptr, (uint32_t)size,\"malloc\",2); &#125;#ifdef __enable_malloc_logger__ malloc_printf(\"malloc ptr:%p size:%lu thread:%lu\\n\",ptr, size,mach_thread_self());#endif return ptr;&#125; new_malloc函数首先会调用原来的malloc函数，接着会记录申请的内存的堆栈。 下面是原始函数的定义： 12345static void* (*orig_malloc)(size_t);static void* (*orig_calloc)(size_t, size_t);static void* (*orig_realloc)(void *, size_t);static void* (*orig_valloc)(size_t);static void* (*orig_block_copy)(const void *aBlock); 下面是rebind_symbols_for_imagename第三个入参————镜像名称的获取方式： 123456789const char *getImagename(void)&#123; const char* name = _dyld_get_image_name(0); const char* tmp = strrchr(name, '/'); if (tmp) &#123; name = tmp + 1; &#125; return name;&#125; 调用了&lt;mach-o/dyld.h&gt; 头文件中的_dyld_get_image_name函数。 _dyld_get_image_name 根据镜像的索引，获取镜像的名称。strrchr函数是反向查找第一个给定字符。返回第一次匹配到的地址指针。 下面代码进入fishhook的入口函数rebind_symbols_for_imagename。 12345678910111213141516171819202122void rebind_symbols_for_imagename(struct rebinding rebindings[], size_t rebindings_nel, const char *imagename)&#123; uint32_t count = _dyld_image_count(); for (uint32_t i = 0; i &lt; count; i++) &#123; const mach_header_t* header = (const mach_header_t*)_dyld_get_image_header(i); const char* name = _dyld_get_image_name(i); const char* tmp = strrchr(name, '/'); long slide = _dyld_get_image_vmaddr_slide(i); if (tmp) &#123; name = tmp + 1; &#125; if(strcmp(name,imagename) == 0)&#123; rebind_symbols_image((void *)header, slide, rebindings, rebindings_nel); break; &#125; &#125;&#125; rebindings承载重新绑定的所有信息，rebindings_nel是rebindings的个数，imagename要替换函数指针镜像名称，也就是只替换名称为imagename文件中的函数指针，其他库不做替换。 _dyld_get_image_header 获取镜像的header头，_dyld_get_image_vmaddr_slide获取镜像的随机启动地址。rebind_symbols_for_imagename函数为重新绑定做准备，增加了两个参数，header、slide。header就是加载到内存的中二进制文件的头。slide 的是ALSR技术中的随机启动地址。这个地址的含义可以参考iOS crash reports: atos not working as expected、 iOS crash log 解析 symbol address = stack address - slide 运行时获取slide的api 利用dwarfdump从dsym文件中得到symbol 。 下面为了理解ALSR中的slide，贴出一段测试代码： 12345678910111213void understandALSR()&#123; ///枚举所有镜像 for (int i = 0; i &lt; _dyld_image_count(); i++) &#123; char *image_name = (char *)_dyld_get_image_name(i); const struct mach_header *mh = _dyld_get_image_header(i); intptr_t vmaddr_slide = _dyld_get_image_vmaddr_slide(i); printf(\"Image name %s ,image header 0x%llx , ASLR slide 0x%lx.\\n\", image_name, (mach_vm_address_t)mh, vmaddr_slide); &#125;&#125; 输出如下： 1234Image name /Users/lijian/Library/Developer/CoreSimulator/Devices/21045765-7E1F-499B-A985-1BCCFC70B079/data/Containers/Bundle/Application/0975D79D-5079-4258-8A0F-48175818A28A/LearnMachO.app/LearnMachO ,image header 0x10dff0000 , ASLR slide 0xdff0000.Image name /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/libBacktraceRecording.dylib ,image header 0x10e07c000 , ASLR slide 0x10e07c000.Image name /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/usr/lib/libMainThreadChecker.dylib ,image header 0x10e08b000 , ASLR slide 0x10e08b000.Image name /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/Developer/Library/PrivateFrameworks/DTDDISupport.framework/libViewDebuggerSupport.dylib ,image header 0x10e27d000 , ASLR slide 0x10e27d000. 代码对应的二进制文件中的加载地址（链接时load address）示意图：结合上面的示例代码和二进制内容图片，可以诠释下面的公式： 12slide = (运行时)load address - (链接时)load address;symble address ＝ stack address －slide； 其中： stack address ： 程序运行时线程栈中 所有 函数调用的地址 symble address ： dsym文件中函数符号对应的地址，用此地址在dsym 文件中可以查出对应的符号信息。 可以看出，没有ASLR时： 1symble address = stack address 好了，接着看rebind_symbols_image函数： 12345678910int rebind_symbols_image(void *header, intptr_t slide, struct rebinding rebindings[], size_t rebindings_nel) &#123; struct rebindings_entry *rebindings_head = NULL; int retval = prepend_rebindings(&amp;rebindings_head, rebindings, rebindings_nel); rebind_symbols_for_image(rebindings_head, header, slide); free(rebindings_head); return retval;&#125; rebind_symbols_image 主要工作是通过prepend_rebindings构造绑定的结构体struct rebindings_entry，定义如下： 12345struct rebindings_entry &#123; struct rebinding *rebindings; size_t rebindings_nel; struct rebindings_entry *next;&#125;; 1234567891011121314151617181920212223242526static int prepend_rebindings(struct rebindings_entry **rebindings_head, struct rebinding rebindings[], size_t nel) &#123; ///申请new_entry地址 struct rebindings_entry *new_entry = malloc(sizeof(struct rebindings_entry)); if (!new_entry) &#123; return -1; &#125; ///给new_entry-&gt;rebindings分配内存 new_entry-&gt;rebindings = malloc(sizeof(struct rebinding) * nel); if (!new_entry-&gt;rebindings) &#123; free(new_entry); return -1; &#125; ///拷贝重新绑定信息到new_entry-&gt;rebindings memcpy(new_entry-&gt;rebindings, rebindings, sizeof(struct rebinding) * nel); new_entry-&gt;rebindings_nel = nel; new_entry-&gt;next = *rebindings_head; ///这个将创建的new_entry赋值给rebindings_head，通过二级指针返回给调用者 *rebindings_head = new_entry; return 0;&#125; prepend_rebindings 只是将绑定的struct rebinding类型参数转化为struct rebindings_entry结构，这种结构类似链表，可以方便的管理多个struct rebinding结构。下面看rebind_symbols_for_image： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static void rebind_symbols_for_image(struct rebindings_entry *rebindings, const struct mach_header *header, intptr_t slide) &#123; Dl_info info; ///find the image containing a given address ///验证库是否存在 if (dladdr(header, &amp;info) == 0) &#123; return; &#125; segment_command_t *cur_seg_cmd; ///SEG_LINKEDIT commond指针 segment_command_t *linkedit_segment = NULL; ///LC_SYMTAB commond指针 struct symtab_command* symtab_cmd = NULL; ///LC_DYSYMTAB commond指针 struct dysymtab_command* dysymtab_cmd = NULL; ///定位linkedit_segment、symtab_cmd、dysymtab_cmd三指针 uintptr_t cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_LINKEDIT) == 0) &#123; linkedit_segment = cur_seg_cmd; &#125; &#125; else if (cur_seg_cmd-&gt;cmd == LC_SYMTAB) &#123; symtab_cmd = (struct symtab_command*)cur_seg_cmd; &#125; else if (cur_seg_cmd-&gt;cmd == LC_DYSYMTAB) &#123; dysymtab_cmd = (struct dysymtab_command*)cur_seg_cmd; &#125; &#125; if (!symtab_cmd || !dysymtab_cmd || !linkedit_segment || !dysymtab_cmd-&gt;nindirectsyms) &#123; return; &#125; // Find base symbol/string table addresses 查找符号表和string表 uintptr_t linkedit_base = (uintptr_t)slide + linkedit_segment-&gt;vmaddr - linkedit_segment-&gt;fileoff; nlist_t *symtab = (nlist_t *)(linkedit_base + symtab_cmd-&gt;symoff); char *strtab = (char *)(linkedit_base + symtab_cmd-&gt;stroff); // Get indirect symbol table (array of uint32_t indices into symbol table) uint32_t *indirect_symtab = (uint32_t *)(linkedit_base + dysymtab_cmd-&gt;indirectsymoff); cur = (uintptr_t)header + sizeof(mach_header_t); for (uint i = 0; i &lt; header-&gt;ncmds; i++, cur += cur_seg_cmd-&gt;cmdsize) &#123; cur_seg_cmd = (segment_command_t *)cur; if (cur_seg_cmd-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) &#123; if (strcmp(cur_seg_cmd-&gt;segname, SEG_DATA) != 0 &amp;&amp; strcmp(cur_seg_cmd-&gt;segname, SEG_DATA_CONST) != 0) &#123; continue; &#125; //找到类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section for (uint j = 0; j &lt; cur_seg_cmd-&gt;nsects; j++) &#123; section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; if ((sect-&gt;flags &amp; SECTION_TYPE) == S_NON_LAZY_SYMBOL_POINTERS) &#123; perform_rebinding_with_section(rebindings, sect, slide, symtab, strtab, indirect_symtab); &#125; &#125; &#125; &#125;&#125; rebind_symbols_for_image 函数主要定位到三表、类型为S_LAZY_SYMBOL_POINTERS、S_NON_LAZY_SYMBOL_POINTERS类型的section。然后调用perform_rebinding_with_section 函数。其中部分宏定义如下。 1234#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64#define SEG_LINKEDIT \"__LINKEDIT\"#define S_NON_LAZY_SYMBOL_POINTERS 0x6 /* section with only non-lazy symbol pointers */#define S_LAZY_SYMBOL_POINTERS 0x7 /* section with only lazy symbol 上面的宏定义于&lt;mach-o/loader.h&gt;文件中，位于458行。 在S_NON_LAZY_SYMBOL_POINTERS宏的上面有一段注释。这段注释非常的关键。说明了S_NON_LAZY_SYMBOL_POINTERS类型的section中的数据和动态符号表中的符号是顺序对应的。只有理解了这段内容。才能真正的理解fishhook。 For the two types of symbol pointers sections and the symbol stubs section they have indirect symbol table entries. 对于存储符号指针、符号存根两种类型的section，它们有间接符号表条目。 For each of the entries in the section,the indirect symbol table entries, in corresponding order in the indirect symbol table, start at the index stored in the reserved1 field of the section structure. 间接符号表条目顺序对应section中的条目，对应从section的reserved1索引开始。 Since the indirect symbol table entries correspond to the entries in the section the number of indirect symbol table entries is inferred from the size of the section divided by the size of the entries in the section. For symbol pointers sections the size of the entries in the section is 4 bytes (看结构是8bytes，可能是64位的缘故) 由于间接符号表条目对应于section中的条目，因此间接符号表条目的数量由section的大小除以section中的条目的大小来推断。对于符号指针节，section中的条目的大小是4个字节 下面是perform_rebinding_with_section函数源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960static void perform_rebinding_with_section(struct rebindings_entry *rebindings, section_t *section, //section intptr_t slide, //基址 nlist_t *symtab, //符号表 char *strtab, //sting 表 uint32_t *indirect_symtab //动态符号表 )&#123; ///动态符号表 对应section的地址，动态符号表的基地址+section对应的偏移量 uint32_t *indirect_symbol_indices = indirect_symtab + section-&gt;reserved1; ///section加载到内存的虚拟地址（是要替换这里面的东西） void **indirect_symbol_bindings = (void **)((uintptr_t)slide + section-&gt;addr); ///section中替换函数指针 for (uint i = 0; i &lt; section-&gt;size / sizeof(void *); i++) &#123; //由于section中条目和动态符号表中的条目对应，所以将section中的条目索引i用于动态符号表。 ///下面目的是获取section中存储的函数指针的符号 动态符号表-&gt; 符号表-&gt; string表 //indirect_symbol_indices[i]中存储符号表的索引。symtab_index就是符号表的索引 uint32_t symtab_index = indirect_symbol_indices[i]; if (symtab_index == INDIRECT_SYMBOL_ABS || symtab_index == INDIRECT_SYMBOL_LOCAL || symtab_index == (INDIRECT_SYMBOL_LOCAL | INDIRECT_SYMBOL_ABS)) &#123; continue; &#125; ///通过nlist_t的n_strx找到String表的偏移地址，strtab_offset。 uint32_t strtab_offset = symtab[symtab_index].n_un.n_strx; char *symbol_name = strtab + strtab_offset; if (strnlen(symbol_name, 2) &lt; 2) &#123; continue; &#125; ///依次枚举struct rebindings_entry 结构，判断时候有和当前函数指针相等的带替换的函数。 struct rebindings_entry *cur = rebindings; while (cur) &#123; for (uint j = 0; j &lt; cur-&gt;rebindings_nel; j++) &#123; ///如果符号名称和替换的名称一样，进行替换 if (strcmp(&amp;symbol_name[1], cur-&gt;rebindings[j].name) == 0) &#123; if (cur-&gt;rebindings[j].replaced != NULL &amp;&amp; indirect_symbol_bindings[i] != cur-&gt;rebindings[j].replacement) &#123; ///保存原始的指针地址，只保存一次 *(cur-&gt;rebindings[j].replaced) = indirect_symbol_bindings[i]; &#125; ///在section中替换。将indirect_symbol_bindings[i]中存储的函数指针地址进行替换。 indirect_symbol_bindings[i] = cur-&gt;rebindings[j].replacement; goto symbol_loop; &#125; &#125; cur = cur-&gt;next; &#125; symbol_loop:; &#125;&#125; perform_rebinding_with_section函数完成替换的关键函数。 将section中的函数指针替换为新的函数指针。 参考Fishhook替换C函数的原理","tags":[{"name":"fishhook","slug":"fishhook","permalink":"http://yoursite.com/tags/fishhook/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"opensource","slug":"IOS/opensource","permalink":"http://yoursite.com/categories/IOS/opensource/"},{"name":"fishhook","slug":"IOS/opensource/fishhook","permalink":"http://yoursite.com/categories/IOS/opensource/fishhook/"}]},{"title":"Xcode编译环境变量","date":"2018-06-06T04:07:12.000Z","path":"wiki/工具/Xcode编译常量/xcode编译环境变量/","text":"看图吧","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Xcode编译常量","slug":"工具/Xcode编译常量","permalink":"http://yoursite.com/categories/工具/Xcode编译常量/"}]},{"title":"合并真机模拟器静态库(转载)","date":"2018-06-06T04:07:12.000Z","path":"wiki/IOS/动态库/static_lib_aggregate_script/","text":"这篇文章解释合并真机模拟器静态库的脚本 合成脚本合并的脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657if [ \"$&#123;ACTION&#125;\" = \"build\" ]then#要build的target名target_Name=$&#123;PROJECT_NAME&#125; echo \"target_Name=$&#123;target_Name&#125;\"#build之后的文件夹路径build_DIR=$&#123;SRCROOT&#125;/build echo \"build_DIR=$&#123;build_DIR&#125;\"#真机build生成的头文件的文件夹路径DEVICE_DIR_INCLUDE=$&#123;build_DIR&#125;/Release-iphoneos/include/$&#123;PROJECT_NAME&#125; echo \"DEVICE_DIR_INCLUDE=$&#123;DEVICE_DIR_INCLUDE&#125;\"#真机build生成的.a文件路径DEVICE_DIR_A=$&#123;build_DIR&#125;/Release-iphoneos/lib$&#123;PROJECT_NAME&#125;.a echo \"DEVICE_DIR_A=$&#123;DEVICE_DIR_A&#125;\"#模拟器build生成的.a文件路径SIMULATOR_DIR_A=$&#123;build_DIR&#125;/Release-iphonesimulator/lib$&#123;PROJECT_NAME&#125;.a echo \"SIMULATOR_DIR_A=$&#123;SIMULATOR_DIR_A&#125;\"#目标文件夹路径INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125; echo \"INSTALL_DIR=$&#123;INSTALL_DIR&#125;\"#目标头文件文件夹路径INSTALL_DIR_Headers=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;/Headers echo \"INSTALL_DIR_Headers=$&#123;INSTALL_DIR_Headers&#125;\"#目标.a路径INSTALL_DIR_A=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;/lib$&#123;PROJECT_NAME&#125;.a echo \"INSTALL_DIR_A=$&#123;INSTALL_DIR_A&#125;\"#判断build文件夹是否存在，存在则删除if [ -d \"$&#123;build_DIR&#125;\" ]thenrm -rf \"$&#123;build_DIR&#125;\"fi#判断目标文件夹是否存在，存在则删除该文件夹if [ -d \"$&#123;INSTALL_DIR&#125;\" ]thenrm -rf \"$&#123;INSTALL_DIR&#125;\"fi#创建目标文件夹mkdir -p \"$&#123;INSTALL_DIR&#125;\"#build之前clean一下xcodebuild -target $&#123;target_Name&#125; clean#模拟器buildxcodebuild -target $&#123;target_Name&#125; -configuration Release -sdk iphonesimulator#真机buildxcodebuild -target $&#123;target_Name&#125; -configuration Release -sdk iphoneos#复制头文件到目标文件夹cp -R \"$&#123;DEVICE_DIR_INCLUDE&#125;\" \"$&#123;INSTALL_DIR_Headers&#125;\"#合成模拟器和真机.a包lipo -create \"$&#123;DEVICE_DIR_A&#125;\" \"$&#123;SIMULATOR_DIR_A&#125;\" -output \"$&#123;INSTALL_DIR_A&#125;\"#打开目标文件夹open \"$&#123;INSTALL_DIR&#125;\"fi 铺路本代码中用到的核心命令： xcodebuild苹果给的一个命令。主要用来编译Xcode的工程。可以在终端中输入xcodebuild -h来查看命令的详情，介绍一下本脚本中用到的几个参数 clean:clean一下工程 -configuration Release使用Release方式编译，还可以使用Debug -sdk iphoneos真机编译，还可以使用-sdk iphonesimulator模拟器编译 cp “源文件路径” “目标文件路径”复制”源文件路径”的文件到 “目标文件路径” lipolipo -create “模拟器.a文件路径” “真机.a文件路径” -output “目标.a文件路径” 将模拟器和真机的.a包合成。 用到的一些shell脚本基础命令echo “你要写的东西”打印的log,将”你要写的东西”打印出来，相当于OC中的NSLogXcode的话，运行脚本后，可以在这里找到log 赋值命令。 变量名=变量值比如将”CrazyStone”赋值给MyName变量 MyName=CrazyStone ${变量名}取出变量名的内容。比如：取出变量MyName中的内容${MyName} 判断语句if [ 条件语句 ]then…fi条件语句为真就执行then后面的语句，不成立就结束判断语句 本脚本中用到的判断语句：[ -d “文件夹路径” ] ：判断是否为文件夹 脚本结构解释看完上面，我想你再看一下代码应该就能理解脚本，然后可以做一些简单的改动了。下面再介绍一下脚本的结构。 执行条件– 编译1234if [ \"$&#123;ACTION&#125;\" = \"build\" ]then#我们的大部分脚本代码fi 执行脚本的时候做个判断，在Xcode里面build这个工程的时候就执行then后面的脚本 工程名称定义123#要build的target名target_Name=$&#123;PROJECT_NAME&#125; echo \"target_Name=$&#123;target_Name&#125;\" 变量target_Name是我们要编译的target的名字，在这里指的是工程的名字${PROJECT_NAME}，也就是MySDK。 顺便说一下，ACTION和PROJECT_NAME都是Xcode里面定义的，这是在Xcode里面写脚本的一个好处。 build 路径123456789101112131415#build之后的文件夹路径build_DIR=$&#123;SRCROOT&#125;/build echo \"build_DIR=$&#123;build_DIR&#125;\"#真机build生成的头文件的文件夹路径DEVICE_DIR_INCLUDE=$&#123;build_DIR&#125;/Release-iphoneos/include/$&#123;PROJECT_NAME&#125; echo \"DEVICE_DIR_INCLUDE=$&#123;DEVICE_DIR_INCLUDE&#125;\"#真机build生成的.a文件路径DEVICE_DIR_A=$&#123;build_DIR&#125;/Release-iphoneos/lib$&#123;PROJECT_NAME&#125;.a echo \"DEVICE_DIR_A=$&#123;DEVICE_DIR_A&#125;\"#模拟器build生成的.a文件路径SIMULATOR_DIR_A=$&#123;build_DIR&#125;/Release-iphonesimulator/lib$&#123;PROJECT_NAME&#125;.a echo \"SIMULATOR_DIR_A=$&#123;SIMULATOR_DIR_A&#125;\" 这里是定义的build之后各个文件的路径。我们执行了xcodebuild命令之后，会在工程目录生成一个build文件夹，里面有build之后生成的文件。打开Finder看看就知道各个文件的路径了。 build目录的位置1234567891011#目标文件夹路径INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125; echo \"INSTALL_DIR=$&#123;INSTALL_DIR&#125;\"#目标头文件文件夹路径INSTALL_DIR_Headers=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;/Headers echo \"INSTALL_DIR_Headers=$&#123;INSTALL_DIR_Headers&#125;\"#目标.a路径INSTALL_DIR_A=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;/lib$&#123;PROJECT_NAME&#125;.a echo \"INSTALL_DIR_A=$&#123;INSTALL_DIR_A&#125;\" 这里就是定义目标变量的路径了。你想把文件放在哪里？在这里定义咯。${SRCROOT}表示工程的根目录。用了这么久的Xcode，这个有用过吧(全局头文件配置过吧？)？ 文件状态判断12345678910111213#判断build文件夹是否存在，存在则删除if [ -d \"$&#123;build_DIR&#125;\" ]thenrm -rf \"$&#123;build_DIR&#125;\"fi#判断目标文件夹是否存在，存在则删除该文件夹if [ -d \"$&#123;INSTALL_DIR&#125;\" ]thenrm -rf \"$&#123;INSTALL_DIR&#125;\"fi#创建目标文件夹mkdir -p \"$&#123;INSTALL_DIR&#125;\" 这里就是文件的操作了。如果有这两个文件夹，就删除掉。为什么？为了保证我们工程的纯净啊。 编译12345678#build之前clean一下xcodebuild -target $&#123;target_Name&#125; clean#模拟器buildxcodebuild -target $&#123;target_Name&#125; -configuration Release -sdk iphonesimulator#真机buildxcodebuild -target $&#123;target_Name&#125; -configuration Release -sdk iphoneos 这里就跟平常操作一样了。先clean一下工程，然后模拟器编译一次，真机编译一次。 合并12345#复制头文件到目标文件夹cp -R \"$&#123;DEVICE_DIR_INCLUDE&#125;\" \"$&#123;INSTALL_DIR_Headers&#125;\"#合成模拟器和真机.a包lipo -create \"$&#123;DEVICE_DIR_A&#125;\" \"$&#123;SIMULATOR_DIR_A&#125;\" -output \"$&#123;INSTALL_DIR_A&#125;\" 关键代码。拷贝头文件到我们的目标位置去。合成.a包。大功告成。 打开目标文件夹12#打开目标文件夹open \"$&#123;INSTALL_DIR&#125;\" 最后，打开文件夹。检查一下文件是否真正生成了。 shell脚本基础知识如果你想了解更多关于shell脚本的知识，可以看看这篇文章：Linux shell脚本基础学习详细介绍 xcworkspace 工程对应的脚本12345#模拟器buildxcodebuild -workspace $&#123;target_Name&#125;.xcworkspace -scheme $&#123;target_Name&#125; -configuration $&#123;build_model&#125; -sdk iphonesimulator#真机buildxcodebuild -workspace $&#123;target_Name&#125;.xcworkspace -scheme $&#123;target_Name&#125; -configuration $&#123;build_model&#125; -sdk iphoneos 对于xcworkspace工程，需要将编译的脚本替换 ，其中–workspace、-scheme是必须的 ，scheme 可以通过xcodebuild -list 查看。 iOS设备架构模拟器：iPhone4s-iPnone5：i386iPhone5s-iPhone7 Plus：x86_64 真机:iPhone3gs-iPhone4s： armv7iPhone5-iPhone5c： armv7siPhone5s-iPhone7 Plus： arm64 参考【iOS开发】静态库.a文件合成脚本解释","tags":[{"name":"ios","slug":"ios","permalink":"http://yoursite.com/tags/ios/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"动态库","slug":"IOS/动态库","permalink":"http://yoursite.com/categories/IOS/动态库/"}]},{"title":"查看虚拟内存","date":"2018-06-02T04:07:12.000Z","path":"wiki/IOS/虚拟内存/虚拟内存之2/","text":"If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。 The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see Instruments User Guide and the other articles in this document. For information on how to use the top tool,以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅仪器用户指南和本文中的其他文章。有关如何使用顶部工具的信息，请参见2。see Performance Overview. Viewing Virtual Memory Statistics（查看虚拟内存统计信息）The vm_stat tool displays high-level statistics about the current virtual memory usage of the system. By default, vm_stat displays these statistics once, but you can specify an interval value (in seconds) to update these statistics continuously. For information on the usage of this tool, see the vm_stat man page.vm_stat工具显示关于系统当前虚拟内存使用情况的高级统计信息。默认情况下，vm_stat只显示这些统计信息一次，但是您可以指定一个间隔值(以秒为单位)来持续更新这些统计信息。有关此工具使用的信息，请参见vm_stat手册页。 Listing 1 shows an example of the output from vm_stat. 123456789101112Mach Virtual Memory Statistics: (page size of 4096 bytes)Pages free: 3194.Pages active: 34594.Pages inactive: 17870.Pages wired down: 9878.\"Translation faults\": 6333197.Pages copy-on-write: 81385.Pages zero filled: 3180051.Pages reactivated: 343961.Pageins: 33043.Pageouts: 78496.Object cache: 66227 hits of 96952 lookups (68% hit rate) Viewing Mach-O Code PagesThe pagestufftool displays information about the specified logical pages of a file conforming to the Mach-O executable format. For each specified page of code, symbols (function and static data structure names) are displayed. All pages in the TEXT, text section are displayed if no page numbers are given.pagestufftool显示符合Mach-O可执行格式的文件的指定逻辑页的信息。对于每个指定的代码页，将显示符号(函数和静态数据结构名称)。如果没有给出页码，则显示__TEXT节中的所有页面。 Listing 2 shows part of the output from pagestuff for the TextEdit application. This output is the result of running the tool with the -a option, which prints information about all of the executable’s code pages. It includes the virtual address locations of each page and the type of information on that page.清单2显示了TextEdit应用程序的页面内容的部分输出。此输出是使用-a选项运行工具的结果，该选项打印关于可执行文件的所有代码页的信息。它包括每个页面的虚拟地址位置和页面上的信息类型。 Listing 2 Partial output of pagestuff tool 12345678910111213141516171819202122232425262728File Page 0 contains Mach-O headersFile Page 1 contains Mach-O headersFile Page 2 contains contents of section (__TEXT,__text)Symbols on file page 2 virtual address 0x3a08 to 0x4000File Page 3 contains contents of section (__TEXT,__text)Symbols on file page 3 virtual address 0x4000 to 0x5000File Page 4 contains contents of section (__TEXT,__text)Symbols on file page 4 virtual address 0x5000 to 0x6000 ...File Page 22 contains contents of section (__TEXT,__cstring)File Page 22 contains contents of section (__TEXT,__literal4)File Page 22 contains contents of section (__TEXT,__literal8)File Page 22 contains contents of section (__TEXT,__const)Symbols on file page 22 virtual address 0x17000 to 0x17ffcFile Page 23 contains contents of section (__DATA,__data)File Page 23 contains contents of section (__DATA,__la_symbol_ptr)File Page 23 contains contents of section (__DATA,__nl_symbol_ptr)File Page 23 contains contents of section (__DATA,__dyld)File Page 23 contains contents of section (__DATA,__cfstring)File Page 23 contains contents of section (__DATA,__bss)File Page 23 contains contents of section (__DATA,__common)Symbols on file page 23 virtual address 0x18000 to 0x18d48 0x00018000 _NXArgc 0x00018004 _NXArgv 0x00018008 _environ 0x0001800c ___progname... In the preceding listing, if a page exports any symbols, those symbols are also displayed by the -a option. If you want to view the symbols for a single page, pass in the desired page number instead of the -a option. For more information about the pagestuff tool and its supported options, see the pagestuff man page. 在前面的列表中，如果一个页面导出任何符号，那么这些符号也会被a选项显示。如果要查看单个页面的符号，请输入所需的页码，而不是-a选项。有关pagestuff工具及其支持选项的更多信息，请参见pagestuff man页面。 Viewing Virtual Memory RegionsThe vmmap and vmmap64 tools display the virtual memory regions allocated for a specified process. These tools provide access to the virtual memory of 32-bit and 64-bit applications, respectively. You can use them to understand the purpose of memory at a given address and how that memory is being used. For each virtual-memory region, these tools display the type of page, the starting address, region size (in kilobytes), read/write permissions, sharing mode, and the purpose of the pages in that region.vmmap和vmmap64工具显示为指定进程分配的虚拟内存区域。这些工具分别提供对32位和64位应用程序的虚拟内存的访问。您可以使用它们来理解给定地址的内存用途以及内存的使用方式。对于每个虚拟内存区域，这些工具显示页面的类型、起始地址、区域大小(单位为千字节)、读/写权限、共享模式和该区域的页面用途。 The following sections show you how to interpret the output from the vmmap tool. For more information about the vmmap and vmmap64 tools, see the vmmap or vmmap64 man pages.以下部分将向您展示如何解释vmmap工具的输出。有关vmmap和vmmap64工具的更多信息，请参见vmmap或vmmap64手册页面。 Sample Output From vmmapListing 3 shows some sample output from the vmmap tool. This example is not a full listing of the tool’s output but is an abbreviated version showing the primary sections. Listing 3 Typical output of vmmap 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556==== Non-writable regions for process 313__PAGEZERO 0 [ 4K] ---/--- SM=NUL ...ts/MacOS/Clock__TEXT 1000 [ 40K] r-x/rwx SM=COW ...ts/MacOS/Clock__LINKEDIT e000 [ 4K] r--/rwx SM=COW ...ts/w/Clock 90000 [ 4K] r--/r-- SM=SHM 340000 [3228K] r--/rwx SM=COW 00000100 00320... 789000 [3228K] r--/rwx SM=COW 00000100 00320...Submap 90000000-9fffffff r--/r-- machine-wide submap__TEXT 90000000 [ 932K] r-x/r-x SM=COW /usr/lib/libSystem.B.dylib__LINKEDIT 900e9000 [ 260K] r--/r-- SM=COW /usr/lib/libSystem.B.dylib__TEXT 90130000 [ 740K] r-x/r-x SM=COW .../Versions/A/CoreFoundation__LINKEDIT 901e9000 [ 188K] r--/r-- SM=COW .../Versions/A/CoreFoundation__TEXT 90220000 [2144K] r-x/r-x SM=COW .../Versions/A/CarbonCore__LINKEDIT 90438000 [ 296K] r--/r-- SM=COW .../Versions/A/CarbonCore [...data omitted...]==== Writable regions for process 606__DATA 18000 [ 4K] rw-/rwx SM=PRV /Contents/MacOS/TextEdit__OBJC 19000 [ 8K] rw-/rwx SM=COW /Contents/MacOS/TextEditMALLOC_OTHER 1d000 [ 256K] rw-/rwx SM=PRVMALLOC_USED(DefaultMallocZone_0x5d2c0) 5d000 [ 256K] rw-/rwx SM=PRV 9d000 [ 372K] rw-/rwx SM=COW 33320000 00000020 00000000 00001b84...VALLOC_USED(DefaultMallocZone_0x5d2c0) ff000 [ 36K] rw-/rwx SM=PRVMALLOC_USED(CoreGraphicsDefaultZone_0x10 108000 [ 256K] rw-/rwx SM=PRVMALLOC_USED(CoreGraphicsRegionZone_0x148 148000 [ 256K] rw-/rwx SM=PRV [...data omitted...]Submap a000b000-a012ffff r--/r-- process-only submap__DATA a0130000 [ 28K] rw-/rw- SM=COW .../Versions/A/CoreFoundationSubmap a0137000-a021ffff r--/r-- process-only submap__DATA a0220000 [ 20K] rw-/rw- SM=COW .../Versions/A/CarbonCoreSubmap a0225000-a048ffff r--/r-- process-only submap__DATA a0490000 [ 12K] rw-/rw- SM=COW .../IOKit.framework/Versions/A/IOKitSubmap a0493000-a050ffff r--/r-- process-only submap__DATA a0510000 [ 36K] rw-/rw- SM=COW .../Versions/A/OSServices b959e000 [ 4K] rw-/rw- SM=SHM b95a0000 [ 4K] rw-/rw- SM=SHM b9630000 [ 164K] rw-/rw- SM=SHM b965a000 [ 896K] rw-/rw- SM=SHM bff80000 [ 504K] rw-/rwx SM=ZERSTACK[0] bfffe000 [ 4K] rw-/rwx SM=PRV bffff000 [ 4K] rw-/rwx SM=PRV__DATA c000c000 [ 4K] rw-/rwx SM=PRV .../Versions/A/ApplicationEnhancerSTACK[1] f0001000 [ 512K] rw-/rwx SM=PRV ff002000 [12272K] rw-/rw- SM=SHM ==== LegendSM=sharing mode: COW=copy_on_write PRV=private NUL=empty ALI=aliased SHM=shared ZER=zero_filled S/A=shared_alias ==== Summary for process 313ReadOnly portion of Libraries: Total=27420KB resident=12416KB(45%) swapped_out_or_unallocated=15004KB(55%)Writable regions: Total=21632KB written=536KB(2%) resident=1916KB(9%) swapped_out=0KB(0%) unallocated=19716KB(91%) If you specify the -d parameter (plus an interval in seconds), vmmap takes two snapshots of virtual-memory usage—one at the beginning of a specified interval and the other at the end—and displays the differences. It shows three sets of differences: individual differences regions in the first snapshot that are not in the second regions in the second snapshot that are not in the first 如果您指定-d参数(加上以秒为单位的间隔)，vmmap将获取两个虚拟内存使用快照(一个在指定的间隔开始，另一个在结束)，并显示差异。它显示了三组差异: 个体差异 第一个快照中的区域而不是第二个快照中的区域 第二个快照中不属于第一个快照的区域 Interpreting vmmap’s OutputThe columns of vmmap output have no headings. Instead you can interpret the type of data in each column by its format. Table 1 describes these columns. Table 1 Column descriptions for vmmap Table 1 Column descriptions for vmmap Column Number Example Description 1 __TEXT, __LINKEDIT, MALLOC_USED, STACK, and so on The purpose of the memory. This column can contain the name of a Mach-O segment or the memory allocation technique. 2 (DefaultMallocZone_0x5d2c0) If present, the zone used for allocation. 3 4eee000 The virtual memory address of the region. 4 [ 124K] The size of the region, measured in kilobytes 5 rw-/rwx Read, write and execution permissions for the region. The first set of flags specifies the current protection for the region. The second set of values specifies the maximum protection for the region. If an entry contains a dash (-), the process does not have the target permission. 6 SM=PRV Sharing mode for the region, either COW (copy-on-write), PRV (private), NUL (empty), ALI (aliased), or SHM (shared). 7 ...ts/MacOS/Clock The end of the pathname identifying the executable mapped into this region of virtual memory. If the region is stack or heap memory, nothing is displayed in this column. Column 1 identifies the purpose of the memory. A TEXT segment contains read-only code and data. A DATA segment contains data that may be both readable and writable. For allocated data, this column shows how the memory was allocated, such as on the stack, using malloc, and so on. For regions loaded from a library, the far right column shows the name of the library loaded into memory.第1列标识内存的用途。TEXT段包含只读代码和数据。DATA段包含可读和可写的数据。对于已分配的数据，这一列显示如何分配内存，例如使用malloc在堆栈上，等等。对于从库中加载的区域，最右边的列显示加载到内存中的库的名称。 The size of the virtual memory region (column 4) represents the total size reserved for that region. This number may not reflect the actual number of memory pages allocated for the region. For example, calling vm_allocate reserves a set of memory pages but does not allocate any physical memory until the pages are actually touched. Similarly, a memory-mapped file may reserve a set of pages, but the system does not load pages until a read or write event occurs on the file.虚拟内存区域的大小(第4列)表示该区域保留的总大小。这个数字可能不能反映为该区域分配的内存页的实际数量。例如，调用vm_allocation会保留一组内存页，但在实际操作这些页之前不会分配任何物理内存。类似地，内存映射文件可以保留一组页面，但是系统在文件上发生读或写事件之前不会加载页面。 The protection mode (column 5) describes the access restrictions for the memory region. A memory region contains separate flags for read, write, and execution permissions. Each virtual memory region has a current permission, and a maximum permission. In the output from vmmap, the current permission appears first followed by the maximum permission. Thus, if the permissions are “r–/rwx“ the page is currently read-only but allows read, write, and execution access as its maximum allowed permissions. Typically, the current permissions do not permit writing to a region. However, these permissions may change under certain circumstances. For example, a debugger may request write access to a page in order to set a breakpoint.保护模式(第5列)描述了内存区域的访问限制。内存区域包含用于读取、写入和执行权限的单独标志。每个虚拟内存区域都有一个当前权限和最大权限。在vmmap的输出中，当前权限首先显示为最大权限。因此，如果权限是“r- /rwx”，页面当前是只读的，但允许读、写和执行访问作为其最大允许的权限。通常，当前权限不允许写入区域。但是，这些权限在某些情况下可能会改变。例如，调试器可以请求对页面的写访问，以便设置断点。 The sharing mode (SM= field) tells you whether pages are shared between processes and what happens when pages are modified. Private pages (PRV) are visible only to the process and are allocated as they are used. Private pages can also be paged out to disk. Copy-on-write (COW) pages are shared by multiple processes (or shared by a single process in multiple locations). When the page is modified, the writing process then receives its own copy of the page. Empty (NUL) sharing implies that the page does not really exist in physical memory. Aliased (ALI) and shared (SHM) memory are shared between processes.共享模式(SM= field)告诉您进程之间是否共享页面，以及修改页面时会发生什么。私有页面(PRV)只对进程可见，并在使用它们时进行分配。还可以将私有页面分页到磁盘。写时复制(COW)页面由多个进程共享(或由多个位置的单个进程共享)。当页面被修改时，编写过程将收到它自己的页面副本。空(NUL)共享意味着页面并不真正存在于物理内存中。别名(ALI)和共享(SHM)内存在进程之间共享。 The sharing mode typically describes the general mode controlling the region. For example, as copy-on-write pages are modified, they become private to the application. However, the region containing those private pages is still copy-on-write until all pages become private. Once all pages are private, the sharing mode changes to private.共享模式通常描述控制该区域的通用模式。例如，当对写后复制的页面进行修改时，它们将成为应用程序的私有页面。但是，包含这些私有页面的区域仍然是“写时复制”，直到所有页面变为私有。一旦所有页面都是私有的，共享模式就会变为私有。 Some lines in the output of vmmap describe submaps. A submap is a shared set of virtual memory page descriptions that the operating system can reuse between multiple processes. For example, the memory between 0x90000000 and 0xAFFFFFFF is a submap containing the most common dynamic libraries. Submaps minimize the operating system’s memory usage by representing the virtual memory regions only once. Submaps can either be shared by all processes (machine-wide) or be local to the process (process-only). If the contents of a machine-wide submap are changed—for example, the debugger makes a section of memory for a dynamic library writable so it can insert debugging traps—then the submap becomes local, and the kernel allocates memory to store the extra copy.vmmap输出中的一些行描述子映射。子映射是操作系统可以在多个进程之间重用的一组共享的虚拟内存页面描述。例如，0x90000000和0xAFFFFFFF之间的内存是包含最常见动态库的子映射。子映射只表示一次虚拟内存区域，从而最小化操作系统的内存使用。子映射可以由所有进程(机器范围内)共享，也可以是进程(仅处理)的本地映射。如果修改了机器范围的子映射的内容(例如，调试器为动态库编写一个内存段，以便它可以插入调试trap)，那么子映射就变成本地的，内核分配内存来存储额外的副本。 [a]: [a]:","tags":[{"name":"虚拟内存","slug":"虚拟内存","permalink":"http://yoursite.com/tags/虚拟内存/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"虚拟内存","slug":"IOS/虚拟内存","permalink":"http://yoursite.com/categories/IOS/虚拟内存/"}]},{"title":"虚拟内存之一----关于","date":"2018-06-01T04:07:12.000Z","path":"wiki/IOS/虚拟内存/虚拟内存/","text":"这篇文章翻译下Memory Usage Performance Guidelines About Virtual MemoryVirtual memory allows an operating system to escape the limitations of physical RAM. The virtual memory manager creates a logical address space (or “virtual” address space) for each process and divides it up into uniformly-sized chunks of memory called pages. The processor and its memory management unit (MMU) maintain a page table to map pages in the program’s logical address space to hardware addresses in the computer’s RAM. When a program’s code accesses an address in memory, the MMU uses the page table to translate the specified logical address into the actual hardware memory address. This translation occurs automatically and is transparent to the running application. 虚拟内存允许操作系统摆脱物理RAM的限制。虚拟内存管理器为每个进程创建一个逻辑地址空间(或“虚拟”地址空间)，并将其划分为大小相同的称为页面的内存块。处理器及其内存管理单元(MMU)维护一个页表，将程序逻辑地址空间中的页映射到计算机RAM中的硬件地址。当程序的代码访问内存中的地址时，MMU使用页表将指定的逻辑地址转换为实际的硬件内存地址。这种转换是自动进行的，对正在运行的应用程序是透明的。 As far as a program is concerned, addresses in its logical address space are always available. 就程序而言，其逻辑地址空间中的地址总是可用的。However, if an application accesses an address on a memory page that is not currently in physical RAM, a page fault occurs.但是，如果应用程序访问当前不在物理RAM中的内存页上的地址，则会发生页面错误。 When that happens, the virtual memory system invokes a special page-fault handler to respond to the fault immediately.当发生这种情况时，虚拟内存系统调用一个特殊的页面错误处理程序来立即响应错误。 The page-fault handler stops the currently executing code, locates a free page of physical memory, loads the page containing the needed data from disk, updates the page table, and then returns control to the program’s code, which can then access the memory address normally. This process is known as paging. 页面错误处理程序停止当前执行的代码，定位物理内存的空闲页面，从磁盘装载包含所需数据的页面，更新页面表，然后返回对程序代码的控制，然后程序代码就可以正常地访问内存地址。这个过程称为分页。 If there are no free pages available in physical memory, the handler must first release an existing page to make room for the new page.如果在物理内存中没有可用的空闲页面，处理程序必须首先释放一个现有页面，以便为新页面腾出空间。 How the system release pages depends on the platform. 系统释放页面的方式取决于平台。In OS X, the virtual memory system often writes pages to the backing store.在OS X中，虚拟内存系统经常将页面写入后备存储器。 The backing store is a disk-based repository containing a copy of the memory pages used by a given process.后备存储是一个基于磁盘的存储库，其中包含给定进程使用的内存页的副本。 Moving data from physical memory to the backing store is called paging out (or “swapping out”);将数据从物理内存移动到后台存储被称为分页(或“交换出”); moving data from the backing store back in to physical memory is called paging in (or “swapping in”). 将数据从后台存储恢复到物理内存称为分页in(或“交换in”)。In iOS, there is no backing store and so pages are are never paged out to disk, but read-only pages are still be paged in from disk as needed.在iOS中，没有备份存储，所以不会将页面调出到磁盘，但是只读页面仍然根据需要从磁盘调入。 In OS X and in earlier versions of iOS, the size of a page is 4 kilobytes.在OS X和iOS的早期版本中，页面的大小是4千字节。 In later versions of iOS, A7- and A8-based systems expose 16-kilobyte pages to the 64-bit userspace backed by 4-kilobyte physical pages,在iOS的后续版本中，基于A7和基于a8的系统将16千字节的页暴露给由4千字节物理页支持的64位用户空间， while A9 systems expose 16-kilobyte pages backed by 16-kilobyte physical pages. 而A9系统将16千字节的页暴露给由16千字节物理页支持的64位用户空间。These sizes determine how many kilobytes the system reads from disk when a page fault occurs. 这些大小决定了当发生页面错误时系统从磁盘读取多少千字节。Disk thrashing can occur when the system spends a disproportionate amount of time handling page faults and reading and writing pages, rather than executing code for a program. 当系统花费过多的时间处理页面错误、读写页面，而不是为程序执行代码时，就会发生磁盘抖动。 Paging of any kind, and disk thrashing in particular, affects performance negatively because it forces the system to spend a lot of time reading and writing to disk. Reading a page in from the backing store takes a significant amount of time and is much slower than reading directly from RAM. If the system has to write a page to disk before it can read another page from disk, the performance impact is even worse.任何类型的分页，特别是磁盘抖动，都会对性能产生负面影响，因为这会迫使系统花费大量时间对磁盘进行读写。从后台存储读取页面需要大量的时间，而且比直接从RAM读取要慢得多。如果系统必须在从磁盘读取另一个页面之前将一个页面写到磁盘，那么性能的影响甚至更糟。 Details of the Virtual Memory SystemThe logical address space of a process consists of mapped regions of memory. Each mapped memory region contains a known number of virtual memory pages. Each region has specific attributes controlling such things as inheritance (portions of the region may be mapped from “parent” regions), write-protection, and whether it is wired (that is, it cannot be paged out). Because regions contain a known number of pages, they are page-aligned, meaning the starting address of the region is also the starting address of a page and the ending address also defines the end of a page.进程的逻辑地址空间由内存的映射区域组成。每个映射内存区域包含已知数量的虚拟内存页。每个区域都有特定的属性来控制诸如继承(该区域的一部分可以从“父”区域映射)、写保护以及它是否连接(也就是说，它不能被分页)。因为区域包含已知的页数，所以它们是页面对齐的，这意味着该区域的起始地址也是页面的起始地址，而结尾地址也定义了页面的结束地址。 The kernel associates a VM object with each region of the logical address space.内核将VM对象与逻辑地址空间的每个区域关联起来。 The kernel uses VM objects to track and manage the resident and nonresident pages of the associated regions.内核使用VM对象跟踪和管理关联区域的驻留页和非驻留页。 A region can map to part of the backing store or to a memory-mapped file in the file system.区域可以映射到备份存储的一部分，或者映射到文件系统中的内存映射文件。 Each VM object contains a map that associates regions with either the default pager or the vnode pager. 每个VM对象都包含一个映射，该映射将区域与默认分页器或vnode分页器关联起来。The default pager is a system manager that manages the nonresident virtual memory pages in the backing store and fetches those pages when requested. 默认分页器是一个系统管理器，它管理后台存储中的非驻留虚拟内存页，并在请求时获取这些页。The vnode pager implements memory-mapped file access. vnode分页器实现内存映射文件访问。The vnode pager uses the paging mechanism to provide a window directly into a file. vnode分页器使用分页机制直接向文件提供一个窗口。This mechanism lets you read and write portions of the file as if they were located in memory.该机制允许您读取和写入文件的部分，就像它们位于内存中一样。 In addition to mapping regions to either the default or vnode pager, a VM object may also map regions to another VM object. The kernel uses this self referencing technique to implement copy-on-write regions. Copy-on-write regions allow different processes (or multiple blocks of code within a process) to share a page as long as none of them write to that page. When a process attempts to write to the page, a copy of the page is created in the logical address space of the process doing the writing. From that point forward, the writing process maintains its own separate copy of the page, which it can write to at any time. Copy-on-write regions let the system share large quantities of data efficiently in memory while still letting processes manipulate those pages directly (and safely) if needed. These types of regions are most commonly used for the data pages loaded from system frameworks.除了将区域映射到默认或vnode页导航之外，VM对象还可以将区域映射到另一个VM对象。内核使用这种自引用技术来实现写时复制区域。写后复制区域允许不同的进程(或一个进程中的多个代码块)共享一个页面，只要它们中没有一个写入该页。当进程试图写入页面时，将在执行写入操作的进程的逻辑地址空间中创建页面的副本。从那时起，编写过程就维护了它自己的页面的独立拷贝，它可以在任何时候对其进行写入。写后复制区域允许系统在内存中有效地共享大量数据，同时还允许进程在需要时直接(和安全地)操作这些页面。这些类型的区域通常用于从系统框架加载的数据页。每个VM对象包含几个字段，如表1所示。 Field Description Resident pages A list of the pages of this region that are currently resident in physical memory. Size The size of the region, in bytes. Pager The pager responsible for tracking and handling the pages of this region in backing store. Shadow Used for copy-on-write optimizations. Copy Used for copy-on-write optimizations. Attributes Flags indicating the state of various implementation detai**ls. If the VM object is involved in a copy-on-write (vm_copy) operation, the shadow and copy fields may point to other VM objects. Otherwise both fields are usually NULL. Wired MemoryWired memory (also called resident memory) stores kernel code and data structures that must never be paged out to disk. Applications, frameworks, and other user-level software cannot allocate wired memory. However, they can affect how much wired memory exists at any time. For example, an application that creates threads and ports implicitly allocates wired memory for the required kernel resources that are associated with them.Wired memory(也称为常驻内存)存储内核代码和数据结构，这些代码和数据结构永远不能被分页到磁盘上。应用程序、框架和其他用户级软件不能分配Wired memory。然而，它们可以影响在任何时候存在多少Wired memory。例如，创建线程和端口的应用程序隐式申请了Wired memory，这些内存是内核资源需要的。 Table 2 lists some of the wired-memory costs for application-generated entities. Resource Wired Memory Used by Kernel Process 16 kilobytes Thread blocked in a continuation—5 kilobytes; blocked—21 kilobyte Mach port 116 bytes Mapping 32 byte Library 2 kilobytes plus 200 bytes for each task that uses it Memory region 160 bytes As you can see, every thread, process, and library contributes to the resident footprint of the system. In addition to your application using wired memory, however, the kernel itself requires wired memory for the following entities:如您所见，每个线程、进程和库都会影响系统的驻留内存。但是，除了使用Wired memory的应用程序之外，内核本身的以下实体会使用有线内存: VM objects the virtual memory buffer cache I/O buffer caches drivers Wired data structures are also associated with the physical page and map tables used to store virtual-memory mapping information, Both of these entities scale with the amount of available physical memory. Consequently, when you add memory to a system, the amount of wired memory increases even if nothing else changes. When a computer is first booted into the Finder, with no other applications running, wired memory can consume approximately 14 megabytes of a 64 megabyte system and 17 megabytes of a 128 megabyte system.Wired data structures还与物理页面、用于存储虚拟内存映射信息的映射表相关联，这两个实体都与可用物理内存的大小相关联。因此，当您向系统添加内存时，即使没有其他变化，wired-memory的数量也会增加。当一台计算机第一次启动Finder时，没有其他应用程序运行时，在64兆系统中wired-memory可以消耗大约14兆字节 在128兆系统中消耗17兆字节。 Wired memory pages are not immediately moved back to the free list when they become invalid. Instead they are “garbage collected” when the free-page count falls below the threshold that triggers page out events.Wired memory页在无效时不会立即移回空闲列表。相反，当空闲页面数低于触发page out事件的阈值时，它们会被“垃圾收集”。 Page Lists in the KernelThe kernel maintains and queries three system-wide lists of physical memory pages:内核维护和查询三个系统范围的物理内存页列表:。 The active list contains pages that are currently mapped into memory and have been recently accessed. The inactive list contains pages that are currently resident in physical memory but have not been accessed recently. These pages contain valid data but may be removed from memory at any time. The free list contains pages of physical memory that are not associated with any address space of VM object. These pages are available for immediate use by any process that needs them. 活动列表包含当前映射到内存和最近访问的页面。 非活动列表包含当前驻留在物理内存中但最近未被访问的页面。这些页面包含有效的数据，但是可以随时从内存中删除。 空闲列表包含 没有和任何VM对象关联的物理内存页。任何需要这些页面的进程都可以立即使用这些页面。 When the number of pages on the free list falls below a threshold (determined by the size of physical memory), the pager attempts to balance the queues. It does this by pulling pages from the inactive list. If a page has been accessed recently, it is reactivated and placed on the end of the active list. In OS X, if an inactive page contains data that has not been written to the backing store recently, its contents must be paged out to disk before it can be placed on the free list. (In iOS, modified but inactive pages must remain in memory and be cleaned up by the application that owns them.) If an inactive page has not been modified and is not permanently resident (wired), it is stolen (any current virtual mappings to it are destroyed) and added to the free list. Once the free list size exceeds the target threshold, the pager rests.当空闲列表中的页面数低于阈值(由物理内存大小决定)时，pager将尝试平衡队列。它通过从非活动列表中提取页面来实现这一点。如果最近访问了某个页面，则重新激活该页面并将其放置在活动列表的末尾。在OS X中，如果一个不活动的页面包含了最近没有写到后台存储的数据，那么在它被放到空闲列表之前，它的内容必须被分页到磁盘上。(在iOS中，修改但不活跃的页面必须保留在内存中，并由拥有它们的应用程序进行清理。) 如果一个不活动的页面没有被修改，并且不是永久驻留(wired)，那么它将被窃取(它的任何当前虚拟映射都将被销毁)并添加到空闲列表中。一旦空闲列表大小超过目标阈值，pager就会停止。 The kernel moves pages from the active list to the inactive list if they are not accessed; it moves pages from the inactive list to the active list on a soft fault (see Paging In Process). When virtual pages are swapped out, the associated physical pages are placed in the free list. Also, when processes explicitly free memory, the kernel moves the affected pages to the free list.内核将未访问的页面从活动列表移动到非活动列表;通过soft fault将页面从非活动列表移动到活动列表 (请参阅分页In Process)。当虚拟页面交换出去时，相关的物理页面被放在空闲列表中。此外，当进程显式地释放内存时，内核将受影响的页面移动到空闲列表。 Paging Out ProcessIn OS X, when the number of pages in the free list dips below a computed threshold, the kernel reclaims physical pages for the free list by swapping inactive pages out of memory. To do this, the kernel iterates all resident pages in the active and inactive lists, performing the following steps: If a page in the active list is not recently touched, it is moved to the inactive list. If a page in the inactive list is not recently touched, the kernel finds the page’s VM object. If the VM object has never been paged before, the kernel calls an initialization routine that creates and assigns a default pager object. The VM object’s default pager attempts to write the page out to the backing store. If the pager succeeds, the kernel frees the physical memory occupied by the page and moves the page from the inactive to the free list. 在OS X中，当空闲列表中的页面数量低于计算的阈值时，内核通过将不活动的页面从内存中交换出来，从而回收空闲列表的物理页面。为此，内核遍历活动和非活动列表中的所有驻留页面，执行以下步骤: 如果活动列表中的某个页面最近未被触摸，它将被移到非活动列表。 如果非活动列表中的一个页面最近没有被使用，内核将找到页面的VM对象。 如果VM对象以前从未被分页，那么内核将调用一个初始化例程，该例程创建并分配一个默认的分页器对象。 VM对象的默认分页器尝试将页面写到后台存储。 如果pager成功，内核释放页面占用的物理内存，并将页面从非活动列表移动到空闲列表。 Paging In ProcessThe final phase of virtual memory management moves pages into physical memory, either from the backing store or from the file containing the page data. A memory access fault initiates the page-in process. A memory access fault occurs when code tries to access data at a virtual address that is not mapped to physical memory. There are two kinds of faults:虚拟内存管理的最后一个阶段是将页面移动到物理内存中，或者从后台存储区，或者从包含页面数据的文件中。内存访问错误启动page-in进程。当代码试图访问没有映射到物理内存的虚拟地址中的数据时，会发生内存访问错误。有两种错误: A soft fault occurs when the page of the referenced address is resident in physical memory but is currently not mapped into the address space of this process. A hard fault occurs when the page of the referenced address is not in physical memory but is swapped out to backing store (or is available from a mapped file). This is what is typically known as a page fault. soft fault：当引用地址的页驻留在物理内存中，但当前没有映射到此进程的地址空间时，就会发生此错误。 hard fault：当引用地址的页面不在物理内存中，而是被交换到后备存储器(或从映射文件中可用)时，就会出现。这就是通常所说的页面错误。 When any type of fault occurs, the kernel locates the map entry and VM object for the accessed region. The kernel then goes through the VM object’s list of resident pages. If the desired page is in the list of resident pages, the kernel generates a soft fault. If the page is not in the list of resident pages, it generates a hard fault.当发生任何类型的错误时，内核为被访问区域定位映射条目和VM对象。内核然后遍历VM对象的常驻页面列表。如果希望的页面位于驻留页面的列表中，内核会生成一个软错误。如果页面不在常驻页面列表中，则会产生硬错误。 For soft faults, the kernel maps the physical memory containing the pages to the virtual address space of the process. The kernel then marks the specific page as active. If the fault involved a write operation, the page is also marked as modified so that it will be written to backing store if it needs to be freed later.对于软故障，内核将包含页面的物理内存映射到进程的虚拟地址空间。然后内核将特定页面标记为活动页面。如果该错误涉及到写操作，那么该页面也会被标记为修改，以便在以后需要释放时写入到后备存储器中。 For hard faults, the VM object’s pager finds the page in the backing store or from the file on disk, depending on the type of pager. After making the appropriate adjustments to the map information, the pager moves the page into physical memory and places the page on the active list. As with a soft fault, if the fault involved a write operation, the page is marked as modified.对于硬故障，VM对象的寻呼机根据寻呼机的类型在备份存储中或从磁盘上的文件中查找页面。在对映射信息进行适当的调整之后，寻呼机将页面移动到物理内存中，并将页面放在活动列表中。与软错误一样，如果错误涉及写操作，则将页面标记为已修改。 名称解释Mac的内存使用：Wired, Active, Inactive和Free Wired(联动): 系统核心占用的，永远不会从系统物【[内存】中去除。 Active(活跃): 表示这些内存数据正在使用种，或者刚被使用过。 Inactive(非活跃): 表示这些内存中的数据是有效的，但是最近没有被使用。 Free(可用空间): 表示这些内存中的数据是无效的，即内存剩余量！ 当Free的【内存】低于某个key值时，这个key值是由你的物理内存大小决定的，系统则会按照以下顺序使用Inactive的资源。 首先，如果Inactive的数据最近被调用了，系统会把它们的状态改变成Active,并且在原有Active内存逻辑地址的后面； 其次，如果Inactive的内存数据最近没有被使用过，但是曾经被更改过，而还没有在硬盘的相应虚拟[内存]中做修改，系统会对相应硬盘的虚拟内存做修改，并把这部分物理内存释放为free供程序使用。 再次，如果inactive[内存]中得数据被在映射到硬盘后再没有被更改过，则直接释放成free。 最后如果active的内存一段时间没有被使用，会被暂时改变状态为inactive。 所以，如果你的系统里有少量的free memeory和大量的inactive的memeory，说明你的内存是够用的，系统运行在最佳状态，只要需要,系统就会使用它们，不用担心。 如果系统的free memory和inactive memory都很少，而active memory很多，说明你的[内存]不够了。当然一开机，大部分[内存]都是free,这时系统反而不在最佳状态，因为很多数据都需要从硬盘调用，速度反而慢了。 Free memoryThis is RAM that’s not being used. Wired memoryInformation in this memory can’t be moved to the hard disk, so it must stay in RAM. The amount of Wired memory depends on the applications you are using. Active memoryThis information is currently in memory, and has been recently used. Inactive memoryThis information in memory is not actively being used, but was recently used. For example, if you’ve been using Mail and then quit it, the RAM that Mail was using is marked as Inactive memory. This Inactive memory is available for use by another application, just like Free memory. However, if you open Mail before its Inactive memory is used by a different application, Mail will open quicker because its Inactive memory is converted to Active memory, instead of loading Mail from the slower hard disk. UsedThis is the total amount of memory used. VM sizeThis is the total amount of Virtual Memory for all processes on your Mac. Page ins / Page outsThis refers to the amount of information moved between RAM and the hard disk. This number is a cumulative amount of data that Mac OS X has moved between RAM and disk space. Tip: Page outs occur when your Mac has to write information from RAM to the hard drive (because RAM is full). Adding more RAM may reduce page outs. Swap usedThis is the amount of information copied to the swap file on your hard drive.","tags":[{"name":"虚拟内存1","slug":"虚拟内存1","permalink":"http://yoursite.com/tags/虚拟内存1/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"虚拟内存","slug":"IOS/虚拟内存","permalink":"http://yoursite.com/categories/IOS/虚拟内存/"}]},{"title":"Mach-O文件结构理解","date":"2018-05-16T04:07:12.000Z","path":"wiki/IOS/MachO/MachO_FileStructure/","text":"Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以： 有助于理解崩溃日志解析的原理。理解KSCrash源码； 有助于理解开源代码fishhook的原理； 有助于理解腾讯OOMDetector开源库源码； 好处应该不止这些。 总体结构它的组成结构如下图所示，包括了Header、Load commands、Data（包含Segement的具体数据）。 这张图片说明了几点： mach-o由三部分构成，header、Load Commands、Data区域。 commond指定了各种数据在Data区域的位置。 可以将header比喻为文章的摘要，Load Commands为文章的目录、Data是文章的正文。 目录的特点是可以定位内容在文章的位置。Load Commands其实就是这个作用。 每个segment下面可以有一个或多个section。 可以理解为一级目录下的子二级目录~~。 也可以从另外角度认识Mach-O结构，如图所示。 这张图表达了更多的细节信息： segment 的类型有__TEXT(程序的代码区域，只读) 、__DATA(程序的数据区域，可读写) __DATA segment 后面跟随着多个section，包括__nl__symbol_ptr （not layz符号）__la__symbol_ptr 下面来聊聊Header部分 mach-headermach-header 的定义如下： 1234567891011///&lt;mach-o/loader.h&gt;struct mach_header_64 &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */&#125;; magic：魔数，用于快速确认该文件的种类（用于64位还是32位）。可取值（部分）如下： 12#define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */#define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ cputype：CPU类型，可取值（部分）如下： 1234#define CPU_TYPE_I386 CPU_TYPE_X86 /* compatibility */#define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)#define CPU_TYPE_ARM ((cpu_type_t) 12)#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64) cpusubtype：对应的具体类型，比如arm64、armv7，可取值（部分）如下： 1234#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_X86_64_ALL ((cpu_subtype_t)3)#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9)#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11) /* Swift */ filetype：文件类型，比如可执行文件、库文件、Dsym文件，例如：MH_EXECUTE值是2，代表可执行文件，可取值如下： 12345678910111213 * Constants for the filetype field of the mach_header */#define MH_OBJECT 0x1 /* relocatable object file */#define MH_EXECUTE 0x2 /* demand paged executable file */#define MH_FVMLIB 0x3 /* fixed VM shared library file */#define MH_CORE 0x4 /* core file */#define MH_PRELOAD 0x5 /* preloaded executable file */#define MH_DYLIB 0x6 /* dynamically bound shared library */#define MH_DYLINKER 0x7 /* dynamic link editor */#define MH_BUNDLE 0x8 /* dynamically bound bundle file */#define MH_DYLIB_STUB 0x9 /* shared library stub for static */#define MH_DSYM 0xa /* companion file with only debug */#define MH_KEXT_BUNDLE 0xb /* x86_64 kexts */ ncmds ：加载命令条数 sizeofcmds：所有加载命令的大小 reserved：保留字段 flags：标志位，可取值（部分）如下： 123456789101112131415161718192021222324252627#define MH_DYLDLINK 0x4 /* the object file is input for the dynamic linker and can't be staticly link edited again */#define MH_PREBOUND 0x10 /* the file has its dynamic undefined references prebound. */#define MH_SPLIT_SEGS 0x20 /* the file has its read-only and read-write segments split */#define MH_TWOLEVEL 0x80 /* the image is using two-level name space bindings */#define MH_NOMULTIDEFS 0x200 /* this umbrella guarantees no multiple defintions of symbols in its sub-images so the two-level namespace hints can always be used. */#define MH_CANONICAL 0x4000 /* the binary has been canonicalized via the unprebind operation */#define MH_WEAK_DEFINES 0x8000 /* the final linked image contains external weak symbols */#define MH_BINDS_TO_WEAK 0x10000 /* the final linked image uses weak symbols */#define MH_PIE 0x200000 /* When this bit is set, the OS will load the main executable at a random address. Only used in MH_EXECUTE filetypes. */.... 下图是借用machoview查看header的结构： 可以看出： 该文件是可执行文件 文件的构架是x86_64 number of Load commands表示有74个load commond MH_TWOLEVEL二级名字空间 MH_PIE 随机地址空间 接下来介绍head后的load command部分。 load commandLoad commands紧跟在头部之后。Load commands指定了文件的布局结构和链接特征。有很多很多种Load commands。这些加载指令清晰地告诉加载器如何处理二进制数据，有些命令是由内核处理的，有些是由动态链接器处理的。 这里列举几个看上去比较熟悉的…. 12345678910111213141516// &lt;mach-o/loader.h&gt;#define LC_SEGMENT 0x1 /* segment of this file to be mapped 被映射到内存的段*/#define LC_SYMTAB 0x2 /* link-edit stab symbol table info 符号表*/#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info 动态符号表*/#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library 动态链接库*//* * load a dynamically linked shared library that is allowed to be missing * (all symbols are weak imported). */#define LC_LOAD_WEAK_DYLIB (0x18 | LC_REQ_DYLD)#define LC_SEGMENT_64 0x19 /* 64-bit segment of this file to be mapped */#define LC_UUID 0x1b /* the uuid */#define LC_RPATH (0x1c | LC_REQ_DYLD) /* runpath additions */#define LC_CODE_SIGNATURE 0x1d /* local of code signature */ load command的基本定义如下： 1234struct load_command &#123; uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */&#125;; 这个结构体只表示了所有的command都需要包含的属性—-命令类型和命令的大小。具体对于不同的命令都会有不同的定义。但是必须包含上面两个字段。 下面就来看具体的命令—LC_SEGMENT_64类型命令的定义。 LC_SEGMENT123456789101112131415161718192021222324252627282930/* * The segment load command indicates that a part of this file is to be * mapped into the task's address space. The size of this segment in memory, * vmsize, maybe equal to or larger than the amount to map from this file, * filesize. The file is mapped starting at fileoff to the beginning of * the segment in memory, vmaddr. The rest of the memory of the segment, * if any, is allocated zero fill on demand. The segment's maximum virtual * memory protection and initial virtual memory protection are specified * by the maxprot and initprot fields. If the segment has sections then the * section structures directly follow the segment command and their size is * reflected in cmdsize.段加载命令指定了：文件需要映射到程序地址空间的某个部分。 段在内存中的大小用vmsize指定。内存中段的大小可能等于或大于文件大小（filesize），文件大小使用filesize指定。映射的源起始文件地址是fileoff，目的起始地址是vmaddr。内存中剩余的段内存用0填充。段的最大内存权限和初始内存权限用maxprot、initprot字段指定。如果段有section，那么section的结构紧跟着段。section的大小包括在cmdsize字段中。 */struct segment_command &#123; /* for 32-bit architectures */ uint32_t cmd; /* LC_SEGMENT */ uint32_t cmdsize; /* includes sizeof section structs */ char segname[16]; /* segment name */ uint32_t vmaddr; /* memory address of this segment */ uint32_t vmsize; /* memory size of this segment */ uint32_t fileoff; /* file offset of this segment */ uint32_t filesize; /* amount to map from the file */ vm_prot_t maxprot; /* maximum VM protection */ vm_prot_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */&#125;; 可以看出segment_command包含了命令必须的属性cmd、cmdsize。剩下的属性是segment_command特有的属性。 下面是名称为_DATA的segment commond的截图： 可以看出： 命令类型是LC_SEGMENT_64 命令的大小1832 segment 命令的名称是__DATA 映射的内存地址是4360744960（十进制） 内存的大小12488704 文件的偏移量是65777664 需要映射的文件的大小10424320 最大内存保护权限：读写执行 初始内存权限：读写 这个端附属了22个 section，也就是说1832大小的segment_command包括了22个section命令的大小。 看的方法：offset代表文件的便宜量、Data表示内存地址中存储的值、description表示这段内存地址的名称的描述、value表示存储的值的可视描述。 下面看看22个section的示意图： 下面讲解section的结构,section 的定义如下： 1234567891011121314struct section_64 &#123; /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */&#125;; 下图是__nl_symbol_ptr section 的示意图： 可以看出： section的名称是__nl_symbol_ptr 该section所属的segment的名称 _DATA 。segment名称大写，section名称小写，这个是默认的规定。 内存地址4360744960 该section在内存中的大小是16 该section在物理文件的偏移量65777664 内存对齐大小 8 间接符号索引是1198 （这里不太懂什么意思） segment 常用的有四种，如图所示： 可以看出有PAGEZERO、TEXT、DATA、LINKEDIT。下面是这四个segement的基本介绍。 The static linker creates a __PAGEZERO segment as the first segment of an executable file. This segment is located at virtual memory location 0 and has no protection rights assigned, the combination of which causes accesses to NULL, a common C programming error, to immediately crash. The __PAGEZERO segment is the size of one full VM page for the current architecture (for Intel-based and PowerPC-based Macintosh computers, this is 4096 bytes or 0x1000 in hexadecimal). Because there is no data in the __PAGEZERO segment, it occupies no space in the file (the file size in the segment command is 0). The __TEXT segment contains executable code and other read-only data. To allow the kernel to map it directly from the executable into sharable memory, the static linker sets this segment’s virtual memory permissions to disallow writing. When the segment is mapped into memory, it can be shared among all processes interested in its contents. (This is primarily used with frameworks, bundles, and shared libraries, but it is possible to run multiple copies of the same executable in OS X, and this applies in that case as well.) The read-only attribute also means that the pages that make up the __TEXT segment never need to be written back to disk. When the kernel needs to free up physical memory, it can simply discard one or more __TEXT pages and re-read them from disk when they are next needed. The __DATA segment contains writable data. The static linker sets the virtual memory permissions of this segment to allow both reading and writing. Because it is writable, the __DATA segment of a framework or other shared library is logically copied for each process linking with the library. When memory pages such as those making up the __DATA segment are readable and writable, the kernel marks them copy- on-write; therefore when a process writes to one of these pages, that process receives its own private copy of the page. The __LINKEDIT segment contains raw data used by the dynamic linker, such as symbol, string, and relocation table entries. LC_SYMTAB1234567891011121314/* * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD * \"stab\" style symbol table information as described in the header files * &lt;nlist.h&gt; and &lt;stab.h&gt;. * symtab_command 包含了符号表、字符串索引表 的偏移量和大小 。 */struct symtab_command &#123; uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; /* symbol table offset */ uint32_t nsyms; /* number of symbol table entries */ uint32_t stroff; /* string table offset */ uint32_t strsize; /* string table size in bytes */&#125;; 下面是LC_SYMTAB command示意图： 由表中可以看出 命令的大小是24 （十进制） 符号表在物理文件的偏移量是 77360448 符号表的大小 1069179 String表的物理文件偏移量是94479244 string表的大小是22093264 这个commond同时指定了两个表(符号表、String表)的位置信息。 LC_UUIDLC_UUID 用来标识唯一APP，命令的定义如下: 12345struct uuid_command &#123; uint32_t cmd; /* LC_UUID */ uint32_t cmdsize; /* sizeof(struct uuid_command) */ uint8_t uuid[16]; /* the 128-bit uuid */&#125;; 每个可执行程序都有一个uuid，这样根据不同的uuid能确定包。比如崩溃日志中就会包含uuid字段。表示是哪个包崩溃了。 LC_DYSYMTAB（动态符号表）下面的描述摘至&lt;mach-o/loader.h&gt; 的459行。 This is the second set of the symbolic information which is used to support the data structures for the dynamically link editor.LC_DYSYMTAB 是第二种类型符号集，这个符号集被动态连接器的数据结构使用。 The original set of symbolic information in the symtab_command which contains the symbol and string tables must also be present when this load command is present.当这个command（动态符号command）出现的时候，symtab_command必须出现，symtab_command包含符号表和String表。 When this load command is present the symbol table is organized into three groups of symbols:当这个加载命令出现的时候，符号表被组织为三部分： local symbols (static and debugging symbols) - grouped by module defined external symbols - grouped by module (sorted by name if not lib) undefined external symbols (sorted by name if MH_BINDATLOAD is not set, and in order the were seen by the static linker if MH_BINDATLOAD is set) In this load command there are offsets and counts to each of the three groups of symbols.这个命令指定了每个部分的偏移量和符号个数： This load command contains a the offsets and sizes of the following new symbolic information tables:这个命令包含下面新的符号： table of contents module table reference symbol table indirect symbol table The first three tables above (the table of contents, module table and reference symbol table) are only present if the file is a dynamically linked shared library.前三个只有文件是动态库的时候才出现。 For executable and object modules, which are files containing only one module, the information that would be in these three tables is determined as follows: table of contents - the defined external symbols are sorted by name module table - the file contains only one module so everything in the file is part of the module. reference symbol table - is the defined and undefined external symbols For dynamically linked shared library files this load command also contains offsets and sizes to the pool of relocation entries for all sections separated into two groups: external relocation entries local relocation entries For executable and object modules the relocation entries continue to hang off the section structures. 名称 类型 描述 cmd uint32_t LC_DYSYMTAB cmdsize uint32_t sizeof(struct dysymtab_command) - - - ilocalsym uint32_t index to local symbols nlocalsym uint32_t number of local symbols iextdefsym uint32_t index to externally defined symbols nextdefsym uint32_t number of externally defined symbols iundefsym uint32_t index to undefined symbols nundefsym uint32_t number of undefined symbols - - - tocoff uint32_t file offset to table of contents ntoc uint32_t number of entries in table of contents modtaboff uint32_t file offset to module table nmodtab uint32_t number of module table entries extrefsymoff uint32_t offset to referenced symbol table nextrefsyms uint32_t number of referenced symbol table entries indirectsymoff uint32_t file offset to the indirect symbol table nindirectsyms uint32_t number of indirect symbol table entries – – – extreloff uint32_t offset to external relocation entries nextrel uint32_t number of external relocation entries locreloff uint32_t offset to local relocation entries nlocrel uint32_t number of local relocation entries 又表得：动态符号command定义了各种符号的偏移量和各种符号的个数(9种)。 DATA部分DATA部分是Mach-O文件的主体，存储着各种类型的实际数据，例如LC_SEGMENT（TEXT）指定的代码段, LC_SEGMENT（DATA）指定的数据段。 LC_SYMTAB（__LINKEDIT）段指定的符号表和String表、以及动态符号表，等等。这里只了解三种结构： 符号表 String表 动态符号表 符号表符号表的数据结构如下： 12345678910111213141516171819202122232425262728struct nlist_64 &#123; union &#123; uint32_t n_strx; /* index into the string table */ &#125; n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */&#125;;/* * Symbols with a index into the string table of zero (n_un.n_strx == 0) are * defined to have a null, \"\", name. Therefore all string indexes to non null * names must not have a zero string index. This is bit historical information * that has never been well documented. *//* * The n_type field really contains four fields: * unsigned char N_STAB:3, * N_PEXT:1, * N_TYPE:3, * N_EXT:1; * which are used via the following masks. */#define N_STAB 0xe0 /* if any of these bits set, a symbolic debugging entry */#define N_PEXT 0x10 /* private external symbol bit */#define N_TYPE 0x0e /* mask for the type bits */#define N_EXT 0x01 /* external symbol bit, set for external symbols */ 示意图如下： 可以看出： String表的偏移量是0xbbff8, 翻译后是[GMRYouHaoHuoReq getRequestURL] 地址是0x100003300， string表String表顺序列出了二进制mach-O文件的中的所有可见字符串。串之间通过0x00分隔。可以通过相对String表起始位置的偏移量随机访问String表中的字符串。符号表结构中的n_strx指定的就是String表中的偏移量。通过这个偏移量可以访问到符号对应的具体字符串。 例如： String表的0xbbf8处是不是[GMRYouHaoHuoReq getRequestURL]，string表的地址是0x049C6D40 加上偏移量0x000BBFB1 ，等于0x54d633d。 可以看出string表的0x54d633d地址出就是：[GMRYouHaoHuoReq getRequestURL]。 动态符号表。动态符号表中存储着动态连接器使用的相关符号。 每个符号一般占用32bit的存储空间。存储的内容是符号表中的索引。 注意啦网上直接下载的MachOView经常崩溃，是由于有段代码没有做非空判断，所以为了有效使用MachOView，请从官网下载代码，然后在崩溃的地方添加非空判断。就OK拉。 参考 mach-o/loader.h 趣探 Mach-O：文件格式分析 MachOView 源码地址","tags":[{"name":"Mach-O","slug":"Mach-O","permalink":"http://yoursite.com/tags/Mach-O/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"MachO","slug":"IOS/MachO","permalink":"http://yoursite.com/categories/IOS/MachO/"}]},{"title":"注意事项","date":"2018-05-13T04:07:12.000Z","path":"wiki/资料收集/notice/notice/","text":"hexo注意事项 文档的图片的路径必须和文档名称一致 日期不能超过当前日期。","tags":[{"name":"注意事项","slug":"注意事项","permalink":"http://yoursite.com/tags/注意事项/"}],"categories":[{"name":"资料收集","slug":"资料收集","permalink":"http://yoursite.com/categories/资料收集/"},{"name":"notice","slug":"资料收集/notice","permalink":"http://yoursite.com/categories/资料收集/notice/"}]},{"title":"weex系列抄之一---事件处理","date":"2018-05-04T05:07:12.000Z","path":"wiki/Hybird/weex/Weex_six_events/","text":"前言在前两篇文章里面分别谈了 Weex 如何在 Native 端初始化的和 Weex 是如何高效的渲染 Native 的原生 UI 的。Native 这边还缺一块，那就是 Native 产生的一些事件，是怎么传回给 JS 的。这篇文章就详细分析这一部分。 目录 1.Weex 的事件类型 2.Weex 的事件传递 一.Weex的事件类型在 Weex 中，目前最新版本中事件总共分为 4 种类型，通用事件，Appear 事件，Disappear 事件，Page 事件。 在 Weex 的组件里面只包含前三种事件，即通用事件，Appear 事件，Disappear 事件。 当 WXComponent 添加事件的时候，会调用以下函数： 12345678910111213141516171819202122232425- (void)_addEventOnMainThread:(NSString *)addEventName&#123; WX_ADD_EVENT(appear, addAppearEvent) WX_ADD_EVENT(disappear, addDisappearEvent) WX_ADD_EVENT(click, addClickEvent) WX_ADD_EVENT(swipe, addSwipeEvent) WX_ADD_EVENT(longpress, addLongPressEvent) WX_ADD_EVENT(panstart, addPanStartEvent) WX_ADD_EVENT(panmove, addPanMoveEvent) WX_ADD_EVENT(panend, addPanEndEvent) WX_ADD_EVENT(horizontalpan, addHorizontalPanEvent) WX_ADD_EVENT(verticalpan, addVerticalPanEvent) WX_ADD_EVENT(touchstart, addTouchStartEvent) WX_ADD_EVENT(touchmove, addTouchMoveEvent) WX_ADD_EVENT(touchend, addTouchEndEvent) WX_ADD_EVENT(touchcancel, addTouchCancelEvent) [self addEvent:addEventName];&#125; WX_ADD_EVENT 是一个宏： 123456#define WX_ADD_EVENT(eventName, addSelector) \\if ([addEventName isEqualToString:@#eventName]) &#123;\\ [self addSelector];\\&#125; 即是判断待添加的事件 addEventName 的名字和默认支持的事件名字 eventName 是否一致，如果一致，就执行 addSelector 方法。 最后会执行一个 addEvent: 方法，每个组件里面会可以重写这个方法。在这个方法里面做的就是对组件的状态的标识。 比如 WXWebComponent 组件里面的 addEvent: 方法： 12345678910111213- (void)addEvent:(NSString *)eventName&#123; if ([eventName isEqualToString:@\"pagestart\"]) &#123; _startLoadEvent = YES; &#125; else if ([eventName isEqualToString:@\"pagefinish\"]) &#123; _finishLoadEvent = YES; &#125; else if ([eventName isEqualToString:@\"error\"]) &#123; _failLoadEvent = YES; &#125;&#125; 在这个方法里面即对 Web 组件里面的状态进行了标识。 接下来就看看这几个组件是怎么识别事件的触发的。 1. 通用事件在 WXComponent 的定义里，定义了如下和事件相关的变量： 123456789101112131415161718192021@interface WXComponent ()&#123;@package BOOL _appearEvent; BOOL _disappearEvent; UITapGestureRecognizer *_tapGesture; NSMutableArray *_swipeGestures; UILongPressGestureRecognizer *_longPressGesture; UIPanGestureRecognizer *_panGesture; BOOL _listenPanStart; BOOL _listenPanMove; BOOL _listenPanEnd; BOOL _listenHorizontalPan; BOOL _listenVerticalPan; WXTouchGestureRecognizer* _touchGesture;&#125; 上述变量里面就包含有4个手势识别器和1个自定义手势识别器。所以Weex的通用事件里面就包含这5种，点击事件，轻扫事件，长按事件，拖动事件，通用触摸事件。 （一）点击事件首先看点击事件： 123WX_ADD_EVENT(click, addClickEvent) 点击事件是通过上面这个宏加到指定视图上的。这个宏上面提到过了。这里直接把宏展开 12345#define WX_ADD_EVENT(click, addClickEvent) \\if ([addEventName isEqualToString:@“click”]) &#123;\\ [self addClickEvent];\\&#125; 如果 addEventName 传进来 event 的是 @“click”，那么就是执行 addClickEvent 方法。 123456789- (void)addClickEvent&#123; if (!_tapGesture) &#123; _tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onClick:)]; _tapGesture.delegate = self; [self.view addGestureRecognizer:_tapGesture]; &#125;&#125; 给当前的视图增加一个点击手势，触发的方法是 onClick: 方法。 1234567891011121314151617- (void)onClick:(__unused UITapGestureRecognizer *)recognizer&#123; NSMutableDictionary *position = [[NSMutableDictionary alloc] initWithCapacity:4]; CGFloat scaleFactor = self.weexInstance.pixelScaleFactor; if (!CGRectEqualToRect(self.calculatedFrame, CGRectZero)) &#123; CGRect frame = [self.view.superview convertRect:self.calculatedFrame toView:self.view.window]; position[@\"x\"] = @(frame.origin.x/scaleFactor); position[@\"y\"] = @(frame.origin.y/scaleFactor); position[@\"width\"] = @(frame.size.width/scaleFactor); position[@\"height\"] = @(frame.size.height/scaleFactor); &#125; [self fireEvent:@\"click\" params:@&#123;@\"position\":position&#125;];&#125; 一旦用户点击屏幕，就会触发点击手势，点击手势就会执行上述的 onClick: 方法。在这个方法中，Weex 会计算点击出点击到的视图的坐标以及宽高尺寸。 说到这里就需要提到 Weex 的坐标计算方法了。 （1）计算缩放比例因子在日常 iOS 开发中，开发者使用的计算单位是 pt。 iPhone5 分辨率320pt x 568ptiPhone6 分辨率375pt x 667ptiPhone6 Plus 分辨率414pt x 736pt 由于每个屏幕的 ppi 不同(ppi:Pixels Per Inch，即每英寸所拥有的像素数目，屏幕像素密度。)，最终会导致分辨率的不同。 这也就是我们日常说的@1x，@2x，@3x，目前 iPhone 手机也就3种 ppi @1x，163ppi（iPhone3gs）@2x，326ppi（iPhone4、4s、5、5s、6，6s，7）@3x，401ppi（iPhone6+、6s+、7+） px 即 pixels 像素，1px 代表屏幕上一个物理的像素点。 iPhone5 像素640px x 1136pxiPhone6 像素750px x 1334pxiPhone6 Plus 像素1242px x 2208px 而 Weex 的开发中，目前都是用的 px，而且 Weex 对于长度值目前只支持像素 px 值，还不支持相对单位（em、rem）。 那么就需要 pt 和 px 的换算了。 在 Weex 的世界里，定义了一个默认屏幕尺寸，用来适配 iOS，Android 各种不同大小的屏幕。 123// The default screen width which helps us to calculate the real size or scale in different devices.static const CGFloat WXDefaultScreenWidth = 750.0; 在 Weex 中定义的默认的屏幕宽度是750，注意是宽度。 123456789101112+ (CGFloat)defaultPixelScaleFactor&#123; static CGFloat defaultScaleFactor; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; defaultScaleFactor = [self portraitScreenSize].width / WXDefaultScreenWidth; &#125;); return defaultScaleFactor;&#125; 这里计算了一个默认的缩放比例因子，portraitScreenSize 里面计算出了屏幕在 portrait 方向下的大小，即如果方向是 landscape，那么缩放比例因子应该等于 WXScreenSize().height / WXDefaultScreenWidth，反之应该等于 WXScreenSize().width / WXDefaultScreenWidth。 这里计算的是 pt。 iPhone 4、4s、5、5s、5c、SE的比例因子是 0.42666667iPhone 6、6s、7比例因子是0.5iPhone 6+、6s+、7+比例因子是0.552 （2）计算视图的缩放尺寸计算视图的缩放尺寸主要在这个方法里面被计算。 1234567891011121314151617181920212223242526272829303132333435363738- (void)_calculateFrameWithSuperAbsolutePosition:(CGPoint)superAbsolutePosition gatherDirtyComponents:(NSMutableSet&lt;WXComponent *&gt; *)dirtyComponents&#123; if (!_cssNode-&gt;layout.should_update) &#123; return; &#125; _cssNode-&gt;layout.should_update = false; _isLayoutDirty = NO; // 计算视图的Frame CGRect newFrame = CGRectMake(WXRoundPixelValue(_cssNode-&gt;layout.position[CSS_LEFT]), WXRoundPixelValue(_cssNode-&gt;layout.position[CSS_TOP]), WXRoundPixelValue(_cssNode-&gt;layout.dimensions[CSS_WIDTH]), WXRoundPixelValue(_cssNode-&gt;layout.dimensions[CSS_HEIGHT])); BOOL isFrameChanged = NO; // 比较newFrame和_calculatedFrame，第一次_calculatedFrame为CGRectZero if (!CGRectEqualToRect(newFrame, _calculatedFrame)) &#123; isFrameChanged = YES; _calculatedFrame = newFrame; [dirtyComponents addObject:self]; &#125; CGPoint newAbsolutePosition = [self computeNewAbsolutePosition:superAbsolutePosition]; _cssNode-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED; _cssNode-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED; _cssNode-&gt;layout.position[CSS_LEFT] = 0; _cssNode-&gt;layout.position[CSS_TOP] = 0; [self _frameDidCalculated:isFrameChanged]; for (WXComponent *subcomponent in _subcomponents) &#123; [subcomponent _calculateFrameWithSuperAbsolutePosition:newAbsolutePosition gatherDirtyComponents:dirtyComponents]; &#125;&#125; newFrame 就是计算出来的缩放过的 Frame。 如果尝试自己手动计算 Vue.js 上设置的 px 与实际的视图坐标值相比，你会发现永远都差一点，虽然偏差不多，但是总有误差，原因在哪里呢？就在 WXRoundPixelValue 这个函数里面。 123456CGFloat WXRoundPixelValue(CGFloat value)&#123; CGFloat scale = WXScreenScale(); return round(value * scale) / scale;&#125; WXRoundPixelValue 这个函数里面进行了一次四舍五入的计算，这里会对精度有所损失，所以就会导致最终 Native 的组件的坐标会偏差一点。 举个例子： 12345678910111213&lt;style&gt; .pic&#123; width: 200px; height: 200px; margin-top: 100px; left: 200px; background-color: #a88859; &#125;&lt;/style&gt; 这里是一个 imageComponent，坐标是距离上边距 100px，距离左边距 200px，宽 200px，高 200px。 假设我们是在 iPhone 7+ 的屏幕上，ppi 对应的应该是 scale = 3（即@3x）。 按照 Weex 的上述的计算方法算，那么对应缩放的 px 为： 12345x = 200 * ( 414.0 / 750.0 ) = 110.400000y = 100 * ( 414.0 / 750.0 ) = 55.200000width = 200 * ( 414.0 / 750.0 ) = 110.400000height = 200 * ( 414.0 / 750.0 ) = 110.400000 再转换成 pt： 12345x = round ( 110.400000 * 3 ) / 3 = 110.333333y = round ( 55.200000 * 3 ) / 3 = 55.333333width = round ( 110.400000 * 3 ) / 3 = 110.333333height = round ( 110.400000 * 3 ) / 3 = 110.333333 如果只是单纯的认为是针对 750 的成比缩放，那么这里 110.333333 / ( 414.0 / 750.0 ) = 199.87922101，你会发现这个数字距离 200 还是差了零点几。精度就是损失在了 round函数上了 那么当前的 imageComponent 在父视图里面的 Frame = （110.333333，55.333333，110.333333，110.333333）。 回到 onClick: 方法里面。 12345678910111213141516- (void)onClick:(__unused UITapGestureRecognizer *)recognizer&#123; NSMutableDictionary *position = [[NSMutableDictionary alloc] initWithCapacity:4]; CGFloat scaleFactor = self.weexInstance.pixelScaleFactor; if (!CGRectEqualToRect(self.calculatedFrame, CGRectZero)) &#123; CGRect frame = [self.view.superview convertRect:self.calculatedFrame toView:self.view.window]; position[@\"x\"] = @(frame.origin.x/scaleFactor); position[@\"y\"] = @(frame.origin.y/scaleFactor); position[@\"width\"] = @(frame.size.width/scaleFactor); position[@\"height\"] = @(frame.size.height/scaleFactor); &#125; [self fireEvent:@\"click\" params:@&#123;@\"position\":position&#125;];&#125; 如果点击到视图，就会触发点击手势的处理方法，就会进入到上述方法里。 这里会计算出点击到的视图相对于 window 的绝对坐标。 12CGRect frame = [self.view.superview convertRect:self.calculatedFrame toView:self.view.window]; 上面这句话会进行一个坐标转换。坐标系转换到全局的 window 的左边。 还是按照上面举的例子，如果 imageComponent 经过转换以后，frame = （110.33333333333333, 119.33333333333334, 110.33333333333333, 110.33333333333331），这里就是 y 轴的距离发生了变化，因为就加上了 navigation + statusBar 的64的高度。 计算出了这个 window 绝对坐标之后，还要还原成相对于 750.0 宽度的“尺寸”。这里之所以打引号，就是因为这里有精度损失，在 round 函数那里丢了一些精度。 12345x = 110.33333333333333 / ( 414.0 / 750.0 ) = 199.8792270531401y = 119.33333333333334 / ( 414.0 / 750.0 ) = 216.1835748792271width = 110.33333333333333 / ( 414.0 / 750.0 ) = 199.8792270531401height = 110.33333333333333 / ( 414.0 / 750.0 ) = 199.8792270531401 上述就是点击以后经过转换最终得到的坐标，这个坐标会传递给 JS。 （二）轻扫事件接着是轻扫事件。 123WX_ADD_EVENT(swipe, addSwipeEvent) 这个宏和上面点击事件的展开原理一样，这里不再赘述。 如果 addEventName 传进来event的是@“swipe”，那么就是执行 addSwipeEvent 方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647- (void)addSwipeEvent&#123; if (_swipeGestures) &#123; return; &#125; _swipeGestures = [NSMutableArray arrayWithCapacity:4]; // 下面的代码写的比较“奇怪”，原因在于UISwipeGestureRecognizer的direction属性，是一个可选的位掩码，但是每个手势识别器又只能处理一个方向的手势，所以就导致了下面需要生成四个UISwipeGestureRecognizer的手势识别器。 SEL selector = @selector(onSwipe:); // 新建一个upSwipeRecognizer UISwipeGestureRecognizer *upSwipeRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:selector]; upSwipeRecognizer.direction = UISwipeGestureRecognizerDirectionUp; upSwipeRecognizer.delegate = self; [_swipeGestures addObject:upSwipeRecognizer]; [self.view addGestureRecognizer:upSwipeRecognizer]; // 新建一个downSwipeRecognizer UISwipeGestureRecognizer *downSwipeRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:selector]; downSwipeRecognizer.direction = UISwipeGestureRecognizerDirectionDown; downSwipeRecognizer.delegate = self; [_swipeGestures addObject:downSwipeRecognizer]; [self.view addGestureRecognizer:downSwipeRecognizer]; // 新建一个rightSwipeRecognizer UISwipeGestureRecognizer *rightSwipeRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:selector]; rightSwipeRecognizer.direction = UISwipeGestureRecognizerDirectionRight; rightSwipeRecognizer.delegate = self; [_swipeGestures addObject:rightSwipeRecognizer]; [self.view addGestureRecognizer:rightSwipeRecognizer]; // 新建一个leftSwipeRecognizer UISwipeGestureRecognizer *leftSwipeRecognizer = [[UISwipeGestureRecognizer alloc] initWithTarget:self action:selector]; leftSwipeRecognizer.direction = UISwipeGestureRecognizerDirectionLeft; leftSwipeRecognizer.delegate = self; [_swipeGestures addObject:leftSwipeRecognizer]; [self.view addGestureRecognizer:leftSwipeRecognizer];&#125; 上面会新建4个方向上的手势识别器。因为每个手势识别器又只能处理一个方向的手势，所以就导致了需要生成四个 UISwipeGestureRecognizer 的手势识别器。 给当前的视图增加一个轻扫手势，触发的方法是 onSwipe: 方法。 1234567891011121314151617181920212223242526272829- (void)onSwipe:(UISwipeGestureRecognizer *)gesture&#123; UISwipeGestureRecognizerDirection direction = gesture.direction; NSString *directionString; switch(direction) &#123; case UISwipeGestureRecognizerDirectionLeft: directionString = @\"left\"; break; case UISwipeGestureRecognizerDirectionRight: directionString = @\"right\"; break; case UISwipeGestureRecognizerDirectionUp: directionString = @\"up\"; break; case UISwipeGestureRecognizerDirectionDown: directionString = @\"down\"; break; default: directionString = @\"unknown\"; &#125; CGPoint screenLocation = [gesture locationInView:self.view.window]; CGPoint pageLoacation = [gesture locationInView:self.weexInstance.rootView]; NSDictionary *resultTouch = [self touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier]; [self fireEvent:@\"swipe\" params:@&#123;@\"direction\":directionString, @\"changedTouches\":resultTouch ? @[resultTouch] : @[]&#125;];&#125; 当用户轻扫以后，会触发轻扫手势，于是会在 window 上和 rootView 上会获取到2个坐标。 12345678910111213- (NSDictionary *)touchResultWithScreenLocation:(CGPoint)screenLocation pageLocation:(CGPoint)pageLocation identifier:(NSNumber *)identifier&#123; NSMutableDictionary *resultTouch = [[NSMutableDictionary alloc] initWithCapacity:5]; CGFloat scaleFactor = self.weexInstance.pixelScaleFactor; resultTouch[@\"screenX\"] = @(screenLocation.x/scaleFactor); resultTouch[@\"screenY\"] = @(screenLocation.y/scaleFactor); resultTouch[@\"pageX\"] = @(pageLocation.x/scaleFactor); resultTouch[@\"pageY\"] = @(pageLocation.y/scaleFactor); resultTouch[@\"identifier\"] = identifier; return resultTouch;&#125; screenLocation 和 pageLocation 两个坐标点，还是会根据缩放比例还原成相对于750宽度的页面的坐标。screenLocation 的 X 值和 Y 值、pageLocation 的 X 值和 Y 值分别封装到 resultTouch 字典里。 1234567891011121314151617181920212223@implementation UIGestureRecognizer (WXGesture)- (NSNumber *)wx_identifier&#123; NSNumber *identifier = objc_getAssociatedObject(self, _cmd); if (!identifier) &#123; static NSUInteger _gestureIdentifier; identifier = @(_gestureIdentifier++); self.wx_identifier = identifier; &#125; return identifier;&#125;- (void)setWx_identifier:(NSNumber *)wx_identifier&#123; objc_setAssociatedObject(self, @selector(wx_identifier), wx_identifier, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 最后 resultTouch 里面还包含一个 identifier 的参数，这个 identifier 是一个全局唯一的 NSUInteger。wx_identifier 被关联到了各个手势识别器上了。 （三）长按事件接着是轻扫事件。 123WX_ADD_EVENT(longpress, addLongPressEvent) 这个宏和上面点击事件的展开原理一样，这里不再赘述。 如果 addEventName 传进来 event 的是 @“longpress”，那么就是执行 addLongPressEvent 方法。 123456789- (void)addLongPressEvent&#123; if (!_longPressGesture) &#123; _longPressGesture = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(onLongPress:)]; _longPressGesture.delegate = self; [self.view addGestureRecognizer:_longPressGesture]; &#125;&#125; 给当前的视图增加一个长按手势，触发的方法是 onLongPress: 方法。 12345678910111213- (void)onLongPress:(UILongPressGestureRecognizer *)gesture&#123; if (gesture.state == UIGestureRecognizerStateBegan) &#123; CGPoint screenLocation = [gesture locationInView:self.view.window]; CGPoint pageLoacation = [gesture locationInView:self.weexInstance.rootView]; NSDictionary *resultTouch = [self touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier]; [self fireEvent:@\"longpress\" params:@&#123;@\"changedTouches\":resultTouch ? @[resultTouch] : @[]&#125;]; &#125; else if (gesture.state == UIGestureRecognizerStateEnded) &#123; gesture.wx_identifier = nil; &#125;&#125; 长按手势传给 JS 的参数和轻扫的参数 changedTouches 几乎一致。在长按手势开始的时候就传递给 JS 两个 Point，screenLocation 和 pageLoacation，以及手势的wx_identifier。这部分和轻扫手势基本一样，不多赘述。 （四）拖动事件拖动事件在 Weex 里面包含5个事件。分别对应着拖动的5种状态：拖动开始，拖动中，拖动结束，水平拖动，竖直拖动。 123456WX_ADD_EVENT(panstart, addPanStartEvent)WX_ADD_EVENT(panmove, addPanMoveEvent)WX_ADD_EVENT(panend, addPanEndEvent)WX_ADD_EVENT(horizontalpan, addHorizontalPanEvent)WX_ADD_EVENT(verticalpan, addVerticalPanEvent) 为了区分上面5种状态，Weex 还对每个状态增加了一个 BOOL 变量来判断当前的状态。分别如下： 1234567BOOL _listenPanStart;BOOL _listenPanMove;BOOL _listenPanEnd;BOOL _listenHorizontalPan;BOOL _listenVerticalPan; 通过宏增加的5个事件，实质都是执行了 addPanGesture 方法，只不过每个状态的事件都会跟对应的BOOL变量。 123456789101112131415161718192021222324252627282930313233343536- (void)addPanStartEvent&#123; // 拖动开始 _listenPanStart = YES; [self addPanGesture];&#125;- (void)addPanMoveEvent&#123; // 拖动中 _listenPanMove = YES; [self addPanGesture];&#125;- (void)addPanEndEvent&#123; // 拖动结束 _listenPanEnd = YES; [self addPanGesture];&#125;- (void)addHorizontalPanEvent&#123; // 水平拖动 _listenHorizontalPan = YES; [self addPanGesture];&#125;- (void)addVerticalPanEvent&#123; // 竖直拖动 _listenVerticalPan = YES; [self addPanGesture];&#125; 最终都是调用addPanGesture方法： 12345678910- (void)addPanGesture&#123; if (!_panGesture) &#123; _panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(onPan:)]; _panGesture.delegate = self; [self.view addGestureRecognizer:_panGesture]; &#125;&#125; 给当前的视图增加一个拖动手势，触发的方法是 onPan: 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142- (void)onPan:(UIPanGestureRecognizer *)gesture&#123; CGPoint screenLocation = [gesture locationInView:self.view.window]; CGPoint pageLoacation = [gesture locationInView:self.weexInstance.rootView]; NSString *eventName; NSString *state = @&quot;&quot;; NSDictionary *resultTouch = [self touchResultWithScreenLocation:screenLocation pageLocation:pageLoacation identifier:gesture.wx_identifier]; if (gesture.state == UIGestureRecognizerStateBegan) &#123; if (_listenPanStart) &#123; eventName = @&quot;panstart&quot;; &#125; state = @&quot;start&quot;; &#125; else if (gesture.state == UIGestureRecognizerStateEnded) &#123; if (_listenPanEnd) &#123; eventName = @&quot;panend&quot;; &#125; state = @&quot;end&quot;; gesture.wx_identifier = nil; &#125; else if (gesture.state == UIGestureRecognizerStateChanged) &#123; if (_listenPanMove) &#123; eventName = @&quot;panmove&quot;; &#125; state = @&quot;move&quot;; &#125; CGPoint translation = [_panGesture translationInView:self.view]; if (_listenHorizontalPan &amp;&amp; fabs(translation.y) &lt;= fabs(translation.x)) &#123; [self fireEvent:@&quot;horizontalpan&quot; params:@&#123;@&quot;state&quot;:state, @&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;]; &#125; if (_listenVerticalPan &amp;&amp; fabs(translation.y) &gt; fabs(translation.x)) &#123; [self fireEvent:@&quot;verticalpan&quot; params:@&#123;@&quot;state&quot;:state, @&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;]; &#125; if (eventName) &#123; [self fireEvent:eventName params:@&#123;@&quot;changedTouches&quot;:resultTouch ? @[resultTouch] : @[]&#125;]; &#125;&#125; 拖动事件最终传给 JS 的 resultTouch 字典和前两个手势的原理一样，也是需要传入两个 Point，screenLocation 和 pageLoacation，这里不再赘述。 根据 _listenPanStart，_listenPanEnd，_listenPanMove 判断当前的状态，并生成与之对应的 eventName 和 state 字符串。 根据 _panGesture 在当前视图上拖动形成的有方向的向量，进行判断当前拖动的方向。 （五）通用触摸事件最后就是通用的触摸事件。 Weex 里面对每个 Component 都新建了一个手势识别器。 12345678910111213141516@interface WXTouchGestureRecognizer : UIGestureRecognizer@property (nonatomic, assign) BOOL listenTouchStart;@property (nonatomic, assign) BOOL listenTouchMove;@property (nonatomic, assign) BOOL listenTouchEnd;@property (nonatomic, assign) BOOL listenTouchCancel;@property (nonatomic, assign) BOOL listenPseudoTouch;&#123; __weak WXComponent *_component; NSUInteger _touchIdentifier;&#125;- (instancetype)initWithComponent:(WXComponent *)component NS_DESIGNATED_INITIALIZER;@end WXTouchGestureRecognizer 是继承自 UIGestureRecognizer。里面就5个 BOOL。分别表示5种状态。 WXTouchGestureRecognizer 会弱引用当前的 WXComponent，并且也依旧有touchIdentifier。 Weex 通过以下4个宏注册触摸事件方法。 12345WX_ADD_EVENT(touchstart, addTouchStartEvent)WX_ADD_EVENT(touchmove, addTouchMoveEvent)WX_ADD_EVENT(touchend, addTouchEndEvent)WX_ADD_EVENT(touchcancel, addTouchCancelEvent) 通过上述宏增加的4个事件，实质都是改变每个状态的事件都会跟对应的BOOL变量。 1234567891011121314151617181920- (void)addTouchStartEvent&#123; self.touchGesture.listenTouchStart = YES;&#125;- (void)addTouchMoveEvent&#123; self.touchGesture.listenTouchMove = YES;&#125;- (void)addTouchEndEvent&#123; self.touchGesture.listenTouchEnd = YES;&#125;- (void)addTouchCancelEvent&#123; self.touchGesture.listenTouchCancel = YES;&#125; 当用户开始触摸屏幕，在屏幕上移动，手指从屏幕上结束触摸，取消触摸，分别都会触发touchesBegan:，touchesMoved:，touchesEnded:，touchesCancelled:方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [super touchesBegan:touches withEvent:event]; if (_listenTouchStart) &#123; [self fireTouchEvent:@\"touchstart\" withTouches:touches]; &#125; if(_listenPseudoTouch) &#123; NSMutableDictionary *styles = [_component getPseudoClassStyles:@\"active\"]; [_component updatePseudoClassStyles:styles]; &#125;&#125;- (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [super touchesMoved:touches withEvent:event]; if (_listenTouchMove) &#123; [self fireTouchEvent:@\"touchmove\" withTouches:touches]; &#125;&#125;- (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [super touchesEnded:touches withEvent:event]; if (_listenTouchEnd) &#123; [self fireTouchEvent:@\"touchend\" withTouches:touches]; &#125; if(_listenPseudoTouch) &#123; [self recoveryPseudoStyles:_component.styles]; &#125;&#125;- (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [super touchesCancelled:touches withEvent:event]; if (_listenTouchCancel) &#123; [self fireTouchEvent:@\"touchcancel\" withTouches:touches]; &#125; if(_listenPseudoTouch) &#123; [self recoveryPseudoStyles:_component.styles]; &#125;&#125; 上述的4个事件里面实质都是在调用 fireTouchEvent:withTouches: 方法： 1234567891011121314151617- (void)fireTouchEvent:(NSString *)eventName withTouches:(NSSet&lt;UITouch *&gt; *)touches&#123; NSMutableArray *resultTouches = [NSMutableArray new]; for (UITouch *touch in touches) &#123; CGPoint screenLocation = [touch locationInView:touch.window]; CGPoint pageLocation = [touch locationInView:_component.weexInstance.rootView]; if (!touch.wx_identifier) &#123; touch.wx_identifier = @(_touchIdentifier++); &#125; NSDictionary *resultTouch = [_component touchResultWithScreenLocation:screenLocation pageLocation:pageLocation identifier:touch.wx_identifier]; [resultTouches addObject:resultTouch]; &#125; [_component fireEvent:eventName params:@&#123;@\"changedTouches\":resultTouches ?: @[]&#125;];&#125; 最终这个方法和前3个手势一样，都需要给 resultTouches 传入2个Point和1个wx_identifier。原理一致。 至于坐标如何传递给JS见第二章。 2. Appear 事件如果一个位于某个可滚动区域内的组件被绑定了 appear 事件，那么当这个组件的状态变为在屏幕上可见时，该事件将被触发。 所以绑定了 Appear 事件的都是可以滚动的视图。 123WX_ADD_EVENT(appear, addAppearEvent) 通过上述的宏给可以滚动的视图增加 Appear 事件。也就是当前视图执行 addAppearEvent 方法。 123456- (void)addAppearEvent&#123; _appearEvent = YES; [self.ancestorScroller addScrollToListener:self];&#125; 在 Weex 的每个组件里面都有2个 BOOL 记录着当前 _appearEvent 和 _disappearEvent 的状态。 123BOOL _appearEvent;BOOL _disappearEvent; 当增加对应的事件的时候，就会把对应的 BOOL 变成 YES。 12345678910111213141516- (id&lt;WXScrollerProtocol&gt;)ancestorScroller&#123; if(!_ancestorScroller) &#123; WXComponent *supercomponent = self.supercomponent; while (supercomponent) &#123; if([supercomponent conformsToProtocol:@protocol(WXScrollerProtocol)]) &#123; _ancestorScroller = (id&lt;WXScrollerProtocol&gt;)supercomponent; break; &#125; supercomponent = supercomponent.supercomponent; &#125; &#125; return _ancestorScroller;&#125; 由于 Appear 事件和 Disappear 事件都必须要求是滚动视图，所以这里会遍历当前视图的 supercomponent，直到找到一个遵循 WXScrollerProtocol 的 supercomponent。 123456789101112131415161718- (void)addScrollToListener:(WXComponent *)target&#123; BOOL has = NO; for (WXScrollToTarget *targetData in self.listenerArray) &#123; if (targetData.target == target) &#123; has = YES; break; &#125; &#125; if (!has) &#123; WXScrollToTarget *scrollTarget = [[WXScrollToTarget alloc] init]; scrollTarget.target = target; scrollTarget.hasAppear = NO; [self.listenerArray addObject:scrollTarget]; &#125;&#125; 在滚动视图里面包含有一个 listenerArray，数组里面装的都是被监听的对象。添加进这个数组会先判断当前是否有相同的 WXScrollToTarget，避免重复添加，如果没有重复的就新建一个 WXScrollToTarget，再添加进 listenerArray中。 123456@interface WXScrollToTarget : NSObject@property (nonatomic, weak) WXComponent *target;@property (nonatomic, assign) BOOL hasAppear;@end WXScrollToTarget 是一个普通的对象，里面弱引用了当前需要监听的 WXComponent，以及一个 BOOL 变量记录当前是否 Appear 了。 当滚动视图滚动的时候，就会触发 scrollViewDidScroll: 方法。 123456789101112131415161718192021222324252627282930313233- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; //apply block which are registered WXSDKInstance *instance = self.weexInstance; if ([self.ref isEqualToString:WX_SDK_ROOT_REF] &amp;&amp; [self isKindOfClass:[WXScrollerComponent class]]) &#123; if (instance.onScroll) &#123; instance.onScroll(scrollView.contentOffset); &#125; &#125; if (_lastContentOffset.x &gt; scrollView.contentOffset.x) &#123; _direction = @\"right\"; &#125; else if (_lastContentOffset.x &lt; scrollView.contentOffset.x) &#123; _direction = @\"left\"; &#125; else if(_lastContentOffset.y &gt; scrollView.contentOffset.y) &#123; _direction = @\"down\"; &#125; else if(_lastContentOffset.y &lt; scrollView.contentOffset.y) &#123; _direction = @\"up\"; &#125; _lastContentOffset = scrollView.contentOffset; // check sticky [self adjustSticky]; [self handleLoadMore]; [self handleAppear]; if (self.onScroll) &#123; self.onScroll(scrollView); &#125;&#125; 在上面的方法中[self handleAppear]就是触发了判断是否 Appear 了。 123456789101112131415161718- (void)handleAppear&#123; if (![self isViewLoaded]) &#123; return; &#125; UIScrollView *scrollView = (UIScrollView *)self.view; CGFloat vx = scrollView.contentInset.left + scrollView.contentOffset.x; CGFloat vy = scrollView.contentInset.top + scrollView.contentOffset.y; CGFloat vw = scrollView.frame.size.width - scrollView.contentInset.left - scrollView.contentInset.right; CGFloat vh = scrollView.frame.size.height - scrollView.contentInset.top - scrollView.contentInset.bottom; CGRect scrollRect = CGRectMake(vx, vy, vw, vh);; // notify action for appear for(WXScrollToTarget *target in self.listenerArray)&#123; [self scrollToTarget:target scrollRect:scrollRect]; &#125;&#125; 上面这个方法会把 listenerArray 数组里面的每个 WXScrollToTarget 对象都调用 scrollToTarget:scrollRect: 方法。根据当前滚动的情况传入一个 CGRect，这个 CGRect 就是当前滚动到那个矩形区域的坐标信息以及宽和高。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (void)scrollToTarget:(WXScrollToTarget *)target scrollRect:(CGRect)rect&#123; WXComponent *component = target.target; if (![component isViewLoaded]) &#123; return; &#125; // 计算出当前的可见区域的顶部坐标 CGFloat ctop; if (component &amp;&amp; component-&gt;_view &amp;&amp; component-&gt;_view.superview) &#123; ctop = [component-&gt;_view.superview convertPoint:component-&gt;_view.frame.origin toView:_view].y; &#125; else &#123; ctop = 0.0; &#125; // 计算出当前的可见区域的底部坐标 CGFloat cbottom = ctop + CGRectGetHeight(component.calculatedFrame); // 计算出当前的可见区域的左边界坐标 CGFloat cleft; if (component &amp;&amp; component-&gt;_view &amp;&amp; component-&gt;_view.superview) &#123; cleft = [component-&gt;_view.superview convertPoint:component-&gt;_view.frame.origin toView:_view].x; &#125; else &#123; cleft = 0.0; &#125; // 计算出当前的可见区域的右边界坐标 CGFloat cright = cleft + CGRectGetWidth(component.calculatedFrame); // 获取传入的滚动的区域 CGFloat vtop = CGRectGetMinY(rect), vbottom = CGRectGetMaxY(rect), vleft = CGRectGetMinX(rect), vright = CGRectGetMaxX(rect); // 判断当前可见区域是否包含在传入的滚动区域内，如果在，并且监听了appear事件，就触发appear事件，否则如果监听了disappear事件就触发disappear事件 if(cbottom &gt; vtop &amp;&amp; ctop &lt;= vbottom &amp;&amp; cleft &lt;= vright &amp;&amp; cright &gt; vleft)&#123; if(!target.hasAppear &amp;&amp; component)&#123; target.hasAppear = YES; // 如果当前监听了appear，就触发appear事件 if (component-&gt;_appearEvent) &#123; [component fireEvent:@\"appear\" params:_direction ? @&#123;@\"direction\":_direction&#125; : nil]; &#125; &#125; &#125; else &#123; if(target.hasAppear &amp;&amp; component)&#123; target.hasAppear = NO; // 如果当前监听了disappear，就触发disappear事件 if(component-&gt;_disappearEvent)&#123; [component fireEvent:@\"disappear\" params:_direction ? @&#123;@\"direction\":_direction&#125; : nil]; &#125; &#125; &#125;&#125; scrollToTarget:scrollRect: 方法的核心就是拿当前可视区域和传入的滚动区域进行对比，如果在该区域内，且监听了 appear 事件，就会触发 appear 事件，如果不在该区域内，且监听了 disappear 事件，就会触发 disappear 事件。 3. Disappear 事件如果一个位于某个可滚动区域内的组件被绑定了 disappear 事件，那么当这个组件被滑出屏幕变为不可见状态时，该事件将被触发。 同理，绑定了 Disappear 事件的都是可以滚动的视图。 123WX_ADD_EVENT(disappear, addDisappearEvent) 通过上述的宏给可以滚动的视图增加 Disappear 事件。也就是当前视图执行 addDisappearEvent 方法。 123456- (void)addDisappearEvent&#123; _disappearEvent = YES; [self.ancestorScroller addScrollToListener:self];&#125; 接下去的和 Appear 事件的原理就一模一样了。 4. Page 事件暂时 Weex 只支持 iOS 和 Android，H5 暂不支持。 Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力。 viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。 与组件 Component的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上。 特殊情况下，这两个事件也能被绑定到非根元素的 body 组件上，例如 wxc-navpage 组件。 举个例子： 12345678910111213- (void)_updateInstanceState:(WXState)state&#123; if (_instance &amp;&amp; _instance.state != state) &#123; _instance.state = state; if (state == WeexInstanceAppear) &#123; [[WXSDKManager bridgeMgr] fireEvent:_instance.instanceId ref:WX_SDK_ROOT_REF type:@\"viewappear\" params:nil domChanges:nil]; &#125; else if (state == WeexInstanceDisappear) &#123; [[WXSDKManager bridgeMgr] fireEvent:_instance.instanceId ref:WX_SDK_ROOT_REF type:@\"viewdisappear\" params:nil domChanges:nil]; &#125; &#125;&#125; 比如在 WXBaseViewController 里面，有这样一个更新当前 Instance 状态的方法，这个方法里面就会触发 viewappear 和 viewdisappear 事件。 其中 WX_SDK_ROOT_REF 就是 _root 12#define WX_SDK_ROOT_REF @\"_root\" 上述更新状态的方法同样出现在 WXEmbedComponent 组件中。 123456789101112131415- (void)_updateState:(WXState)state&#123; if (_renderFinished &amp;&amp; _embedInstance &amp;&amp; _embedInstance.state != state) &#123; _embedInstance.state = state; if (state == WeexInstanceAppear) &#123; [self setNavigationWithStyles:self.embedInstance.naviBarStyles]; [[WXSDKManager bridgeMgr] fireEvent:self.embedInstance.instanceId ref:WX_SDK_ROOT_REF type:@\"viewappear\" params:nil domChanges:nil]; &#125; else if (state == WeexInstanceDisappear) &#123; [[WXSDKManager bridgeMgr] fireEvent:self.embedInstance.instanceId ref:WX_SDK_ROOT_REF type:@\"viewdisappear\" params:nil domChanges:nil]; &#125; &#125;&#125; 二.Weex 的事件传递在 Weex 中，iOS Native 把事件传递给 JS 目前只有2种方式，一是 Module 模块的 callback，二是通过 Component 组件自定义的通知事件。 （1）callback 在 WXModuleProtocol 中定义了2种可以 callback 给 JS 的闭包。 12345678910111213/** * @abstract the module callback , result can be string or dictionary. * @discussion callback data to js, the id of callback function will be removed to save memory. */typedef void (^WXModuleCallback)(id result);/** * @abstract the module callback , result can be string or dictionary. * @discussion callback data to js, you can specify the keepAlive parameter to keep callback function id keepalive or not. If the keepAlive is true, it won't be removed until instance destroyed, so you can call it repetitious. */typedef void (^WXModuleKeepAliveCallback)(id result, BOOL keepAlive); 两个闭包都可以 callback 把 data 传递回给 JS，data 可以是字符串或者字典。 这两个闭包的区别在于： WXModuleCallback 用于 Module 组件，为了节约内存，该回调只能回调通知 JS 一次，之后会被释放，多用于一次结果。 WXModuleKeepAliveCallback 同样是用于 Module 组件，但是该回调可以设置是否为多次回调类型，如果设置了 keepAlive，那么可以进行持续监听变化，多次回调，并返回给 JS。 在 Weex 中使用 WXModuleCallback 回调，很多情况是把状态回调给 JS，比如成功或者失败的状态，还有一些出错的信息回调给 JS。 比如在 WXStorageModule 中 123456789101112131415161718192021222324252627- (void)setItem:(NSString *)key value:(NSString *)value callback:(WXModuleCallback)callback&#123; if ([self checkInput:key]) &#123; callback(@&#123;@\"result\":@\"failed\",@\"data\":@\"key must a string or number!\"&#125;); return; &#125; if ([self checkInput:value]) &#123; callback(@&#123;@\"result\":@\"failed\",@\"data\":@\"value must a string or number!\"&#125;); return; &#125; if ([key isKindOfClass:[NSNumber class]]) &#123; key = [((NSNumber *)key) stringValue]; &#125; if ([value isKindOfClass:[NSNumber class]]) &#123; value = [((NSNumber *)value) stringValue]; &#125; if ([WXUtility isBlankString:key]) &#123; callback(@&#123;@\"result\":@\"failed\",@\"data\":@\"invalid_param\"&#125;); return ; &#125; [self setObject:value forKey:key persistent:NO callback:callback];&#125; 在调用 setItem:value:callback: 方法里面，如果 setKey-value 的时候失败了，会把错误信息通过 WXModuleCallback 回调给JS。 当然，如果调用存储模块 WXStorageModule 的某些查询信息的方法： 1234567891011- (void)length:(WXModuleCallback)callback&#123; callback(@&#123;@\"result\":@\"success\",@\"data\":@([[WXStorageModule memory] count])&#125;);&#125;- (void)getAllKeys:(WXModuleCallback)callback&#123; callback(@&#123;@\"result\":@\"success\",@\"data\":[WXStorageModule memory].allKeys&#125;);&#125; length: 和 getAllKeys: 方法调用成功，会把成功的状态和数据通过 WXModuleCallback 回调给JS。 在 Weex 中使用了 WXModuleKeepAliveCallback 的模块总共只有以下4个： WXDomModule，WXStreamModule，WXWebSocketModule，WXGlobalEventModule 在 WXDomModule 模块中，JS 调用获取 Component 组件的位置信息和宽高信息的时候，需要把这些坐标和尺寸信息回调给 JS，不过这里虽然用到了WXModuleKeepAliveCallback，但是 keepAlive 是 false，并没有用到多次回调的功能。 在 WXStreamModule 模块中，由于这是一个传输流的模块，所以肯定需要用到WXModuleKeepAliveCallback，需要持续不断的监听数据的变化，并把进度回调给 JS，这里用到了 keepAlive。WXStreamModule 模块中也会用到 WXModuleCallback，WXModuleCallback 会即时把各个状态回调给 JS。 在 WXWebSocketModule 模块中 12345678910@interface WXWebSocketModule()@property(nonatomic,copy)WXModuleKeepAliveCallback errorCallBack;@property(nonatomic,copy)WXModuleKeepAliveCallback messageCallBack;@property(nonatomic,copy)WXModuleKeepAliveCallback openCallBack;@property(nonatomic,copy)WXModuleKeepAliveCallback closeCallBack;@end 用到了4个 WXModuleKeepAliveCallback 回调，这4个 callback 分别是把 error 错误信息，message 收到的数据，open 打开链接的状态，close 关闭链接的状态，持续的回调给 JS。 在 WXGlobalEventModule 模块中，有一个 fireGlobalEvent: 方法。 12345678910111213141516- (void)fireGlobalEvent:(NSNotification *)notification&#123; NSDictionary * userInfo = notification.userInfo; NSString * userWeexInstanceId = userInfo[@\"weexInstance\"]; WXSDKInstance * userWeexInstance = [WXSDKManager instanceForID:userWeexInstanceId]; // 防止userInstanceId存在，但是instance实际已经被销毁了 if (!userWeexInstanceId || userWeexInstance == weexInstance) &#123; for (WXModuleKeepAliveCallback callback in _eventCallback[notification.name]) &#123; callback(userInfo[@\"param\"], true); &#125; &#125;&#125; 开发者可以通过 WXGlobalEventModule 进行全局的通知，在 userInfo 里面可以夹带 weexInstance 的参数。native 是不需要关心 userWeexInstanceId，这个参数是给 JS 用的。 Native 开发者只需要在用到了 WXGlobalEventModule 的模块里加上事件的监听者，然后发送全局通知即可。userInfo[@”param”]会被回调给 JS。 （2）fireEvent:params:domChanges: 在开头我们介绍的 Weex 事件的4种类型，通用事件，Appear 事件，Disappear 事件，Page 事件，全部都是通过 fireEvent:params:domChanges: 这种方式，Native 触发事件之后，Native 把参数传递给 JS 的。 在 WXComponent 里面定义了2个可以给 JS 发送消息的方法： 12345678910111213141516171819/** * @abstract Fire an event to the component in Javascript. * * @param eventName The name of the event to fire * @param params The parameters to fire with **/- (void)fireEvent:(NSString *)eventName params:(nullable NSDictionary *)params;/** * @abstract Fire an event to the component and tell Javascript which value has been changed. * Used for two-way data binding. * * @param eventName The name of the event to fire * @param params The parameters to fire with * @param domChanges The values has been changed, used for two-way data binding. **/- (void)fireEvent:(NSString *)eventName params:(nullable NSDictionary *)params domChanges:(nullable NSDictionary *)domChanges; 这两个方法的区别就在于最后一个 domChanges 的参数，有这个参数的方法主要多用于 Weex 的 Native 和 JS 的双向数据绑定。 123456789101112131415161718- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params&#123; [self fireEvent:eventName params:params domChanges:nil];&#125;- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges&#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; NSTimeInterval timeSp = [[NSDate date] timeIntervalSince1970] * 1000; [dict setObject:@(timeSp) forKey:@\"timestamp\"]; if (params) &#123; [dict addEntriesFromDictionary:params]; &#125; [[WXSDKManager bridgeMgr] fireEvent:self.weexInstance.instanceId ref:self.ref type:eventName params:dict domChanges:domChanges];&#125; 上述就是两个方法的具体实现。可以看到 fireEvent:params: 方法就是调用了 fireEvent:params:domChanges: 方法，只不过最后的 domChanges 参数传了 nil。 在fireEvent:params:domChanges: 方法中会对 params 字典做了一次加工，加上了 timestamp 的键值。最终还是会调用 WXBridgeManager 里面的 fireEvent:ref: type:params:domChanges: 方法。 在 WXBridgeManager 中具体实现了上述的两个方法。 1234567891011121314151617181920- (void)fireEvent:(NSString *)instanceId ref:(NSString *)ref type:(NSString *)type params:(NSDictionary *)params&#123; [self fireEvent:instanceId ref:ref type:type params:params domChanges:nil];&#125;- (void)fireEvent:(NSString *)instanceId ref:(NSString *)ref type:(NSString *)type params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges&#123; if (!type || !ref) &#123; WXLogError(@\"Event type and component ref should not be nil\"); return; &#125; NSArray *args = @[ref, type, params?:@&#123;&#125;, domChanges?:@&#123;&#125;]; WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; WXCallJSMethod *method = [[WXCallJSMethod alloc] initWithModuleName:nil methodName:@\"fireEvent\" arguments:args instance:instance]; [self callJsMethod:method];&#125; 入参 ref, type, params, domChanges 封装到最终的 args 参数数组里面，最后会封装出 WXCallJSMethod 方法，通过 WXBridgeManager 的 callJsMethod 调用到 JS 的 fireEvent 方法。 这里可以举个例子： 假设一个场景，用户点击了一张图片，于是就会改变 label 上的一段文字。 首先图片是 imageComponent，用户点击会触发该 Component 的 onclick: 方法 组件里面会调用 fireEvent:params: 方法： 12[self fireEvent:@\"click\" params:@&#123;@\"position\":position&#125;]; 最终通过 fireEvent:params:domChanges: 方法，发送给 JS 的参数字典大概如下： 12345678910111213141516171819202122232425args:( 0, ( &#123; args = ( 3, click, &#123; position = &#123; height = \"199.8792270531401\"; width = \"199.8792270531401\"; x = \"274.7584541062802\"; y = \"115.9420289855072\"; &#125;; timestamp = \"1489932655404.133\"; &#125;, &#123; &#125; ); method = fireEvent; module = \"\"; &#125; )) JSFramework 收到了 fireEvent 方法调用以后，处理完，知道 label 需要更新，于是又会开始 call Native，调用 Native 的方法。调用 Native 的 callNative 方法，发过来的参数如下： 1234567891011121314( &#123; args = ( 4, &#123; value = \"\\U56fe\\U7247\\U88ab\\U70b9\\U51fb\"; &#125; ); method = updateAttrs; module = dom; &#125;) 最终会调用 Dom 的 updateAttrs 方法，会去更新 id 为4的 value，id 为4对应的就是 label，更新它的值就是刷新 label。 接着 JSFramework 还会继续调用 Native 的 callNative 方法，发过来的参数如下： 12345678910( &#123; args = ( ); method = updateFinish; module = dom; &#125;) 调用 Dom 的 updateFinish 方法，即页面刷新完毕。 最后至此，Weex 从 View 的创建，到渲染，产生事件回调 JSFramework，这一系列的流程源码都解析完成了。 中间涉及到了3个子线程，mainThread，com.taobao.weex.component，com.taobao.weex.bridge，分别是 UI 主线程，DOM 线程，JSbridge 线程。 Native 端目前还差神秘的 JSFramework 的源码解析。请大家多多指点。 Weex 源码解析系列文章： Weex 是如何在 iOS 客户端上跑起来的由 FlexBox 算法强力驱动的 Weex 布局引擎Weex 事件传递的那些事儿Weex 中别具匠心的 JS FrameworkiOS 开发者的 Weex 伪最佳实践指北","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"weex系列抄之二---weex原理","date":"2018-05-04T04:07:12.000Z","path":"wiki/Hybird/weex/weex_two/","text":"关于WeexWeex是一套跨平台的动态页面解决方案，让开发者可以用前端的语法写出Native级别的体验，这一点核心功能与React Native是相同的，但RN并不是今天的主角， 这里也不多花笔墨介绍。WEEX宣称「Write Once, Run Everywhere」，同一份代码可以在不同端上运行。Weex是如何做到的呢？ 话不多说，先上一张上镜率特别高的流程图，了解一下Weex的工作流程： 在服务端，开发者将写好的Weex文件转换成JS bundle并部署到服务器上供终端下载；终端会在合适的时机拉取JS Bundle，同时利用WeexSDK 中预先准备好的 JavaScript 引擎解析执行JS bundle，在执行过程中通过JS-Native Bridge产生各种终端能够识别的命令进行界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践。 Weex框架Weex源码可以在Github(https://github.com/apache/incubator-weex)上下载到，先看下0.16.1版本下的文件目录结构： 目录的划分比较清楚，一个目录基本就是对应一个功能模块，我们可以对其做一个归类，把它分为三端：JS端、桥接端和纯Native端。见下图：（灰色的方块代表一个文件目录） JS端JS端主要内容是Weex源码中的native-bundle-main.js文件，它提供了一系列Weex的基础JS方法，作用相当于一个库，因此我们又称之为JS Framework。Weex把JS Bundle拆分为基础JS库和业务JS代码， 并把JS库带到安装包中，这样一来，页面请求的JS Bundle就只需要包含业务代码，体积会变得很小，对于加载速度提升大有裨益。JS Framework会在WeexSDK初始化时被加载到内存中。 桥接端（Bridge）桥接层负责JS和Native的通信，主要依靠一个全局的JSContext作为媒介。WeexSDK初始化时会往这个全局的JSContext中注入一些方法，举个栗子： 1234567891011- (void)registerCallNative:(WXJSCallNative)callNative&#123; JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123; NSString *instanceId = [instance toString]; NSArray *tasksArray = [tasks toArray]; NSString *callbackId = [callback toString]; return [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]]; &#125;; _jsContext[@\"callNative\"] = callNativeBlock&#125; 而终端调用JS也是通过取JSContext对象，调用invokeMethod:withArguments:方法实现。 1234- (JSValue *)callJSMethod:(NSString *)method args:(NSArray *)args&#123; return [[_jsContext globalObject] invokeMethod:method withArguments:args];&#125; 纯Native端主要的业务都代码都是这一端，包括JS Bundle的请求、UI渲染、性能统计等等。功能层面对其自上而下划分，又可拆分为接口层（Interface）、功能层（Function）、基础层（Basic）。 接口层顾名思义，就是对外暴露API的模块，是最贴近开发者的一层。通过Engine可以对SDK进行初始化，同时注册一些通用的Component和Module，JS Framework会在此时被加载。Controller不必多说，可以使用这个现成的Controller创建一个weex页面，我们需要做的仅仅是传递一个url给它。但如果想要自已实现一个Weex Controller而不是继承它，这个时候就需要用到Model中的WXSDKInstance，Weex渲染过程的各个阶段都会在WXSDKInstance中有回调，JS Bundle的请求也是在这个类中发出。 先绕过功能层，看基础层。基础层提供了一些基础的、与业务无强相关的功能。如Network就是对NSURLSession进行一次再封装，提供基础的下载功能；Event用来定义一些标准手势事件；Layout则是页面布局相关实现，布局引擎采用C语言，可以跨平台使用。Event和Layout最终都服务于Component。 最后是代码最重的功能层，其中Monitor和DevTool是相对比较独立的，Monitor是测速模块，DevTool用来支持远程调试的，可以不集成到代码中，不影响编译，此处不谈。 Module、Component和Handler是Weex三贱客，它们都是采用插件的形式集合到SDK中，很方便扩展。注册的时机也相同，SDK会在初始化时调用registerDefaultModules/Compoents/Handlers加载一些标准的插件。 123456+ (void)registerDefaults&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers];&#125; 12345678// register some default components when the engine initializes.+ (void)_registerDefaultComponents&#123; [self registerComponent:@\"container\" withClass:NSClassFromString(@\"WXDivComponent\") withProperties:nil]; [self registerComponent:@\"div\" withClass:NSClassFromString(@\"WXComponent\") withProperties:nil]; [self registerComponent:@\"text\" withClass:NSClassFromString(@\"WXTextComponent\") withProperties:nil]; [self registerComponent:@\"image\" withClass:NSClassFromString(@\"WXImageComponent\") withProperties:nil]; ……&#125; 从注册时的命名上不难看出，Component实现的是UIKit的功能。那还有两贱客是干吗的？我们可以认为Module是终端提供给JS的功能模块，为了让JS获得终端的能力，例如网络请求的能力（WXStreamModule）、定时器的能力（WXTimerModule）等。三贱客里，Component和Module都是可以直接和JS通信的，而Handler不行，Handler仅仅作为面向协议编程的一种手段，在纯Native端使用。 Loader就是采用了Handler的形式对Network进行了进一步的再封装，用这种方式会让Loader模块更灵活一些，开发者完全可以通过重新注册Handler来挂载新的网络请求方法，实现一些自定义的功能。 除了Component和Module，还有一个模块可以直接和JS通信，就是结构图中与桥接端相邻的Manager（与桥接端相邻代表二者可以直接通信），Manager模块主要包括WXComponentManager和Factory，WXComponentManager用来做Component的调度，而Factory用来保存Component和Module的配置。 讲完了WeexSDK源码框架，或许读者还是会有不少疑问：说了那么一堆高大上的名词，然并卵，我还是不知道Weex是怎么跑起来的。那我们就更具体一点，去看看Module和Component的世界吧。 Module前面有一个高频词汇：注册。所谓注册，其实在实现上就是往全局字典里面以Key-Value的形式保存一些模块的信息。Weex三贱客都需要注册，Handler的注册上文提到过，其实就是以Protocol Name为Key，往全局字典里面写入一个实现了该Protocol的对象。Module和Component的注册则更接近一些，都是以注册时的标签为Key，而保存的value是一个WXInvocationConfig派生类对象，可以瞄一眼WXInvocationConfig携带的信息，包括：标签名、类名、同步方法和异步方法。 123456789101112@interface WXInvocationConfig : NSObject@property (nonatomic, strong) NSString *name;@property (nonatomic, strong) NSString *clazz;@property (nonatomic, strong) NSMutableDictionary *asyncMethods;@property (nonatomic, strong) NSMutableDictionary *syncMethods;- (instancetype)initWithName:(NSString *)name class:(NSString *)clazz;- (void)registerMethods;@end 以WXDomModule为例，在WXDomModule的类实现文件中有一坨被WX_EXPORT_METHOD宏定义包裹的selector： 1234567WX_EXPORT_METHOD(@selector(createBody:))WX_EXPORT_METHOD(@selector(addElement:element:atIndex:))WX_EXPORT_METHOD(@selector(removeElement:))WX_EXPORT_METHOD(@selector(moveElement:parentRef:index:))WX_EXPORT_METHOD(@selector(addEvent:event:))WX_EXPORT_METHOD(@selector(removeEvent:event:))…… 12345678#define WX_EXPORT_METHOD(method) WX_EXPORT_METHOD_INTERNAL(method,wx_export_method_)#define WX_EXPORT_METHOD_INTERNAL(method, token) \\+ (NSString *)WX_CONCAT_WRAPPER(token, __LINE__) &#123; \\ return NSStringFromSelector(method); \\&#125;#define WX_CONCAT_WRAPPER(a, b) WX_CONCAT(a, b) 123+ (NSString *)wx_export_method_40 &#123; return NSStringFromSelector(@selector(createBody:));&#125; 12345678910111213141516171819202122232425262728293031323334353637383940- (void)registerMethods&#123; Class currentClass = NSClassFromString(_clazz); while (currentClass != [NSObject class]) &#123; unsigned int methodCount = 0; Method *methodList = class_copyMethodList(object_getClass(currentClass), &amp;methodCount); for (unsigned int i = 0; i &lt; methodCount; i++) &#123; NSString *selStr = [NSString stringWithCString:sel_getName(method_getName(methodList[i])) encoding:NSUTF8StringEncoding]; BOOL isSyncMethod = NO; if ([selStr hasPrefix:@\"wx_export_method_sync_\"]) &#123; isSyncMethod = YES; &#125; else if ([selStr hasPrefix:@\"wx_export_method_\"]) &#123; isSyncMethod = NO; &#125; else &#123; continue; &#125; NSString *name = nil, *method = nil; SEL selector = NSSelectorFromString(selStr); if ([currentClass respondsToSelector:selector]) &#123; method = ((NSString* (*)(id, SEL))[currentClass methodForSelector:selector])(currentClass, selector); &#125; NSRange range = [method rangeOfString:@\":\"]; if (range.location != NSNotFound) &#123; name = [method substringToIndex:range.location]; &#125; else &#123; name = method; &#125; NSMutableDictionary *methods = isSyncMethod ? _syncMethods : _asyncMethods; [methods setObject:method forKey:name]; &#125; free(methodList); currentClass = class_getSuperclass(currentClass); &#125;&#125; 调用完registerMethods方法后，WXDomModule的Config包含的信息如下： 同步方法和异步方法存储的Key列表就是JS端可调用的函数名列表。趁热打铁，继续看下JS端是具体是怎么调用这些暴露出去的方法。在前文第二节Weex框架中有提到，WeexSDK会在桥接层往JSContext注入一些方法作为JS调用Native的通道，其中callNativeModule方法就是用来调用Native Module的（JS调用Module不仅限于callNativeModule方法）。12345[_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) &#123; WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments options:options instance:instance]; return [method invoke];&#125;];| Moudule | 能力| — | — || WXDomModule | 提供Demo解析能力 || WXNavigatorModule | 提供控制UI能力 || WXStreamModule | 提供网络请求能力 || WXAnimationModule | 提供动画能力 || WXModalUIModule | 提供alert、toast等模态UI展示能力 || WXWebViewModule | 提供webview基础能力 || WXInstanceWrap | 提供访问终端instance实例能力 || WXTimerModule | 提供定时器能力 || WXStorageModule | 提供持久化能力 || WXClipboardModule | 提供剪切板能力 || WXGlobalEventModule | 提供全局事件(监听通知)能力 || WXCanvasModule | 提供绘图能力 || WXPickerModule | 提供DatePicker和TimePicker能力 || WXMetaModule | 提供设置视口(viewport)能力 || WXWebSocketModule | 提供WebSocket能力 || WXVoiceOverModule | 提供VoiceOver能力 |## Component理解了Module后再来看一下Component。前面提到过Component的主要作用对应UIKit,每一个Component类就与一种UI类型强相关，如tableView、imageView。Component维护了一个生命周期，这一点跟UIViewController有点相似：Component的init方法有许多参数要传，包括样式、属性、事件等都可以在初始化时传入；loadView时，WXComponent的派生类需要返回一个UI类型实例，它会被赋值给Component的view属性，跟Component关联起来；loadView之后会走到addEvent，这里允许我们添加一些自定义的事件（常用的单击、长按等事件已经实现，在初始化时传入即可，不需要操作addEvent方法）；在viewDidLoad中可以对view做个性化的配置，然后启动布局。Weex允许在view加载出来了以后再去updateStyles/Attributes，JS可以直接访问到这个Component对象。JS调用Component的原理和Module基本一样，通过注入的callNativeComponent、callUpdateAttrs等一系列方法，在调用过程中生成一个WXComponentMethod对象，然后再利用NSInvocation invoke触达Native。除此之外，JS还可以通过WXComponentManager间接调用Component。WXComponentManager是Component的调度器，可以直接和JS通信。注入JSContext的方法中与其相关的有callAddElement、callRemoveElement、callAddEvent等,通过这些方法直接调用WXComponentManager即图示中的链路①。而在首屏渲染时通常走的是链路②，即JS Framework在解析JS Bundle时会先访问WXDomModule，然后再由WXDomModule间接地调用WXComponentManager，两种方式其实没有太大差别，在首屏全部使用WXDomModule会更容易监控Dom解析过程而已。 addComponent的作用类似于addSubview，WXComponentManager会先用JS传递过来的componentData创建Component对象，然后再把生成的Component添加到它supercomponent的树结构中，同时把Component关联的view加到视图层级上去，之后再对它的children结点递归调用addComponent。 1234567891011121314151617181920- (void)_recursivelyAddComponent:(NSDictionary *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(NSInteger)index appendingInTree:(BOOL)appendingInTree&#123; WXComponent *component = [self _buildComponentForData:componentData supercomponent:supercomponent]; [supercomponent _insertSubcomponent:component atIndex:index]; if (!component-&gt;_isTemplate) &#123; [supercomponent insertSubview:component atIndex:index]; &#125; NSArray *subcomponentsData = [componentData valueForKey:@\"children\"]; BOOL appendTree = !appendingInTree &amp;&amp; [component.attributes[@\"append\"] isEqualToString:@\"tree\"]; // if ancestor is appending tree, child should not be laid out again even it is appending tree. for(NSDictionary *subcomponentData in subcomponentsData)&#123; [self _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:-1 appendingInTree:appendTree || appendingInTree]; &#125; [component _didInserted]; if (appendTree) &#123; // If appending tree，force layout in case of too much tasks piling up in syncQueue [self _layoutAndSyncUI]; &#125;&#125; WXComponentManager中会起一个DisplayLink，在每个定时周期循环遍历各个元素，检查是否需要更新布局，需要布局的cssNode会在is_dirty字段标识。如果超过1s没有布局任务，DisplayLink会进入休眠状态直至下一次唤醒。 WXSDKInstance在了解过Module和Component的大致原理后，对Weex已经有一个基本认知，但距离整个流程跑通还欠缺一点。分散的Module和Component本身是不会工作的，还需要一个动力，这时我们的WXSDKInstance就要粉墨登场了。 还记得最初的那张Weex框架图吗？ WXSDKInstance（在Model模块里）是整个Weex页面加载的起点，它会去服务端请求JS Bundle，没有JS Bundle我们什么事都干不了！ WXSDKInstance下载JS Bundle后，会把它传给JS Framework，JS Framework解析JS Bundle并通过WXDomModule往RootView上渲染视图。每个WXSDKInstance都会绑定一个独立的WXComponentManager。 用图表示的话，流程大概是下面这样子，WXSDKInstace负责串联各部分模块并带动整个流程： 在一些关键的流程上，WXSDKInstance都会有回调，如图上标注出的onCreate()是在下载完JS Bundle，RootView被创建出时回调；renderFinish()是在首屏Dom解析完成后回调；除此之外，还有onFailed()会在加载失败时回调，onJSRuntimeException()在JS执行异常时回调。这些回调都是对外暴露的，我们可以这些回调上做一些定制化的内容。 参考 官方教程 官方手册 企鹅电竞weex实践—— iOS SDK的小九九","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"weex系列抄之一---环境搭建","date":"2018-05-04T04:07:12.000Z","path":"wiki/Hybird/weex/weex_one/","text":"React Native 和 Weex自从Weex出生的那一天起，就无法摆脱和React Native相互比较的命运。React Native宣称“Learn once, write anywhere”，而Weex宣称“Write Once, Run Everywhere”。Weex从出生那天起，就被给予了一统三端的厚望。React Native可以支持iOS、Android，而Weex可以支持iOS、Android、HTML5。 在Native端，两者的最大的区别可能就是在对JSBundle是否分包。React Native官方只允许将React Native基础JS库和业务JS一起打成一个JS bundle，没有提供分包的功能，所以如果想节约流量就必须制作分包打包工具。而Weex默认打的JS bundle只包含业务JS代码，体积小很多，基础JS库包含在Weex SDK中，这一点Weex与Facebook的React Native和微软的Cordova相比，Weex更加轻量，体积小巧。 在JS端，Weex又被人称为Vue Native，所以 React Native 和 Weex 的区别就在 React 和 Vue 两者上了。 笔者没有写过React Native，所以也没法客观的去比较两者。不过知乎上有一个关于Weex 和 React Native很好的对比文章《weex&amp;React Native对比》，推荐大家阅读。 前两天@Allen 许帅也在Glow 技术团队博客上面发布了一篇《React Native 在 Glow 的实践》这篇文章里面也谈了很多关于React Native实践相关的点，也强烈推荐大家去阅读。 入门手册关于小白想入门Weex，当然最基础的还是要通读文档，文档是官方最好的学习资料。官方的基础文档有两份： 教程文档手册文档 在文档手册里面包含了Weex所有目前有的组件，模块，每个组件和模块的用法和属性。遇到问题可以先过来翻翻。很有可能有些组件和模块没有那些属性。 Weex系列工具看完官方文档以后，就可以开始上手构建工程项目了。 Weex也和前端项目一样，拥有它自己的脚手架全家桶。 weex-toolkit weexpack playground code snippets weex-devtool。 weex-toolkitweex-toolkit是用来初始化项目，编译，运行，debug所有工具。 通过下面的命令安装 1npm install -g weex-toolkit 安装完成后就可以使用weex 命令了 我们主要用的就是debug 和 compile命令。debug 是启动chrome调试器 、compile命令是将写好的js文件编译为JS bundle。 weexpackweexpack是用来打包JSBundle的，实际也是对Webpack的封装。 playgroundplayground是一个上架的App，这个可以用来通过扫码实时在手机上显示出实际的页面。 code snippetscode snippets这个是一个在线的playground。 weex-devtoolweex-devtool 可以使用chrome调试JS 代码。 这个工具我认为主要方便前端开发使用。 使用步骤，首先启动调试服务，终端输入 1weex debug 结果如下: 同时启动chrome。然后在代码中将host换为图中的host。 12345678910111213NSString *strHost = [[NSUserDefaults standardUserDefaults] objectForKey:GWX_WEEX_DEBUG_HOST]; if(strHost.length&gt;5) &#123; NSString *strURL = [NSString stringWithFormat:@\"ws://%@/debugProxy/native\",strHost]; [WXDevTool setDebug:YES]; [WXLog setLogLevel:WXLogLevelLog]; [WXDevTool launchDevToolDebugWithUrl:strURL]; &#125; else &#123; [WXDebugTool setDebug:NO]; [WXLog setLogLevel:WXLogLevelError]; &#125; 启动app，看到app链接到了 chrome调试服务器 下图是debuger 截图 ： 下图是inspect截图： 具体使用方法看这两篇文章即可： 《Weex 入坑指南：Debug 调试是一门手艺活》 《Weex调试神器——Weex Devtools使用手册》 Weex Market插件在日常开发中，我们可以全部自己开发完所有的Weex界面，当然还可以用一些已有的优秀的轮子。Weex的所有优秀的轮子都在Weex Market里面。 Weex Market 在这个Market里面有很多已经写好的轮子，直接拿来用，可以节约很多时间。 比如这里很火的weex-chart。weex-chart图表插件是通过g2-mobile依赖[gcanvas插件][23]实现的 如果你想使用[Weex Market][24]的Plugin插件，你可以使用weex plugin 命令： 1$ weex plugin add plugin_name 你只需要输入插件的名称就可以从远程添加插件到你本地的项目，比如添加 weex-chart，我们可以输入命令： 1$ weex plugin add weex-chart 我们可以使用plugin remove移除插件，比如移除安装好的 weex-cahrt： 1$ weex plugin remove weex-chart 这个插件库里面我用过weex-router，还不错，用它来做weex的路由管理。推荐使用。 参考 官方教程 官方手册 iOS 开发者的 Weex 伪最佳实践指北","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"weex系列抄之四---flex 布局","date":"2018-05-04T04:07:12.000Z","path":"wiki/Hybird/weex/weex_four/","text":"一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 .box{ display: flex; } 行内元素也可以使用 Flex 布局。 .box{ display: inline-flex; } Webkit 内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; / Safari / display: flex; } 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上。 flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 3.3 flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: || ; } 3.4 justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 3.5 align-items属性align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flexalign-self 4.1 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: ; } 4.2 flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: ; / default 0 / } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: ; / default 1 / } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: | auto; / default auto / } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 抄袭地址 Flex 布局教程：语法篇","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎","date":"2018-05-04T04:07:12.000Z","path":"wiki/Hybird/weex/Weex_five/","text":"前言在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。 目录 1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的 一. Weex布局算法打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。 Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。 当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。 Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(Yoga官网)。 那么Flexbox是什么呢？ 熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。 关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。官方文档链接 Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。 故以下源码分析都基于v0.10.0这个版本。 （一）FlexBox中的基本数据结构Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。 在FlexBox的世界里，存在着主轴和侧轴的概念。 大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况： 在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。 主轴（main axis）：父视图的主轴，子视图主要沿着这条轴进行排列布局。 主轴起点（main-start）和主轴终点（main-end）：子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。 主轴尺寸（main size）：子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。 侧轴（cross axis）：垂直于主轴称为侧轴。它的方向主要取决于主轴方向。 侧轴起点（cross-start）和侧轴终点（cross-end）：子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。 侧轴尺寸（cross size）：子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。 接下来看看Layout是怎么定义FlexBox里面的元素的。 123456typedef enum &#123; CSS_DIRECTION_INHERIT = 0, CSS_DIRECTION_LTR, CSS_DIRECTION_RTL&#125; css_direction_t; 这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。 12345678typedef enum &#123; CSS_FLEX_DIRECTION_COLUMN = 0, CSS_FLEX_DIRECTION_COLUMN_REVERSE, CSS_FLEX_DIRECTION_ROW, CSS_FLEX_DIRECTION_ROW_REVERSE&#125; css_flex_direction_t; 这里定义的是Flex的方向。 上图是COLUMN。布局的走向是从上往下。 上图是COLUMN_REVERSE。布局的走向是从下往上。 上图是ROW。布局的走向是从左往右。 上图是ROW_REVERSE。布局的走向是从右往左。 这里可以看出来，在LTR的上下文中，ROW_REVERSE即等于RTL的上下文中的ROW。 123456789typedef enum &#123; CSS_JUSTIFY_FLEX_START = 0, CSS_JUSTIFY_CENTER, CSS_JUSTIFY_FLEX_END, CSS_JUSTIFY_SPACE_BETWEEN, CSS_JUSTIFY_SPACE_AROUND&#125; css_justify_t; 这是定义的子视图在主轴上的排列方式。 上图是JUSTIFY_FLEX_START 上图是JUSTIFY_CENTER 上图是JUSTIFY_FLEX_END 上图是JUSTIFY_SPACE_BETWEEN 上图是JUSTIFY_SPACE_AROUND。这种方式是每个视图的左右都保持着一定的宽度。 12345678typedef enum &#123; CSS_ALIGN_AUTO = 0, CSS_ALIGN_FLEX_START, CSS_ALIGN_CENTER, CSS_ALIGN_FLEX_END, CSS_ALIGN_STRETCH&#125; css_align_t; 这是定义的子视图在侧轴上的对齐方式。 在Weex这里定义了三种属于css_align_t类型的方式，align_content，align_items，align_self。这三种类型的对齐方式略有不同。 ALIGN_AUTO只是针对align_self的一个默认值，但是对于align_content，align_items子视图的对齐方式是无效的值。 1.align_itemsalign_items定义的是子视图在一行里面侧轴上排列的方式。 上图是ALIGN_FLEX_START 上图是ALIGN_CENTER 上图是ALIGN_FLEX_END 上图是ALIGN_STRETCH align_items在W3C的定义里面其实还有一个种baseline的对齐方式，这里在定义里面并没有。 注意，上面这种baseline的对齐方式在Weex的定义里面并没有！ 2. align_contentalign_content定义的是子视图行与行之间在侧轴上排列的方式。 上图是ALIGN_FLEX_START 上图是ALIGN_CENTER 上图是ALIGN_FLEX_END 上图是ALIGN_STRETCH 在FlexBox的W3C的定义里面其实还有两种方式在Weex没有定义。 上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_AROUND，align-content里面的space-around这种对齐方式在Weex是没有的。 上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_BETWEEN，align-content里面的space-between这种对齐方式在Weex是没有的。 3.align_self最后这一种对齐方式是可以在align_items的基础上再分别自定义每个子视图的对齐方式。如果是auto，是与align_items方式相同。 12345typedef enum &#123; CSS_POSITION_RELATIVE = 0, CSS_POSITION_ABSOLUTE&#125; css_position_type_t; 这个是定义坐标地址的类型，有相对坐标和绝对坐标两种。 12345typedef enum &#123; CSS_NOWRAP = 0, CSS_WRAP&#125; css_wrap_type_t; 在Weex里面wrap只有两种类型。 上图是NOWRAP。所有的子视图都会排列在一行之中。 上图是WRAP。所有的子视图会从左到右，从上到下排列。 在W3C的标准里面还有一种wrap_reverse的排列方式。 这种排列方式，是从左到右，从下到上进行排列，目前在Weex里面没有定义。 12345678910typedef enum &#123; CSS_LEFT = 0, CSS_TOP, CSS_RIGHT, CSS_BOTTOM, CSS_START, CSS_END, CSS_POSITION_COUNT&#125; css_position_t; 这里定义的是坐标的描述。Left和Top因为会出现在position[2] 和 position[4]中，所以它们两个排列在Right和Bottom前面。 1234567typedef enum &#123; CSS_MEASURE_MODE_UNDEFINED = 0, CSS_MEASURE_MODE_EXACTLY, CSS_MEASURE_MODE_AT_MOST&#125; css_measure_mode_t; 这里定义的是计算的方式，一种是精确计算，另外一种是估算近视值。 12345typedef enum &#123; CSS_WIDTH = 0, CSS_HEIGHT&#125; css_dimension_t; 这里定义的是子视图的尺寸，宽和高。 1234567891011121314typedef struct &#123; float position[4]; float dimensions[2]; css_direction_t direction; // 缓存一些信息防止每次Layout过程都要重复计算 bool should_update; float last_requested_dimensions[2]; float last_parent_max_width; float last_parent_max_height; float last_dimensions[2]; float last_position[2]; css_direction_t last_direction;&#125; css_layout_t; 这里定义了一个css_layout_t结构体。结构体里面position和dimensions数组里面分别存储的是四周的位置和宽高的尺寸。direction里面存储的就是LTR还是RTL的方向。 至于下面那些变量信息都是缓存，用来防止没有改变的Lauout还会重复计算的问题。 1234typedef struct &#123; float dimensions[2];&#125; css_dim_t; css_dim_t结构体里面装的就是子视图的尺寸信息，宽和高。 12345678910111213141516171819202122232425262728293031323334typedef struct &#123; // 整个页面CSS的方向，LTR、RTL css_direction_t direction; // Flex 的方向 css_flex_direction_t flex_direction; // 子视图在主轴上的排列对齐方式 css_justify_t justify_content; // 子视图在侧轴上行与行之间的对齐方式 css_align_t align_content; // 子视图在侧轴上的对齐方式 css_align_t align_items; // 子视图自己本身的对齐方式 css_align_t align_self; // 子视图的坐标系类型(相对坐标系，绝对坐标系) css_position_type_t position_type; // wrap类型 css_wrap_type_t flex_wrap; float flex; // 上，下，左，右，start，end float margin[6]; // 上，下，左，右 float position[4]; // 上，下，左，右，start，end float padding[6]; // 上，下，左，右，start，end float border[6]; // 宽，高 float dimensions[2]; // 最小的宽和高 float minDimensions[2]; // 最大的宽和高 float maxDimensions[2];&#125; css_style_t; css_style_t记录了整个style的所有信息。每个变量的意义见上面注释。 1234567891011121314151617typedef struct css_node css_node_t;struct css_node &#123; css_style_t style; css_layout_t layout; int children_count; int line_index; css_node_t *next_absolute_child; css_node_t *next_flex_child; css_dim_t (*measure)(void *context, float width, css_measure_mode_t widthMode, float height, css_measure_mode_t heightMode); void (*print)(void *context); struct css_node* (*get_child)(void *context, int i); bool (*is_dirty)(void *context); void *context;&#125;; css_node定义的是FlexBox的一个节点的数据结构。它包含了之前的css_style_t和css_layout_t。由于结构体里面无法定义成员函数，所以下面包含4个函数指针。 123css_node_t *new_css_node(void);void init_css_node(css_node_t *node);void free_css_node(css_node_t *node); 上面3个函数是关于css_node的生命周期相关的函数。 1234567891011// 新建节点css_node_t *new_css_node() &#123; css_node_t *node = (css_node_t *)calloc(1, sizeof(*node)); init_css_node(node); return node;&#125;// 释放节点void free_css_node(css_node_t *node) &#123; free(node);&#125; 新建节点的时候就是调用的init_css_node方法。 12345678910111213141516171819202122232425262728293031323334353637383940void init_css_node(css_node_t *node) &#123; node-&gt;style.align_items = CSS_ALIGN_STRETCH; node-&gt;style.align_content = CSS_ALIGN_FLEX_START; node-&gt;style.direction = CSS_DIRECTION_INHERIT; node-&gt;style.flex_direction = CSS_FLEX_DIRECTION_COLUMN; // 注意下面这些数组里面的值初始化为undefined，而不是0 node-&gt;style.dimensions[CSS_WIDTH] = CSS_UNDEFINED; node-&gt;style.dimensions[CSS_HEIGHT] = CSS_UNDEFINED; node-&gt;style.minDimensions[CSS_WIDTH] = CSS_UNDEFINED; node-&gt;style.minDimensions[CSS_HEIGHT] = CSS_UNDEFINED; node-&gt;style.maxDimensions[CSS_WIDTH] = CSS_UNDEFINED; node-&gt;style.maxDimensions[CSS_HEIGHT] = CSS_UNDEFINED; node-&gt;style.position[CSS_LEFT] = CSS_UNDEFINED; node-&gt;style.position[CSS_TOP] = CSS_UNDEFINED; node-&gt;style.position[CSS_RIGHT] = CSS_UNDEFINED; node-&gt;style.position[CSS_BOTTOM] = CSS_UNDEFINED; node-&gt;style.margin[CSS_START] = CSS_UNDEFINED; node-&gt;style.margin[CSS_END] = CSS_UNDEFINED; node-&gt;style.padding[CSS_START] = CSS_UNDEFINED; node-&gt;style.padding[CSS_END] = CSS_UNDEFINED; node-&gt;style.border[CSS_START] = CSS_UNDEFINED; node-&gt;style.border[CSS_END] = CSS_UNDEFINED; node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED; node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED; // 以下这些用来对比是否发生变化的缓存变量，初始值都为 -1。 node-&gt;layout.last_requested_dimensions[CSS_WIDTH] = -1; node-&gt;layout.last_requested_dimensions[CSS_HEIGHT] = -1; node-&gt;layout.last_parent_max_width = -1; node-&gt;layout.last_parent_max_height = -1; node-&gt;layout.last_direction = (css_direction_t)-1; node-&gt;layout.should_update = true;&#125; css_node的初始化的align_items是ALIGN_STRETCH，align_content是ALIGN_FLEX_START，direction是继承自父类，flex_direction是按照列排列的。 接着下面数组里面存的都是UNDEFINED，而不是0，因为0会和结构体里面的0冲突。 最后缓存的变量初始化都为-1。 接下来定义了4个全局的数组，这4个数组非常有用，它会决定接下来layout的方向和属性。4个数组和轴的方向是相互关联的。 123456static css_position_t leading[4] = &#123; /* CSS_FLEX_DIRECTION_COLUMN = */ CSS_TOP, /* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */ CSS_BOTTOM, /* CSS_FLEX_DIRECTION_ROW = */ CSS_LEFT, /* CSS_FLEX_DIRECTION_ROW_REVERSE = */ CSS_RIGHT&#125;; 如果主轴在COLUMN垂直方向，那么子视图的leading就是CSS_TOP，方向如果是COLUMN_REVERSE，那么子视图的leading就是CSS_BOTTOM；如果主轴在ROW水平方向，那么子视图的leading就是CSS_LEFT，方向如果是ROW_REVERSE，那么子视图的leading就是CSS_RIGHT。 1234567static css_position_t trailing[4] = &#123; /* CSS_FLEX_DIRECTION_COLUMN = */ CSS_BOTTOM, /* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */ CSS_TOP, /* CSS_FLEX_DIRECTION_ROW = */ CSS_RIGHT, /* CSS_FLEX_DIRECTION_ROW_REVERSE = */ CSS_LEFT&#125;; 如果主轴在COLUMN垂直方向，那么子视图的trailing就是CSS_BOTTOM，方向如果是COLUMN_REVERSE，那么子视图的trailing就是CSS_TOP；如果主轴在ROW水平方向，那么子视图的trailing就是CSS_RIGHT，方向如果是ROW_REVERSE，那么子视图的trailing就是CSS_LEFT。 1234567static css_position_t pos[4] = &#123; /* CSS_FLEX_DIRECTION_COLUMN = */ CSS_TOP, /* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */ CSS_BOTTOM, /* CSS_FLEX_DIRECTION_ROW = */ CSS_LEFT, /* CSS_FLEX_DIRECTION_ROW_REVERSE = */ CSS_RIGHT&#125;; 如果主轴在COLUMN垂直方向，那么子视图的position就是以CSS_TOP开始的，方向如果是COLUMN_REVERSE，那么子视图的position就是以CSS_BOTTOM开始的；如果主轴在ROW水平方向，那么子视图的position就是以CSS_LEFT开始的，方向如果是ROW_REVERSE，那么子视图的position就是以CSS_RIGHT开始的。 1234567static css_dimension_t dim[4] = &#123; /* CSS_FLEX_DIRECTION_COLUMN = */ CSS_HEIGHT, /* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */ CSS_HEIGHT, /* CSS_FLEX_DIRECTION_ROW = */ CSS_WIDTH, /* CSS_FLEX_DIRECTION_ROW_REVERSE = */ CSS_WIDTH&#125;; 如果主轴在COLUMN垂直方向，那么子视图在这个方向上的尺寸就是CSS_HEIGHT，方向如果是COLUMN_REVERSE，那么子视图在这个方向上的尺寸也是CSS_HEIGHT；如果主轴在ROW水平方向，那么子视图在这个方向上的尺寸就是CSS_WIDTH，方向如果是ROW_REVERSE，那么子视图在这个方向上的尺寸是CSS_WIDTH。 （二）FlexBox中的布局算法Weex 盒模型基于 CSS 盒模型，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。 盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。 盒子模型如上，这个图是基于LTR，并且主轴在水平方向的。 所以主轴在不同方向可能就会有不同的情况。 注意：Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容content、内边距padding和边框的宽度border，不包含外边距的宽度margin。 123456789101112// 判断轴是否是水平方向static bool isRowDirection(css_flex_direction_t flex_direction) &#123; return flex_direction == CSS_FLEX_DIRECTION_ROW || flex_direction == CSS_FLEX_DIRECTION_ROW_REVERSE;&#125;// 判断轴是否是垂直方向static bool isColumnDirection(css_flex_direction_t flex_direction) &#123; return flex_direction == CSS_FLEX_DIRECTION_COLUMN || flex_direction == CSS_FLEX_DIRECTION_COLUMN_REVERSE;&#125; 判断轴的方向的方向就是上面这两个。 然后接着还要计算4个方向上的padding、border、margin。这里就举一个方向的例子。 首先如何计算Margin的呢？ 1234567static float getLeadingMargin(css_node_t *node, css_flex_direction_t axis) &#123; if (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_START])) &#123; return node-&gt;style.margin[CSS_START]; &#125; return node-&gt;style.margin[leading[axis]];&#125; 判断轴的方向是不是水平方向，如果是水平方向就直接取node的margin里面的CSS_START即是LeadingMargin，如果是竖直方向，就取出在竖直轴上面的leading方向的margin的值。 如果取TrailingMargin那么就取margin[CSS_END]。 12345678static float getTrailingMargin(css_node_t *node, css_flex_direction_t axis) &#123; if (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_END])) &#123; return node-&gt;style.margin[CSS_END]; &#125; return node-&gt;style.margin[trailing[axis]];&#125; 以下padding、border、margin三个值的数组存储有6个值，如果是水平方向，那么CSS_START存储的都是Leading，CSS_END存储的都是Trailing。下面没有特殊说明，都按照这个规则来。 1234567891011121314static float getLeadingPadding(css_node_t *node, css_flex_direction_t axis) &#123; if (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.padding[CSS_START]) &amp;&amp; node-&gt;style.padding[CSS_START] &gt;= 0) &#123; return node-&gt;style.padding[CSS_START]; &#125; if (node-&gt;style.padding[leading[axis]] &gt;= 0) &#123; return node-&gt;style.padding[leading[axis]]; &#125; return 0;&#125; 取Padding的思路也和取Margin的思路一样，水平方向就是取出数组里面的padding[CSS_START]，如果是竖直方向，就对应得取出padding[leading[axis]]的值即可。 1234567891011121314static float getLeadingBorder(css_node_t *node, css_flex_direction_t axis) &#123; if (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.border[CSS_START]) &amp;&amp; node-&gt;style.border[CSS_START] &gt;= 0) &#123; return node-&gt;style.border[CSS_START]; &#125; if (node-&gt;style.border[leading[axis]] &gt;= 0) &#123; return node-&gt;style.border[leading[axis]]; &#125; return 0;&#125; 最后这是Border的计算方法，和上述Padding，Margin一模一样，这里就不再赘述了。 四周边距的计算方法都实现了，接下来就是如何layout了。 123456// 计算布局的方法void layoutNode(css_node_t *node, float maxWidth, float maxHeight, css_direction_t parentDirection);// 在调用layoutNode之前，可以重置node节点的layoutvoid resetNodeLayout(css_node_t *node); 重置node节点的方法就是把节点的坐标重置为0，然后把宽和高都重置为UNDEFINED。 1234567void resetNodeLayout(css_node_t *node) &#123; node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED; node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED; node-&gt;layout.position[CSS_LEFT] = 0; node-&gt;layout.position[CSS_TOP] = 0;&#125; 最后，布局方法就是如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void layoutNode(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) &#123; css_layout_t *layout = &amp;node-&gt;layout; css_direction_t direction = node-&gt;style.direction; layout-&gt;should_update = true; // 对比当前环境是否“干净”，以及比较待布局的node节点和上次节点是否完全一致。 bool skipLayout = !node-&gt;is_dirty(node-&gt;context) &amp;&amp; eq(layout-&gt;last_requested_dimensions[CSS_WIDTH], layout-&gt;dimensions[CSS_WIDTH]) &amp;&amp; eq(layout-&gt;last_requested_dimensions[CSS_HEIGHT], layout-&gt;dimensions[CSS_HEIGHT]) &amp;&amp; eq(layout-&gt;last_parent_max_width, parentMaxWidth) &amp;&amp; eq(layout-&gt;last_parent_max_height, parentMaxHeight) &amp;&amp; eq(layout-&gt;last_direction, direction); if (skipLayout) &#123; // 把缓存的值直接赋值给当前的layout layout-&gt;dimensions[CSS_WIDTH] = layout-&gt;last_dimensions[CSS_WIDTH]; layout-&gt;dimensions[CSS_HEIGHT] = layout-&gt;last_dimensions[CSS_HEIGHT]; layout-&gt;position[CSS_TOP] = layout-&gt;last_position[CSS_TOP]; layout-&gt;position[CSS_LEFT] = layout-&gt;last_position[CSS_LEFT]; &#125; else &#123; // 缓存node节点 layout-&gt;last_requested_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH]; layout-&gt;last_requested_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT]; layout-&gt;last_parent_max_width = parentMaxWidth; layout-&gt;last_parent_max_height = parentMaxHeight; layout-&gt;last_direction = direction; // 初始化所有子视图node的尺寸和位置 for (int i = 0, childCount = node-&gt;children_count; i &lt; childCount; i++) &#123; resetNodeLayout(node-&gt;get_child(node-&gt;context, i)); &#125; // 布局视图的核心实现 layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection); // 布局完成，把此次的布局缓存起来，防止下次重复的布局重复计算 layout-&gt;last_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH]; layout-&gt;last_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT]; layout-&gt;last_position[CSS_TOP] = layout-&gt;position[CSS_TOP]; layout-&gt;last_position[CSS_LEFT] = layout-&gt;position[CSS_LEFT]; &#125;&#125; 每步都注释了，见上述代码注释，在调用布局的核心实现layoutNodeImpl之前，会循环调用resetNodeLayout，初始化所有子视图。 所有的核心实现就在layoutNodeImpl这个方法里面了。Weex里面的这个方法实现有700多行，在Yoga的实现中，布局算法有1000多行。 1234static void layoutNodeImpl(css_node_t *node, float parentMaxWidth, float parentMaxHeight, css_direction_t parentDirection) &#123;&#125; 这里分析一下这个算法的主要流程。在Weex的这个实现中，有7个循环，假设依次分别标上A，B，C，D，E，F，G。 先来看循环A 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778float mainContentDim = 0;// 存在3类子视图，支持flex的子视图，不支持flex的子视图，绝对布局的子视图，我们需要知道哪些子视图是在等待分配空间。int flexibleChildrenCount = 0;float totalFlexible = 0;int nonFlexibleChildrenCount = 0;// 利用一层循环在主轴上简单的堆叠子视图，在循环C中，会忽略这些已经在循环A中已经排列好的子视图bool isSimpleStackMain = (isMainDimDefined &amp;&amp; justifyContent == CSS_JUSTIFY_FLEX_START) || (!isMainDimDefined &amp;&amp; justifyContent != CSS_JUSTIFY_CENTER);int firstComplexMain = (isSimpleStackMain ? childCount : startLine);// 利用一层循环在侧轴上简单的堆叠子视图，在循环D中，会忽略这些已经在循环A中已经排列好的子视图bool isSimpleStackCross = true;int firstComplexCross = childCount;css_node_t* firstFlexChild = NULL;css_node_t* currentFlexChild = NULL;float mainDim = leadingPaddingAndBorderMain;float crossDim = 0;float maxWidth = CSS_UNDEFINED;float maxHeight = CSS_UNDEFINED;// 循环A从这里开始for (i = startLine; i &lt; childCount; ++i) &#123; child = node-&gt;get_child(node-&gt;context, i); child-&gt;line_index = linesCount; child-&gt;next_absolute_child = NULL; child-&gt;next_flex_child = NULL; css_align_t alignItem = getAlignItem(node, child); // 在递归layout之前，先预填充侧轴上可以被拉伸的子视图 if (alignItem == CSS_ALIGN_STRETCH &amp;&amp; child-&gt;style.position_type == CSS_POSITION_RELATIVE &amp;&amp; isCrossDimDefined &amp;&amp; !isStyleDimDefined(child, crossAxis)) &#123; // 这里要进行一个比较，比较子视图在侧轴上的尺寸 和 侧轴上减去两边的Margin、padding、Border剩下的可拉伸的空间 进行比较，因为拉伸是不会压缩原始的大小的。 child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf( boundAxis(child, crossAxis, node-&gt;layout.dimensions[dim[crossAxis]] - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)), getPaddingAndBorderAxis(child, crossAxis) ); &#125; else if (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE) &#123; // 这里会储存一个绝对布局子视图的链表。这样我们在后面布局的时候可以快速的跳过它们。 if (firstAbsoluteChild == NULL) &#123; firstAbsoluteChild = child; &#125; if (currentAbsoluteChild != NULL) &#123; currentAbsoluteChild-&gt;next_absolute_child = child; &#125; currentAbsoluteChild = child; // 预填充子视图，这里需要用到视图在轴上面的绝对坐标，如果是水平轴，需要用到左右的偏移量，如果是竖直轴，需要用到上下的偏移量。 for (ii = 0; ii &lt; 2; ii++) &#123; axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN; if (isLayoutDimDefined(node, axis) &amp;&amp; !isStyleDimDefined(child, axis) &amp;&amp; isPosDefined(child, leading[axis]) &amp;&amp; isPosDefined(child, trailing[axis])) &#123; child-&gt;layout.dimensions[dim[axis]] = fmaxf( // 这里是绝对布局，还需要减去leading和trailing boundAxis(child, axis, node-&gt;layout.dimensions[dim[axis]] - getPaddingAndBorderAxis(node, axis) - getMarginAxis(child, axis) - getPosition(child, leading[axis]) - getPosition(child, trailing[axis])), getPaddingAndBorderAxis(child, axis) ); &#125; &#125; &#125; 循环A的具体实现如上，注释见代码。循环A主要是实现的是layout布局中不可以flex的子视图的布局，mainContentDim变量是用来记录所有的尺寸以及所有不能flex的子视图的margin的总和。它被用来设置node节点的尺寸，和计算剩余空间以便供可flex子视图进行拉伸适配。 每个node节点的next_absolute_child维护了一个链表，这里存储的依次是绝对布局视图的链表。 接着需要再统计可以被拉伸的子视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758float nextContentDim = 0;// 统计可以拉伸flex的子视图if (isMainDimDefined &amp;&amp; isFlex(child)) &#123; flexibleChildrenCount++; totalFlexible += child-&gt;style.flex; // 存储一个链表维护可以flex的子视图 if (firstFlexChild == NULL) &#123; firstFlexChild = child; &#125; if (currentFlexChild != NULL) &#123; currentFlexChild-&gt;next_flex_child = child; &#125; currentFlexChild = child; // 这时我们虽然不知道确切的尺寸信息，但是已经知道了padding , border , margin，我们可以利用这些信息来给子视图确定一个最小的size，计算剩余可用的空间。 // 下一个content的距离等于当前子视图Leading和Trailing的padding , border , margin6个尺寸之和。 nextContentDim = getPaddingAndBorderAxis(child, mainAxis) + getMarginAxis(child, mainAxis);&#125; else &#123; maxWidth = CSS_UNDEFINED; maxHeight = CSS_UNDEFINED; // 计算出最大宽度和最大高度 if (!isMainRowDirection) &#123; if (isLayoutDimDefined(node, resolvedRowAxis)) &#123; maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow; &#125; else &#123; maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow; &#125; &#125; else &#123; if (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123; maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] - paddingAndBorderAxisColumn; &#125; else &#123; maxHeight = parentMaxHeight - getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) - paddingAndBorderAxisColumn; &#125; &#125; // 递归调用layout函数，进行不能拉伸的子视图的布局。 if (alreadyComputedNextLayout == 0) &#123; layoutNode(child, maxWidth, maxHeight, direction); &#125; // 由于绝对布局的子视图的位置和layout无关，所以我们不能用它们来计算mainContentDim if (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123; nonFlexibleChildrenCount++; nextContentDim = getDimWithMargin(child, mainAxis); &#125;&#125; 上述代码就确定出了不可拉伸的子视图的布局。 每个node节点的next_flex_child维护了一个链表，这里存储的依次是可以flex拉伸视图的链表。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 // 将要加入的元素可能会被挤到下一行 if (isNodeFlexWrap &amp;&amp; isMainDimDefined &amp;&amp; mainContentDim + nextContentDim &gt; definedMainDim &amp;&amp; // 如果这里只有一个元素，它可能就需要单独占一行 i != startLine) &#123; nonFlexibleChildrenCount--; alreadyComputedNextLayout = 1; break; &#125; // 停止在主轴上堆叠子视图，剩余的子视图都在循环C里面布局 if (isSimpleStackMain &amp;&amp; (child-&gt;style.position_type != CSS_POSITION_RELATIVE || isFlex(child))) &#123; isSimpleStackMain = false; firstComplexMain = i; &#125; // 停止在侧轴上堆叠子视图，剩余的子视图都在循环D里面布局 if (isSimpleStackCross &amp;&amp; (child-&gt;style.position_type != CSS_POSITION_RELATIVE || (alignItem != CSS_ALIGN_STRETCH &amp;&amp; alignItem != CSS_ALIGN_FLEX_START) || (alignItem == CSS_ALIGN_STRETCH &amp;&amp; !isCrossDimDefined))) &#123; isSimpleStackCross = false; firstComplexCross = i; &#125; if (isSimpleStackMain) &#123; child-&gt;layout.position[pos[mainAxis]] += mainDim; if (isMainDimDefined) &#123; // 设置子视图主轴上的TrailingPosition setTrailingPosition(node, child, mainAxis); &#125; // 可以算出了主轴上的尺寸了 mainDim += getDimWithMargin(child, mainAxis); // 可以算出侧轴上的尺寸了 crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis))); &#125; if (isSimpleStackCross) &#123; child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross; if (isCrossDimDefined) &#123; // 设置子视图侧轴上的TrailingPosition setTrailingPosition(node, child, crossAxis); &#125; &#125; alreadyComputedNextLayout = 0; mainContentDim += nextContentDim; endLine = i + 1; &#125;// 循环A 至此结束 循环A结束以后，会计算出endLine，计算出主轴上的尺寸，侧轴上的尺寸。不可拉伸的子视图的布局也会被确定。 接下来进入循环B的阶段。 循环B主要分为2个部分，第一个部分是用来布局可拉伸的子视图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 为了在主轴上布局，需要控制两个space，一个是第一个子视图和最左边的距离，另一个是两个子视图之间的距离float leadingMainDim = 0;float betweenMainDim = 0;// 记录剩余的可用空间float remainingMainDim = 0;if (isMainDimDefined) &#123; remainingMainDim = definedMainDim - mainContentDim;&#125; else &#123; remainingMainDim = fmaxf(mainContentDim, 0) - mainContentDim;&#125;// 如果当前还有可拉伸的子视图，它们就要填充剩余的可用空间if (flexibleChildrenCount != 0) &#123; float flexibleMainDim = remainingMainDim / totalFlexible; float baseMainDim; float boundMainDim; // 如果剩余的空间不能提供给可拉伸的子视图，不能满足它们的最大或者最小的bounds，那么这些子视图也要排除到计算拉伸的过程之外 currentFlexChild = firstFlexChild; while (currentFlexChild != NULL) &#123; baseMainDim = flexibleMainDim * currentFlexChild-&gt;style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis); boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim); if (baseMainDim != boundMainDim) &#123; remainingMainDim -= boundMainDim; totalFlexible -= currentFlexChild-&gt;style.flex; &#125; currentFlexChild = currentFlexChild-&gt;next_flex_child; &#125; flexibleMainDim = remainingMainDim / totalFlexible; // 不可以拉伸的子视图可以在父视图内部overflow，在这种情况下，假设没有可用的拉伸space if (flexibleMainDim &lt; 0) &#123; flexibleMainDim = 0; &#125; currentFlexChild = firstFlexChild; while (currentFlexChild != NULL) &#123; // 在这层循环里面我们已经可以确认子视图的最终大小了 currentFlexChild-&gt;layout.dimensions[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis, flexibleMainDim * currentFlexChild-&gt;style.flex + getPaddingAndBorderAxis(currentFlexChild, mainAxis) ); // 计算水平方向轴上子视图的最大宽度 maxWidth = CSS_UNDEFINED; if (isLayoutDimDefined(node, resolvedRowAxis)) &#123; maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] - paddingAndBorderAxisResolvedRow; &#125; else if (!isMainRowDirection) &#123; maxWidth = parentMaxWidth - getMarginAxis(node, resolvedRowAxis) - paddingAndBorderAxisResolvedRow; &#125; // 计算垂直方向轴上子视图的最大高度 maxHeight = CSS_UNDEFINED; if (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123; maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] - paddingAndBorderAxisColumn; &#125; else if (isMainRowDirection) &#123; maxHeight = parentMaxHeight - getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) - paddingAndBorderAxisColumn; &#125; // 再次递归完成可拉伸的子视图的布局 layoutNode(currentFlexChild, maxWidth, maxHeight, direction); child = currentFlexChild; currentFlexChild = currentFlexChild-&gt;next_flex_child; child-&gt;next_flex_child = NULL; &#125;&#125; 在上述2个while结束以后，所有可以被拉伸的子视图就都布局完成了。 12345678910111213141516171819202122else if (justifyContent != CSS_JUSTIFY_FLEX_START) &#123; if (justifyContent == CSS_JUSTIFY_CENTER) &#123; leadingMainDim = remainingMainDim / 2; &#125; else if (justifyContent == CSS_JUSTIFY_FLEX_END) &#123; leadingMainDim = remainingMainDim; &#125; else if (justifyContent == CSS_JUSTIFY_SPACE_BETWEEN) &#123; remainingMainDim = fmaxf(remainingMainDim, 0); if (flexibleChildrenCount + nonFlexibleChildrenCount - 1 != 0) &#123; betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount - 1); &#125; else &#123; betweenMainDim = 0; &#125; &#125; else if (justifyContent == CSS_JUSTIFY_SPACE_AROUND) &#123; // 这里是实现SPACE_AROUND的代码 betweenMainDim = remainingMainDim / (flexibleChildrenCount + nonFlexibleChildrenCount); leadingMainDim = betweenMainDim / 2; &#125; &#125; 可flex拉伸的视图布局完成以后，这里是收尾工作，根据justifyContent，更改betweenMainDim和leadingMainDim的大小。 接着再是循环C。 1234567891011121314151617181920212223242526272829303132333435363738394041// 在这个循环中，所有子视图的宽和高都将被确定下来。在确定各个子视图的坐标的时候，同时也将确定父视图的宽和高。mainDim += leadingMainDim;// 按照Line，一层层的循环for (i = firstComplexMain; i &lt; endLine; ++i) &#123; child = node-&gt;get_child(node-&gt;context, i); if (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp; isPosDefined(child, leading[mainAxis])) &#123; // 到这里，绝对坐标的子视图的坐标已经确定下来了，左边距和上边距已经被定下来了。这时子视图的绝对坐标可以确定了。 child-&gt;layout.position[pos[mainAxis]] = getPosition(child, leading[mainAxis]) + getLeadingBorder(node, mainAxis) + getLeadingMargin(child, mainAxis); &#125; else &#123; // 如果子视图不是绝对坐标，坐标是相对的，或者还没有确定下来左边距和上边距，那么就根据当前位置确定坐标 child-&gt;layout.position[pos[mainAxis]] += mainDim; // 确定trailing的坐标位置 if (isMainDimDefined) &#123; setTrailingPosition(node, child, mainAxis); &#125; // 接下来开始处理相对坐标的子视图，具有绝对坐标的子视图不会参与下述的布局计算中 if (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123; // 主轴上的宽度是由所有的子视图的宽度累加而成 mainDim += betweenMainDim + getDimWithMargin(child, mainAxis); // 侧轴的高度是由最高的子视图决定的 crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis))); &#125; &#125;&#125;float containerCrossAxis = node-&gt;layout.dimensions[dim[crossAxis]];if (!isCrossDimDefined) &#123; containerCrossAxis = fmaxf( // 计算父视图的时候需要加上，上下的padding和Border。 boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross );&#125; 在循环C中，会在主轴上计算出所有子视图的坐标，包括各个子视图的宽和高。 接下来就到循环D的流程了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 for (i = firstComplexCross; i &lt; endLine; ++i) &#123; child = node-&gt;get_child(node-&gt;context, i); if (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp; isPosDefined(child, leading[crossAxis])) &#123; // 到这里，绝对坐标的子视图的坐标已经确定下来了，上下左右至少有一边的坐标已经被定下来了。这时子视图的绝对坐标可以确定了。 child-&gt;layout.position[pos[crossAxis]] = getPosition(child, leading[crossAxis]) + getLeadingBorder(node, crossAxis) + getLeadingMargin(child, crossAxis); &#125; else &#123; float leadingCrossDim = leadingPaddingAndBorderCross; // 在侧轴上，针对相对坐标的子视图，我们利用父视图的alignItems或者子视图的alignSelf来确定具体的坐标位置 if (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123; // 获取子视图的AlignItem属性值 css_align_t alignItem = getAlignItem(node, child); if (alignItem == CSS_ALIGN_STRETCH) &#123; // 如果在侧轴上子视图还没有确定尺寸，那么才会相应STRETCH拉伸。 if (!isStyleDimDefined(child, crossAxis)) &#123; float dimCrossAxis = child-&gt;layout.dimensions[dim[crossAxis]]; child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf( boundAxis(child, crossAxis, containerCrossAxis - paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)), getPaddingAndBorderAxis(child, crossAxis) ); // 如果视图的大小变化了，连带该视图的子视图还需要再次layout if (dimCrossAxis != child-&gt;layout.dimensions[dim[crossAxis]] &amp;&amp; child-&gt;children_count &gt; 0) &#123; // Reset child margins before re-layout as they are added back in layoutNode and would be doubled child-&gt;layout.position[leading[mainAxis]] -= getLeadingMargin(child, mainAxis) + getRelativePosition(child, mainAxis); child-&gt;layout.position[trailing[mainAxis]] -= getTrailingMargin(child, mainAxis) + getRelativePosition(child, mainAxis); child-&gt;layout.position[leading[crossAxis]] -= getLeadingMargin(child, crossAxis) + getRelativePosition(child, crossAxis); child-&gt;layout.position[trailing[crossAxis]] -= getTrailingMargin(child, crossAxis) + getRelativePosition(child, crossAxis); // 递归子视图的布局 layoutNode(child, maxWidth, maxHeight, direction); &#125; &#125; &#125; else if (alignItem != CSS_ALIGN_FLEX_START) &#123; // 在侧轴上剩余的空间等于父视图在侧轴上的高度减去子视图的在侧轴上padding、Border、Margin以及高度 float remainingCrossDim = containerCrossAxis - paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis); if (alignItem == CSS_ALIGN_CENTER) &#123; leadingCrossDim += remainingCrossDim / 2; &#125; else &#123; // CSS_ALIGN_FLEX_END leadingCrossDim += remainingCrossDim; &#125; &#125; &#125; // 确定子视图在侧轴上的坐标位置 child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingCrossDim; // 确定trailing的坐标 if (isCrossDimDefined) &#123; setTrailingPosition(node, child, crossAxis); &#125; &#125; &#125; linesCrossDim += crossDim; linesMainDim = fmaxf(linesMainDim, mainDim); linesCount += 1; startLine = endLine;&#125; 上述的循环D中主要是在侧轴上计算子视图的坐标。如果视图发生了大小变化，还需要递归子视图，重新布局一次。 再接着是循环E 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071if (linesCount &gt; 1 &amp;&amp; isCrossDimDefined) &#123; float nodeCrossAxisInnerSize = node-&gt;layout.dimensions[dim[crossAxis]] - paddingAndBorderAxisCross; float remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim; float crossDimLead = 0; float currentLead = leadingPaddingAndBorderCross; // 布局alignContent css_align_t alignContent = node-&gt;style.align_content; if (alignContent == CSS_ALIGN_FLEX_END) &#123; currentLead += remainingAlignContentDim; &#125; else if (alignContent == CSS_ALIGN_CENTER) &#123; currentLead += remainingAlignContentDim / 2; &#125; else if (alignContent == CSS_ALIGN_STRETCH) &#123; if (nodeCrossAxisInnerSize &gt; linesCrossDim) &#123; crossDimLead = (remainingAlignContentDim / linesCount); &#125; &#125; int endIndex = 0; for (i = 0; i &lt; linesCount; ++i) &#123; int startIndex = endIndex; // 计算每一行的行高，行高根据lineHeight和子视图在侧轴上的高度加上下的Margin之和比较，取最大值 float lineHeight = 0; for (ii = startIndex; ii &lt; childCount; ++ii) &#123; child = node-&gt;get_child(node-&gt;context, ii); if (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123; continue; &#125; if (child-&gt;line_index != i) &#123; break; &#125; if (isLayoutDimDefined(child, crossAxis)) &#123; lineHeight = fmaxf( lineHeight, child-&gt;layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis) ); &#125; &#125; endIndex = ii; lineHeight += crossDimLead; for (ii = startIndex; ii &lt; endIndex; ++ii) &#123; child = node-&gt;get_child(node-&gt;context, ii); if (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123; continue; &#125; // 布局AlignItem css_align_t alignContentAlignItem = getAlignItem(node, child); if (alignContentAlignItem == CSS_ALIGN_FLEX_START) &#123; child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis); &#125; else if (alignContentAlignItem == CSS_ALIGN_FLEX_END) &#123; child-&gt;layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child-&gt;layout.dimensions[dim[crossAxis]]; &#125; else if (alignContentAlignItem == CSS_ALIGN_CENTER) &#123; float childHeight = child-&gt;layout.dimensions[dim[crossAxis]]; child-&gt;layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / 2; &#125; else if (alignContentAlignItem == CSS_ALIGN_STRETCH) &#123; child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis); // TODO(prenaux): Correctly set the height of items with undefined // (auto) crossAxis dimension. &#125; &#125; currentLead += lineHeight; &#125;&#125; 执行循环E有一个前提，就是，行数至少要超过一行，并且侧轴上有高度定义。满足了这个前提条件以后才会开始下面的align规则。 在循环E中会处理侧轴上的align拉伸规则。这里会布局alignContent和AlignItem。 这块代码实现的算法原理请参见http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm section 9.4部分。 至此可能还存在一些没有指定宽和高的视图，接下来将会做最后一次的处理。 12345678910111213141516171819202122232425262728// 如果某个视图没有被指定宽或者高，并且也没有被父视图设置宽和高，那么在这里通过子视图来设置宽和高if (!isMainDimDefined) &#123; // 视图的宽度等于内部子视图的宽度加上Trailing的Padding、Border的宽度和主轴上Leading的Padding、Border+ Trailing的Padding、Border，两者取最大值。 node-&gt;layout.dimensions[dim[mainAxis]] = fmaxf( boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)), paddingAndBorderAxisMain ); if (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE || mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123; needsMainTrailingPos = true; &#125;&#125;if (!isCrossDimDefined) &#123; node-&gt;layout.dimensions[dim[crossAxis]] = fmaxf( // 视图的高度等于内部子视图的高度加上上下的Padding、Border的宽度和侧轴上Padding、Border，两者取最大值。 boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross), paddingAndBorderAxisCross ); if (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE || crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123; needsCrossTrailingPos = true; &#125;&#125; 这些没有确定宽和高的子视图的宽和高会根据父视图来决定。方法见上述代码。 再就是循环F了。 123456789101112131415if (needsMainTrailingPos || needsCrossTrailingPos) &#123; for (i = 0; i &lt; childCount; ++i) &#123; child = node-&gt;get_child(node-&gt;context, i); if (needsMainTrailingPos) &#123; setTrailingPosition(node, child, mainAxis); &#125; if (needsCrossTrailingPos) &#123; setTrailingPosition(node, child, crossAxis); &#125; &#125;&#125; 这一步是设置当前node节点的Trailing坐标，如果有必要的话。如果不需要，这一步会直接跳过。 最后一步就是循环G了。 123456789101112131415161718192021222324252627282930313233343536currentAbsoluteChild = firstAbsoluteChild;while (currentAbsoluteChild != NULL) &#123; for (ii = 0; ii &lt; 2; ii++) &#123; axis = (ii != 0) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN; if (isLayoutDimDefined(node, axis) &amp;&amp; !isStyleDimDefined(currentAbsoluteChild, axis) &amp;&amp; isPosDefined(currentAbsoluteChild, leading[axis]) &amp;&amp; isPosDefined(currentAbsoluteChild, trailing[axis])) &#123; // 绝对坐标的子视图在主轴上的宽度，在侧轴上的高度都不能比Padding、Border的总和小。 currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] = fmaxf( boundAxis(currentAbsoluteChild, axis, node-&gt;layout.dimensions[dim[axis]] - getBorderAxis(node, axis) - getMarginAxis(currentAbsoluteChild, axis) - getPosition(currentAbsoluteChild, leading[axis]) - getPosition(currentAbsoluteChild, trailing[axis]) ), getPaddingAndBorderAxis(currentAbsoluteChild, axis) ); &#125; if (isPosDefined(currentAbsoluteChild, trailing[axis]) &amp;&amp; !isPosDefined(currentAbsoluteChild, leading[axis])) &#123; // 当前子视图的坐标等于当前视图的宽度减去子视图的宽度再减去trailing currentAbsoluteChild-&gt;layout.position[leading[axis]] = node-&gt;layout.dimensions[dim[axis]] - currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] - getPosition(currentAbsoluteChild, trailing[axis]); &#125; &#125; child = currentAbsoluteChild; currentAbsoluteChild = currentAbsoluteChild-&gt;next_absolute_child; child-&gt;next_absolute_child = NULL;&#125; 最后这一步循环G是用来给绝对坐标的子视图计算宽度和高度。 执行完上述7个循环以后，所有的子视图就都layout完成了。 总结一下上述的流程，如下图： 二. Weex布局算法性能分析1.算法实现分析上一章节看了Weex的layout算法实现。这里就分析一下在这个实现下，布局能力究竟有多强。 Weex的实现是FaceBook的开源库Yoga的前身，所以这里可以把两个看成是一种实现。 Weex的这种FlexBox的实现其实只是W3C标准的一个实现的子集，因为FlexBox的官方标准里面还有一些并没有实现出来。W3C上定义的FlexBox的标准，文档在这里。 FlexBox标准定义： 针对父视图 (flex container): display flex-direction flex-wrap flex-flow justify-content align-items align-content 针对子视图 (flex items): order flex-grow flex-shrink flex-basis flex align-self 相比官方的定义，上述的实现有一些限制： 所有显示属性的node节点都默认假定是Flex的视图，当然这里要除去文本节点，因为它会被假定为inline-flex。 不支持zIndex的属性，包括任何z上的排序。所有的node节点都是按照代码书写的先后顺序进行排列的。Weex 目前也不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。 FlexBox里面定义的order属性，也不支持。flex item默认按照代码书写顺序。 visibility属性默认都是可见的，暂时不支持边缘塌陷合并(collapse)和隐藏(hidden)属性。 不支持forced breaks。 不支持垂直方向的inline(比如从上到下的text，或者从下到上的text) 关于Flexbox 在iOS这边的具体实现上一章节已经分析过了。 接下来仔细分析一下Autolayout的具体实现 原来我们用Frame进行布局的时候，需要知道一个点（origin或者center）和宽高就可以确定一个View。 现在换成了Autolayout，每个View需要知道4个尺寸。left，top，width，height。 但是一个View的约束是相对于另一个View的，比如说相对于父视图，或者是相对于两两View之间的。 那么两两个View之间的约束就会变成一个八元一次的方程组。 解这个方程组可能有以下3种情况： 当方程组的解的个数有无穷多个，最终会得到欠约束的有歧义的布局。 当方程无解时，则表示约束有冲突。 只有当方程组有唯一解的时候，才能得到一个稳定的布局。 Autolayout 本质是一个线性方程解析器，该解析器试图找到一种可满足其规则的几何表达式。 Autolayout的底层数学模型是线性算术约束问题。 关于这个问题，早在1940年，由Dantzig提出了一个the simplex algorithm算法，但是由于这个算法实在很难用在UI应用上面，所以没有得到很广泛的应用，直到1997年，澳大利亚的莫纳什大学（Monash University）的两名学生，Alan Borning 和 Kim Marriott实现了Cassowary线性约束算法，才得以在UI应用上被大量的应用起来。 Cassowary线性约束算法是基于双simplex算法的，在增加约束或者一个对象被移除的时候，通过局部误差增益 和 加权求和比较 ，能够完美的增量处理不同层次的约束。Cassowary线性约束算法适合GUI布局系统，被用来计算view之间的位置的。开发者可以指定不同View之间的位置关系和约束关系，Cassowary线性约束算法会去求处符合条件的最优值。 下面是两位学生写的相关的论文，有兴趣的可以读一下，了解一下算法的具体实现： Alan Borning, Kim Marriott, Peter Stuckey, and Yi Xiao, Solving Linear Arithmetic Constraints for User Interface Applications, Proceedings of the 1997 ACM Symposium on User Interface Software and Technology, October 1997, pages 87-96. Greg J. Badros and Alan Borning, “The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation”, Technical Report UW-CSE-98-06-04, June 1998 (pdf) Greg J. Badros, Alan Borning, and Peter J. Stuckey, “The Cassowary Linear Arithmetic Constraint Solving Algorithm,” ACM Transactions on Computer Human Interaction, Vol. 8 No. 4, December 2001, pages 267-306. (pdf) Cassowary线性约束算法的伪代码如下： 关于这个算法已经被人们实现成了各个版本。1年以后，又出了一个新的QOCA算法。以下这段话摘抄自1997年ACM权威论文上的一篇文章： Both of our algorithms have been implemented, Cassowaryin Smalltalk and QOCA in C++. They perform surprisinglywell. The QOCA implementation is considerably more sophisticatedand has much better performance than the current version ofCassowary. However, QOCA is inherently a more complexalgorithm, and re-implementing it with a comparable levelof performance would be a daunting task. In contrast, Cassowaryis straightforward, and a reimplementation based onthis paper is more reasonable, given a knowledge of the simplexalgorithm. Cassowary（项目主页）也是优先被Smalltalk实现了，也是用在Autolayout技术上。另外还有更加复杂的QOCA算法，这里就不再细谈了，有兴趣的同学可以看看上面三篇论文，里面有详细的描述。 2.算法性能测试准备工作开始笔者是打算连带Weex的布局性能一起测试的，但是由于Weex的布局都在子线程，刷新渲染回到主线程，需要测试都在主线程的情况需要改动一些代码，而且Weex原生的布局是从JS调用方法，如果用这种方法又会多损耗一些性能，对测试结果有影响。于是换成Weex相同布局方式的Yoga算法进行测试。由于Facebook对它进行了很好的封装，使用起来也很方便。虽然Layout算法和Weex有些差异，但是不影响定性的比较。 确定下来测试对象：Frame，FlexBox(Yoga实现)，Autolayout。 测试前，还需要准备测试模型，这里选出了3种测试模型。 第一种测试模型是随机生成完全不相关联的View。如下图： 第二种测试模型是生成相互嵌套的View。嵌套规则设置一个简单的：子视图依次比父视图高度少一个像素。类似下图，这是500个View相互嵌套的结果： 第三种测试模型是针对Autolayout专门加的。由于Autolayout约束的特殊性，这里针对链式约束额外增加的测试模型。规则是前后两个相连的View之间依次加上约束。类似下图，这是500个View链式的约束结果： 根据测试模型，我们可以得到如下的7组需要测试的测试用例： 1.Frame2.嵌套的Frame3.Yoga4.嵌套的Yoga5.Autolayout6.嵌套的Autolayout7.链式的Autolayout 测试样本：由于需要考虑到测试的通用性，测试样本要尽量随机。于是针对随机生成的坐标全部都随机生成，View的颜色也全部都随机生成，这样保证了通用公正公平性质。 测试次数：为了保证测试数据能尽量真实，笔者在这里花了大量的时间。每组测试用例都针对从100，200，300，400，500，600，700，800，900，1000个视图进行测试，为了保证测试的普遍性，这里每次测试都测试10000次，然后对10000次的结果进行加和平均。加和平均取小数点后5位。（10000次的统计是用计算机来算的，但是真的非常非常非常的耗时，有兴趣的可以自己用电脑试试） 最后展示一下测试机器的配置和系统版本： （由于iPhone真机对每个App的内存有限制，产生1000个嵌套的视图，并且进行10000次试验，iPhone真机完全受不了这种计算量，App直接闪退，所以用真机测试到一半，改用模拟器测试，借助Mac的性能，咬着牙从零开始，重新统计了所有测试用例的数据） 如果有性能更强的Mac电脑（垃圾桶），测试全过程花的时间可能会更少。 笔者用的电脑的配置如下： 测试用的模拟器是iPad Pro（12.9 inch）iOS 10.3（14E269） 我所用的测试代码也公布出来，有兴趣的可以自己测试测试。测试代码在这里 3.算法性能测试结果公布测试结果： 上图数据是10，20，30，40，50，60，70，80，90，100个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下： 结果依旧是Autolayout的3种方式都高于其他4种布局方式。 上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。 上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。 最后这张图也是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，嵌套的Autolayout的性能依旧是最差的！ 上图数据是100，200，300，400，500，600，700，800，900，1000个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下： 当视图多到900，1000的时候，嵌套的Autolayout直接就导致模拟器崩溃了。 上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。 上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。 最后这张图是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，平时我们使用嵌套的Autolayout的性能是最差的！ 三. Weex是如何布局原生界面的上一章节看了FlexBox算法的强大布局能力，这一章节就来看看Weex究竟是如何利用这个能力的对原生View进行Layout。 在解答上面这个问题之前，先让我们回顾一下上篇文章《Weex 是如何在 iOS 客户端上跑起来的》里面提到的，在JSFramework转换从网络上下载下来的JS文件之前，本地先注册了4个重要的回调函数。 12345typedef NSInteger(^WXJSCallNative)(NSString *instance, NSArray *tasks, NSString *callback);typedef NSInteger(^WXJSCallAddElement)(NSString *instanceId, NSString *parentRef, NSDictionary *elementData, NSInteger index);typedef NSInvocation *(^WXJSCallNativeModule)(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *args, NSDictionary *options);typedef void (^WXJSCallNativeComponent)(NSString *instanceId, NSString *componentRef, NSString *methodName, NSArray *args, NSDictionary *options); 这4个block非常重要，是JS和OC进行相互调用的四大函数。 先来回顾一下这四大函数注册的时候分别封装了哪些闭包。 123@interface WXBridgeContext ()@property (nonatomic, strong) id&lt;WXBridgeProtocol&gt; jsBridge; 在WXBridgeContext类里面有一个jsBridge。jsBridge初始化的时候会注册这4个全局函数。 第一个闭包函数： 1234[_jsBridge registerCallNative:^NSInteger(NSString *instance, NSArray *tasks, NSString *callback) &#123; return [weakSelf invokeNative:instance tasks:tasks callback:callback];&#125;]; 这里的闭包函数会被传入到下面这个函数中： 1234567891011121314- (void)registerCallNative:(WXJSCallNative)callNative&#123; JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123; NSString *instanceId = [instance toString]; NSArray *tasksArray = [tasks toArray]; NSString *callbackId = [callback toString]; WXLogDebug(@\"Calling native... instance:%@, tasks:%@, callback:%@\", instanceId, tasksArray, callbackId); return [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]]; &#125;; _jsContext[@\"callNative\"] = callNativeBlock;&#125; 这里就封装了一个函数，暴露给JS用。方法名叫callNative，函数参数为3个，分别是instanceId，tasksArray任务数组，callbackId回调ID。 所有的OC的闭包都需要封装一层，因为暴露给JS的方法不能有冒号，所有的参数都是直接跟在小括号的参数列表里面的，因为JS的函数是这样定义的。 当JS调用callNative方法之后，就会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。 第二个闭包函数： 1234567891011121314151617181920[_jsBridge registerCallAddElement:^NSInteger(NSString *instanceId, NSString *parentRef, NSDictionary *elementData, NSInteger index) &#123; // Temporary here , in order to improve performance, will be refactored next version. WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; if (!instance) &#123; WXLogInfo(@\"instance not found, maybe already destroyed\"); return -1; &#125; WXPerformBlockOnComponentThread(^&#123; WXComponentManager *manager = instance.componentManager; if (!manager.isValid) &#123; return; &#125; [manager startComponentTasks]; [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:NO]; &#125;); return 0;&#125;]; 这个闭包会被传到下面的函数中： 123456789101112131415161718- (void)registerCallAddElement:(WXJSCallAddElement)callAddElement&#123; id callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123; NSString *instanceIdString = [instanceId toString]; NSDictionary *componentData = [element toDictionary]; NSString *parentRef = [ref toString]; NSInteger insertIndex = [[index toNumber] integerValue]; WXLogDebug(@\"callAddElement...%@, %@, %@, %ld\", instanceIdString, parentRef, componentData, (long)insertIndex); return [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]]; &#125;; _jsContext[@\"callAddElement\"] = callAddElementBlock;&#125; 这里的包装方法和第一个方法是相同的。这里暴露给JS的方法名叫callAddElement，函数参数为4个，分别是instanceIdString，componentData组件的数据，parentRef引用编号，insertIndex插入视图的index。 当JS调用callAddElement方法，就会最终执行WXBridgeContext类里面的WXPerformBlockOnComponentThread闭包。 第三个闭包函数： 12345678910111213[_jsBridge registerCallNativeModule:^NSInvocation*(NSString *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) &#123; WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; if (!instance) &#123; WXLogInfo(@\"instance not found for callNativeModule:%@.%@, maybe already destroyed\", moduleName, methodName); return nil; &#125; WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance]; return [method invoke];&#125;]; 这个闭包会被传到下面的函数中： 123456789101112131415161718- (void)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock&#123; _jsContext[@\"callNativeModule\"] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options) &#123; NSString *instanceIdString = [instanceId toString]; NSString *moduleNameString = [moduleName toString]; NSString *methodNameString = [methodName toString]; NSArray *argsArray = [args toArray]; NSDictionary *optionsDic = [options toDictionary]; WXLogDebug(@\"callNativeModule...%@,%@,%@,%@\", instanceIdString, moduleNameString, methodNameString, argsArray); NSInvocation *invocation = callNativeModuleBlock(instanceIdString, moduleNameString, methodNameString, argsArray, optionsDic); JSValue *returnValue = [JSValue wx_valueWithReturnValueFromInvocation:invocation inContext:[JSContext currentContext]]; return returnValue; &#125;;&#125; 这里暴露给JS的方法名叫callNativeModule，函数参数为5个，分别是instanceIdString，moduleNameString模块名，methodNameString方法名，argsArray参数数组，optionsDic字典。 当JS调用callNativeModule方法，就会最终执行WXBridgeContext类里面的WXModuleMethod方法。 第四个闭包函数： 1234567[_jsBridge registerCallNativeComponent:^void(NSString *instanceId, NSString *componentRef, NSString *methodName, NSArray *args, NSDictionary *options) &#123; WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:componentRef methodName:methodName arguments:args instance:instance]; [method invoke];&#125;]; 这个闭包会被传到下面的函数中： 123456789101112131415- (void)registerCallNativeComponent:(WXJSCallNativeComponent)callNativeComponentBlock&#123; _jsContext[@\"callNativeComponent\"] = ^void(JSValue *instanceId, JSValue *componentName, JSValue *methodName, JSValue *args, JSValue *options) &#123; NSString *instanceIdString = [instanceId toString]; NSString *componentNameString = [componentName toString]; NSString *methodNameString = [methodName toString]; NSArray *argsArray = [args toArray]; NSDictionary *optionsDic = [options toDictionary]; WXLogDebug(@\"callNativeComponent...%@,%@,%@,%@\", instanceIdString, componentNameString, methodNameString, argsArray); callNativeComponentBlock(instanceIdString, componentNameString, methodNameString, argsArray, optionsDic); &#125;;&#125; 这里暴露给JS的方法名叫callNativeComponent，函数参数为5个，分别是instanceIdString，componentNameString组件名，methodNameString方法名，argsArray参数数组，optionsDic字典。 当JS调用callNativeComponent方法，就会最终执行WXBridgeContext类里面的WXComponentMethod方法。 总结一下上述暴露给JS的4个方法： callNative这个方法是JS用来调用任意一个Native方法的。 callAddElement这个方法是JS用来给当前页面添加视图元素的。 callNativeModule这个方法是JS用来调用模块里面暴露出来的方法。 callNativeComponent这个方法是JS用来调用组件里面暴露出来的方法。 Weex在布局的时候就只会用到前2个方法。 ####（一）createRoot: 当JSFramework把JS文件转换类似JSON的文件之后，就开始调用Native的callNative方法。 callNative方法会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。 当前操作处于子线程“com.taobao.weex.bridge”中。 1234567891011121314151617181920212223242526272829303132333435363738- (NSInteger)invokeNative:(NSString *)instanceId tasks:(NSArray *)tasks callback:(NSString __unused*)callback&#123; WXAssertBridgeThread(); if (!instanceId || !tasks) &#123; WX_MONITOR_FAIL(WXMTNativeRender, WX_ERR_JSFUNC_PARAM, @\"JS call Native params error!\"); return 0; &#125; WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; if (!instance) &#123; WXLogInfo(@\"instance already destroyed, task ignored\"); return -1; &#125; // 根据JS发送过来的方法，进行转换成Native方法调用 for (NSDictionary *task in tasks) &#123; NSString *methodName = task[@\"method\"]; NSArray *arguments = task[@\"args\"]; if (task[@\"component\"]) &#123; NSString *ref = task[@\"ref\"]; WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:ref methodName:methodName arguments:arguments instance:instance]; [method invoke]; &#125; else &#123; NSString *moduleName = task[@\"module\"]; WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance]; [method invoke]; &#125; &#125; // 如果有回调，回调给JS [self performSelector:@selector(_sendQueueLoop) withObject:nil]; return 1;&#125; 这里会把JS从发送过来的callNative方法转换成Native的组件component的方法调用或者模块module的方法调用。 举个例子： JS从callNative方法传过来3个参数 12345678910111213141516171819202122instance:0,tasks:( &#123; args = ( &#123; attr = &#123; &#125;; ref = &quot;_root&quot;; style = &#123; alignItems = center; &#125;; type = div; &#125; ); method = createBody; module = dom; &#125;), callback:-1 tasks数组里面会解析出各个方法和调用者。 这个例子里面就会解析出Dom模块的createBody方法。 接着就会调用Dom模块的createBody方法。 123456789if (isSync) &#123; [invocation invoke]; return invocation;&#125; else &#123; [self _dispatchInvocation:invocation moduleInstance:moduleInstance]; return nil;&#125; 调用方法之前，有一个线程切换的步骤。如果是同步方法，那么就直接调用，如果是异步方法，那么嗨需要进行线程转换。 Dom模块的createBody方法是异步的方法，于是就需要调用_dispatchInvocation: moduleInstance:方法。 123456789101112131415161718192021222324252627282930313233- (void)_dispatchInvocation:(NSInvocation *)invocation moduleInstance:(id&lt;WXModuleProtocol&gt;)moduleInstance&#123; // dispatch to user specified queue or thread, default is main thread dispatch_block_t dispatchBlock = ^ ()&#123; [invocation invoke]; &#125;; NSThread *targetThread = nil; dispatch_queue_t targetQueue = nil; if([moduleInstance respondsToSelector:@selector(targetExecuteQueue)])&#123; // 判断当前是否有Queue，如果没有，就返回main_queue，如果有，就切换到targetQueue targetQueue = [moduleInstance targetExecuteQueue] ?: dispatch_get_main_queue(); &#125; else if([moduleInstance respondsToSelector:@selector(targetExecuteThread)])&#123; // 判断当前是否有Thread，如果没有，就返回主线程，如果有，就切换到targetThread targetThread = [moduleInstance targetExecuteThread] ?: [NSThread mainThread]; &#125; else &#123; targetThread = [NSThread mainThread]; &#125; WXAssert(targetQueue || targetThread, @\"No queue or thread found for module:%@\", moduleInstance); if (targetQueue) &#123; dispatch_async(targetQueue, dispatchBlock); &#125; else &#123; WXPerformBlockOnThread(^&#123; dispatchBlock(); &#125;, targetThread); &#125;&#125; 在整个Weex模块中，目前只有2个模块是有targetQueue的，一个是WXClipboardModule，另一个是WXStorageModule。所以这里没有targetQueue，就只能切换到对应的targetThread上。 1234567891011121314151617181920void WXPerformBlockOnThread(void (^ _Nonnull block)(), NSThread *thread)&#123; [WXUtility performBlock:block onThread:thread];&#125;+ (void)performBlock:(void (^)())block onThread:(NSThread *)thread&#123; if (!thread || !block) return; // 如果当前线程不是目标线程上，就要切换线程 if ([NSThread currentThread] == thread) &#123; block(); &#125; else &#123; [self performSelector:@selector(_performBlock:) onThread:thread withObject:[block copy] waitUntilDone:NO]; &#125;&#125; 这里就是切换线程的操作，如果当前线程不是目标线程，就要切换线程。在目标线程上调用_performBlock:方法，入参还是最初传进来的block闭包。 切换前线程处于子线程“com.taobao.weex.bridge”中。 在WXDomModule中调用targetExecuteThread方法 123456- (NSThread *)targetExecuteThread&#123; return [WXComponentManager componentThread];&#125; 切换线程之后，当前线程变成了“com.taobao.weex.component”。 123456789101112131415161718192021222324252627- (void)createBody:(NSDictionary *)body&#123; [self performBlockOnComponentManager:^(WXComponentManager *manager) &#123; [manager createRoot:body]; &#125;];&#125;- (void)performBlockOnComponentManager:(void(^)(WXComponentManager *))block&#123; if (!block) &#123; return; &#125; __weak typeof(self) weakSelf = self; WXPerformBlockOnComponentThread(^&#123; WXComponentManager *manager = weakSelf.weexInstance.componentManager; if (!manager.isValid) &#123; return; &#125; // 开启组件任务 [manager startComponentTasks]; block(manager); &#125;);&#125; 当调用了Dom模块的createBody方法以后，会先调用WXComponentManager的startComponentTasks方法，再调用createRoot:方法。 这里会初始化一个WXComponentManager。 12345678910111213141516171819202122232425- (WXComponentManager *)componentManager&#123; if (!_componentManager) &#123; _componentManager = [[WXComponentManager alloc] initWithWeexInstance:self]; &#125; return _componentManager;&#125;- (instancetype)initWithWeexInstance:(id)weexInstance&#123; if (self = [self init]) &#123; _weexInstance = weexInstance; _indexDict = [NSMapTable strongToWeakObjectsMapTable]; _fixedComponents = [NSMutableArray wx_mutableArrayUsingWeakReferences]; _uiTaskQueue = [NSMutableArray array]; _isValid = YES; [self _startDisplayLink]; &#125; return self;&#125; WXComponentManager的初始化重点是会开启DisplayLink，它会开启一个runloop。 12345678910- (void)_startDisplayLink&#123; WXAssertComponentThread(); if(!_displayLink)&#123; _displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(_handleDisplayLink)]; [_displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; &#125;&#125; displayLink一旦开启，被加入到当前runloop之中，每次runloop循环一次都会执行刷新布局的方法_handleDisplayLink。 12345678910111213- (void)startComponentTasks&#123; [self _awakeDisplayLink];&#125;- (void)_awakeDisplayLink&#123; WXAssertComponentThread(); if(_displayLink &amp;&amp; _displayLink.paused) &#123; _displayLink.paused = NO; &#125;&#125; WXComponentManager的startComponentTasks方法仅仅是更改了CADisplayLink的paused的状态。CADisplayLink就是用来刷新layout的。 12345678910111213141516171819202122@implementation WXComponentManager&#123; // 对WXSDKInstance的弱引用 __weak WXSDKInstance *_weexInstance; // 当前WXComponentManager是否可用 BOOL _isValid; // 是否停止刷新布局 BOOL _stopRunning; NSUInteger _noTaskTickCount; // access only on component thread NSMapTable&lt;NSString *, WXComponent *&gt; *_indexDict; NSMutableArray&lt;dispatch_block_t&gt; *_uiTaskQueue; WXComponent *_rootComponent; NSMutableArray *_fixedComponents; css_node_t *_rootCSSNode; CADisplayLink *_displayLink;&#125; 以上就是WXComponentManager的所有属性，可以看出WXComponentManager就是用来处理UI任务的。 再来看看createRoot:方法： 123456789101112131415161718192021- (void)createRoot:(NSDictionary *)data&#123; WXAssertComponentThread(); WXAssertParam(data); // 1.创建WXComponent，作为rootComponent _rootComponent = [self _buildComponentForData:data]; // 2.初始化css_node_t，作为rootCSSNode [self _initRootCSSNode]; __weak typeof(self) weakSelf = self; // 3.添加UI任务到uiTaskQueue数组中 [self _addUITask:^&#123; __strong typeof(self) strongSelf = weakSelf; strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent; [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view]; &#125;];&#125; 这里干了3件事情: 1.创建WXComponent1234567891011121314151617- (WXComponent *)_buildComponentForData:(NSDictionary *)data&#123; NSString *ref = data[@\"ref\"]; NSString *type = data[@\"type\"]; NSDictionary *styles = data[@\"style\"]; NSDictionary *attributes = data[@\"attr\"]; NSArray *events = data[@\"event\"]; Class clazz = [WXComponentFactory classWithComponentName:type]; WXComponent *component = [[clazz alloc] initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:self.weexInstance]; WXAssert(component, @\"Component build failed for data:%@\", data); [_indexDict setObject:component forKey:component.ref]; return component;&#125; 这里的入参data是之前的tasks数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; if (self = [super init]) &#123; pthread_mutexattr_init(&amp;_propertMutexAttr); pthread_mutexattr_settype(&amp;_propertMutexAttr, PTHREAD_MUTEX_RECURSIVE); pthread_mutex_init(&amp;_propertyMutex, &amp;_propertMutexAttr); _ref = ref; _type = type; _weexInstance = weexInstance; _styles = [self parseStyles:styles]; _attributes = attributes ? [NSMutableDictionary dictionaryWithDictionary:attributes] : [NSMutableDictionary dictionary]; _events = events ? [NSMutableArray arrayWithArray:events] : [NSMutableArray array]; _subcomponents = [NSMutableArray array]; _absolutePosition = CGPointMake(NAN, NAN); _isNeedJoinLayoutSystem = YES; _isLayoutDirty = YES; _isViewFrameSyncWithCalculated = YES; _async = NO; //TODO set indicator style if ([type isEqualToString:@\"indicator\"]) &#123; _styles[@\"position\"] = @\"absolute\"; if (!_styles[@\"left\"] &amp;&amp; !_styles[@\"right\"]) &#123; _styles[@\"left\"] = @0.0f; &#125; if (!_styles[@\"top\"] &amp;&amp; !_styles[@\"bottom\"]) &#123; _styles[@\"top\"] = @0.0f; &#125; &#125; // 设置NavBar的Style [self _setupNavBarWithStyles:_styles attributes:_attributes]; // 根据style初始化cssNode数据结构 [self _initCSSNodeWithStyles:_styles]; // 根据style初始化View的各个属性 [self _initViewPropertyWithStyles:_styles]; // 处理Border的圆角，边线宽度，背景颜色等属性 [self _handleBorders:styles isUpdating:NO]; &#125; return self;&#125; 上述函数就是初始化WXComponent的布局的各个属性。这里会用到FlexBox里面的一些计算属性的方法就在_initCSSNodeWithStyles:方法里面。 123456789101112131415161718192021222324252627282930- (void)_initCSSNodeWithStyles:(NSDictionary *)styles&#123; _cssNode = new_css_node(); _cssNode-&gt;print = cssNodePrint; _cssNode-&gt;get_child = cssNodeGetChild; _cssNode-&gt;is_dirty = cssNodeIsDirty; if ([self measureBlock]) &#123; _cssNode-&gt;measure = cssNodeMeasure; &#125; _cssNode-&gt;context = (__bridge void *)self; // 重新计算_cssNode需要布局的子视图个数 [self _recomputeCSSNodeChildren]; // 将style各个属性都填充到cssNode数据结构中 [self _fillCSSNode:styles]; // To be in conformity with Android/Web, hopefully remove this in the future. if ([self.ref isEqualToString:WX_SDK_ROOT_REF]) &#123; if (isUndefined(_cssNode-&gt;style.dimensions[CSS_HEIGHT]) &amp;&amp; self.weexInstance.frame.size.height) &#123; _cssNode-&gt;style.dimensions[CSS_HEIGHT] = self.weexInstance.frame.size.height; &#125; if (isUndefined(_cssNode-&gt;style.dimensions[CSS_WIDTH]) &amp;&amp; self.weexInstance.frame.size.width) &#123; _cssNode-&gt;style.dimensions[CSS_WIDTH] = self.weexInstance.frame.size.width; &#125; &#125;&#125; 在_fillCSSNode:方法里面会对FlexBox算法里面定义的各个属性值就行赋值。 2.初始化css_node_t在这里，准备开始Layout之前，我们需要先初始化rootCSSNode 1234567891011121314- (void)_initRootCSSNode&#123; _rootCSSNode = new_css_node(); // 根据页面weexInstance设置rootCSSNode的坐标和宽高尺寸 [self _applyRootFrame:self.weexInstance.frame toRootCSSNode:_rootCSSNode]; _rootCSSNode-&gt;style.flex_wrap = CSS_NOWRAP; _rootCSSNode-&gt;is_dirty = rootNodeIsDirty; _rootCSSNode-&gt;get_child = rootNodeGetChild; _rootCSSNode-&gt;context = (__bridge void *)(self); _rootCSSNode-&gt;children_count = 1;&#125; 在上述方法中，会初始化rootCSSNode的坐标和宽高尺寸。 3.添加UI任务到uiTaskQueue数组中123456[self _addUITask:^&#123; __strong typeof(self) strongSelf = weakSelf; strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent; [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];&#125;]; WXComponentManager会把当前的组件以及它对应的View添加到页面Instance的rootView上面的这个任务，添加到uiTaskQueue数组中。 _rootComponent.view会创建组件对应的WXView，这个是继承自UIView的。所以Weex通过JS代码创建出来的控件都是原生的，都是WXView类型的，实质就是UIView。创建UIView这一步又是回到主线程中执行的。 最后显示到页面上的工作，是由displayLink的刷新方法在主线程刷新UI显示的。 1234567891011121314151617181920212223- (void)_handleDisplayLink&#123; [self _layoutAndSyncUI];&#125;- (void)_layoutAndSyncUI&#123; // Flexbox布局 [self _layout]; if(_uiTaskQueue.count &gt; 0)&#123; // 同步执行UI任务 [self _syncUITasks]; _noTaskTickCount = 0; &#125; else &#123; // 如果当前一秒内没有任务，那么智能的挂起displaylink，以节约CPU时间 _noTaskTickCount ++; if (_noTaskTickCount &gt; 60) &#123; [self _suspendDisplayLink]; &#125; &#125;&#125; _layoutAndSyncUI是布局和刷新UI的核心流程。每次刷新一次，都会先调用Flexbox算法的Layout进行布局，这个布局是在子线程“com.taobao.weex.component”执行的。接着再去查看当前是否有UI任务需要执行，如果有，就切换到主线程进行UI刷新操作。 这里还会有一个智能的挂起操作。就是判断一秒内如果都没有任务，那么就挂起displaylink，以节约CPU时间。 12345678910111213141516171819202122232425262728293031323334- (void)_layout&#123; BOOL needsLayout = NO; NSEnumerator *enumerator = [_indexDict objectEnumerator]; WXComponent *component; // 判断当前是否需要布局，即是判断当前组件的_isLayoutDirty这个BOLL属性值 while ((component = [enumerator nextObject])) &#123; if ([component needsLayout]) &#123; needsLayout = YES; break; &#125; &#125; if (!needsLayout) &#123; return; &#125; // Flexbox的算法核心函数 layoutNode(_rootCSSNode, _rootCSSNode-&gt;style.dimensions[CSS_WIDTH], _rootCSSNode-&gt;style.dimensions[CSS_HEIGHT], CSS_DIRECTION_INHERIT); NSMutableSet&lt;WXComponent *&gt; *dirtyComponents = [NSMutableSet set]; [_rootComponent _calculateFrameWithSuperAbsolutePosition:CGPointZero gatherDirtyComponents:dirtyComponents]; // 计算当前weexInstance的rootView.frame，并且重置rootCSSNode的Layout [self _calculateRootFrame]; // 在每个需要布局的组件之间 for (WXComponent *dirtyComponent in dirtyComponents) &#123; [self _addUITask:^&#123; [dirtyComponent _layoutDidFinish]; &#125;]; &#125;&#125; _indexDict里面维护了一张整个页面的布局结构的Map，举个例子： 12345678NSMapTable &#123;[7] _root -&gt; &lt;div ref=_root&gt; &lt;WXView: 0x7fc59a416140; frame = (0 0; 331.333 331.333); layer = &lt;WXLayer: 0x608000223180&gt;&gt;[12] 5 -&gt; &lt;image ref=5&gt; &lt;WXImageView: 0x7fc59a724430; baseClass = UIImageView; frame = (110.333 192.333; 110.333 110.333); clipsToBounds = YES; layer = &lt;WXLayer: 0x60000002f780&gt;&gt;[13] 3 -&gt; &lt;image ref=3&gt; &lt;WXImageView: 0x7fc59a617a00; baseClass = UIImageView; frame = (110.333 55.3333; 110.333 110.333); clipsToBounds = YES; opaque = NO; gestureRecognizers = &lt;NSArray: 0x60000024b760&gt;; layer = &lt;WXLayer: 0x60000003e8c0&gt;&gt;[15] 4 -&gt; &lt;text ref=4&gt; &lt;WXText: 0x7fc59a509840; text: hello Weex; frame:0.000000,441.666667,331.333333,26.666667 frame = (0 441.667; 331.333 26.6667); opaque = NO; layer = &lt;WXLayer: 0x608000223480&gt;&gt;&#125; 所有的组件都是由ref引用值作为Key存储的，只要知道这个页面上全局唯一的ref，就可以拿到这个ref对应的组件。 _layout会先判断当前是否有需要布局的组件，如果有，就从rootCSSNode开始进行Flexbox算法的Layout。执行完成以后还需要调整一次rootView的frame，最后添加一个UI任务到taskQueue中，这个任务标记的是组件布局完成。 注意上述所有布局操作都是在子线程“com.taobao.weex.component”中执行的。 1234567891011121314- (void)_syncUITasks&#123; // 用blocks接收原来uiTaskQueue里面的所有任务 NSArray&lt;dispatch_block_t&gt; *blocks = _uiTaskQueue; // 清空uiTaskQueue _uiTaskQueue = [NSMutableArray array]; // 在主线程中依次执行uiTaskQueue里面的所有闭包 dispatch_async(dispatch_get_main_queue(), ^&#123; for(dispatch_block_t block in blocks) &#123; block(); &#125; &#125;);&#125; 布局完成以后就调用同步的UI刷新方法。注意这里要对UI进行操作，一定要切换回主线程。 ####（二）callAddElement 在子线程“com.taobao.weex.bridge”中，会一直相应来自JSFramework调用Native的方法。 123456789101112131415161718192021[_jsBridge registerCallAddElement:^NSInteger(NSString *instanceId, NSString *parentRef, NSDictionary *elementData, NSInteger index) &#123; // Temporary here , in order to improve performance, will be refactored next version. WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId]; if (!instance) &#123; WXLogInfo(@\"instance not found, maybe already destroyed\"); return -1; &#125; WXPerformBlockOnComponentThread(^&#123; WXComponentManager *manager = instance.componentManager; if (!manager.isValid) &#123; return; &#125; [manager startComponentTasks]; [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:NO]; &#125;); return 0;&#125;]; 当JSFramework调用callAddElement方法，就会执行上述代码的闭包函数。这里会接收来自JS的4个入参。 举个例子，JSFramework可能会通过callAddElement方法传过来这样4个参数： 1234567891011121314150,_root, &#123; attr = &#123; value = \"Hello World\"; &#125;; ref = 4; style = &#123; color = \"#000000\"; fontSize = 40; &#125;; type = text;&#125;, -1 这里的insertIndex为0，parentRef是_root，componentData是当前要创建的组件的信息，instanceIdString是-1。 之后WXComponentManager就会调用startComponentTasks开始displaylink继续准备刷新布局，最后调用addComponent: toSupercomponent: atIndex: appendingInTree:方法添加新的组件。 注意，WXComponentManager的这两步操作，又要切换线程，切换到“com.taobao.weex.component”子线程中。 12345678- (void)addComponent:(NSDictionary *)componentData toSupercomponent:(NSString *)superRef atIndex:(NSInteger)index appendingInTree:(BOOL)appendingInTree&#123; WXComponent *supercomponent = [_indexDict objectForKey:superRef]; WXAssertComponentExist(supercomponent); [self _recursivelyAddComponent:componentData toSupercomponent:supercomponent atIndex:index appendingInTree:appendingInTree];&#125; WXComponentManager会在“com.taobao.weex.component”子线程中递归的添加子组件。 1234567891011121314151617181920212223242526272829303132- (void)_recursivelyAddComponent:(NSDictionary *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(NSInteger)index appendingInTree:(BOOL)appendingInTree&#123; // 根据componentData构建组件 WXComponent *component = [self _buildComponentForData:componentData]; index = (index == -1 ? supercomponent-&gt;_subcomponents.count : index); [supercomponent _insertSubcomponent:component atIndex:index]; // 用_lazyCreateView标识懒加载 if(supercomponent &amp;&amp; component &amp;&amp; supercomponent-&gt;_lazyCreateView) &#123; component-&gt;_lazyCreateView = YES; &#125; // 插入一个UI任务 [self _addUITask:^&#123; [supercomponent insertSubview:component atIndex:index]; &#125;]; NSArray *subcomponentsData = [componentData valueForKey:@\"children\"]; BOOL appendTree = !appendingInTree &amp;&amp; [component.attributes[@\"append\"] isEqualToString:@\"tree\"]; // 再次递归的规则：如果父视图是一个树状结构，子视图即使也是一个树状结构，也不能再次Layout for(NSDictionary *subcomponentData in subcomponentsData)&#123; [self _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:-1 appendingInTree:appendTree || appendingInTree]; &#125; if (appendTree) &#123; // 如果当前组件是树状结构，强制刷新layout，以防在syncQueue中堆积太多的同步任务。 [self _layoutAndSyncUI]; &#125;&#125; 在递归的添加子组件的时候，如果是树状结构，还需要再次强制进行一次layout，同步一次UI。这里调用[self _layoutAndSyncUI]方法和createRoot:时候实现是完全一样的，下面就不再赘述了。 这里会循环添加多个子视图，相应的也会调用多次Layout方法。 （三）createFinish当所有的视图都添加完成以后，JSFramework就是再次调用callNative方法。 还是会传过来3个参数。 123456789101112instance:0, tasks:( &#123; args = ( ); method = createFinish; module = dom; &#125;), callback:-1 callNative通过这个参数会调用到WXDomModule的createFinish方法。这里的具体实现见第一步的callNative，这里不再赘述。 1234567- (void)createFinish&#123; [self performBlockOnComponentManager:^(WXComponentManager *manager) &#123; [manager createFinish]; &#125;];&#125; 这里最终也是会调用到WXComponentManager的createFinish。当然这里是会进行线程切换，切换到WXComponentManager的线程“com.taobao.weex.component”子线程上。 12345678910111213141516171819- (void)createFinish&#123; WXAssertComponentThread(); WXSDKInstance *instance = self.weexInstance; [self _addUITask:^&#123; UIView *rootView = instance.rootView; WX_MONITOR_INSTANCE_PERF_END(WXPTFirstScreenRender, instance); WX_MONITOR_INSTANCE_PERF_END(WXPTAllRender, instance); WX_MONITOR_SUCCESS(WXMTJSBridge); WX_MONITOR_SUCCESS(WXMTNativeRender); if(instance.renderFinish)&#123; instance.renderFinish(rootView); &#125; &#125;];&#125; WXComponentManager的createFinish方法最后就是添加一个UI任务，回调到主线程的renderFinish方法里面。 至此，Weex的布局流程就完成了。 最后 虽然Autolayout是苹果原生就支持的自动布局方案，但是在稍微复杂的界面就会出现性能问题。大半年前，Draveness的这篇《从 Auto Layout 的布局算法谈性能》文章里面也稍微“批判”了Autolayout的性能问题，但是文章里面最后提到的是用ASDK的方法来解决问题。本篇文章则献上另外一种可用的布局方法——FlexBox，并且带上了经过大量测试的测试数据，向大左的这篇经典文章致敬！ 如今，iOS平台上几大可用的布局方法有：Frame原生布局，Autolayout原生自动布局，FlexBox的Yoga实现，ASDK。 当然，基于这4种基本方案以外，还有一些组合方法，比如Weex的这种，用JS的CSS解析成类似JSON的DOM，再调用Native的FlexBox算法进行布局。前段时间还有来自美团的《布局编码的未来》里面提到的毕加索（picasso）布局方法。原理也是会用到JSCore，将JS写的JSON或者自定义的DSL，经过本地的picassoEngine布局引擎转换成Native布局，最终利用锚点的概念做到高效的布局。 最后，推荐2个iOS平台上比较优秀的利用了FlexBox的原理的开源库： 来自Facebook的yoga来自饿了么的FlexBoxLayout Weex 源码解析系列文章： Weex 是如何在 iOS 客户端上跑起来的由 FlexBox 算法强力驱动的 Weex 布局引擎Weex 事件传递的那些事儿Weex 中别具匠心的 JS FrameworkiOS 开发者的 Weex 伪最佳实践指北","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"iOS事件处理看我就够了(转载)","date":"2018-04-27T04:07:12.000Z","path":"wiki/IOS/事件处理/event/","text":"本文转载自iOS事件处理，看我就够了~ UIResponderUIResponder是iOS中用于处理用户事件的API，可以处理触摸事件、按压事件(3D touch)、远程控制事件、硬件运动事件。可以通过touchesBegan、pressesBegan、motionBegan、remoteControlReceivedWithEvent等方法，获取到对应的回调消息。UIResponder不只用来接收事件，还可以处理和传递对应的事件，如果当前响应者不能处理，则转发给其他合适的响应者处理。 应用程序通过响应者来接收和处理事件，响应者可以是继承自UIResponder的任何子类，例如UIView、UIViewController、UIApplication等。当事件来到时，系统会将事件传递给合适的响应者，并且将其成为第一响应者。 第一响应者未处理的事件，将会在响应者链中进行传递，传递规则由UIResponder的nextResponder决定，可以通过重写该属性来决定传递规则。当一个事件到来时，第一响应者没有接收消息，则顺着响应者链向后传递。 查找第一响应者基础API查找第一响应者时，有两个非常关键的API，查找第一响应者就是通过不断调用子视图的这两个API完成的。 调用下面方法，获取到被点击的视图，也就是第一响应者。 1- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event; 查找点击的视图。 内部会调用pointInside:withEvent方法。 1- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event; 来判断点击区域是否在视图上，是则返回YES，不是则返回NO。 查找第一响应者应用程序接收到事件后，将事件交给keyWindow并转发给根视图，根视图按照视图层级逐级遍历子视图，并且遍历的过程中不断判断视图范围，并最终找到第一响应者。 从keyWindow开始，向前逐级遍历子视图，不断调用UIView的hitTest:withEvent:方法，通过该方法查找在点击区域中的视图后，并继续调用返回视图的子视图的hitTest:withEvent:方法，以此类推。如果子视图不在点击区域或没有子视图，则当前视图就是第一响应者。 在hitTest:withEvent:方法中，会从上到下遍历子视图，并调用subViews的pointInside:withEvent:方法，来找到点击区域内且最上面的子视图。如果找到子视图则调用其hitTest:withEvent:方法，并继续执行这个流程，以此类推。如果子视图不在点击区域内，则忽略这个视图及其子视图，继续遍历其他视图。 可以通过重写对应的方法，控制这个遍历过程。通过重写pointInside:withEvent:方法，来做自己的判断并返回YES或NO，返回点击区域是否在视图上。通过重写hitTest:withEvent:方法，返回被点击的视图。此方法在遍历视图时，忽略以下三种情况的视图，如果视图具有以下特征则忽略。但是视图的背景颜色是clearColor，并不在忽略范围内。1. 视图的hidden等于YES。2. 视图的alpha小于等于0.01。3. 视图的userInteractionEnabled为NO。 如果点击事件是发生在视图外，但在其子视图内部，子视图也不能接收事件并成为第一响应者。这是因为在其父视图进行hitTest:withEvent:的过程中，就会将其忽略掉。 事件传递传递过程 UIApplication接收到事件，将事件传递给keyWindow。 keyWindow遍历subViews的hitTest:withEvent:方法，找到点击区域内合适的视图来处理事件。 UIView的子视图也会遍历其subViews的hitTest:withEvent:方法，以此类推。 直到找到点击区域内，且处于最上方的视图，将视图逐步返回给UIApplication。 在查找第一响应者的过程中，已经形成了一个响应者链。 应用程序会先调用第一响应者处理事件。 如果第一响应者不能处理事件，则调用其nextResponder方法，一直找响应者链中能处理该事件的对象。 最后到UIApplication后仍然没有能处理该事件的对象，则该事件被废弃。 模拟代码 123456789101112131415161718192021- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; if (self.alpha &lt;= 0.01 || self.userInteractionEnabled == NO || self.hidden) &#123; return nil; &#125; BOOL inside = [self pointInside:point withEvent:event]; if (inside) &#123; NSArray *subViews = self.subviews; // 对子视图从上向下找 for (NSInteger i = subViews.count - 1; i &gt;= 0; i--) &#123; UIView *subView = subViews[i]; CGPoint insidePoint = [self convertPoint:point toView:subView]; UIView *hitView = [subView hitTest:insidePoint withEvent:event]; if (hitView) &#123; return hitView; &#125; &#125; return self; &#125; return nil;&#125; 事件响应 如上图所示，响应者链如下： 如果点击UITextField后其会成为第一响应者。 如果textField未处理事件，则会将事件传递给下一级响应者链，也就是其父视图。 父视图未处理事件则继续向下传递，也就是UIViewController的View。 如果控制器的View未处理事件，则会交给控制器处理。 控制器未处理则会交给UIWindow。 然后会交给UIApplication。 最后交给UIApplicationDelegate，如果其未处理则丢弃事件。 事件通过UITouch进行传递，在事件到来时，第一响应者会分配对应的UITouch，UITouch会一直跟随着第一响应者，并且根据当前事件的变化UITouch也会变化，当事件结束后则UITouch被释放。 UIViewController没有hitTest:withEvent:方法，所以控制器不参与查找响应视图的过程。但是控制器在响应者链中，如果控制器的View不处理事件，会交给控制器来处理。控制器不处理的话，再交给View的下一级响应者处理。 注意 在执行hitTest:withEvent:方法时，如果该视图是hidden等于NO的那三种被忽略的情况，则改视图返回nil。 如果当前视图在响应者链中，但其没有处理事件，则不考虑其兄弟视图，即使其兄弟视图和其都在点击范围内。 UIImageView的userInteractionEnabled默认为NO，如果想要UIImageView响应交互事件，将属性设置为YES即可响应事件。 事件控制事件拦截有时候想让指定视图来响应事件，不再向其子视图继续传递事件，可以通过重写hitTest:withEvent:方法。在执行到方法后，直接将该视图返回，而不再继续遍历子视图，这样响应者链的终端就是当前视图。 123- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123; return self;&#125; 事件转发在开发过程中，经常会遇到子视图显示范围超出父视图的情况，这时候可以重写该视图的pointInside:withEvent:方法，将点击区域扩大到能够覆盖所有子视图。 扩大响应区域 假设有上面的视图结构，SuperView的Subview超出了其视图范围，如果点击Subview在父视图外面的部分，则不能响应事件。所以通过重写pointInside:withEvent:方法，将响应区域扩大为虚线区域，包含SuperView的所有子视图，即可让子视图响应事件。 事件逐级传递如果想让响应者链中，每一级UIResponder都可以响应事件，可以在每级UIResponder中都实现touches并调用super方法，即可实现响应者链事件逐级传递。 只不过这并不包含UIControl子类以及UIGestureRecognizer的子类，这两类会直接打断响应者链。 Gesture Recognizer如果有事件到来时，视图有附加的手势识别器，则手势识别器优先处理事件。如果手势识别器没有处理事件，则将事件交给视图处理，视图如果未处理则顺着响应者链继续向后传递。 手势识别 当响应者链和手势同时出现时，也就是既实现了touches方法又添加了手势，会发现touches方法有时会失效，这是因为手势的执行优先级是高于响应者链的。 事件到来后先会执行hitTest和pointInside操作，通过这两个方法找到第一响应者，这个在上面已经详细讲过了。当找到第一响应者并将其返回给UIApplication后，UIApplication会向第一响应者派发事件，并且遍历整个响应者链。如果响应者链中能够处理当前事件的手势，则将事件交给手势处理，并调用touches的cancelled方法将响应者链取消。 在UIApplication向第一响应者派发事件，并且遍历响应者链查找手势时，会开始执行响应者链中的touches系列方法。会先执行touchesBegan和touchesMoved方法，如果响应者链能够继续响应事件，则执行touchesEnded方法表示事件完成，如果将事件交给手势处理则调用touchesCancelled方法将响应者链打断。 根据苹果的官方文档，手势不参与响应者链传递事件，但是也通过hitTest的方式查找响应的视图，手势和响应者链一样都需要通过hitTest方法来确定响应者链的。在UIApplication向响应者链派发消息时，只要响应者链中存在能够处理事件的手势，则手势响应事件，如果手势不在响应者链中则不能处理事件。 Apple UIGestureRecognizer Documentation UIControl根据上面的手势和响应者链的处理规则，我们会发现UIButton或者UISlider等控件，并不符合这个处理规则。UIButton可以在其父视图已经添加tapGestureRecognizer的情况下，依然正常响应事件，并且tap手势不响应。 UIControl 以UIButton为例，UIButton也是通过hitTest的方式查找第一响应者的。区别在于，如果UIButton是第一响应者，则直接由UIApplication派发事件，不通过Responder Chain派发。如果其不能处理事件，则交给手势处理或响应者链传递。 不只UIButton是直接由UIApplication派发事件的，所有继承自UIControl的类，都是由UIApplication直接派发事件的。 [Apple UIControl Documentation][2] 事件传递优先级为了有依据的推断响应事件的实现和传递机制，我们做以下测试。 示例1假设RootView、SuperView、Button都实现touches方法，并且Button添加buttonAction:的action，点击button后的调用如下。 123456789101112RootView -&gt; hitTest:withEvent:RootView -&gt; pointInside:withEvent:SuperView -&gt; hitTest:withEvent:SuperView -&gt; pointInside:withEvent:Button -&gt; hitTest:withEvent:Button -&gt; pointInside:withEvent:RootView -&gt; hitTest:withEvent:RootView -&gt; pointInside:withEvent:Button -&gt; touchesBegan:withEvent:Button -&gt; touchesEnded:withEvent:Button -&gt; buttonAction: 示例2还是上面的视图结构，我们给RootView加上UITapGestureRecognizer手势，并且通过tapAction:方法接收回调，点击上面的SuperView后，方法调用如下。 123456789101112131415RootView -&gt; hitTest:withEvent:RootView -&gt; pointInside:withEvent:SuperView -&gt; hitTest:withEvent:SuperView -&gt; pointInside:withEvent:Button -&gt; hitTest:withEvent:Button -&gt; pointInside:withEvent:RootView -&gt; hitTest:withEvent:RootView -&gt; pointInside:withEvent:RootView -&gt; gestureRecognizer:shouldReceivePress:RootView -&gt; gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:SuperView -&gt; touchesBegan:withEvent:RootView -&gt; gestureRecognizerShouldBegin:RootView -&gt; tapAction:SuperView -&gt; touchesCancelled: 示例3 上面的视图中Subview1、Subview2、Subview3是同级视图，都是SuperView的子视图。我们给Subview1加上UITapGestureRecognizer手势，并且通过subView1Action:方法接收回调，点击上面的Subview3后，方法调用如下。 123456789SuperView -&gt; hitTest:withEvent:SuperView -&gt; pointInside:withEvent:Subview3 -&gt; hitTest:withEvent:Subview3 -&gt; pointInside:withEvent:SuperView -&gt; hitTest:withEvent:SuperView -&gt; pointInside:withEvent:Subview3 -&gt; touchesBegan:withEvent:Subview3 -&gt; touchesEnded:withEvent: 通过上面的例子来看，虽然Subview1在Subview3的下面，并且添加了手势，点击区域是在Subview1和Subview3两个视图上的。但是由于经过hitTest和pointInside之后，响应者链中并没有Subview1，所以Subview1的手势并没有被响应。 分析(这个很重要)根据我们上面的测试，推断iOS响应事件的优先级，以及整体的响应逻辑。 当事件到来时，会通过hitTest和pointInside两个方法，从Window开始向上面的视图查找，找到第一响应者的视图。找到第一响应者后，系统会判断其是继承自UIControl还是UIResponder，如果是继承自UIControl，则直接通过UIApplication直接向其派发消息，并且不再向响应者链派发消息。 如果是继承自UIResponder的类，则调用第一响应者的touchesBegin，并且不会立即执行touchesEnded，而是调用之后顺着响应者链向后查找。如果在查找过程中，发现响应者链中有的视图添加了手势，则进入手势的代理方法中，如果代理方法返回可以响应这个事件，则将第一响应者的事件取消，并调用其touchesCanceled方法，然后由手势来响应事件。 如果手势不能处理事件，则交给第一响应者来处理。如果第一响应者也不能响应事件，则顺着响应者链继续向后查找，直到找到能够处理事件的UIResponder对象。如果找到UIApplication还没有对象响应事件的话，则将这次事件丢弃。 接收事件深度剖析在UIApplication接收到响应事件之前，还有更复杂的系统级的处理，处理流程大致如下。 系统通过IOKit.framework来处理硬件操作，其中屏幕处理也通过IOKit完成(IOKit可能是注册监听了屏幕输出的端口) 当用户操作屏幕，IOKit收到屏幕操作，会将这次操作封装为IOHIDEvent对象。通过mach port(IPC进程间通信)将事件转发给SpringBoard来处理。 SpringBoard是iOS系统的桌面程序。SpringBoard收到mach port发过来的事件，唤醒main runloop来处理。 main runloop将事件交给source1处理，source1会调用__IOHIDEventSystemClientQueueCallback()函数。 函数内部会判断，是否有程序在前台显示，如果有则通过mach port将IOHIDEvent事件转发给这个程序。 如果前台没有程序在显示，则表明SpringBoard的桌面程序在前台显示，也就是用户在桌面进行了操作。 IOHIDEventSystemClientQueueCallback()函数会将事件交给source0处理，source0会调用UIApplicationHandleEventQueue()函数，函数内部会做具体的处理操作。 例如用户点击了某个应用程序的icon，会将这个程序启动。 应用程序接收到SpringBoard传来的消息，会唤醒main runloop并将这个消息交给source1处理，source1调用IOHIDEventSystemClientQueueCallback()函数，在函数内部会将事件交给source0处理，并调用source0的UIApplicationHandleEventQueue()函数。 在__UIApplicationHandleEventQueue()函数中，会将传递过来的IOHIDEvent转换为UIEvent对象。 在函数内部，调用UIApplication的sendEvent:方法，将UIEvent传递给第一响应者或UIControl对象处理，在UIEvent内部包含若干个UITouch对象。 Tipssource1是runloop用来处理mach port传来的系统事件的，source0是用来处理用户事件的。 source1收到系统事件后，都会调用source0的函数，所以最终这些事件都是由source0处理的。 小技巧在开发中，有时会有找到当前View对应的控制器的需求，这时候就可以利用我们上面所学，根据响应者链来找到最近的控制器。 在UIResponder中提供了nextResponder方法，通过这个方法可以找到当前响应环节的上一级响应对象。可以从当前UIView开始不断调用nextResponder，查找上一级响应者链的对象，就可以找到离自己最近的UIViewController。 示例代码： 12345678910- (UIViewController *)parentController &#123; UIResponder *responder = [self nextResponder]; while (responder) &#123; if ([responder isKindOfClass:[UIViewController class]]) &#123; return (UIViewController *)responder; &#125; responder = [responder nextResponder]; &#125; return nil;&#125; 作者：刘小壮 链接：https://www.jianshu.com/p/b0884faae603","tags":[{"name":"事件处理","slug":"事件处理","permalink":"http://yoursite.com/tags/事件处理/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"事件处理","slug":"IOS/事件处理","permalink":"http://yoursite.com/categories/IOS/事件处理/"}]},{"title":"homebrew-gem使用.","date":"2018-04-23T04:07:12.000Z","path":"wiki/工具/ruby/homebrew-gem使用/","text":"最近使用cocoapod更新repo会报下面错误： Updating spec repo master[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down 经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。传送门。 解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。 Homebrew介绍Homebrew是一款Mac OS平台下的软件包管理工具，拥有安装、卸载、更新、查看、搜索等很多实用的功能。简单的一条指令，就可以实现包管理，而不用你关心各种依赖和文件路径的情况，十分方便快捷。援引官方的一句话：又提示缺少套件啦？别担心，Homebrew 随时守候。Homebrew – OS X 不可或缺的套件管理器。 使用ruby安装Homebrew 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 卸载 1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/uninstall)\" homebrew使用 安装包 brew install 卸载包 brew uninstall 查询可用包 brew search 查看已经安装列表 brew list 查看任意包信息brew info ruby更新使用brew安装ruby很方便，但缺点也是很明显的，不能实时进行版本的切换，所以还是用 brew + rvm 或brew + rbenv比较好，但是后面的这种方法我没有走通。所以我使用Homebrew更新ruby。 我们不去删除系统自带的ruby，gem，而是自己重新安装一套新的ruby，gem，通过更改PATH环境变量的方式来更新系统， 这样做好处比较安全的，不会破坏原有的苹果系统，又不耽误我使用最新的ruby。 更新Home brew好了，开始吧 12brew updatebrew install ruby 设置环境变量系统原始版本的/usr/bin/ruby 我们并不删除，只是更改PATH环境变量，且将/usr/local/bin 添加到PATH的前面，这样系统就会首先用 /usr/local/bin下面找到我们用brew安装的ruby ruby 2.5.1p57(2018-03-29 revision 63029) [x86_64-darwin16]版本的了。 到自己目录下的.profile 或者 .bashrc 或者 .bash_profile 用vim打开 （更改前请备份好这个文件，避免误操作） 在文件的末尾加入: 12# for brew installexport PATH=/usr/local/bin:$PATH 然后重启终端，就可以用到了新的ruby了 检验一下 1234$ ruby --versionruby 2.5.1p57 (2018-03-29 revision 63029) [x86_64-darwin16]$ which ruby/usr/local/bin/ruby 注意：系统的是 /usr/bin/ruby gem的自我更新gem是随着ruby的安装而安装的，所以路径和刚刚安装ruby的路径是相同过的， 此gem是自己安装路径中的gem (/usr/local/bin/gem)，不是系统的gem(/usr/bin/gem)，我们这里也不动系统的gem 12$ which gem/usr/local/bin/gem gem 介绍Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem源来查找、安装、升级和卸载软件包，非常的便捷。 Ruby 1.9.2版本默认已安装Ruby Gem，如果你使用其它发行版本，请参考“如何安装Ruby Gem”。 Ruby gem包的安装方式： 所有的gem包，会被安装到 /[Ruby root]/lib/ruby/gems/[ver]/ 目录下，这其中包括了Cache、doc、gems、specifications 4个目录，cache下放置下载的原生gem包，gems下则放置的是解压过的gem包。当安装过程中遇到问题时，可以进入这些目录，手动删除有问题的gem包，然后重新运行 gem install [gemname] 命令即可。 Ruby Gem命令详解： //更新Gem自身//注意：在某些linux发行版中为了系统稳定性此命令禁止执行$ gem update –system // 从Gem源安装gem包$ gem install [gemname] // 从本机安装gem包$ gem install -l [gemname].gem // 安装指定版本的gem包$ gem install [gemname] –version=[ver] // 更新所有已安装的gem包$ gem update // 更新指定的gem包// 注意：gem update [gemname]不会升级旧版本的包，此时你可以使用 gem install [gemname] –version=[ver]代替$ gem update [gemname] // 删除指定的gem包，注意此命令将删除所有已安装的版本$ gem uninstall [gemname] // 删除某指定版本gem$ gem uninstall [gemname] –version=[ver] // 查看本机已安装的所有gem包$ gem list [–local] 解决无法连接到GitHub问题通过下面的命令可以解决链接到Github失败的问题 ： 升级openssl123456789101112131415161718192021222324$ which openssl/usr/local/opt/openssl/bin/openssl$ openssl versionOpenSSL 1.0.2o 27 Mar 2018#如果openssl版本低，请使用Homebrew更新$ brew update$ brew install openssl$ brew upgrade openssl`` If you need to have this software first in your PATH run: echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ echo 'export PATH=\"/usr/local/opt/openssl/bin:$PATH\"' &gt;&gt; ~/.bash_profile$ source ~/.bash_profile$ which openssl/usr/local/opt/openssl/bin/openssl$ openssl versionOpenSSL 1.0.2n 7 Dec 2017 升级ruby$ ruby –versionruby 2.5.0p0 (2017-12-25 revision 61468) [x86_64-darwin16] 如果版本比较低，请参考ruby升级 升级cocoapod$ gem install cocoapods -n /usr/local/bin $ which pod/usr/local/bin/pod $ pod –version1.5.0 参考 mac系统用HomeBrew直接安装ruby Cocoapods: Failed to connect to GitHub to update the CocoaPods/Specs specs repo","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"ruby","slug":"工具/ruby","permalink":"http://yoursite.com/categories/工具/ruby/"}]},{"title":"堆区（heap）和栈区（stack）的区别(转载)","date":"2018-04-03T04:07:12.000Z","path":"wiki/C语言语法/堆区（heap）和栈区（stack）的区别/","text":"（1）申请方式 栈区：由编译器自动分配释放，存放函数的参数值，局部变量值等； 堆区：一般由程序员分配释放（使用new/delete或malloc/free），若程序员不释放，程序结束时可能由OS回收； （2）操作方式 栈区：操作方式类似于数据结构中的栈； 堆区：不同于数据结构中的堆，分配方式类似于链表。 （3）申请后系统的响应 栈区：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出； 堆区：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。 （4）申请大小的限制 栈区：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆区：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。 （5）申请效率的比较 栈区：系统自动分配，速度较快。但程序员是无法控制的。 堆区：由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便. 注意：在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 （6）堆和栈中的存储内容 栈区：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。 堆区：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。 参考资料 堆区（heap）和栈区（stack）的区别","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"NSDateFormatter 时间格式","date":"2018-03-22T07:35:49.000Z","path":"wiki/IOS/foundation使用记录/NSDateFormatter时间格式/","text":"时间匹配格式Date Field Symbol Table Field Sym. No. Example Description era G 1..3 AD Era - Replaced with the Era string for the current date. One to three letters for the abbreviated form, four letters for the long form, five for the narrow form. 4 Anno Domini 5 A year y 1..n 1996 Year. Normally the length specifies the padding, but for two letters it also specifies the maximum length. Example: Y 1..n 1997 Year (in “Week of Year” based calendars). This year designation is used in ISO year-week calendar as defined by ISO 8601, but can be used in non-Gregorian based calendar systems where week date processing is desired. May not always be the same value as calendar year. u 1..n 4601 Extended year. This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0. quarter Q 1..2 02 Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name. 3 Q2 4 2nd quarter q 1..2 02 Stand-Alone Quarter - Use one or two for the numerical quarter, three for the abbreviation, or four for the full name. 3 Q2 4 2nd quarter month M 1..2 09 Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or five for the narrow name. 3 Sept 4 September 5 S L 1..2 09 Stand-Alone Month - Use one or two for the numerical month, three for the abbreviation, or four for the full name, or 5 for the narrow name. 3 Sept 4 September 5 S l 1 * Special symbol for Chinese leap month, used in combination with M. Only used with the Chinese calendar. week w 1..2 27 Week of Year. W 1 3 Week of Month day d 1..2 1 Date - Day of the month D 1..3 345 Day of year F 1 2 Day of Week in Month. The example is for the 2nd Wed in July g 1..n 2451334 Modified Julian day. This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields. week day E 1..3 Tues Day of week - Use one through three letters for the short day, or four for the full name, or five for the narrow name. 4 Tuesday 5 T e 1..2 2 Local day of week. Same as E except adds a numeric value that will depend on the local starting day of the week, using one or two letters. For this example, Monday is the first day of the week. 3 Tues 4 Tuesday 5 T c 1 2 Stand-Alone local day of week - Use one letter for the local numeric value (same as ‘e’), three for the short day, or four for the full name, or five for the narrow name. 3 Tues 4 Tuesday 5 T period a 1 AM AM or PM hour h 1..2 11 Hour [1-12]. H 1..2 13 Hour [0-23]. K 1..2 0 Hour [0-11]. k 1..2 24 Hour [1-24]. j 1..2 n/a This is a special-purpose symbol. It must not occur in patterns, but is reserved for use in APIs doing flexible date pattern generation, and requests the preferred format (12 vs 24 hour) for the language in question. minute m 1..2 59 Minute. Use one or two for zero padding. second s 1..2 12 Second. Use one or two for zero padding. S 1..n 3457 Fractional Second - rounds to the count of letters. (example is for 12.34567) A 1..n 69540000 Milliseconds in day. This field behaves _exactly_ like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value. zone z 1..3 PDT _fallbacks: _HPG-8:00 GMT-08:00 Timezone - with the s _pecific non-location format_ . Where that is unavailable, falls back to _localized GMT format_ . Use one to three letters for the short format or four for the full format. In the short format, metazone names are not used unless the commonlyUsed flag is on in the locale. 4 Pacific Daylight Time _fallbacks:_ HPG-8:00 GMT-08:00 Z 1..3 -0800 Timezone - Use one to three letters for RFC 822 format, four letters for the localized GMT format. 4 HPG+8:00 _fallbacks:_ GMT-08:00 v 1 PT Timezone - with the _generic_ _non-location format_ . Where that is unavailable, uses special fallback rules given in _[Appendix J][6]_ . Use one letter for short format, four for long format. 4 Pacific Time _fallbacks:_ Pacific Time (Canada) Pacific Time (Yellowknife) United States (Los Angeles) Time HPG-8:35 GMT-08:35 V 1 PST HPG-8:00 GMT-08:00 Timezone - with the same format as z, except that metazone timezone abbreviations are to be displayed if available, regardless of the value of commonlyUsed. 4 United States (Los Angeles) Time _fallbacks:_ HPG-8:35 MT-08:35 Timezone - with the _generic_ _location format_ . Where that is unavailable, falls back to the localized GMT format. (Fallback is only necessary with a GMT-style Timezone ID, like Etc/GMT-830.) This is especially useful when presenting possible timezone choices for user selection, since the naming is more uniform than the v format. 参考 UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)","tags":[{"name":"NSDateFormatter","slug":"NSDateFormatter","permalink":"http://yoursite.com/tags/NSDateFormatter/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"foundation使用记录","slug":"IOS/foundation使用记录","permalink":"http://yoursite.com/categories/IOS/foundation使用记录/"}]},{"title":"正确使用NS_DESIGNATED_INITIALIZER","date":"2018-03-21T04:07:12.000Z","path":"wiki/IOS/暂无分类/指定初始化函数/","text":"本文结束了下指定初始化函数，本文完全转载自 正确使用NS_DESIGNATED_INITIALIZER 。 为什么会提到NS_DESIGNATED_INITIALIZER============================================================ 最近在清理项目警告，遇到了“Method override for the designated initializer”的警告，全称为： Method override for the designated initializer of the superclass ‘-init’ not found 或者 Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found。 经排查是因为头文件中出现NS_DESIGNATED_INITIALIZER 声明的初始化方法，如下： 1- (instancetype)initWithPurchaseService:(HTLPrepayPurchaseService *)service NS_DESIGNATED_INITIALIZER; 如果用了NS_DESIGNATED_INITIALIZER，那么警告中出现init、initWithNibName或是其它，取决于你的继承的父类类型： UIViewController Method override for the designated initializer of the superclass ‘-initWithNibName:bundle:’ not found Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found UIView Method override for the designated initializer of the superclass ‘-initWithFrame:’ not found Method override for the designated initializer of the superclass ‘-initWithCoder:’ not found NSObject Method override for the designated initializer of the superclass ‘-init’ not found 正确使用NS_DESIGNATED_INITIALIZER为什么要用NS_DESIGNATED_INITIALIZERObjective-C 中主要通过NS_DESIGNATED_INITIALIZER宏来实现指定构造器的。这里之所以要用这个宏，往往是想告诉调用者要用这个方法去初始化（构造）类对象。 怎样避免使用NS_DESIGNATED_INITIALIZER产生的警告如果子类指定了新的初始化器，那么在这个初始化器内部必须调用父类的Designated Initializer。并且需要重写父类的Designated Initializer，将其指向子类新的初始化器。 如下： 123456789101112131415161718- (instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER;- (instancetype)init&#123; return [self initWithName:@\"\"];&#125;- (instancetype)initWithName:(NSString *)name&#123; self = [super init]; if (self) &#123; // do something &#125; return self; &#125; 更好的做法如果定义NS_DESIGNATED_INITIALIZER，大多是不想让调用者调用父类的初始化函数，只希望通过该类指定的初始化进行初始化，这时候就可以用NS_UNAVAILABLE宏。 如下： 12- (instancetype)init NS_UNAVAILABLE;- (instancetype)initWithName:(NSString *)name NS_DESIGNATED_INITIALIZER; 如果调用者使用init 初始化，编译器就会给出一个编译错误。使用NS_UNAVAILABLE后，就不需要在.m中重写父类初始化函数了。如果要允许调用者使用init就需要在.m中重写父类的初始化函数，如上提到的，否则就会报警告。 避免使用new如果使用new来创建对象的话，即使init被声明为NS_UNAVAILABLE，也不会收到编译器的警告和错误提示了。 参考链接 iOS Designated Initializers : Using NS_DESIGNATED_INITIALIZER","tags":[{"name":"指定初始化函数","slug":"指定初始化函数","permalink":"http://yoursite.com/tags/指定初始化函数/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"暂无分类","slug":"IOS/暂无分类","permalink":"http://yoursite.com/categories/IOS/暂无分类/"}]},{"title":"工具下载地址","date":"2018-03-13T10:01:31.000Z","path":"wiki/工具/工具下载地址/工具下载地址/","text":"本文记录常用工具下载地址 xclient mac gif制作工具 PicGIF+v2.0.0.dmg","tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"工具下载地址","slug":"工具/工具下载地址","permalink":"http://yoursite.com/categories/工具/工具下载地址/"}]},{"title":"创建私有仓库","date":"2018-03-01T06:50:54.000Z","path":"wiki/工具/Cocoapods/cocoapod-private-repo/","text":"本文说明制作Cocoapod私有库的过程。本文涉及到两个仓库 ‘官方仓库’、’私有仓库’。 官方仓库的作用代表CocoaPods的官方podspec存放地址。 具体可以参考:CocoaPods官方源、Specs; 私有仓库的是私有podspec存放地址。在git中仓库名称是LJRepo，clone到本地的别名是MyPrivateRepo。后文中私有仓库–LJRepo指的git地址，MyPrivateRepo指的是clone到本地的名称。 创建私有仓库仓库（Spec Repo） 是所有的Pods的一个索引，是所有公开\\私有Pods的podspec文件仓库，其实就是一个部署在服务器的Git仓库，当你使用CocoaPods 后它会被Clone到本地的 ~/.cocoapods/repos 目录下。 首先在git上创建一个私有远端仓库LJRepo，步骤如下： 在GitHub上创建私有仓库LJRepo，空的就可以。 将私有仓库LJRepo添加到cocoapod中，远端私有仓库LJRepo 在本地中的别名是MyPrivateRepo，这样以后操作MyPrivateRepo就相当于操作LJRepo， 命令如下： 1pod repo add 'MyPrivateRepo' 'git@github.com:jianli2017/LJRepo.git' 注意：这个Git 仓库地址要换成你自己的创建的 Specs git 地址！！！ 成功后会在~/.cocoapods/repos目录下就能看到MyPrivateRepo了，至此，第一步就完成了创建私有仓库。 创建完成后，查看~/.cocoapods/repos 目录的变化： 12345# cd 到~/.cocoapods/repos 目录cd ~/.cocoapods/repos# 查看目录结构tree -L 3 大概的文件目录如下: 1234567891011.├── MyPrivateRepo│ └── LJMenu│ └── 1.0.1└── master ├── CocoaPods-version.yml ├── README.md └── Specs ├── 0 ├── 1 ├── 2 其中master就是官方的Sepc Repo,跟master同目录级别的MyPrivateRepo目录就是我自己创建的私有Sepc Repo。私有仓库中LJMenu是以前创建的，如果以前没有创建，MyPrivateRepo下面是空的。 也可以使用’pod repo list ‘ 命令查看仓库信息，结果如下： 1234567891011master- Type: git (master)- URL: https://github.com/CocoaPods/Specs.git- Path: /Users/lijian/.cocoapods/repos/masterMyPrivateRepo- Type: git (master)- URL: git@github.com:jianli2017/LJRepo.git- Path: /Users/lijian/.cocoapods/repos/MyPrivateRepo2 repos 小结 上面讲解了私有仓库的创建方法。创建完成后，从两个方面描述私有仓库，进一步认识私有创库：文件目录、pod命令 创建LJMenu库1.创建LJMenu库： 首先，在Git上创建一个LJMenu仓库,当然你也是可以在公司内网创建的。 创建方法使用Cocoapods提供的一个Using Pod Lib Create 工具。 在Terminal中执行cd命令，进入要创建项目的目录，执行以下命令： 12#pod lib create [项目名]pod lib create LJMenu ‘pod lib create’命令会在当前目录创建LJMenu项目，接着在Terminal控制台会输出： 123456789101112131415Cloning `https://github.com/CocoaPods/pod-template.git` into `LJMenu`.Configuring LJMenu template.Ignoring ffi-1.9.14 because its extensions are not built. Try: gem pristine ffi --version 1.9.14------------------------------To get you started we need to ask a few questions, this should only take a minute.2018-03-02 13:55:04.386 defaults[30912:784564] The domain/default pair of (org.cocoapods.pod-template, HasRunbefore) does not existIf this is your first time we recommend running through with the guide: - http://guides.cocoapods.org/making/using-pod-lib-create.html ( hold cmd and double click links to open in a browser. ) Press return to continue. 选择回车按钮，接着会出现一系列的问题： 1234567891011121314151617What platform do you want to use?? [ iOS / macOS ] &gt; iosWhat language do you want to use?? [ Swift / ObjC ] &gt; objcWould you like to include a demo application with your library? [ Yes / No ] &gt; yesWhich testing frameworks will you use? [ Specta / Kiwi / None ] &gt; spectaWould you like to do view based testing? [ Yes / No ] &gt; yesWhat is your class prefix? &gt; LJ 回答完问题后，会创建出LJMenu项目。结构如下： 12345678910111213141516.├── Example│ ├── LJMenu│ ├── LJMenu.xcodeproj│ ├── LJMenu.xcworkspace│ ├── Podfile│ ├── Podfile.lock│ ├── Pods│ └── Tests├── LICENSE├── LJMenu **这个是创建的LJMenu项目**│ ├── Assets│ └── Classes├── LJMenu.podspec ├── README.md└── _Pods.xcodeproj -&gt; Example/Pods/Pods.xcodeproj 2、添加实现代码 123456789101112131415LJMenu├── Assets└── Classes ├── LJMenu │ ├── IFMMenu.h │ ├── IFMMenu.m │ ├── IFMMenuContainerView.h │ ├── IFMMenuContainerView.m │ ├── IFMMenuItem.h │ ├── IFMMenuItem.m │ ├── IFMMenuView.h │ └── IFMMenuView.m └── ReplaceMe.m3 directories, 9 files 在本教程中我在上面的Classes文件目录添加了 IFMMenu*.[h、m]八个文件。3.开发模式下测试pod库的代码 打开Example工程目录Podfile文件： 12pod 'MyLib', :path =&gt; '../' # 指定路径#pod 'MyLib', :podspec =&gt; '../MyLib.podspec' # 指定podspec文件 然后在Example工程目录下执行 pod install命令安装依赖，打开项目工程，可以看到库文件都被加载到Pods子项目中了 不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/MyLib中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。测试库文件没有问题,接着我们需要执行第4步。 4.提交LJMenu库到git上。 在Terminal中执行以下命令： 123456git add .git commit -m '1.0.2'git remote add origin git@github.com:jianli2017/LJMenu.gitgit push origin master #提交到远端仓库git tag -m \"v1.0.2\" \"v1.0.2\" #打上标签，这个很重要git push --tags #推送tag到远端仓库 到这里，成功提交到远程仓库—LJMenu库，以后就可以使用git上的LJMenu库了。 创建并提交LJMenu库的podspec文件到私有仓库MyPrivateRepo1.配置LJMenu库的podspec 文件 123456789101112131415161718192021222324252627282930313233343536373839404142## Be sure to run `pod lib lint LJMenu.podspec' to ensure this is a# valid spec before submitting.## Any lines starting with a # are optional, but their use is encouraged# To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html#Pod::Spec.new do |s| s.name = 'LJMenu' s.version = '1.0.2' s.summary = 'A short description of LJMenu.'# This description is used to generate tags and improve search results.# * Think: What does it do? Why did you write it? What is the focus?# * Try to keep it short, snappy and to the point.# * Write the description between the DESC delimiters below.# * Finally, don't worry about the indent, CocoaPods strips it! s.description = &lt;&lt;-DESCTODO: Add long description of the pod here. DESC s.homepage = 'https://github.com/jianli2017/LJMenu' # s.screenshots = 'www.example.com/screenshots_1', 'www.example.com/screenshots_2' s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; 'jianli2017' =&gt; 'lijian-ds1@gomeplus.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/jianli2017/LJMenu.git', :tag =&gt; 'v1.0.2'&#125; # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' s.ios.deployment_target = '8.0' s.source_files = 'LJMenu/Classes/**/*' # s.resource_bundles = &#123; # 'LJMenu' =&gt; ['LJMenu/Assets/*.png'] # &#125; # s.public_header_files = 'Pod/Classes/**/*.h' # s.frameworks = 'UIKit', 'MapKit' # s.dependency 'AFNetworking', '~&gt; 2.3'end podspec更多配置请参考:官方文档 2.验证LJMenu.podspec 编辑完LJMenu.podspec文件后，需要验证一下这个LJMenu.podspec文件是否可用 ,在Terminal中执行cd进入MyLib项目根目录然后，执行以下命令： 1pod spec lint --allow-warnings 当你看到 Terminal 中输出： 1234567 -&gt; LJMenu (1.0.2) - WARN | summary: The summary is not meaningful. - WARN | url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.Analyzed 1 podspec.LJMenu.podspec passed validation. 表示这个LJMenu.podspec 验证通过，是一个符合CocoaPods规则的配置文件。 3.本地测试LJMenu.podspec文件 打开Example工程目录Podfile文件修改下pod 的引用 12#pod 'LJMenu', :path =&gt; '../' # 指定路径pod 'LJMenu', :podspec =&gt; '../LJMenu.podspec' # 指定podspec文件 然后在Example工程目录下执行pod install命令安装依赖，打开项目工程，现在可以看到库文件都被加载到Pods子项目中了 4.向Spec Repo提交podspec 测试库文件没有问题我们就把MyLib.podspec提交到远程Spec Repo仓库中，就是本文开头说的[官方仓库][13] 在Terminal中执行 cd进入MyLib项目根目录然后，执行以下命令： 12# pod repo push [Repo名] [podspec 文件名字]$ pod repo push MyPrivateRepo ./LJMenu.podspec --allow-warnings 如果提交成功，在Terminal会输出： 1234567891011121314Validating spec -&gt; LJMenu (1.0.2) - WARN | summary: The summary is not meaningful. - WARN | url: There was a problem validating the URL https://github.com/jianli2017/LJMenu.Updating the `MyPrivateRepo' repoAlready up-to-date.Adding the spec to the `MyPrivateRepo' repo - [Update] LJMenu (1.0.2)Pushing the `MyPrivateRepo' repo 表示提交成功了！这个组件库就添加到我们的私有Spec Repo中了，可以进入到~/.cocoapods/repos/MySpecs目录下查看 12cd ~/.cocoapods/repos/tree -L 3 MyPrivateRepo/ 结果如下： 12345678MyPrivateRepo/└── LJMenu ├── 1.0.1 │ └── LJMenu.podspec └── 1.0.2 └── LJMenu.podspec3 directories, 2 files 再去看我们的Spec Repo远端仓库 也就是[官方仓库][14]，也有了一次提交，这个podspec也已经被Push上去了。 至此，我们的这个组件库就已经制作添加完成了，使用pod search命令就可以查到我们自己的库了. 在Terminal中执行 pod search MyLib 123456-&gt; LJMenu (1.0.2) A short description of LJMenu. pod 'LJMenu', '~&gt; 1.0.2' - Homepage: https://github.com/jianli2017/LJMenu - Source: https://github.com/jianli2017/LJMenu.git - Versions: 1.0.2, 1.0.1 [MyPrivateRepo repo] 使用制作好的Pod在完成这一系列步骤之后，我们就可以在正式项目中使用这个私有的Pod了只需要在项目的Podfile里增加以下一行代码即可, 在正式项目的Podfile 里添加私有Spec Repo 123456#私有Spec Reposource 'git@github.com:jianli2017/LJRepo.git' source 'git@github.com:CocoaPods/Specs.git'pod 'LJMenu', '~&gt; 1.0.2' 然后执行pod install，安装依赖，然后打开项目可以看到，我们自己的库文件已经出现在Pods子项目中的Pods子目录下了，而不再是Development Pods。 将LJMenu发布到官方仓库中注册CocoaPods首先使用pod trunk me查看自己是否注册过：如果没有下面类似的内容输出,则表示没有注册过 123456- Name: jianli2017- Email: jianli2017@163.com- Since: February 28th, 04:01- Pods: None- Sessions:- February 28th, 04:01 - July 6th, 04:04. IP: 101.254.248.194 使用pod trunk register命令注册。 1pod trunk register jianli2017@163.com 'jianli2017' --verbose 注册完成后，使用下面的命令，将LJMenu库的spec推送到官方仓库中。 1pod trunk push --allow-warnings 推送完成后，可以使用pod search 查看。 tippod命令使用方法pod的命令如果不知道怎么用，可以使用pod –help命令查看使用方法： 12345678910111213141516171819202122232425262728293031323334Usage:$ pod COMMANDCocoaPods, the Cocoa library package manager.Commands:+ cache Manipulate the CocoaPods cache+ deintegrate Deintegrate CocoaPods from your project+ env Display pod environment+ init Generate a Podfile for the current directory+ install Install project dependencies according to versions from aPodfile.lock+ ipc Inter-process communication+ lib Develop pods+ list List pods+ outdated Show outdated project dependencies+ plugins Show available CocoaPods plugins+ repo Manage spec-repositories+ search Search for pods+ setup Setup the CocoaPods environment+ spec Manage pod specs+ trunk Interact with the CocoaPods API (e.g. publishing new specs)+ try Try a Pod!+ update Update outdated project dependencies and create new Podfile.lockOptions:--silent Show nothing--version Show the version of the tool--verbose Show more debugging information--no-ansi Show output without ANSI codes--help Show help banner of specified command 通过上面可以看到pod 的所有命令。常用的有pod init、pod install、 pod update、pod lib、pod repo等等，如果对pod repo不了解，可以使用pod repo –help进一步查看使用方法。 123456789101112131415161718192021Usage:$ pod repo [COMMAND]Manage spec-repositoriesCommands:+ add Add a spec repo+ lint Validates all specs in a repo&gt; list List repos+ push Push new specifications to a spec-repo+ remove Remove a spec repo+ update Update a spec repoOptions:--silent Show nothing--verbose Show more debugging information--no-ansi Show output without ANSI codes--help Show help banner of specified command 可以看出，pod repo add 、pod repo list 等命令，如果对pod repo list命令不知道如何使用，可以使用pod repo list –help命令进一步查看使用方法 12345678910111213Usage:$ pod repo listList the repos from the local spec-repos directory at `~/.cocoapods/repos/.`Options:--count-only Show the total number of repos--silent Show nothing--verbose Show more debugging information--no-ansi Show output without ANSI codes--help Show help banner of specified command 上面的方法对任何的pod命令都使用，通过上面的方法我们可以学习会pod命令的使用方法。 参考资料 利用CocoaPods创建私有库","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Cocoapods","slug":"工具/Cocoapods","permalink":"http://yoursite.com/categories/工具/Cocoapods/"}]},{"title":"","date":"2018-02-28T08:39:10.000Z","path":"wiki/IOS/swiftUI/swiftUI_Share的副本/","text":"跨平台技术演变史 H5+原生（Cordova） JavaScript开发+原生渲染 （React Native、Weex） 自绘UI+原生功能(Flutter、SwiftUI) H5+原生 缺点： webview渲染存在性能瓶颈、复杂任务无法胜任 调用原生功能需要封装插件，麻烦 JavaScript开发+原生渲染 分析： 解决了Webview渲染性能问题，相比较于原生，多了从Vue到原始的翻译过程。 调用原生功能需要封装插件，也比较麻烦 自绘UI+原生功能 flutter Dart语言开发, Skia渲染。Skia是Google的一个2D图形处理函数库，包含字型、坐标转换，以及点阵图都有高效能且简洁的表现，Skia是跨平台的，并提供了非常友好的API 分析： 解决了JS到Native的翻译过程，自渲染。 调用原生功能需要封装插件，也比较麻烦 SwiftUI简介 声明式语法（SwiftUI），内部黑盒完成渲染 响应式编程，数据变化，监控、通知SwiftUI刷新数据 无缝调用原始功能 一个例子—体验SwiftUI现代编程语言的魅力代码 12345678910111213141516171819202122232425struct LandmarkList: View &#123; @EnvironmentObject var userData: UserData var body: some View &#123; NavigationView &#123; List &#123; Toggle(isOn: $userData.showFavoritesOnly) &#123; Text(\"Show Favorites Only\") &#125; ForEach(userData.landmarks) &#123; landmark in if !self.userData.showFavoritesOnly || landmark.isFavorite &#123; NavigationButton( destination: LandmarkDetail(landmark: landmark) .environmentObject(self.userData) ) &#123; LandmarkRow(landmark: landmark) &#125; &#125; &#125; &#125; .navigationBarTitle(Text(\"Landmarks\"), displayMode: .large) &#125; &#125;&#125; 12345678910111213141516171819202122struct LandmarkRow: View &#123; var landmark: Landmark var body: some View &#123; HStack &#123; landmark.image(forSize: 50) Text(verbatim: landmark.name) Spacer() if landmark.isFavorite &#123; VStack &#123; Image(systemName: \"star.fill\") .imageScale(.medium) .foregroundColor(.yellow) Text(\"sdfsdf\") &#125; &#125; &#125; &#125;&#125; SwiftUI原理浅析View的运作原理体会了SwiftUI的简洁用法，强大的功能后，分析下背后的原理： 定义了View的协议，所有的控件都准守View协议，View协议只定义了一个属性body，由于有了body属性，所以可以对body做对应的操作，这些操作封装在View的扩展中。这些扩展称为modifier。modifer作用于一个元素后，返回一个modified对象，这个对象也准守View协议，可以链式调用。 声明了控件的样式（内存看是链式结构）， 传入渲染引擎渲染。开发者只声明，不用管复杂的渲染机制，大大简化了开发难度 按需添加modifer，避免子类内存暴涨（性能） 基于协议式，底层可以任意修改，底层预留可非常大的扩展空间 HStack/ZStackHStack 和 ZStack 的非常类似安卓的 LinerLayout，算法也同 Flex 布局比较相似。 对于如下的布局, 苹果都会在控件之间添加上符合苹果人机交互指南的间距，保证 UI 的优雅和一致性。 对于如上的 Stack 是怎么计算的？设 Stack 主轴方向长度为 W1。 根据人机交互指南的预留出边距 S, 边距根据元素的排列可能有多个 得到剩余的主轴宽度 W2= W1 - N * S 平均分配一个预估宽度 计算一些具备明确宽高的元素 如 Image 设置了 Frame的元素的等。 沿主轴方向从前到后计算，，如果计算出来的宽度小于预估宽度则正常显示，不够则截断。 最后的元素为剩余宽度，如果不够显示则阶段 默认的交叉轴对齐方式为 Center，Stack 占据包括最大元素的边界。 默认的计算是顺序计算布局，如果某些元素比较重要，可以使用 LayoutPriority Modifier 提高布局优先级避免出现视图截断。 总结 基于声明式，底层做了大量工作，上层开发者开发更简单 响应式也简化了内部状态的维护 苹果生态系统的无缝衔接，无缝调用原生功能 内部人性化精细的设计，苹果的大力推广，不久的几年后，苹果开发的主要方式？ 参考 官方教程 SwiftUI 的一些初步探索 (一) 系列文章深度解读|SwiftUI 背后那些事儿","tags":[],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"swiftUI","slug":"IOS/swiftUI","permalink":"http://yoursite.com/categories/IOS/swiftUI/"}]},{"title":"图解SSH原理","date":"2018-02-27T10:11:35.000Z","path":"wiki/编程理论/SSH/ssh-theory/","text":"SSH是一种协议标准，其目的是实现安全远程登录以及其它安全网络服务。本文转载于图解SSH原理 初见SSH SSH仅仅是一协议标准，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。 SSH工作原理在讨论SSH的原理和使用前，我们需要分析一个问题：为什么需要SSH？ 从第一节SSH的定义中可以看出，SSH和telnet、ftp等协议主要的区别在于安全性。这就引出下一个问题：如何实现数据的安全呢？首先想到的实现方案肯定是对数据进行加密。加密的方式主要有两种： 对称加密（也称为秘钥加密） 非对称加密（也称公钥加密） 所谓对称加密，指加密解密使用同一套秘钥。如下图所示： 对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：如何安全的传输密钥、保存秘钥呢？尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，非对称加密应运而生。非对称加密有两个密钥：“公钥”和“私钥”。 两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。 下面看下使用非对称加密方案的登录流程： 远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。 Client使用这个公钥，将密码进行加密。 Client将加密的密码发送给Server端。 远程Server用自己的私钥，解密登录密码，然后验证其合法性。 若验证结果，给Client相应的响应。 私钥是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。 这样就一定安全了吗？上述流程会有一个问题：Client端如何保证接受到的公钥就是目标Server端的？，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？这就是所谓的[中间人攻击][2] SSH中是如何解决这个问题的？基于口令的认证从上面的描述可以看出，问题就在于如何对Server的公钥进行认证？在https中可以通过CA来进行公证，可是SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息： 123The authenticity of host 'ssh-server.example.com (12.18.429.21)' can't be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)? 上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？ 之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。 如果输入yes后，会出现下面信息： 12Warning: Permanently added 'ssh-server.example.com,12.18.429.21' (RSA) to the list of known hosts. Password: (enter password) 该host已被确认，并被追加到文件known_hosts中，然后就需要输入密码，之后的流程就按照图1-3进行。 2.基于公钥认证在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下： Client端用户TopGun将自己的公钥存放在Server上，追加在文件authorized_keys中。 Server收到登录请求后，随机生成一个字符串str1，并发送给Client。 Client用自己的私钥对字符串str1进行加密。 将加密后字符串发送给Server。 Server用之前存储的公钥进行解密，比较解密后的str2和str1。 根据比较结果，返回客户端登陆结果。 在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图： SSH实践生成密钥操作经过上面的原理分析，下面三行命令的含义应该很容易理解了： 123$ ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys$ chmod 0600 ~/.ssh/authorized_keys ssh-keygen是用于生产密钥的工具。 -t：指定生成密钥类型（rsa、dsa、ecdsa等） -P：指定passphrase，用于确保私钥的安全 -f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub） 首先看下面~/.ssh中的四个文件： id_rsa：保存私钥 id_rsa.pub：保存公钥 authorized_keys：保存已授权的客户端公钥 known_hosts：保存已认证的远程主机公钥四个角色的关系如下图所示： 需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。 登录操作12345678# 以用户名user，登录远程主机host$ ssh user@host# 本地用户和远程用户相同，则用户名可省去$ ssh host# SSH默认端口22，可以用参数p修改端口$ ssh -p 2017 user@host 4 总结本文以图文方式对SSH原理进行解析（主要指远程登录，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。 参考资料 图解SSH原理","tags":[],"categories":[{"name":"编程理论","slug":"编程理论","permalink":"http://yoursite.com/categories/编程理论/"},{"name":"SSH","slug":"编程理论/SSH","permalink":"http://yoursite.com/categories/编程理论/SSH/"}]},{"title":"Cocoapods-new-spec","date":"2018-02-27T07:06:13.000Z","path":"wiki/工具/Cocoapods/Cocoapods-new-spec/","text":"参考资料","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Cocoapods","slug":"工具/Cocoapods","permalink":"http://yoursite.com/categories/工具/Cocoapods/"}]},{"title":"cocoapod学习 安装和使用（1）","date":"2018-02-27T02:29:06.000Z","path":"wiki/工具/Cocoapods/cocoapod-learn-install/","text":"CocoaPods Get on with building your app, not duplicating code ,是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要做太多的配置。本文在看一遍就会的CocoaPods的安装和使用教程的基础上稍微修改而来。 什么是CocoaPods？CocoaPods是管理iOS工程依赖的第三方库的工具，通过CocoaPods，我们可以很方便地管理每个第三方库的版本，且不需要我们做太多的配置。直观、集中和自动化地管理项目的第三方库。 我们都有这样的经历，当添加第三方库的时候，需要导入一堆相关依赖库。当需要更新某个第三方库的时候，又需要手动移除该库，导入新的库，然后再配置。这些是很麻烦且没有意义的工作。 使用CocoaPods管理第三方库后，只需要相当少的配置，就可将第三方库集成到工程中，其它的一切都交由CocoaPods来管理即可，我们使用起来就更省心了。 安装CocoaPods1.首先更新gem到最新版本，在终端中输入：sudo gem update –system更新gem Gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem（如 http://rubygems.org/ ）源来查找、安装、升级和卸载软件包，非常的便捷。 2.删除自带的ruby镜像，终端输入：gem sources --remove https://rubygems.org/。 3.添加淘宝的镜像，终端输入：gem sources -a https://gems.ruby-china.org/(原来的淘宝镜像 https://ruby.taobao.org/已经不能用了)。 4.可以用gem sources -l来检查使用替换镜像位置成功，结果应该只有 https://gems.ruby-china.org/ 才对。 5.安装CocoaPods，终端输入：sudo gem install cocoapods。 如果提示Operation not permitted，执行sudo gem install -n /usr/local/bin cocoapods命令安装，原因请参考系统集成保护。 6.然后配置下CocoaPods，终端输入：pod setup。 到这里CocoaPods就安装好了。 查找第三方库比如查找MJExtension，终端输入：pod search MJExtension，第一次搜索他需要建索引，等待一会儿就可以了。 输出结果如下： 12345678910111213141516171819-&gt; MJExtension (3.0.13) A fast and convenient conversion between JSON and model pod 'MJExtension', '~&gt; 3.0.13' - Homepage: https://github.com/CoderMJLee/MJExtension - Source: https://github.com/CoderMJLee/MJExtension.git - Versions: 3.0.13, 3.0.12, 3.0.11, 3.0.10, 3.0.9, 3.0.8, 3.0.7, 3.0.6, 3.0.5, 3.0.4, 3.0.3, 3.0.2, 3.0.0, 2.5.16, 2.5.15, 2.5.14, 2.5.13, 2.5.12, 2.5.10, 2.5.9, 2.5.8, 2.5.7, 2.5.6, 2.5.5, 2.5.3, 2.5.2, 2.5.1, 2.5.0, 2.4.4, 2.4.2, 2.4.1, 2.4.0, 2.3.8, 2.3.7, 2.3.6, 2.3.5, 2.3.4, 2.3.3, 2.3.2, 2.3.1, 2.3.0, 2.2.0, 2.1.1, 2.1.0, 2.0.4, 2.0.3, 2.0.2, 2.0.1, 2.0.0, 1.2.1, 1.2.0, 1.1.0, 1.0.1, 1.0.0, 0.3.2, 0.3.1, 0.3.0, 0.2.0, 0.1.3, 0.1.2, 0.1.1, 0.1.0, 0.0.3, 0.0.2, 0.0.1 [master repo]-&gt; MJExtension_HPTest (0.0.1) 花圃测试项目 pod 'MJExtension_HPTest', '~&gt; 0.0.1' - Homepage: https://github.com/LetMeCrazy/testPods - Source: https://github.com/LetMeCrazy/testPods.git - Versions: 0.0.1 [master repo] 引入第三方库到项目中我先在桌面上新建一个cocoapodUse项目，然后演示把MJExtension导进去。 2.然后生成并编辑一个Podfile文件，命令为: vim Podfile 要导入的第三方都要写在Podfile中。进去后需要先按 I 键进入编辑状态，写完后按esc，然后按shift+zz(或者先按shift+:,再按wq)就可以保存退出了。 Podfile的格式如下，其中’cocoapodUse’为你的target的名字。 1234567platform :ios,'8.0'target 'cocoapodUse' dopod 'MJExtension', '~&gt; 3.0.13'end 3.安装，命令为： pod install 安装成功之后，第三方库就被包含到项目中了。 之前我们一直是双击Test.xcodeproj打开项目，以后我们就要双击Test.xcworkspace打开了，可以看到MJExtension已经被引入了。 项目引入MJExtension你会发现当引入MJExtension的头文件时，可以 #import &lt;MJExtension.h&gt;或者#import &lt;MJExtension/MJExtension.h&gt;，但是却不能在输入#import &quot;MJExtension.h&quot;的时候出现提示。虽然强制输入也可以编译通过，但是感觉很不爽。 解决这个问题的办法是在工程的Build Settings搜索Search，然后在User header search paths中添加$(SRCROOT)并选择recursive。 现在就可以提示#import “MJExtension.h”啦。 增加新的第三方如果使用过程中我还想添加其他的第三方怎么办，只要在Podfile里面接着添加，然后终端再执行pod install就可以了。 更新CocoaPods中的第三方库第三方库们都有人在维护升级，我们需要隔断时间就要更新下我们工程中第三方库的版本。只需要终端输入命令pod update就可以了。 如果遇到pod install或者pod update慢的问题，原因在于当执行以上两个命令的时候会升级CocoaPods的spec仓库，加一个参数可以省略这一步，然后速度就会提升不少。加参数的命令如下： pod install –verbose –no-repo-update 删除CocoaPods中的某些第三方库。当我们需要去掉某个第三方库时，只需要在Podfile删除该引入该库的语句，然后执行pod update或者pod install就可以了。 升级CocoaPods升级CocoaPods版本的命令和安装CocoaPods的命令一样，都是sudo gem install cocoapods。 如果老版本升级cocoapods的时候提示Operation not permitted - /usr/bin/xcodeproj，改用命令sudo gem install -n /usr/local/bin cocoapods –pre就可以了。 卸载CocoaPods卸载CocoaPods的命令是sudo gem uninstall cocoapods 执行完命令后，最下面打印Successfully uninstalled cocoapods字样就代表已经成功卸载了。 CocoaPods Mac App的安装和使用CocoaPods桌面应用版下载地址：[https://cocoapods.org/app][1] 打开应用会提示你是否安装命令行工具，选择install就也可以在命令行使用Pod了。省去了上面的步骤们，方便快捷的使用CocoaPods。 现在假如要给一个Test项目加入第三方库 1.选择File-New Podfile from Xcode Project，去选择项目的Project文件。 2.填写自动生成的Podfile，并且安装。 然后就可以去打开工程了，是不是比命令行简单多了。 注意：Cocoapods.app 删掉并执行命令可能会报错：Unable to locate the CocoaPods.app application bundle. Please ensure the application is available and launch it at least once这时候只要执行sudo gem install -n /usr/local/bin cocoapods命令就可以了。 CocoaPods官方使用指南链接：CocoaPods 官方使用指南有什么不了解的或者遇到错误可以去这里查看一下。 XCode的CocoaPods插件[CocoaPods-xcode-plugin]是一个XCode的插件，可以很方便的在Xcode通过pods安装各种第三方库。前提是终端已经安装好CocoaPods。 参考资料 看一遍就会的CocoaPods的安装和使用教程 升级 OS X 10.11 cocoapods 使用不正常的问题","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"Cocoapods","slug":"工具/Cocoapods","permalink":"http://yoursite.com/categories/工具/Cocoapods/"}]},{"title":"支持LaTEX的hexo博客","date":"2018-02-21T04:07:12.000Z","path":"wiki/工具/hexo/LaTex/","text":"本文主要解决hexo 博客部分数学公式不能正常显示的问题。 使Marked.js与MathJax共存因此我提供一个修改marked.js源码的方式来避开这些问题 针对下划线的问题，我决定取消_作为斜体转义，因为marked.js中也是斜体的意思，所以取消掉_的转义并不影响我们使用markdown，只要我们习惯用作为斜体字标记就行了。 针对marked.js与Mathjax对于个别字符二次转义的问题，我们只要不让marked.js去转义\\\\,\\{,\\}在MathJax中有特殊用途的字符就行了。具体修改方式，用编辑器打开marked.js（在./node_modules/marked/lib/中） Step 1: 1escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 替换成 1escape: /^\\\\([`*\\[\\]()# +\\-.!_&gt;])/, 这一步是在原基础上取消了对\\\\,\\{,\\}的转义(escape) Step 2: 1em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 替换成 1em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 这样一来MathJax就能与marked.js共存了。重启一下hexo看一下吧","tags":[{"name":"hexo_LaTEX","slug":"hexo-LaTEX","permalink":"http://yoursite.com/tags/hexo-LaTEX/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"hexo","slug":"工具/hexo","permalink":"http://yoursite.com/categories/工具/hexo/"}]},{"title":"自己搭建博客的经历","date":"2018-02-13T07:33:17.000Z","path":"wiki/工具/hexo/自己搭建博客的经历/","text":"本文记录自己搭建博客的记录，前提是Node.js、Git安装完成。 初始化hexo环境 新建博客的文件夹 12~/Desktop/jiangli2017 cd ~/Desktop/jianli2017 初始化hexo 1hexo init Wikitten主题配置本博客根据自己的喜好，选择的Wikitten主题，这个主题类似wiki，具有文章的目录结构。 进入你的 hexo 站点文件夹，克隆 Wikitten 主题到 themes/ 路径下 12cd ~/Desktop/jiangli2017 git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten 覆盖站点目录中一些默认页面模板 12cp -rf themes/Wikitten/_source/* source/cp -rf themes/Wikitten/_scaffolds/* scaffolds/ 重命名主题中的 _config.yml.example 到 _config.yml，然后可以使用配置文件配置主题 123cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml# 编辑配置文件，定制你的配置项vim themes/Wikitten/_config.yml 大部分的配置项都和 icarus 主题中的配置项一样，你可以首先去阅读一下 icraus 的文档。 需要安装的插件写在主题的 package.json 文件中 这里列出了这些插件的功能作用： 12345hexo-autonofollow // 打开非本站链接时自动开启新标签页hexo-directory-category // 根据文章文件目录自动为文章添加分类hexo-generator-feed // 生成 RSS 源hexo-generator-json-content // 生成全站文章 json 内容，用于全文搜索hexo-generator-sitemap // 生成全站站点地图 sitemap 你可以将这些插件合并到站点的 package.json 文件中通过 npm install 一次安装， 或者在站点目录下，你可以通过以下命令安装他们： 1$ npm i -S hexo-autonofollow hexo-directory-category hexo-generator-feed hexo-generator-json-content hexo-generator-sitemap 配置站点配置下面是站点推荐配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960yaml# Hexo Configuration# URLpermalink: wiki/:title/theme: Wikitten# Directoryskip_render: - README.md - '_posts/**/embed_page/**'# Writingnew_post_name: :title.md # File name of new posts## Markdown## https://github.com/hexojs/hexo-renderer-markedmarked: gfm: true ## Plugins: https://hexo.io/plugins/### JsonContentjsonContent: meta: false pages: title: true date: true path: true text: true posts: title: true date: true path: true text: true tags: true categories: true ignore: - 404.html ### Creat sitemapsitemap: path: sitemap.xml### Adds nofollow attribute to all external links in your hexo blog posts automatically.nofollow: enable: true exclude: - &lt;your site url domain&gt; # eg: zthxxx.me# Deployment（发布git）## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/jianli2017/jianli2017.github.io.git branch: master # 多级目录结构auto_dir_categorize: enable: true # options:true, false; default is true force: true # options:true, false; default is false 多级目录结构可以需要安装插件： 1npm install --save hexo-directory-category 遇到的问题 不能发布到git上面 12hexo dERROR Deployer not found: git 解决办法：hexo目录下安装： 1npm install --save hexo-deployer-git hexo d 没有反应 需要在站点目录下的_config.yml 中添加如下配置： 1234deploy: type: git repo: https://github.com/jianli2017/jianli2017.github.io.git branch: master 图床 我的博客中用相对目录显示图片，无法显示，需要用图床，我选择的是七牛云 参考资料","tags":[],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"hexo","slug":"工具/hexo","permalink":"http://yoursite.com/categories/工具/hexo/"}]},{"title":"Git分支管理(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git分支管理/","text":"本文全部复制Git教程,自己理解的就简单复制，没有理解的就全部粘贴。 创建和合并分支在[版本回退][1]里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长： 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： 12$ git checkout -b devSwitched to a new branch 'dev' 123$ git branch dev$ git checkout devSwitched to branch 'dev' 123$ git branch* dev master 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： 1Creating a new branch is quick. 1234$ git add readme.txt $ git commit -m \"branch test\"[dev fec145a] branch test 1 file changed, 1 insertion(+) 12$ git checkout masterSwitched to branch 'master' 现在，我们把dev分支的工作成果合并到master分支上： 12345$ git merge devUpdating d17efd8..fec145aFast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： 12$ git branch -d devDeleted branch dev (was fec145a). 12$ git branch* master 小结Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch dev 切换分支：git checkout 创建+切换分支：git checkout -b 合并某分支到当前分支：git merge 删除分支：git branch -d 解决冲突人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： 12$ git checkout -b feature1Switched to a new branch 'feature1' 1Creating a new branch is quick AND simple. 1234$ git add readme.txt $ git commit -m \"AND simple\"[feature1 75a857c] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 123$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 1 commit. 在master分支上把readme.txt文件的最后一行改为： 1Creating a new branch is quick &amp; simple. 1234$ git add readme.txt $ git commit -m \"&amp; simple\"[master 400b400] &amp; simple 1 file changed, 1 insertion(+), 1 deletion(-) 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： 1234$ git merge feature1Auto-merging readme.txtCONFLICT (content): Merge conflict in readme.txtAutomatic merge failed; fix conflicts and then commit the result. 12345678910$ git status# On branch master# Your branch is ahead of 'origin/master' by 2 commits.## Unmerged paths:# (use \"git add/rm ...\" as appropriate to mark resolution)## both modified: readme.txt#no changes added to commit (use \"git add\" and/or \"git commit -a\") 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADCreating a new branch is quick &amp; simple.=======Creating a new branch is quick AND simple.&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1 1Creating a new branch is quick and simple. 123$ git add readme.txt $ git commit -m \"conflict fixed\"[master 59bc1cb] conflict fixed 用带参数的git log也可以看到分支的合并情况： 12345678$ git log --graph --pretty=oneline --abbrev-commit* 59bc1cb conflict fixed|\\| * 75a857c AND simple* | 400b400 &amp; simple|/* fec145a branch test... 12$ git branch -d feature1Deleted branch feature1 (was 75a857c). 小结当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 用git log –graph命令可以看到分支合并图。 分支管理策略合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 bug分支软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它，但是，等等，当前正在dev上进行的工作还没有提交： 12345678910111213$ git status# On branch dev# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)## new file: hello.py## Changes not staged for commit:# (use \"git add ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## modified: readme.txt# 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： 123$ git stashSaved working directory and index state WIP on dev: 6224937 add mergeHEAD is now at 6224937 add merge 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： 12345$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 6 commits.$ git checkout -b issue-101Switched to a new branch 'issue-101' 1234$ git add readme.txt $ git commit -m \"fix bug 101\"[issue-101 cc17032] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 123456789$ git checkout masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 2 commits.$ git merge --no-ff -m \"merged bug fix 101\" issue-101Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-)$ git branch -d issue-101Deleted branch issue-101 (was cc17032). 12345$ git checkout devSwitched to branch 'dev'$ git status# On branch devnothing to commit (working directory clean) 12$ git stash liststash@&#123;0&#125;: WIP on dev: 6224937 add merge 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： 1234567891011121314$ git stash pop# On branch dev# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)## new file: hello.py## Changes not staged for commit:# (use \"git add ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## modified: readme.txt#Dropped refs/stash@&#123;0&#125; (f624f8e5f082f2df2bed8a4e09c12fd2943bdd40) 1$ git stash list 1$ git stash apply stash@&#123;0&#125; 小结修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。 feature 分支开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 多人协作当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： 12$ git remoteorigin 123$ git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 推送分支推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： 1$ git push origin master 1$ git push origin dev master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 抓取分支多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： 1234567$ git clone git@github.com:michaelliao/learngit.gitCloning into 'learngit'...remote: Counting objects: 46, done.remote: Compressing objects: 100% (26/26), done.remote: Total 46 (delta 16), reused 45 (delta 15)Receiving objects: 100% (46/46), 15.69 KiB | 6 KiB/s, done.Resolving deltas: 100% (16/16), done. 12$ git branch* master 1$ git checkout -b dev origin/dev 1234567891011$ git commit -m \"add /usr/bin/env\"[dev 291bea8] add /usr/bin/env 1 file changed, 1 insertion(+)$ git push origin devCounting objects: 5, done.Delta compression using up to 4 threads.Compressing objects: 100% (2/2), done.Writing objects: 100% (3/3), 349 bytes, done.Total 3 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git fc38031..291bea8 dev -&gt; dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： 123456789101112$ git add hello.py $ git commit -m \"add coding: utf-8\"[dev bd6ae48] add coding: utf-8 1 file changed, 1 insertion(+)$ git push origin devTo git@github.com:michaelliao/learngit.git ! [rejected] dev -&gt; dev (non-fast-forward)error: failed to push some refs to 'git@github.com:michaelliao/learngit.git'hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Merge the remote changes (e.g. 'git pull')hint: before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 12345678910111213141516$ git pullremote: Counting objects: 5, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From github.com:michaelliao/learngit fc38031..291bea8 dev -&gt; origin/devThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull If you wish to set tracking information for this branch you can do so with: git branch --set-upstream dev origin/ 12$ git branch --set-upstream dev origin/devBranch dev set up to track remote branch dev from origin. 1234$ git pullAuto-merging hello.pyCONFLICT (content): Merge conflict in hello.pyAutomatic merge failed; fix conflicts and then commit the result. 12345678910$ git commit -m \"merge &amp; fix hello.py\"[dev adca45d] merge &amp; fix hello.py$ git push origin devCounting objects: 10, done.Delta compression using up to 4 threads.Compressing objects: 100% (5/5), done.Writing objects: 100% (6/6), 747 bytes, done.Total 6 (delta 0), reused 0 (delta 0)To git@github.com:michaelliao/learngit.git 291bea8..adca45d dev -&gt; dev 因此，多人协作的工作模式通常是这样： 首先，可以试图用git push origin branch-name推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin branch-name推送就能成功！ 如果git pull提示“no tracking information”，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream branch-name origin/branch-name。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 创建标签在Git中打标签非常简单，首先，切换到需要打标签的分支上： 12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 1$ git tag v1.0 12$ git tagv1.0 方法是找到历史提交的commit id，然后打上就可以了： 1234567891011$ git log --pretty=oneline --abbrev-commit6a5819e merged bug fix 101cc17032 fix bug 1017825a50 merge with no-ff6224937 add merge59bc1cb conflict fixed400b400 &amp; simple75a857c AND simplefec145a branch testd17efd8 remove test.txt... 1$ git tag v0.9 6224937 123$ git tagv0.9v1.0 1234567$ git show v0.9commit 622493706ab447b6bb37e4e2a2f276a20fed2ab4Author: Michael Liao Date: Thu Aug 22 11:22:08 2013 +0800 add merge... 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： 1$ git tag -a v0.1 -m \"version 0.1 released\" 3628164 123456789101112$ git show v0.1tag v0.1Tagger: Michael Liao Date: Mon Aug 26 07:28:11 2013 +0800version 0.1 releasedcommit 3628164fb26d48395383f8f31179f24e0882e1e0Author: Michael Liao Date: Tue Aug 20 15:11:49 2013 +0800 append GPL 1$ git tag -s v0.2 -m \"signed version 0.2 released\" fec145a 123gpg: signing failed: secret key not availableerror: gpg failed to sign the dataerror: unable to sign the tag 用命令git show 可以看到PGP签名信息： 1234567891011121314151617$ git show v0.2tag v0.2Tagger: Michael Liao Date: Mon Aug 26 07:28:33 2013 +0800signed version 0.2 released-----BEGIN PGP SIGNATURE-----Version: GnuPG v1.4.12 (Darwin)iQEcBAABAgAGBQJSGpMhAAoJEPUxHyDAhBpT4QQIAKeHfR3bo...-----END PGP SIGNATURE-----commit fec145accd63cdc9ed95a2f557ea0658a2a6537fAuthor: Michael Liao Date: Thu Aug 22 10:37:30 2013 +0800 branch test 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； git tag -a -m “blablabla…”可以指定标签信息； git tag -s -m “blablabla…”可以用PGP签名标签； 命令git tag可以查看所有标签。 标签操作 命令git push origin 可以推送一个本地标签； 命令git push origin –tags可以推送全部未推送过的本地标签； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/工具/git/"},{"name":"git详细记录","slug":"工具/git/git详细记录","permalink":"http://yoursite.com/categories/工具/git/git详细记录/"}]},{"title":"Git仓库(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git仓库/","text":"本文全部复制Git教程,自己已经理解的内容只是简单复制总结部分，没有理解的就全部粘贴，方便以后进一步学习、理解。 添加远程库要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 克隆远程仓库1git clone git@github.com:michaelliao/gitskills.git 使用码云使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。 如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——[码云](https://gitee.com/）。 和GitHub相比，码云也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，码云还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。 码云的免费版本也提供私有库功能，只是有5人的成员上限。 使用码云和使用GitHub类似，我们在码云上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -&gt; 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去： 点击“确定”即可完成并看到刚才添加的Key： 如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到码云的远程库上呢？ 首先，我们在码云上创建一个新的项目，选择右上角用户头像 -&gt; 菜单“控制面板”，然后点击“创建项目”： 项目名称最好与本地库保持一致： 然后，我们在本地库上使用命令git remote add把它和码云的远程库关联： 1git remote add origin git@gitee.com:liaoxuefeng/learngit.git 小提示 ： origin 远程仓库也就是url对应的仓库 在本地的别名。 如果在使用命令git remote add时报错： 12git remote add origin git@gitee.com:liaoxuefeng/learngit.gitfatal: remote origin already exists. 123git remote -vorigin git@github.com:michaelliao/learngit.git (fetch)origin git@github.com:michaelliao/learngit.git (push) 我们可以删除已有的GitHub远程库： 1git remote rm origin 1git remote add origin git@gitee.com:liaoxuefeng/learngit.git 123git remote -vorigin git@gitee.com:liaoxuefeng/learngit.git (fetch)origin git@gitee.com:liaoxuefeng/learngit.git (push) 有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联码云呢？ 答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库： 1git remote rm origin 1git remote add github git@github.com:michaelliao/learngit.git 接着，再关联码云的远程库： 1git remote add gitee git@gitee.com:liaoxuefeng/learngit.git 现在，我们用git remote -v查看远程库信息，可以看到两个远程库： 12345git remote -vgitee git@gitee.com:liaoxuefeng/learngit.git (fetch)gitee git@gitee.com:liaoxuefeng/learngit.git (push)github git@github.com:michaelliao/learngit.git (fetch)github git@github.com:michaelliao/learngit.git (push) 1git push github master 1git push gitee master 码云也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。 小贴士 ：git fetch 和git pull的区别 fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支 pull 若某个分支用于跟踪某个远端仓库的分支，可以使用 git pull 命令自动抓取数据下来，然后将远端分支自动合并到本地仓库中当前分支 参考 Git-基础-远程仓库的使用","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/工具/git/"},{"name":"git详细记录","slug":"工具/git/git详细记录","permalink":"http://yoursite.com/categories/工具/git/git详细记录/"}]},{"title":"git时光穿梭(转载)","date":"2018-02-12T04:18:26.000Z","path":"wiki/工具/git/git详细记录/git工作区/","text":"本文全部复制Git教程,自己理解的就简单复制，没有理解的就全部粘贴。 git 配置12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的–global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 创建版本库初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令git commit，完成。 工作区的状态 要随时掌握工作区的状态，使用git status命令。 如果git status告诉你有文件被修改过，用git diff可以查看修改内容。 版本回退Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD指向append GPL： 改为指向add distributed： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 工作区和暂存区Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 工作区（Working Directory）就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 版本库（Repository）工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 先用git status查看一下状态： 12345678910111213$ git status# On branch master# Changes not staged for commit:# (use \"git add &lt;file&gt;...\" to update what will be committed)# (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)## modified: readme.txt## Untracked files:# (use \"git add &lt;file&gt;...\" to include in what will be committed)## LICENSEno changes added to commit (use \"git add\" and/or \"git commit -a\") 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： 12345678$ git status# On branch master# Changes to be committed:# (use \"git reset HEAD &lt;file&gt;...\" to unstage)## new file: LICENSE# modified: readme.txt# 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 1234$ git commit -m \"understand how stage works\"[master 27c9860] understand how stage works 2 files changed, 675 insertions(+) create mode 100644 LICENSE 123$ git status# On branch masternothing to commit (working directory clean) 小结暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 管理修改现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 12345678$ git add readme.txt$ git status# On branch master# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)## modified: readme.txt# 12345$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 123$ git commit -m \"git tracks changes\"[master d4f25b6] git tracks changes 1 file changed, 1 insertion(+) 123456789$ git status# On branch master# Changes not staged for commit:# (use \"git add ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## modified: readme.txt#no changes added to commit (use \"git add\" and/or \"git commit -a\") 别激动，我们回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD – readme.txt命令可以查看工作区和版本库里面最新版本的区别： 1234567891011$ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txtindex 76d770f..a9c5755 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git add -&gt; git commit 好，现在，把第二次修改提交了，然后开始小结。 小结现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。 撤销修改自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 123456$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789$ git status# On branch master# Changes not staged for commit:# (use \"git add ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## modified: readme.txt#no changes added to commit (use \"git add\" and/or \"git commit -a\") 1$ git checkout -- readme.txt 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： 12345$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： 12345678$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ git add readme.txt 1234567$ git status# On branch master# Changes to be committed:# (use \"git reset HEAD ...\" to unstage)## modified: readme.txt# 123$ git reset HEAD readme.txtUnstaged changes after reset:M readme.txt 再用git status查看一下，现在暂存区是干净的，工作区有修改： 123456789$ git status# On branch master# Changes not staged for commit:# (use \"git add ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## modified: readme.txt#no changes added to commit (use \"git add\" and/or \"git commit -a\") 12345$ git checkout -- readme.txt$ git status# On branch masternothing to commit (working directory clean) 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得[版本回退][1]一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把“stupid boss”提交推送到远程版本库，你就真的惨了…… 小结又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout – file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考[版本回退][2]一节，不过前提是没有推送到远程库。 删除文件在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： 12345$ git add test.txt$ git commit -m \"add test.txt\"[master 94cdc44] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 1$ rm test.txt 123456789$ git status# On branch master# Changes not staged for commit:# (use \"git add/rm ...\" to update what will be committed)# (use \"git checkout -- ...\" to discard changes in working directory)## deleted: test.txt#no changes added to commit (use \"git add\" and/or \"git commit -a\") 123456$ git rm test.txtrm 'test.txt'$ git commit -m \"remove test.txt\"[master d17efd8] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- test.txt 小结命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。","tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/工具/git/"},{"name":"git详细记录","slug":"工具/git/git详细记录","permalink":"http://yoursite.com/categories/工具/git/git详细记录/"}]},{"title":"hexo使用指南","date":"2018-02-07T07:57:29.000Z","path":"wiki/工具/hexo/hexo-use/","text":"使用hexo一年多时间了，今天将使用hexo使用过程做个记录 。备注（搭建平台是MAC） 常用命令123hexo n #写文章hexo g #生成hexo d #部署 # 可与hexo g合并为 hexo d -g 环境搭建 安装Node.js 安装git（Xcode自带） 安装hexo hexo 是基于Node.js的静态博客程序，使用npm 安装： 1npm install -g hexo GitHub 首先注册一个『GitHub』帐号 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 说明 git使用两种协议传输：https、git，如我的blog 的两种协议git地址如下： git@github.com:jianli2017/jianli2017.github.io.githttps://github.com/jianli2017/jianli2017.github.io.git SSH 作用于git协议，使用SSH 后，git协议的push、pull操作不需要输入密码。 初始化使用hexo init 命令在当前目录下初始化一个hexo项目 生成静态页面cd 到你的init目录，执行如下命令，生成静态页面到 ./public/目录。 1hexo generate 本地启动执行如下命令，启动本地服务，进行文章预览调试。 1hexo server 写文章执行new命令，生成指定名称的文章至hexo/source/_posts/postName.md。 1hexo new [lay“out] \"postName\" #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md 123title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: 请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下： 1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories: tags: postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 注意，所有文件：后面都必须有个空格，不然会报错。 看一下刚才生成的文件hexo/source/_posts/postName.md，内容如下： 1234title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: #文章分类目录，可以为空，注意:后面有个空格tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格 fancybox可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片： 1234567layout: phototitle: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos:- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 经过测试，文件头上的layout: photo可以省略。 不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md 12345layout: &#123; &#123; layout &#125; &#125;title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags: photos: 然后每次可以执行带layout的new命令生成照片文章： 1hexo new photo \"photoPostName\" #新建照片文章 descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。 12345title: hexo你的博客date: 2013-11-22 17:11:54categories: defaulttags: [hexo]description: 你对本页的描述 hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。 文章摘要在需要显示摘要的地方添加如下代码即可： 123以上是摘要&lt;!--more--&gt;以下是余下全文 more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 hexo中所有文件的编码格式均是UTF-8。 主题安装安装主题的方法就是一句git命令： 1git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 目录是否是modernist无所谓，只要与_config.yml文件一致即可。 安装完成后，打开hexo/_config.yml，修改主题为modernist 1theme: modernist 打开hexo/themes/modernist目录，编辑主题配置文件_config.yml： 1234567891011121314151617181920212223menu: #配置页头显示哪些菜单# Home: / Archives: /archives Reading: /reading About: /about# Guestbook: /aboutexcerpt_link: Read More #摘要链接文字archive_yearly: false #按年存档widgets: #配置页脚显示哪些小挂件 - category# - tag - tagcloud - recent_posts# - blogrollblogrolls: #友情链接 - bruce sha's duapp wordpress: http://ibruce.duapp.com - bruce sha's javaeye: http://buru.iteye.com - bruce sha's oschina blog: http://my.oschina.net/buru - bruce sha's baidu space: http://hi.baidu.com/iburufancybox: true #是否开启fancybox效果duoshuo_shortname: buru #多说账号google_analytics:rss: #更新 更新hexo： 1npm update -g hexo 参考 hexo你的博客 Hexo静态博客搭建+个人定制 hexo搭建的Github博客绑定域名 初次安装git配置用户名和邮箱","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"hexo","slug":"工具/hexo","permalink":"http://yoursite.com/categories/工具/hexo/"}]},{"title":"通用webview开发记录","date":"2018-02-04T04:07:12.000Z","path":"wiki/Hybird/webview/WKWebview/","text":"为什么做通用webView 通用webView与混合式app的联系 WKWebview介绍 通用webView与JS交互形式 现有webView支持那些JS交互 插件的扩展方法 webview中遇到的问题 调试Webview的JS代码方法 参考 1、为什么做通用webView 两套webview代码：维护复杂、两者交互难。比如：使用在线模板加载美信页面就会遇到问题。 JS交互不统一：美信模板普遍使用URL方式于Native交互，在线模板主要使用JSBridge交互，并且不同模块的Bridge也有一定的区别，不是统一的。 为了解决上面问题，就需要融合两套webview，并使用统一的JS交互机制，JS交互机制最后使用的是现有混合app的js交互机制–cordova，同时为了提高性能，统一将UIwebview替换为WKWebview。 所以主要工作有两部分： 使用wkwebview构建新的综合模板 重新规划、开发混合app和Webview的插件 2、通用webView与混合式app的联系混合app和webview有非常相似的功能，但也有一定的区别，下图的目的是说明它俩的关系： 图1 混合app和通用webview都是使用WKWebview容器渲染html页面，并使用统一的JS交互机制于Native交互。唯一不同点是：混合app启动的时候将远端的html文件以插件或组件的形式下载到本地，当渲染混合app的时候，根据插件信息，查找本地的html文件，并加载。而通用webview直接使用URL加载部署在远端服务器上的html文件。所以混合app的体验、性能都优于通用webview。 3、WKWebview 介绍iOS8之后苹果推荐使用WKWebView替代UIWebView，其主要的有点有： WKWebView更多的支持HTML5的特性 WKWebView更快，占用内存可能只有UIWebView的1/3 ~ 1/4 WKWebView高达60fps的滚动刷新率和丰富的内置手势 WKWebView具有Safari相同的JavaScript引擎 WKWebView增加了加载进度属性 将UIWebViewDelegate和UIWebView重构成了14个类与3个协议 3.1 创建WKWebviewWKWebview既可以使用alloc、init方法创建，也可以使用自己的方法创建，下面是创建WKWebview的实例代码： 1234567WKUserContentController* userContentController = [[WKUserContentController alloc] init];[userContentController addScriptMessageHandler:self name:CDV_BRIDGE_NAME]; WKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];configuration.userContentController = userContentController; WKWebView* wkWebView = [[WKWebView alloc] initWithFrame:frame configuration:configuration]; 3.2 WKWebview加载页面123456789101112131415161718WKWebView *webView =self.webViewEngine.engineWebView;strUrl = [strUrl stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding];NSURL *url = [NSURL URLWithString:GMK_Str_Protect(strUrl)];if (nil == url)&#123; [self notFoundHtml]; return;&#125;NSMutableURLRequest* appReq = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:20.0];if (nil == appReq)&#123; [self notFoundHtml]; return;&#125; [self.webViewEngine loadRequest:appReq]; 3.3 WKWebview代理WKWebView有两个代理,WKUIDelegate 和 WKNavigationDelegate。WKNavigationDelegate主要处理一些跳转、加载处理操作；WKUIDelegate主要处理UI相关的操作：确认框，警告框，提示框。因此WKNavigationDelegate更加常用。下面是WKNavigationDelegate的代理列表： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950///二、页面是否加载 ，相当于shouldStartLoadWithRequest- (void) webView: (WKWebView *) webView decidePolicyForNavigationAction: (WKNavigationAction*) navigationAction decisionHandler: (void (^)(WKNavigationActionPolicy)) decisionHandler&#123; //允许跳转 decisionHandler(WKNavigationResponsePolicyAllow); //不允许跳转 //decisionHandler(WKNavigationResponsePolicyCancel);&#125; ///三、页面开始加载- (void)webView:(WKWebView*)webView didStartProvisionalNavigation:(WKNavigation*)navigation&#123; &#125;///四、收到响应- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123; //允许跳转 decisionHandler(WKNavigationResponsePolicyAllow); //不允许跳转 //decisionHandler(WKNavigationResponsePolicyCancel);&#125;///五、收到数据- (void)webView:(WKWebView *)webView didCommitNavigation:(WKNavigation *)navigation &#123; &#125;///六、页面加载完成- (void)webView:(WKWebView*)webView didFinishNavigation:(WKNavigation*)navigation&#123;&#125;///七、页面加载失败- (void)webView:(WKWebView*)theWebView didFailNavigation:(WKNavigation*)navigation withError:(NSError*)error&#123; &#125;/// 八、跳转失败- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error&#123; &#125;/// 九、重定向- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation&#123;&#125; ///十、这个目的解决白屏问题 （ios9以上）- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0))&#123; [self loadRequestWithUrl:self.strCurrentURL];&#125; WKUIDelegate有下面三个代理： 123456789101112131415- (void) webView:(WKWebView*)webView runJavaScriptAlertPanelWithMessage:(NSString*)message initiatedByFrame:(WKFrameInfo*)frame completionHandler:(void (^)(void))completionHandler - (void) webView:(WKWebView*)webView runJavaScriptConfirmPanelWithMessage:(NSString*)message initiatedByFrame:(WKFrameInfo*)frame completionHandler:(void (^)(BOOL result))completionHandler - (void) webView:(WKWebView*)webView runJavaScriptTextInputPanelWithPrompt:(NSString*)prompt defaultText:(NSString*)defaultText initiatedByFrame:(WKFrameInfo*)frame completionHandler:(void (^)(NSString* result))completionHandler 3.3 WKUserContentControllerA WKUserContentController object provides a way for JavaScript to post messages to a web view. WKUserContentController 对象为JavaSript提供了向webview发送消息的方式。 The user content controller associated with a web view is specified by its web view configuration. WKUserContentController 通过WKWebViewConfiguration 关联到webview。 下面的代码是创建WKUserContentController，并关联到WKWebview的代码： 1234567///创建WKUserContentControllerWKUserContentController* userContentController = [[WKUserContentController alloc] init];[userContentController addScriptMessageHandler:self name:CDV_BRIDGE_NAME]; ///关联到webviewWKWebViewConfiguration* configuration = [[WKWebViewConfiguration alloc] init];configuration.userContentController = userContentController 关联以后，JS就可以通过下面的代码向WKWebview发送消息。 1window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) WKWebview接收到JS的消息后，会触发WKScriptMessageHandler协议的userContentController：didReceiveScriptMessage:方法： 12345678910- (void)userContentController:(WKUserContentController*)userContentController didReceiveScriptMessage:(WKScriptMessage*)message&#123; if (![message.name isEqualToString:CDV_BRIDGE_NAME]) &#123; return; &#125; CDVViewController* vc = (CDVViewController*)self.viewController; NSArray* jsonEntry = message.body; // NSString:callbackId, NSString:service, NSString:action, NSArray:args&#125; 在这个方法中就可以根据消息的内容，调用Native的功能。 3.4 动态注入JSWKWebview支持将JS预先注入到Webview中，可以定制带document加载前或者后执行注入的JS。注入JS是将WKUserScript关联的webview的configuration中，代码示例如下。 1234567891011WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:mstrCookieInfo injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];if (GMK_Ary_Is_Valid(webView.configuration.userContentController.userScripts))&#123; [webView.configuration.userContentController removeAllUserScripts];&#125;if (script)&#123; [webView.configuration.userContentController addUserScript:script];&#125; 4、通用webView与JS交互下图是cordova中JS和Native的交互机制 下面是 cordova源码的结构 下面是 cordova初始化webview的流程 5、现有webView支持那些JS交互在开发通用webview的时候，统一规划了插件。规划后插件列表省略。 6、插件的扩展方法如果现有的插件不能满足新的需求，需要扩展新的插件，扩展方法如下： 首先确定插件的别名，这个名字需要三端一样，然后确定插件的类名（这个按照代码规范命名就可以）。 将插件别名和插件类名的对应关系添加到cordova的配置文件config.xml中。 创建插件类，这个类必须继承于CDVPlugin类； 定义插件方法，插件方法需要三端统一。方法的格式就是： 1-(void)&lt;methodName&gt;:(CDVInvokedUrlCommand *)command； 实现方法，实现插件方法分3部分：解析参数判断、完成Native的功能、将结果回调给JS； 参数解析： CDVInvokedUrlCommand 类是对JS传递过来参数的封装，我们从arguments属性中获取参数，CDVInvokedUrlCommand的属性定义如下： 1234@property (nonatomic, readonly) NSArray* arguments;@property (nonatomic, readonly) NSString* callbackId;@property (nonatomic, readonly) NSString* className;@property (nonatomic, readonly) NSString* methodName; 回调结果： 回调的数据格式需要预先定义好，然后使用下面的代码将数据回调给JS： 1234NSDictionary *dic = @&#123;@\"isSuccess\":@\"Y\"&#125;;CDVPluginResult * result=[CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsDictionary:dic];[self.commandDelegate sendPluginResult:result callbackId:command.callbackId]; 7、webview中遇到的问题 _blank 问题： a便签中如果有_blank属性，表示在新的窗口打开页面，但是我们打不开，解决办法是添加如下代理的实现，直接在当前窗口加载url 1234567-(WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures&#123; if (!navigationAction.targetFrame.isMainFrame) &#123; [webView loadRequest:navigationAction.request]; &#125; return nil;&#125; cookie问题、白屏问题 这个问题都是参考 WKWebView 那些坑解决的，都有不错的解决方法 NSURLErrorCancelled 问题。 webview如果上一个请求没有完成，立即操作界面，触发新的网络请求，wk代理会收到错误，错误码是NSURLErrorCancelled，这个时候不应该展示错误页面，需要直接return。 webview出现错误页面诊断方法 首先找到CordovaVC的WK失败代理： 12webView: didFailNavigation: withError:webView:didFailProvisionalNavigation: withError: 然后打印出错误原因 根据NSError中的错误码分析错误的原因，解决问题。 下面是我遇到的几个记录下来的错误码，通过分析，大部分能明白错误的原因： 12Error Domain=WebKitErrorDomain Code=102 \"Frame load interrupted\" UserInfo=&#123;_WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x60000062fa80&gt;, NSErrorFailingURLStringKey=https://login.m.gomeplus.com/login.html?return_url=Ly9jYXNoaWVyLm0uZ29tZXBsdXMuY29tL3ZvdWNoZXJfbGlzdC0wLmh0bWw=, NSErrorFailingURLKey=https://login.m.gomeplus.com/login.html?return_url=Ly9jYXNoaWVyLm0uZ29tZXBsdXMuY29tL3ZvdWNoZXJfbGlzdC0wLmh0bWw=, NSLocalizedDescription=Frame load interrupted&#125; 这个是加载中访问了https://login.m.gomeplus.com/login.html url，打断了加载。 1Error Domain=NSURLErrorDomain Code=-1002 \"unsupported URL\" UserInfo=&#123;_WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x608000233ae0&gt;, NSErrorFailingURLStringKey=itms-appss://itunes.apple.com/cn/app/guo-mei-zai-xian/id486744917?mt=8, NSErrorFailingURLKey=itms-appss://itunes.apple.com/cn/app/guo-mei-zai-xian/id486744917?mt=8, NSLocalizedDescription=unsupported URL, NSUnderlyingError=0x604000653440 &#123;Error Domain=kCFErrorDomainCFNetwork Code=-1002 \"(null)”&#125;&#125; 这个是JS中访问了不支持的scheme,itms-appss 1234Error Domain=NSURLErrorDomain Code=-1202 \"The certificate for this server is invalid. You might be connecting to a server that is pretending to be “m.gomeholdings.com” which could put your confidential information at risk.\" UserInfo=&#123;NSURLErrorFailingURLPeerTrustErrorKey=&lt;SecTrustRef: 0x600000301200&gt;, NSLocalizedRecoverySuggestion=Would you like to connect to the server anyway?, NSErrorFailingURLStringKey=https://m.gomeholdings.com/content/2017042516183080569_.html, NSErrorFailingURLKey=https://m.gomeholdings.com/content/2017042516183080569_.html, NSErrorPeerCertificateChainKey=( \"&lt;cert(0x7fef30f1fc40) s: *.gomeholdings.com i: Charles Proxy CA (3 \\U516b\\U6708 2016, bogon)&gt;\", \"&lt;cert(0x7fef30f12390) s: Charles Proxy CA (3 \\U516b\\U6708 2016, bogon) i: Charles Proxy CA (3 \\U516b\\U6708 2016, bogon)&gt;\"), NSErrorClientCertificateStateKey=0, NSLocalizedDescription=The certificate for this server is invalid. You might be connecting to a server that is pretending to be “m.gomeholdings.com” which could put your confidential information at risk., _WKRecoveryAttempterErrorKey=&lt;WKReloadFrameErrorRecoveryAttempter: 0x600000829e60&gt;, _kCFStreamErrorDomainKey=3, NSUnderlyingError=0x600000a52f90 &#123;Error Domain=kCFErrorDomainCFNetwork Code=-1202 \"(null)\" UserInfo=&#123;_kCFStreamPropertySSLClientCertificateState=0, _kCFNetworkCFStreamSSLErrorOriginalValue=-9813, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9813&#125;&#125;, _kCFStreamErrorCodeKey=-9813&#125; 这个是认证服务器证书失败。 8、调试Webview的JS代码方法在项目的过程中，有时会遇到webview刷新不出界面的现象，这时，就需要调试html页面，查找问题，进而判断是否是咱们的问题。调试使用safari自带的功能就可以完成。具体步骤： 打开safari开发模式。在safari菜单栏，选择safari、偏好设置、高级，在最下面将 “在菜单中显示开发菜单” 选中。 链接到webview界面。选择开发、Simulator、 对应的页面，打开调试器。 调试代码，查找错误，判断是否是JS的错误 9、参考 IOS进阶之WKWebView iOS 给webView加进度条(WKWebView) WKWebView 那些坑 WKWebView强大的新特性","tags":[{"name":"webview","slug":"webview","permalink":"http://yoursite.com/tags/webview/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"webview","slug":"Hybird/webview","permalink":"http://yoursite.com/categories/Hybird/webview/"}]},{"title":"","date":"2017-11-09T03:26:08.000Z","path":"wiki/Hybird/weex/桌面移动过来的资料/weex 文档/国美weex使用教程/","text":"Gome weex 使用教程 1. 搭建Weex环境1.1安装Node.jsweex 需要依赖Node.js 和 Weex CLi，首先需要安装Node.js ，可以使用 Homebrew 进行安装： brew install node 安装完Node.js 安装 weex-toolkit npm install -g weex-toolkit weex -v //查看当前weex版本 1.2 集成到项目通过cocoaPods 集成 Weex iOS SDK到你的项目，在Podfile文件中添加： pod &apos;WeexSDK&apos;, &apos;0.9.5&apos; ## 建议使用WeexSDK新版本 2. Gome weex 使用方法GWeex分为两个流程: 初始化 加载Gweex页面每个流程 暴露一个API。，分别是initWeexEnvironment、loadWeexPageResourceForUrl。 2.1 GWeex 初始化-(void) initWeex { //初始化SDK环境,最新版本的方法名改为：initSDKEnviroment [WXSDKEngine initSDKEnvironment]; //registerModule是注册模块，如果没有，你点击weex的渲染的view中的按钮将找不到事件。 [WXSDKEngine registerModule:@&quot;event&quot; withClass:[WXEventModule class]]; ////PageManagerModule [WXSDKEngine registerModule:@&quot;PageManagerModule&quot; withClass:[GWXSchemeModule class]]; //注册Handler [WXSDKEngine registerHandler:[WXImageDownloader new] withProtocol:@protocol(WXImgLoaderProtocol)]; ///初始化国美weex GWXEngine *wxEngine = [GWXEngine shareInstance]; [wxEngine initWeexEnvironment]; } 初始化 过程包含两个任务： 初始化weex ，初始化GWXEngine。 2.2加载Gome weex页面加载weex页面，就是将给定的URL 使用weex渲染出来。加载的代码如下： GWXEngine *wxEngine = [GWXEngine shareInstance]; [wxEngine loadWeexPageResourceForUrl:GWX_URL finishBlock:^(NSString *strWeexUrl) { if ([strWeexUrl hasPrefix:@&quot;http&quot;]) { jumpToScheme(self, strWeexUrl); } else { GMFWeexVC *weexVC = [GMFWeexVC new]; weexVC.url = strWeexUrl; [self.navigationController pushViewController:weexVC animated:YES]; } }]; 如果给定的URL能在本地插件表中找到 ，会被使用weex渲染 ，否则会调转到对应的H5页面 。 3. 内部初始化原理Gome Weex内部实现按照功能分，分为两部分，初始化（包括初始化清单流程、下载插件流程）、加载weex页面。下面分析初始化流程。初始化的流程下图（图1） 3.1 初始化清单流程图1 初始化流程一般在App启动的时候触发，初始化有四个状态、分别是未初始化、初始化中、初始化OK、初始化失败。使用状态控制的目的是防止多次初始化功能 ，只有初始化失败，才可以再次初始化，如果初始化成功，不能再次初始化。 第一步：当进入初始化流程，首先读取weex/info目录下的weexConfig.plist配置信息到内存 。weexConfig.plist存储着本地多有可用插件的信息。以key value的形式存储。key：是插件ID__版本，value：是插件的信息 。包括 插件下载地址、host、 插件下所有的页面Etag、插件版本、插件支持的SDK版本。如下图所示 第二步：请求插件清单接口，获取服务器的插件列表。如果请求OK，进入第三步，否则进入第五步。 第三步：根据服务器返回的插件列表和本地已有的插件列表 计算出需要新下载的插件列表，添加到下载列表中 。如果 第四步： 启动下载流程 第五步：如果前面的流程没有出错，将初始化状态设置为OK ，否则设置为失败。 3.2 下载插件流程下载流程是在初始化清单接口完成后，自动触发的 。也包含在初始化流程中。 下载多个插件是使用operation queue管理的，每个插件抽象为一个operation， 然后将所有的operation添加到下载队列中，下载队列管理所有的插件下载 ，并且，队列中同时只有两个插件下载 ，这样防止内存的峰值太高 。队列中的每个插件operation 执行完成后，回调给GWXEngine，这样 GWXEngine会根据下载的结果，做对应的处理 ，下载成功，添加到本地插件列表中，下载失败，添加到失败列表中。在失败列表中的插件在加载weex也的时候会触发重新下载 。 operation queque管理插件下载的示意图 ： 每个插件的下载任务流程如下图所示： 主要分为以下几个过程： 启动插件下载网络请求 。 如果请求状态为200 ，插件的zip会保存到download目录下 。 解压插件zip到unzip目录 根据解压出来的文件，构架插件的信息。插件包下的所有页面的ETag值 （文件的修改时间+文件长度） 将解压出来的插件复制到plugins目录的对应版本下面 。 如果复制成功 ，将插件的信息保存在本地配置文件weexConfig.plist中，同时保存到内存中 。，同时将整个下载任务状态置为成功 如果上面的任何一步失败，都将下载任务状态置为失败。 其中这个过程设计到插件不同状态在不同文件夹下流转的过程如下： 3.3 加载weex 页面流程加载页面的流程如下图所示 ： 完了 。 回头慢慢优化啊 。","tags":[],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"},{"name":"桌面移动过来的资料","slug":"Hybird/weex/桌面移动过来的资料","permalink":"http://yoursite.com/categories/Hybird/weex/桌面移动过来的资料/"},{"name":"weex 文档","slug":"Hybird/weex/桌面移动过来的资料/weex-文档","permalink":"http://yoursite.com/categories/Hybird/weex/桌面移动过来的资料/weex-文档/"}]},{"title":"dispatch_semaphore 的使用方法","date":"2017-02-11T07:35:49.000Z","path":"wiki/IOS/多线程/use-dispatch-semaphore/","text":"转载请注明出处 关于dispatch_semaphore的使用。dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create、dispatch_semaphore_signal、dispatch_semaphore_wait。 下面我们逐一介绍三个函数： dispatch_semaphore_createdispatch_semaphore_create的声明为： 1dispatch_semaphore_t dispatch_semaphore_create(long value); 传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。 dispatch_semaphore_signaldispatch_semaphore_signal的声明为： 1long dispatch_semaphore_signal(dispatch_semaphore_t dsema) 这个函数会使传入的信号量dsema的值加1； dispatch_semaphore_waitdispatch_semaphore_wait的声明为： 1long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)； 这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。 返回值dispatch_semaphore_signal的返回值为long类型，当返回值为0时表示当前并没有线程等待其处理的信号量，其处理的信号量的值加1即可。当返回值不为0时，表示其当前有（一个或多个）线程等待其处理的信号量，并且该函数唤醒了一个等待的线程（当线程有优先级时，唤醒优先级最高的线程；否则随机唤醒）。dispatch_semaphore_wait的返回值也为long型。当其返回0时表示在timeout之前，该函数所处的线程被成功唤醒。当其返回不为0时，表示timeout发生。 宏在设置timeout时，比较有用的两个宏：DISPATCH_TIME_NOW 和 DISPATCH_TIME_FOREVER。 12DISPATCH_TIME_NOW 表示当前；DISPATCH_TIME_FOREVER 表示遥远的未来； 一般可以直接设置timeout为这两个宏其中的一个，或者自己创建一个dispatch_time_t类型的变量。创建dispatch_time_t类型的变量有两种方法，dispatch_time和dispatch_walltime。利用创建dispatch_time创建dispatch_time_t类型变量的时候一般也会用到这两个变量。 dispatch_time的声明如下： 1dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)； 其参数when需传入一个dispatch_time_t类型的变量，和一个delta值。表示when加delta时间就是timeout的时间。例如： 1dispatch_time_t t = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); 表示当前时间向后延时一秒为timeout的时间。 关于信号量，一般可以用停车来比喻。停车场剩余4个车位，那么即使同时来了四辆车也能停的下。如果此时来了五辆车，那么就有一辆需要等待。信号量的值就相当于剩余车位的数目，dispatch_semaphore_wait函数就相当于来了一辆车，dispatch_semaphore_signal就相当于走了一辆车。停车位的剩余数目在初始化的时候就已经指明了（dispatch_semaphore_create（long value）），调用一次dispatch_semaphore_signal，剩余的车位就增加一个；调用一次dispatch_semaphore_wait剩余车位就减少一个；当剩余车位为0时，再来车（即调用dispatch_semaphore_wait）就只能等待。有可能同时有几辆车等待一个停车位。有些车主没有耐心，给自己设定了一段等待时间，这段时间内等不到停车位就走了，如果等到了就开进去停车。而有些车主就像把车停在这，所以就一直等下去。 示例代码举简单示例如下： 12345678910111213141516171819202122232425262728dispatch_semaphore_t signal;signal = dispatch_semaphore_create(1);__block long x = 0;NSLog(@\"0_x:%ld\",x);dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;sleep(1);NSLog(@\"waiting\");x = dispatch_semaphore_signal(signal);NSLog(@\"1_x:%ld\",x);sleep(2);NSLog(@\"waking\");x = dispatch_semaphore_signal(signal);NSLog(@\"2_x:%ld\",x);&#125;);// dispatch_time_t duration = dispatch_time(DISPATCH_TIME_NOW, 1*1000*1000*1000); //超时1秒// dispatch_semaphore_wait(signal, duration);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@\"3_x:%ld\",x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@\"wait 2\");NSLog(@\"4_x:%ld\",x);x = dispatch_semaphore_wait(signal, DISPATCH_TIME_FOREVER);NSLog(@\"wait 3\");NSLog(@\"5_x:%ld\",x); 最终打印的结果为： 123456789102014-08-11 22:51:54.734 LHTest[15700:70b] 0_x:02014-08-11 22:51:54.737 LHTest[15700:70b] 3_x:02014-08-11 22:51:55.738 LHTest[15700:f03] waiting2014-08-11 22:51:55.739 LHTest[15700:70b] wait 22014-08-11 22:51:55.739 LHTest[15700:f03] 1_x:12014-08-11 22:51:55.739 LHTest[15700:70b] 4_x:02014-08-11 22:51:57.741 LHTest[15700:f03] waking2014-08-11 22:51:57.742 LHTest[15700:f03] 2_x:12014-08-11 22:51:57.742 LHTest[15700:70b] wait 32014-08-11 22:51:57.742 LHTest[15700:70b] 5_x:0","tags":[{"name":"dispatch_semaphore GCD","slug":"dispatch-semaphore-GCD","permalink":"http://yoursite.com/tags/dispatch-semaphore-GCD/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"多线程","slug":"IOS/多线程","permalink":"http://yoursite.com/categories/IOS/多线程/"}]},{"title":"搭建weex断点调试环境","date":"2016-12-28T01:48:40.000Z","path":"wiki/Hybird/weex/weex-debug/","text":"Weex Devtools是为 Weex开发者服务的一款调试工具，可对 .we 代码及 JavaScript 代码断点调试，并能够审查 Weex app 运行时属性，支持 iOS 和 Android 两个平台。本文是基于IOS平台。 Weex Devtools 基于 Chrome devtools 实现了 Chrome Debugging Protocol，能够使用Chrome devtools调试 Weex 项目，其主要功能分为两大部分—— Debugger 和 Inspector。若使用Devtools调试weex项目，需要搭建调试环境，包括两部分：安装weex-devtool模块、App项目中集成weex-devtool SDK。 安装weex-devtool 模块weex-devtool是node.js的一个模块，用来启动服务器和Chrome页面，安装weex-devtool需要使用npm安装，由于使用npm安装特别慢，有时候一点速度都没有，这里使用淘宝的镜像源，切换方法： npm install cnpm -g --registry=https://registry.npm.taobao.org 切换完后，使用cnpm安装weex-devtool： cnpm install -g weex-devtool weex-devtool 的用法： weex debug [options] [we_file|bundles_dir] 选项有下面几种： -h, --help 显示帮助 -V, --verbose 显示debug服务器运行时的各种log -v, --version 显示版本 -p, --port [port] 设置debug服务器端口号 默认为8088 -e, --entry [entry] debug一个目录时,这个参数指定整个目录的入口bundle文件,这个bundle文件的地址会显示在debug主页上(作为二维码) -m, --mode [mode] 设置构建we文件的方式,transformer 最基础的风格适合单文件,loader:wepack风格 适合模块化的多文件.默认为transformer 启动服务和chrome页面： weex debug 输出如下： bogon:~ lijian$ weex debug start debugger server at http://10.144.36.206:8088 The websocket address for native is ws://10.144.36.206:8088/debugProxy/native Launching Dev Tools... 输出上面的内容，表示weex-devtool已经并启动。其中ws://10.144.36.206:8088/debugProxy/native是APP连接到Chrome的调试的地址。App集成weex-devtool-iOS后，需要使用这个地址。 APP集成weex-devtool-iOS SDK集成weex-devtool-iOS SDK，可以参考weex-devtool-iOS将 weex-devtool-iOS 集成到项目中。这篇文章中介绍了pod集成方法和源码集成方法。这里假设已经集成完成。直接到使用SDK的步骤。在AppDelegate中添加下面的代码，就可以使APP链接到Chrome的调试环境： #import &lt;WXDevtool.h&gt; [WXDevTool setDebug:YES]; [WXDevTool launchDevToolDebugWithUrl:@&quot;ws://10.144.36.206:8088/debugProxy/native&quot;]; setDebug:参数为YES时，直接开启debug模式，反之关闭。launchDevToolDebugWithUrl 中的url就是在控制台启动Chrome时输出的地址。 调试到目前为止，环境已配置完成，可以体验下调试过程。启动App，App会连接到chrome，Chrome中会显示出连接上的APP，如下： 如图所示，有两个功能debug（调试）、inspector（元素省察）。其中debug可以调试JS的代码；inspector 可以审查界面的元素。点击debuger，进入调试提示页面，界面如下：界面提示：使用option+commond+j进入调试JS代码界面，点击Sources标签，左边的导航栏显示源码列表，可以切换源码。调试面板包括设置断点、单步执行、查看运行时变量值等功能。 具体详细的调试方法请参考如何使用 Devtools 调试 Weex 页面。","tags":[{"name":"weex断点调试","slug":"weex断点调试","permalink":"http://yoursite.com/tags/weex断点调试/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"weex 事件原理分析","date":"2016-12-16T09:46:54.000Z","path":"wiki/Hybird/weex/event-analize/","text":"weex内置多种事件，包括视图的滑动事件：appear、disappear事件；手势事件：click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel。本文主要分析这些事件的传递原理。 事件传递过程分析本节通过一段示例代码，分析事件的传递过程。如果要实现一个点击事件，只需要在模板的某个标签下添加类似的代码onclick=”clickTest”， 例如： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;text class=\"btn\" onclick=\"clickTest\"&gt;测试点击事件&lt;/text&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; module.exports = &#123; data: &#123; &#125;, methods: &#123; clickTest: function (e) &#123; console.log('$event.type + $event.detail'); &#125;, &#125; &#125;&lt;/script&gt; 上面这段代码就是给text标签添加点击事件，事件的响应函数为clickTest。weex引擎渲染上面的代码，会将text标签转化为Native的WXText组件，转化过程中会调用WXText的初始化函数，定义如下： 123456- (instancetype)initWithRef:(NSString *)ref type:(NSString*)type styles:(nullable NSDictionary *)styles attributes:(nullable NSDictionary *)attributes events:(nullable NSArray *)events weexInstance:(WXSDKInstance *)weexInstance; 定义中，参数events会传入组件包含的事件列表，也就是说，weex将text标签中的on开头的属性都当做事件，渲染JS时，传递到Native中，本例中，events的值为click，接下来继续看initWithRef:type:styles:attributes:events:weexInstance中怎么处理events的。 1234567891011121314151617181920212223@property (nonatomic, readonly, strong) NSArray *events;@property(nonatomic, readonly, strong) UIView *view;- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance&#123; .... _events = events ? [NSMutableArray arrayWithArray:events] : [NSMutableArray array]; .... &#125;- (UIView *)view&#123; ... [self _initEvents:self.events]; ...&#125; 上面代码说明，在初始化文本组件WXText（WXComponent的子类）时，将事件列表保存到events属性中。当将组件添加到父视图的时候，会调用属性view的get方法，在get方法中初始化所有的事件。下面是初始化事件的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243- (void)_initEvents:(NSArray *)events&#123; NSArray *eventsCopy = [events copy]; for (NSString *addEventName in eventsCopy) &#123; [self _addEventOnMainThread:addEventName]; &#125;&#125;- (void)_addEventOnMainThread:(NSString *)addEventName&#123; WX_ADD_EVENT(appear, addAppearEvent) WX_ADD_EVENT(disappear, addDisappearEvent) WX_ADD_EVENT(click, addClickEvent) WX_ADD_EVENT(swipe, addSwipeEvent) WX_ADD_EVENT(longpress, addLongPressEvent) WX_ADD_EVENT(panstart, addPanStartEvent) WX_ADD_EVENT(panmove, addPanMoveEvent) WX_ADD_EVENT(panend, addPanEndEvent) WX_ADD_EVENT(touchstart, addTouchStartEvent) WX_ADD_EVENT(touchmove, addTouchMoveEvent) WX_ADD_EVENT(touchend, addTouchEndEvent) WX_ADD_EVENT(touchcancel, addTouchCancelEvent) [self addEvent:addEventName];&#125;#define WX_ADD_EVENT(eventName, addSelector) \\if ([addEventName isEqualToString:@#eventName]) &#123;\\ [self addSelector];\\&#125;- (void)addClickEvent&#123; if (!_tapGesture) &#123; _tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(onClick:)]; _tapGesture.delegate = self; [self.view addGestureRecognizer:_tapGesture]; &#125;&#125; 上面的代码说明初始化事件就是给文本组件的view属性添加一个点击手势tapGesture， 手势的响应函数为onClick。 12345678910111213141516171819202122232425262728293031- (void)onClick:(__unused UITapGestureRecognizer *)recognizer&#123; NSMutableDictionary *position = [[NSMutableDictionary alloc] initWithCapacity:4]; if (!CGRectEqualToRect(self.calculatedFrame, CGRectZero)) &#123; CGRect frame = [self.view.superview convertRect:self.calculatedFrame toView:self.view.window]; position[@\"x\"] = @(frame.origin.x); position[@\"y\"] = @(frame.origin.y); position[@\"width\"] = @(frame.size.width); position[@\"height\"] = @(frame.size.height); &#125; [self fireEvent:@\"click\" params:@&#123;@\"position\":position&#125;];&#125;- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params&#123; [self fireEvent:eventName params:params domChanges:nil];&#125;- (void)fireEvent:(NSString *)eventName params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges&#123; NSMutableDictionary *dict = [NSMutableDictionary dictionary]; NSTimeInterval timeSp = [[NSDate date] timeIntervalSince1970] * 1000; [dict setObject:@(timeSp) forKey:@\"timestamp\"]; if (params) &#123; [dict addEntriesFromDictionary:params]; &#125; [[WXSDKManager bridgeMgr] fireEvent:self.weexInstance.instanceId ref:self.ref type:eventName params:dict domChanges:domChanges];&#125; 上面的代码说明：在手势响应函数中，最后调用weex的WXBridgeManager中的fireEvent函数。代码如下： 123456789101112131415161718192021222324- (void)fireEvent:(NSString *)instanceId ref:(NSString *)ref type:(NSString *)type params:(NSDictionary *)params domChanges:(NSDictionary *)domChanges&#123; if (!type || !ref) &#123; WXLogError(@\"Event type and component ref should not be nil\"); return; &#125; NSArray *args = @[ref, type, params?:@&#123;&#125;, domChanges?:@&#123;&#125;]; NSMutableDictionary *methodDict = [NSMutableDictionary dictionaryWithObjectsAndKeys: @\"fireEvent\", @\"method\", args, @\"args\", nil]; WXBridgeMethod *method = [[WXBridgeMethod alloc] initWithInstance:instanceId data:methodDict]; [self executeJsMethod:method];&#125;- (void)executeJsMethod:(WXBridgeMethod *)method&#123; if (!method) return; __weak typeof(self) weakSelf = self; WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx executeJsMethod:method]; &#125;);&#125; 上面的代码说明： fireEvent实际上就是执行JS的fireEvent函数，JS的fireEvent函数会根据传递的参数找到组件、组件的事件、事件响应函数，最后执行事件。本例中就是第一段JS代码的clickTest函数。其中传递的参数本例如下： 1234567891011121314151617181920212223&#123; args =( ///ref（组件的标记） 5, ///type（事件类型） click, ///params &#123; ///事件触发的位置 position =&#123; height = \"39.5\"; width = 768; x = 0; y = 64; &#125;; timestamp = \"1481882724298.018\"; &#125;, ///domChanges（是否更新界面） &#123; &#125; ); ///JS的方法 method = fireEvent;&#125; 到目前为止，weex的事件传递机制讲完了，下面做个简单的总结。 总结weex的事件处理机制是： 在JS中定义标签的事件类型、事件的处理函数，在Native实现事件。原理是：将标签初始化为组件的时候，初始化标签的事件。其中click、swipe、longpress、panstart、panmove、panend、touchstart、touchmove、touchend、touchcancel初始化为手势事件，appear、disappear初始化为滑动视图的出现事件和消息事件。当事件触发时，通过WXBridgeManager调用JS的fireEvent函数，在JS中调用标签的事件处理函数。下面是做了一张大概的原理图。图中红色部分是JS逻辑，黑色部分是组件的逻辑，蓝色部分是WXBridgeManager逻辑。","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"正则表达式学习摘要","date":"2016-12-13T10:01:31.000Z","path":"wiki/编程理论/正则表达式/正则表达式学习/","text":"本文是学习正则表达式的学习摘要，完整学习请移步正则表达式30分钟入门教程 ,他是非常经典的文字。 元字符表1.常用的元字符 代码 说明 . 匹配除换行符以外的任意字符 \\w 匹配字母或数字或下划线或汉字 \\s 匹配任意的空白符 \\d 匹配数字 \\b 匹配单词的开始或结束 ^ 匹配字符串的开始 $ 匹配字符串的结束 重复表2.常用的限定符 代码/语法 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 字符类 语法 说明 [aeiou] 匹配任何一个英文元音字母 [0-9] 和\\d完全一致的，匹配任何数字 [a-z0-9A-Z_] 等同于\\w 只考虑英文的情况 分支条件具体方法是用|把不同的规则分隔开。 匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。 分组我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。 反义表3.常用的反义代码 代码/语法 说明 \\W 匹配任意不是字母，数字，下划线，汉字的字符 \\S 匹配任意不是空白符的字符 \\D 匹配任意非数字的字符 \\B 匹配不是单词开头或结束的位置 [^x] 匹配除了x以外的任意字符 [^aeiou] 匹配除了aeiou这几个字母以外的任意字符 后向引用使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 呃……其实,组号分配还不像我刚说得那么简单： 分组0对应整个正则表达式 实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号 你可以使用(?:exp)这样的语法来剥夺一个分组对组号分配的参与权． 后向引用用于重复搜索前面某个分组匹配的文本。例如，\\1代表分组1匹配的文本。难以理解？请看示例： \\b(\\w+)\\b\\s+\\1\\b可以用来匹配重复的单词，像go go, 或者kitty kitty。这个表达式首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\\b(\\w+)\\b)，这个单词会被捕获到编号为1的分组中，然后是1个或几个空白符(\\s+)，最后是分组1中捕获的内容（也就是前面匹配的那个单词）(\\1)。 你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：(?\\w+)(或者把尖括号换成’也行：(?’Word’\\w+)),这样就把\\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\\k,所以上一个例子也可以写成这样：\\b(?\\w+)\\b\\s+\\k\\b。 使用小括号的时候，还有很多特定用途的语法。下面列出了最常用的一些： 表4.常用分组语法 分类 代码/语法 说明 捕获 (exp) 匹配exp,并捕获文本到自动命名的组里 (?exp) 匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp) (?:exp) 匹配exp,不捕获匹配的文本，也不给此分组分配组号 零宽断言 (?=exp) 匹配exp前面的位置 (?&lt;=exp) 匹配exp后面的位置 (?!exp) 匹配后面跟的不是exp的位置 (?&lt;!exp) 匹配前面不是exp的位置 注释 (?#comment) 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 我们已经讨论了前两种语法。第三个(?:exp)不会改变正则表达式的处理方式，只是这样的组匹配的内容不会像前两种那样被捕获到某个组里面，也不会拥有组号。“我为什么会想要这样做？”——好问题，你觉得为什么呢？","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}],"categories":[{"name":"编程理论","slug":"编程理论","permalink":"http://yoursite.com/categories/编程理论/"},{"name":"正则表达式","slug":"编程理论/正则表达式","permalink":"http://yoursite.com/categories/编程理论/正则表达式/"}]},{"title":"内存学习","date":"2016-12-13T10:01:31.000Z","path":"wiki/IOS/内存管理/内存学习/","text":"本文记录内存学习的关键内容 概述 对照明设备所做的动作 对Objective-C对象所做的动作 开灯 生产对象 需要照明 持有对象 不需要照明 释放对象 关灯 废弃对象 内存管理的思考方式 自己生成的对象，自己持有 非自己生成的对象，自己也能持有 不再需要自己持有的对象时释放 非自己持有的对象无法释放 对象操作与Objective-C方法的对应 对象操作 Objective-C方法 生成并持有对象 alloc/ new/ copy/ mutableCopy 持有对象 retain方法 是否对象 release 方法 废弃对象 dealloc方法 Cocoa框架中的Foundation框架中的NSObject类担负内存管理的职责。 生成对象的内部实现 1234567-(id) allocObect&#123; id obj = &#123;[NSObject alloc] init]; ///自己持有对象 return obj;&#125; 1234567891011-(id) allocObect&#123; id obj = &#123;[NSObject alloc] init]; ///自己持有对象 [obj autorelease]; ///取得对象的存在，单自己不持有对象 return obj;&#125; autorelease 使对象在超出指定的生存范围时，能够自动正确的释放。 GNU引用计数器是在对象的头部存储。 GNU实现总结： 在Objective-C对象中存在引用计数器这一个整数值 在调用alloc或者是retain方法后，应用计数器加1 在调用release方法后，引用计数器减1 引用计数器为0时，调用dealloc方法废弃对象。 苹果的实现： 保存在引用计数器表的记录中。好处可以追溯到各个对象的内存 autorelease的使用方法： 生成并持有NSAutoreleasePool对象 调用已分配对象的autorelease方法 废弃NSAutoreleasePool对象 NSAutoreleasePool对象的生命周期相当于C语言变量的作用域 NSRunloop每次循环过程中NSAutoreleasePool对象被生成或者释放 所有权修饰符所谓对象类型就是指向NSObject这样的Objective-C类的指针。id类型用于隐藏对象类型的类名部分。 __strong __weak __unsafe_unretained __autoreleasing __strong修饰符是id类型和对象类型默认的所有权修饰符 12///arc有效id __strong obj = [[NSObject alloc] init]; 上面代码相当于： 1234567891011121314&#123; ///arc无效 id obj = [[NSObject alloc] init]; ///变量obj 持有NSObject对象。 ///一些操作 ... [obj release]; ///释放对象， NSObject对象没有持有着，所以废弃 &#125; 持有强引用的变量在超出作用域时被废弃，随着强引用的失效，引用的对象会随之释放。 __strong修饰符的变量，不仅只在变量的作用域中，在赋值上也能正确的管理其对象的所有者。 strong、weak、__autoreleasing 可以保证附加这些属性的自动变量初始化为nil. 一个非常经典的例子,专门收敲的啊。 1234567891011121314151617181920212223242526272829303132333435id __strong obj0 = [[NSObject alloc] init]; /*对象A*/id __strong obj1 = [[NSObject alloc] init]; /*对象B*/id __strong obj2 = nil;/*变量obj0持有对象A变量obj1持有对象B变量obj2不持有任何对象*/ obj0 = obj1;/*obj0持有obj1持有的对象B，由于obj0被赋值，所以原先对A对象的强引用失效A对象不存在持有这，A对象释放。并废弃。此时，持有B的的强引用变量为obj0 、obj1*/ obj2 = obj0;/*obj2持有 由obj0赋值的对象B的强引用。此时持有对象B的强引用变量为obj0、obj1、obj2*/ obj1 = nil;/*nil被赋予了obj1，所以对对象B的强引用失效，可以设想为对象B的引用计数目前为2此时持有对象B的强引用变量为obj0、obj2*/ obj0 = nil;/*nil被赋予了obj0，所以对对象B的强引用失效，可以设想为对象B的引用计数目前为1此时持有对象B的强引用变量为obj2*/ obj2 = nil;/*nil被赋予了obj2，所以对对象B的强引用失效，可以设想为对象B的引用计数目前为0 对象B不存在持有着，废弃对象B */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@interface Test : NSObject&#123; id __strong obj_;&#125;-(void) setObject:(id __strong) obj;@end@implementation Test-(id)init&#123; self = [super init]; return self;&#125;-(void) setObject:(id __strong) obj&#123; obj_ = obj;&#125;@end@implementation ViewController- (void)viewDidLoad&#123; [super viewDidLoad]; id test0 = [[Test alloc] init]; /*对象A*/ /*test0 持有Test对象A的强引用*/ id test1 = [[Test alloc] init]; /*对象B*/ /*test1 持有Test对象B的强引用变量*/ [test0 setObject:test1]; /* Test对象A的obj_成员变量持有Test对象B的强应用， 此时持有对象B的强引用变量为： test1、test0.obj_ */ [test1 setObject:test0]; /* 对象B的obj_成员变量持有对象A的强引用 此时持有对象A的强引用变量为 test0、test1.obj_*/&#125;/* test0 超出作用域，强引用失效 所以自动释放对象A test1 变量超出作用于，强引用失效 自动释放对象B 此时持有对象A的变量有test1.obj_ 此时持有对象B的变量有test0.obj_ 内存泄漏 */ 上图是对象A和对象B内存持有状态 test0 超出作用域，强引用失效，所以自动释放对象A，A对象还有B的obj_持有，不能废弃。 test1 变量超出作用于，强引用失效，自动释放对象B（计数器减2-&gt;1）。对象B还有对象A的obj_属性持有，引用计数器为1，不能废弃 最后对象A、B 在超出作用域没有释放，内存泄漏。 __weak修饰符__weak修饰符不能持有对象实例。 weak修饰符还有一个优点，在持有某对象的弱引用时，若改对象废弃，则次弱引用将自动失效且被赋值为nil。 通过检查附有weak修饰符的变量是否为nil，可以判断被赋值的对象是否已经被废弃。 __unsafe_unretained修饰符尽管ARC式的内存管理是编译器的工作，但附有unsafe_unretained修饰符的变量不属于编译器的内存管理对象 unsafe_unretained __autoreleaseARC有效时，autorelease功能也是起作用的。 123@autoreleasepool&#123; id __weak obj = [[NSObject alloc] init]; &#125; 对象赋值给附有__autorelease修饰符的变量等价于在ARC无效是调用对象的autorelease方法。即对象被注册到autoreleasepool中。用@autoreleasepool快代替NSAutoreleasePool 显示地附加autorelease修饰符同显示地附加strong修饰符一样罕见 id指针或对象的指针的指针在没有显示指定时，会被附加上__autoreleasing修饰符。 1234 - (BOOL) performOperationWithError:(NSError **) error;///等同于- (BOOL) performOperationWithError:(NSError * __autoreleasing*) error; 无论ARC是否有效，@autoreleasepool和 调试用的非公开函数_obj_autoreleasePoolPrint()都可以使用。 规则 不能使用retain/release/retainCount/autorelease 不能使用NSAllocateObject/NSDeallocateObject 必须准守内存内存管理的方法命名规则 不能显示调用dealloc 使用@autoreleasepool快代替NSAutoreleasePool 不能使用区域NSZone 对象型变量不能作为C语言结构体（struct/union）成员 显示的转化id和void* 内存管理命名方法规则 alloc new copy mutableCopy 在arc有效的时候，追加一条 init 以init开始的方法规则要不alloc/new/copy/mutableCopy更严格，改方法必须是实例方法并且必须返回对象，返回的对象应为id类型或者该方法声明类的对象类型，亦或该类的超类或者子类，返回的对象并不注册到autoreleasepool中，基本上是对alloc方法返回的对象进行初始化并返回该对象。 在arc无效的时候在dealloc方法中需要显示的调用[super dealloc] ,arc有效的时候不能调用，如果调用了，违反了第4条规则。 struct Data { NSObject __unsafe_unretained *ary; }; 要把对象添加到结构体成员中时，可强制转换为void* 或者加上unsafe_unretained修饰符。unsafe_unretained修饰符修饰的变量不属于编译器内存管理对象。 ARC 实现ARC是由编译器进行内存管理的","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"内存管理","slug":"IOS/内存管理","permalink":"http://yoursite.com/categories/IOS/内存管理/"}]},{"title":"Git笔记","date":"2016-12-13T10:01:31.000Z","path":"wiki/工具/git/git简略版/git简略版/","text":"git 简略笔记 Git笔记 Git介绍 Git是分布式版本控制系统 集中式VS分布式，SVN VS Git SVN和Git主要的区别在于历史版本维护的位置 Git本地仓库包含代码库还有历史库，在本地的环境开发就可以记录历史而SVN的历史库存在于中央仓库，每次对比与提交代码都必须连接到中央仓库才能进行。 这样的好处在于： 自己可以在脱机环境查看开发的版本历史。 多人开发时如果充当中央仓库的Git仓库挂了，可以随时创建一个新的中央仓库然后同步就立刻恢复了中央库。Git命令Git配置12$ git config --global user.name \"Your Name\"$ git config --global user.email \"email@example.com\" git config命令的--global参数，表明这台机器上的所有Git仓库都会使用这个配置，也可以对某个仓库指定不同的用户名和邮箱地址。 创建版本库初始化一个Git仓库1$ git init 添加文件到Git仓库包括两步：12$ git add &lt;file&gt;$ git commit -m \"description\" git add可以反复多次使用，添加多个文件，git commit可以一次提交很多文件，-m后面输入的是本次提交的说明，可以输入任意内容。 查看工作区状态1$ git status 查看修改内容1$ git diff 1$ git diff --cached 1$ git diff HEAD -- &lt;file&gt; git diff 可以查看工作区(work dict)和暂存区(stage)的区别 git diff --cached 可以查看暂存区(stage)和分支(master)的区别 git diff HEAD -- &lt;file&gt; 可以查看工作区和版本库里面最新版本的区别查看提交日志1$ git log 简化日志输出信息1$ git log --pretty=oneline 查看命令历史1$ git reflog 版本回退1$ git reset --hard HEAD^ 以上命令是返回上一个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本是HEAD^^，往上100个版本写成HEAD~100。 回退指定版本号1$ git reset --hard commit_id commit_id是版本号，是一个用SHA1计算出的序列 工作区、暂存区和版本库工作区：在电脑里能看到的目录；版本库：在工作区有一个隐藏目录.git，是Git的版本库。Git的版本库中存了很多东西，其中最重要的就是称为stage（或者称为index）的暂存区，还有Git自动创建的master，以及指向master的指针HEAD。 进一步解释一些命令： git add实际上是把文件添加到暂存区 git commit实际上是把暂存区的所有内容提交到当前分支撤销修改丢弃工作区的修改1$ git checkout -- &lt;file&gt; 该命令是指将文件在工作区的修改全部撤销，这里有两种情况： 一种是file自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 丢弃暂存区的修改分两步：第一步，把暂存区的修改撤销掉(unstage)，重新放回工作区：1$ git reset HEAD &lt;file&gt; 第二步，撤销工作区的修改1$ git checkout -- &lt;file&gt; 小结： 当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- &lt;file&gt;。 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了第一步，第二步按第一步操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，进行版本回退，前提是没有推送到远程库。 删除文件1$ git rm &lt;file&gt; git rm &lt;file&gt;相当于执行12$ rm &lt;file&gt;$ git add &lt;file&gt; 进一步的解释Q：比如执行了rm text.txt 误删了怎么恢复？A：执行git checkout -- text.txt 把版本库的东西重新写回工作区就行了Q：如果执行了git rm text.txt我们会发现工作区的text.txt也删除了，怎么恢复？A：先撤销暂存区修改，重新放回工作区，然后再从版本库写回到工作区12$ git reset head text.txt$ git checkout -- text.txt Q：如果真的想从版本库里面删除文件怎么做？A：执行git commit -m &quot;delete text.txt&quot;，提交后最新的版本库将不包含这个文件 远程仓库创建SSH Key1$ ssh-keygen -t rsa -C \"youremail@example.com\" 关联远程仓库1$ git remote add origin https://github.com/username/repositoryname.git 推送到远程仓库1$ git push -u origin master -u 表示第一次推送master分支的所有内容，此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程克隆1$ git clone https://github.com/usern/repositoryname.git 分支创建分支1$ git branch &lt;branchname&gt; 查看分支1$ git branch git branch命令会列出所有分支，当前分支前面会标一个*号。 切换分支1$ git checkout &lt;branchname&gt; 创建+切换分支1$ git checkout -b &lt;branchname&gt; 合并某分支到当前分支1$ git merge &lt;branchname&gt; 删除分支1$ git branch -d &lt;branchname&gt; 查看分支合并图1$ git log --graph 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log --graph命令可以看到分支合并图。 普通模式合并分支1$ git merge --no-ff -m \"description\" &lt;branchname&gt; 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并分支时，加上--no-ff参数就可以用普通模式合并，能看出来曾经做过合并，包含作者和时间戳等信息，而fast forward合并就看不出来曾经做过合并。 保存工作现场1$ git stash 查看工作现场1$ git stash list 恢复工作现场1$ git stash pop 丢弃一个没有合并过的分支1$ git branch -D &lt;branchname&gt; 查看远程库信息1$ git remote -v 在本地创建和远程分支对应的分支1$ git checkout -b branch-name origin/branch-name， 本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联1$ git branch --set-upstream branch-name origin/branch-name； 从本地推送分支1$ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交； 从远程抓取分支1$ git pull 如果有冲突，要先处理冲突。 标签tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 新建一个标签1$ git tag &lt;tagname&gt; 命令git tag &lt;tagname&gt;用于新建一个标签，默认为HEAD，也可以指定一个commit id。 指定标签信息1$ git tag -a &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;可以指定标签信息。 PGP签名标签1$ git tag -s &lt;tagname&gt; -m &lt;description&gt; &lt;branchname&gt; or commit_id git tag -s &lt;tagname&gt; -m &quot;blablabla...&quot;可以用PGP签名标签。 查看所有标签1$ git tag 推送一个本地标签1$ git push origin &lt;tagname&gt; 推送全部未推送过的本地标签1$ git push origin --tags 删除一个本地标签1$ git tag -d &lt;tagname&gt; 删除一个远程标签1$ git push origin :refs/tags/&lt;tagname&gt;","tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"git","slug":"工具/git","permalink":"http://yoursite.com/categories/工具/git/"},{"name":"git简略版","slug":"工具/git/git简略版","permalink":"http://yoursite.com/categories/工具/git/git简略版/"}]},{"title":"weex 通信原理分析","date":"2016-12-13T10:01:31.000Z","path":"wiki/Hybird/weex/weex-conmunication/","text":"本文首先简单阐述了JavaScriptCore中JS和Native的通信机制，在此基础上，分析了weex中的JS和Native的通信机制。 万物之源 -JavaScriptCore不论是RN、weex、JSPatch，他们的核心交互机制都使用JavaScriptCore，通过它完成JS和Native的通信。关于JavaScriptCore的简单介绍可以参考IOS7开发～JavaScriptCore （一），这里只简单提及下。 关键类-JSContext、JSValueJavaScriptCore中的两个关键类： JSContext(JS脚本的执行环境) JSValue（JS 和Native传值的载体） JSContext 的核心方法- (JSValue )evaluateScript:(NSString )script;，功能是执行JS脚本代码，执行完后，会将JS中的对象、方法添加到JSContext上下文中的全局对象中。这样就可以通过JSContext引用到JS代码中的对象、方法。 JSValue是用来呈现JS的对象，它可以将JS中的对象、方法转化为Native的对象、函数，反之亦然。下面是JSValue的两个核心方法： 123- (JSValue *)callWithArguments:(NSArray *)arguments; - (JSValue *)invokeMethod:(NSString *)method withArguments:(NSArray *)arguments; 如果JSValue实例代表JS中一个函数变量（变量中存储的是函数），用callWithArguments调用JS的函数。如果拿到了JS代码的执行环境的全局对象，可以向全局对象发送invokeMethod消息调用JS中的函数。参数包括JS的函数名称、调用参数。 Native调用JS机制可以使用JSValue 的callWithArguments 和 invokeMethod方法 单独调用JS中的某个函数 。也可以使用JSContext 的evaluateScript方法执行整个JS代码。下面给出一个例子，其中，test.js的内容如下 123456789101112///匿名函数var functionVar = function(num)&#123; return num + 1;&#125;function jsFucton(num)&#123; return num + 1;&#125;jsFucton(2); 测试代码如下： 123456789101112131415161718-(void) nativeCallJS&#123; NSString *path = [[NSBundle mainBundle]pathForResource:@\"test\"ofType:@\"js\"]; NSString *testScript = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; JSContext *jsContext = [[JSContext alloc] init]; ///1.执行整个JS代码 JSValue *resultEvaluate =[jsContext evaluateScript:testScript]; NSLog(@\"resultEvaluate = %@\",[resultEvaluate toObject]); ///2. callWithArguments 调用方式 JSValue *fuctionVar = jsContext[@\"functionVar\"]; JSValue *resultVar = [fuctionVar callWithArguments:@[@(4)]]; NSLog(@\"resultVar = %@\",[resultVar toObject]); ///3. invokeMethod 调用方式 JSValue *resultFuction = [[jsContext globalObject] invokeMethod:@\"jsFucton\" withArguments:@[@(6)]]; NSLog(@\"resultFuction = %@\",[resultFuction toObject]);&#125; 输出如下： 1232016-12-14 13:36:27.237 Test2222[15246:172495] resultEvaluate = 32016-12-14 13:36:27.238 Test2222[15246:172495] resultVar = 52016-12-14 13:36:30.166 Test2222[15246:172495] resultFuction = 7 例子中展示了使用JSContext的evaluateScript:方法执行整个JS代码，调用完evaluateScript之后，会将JS代码中的变量、方法添加到jsContext的全局对象中，这样可以使用jsContext[@”functionVar”]访问到JS中的functionVar对象。在JS中，functionVar是一个函数对象，可以向fuctionVar发送callWithArguments消息，执行JS中的functionVar变量中存储的函数。同时也可以使用[[jsContext globalObject] invokeMethod:@”jsFucton” withArguments:@[@(6)]]调用到JS中的jsFucton函数。 上面是Native调用JS的三种方式。每种方式使用的场景不同。 JS调用Native机制JS调用Native有两种方式： block JSExport 主要介绍Block方式，因为weex中使用的是Block方式，直接以代码为例： 12345678910111213141516171819-(NSString *) nativeFuction:(NSString *) strParam1 param2:(NSString *)strParam2&#123; return [NSString stringWithFormat:@\"%@_%@\",strParam1,strParam2];&#125;-(void) JSCallNative&#123; JSContext *jsContext = [[JSContext alloc] init]; ///给JS添加一个方法，JS就能调用到Native的方法 __weak typeof(self) weakSelf = self; jsContext[@\"jsMethod\"] = ^(NSString * strParam1, NSString *strParam2) &#123; NSString * strResult = [weakSelf nativeFuction:strParam1 param2:strParam2]; return strResult; &#125;; JSValue *strResult = [jsContext evaluateScript:@\"jsMethod('这是第一个参数','这是第二个参数')\"]; NSLog(@\"strResult = %@\",[strResult toObject]);&#125; 输出： strResult = 这是第一个参数_这是第二个参数 在Native中block相当于JS中的function，jsContext[@”jsMethod”]=…相当于给JS添加一个名为jsMethod的function，不过，这个jsMethod的实现是Native的代码。在JS中执行jsMethod方法，就会调用到Native的代码。 小小结了解了JSContext、JSValue、Native和JS的交互机制，是看懂weex的前提。不论weex如何封装，都离不开上面的基本原理。Native调用JS有三种方式： JSValue 的callWithArguments JSValue的invokeMethod JSContext的evaluateScript JS调用Native有两种方式 block JSExport 刨根问底-weex的交互机制这一节我一步步的分析weex的通信原理，目标两个： 了解weex通信原理 了解通信原理相关的两个重要部分Module、Bridge。 具体的思路是找到SDK初始化的入口，顺着入口逐渐深入分析。直到了解weex的通信机制为止。 寻踪觅迹- 分析初始化weex SDK的入口是WXSDKEngine类，WXSDKEngine 是一个全局类。其中，initSDKEnviroment:完成sdk的初始化工作： 12345678+ (void)initSDKEnviroment:(NSString *)script&#123; [self _registerDefaultComponents]; [self _registerDefaultModules]; [self _registerDefaultHandlers]; [[WXSDKManager bridgeMgr] executeJsFramework:script];&#125; weex有中有三个重要的部分：Components、Modules、Handlers。Components 是布局Native界面的元素，例如UILabel对应的组件是WXTextComponent，他和html元素text对应。Modules是Native的功能模块，是JS可以访问的Native类。应该封装了必须有Native完成的功能。我们主要关注Modules模块，他是weex中Native和JS通信的核心部分。_registerDefaultModules是注册默认的Module： 123456+ (void)_registerDefaultModules&#123; [self registerModule:@\"dom\" withClass:NSClassFromString(@\"WXDomModule\")]; [self registerModule:@\"navigator\" withClass:NSClassFromString(@\"WXNavigatorModule\")]; .....&#125; 这段代码是注册weex提供给开发者的默认模块。每个模块都实现某种功能，它是JS可以调用的Native类。接着分析registerModule函数： 123456789+ (void)registerModule:(NSString *)name withClass:(Class)clazz&#123; ///注册native的module NSString *moduleName = [WXModuleFactory registerModule:name withClass:clazz]; ///组成JS的module NSDictionary *dict = [WXModuleFactory moduleMethodMapsWithName:moduleName]; [[WXSDKManager bridgeMgr] registerModules:dict];&#125; 这段代码完成两个功能，初始化Native端Module的配置信息、初始化JS端Module的配置信息。到目前为止，我们已经找到了weex的入口，后续部分需要分两个单独的模块分析讲解。一个是Module，一个是通信机制。 刨根问底-配置信息和ModuleModule 相关的类有WXModuleFactory、WXModuleManager、WXModuleProtocol。三个类的类图如下：WXModuleManager只有一个方法，-dispatchMethod:(WXBridgeMethod *)method，根据传入的method在配置文件中找到方法并执行。WXModuleFactory是Module的工厂类，存储着所有Module的配置信息。WXModuleProtocol是Module需要遵守的协议。只有遵守了WXModuleProtocol协议的Native类才叫做Module，他才会被添加到Native和JS的配置信息中，这样JS就可以调用到这个类中的方法。这里贴出WXModuleProtocol的代码如下： 12345678910111213141516171819202122///1. 定义了module JS 回调native的方法 typedef void (^WXModuleCallback)(id result);typedef void (^WXModuleKeepAliveCallback)(id result, BOOL keepAlive);#define WX_EXPORT_METHOD(method) \\+ (NSString *)WX_CONCAT_WRAPPER(wx_export_method_, __LINE__) &#123; \\ return NSStringFromSelector(method); \\&#125;///2. 导出类#define WX_EXPORT_MODULE(module)///3. 导出方法 (其实是定义了一个类方法 )WX_EXPORT_METHOD(@selector(getNetUrl:page:sucCallBack:failCallBack:)) ///4. 执行方法的线程- (NSThread *)targetExecuteThread;@property (nonatomic, weak) WXSDKInstance *weexInstance; 主要有三部分： 定义回调 定义导出Native方法的方法 定义Native方法的执行线程。 回调就是JS执行完Native代码后，可以回调的JS的代码。定义导出方法就是：给每个导出方法定义一个类方法，类方法的名字大概就是wx_export_method_100这种样式，返回导出的方法名称。这样做的目的就是不用初始化Module类，就能获取到Module的导出方法信息，并加入到两端的配置信息中。targetExecuteThread是定义了所有的导出方法执行的线程。如果没有实现，默认在主线程执行方法。如果实现，返回对应的线程，就在该线程中执行方法。到目前为止，Native端的Module配置信息都讲完了。总结为：配置信息中包括了所有Module的导出方法、Module的名称、对应的类。接下来简单分析下JS端的配置信息。注册Module的信息到JS，调用的是WXBridgeManager的registerModules 方法： 123456789- (void)registerModules:(NSDictionary *)modules&#123; if (!modules) return; __weak typeof(self) weakSelf = self; WXPerformBlockOnBridgeThread(^()&#123; [weakSelf.bridgeCtx registerModules:modules]; &#125;);&#125; registerModules: 调用了WXBridgeContext中的registerModules:方法，代码如下： 1234- (void)registerModules:(NSDictionary *)modules&#123; [self callJSMethod:@\"registerModules\" args:@[modules]];&#125; 内部调用了JS中的方法registerModules，下面转入到main.js，registerModules代码如下： 12345678910111213141516171819202122232425262728293031323334353637function registerModules(modules)&#123; if((typeof modules===\"undefined\"?\"undefined\":_typeof(modules))===\"object\") &#123; (0,_register.initModules)(modules) &#125;&#125;function initModules(modules,ifReplace)&#123; var _loop=function _loop(moduleName) &#123; var methods=nativeModules[moduleName]; if(!methods) &#123; methods=&#123;&#125;; nativeModules[moduleName]=methods &#125; modules[moduleName].forEach( function(method) &#123; if(typeof method===\"string\") &#123; method=&#123;name:method&#125; &#125; if(!methods[method.name]||ifReplace) &#123; methods[method.name]=method &#125; &#125;) &#125;; for(var moduleName in modules) &#123; _loop(moduleName) &#125;&#125; 大概可以理解为：JS中有个nativeModules变量，这个对象保存着module名称和对应的方法列表。注册就是向nativeModules中添加Module的信息。 终极目标-Bridge(通信机制)接下来了解如何利用这些配置信息完成JS和Native之间的交互。交互就需要一个桥梁，在weex中用Bridge表示。Bridge封装了交互的规则，主要有几个类WXBridgeManager、WXBridgeProtocol、WXBridgeMethod、WXJSCoreBridge、WXBridgeContext。首先将这几个类的类图贴出来：WXBridgeManager是Brider的管理类，承接着Native和JS的交互、调试管理、界面更新、事件传递等任务。具体干活的类是WXBridgeContext和WXJSCoreBridge，其中WXJSCoreBridge是遵守了WXBridgeProtocol协议的类。 图中红色的代码完成Native和JS交互功能的代码。交互分为两部分：JS到Native、Native到JS。首先分析Native到JS这个路径。executeJsMethod: 是Native调用JS的入口方法。内部调用了WXJSCoreBridge的callJSMethod方法，传递的JS方法名是callJS。具体的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738- (void)executeJsMethod:(WXBridgeMethod *)method&#123; .... [sendQueue addObject:method]; [self performSelector:@selector(_sendQueueLoop) withObject:nil];&#125;- (void)_sendQueueLoop&#123; ///构造方法的相关参数 .... ///调用方法 if ([methods count] &gt; 0 &amp;&amp; execIns) &#123; [self callJSMethod:@\"callJS\" args:@[execIns, methods]]; &#125; if (hasTask) &#123; [self performSelector:@selector(_sendQueueLoop) withObject:nil]; &#125;&#125;- (void)callJSMethod:(NSString *)method args:(NSArray *)args&#123; if (self.frameworkLoadFinished) &#123; [self.jsBridge callJSMethod:method args:args]; &#125; else &#123; [_methodQueue addObject:@&#123;@\"method\":method, @\"args\":args&#125;]; &#125;&#125;///WXJSCoreBridge 的callJSMethod方法- (JSValue *)callJSMethod:(NSString *)method args:(NSArray *)args&#123; WXLogDebug(@\"Calling JS... method:%@, args:%@\", method, args); return [[_jsContext globalObject] invokeMethod:method withArguments:args];&#125; 上面是Native调用JS的原理 ，下面分析JS调用Native的原理。 当首次调用- (id)jsBridge方法创建Bridge时，会调用Bridge的registerCallNativeJS设置JS调用Native的入口。入口名称为callNative，即JS代码中调用callNative函数，就能调用到Native的代码。当进入Native后，会调用WXBridgeContext的invokeNative方法，内部会查找配置信息，然后invoke相应的方法。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445- (id&lt;WXBridgeProtocol&gt;)jsBridge&#123; ... _jsBridge = _debugJS ? [NSClassFromString(@\"WXDebugger\") alloc] : [[WXJSCoreBridge alloc] init]; __weak typeof(self) weakSelf = self; [_jsBridge registerCallNative:^NSInteger(NSString *instance, NSArray *tasks, NSString *callback) &#123; return [weakSelf invokeNative:instance tasks:tasks callback:callback]; &#125;]; .... return _jsBridge;&#125;- (void)registerCallNative:(WXJSCallNative)callNative&#123; NSInteger (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^(JSValue *instance, JSValue *tasks, JSValue *callback)&#123; NSString *instanceId = [instance toString]; NSArray *tasksArray = [tasks toArray]; NSString *callbackId = [callback toString]; return callNative(instanceId, tasksArray, callbackId); &#125;; _jsContext[@\"callNative\"] = callNativeBlock;&#125;- (NSInteger)invokeNative:(NSString *)instance tasks:(NSArray *)tasks callback:(NSString *)callback&#123; ... ///批量调用方法 for (NSDictionary *task in tasks) &#123; WXBridgeMethod *method = [[WXBridgeMethod alloc] initWihData:task]; method.instance = instance; [[WXSDKManager moduleMgr] dispatchMethod:method]; &#125; ///下面是处理回调的 NSMutableArray *sendQueue = [self.sendQueue valueForKey:instance]; if (![callback isEqualToString:@\"undefined\"] &amp;&amp; ![callback isEqualToString:@\"-1\"] &amp;&amp; callback) &#123; WXBridgeMethod *method = [self _methodWithCallback:callback]; method.instance = instance; [sendQueue addObject:method]; &#125; [self performSelector:@selector(_sendQueueLoop) withObject:nil]; return 1;&#125; 图中蓝色代码是Native直接调用JS的函数，分别为： createInstance、destroyInstance、refreshInstance、registerModules、registerComponents。具体的功能在JS那边。这里不做了解。 归纳总结weex的JS和Native通信原理可以使用下面图简单描述：在weexSDK初始化的时候，完成JS端和Native端的配置信息。JS端的配置信息的作用应该是确保什么样的Native方法可以在JS中调用；Native配置信息的作用是：当JS调用到Native的方法，需要查找调用的Module、方法、方法的SEL等信息，这样才能invoke到相应的方法。weex这样设计的原因大概是为了统一管理JS和Native的通信机制，假如，有许多Native的方法可以被JS调用，那么就需要配置很多的入口，这样随着代码的增加，无法有效维护，weex借助配置信息，巧妙的将入口控制为两个，一个是JS到Native的入口为callNative，一个是Native到JS的入口为callJS。","tags":[{"name":"weex","slug":"weex","permalink":"http://yoursite.com/tags/weex/"}],"categories":[{"name":"Hybird","slug":"Hybird","permalink":"http://yoursite.com/categories/Hybird/"},{"name":"weex","slug":"Hybird/weex","permalink":"http://yoursite.com/categories/Hybird/weex/"}]},{"title":"flexBox 伸缩盒子模型","date":"2016-12-02T08:18:26.000Z","path":"wiki/JS/flexBox/","text":"本文指在理解flexBox的各个效果，学习React Native的时候总结。 盒子模型标准盒子模型标准的盒子模型如下图所示： 伸缩盒子模型任何一个元素都可以指定为flexbox 布局，设置为display:flex或display:inline-flex的元素称为伸缩容器，伸缩容器的子元素称为伸缩项目，下面是伸缩的模型： 二、React Native中使用flexBox flexDirection（伸缩容器） alignItems（伸缩容器） flexWrap（伸缩容器） justifyContent（伸缩容器） alignSelf（伸缩项目） flex （伸缩项目） flexDirection 指定主轴方向1flexDirection:row|column row、column的效果图如下： alignItems该属性用来定义伸缩项目在伸缩容器的交叉轴上的对齐方式 1alignSelf:auto|flex-start|flex-end|center|stretch flex-start、flex-end、center的效果图如下： flexWrap指定伸缩容器的主轴方向空间不足的情况下，是否换行以及如何换行 1flexWrap:wrap|nowrap wrap、nowrap的效果图如下： justifyContent指定伸缩项目沿主轴线的对齐方式 1justifyContent:flex-start|flex-end|center|space-between|space-around flex-start、flex-end、center、space-between、space-around的效果图如下： alignSelf设置单独的伸缩项目在交叉轴上的对齐方式，会覆写默认的对齐方式 1alignSelf:auto|flex-start|flex-end|center|stretch lex-start、flex-end、center 的效果图如下： flex1flex:number 分别设置四个伸缩项目的 flex为3、2、1、4，效果图如下：","tags":[{"name":"flexBox","slug":"flexBox","permalink":"http://yoursite.com/tags/flexBox/"}],"categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}]},{"title":"深入理解Objective-C：Category(转载)","date":"2016-12-02T02:47:02.000Z","path":"wiki/IOS/Runtime/经典文章/Objective_C_Category/","text":"无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。 初入宝地-category简介category是Objective-C 2.0之后添加的语言特性，category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了category的另外两个使用场景 可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，a)可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 c)可以由多个开发者共同完成一个类 d)可以按需加载想要的category 等等。 声明私有方法 不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景： 模拟多继承 把framework的私有方法公开 Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。 连类比事-category和extensionextension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。 但是category则完全不一样，它是在运行期决议的。就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的。（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。 挑灯细览-category真面目我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了: 类的名字（name） 类（cls） category中所有给类添加的实例方法的列表（instanceMethods） category中所有添加的类方法的列表（classMethods） category实现的所有协议的列表（protocols） category中添加的所有属性（instanceProperties） 12345678typedef struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125; category_t; 从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。ok，我们先去写一个category看一下category到底为何物：MyClass.h： 12345678#import &lt;Foundation/Foundation.h&gt;@interface MyClass : NSObject- (void)printName;@end@interface MyClass(MyAddition)@property(nonatomic, copy) NSString *name;- (void)printName;@end MyClass.m： 1234567891011121314#import \"MyClass.h\"@implementation MyClass- (void)printName&#123; NSLog(@\"%@\",@\"MyClass\");&#125;@end @implementation MyClass(MyAddition)- (void)printName&#123; NSLog(@\"%@\",@\"MyAddition\");&#125;@end 我们使用clang的命令去看看category到底会变成什么： 1clang -rewrite-objc MyClass.m 好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364///实例方法列表static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =&#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"printName\", \"v16@0:8\", (void *)_I_MyClass_MyAddition_printName&#125;&#125;&#125;; ///实例属性列表static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_prop_t), 1, &#123;&#123;\"name\",\"T@\\\"NSString\\\",C,N\"&#125;&#125;&#125;; extern \"C\" __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass; ///category 本身static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (\"__DATA,__objc_const\"))) =&#123; \"MyClass\", 0, // &amp;OBJC_CLASS_$_MyClass, (const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition, 0, 0, (const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,&#125;; static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123; _OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;&#125;#pragma section(\".objc_inithooks$B\", long, read, write)__declspec(allocate(\".objc_inithooks$B\")) static void *OBJC_CATEGORY_SETUP[] = &#123; (void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,&#125;; ///DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (\"__DATA, __objc_classlist,regular,no_dead_strip\")))= &#123; &amp;OBJC_CLASS_$_MyClass,&#125;;static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123; &amp;OBJC_CLASS_$_MyClass,&#125;;static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (\"__DATA, __objc_catlist,regular,no_dead_strip\")))= &#123; &amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,&#125;; 我们可以看到: 首先编译器生成了实例方法列表OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition和属性列表OBJC$_PROP_LISTMyClass$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。 其次，编译器生成了category本身OBJC$_CATEGORYMyClass$_MyAddition，并用前面生成的列表来初始化category本身。 最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。 追本溯源-category如何加载我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。想了解更多dyld地同学可以移步这里。对于OC运行时，入口方法如下（在objc-os.mm文件中）： 123456789101112131415161718void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something _dyld_register_func_for_remove_image(&amp;unmap_image); dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch*/, &amp;map_images); dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; class_t *cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = NULL; if (PrintConnecting) &#123; _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. BOOL classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (isRealized(cls)) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category -%s(%s) %s\", getName(cls), cat-&gt;name, classExists ? \"on existing class\" : \"\"); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; addUnattachedCategoryForClass(cat, cls-&gt;isa, hi); if (isRealized(cls-&gt;isa)) &#123; remethodizeClass(cls-&gt;isa); &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category +%s(%s)\", getName(cls), cat-&gt;name); &#125; &#125; &#125;&#125; 首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。略去PrintConnecting这个用于log的东西，这段代码很容易理解： 把category的实例方法、协议以及属性添加到类上 把category的类方法和协议添加到类的metaclass上 值得注意的是，在代码中有一小段注释 / || cat-&gt;classProperties /，看来苹果有过给类添加属性的计划啊。ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。 12345678910111213141516171819202122232425262728293031323334353637383940414243static void remethodizeClass(class_t *cls)&#123; category_list *cats; BOOL isMeta; rwlock_assert_writing(&amp;runtimeLock); isMeta = isMetaClass(cls); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls))) &#123; chained_property_list *newproperties; const protocol_list_t **newprotos; if (PrintConnecting) &#123; _objc_inform(\"CLASS: attaching categories to class '%s' %s\", getName(cls), isMeta ? \"(meta)\" : \"\"); &#125; // Update methods, properties, protocols ///添加方法 BOOL vtableAffected = NO; attachCategoryMethods(cls, cats, &amp;vtableAffected); ///添加属性 newproperties = buildPropertyList(NULL, cats, isMeta); if (newproperties) &#123; newproperties-&gt;next = cls-&gt;data()-&gt;properties; cls-&gt;data()-&gt;properties = newproperties; &#125; ///添加协议 newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols); if (cls-&gt;data()-&gt;protocols &amp;&amp; cls-&gt;data()-&gt;protocols != newprotos) &#123; _free_internal(cls-&gt;data()-&gt;protocols); &#125; cls-&gt;data()-&gt;protocols = newprotos; _free_internal(cats); // Update method caches and vtables flushCaches(cls); if (vtableAffected) flushVtables(cls); &#125;&#125; 而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods： 12345678910111213141516171819202122232425262728static void attachCategoryMethods(class_t *cls, category_list *cats, BOOL *inoutVtablesAffected)&#123; if (!cats) return; if (PrintReplacedMethods) printReplacements(cls, cats); BOOL isMeta = isMetaClass(cls); method_list_t **mlists = (method_list_t **) _malloc_internal(cats-&gt;count * sizeof(*mlists)); // Count backwards through cats to get newest categories first int mcount = 0; int i = cats-&gt;count; BOOL fromBundle = NO; while (i--) &#123; method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta); if (mlist) &#123; mlists[mcount++] = mlist; fromBundle |= cats-&gt;list[i].fromBundle; &#125; &#125; attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected); _free_internal(mlists); &#125; attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段： 123456789101112131415161718192021222324for (uint32_t m = 0; (scanForCustomRR || scanForCustomAWZ) &amp;&amp; m &lt; mlist-&gt;count; m++) &#123; SEL sel = method_list_nth(mlist, m)-&gt;name; if (scanForCustomRR &amp;&amp; isRRSelector(sel)) &#123; cls-&gt;setHasCustomRR(); scanForCustomRR = false; &#125; else if (scanForCustomAWZ &amp;&amp; isAWZSelector(sel)) &#123; cls-&gt;setHasCustomAWZ(); scanForCustomAWZ = false; &#125; &#125; // Fill method list array newLists[newCount++] = mlist;... // Copy old methods to the method list arrayfor (i = 0; i &lt; oldCount; i++) &#123; newLists[newCount++] = oldLists[i];&#125; 需要注意的有两点： category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。 旁枝末叶-category和+load方法我们知道，在类和category中都可以有+load方法，那么有两个问题： 在类的+load方法调用的时候，我们可以调用category中声明的方法么？ 这么些个+load方法，调用顺序是咋样的呢？ 鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）: 运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下： 1234567891011121314151617objc[1187]: REPLACED: -[MyClass printName] by category Category1objc[1187]: REPLACED: -[MyClass printName] by category Category2...objc[1187]: LOAD: class 'MyClass' scheduled for +loadobjc[1187]: LOAD: category 'MyClass(Category1)' scheduled for +loadobjc[1187]: LOAD: category 'MyClass(Category2)' scheduled for +loadobjc[1187]: LOAD: +[MyClass load]...objc[1187]: LOAD: +[MyClass(Category1) load]...objc[1187]: LOAD: +[MyClass(Category2) load] 所以，对于上面两个问题，答案是很明显的： 可以调用，因为附加category到类的工作会先于+load方法的执行 +load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。 目前的编译顺序是这样的： 虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。 触类旁通-category和方法覆盖鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:怎么调用到原来类中被category覆盖掉的方法？对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法： 12345678910111213141516171819202122232425Class currentClass = [MyClass class];MyClass *my = [[MyClass alloc] init]; if (currentClass) &#123; unsigned int methodCount; Method *methodList = class_copyMethodList(currentClass, &amp;methodCount); IMP lastImp = NULL; SEL lastSel = NULL; for (NSInteger i = 0; i &lt; methodCount; i++) &#123; Method method = methodList[i]; NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) encoding:NSUTF8StringEncoding]; if ([@\"printName\" isEqualToString:methodName]) &#123; lastImp = method_getImplementation(method); lastSel = method_getName(method); &#125; &#125; typedef void (*fn)(id,SEL); if (lastImp != NULL) &#123; fn f = (fn)lastImp; f(my,lastSel); &#125; free(methodList);&#125; 更上一层-category和关联对象如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。 MyClass+Category1.h: 1234567#import \"MyClass.h\" @interface MyClass (Category1) @property(nonatomic,copy) NSString *name; @end MyClass+Category1.m: 12345678910111213141516171819202122232425#import \"MyClass+Category1.h\"#import &lt;objc/runtime.h&gt; @implementation MyClass (Category1) + (void)load&#123; NSLog(@\"%@\",@\"load in Category1\");&#125; - (void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, \"name\", name, OBJC_ASSOCIATION_COPY);&#125; - (NSString*)name&#123; NSString *nameObject = objc_getAssociatedObject(self, \"name\"); return nameObject;&#125; @end 但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); _class_setInstancesHaveAssociatedObjects(_object_getClass(object)); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下： 12345678910111213class AssociationsManager &#123; static OSSpinLock _lock; static AssociationsHashMap *_map; // associative references: object pointer -&gt; PtrPtrHashMap.public: AssociationsManager() &#123; OSSpinLockLock(&amp;_lock); &#125; ~AssociationsManager() &#123; OSSpinLockUnlock(&amp;_lock); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。而在对象的销毁逻辑里面，见objc-runtime-new.mm: 12345678910111213141516171819void *objc_destructInstance(id obj) &#123; if (obj) &#123; Class isa_gen = _object_getClass(obj); class_t *isa = newcls(isa_gen); // Read all of the flags at once for performance. bool cxx = hasCxxStructors(isa); bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); if (!UseGC) objc_clear_deallocating(obj); &#125; return obj;&#125; 嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。","tags":[{"name":"category","slug":"category","permalink":"http://yoursite.com/tags/category/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"经典文章","slug":"IOS/Runtime/经典文章","permalink":"http://yoursite.com/categories/IOS/Runtime/经典文章/"}]},{"title":"第三天——如何正确使用Runtime(转载)","date":"2016-11-29T06:25:09.000Z","path":"wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/","text":"到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。 实现多继承Multiple Inheritance在上一篇文章里面讲到的forwardingTargetForSelector:方法就能知道，一个类可以做到继承多个类的效果，只需要在这一步将消息转发给正确的类对象就可以模拟多继承的效果。 在Objective-C Runtime Programming Guide上记录了这样一段例子。在OC程序中可以借用消息转发机制来实现多继承的功能。 在上图中，一个对象对一个消息做出回应，类似于另一个对象中的方法借过来或是“继承”过来一样。 在图中，warrior实例转发了一个negotiate消息到Diplomat实例中，执行Diplomat中的negotiate方法，结果看起来像是warrior实例执行了一个和Diplomat实例一样的negotiate方法，其实执行者还是Diplomat实例。 这使得不同继承体系分支下的两个类可以“继承”对方的方法，这样一个类可以响应自己继承分支里面的方法，同时也能响应其他不相干类发过来的消息。在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。 消息转发提供了许多类似于多继承的特性，但是他们之间有一个很大的不同： 多继承：合并了不同的行为特征在一个单独的对象中，会得到一个重量级多层面的对象。 消息转发：将各个功能分散到不同的对象中，得到的一些轻量级的对象，这些对象通过消息转发联合起来。 这里值得说明的一点是，即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开。像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个Warrior对象如果被问到是否能响应negotiate消息： 1if ( [aWarrior respondsToSelector:@selector(negotiate)] ) 结果是NO，虽然它能够响应negotiate消息而不报错，但是它是靠转发消息给Diplomat类来响应消息的。 如果非要制造假象，反应出这种“假”的继承关系，那么需要重新实现 respondsToSelector:和 isKindOfClass:来加入你的转发算法： 1234567891011- (BOOL)respondsToSelector:(SEL)aSelector&#123; if ( [super respondsToSelector:aSelector] ) return YES; else &#123; /* Here, test whether the aSelector message can * * be forwarded to another object and whether that * * object can respond to it. Return YES if it can. */ &#125; return NO;&#125; 除了respondsToSelector:和 isKindOfClass:之外，instancesRespondToSelector:中也应该写一份转发算法。如果使用了协议，conformsToProtocol:也一样需要重写。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个methodSignatureForSelector:来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现methodSignatureForSelector: 12345678- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector&#123; NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; signature = [surrogate methodSignatureForSelector:selector]; &#125; return signature;&#125; Note: This is an advanced technique, suitable only for situations where no other solution is possible. It is not intended as a replacement for inheritance. If you must make use of this technique, make sure you fully understand the behavior of the class doing the forwarding and the class you’re forwarding to. 需要引起注意的一点，实现methodSignatureForSelector方法是一种先进的技术，只适用于没有其他解决方案的情况下。它不会作为继承的替代。如果您必须使用这种技术，请确保您完全理解类做的转发和您转发的类的行为。请勿滥用！ Method Swizzling提到Objective-C 中的 Runtime，大多数人第一个想到的可能就是黑魔法Method Swizzling。毕竟这是Runtime里面很强大的一部分，它可以通过Runtime的API实现更改任意的方法，理论上可以在运行时通过类名/方法名hook到任何 OC 方法，替换任何类的实现以及新增任意类。举的最多的例子应该就是埋点统计用户信息的例子。假设我们需要在页面上不同的地方统计用户信息，常见做法有两种： 傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。 把统计的代码写入基类中，比如说BaseViewController。这样虽然代码只需要写一次，但是 UITableViewController，UICollectionViewcontroller都需要写一遍，这样重复的代码依旧不少。 基于这两点，我们这时候选用Method Swizzling来解决这个事情最优雅。 Method Swizzling原理Method Swizzing是发生在运行时的，主要用于在运行时将两个Method进行交换，我们可以将Method Swizzling代码写到任何地方，但是只有在这段Method Swilzzling代码执行完毕之后互换才起作用。而且Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式，我们可以利用苹果这一特性来实现AOP编程。Method Swizzling本质上就是对IMP和SEL进行交换。 Method Swizzling使用一般我们使用都是新建一个分类，在分类中进行Method Swizzling方法的交换。交换的代码模板如下： 12345678910111213141516171819202122232425262728293031323334#import &lt;objc/runtime.h&gt;@implementation UIViewController (Swizzling)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; // When swizzling a class method, use the following: // Class class = object_getClass((id)self); SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@\"viewWillAppear: %@\", self);&#125;@end Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在category中添加一个方法。 Method Swizzling注意点Swizzling应该总在+load中执行Objective-C在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用， +initialize方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize方法是永远不会被调用的。所以Swizzling要是写在+initialize方法中，是有可能永远都不被执行。和+initialize比较+load能保证在类的初始化过程中被加载。 关于+load和+initialize的比较可以参看这篇文章《Objective-C +load vs +initialize》 Swizzling应该总是在dispatch_once中执行Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为Method Swizzling的最佳实践。这里有一个很容易犯的错误，那就是继承中用了Swizzling。如果不写dispatch_once就会导致Swizzling失效！ 举个例子，比如同时对NSArray和NSMutableArray中的objectAtIndex:方法都进行了Swizzling，这样可能会导致NSArray中的Swizzling失效的。 可是为什么会这样呢？ 原因是，我们没有用dispatch_once控制Swizzling只执行一次。如果这段Swizzling被执行多次，经过多次的交换IMP和SEL之后，结果可能就是未交换之前的状态。 比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的IMP，子类C持有B方法的IMP，但是再次交换一次，就又还原了。父类A还是持有B方法的IMP，子类C还是持有D方法的IMP，这样就相当于咩有交换。可以看出，如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！ Swizzling在+load中执行时，不要调用[super load]原因同注意点二，如果是多继承，并且对同一个方法都进行了Swizzling，那么调用[super load]以后，父类的Swizzling就失效了。 上述模板中没有错误有些人怀疑我上述给的模板可能有错误。在这里需要讲解一下。在进行Swizzling的时候，我们需要用class_addMethod先进行判断一下原有类中是否有要替换的方法的实现。如果class_addMethod返回NO，说明当前类中有要替换方法的实现，所以可以直接进行替换，调用method_exchangeImplementations即可实现Swizzling。 如果class_addMethod返回YES，说明当前类中没有要替换方法的实现，我们需要在父类中去寻找。这个时候就需要用到method_getImplementation去获取class_getInstanceMethod里面的方法实现。然后再进行class_replaceMethod来实现Swizzling。这是Swizzling需要判断的一点。 还有一点需要注意的是，在我们替换的方法- (void)xxx_viewWillAppear:(BOOL)animated中，调用了[self xxx_viewWillAppear:animated];这不是死循环了么？ 其实这里并不会死循环。 由于我们进行了Swizzling，所以其实在原来的- (void)viewWillAppear:(BOOL)animated方法中，调用的是- (void)xxx_viewWillAppear:(BOOL)animated方法的实现。所以不会造成死循环。相反的，如果这里把[self xxx_viewWillAppear:animated];改成[self viewWillAppear:animated];就会造成死循环。因为外面调用[self viewWillAppear:animated];的时候，会交换方法走到[self xxx_viewWillAppear:animated];这个方法实现中来，然后这里又去调用[self viewWillAppear:animated]，就会造成死循环了。 所以按照上述Swizzling的模板来写，就不会遇到这4点需要注意的问题啦。 Method Swizzling使用场景Method Swizzling使用场景其实有很多很多，在一些特殊的开发需求中适时的使用黑魔法，可以做法神来之笔的效果。这里就举3种常见的场景。 实现AOPAOP的例子在上一篇文章中举了一个例子，在下一章中也打算详细分析一下其实现原理，这里就一笔带过。 实现埋点统计如果app有埋点需求，并且要自己实现一套埋点逻辑，那么这里用到Swizzling是很合适的选择。优点在开头已经分析了，这里不再赘述。看到一篇分析的挺精彩的埋点的文章，推荐大家阅读。 iOS动态性(二)可复用而且高度解耦的用户统计埋点实现 实现异常保护日常开发我们经常会遇到NSArray数组越界的情况，苹果的API也没有对异常保护，所以需要我们开发者开发时候多多留意。关于Index有好多方法，objectAtIndex，removeObjectAtIndex，replaceObjectAtIndex，exchangeObjectAtIndex等等，这些设计到Index都需要判断是否越界。 常见做法是给NSArray，NSMutableArray增加分类，增加这些异常保护的方法，不过如果原有工程里面已经写了大量的AtIndex系列的方法，去替换成新的分类的方法，效率会比较低。这里可以考虑用Swizzling做。 123456789101112131415161718192021222324252627#import \"NSArray+ Swizzling.h\"#import \"objc/runtime.h\"@implementation NSArray (Swizzling)+ (void)load &#123; Method fromMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(objectAtIndex:)); Method toMethod = class_getInstanceMethod(objc_getClass(\"__NSArrayI\"), @selector(swizzling_objectAtIndex:)); method_exchangeImplementations(fromMethod, toMethod);&#125; - (id)swizzling_objectAtIndex:(NSUInteger)index &#123; if (self.count-1 &lt; index) &#123; // 异常处理 @try &#123; return [self swizzling_objectAtIndex:index]; &#125; @catch (NSException *exception) &#123; // 打印崩溃信息 NSLog(@\"---------- %s Crash Because Method %s ----------\\n\", class_getName(self.class), __func__); NSLog(@\"%@\", [exception callStackSymbols]); return nil; &#125; @finally &#123;&#125; &#125; else &#123; return [self swizzling_objectAtIndex:index]; &#125;&#125;@end 注意，调用这个objc_getClass方法的时候，要先知道类对应的真实的类名才行，NSArray其实在Runtime中对应着NSArrayI，NSMutableArray对应着NSArrayM，NSDictionary对应着NSDictionaryI，NSMutableDictionary对应着NSDictionaryM。 Aspect Oriented ProgrammingWikipedia 里对 AOP 是这么介绍的: An aspect can alter the behavior of the base code by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). 类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(Cross-cutting concern)，AOP作用就是分离横向关注点(Cross-cutting concern)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。 接下来分析分析AOP的工作原理。在上一篇中我们分析过了，在objc_msgSend函数查找IMP的过程中，如果在父类也没有找到相应的IMP，那么就会开始执行_class_resolveMethod方法，如果不是元类，就执行_class_resolveInstanceMethod，如果是元类，执行_class_resolveClassMethod。在这个方法中，允许开发者动态增加方法实现。这个阶段一般是给@dynamic属性变量提供动态方法的。如果_class_resolveMethod无法处理，会开始选择备援接受者接受消息，这个时候就到了forwardingTargetForSelector方法。如果该方法返回非nil的对象，则使用该对象作为新的消息接收者。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(Method:))&#123; return otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 同样也可以替换类方法: 123456+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@\"Class name\"); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 替换类方法返回值就是一个类对象。 forwardingTargetForSelector这种方法属于单纯的转发，无法对消息的参数和返回值进行处理。 最后到了完整转发阶段。Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。12345// 为目标对象中被调用的方法返回一个NSMethodSignature实例#warning 运行时系统要求在执行标准转发时实现这个方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; return [self.proxyTarget methodSignatureForSelector:sel];&#125; 对象需要创建一个NSInvocation对象，把消息调用的全部细节封装进去，包括selector, target, arguments 等参数，还能够对返回结果进行处理。 AOP的多数操作就是在forwardInvocation中完成的。一般会分为2个阶段: 一个是Intercepter注册阶段 一个是Intercepter执行阶段。 Intercepter注册首先会把类里面的某个要切片的方法的IMP加入到Aspect中，类方法里面如果有forwardingTargetForSelector:的IMP，也要加入到Aspect中。 然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换。两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:。这样主要的Intercepter注册就完成了。 Intercepter执行当执行func()方法的时候，会去查找它的IMP，现在它的IMP已经被我们替换为了objc_msgForward()方法，于是开始查找备援转发对象。 查找备援接受者调用forwardingTargetForSelector:这个方法，由于这里是被我们hook过的，所以IMP指向的是hook过的forwardingTargetForSelector:方法。这里我们会返回Aspect的target，即选取Aspect作为备援接受者。有了备援接受者之后，就会重新objc_msgSend，从消息发送阶段重头开始。objc_msgSend找不到指定的IMP，再进行_class_resolveMethod，这里也没有找到，forwardingTargetForSelector:这里也不做处理，接着就会methodSignatureForSelector。在methodSignatureForSelector方法中创建一个NSInvocation对象，传递给最终的forwardInvocation方法。Aspect里面的forwardInvocation方法会干所有切面的事情。这里转发逻辑就完全由我们自定义了。Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP，这里我们可以在forwardInvocation方法中去执行这些IMP。在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的。 Isa Swizzling前面第二点谈到了黑魔法Method Swizzling，本质上就是对IMP和SEL进行交换。其实接下来要说的Isa Swizzling，和它类似，本质上也是交换，不过交换的是Isa。在苹果的官方库里面有一个很有名的技术就用到了这个Isa Swizzling，那就是KVO——Key-Value Observing。Key-Value Observing Programming Guide官方文档上对于KVO的定义是这样的: Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 官方给的就这么多，具体实现也没有说的很清楚。那只能我们自己来实验一下。KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。具体实现应该是重写其setter方法即可。官方是如何优雅的实现重写监听类的setter方法的呢？实验代码如下： 123Student *stu = [[Student alloc]init]; [stu addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; 我们可以打印观察isa指针的指向 1234Printing description of stu-&gt;isa: Student Printing description of stu-&gt;isa: NSKVONotifying_Student 通过打印，我们可以很明显的看到，被观察的对象的isa变了，变成了NSKVONotifying_Student这个类了。 在@interface NSObject(NSKeyValueObserverRegistration) 这个分类里面，苹果定义了KVO的方法。 12345- (void)addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context;- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath context:(nullable void *)context NS_AVAILABLE(10_7, 5_0);- (void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath; KVO在调用addObserver方法之后，苹果的做法是在执行完addObserver: forKeyPath: options: context: 方法之后，把isa指向到另外一个类去。在这个新类里面重写被观察的对象四个方法。class，setter，dealloc，_isKVOA。 重写class方法重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。 1234567891011121314151617181920212223242526272829static NSArray * ClassMethodNames(Class c) &#123; NSMutableArray * array = [NSMutableArray array]; unsigned int methodCount = 0; Method * methodList = class_copyMethodList(c, &amp;methodCount); unsigned int i; for(i = 0; i &lt; methodCount; i++) &#123; [array addObject: NSStringFromSelector(method_getName(methodList[i]))]; &#125; free(methodList); return array;&#125; int main(int argc, char * argv[]) &#123; Student *stu = [[Student alloc]init]; ///添加观察者之前 NSLog(@\"self-&gt;isa:%@\",object_getClass(stu)); NSLog(@\"self class:%@\",[stu class]); NSLog(@\"ClassMethodNames = %@\",ClassMethodNames(object_getClass(stu))); [stu addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]; NSLog(@\"self-&gt;isa:%@\",object_getClass(stu)); NSLog(@\"self class:%@\",[stu class]); NSLog(@\"ClassMethodNames = %@\",ClassMethodNames(object_getClass(stu)));&#125; 打印结果 12345678910111213141516self-&gt;isa:Student self class:Student ClassMethodNames = ( \".cxx_destruct\",name, \"setName:\") self-&gt;isa:NSKVONotifying_Student self class:Student ClassMethodNames = ( \"setName:\",class, dealloc, \"_isKVOA\") 这里也可以看出，这是object_getClass方法和class方法的区别。 重写setter方法在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用： 12- (void)willChangeValueForKey:(NSString *)key- (void)didChangeValueForKey:(NSString *)key 在didChangeValueForKey:方法再调用 1234- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context 这里有几种情况需要说明一下： 如果使用了KVC如果有访问器方法，则运行时会在setter方法中调用will/didChangeValueForKey:方法；如果没用访问器方法，运行时会在setValue:forKey方法中调用will/didChangeValueForKey:方法。所以这种情况下，KVO是奏效的。 有访问器方法运行时会重写访问器方法调用will/didChangeValueForKey:方法。 因此，直接调用访问器方法改变属性值时，KVO也能监听到。 直接调用will/didChangeValueForKey:方法。 综上所述，只要setter中重写will/didChangeValueForKey:方法就可以使用KVO了。 重写dealloc方法销毁新生成的NSKVONotifying_类。 重写_isKVOA方法这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。 Foundation 到底为我们提供了哪些用于 KVO 的辅助函数。打开 terminal，使用 nm -a 命令查看 Foundation 中的信息： 1nm -a /System/Library/Frameworks/Foundation.framework/Versions/C/Foundation 里面包含了以下这些KVO中可能用到的函数 12345678910111213141516171800000000000233e7 t __NSSetDoubleValueAndNotify 00000000000f32ba t __NSSetFloatValueAndNotify 0000000000025025 t __NSSetIntValueAndNotify 000000000007fbb5 t __NSSetLongLongValueAndNotify 00000000000f33e8 t __NSSetLongValueAndNotify 000000000002d36c t __NSSetObjectValueAndNotify 0000000000024dc5 t __NSSetPointValueAndNotify 00000000000f39ba t __NSSetRangeValueAndNotify 00000000000f3aeb t __NSSetRectValueAndNotify 00000000000f3512 t __NSSetShortValueAndNotify 00000000000f3c2f t __NSSetSizeValueAndNotify 00000000000f363b t __NSSetUnsignedCharValueAndNotify 000000000006e91f t __NSSetUnsignedIntValueAndNotify 0000000000034b5b t __NSSetUnsignedLongLongValueAndNotify 00000000000f3766 t __NSSetUnsignedLongValueAndNotify 00000000000f3890 t __NSSetUnsignedShortValueAndNotify 00000000000f3060 t __NSSetValueAndNotifyForKeyInIvar 00000000000f30d7 t __NSSetValueAndNotifyForUndefinedKey Foundation 提供了大部分基础数据类型的辅助函数（Objective C中的 Boolean 只是 unsigned char 的 typedef，所以包括了，但没有 C++中的 bool），此外还包括一些常见的结构体如 Point, Range, Rect, Size，这表明这些结构体也可以用于自动键值观察，但要注意除此之外的结构体就不能用于自动键值观察了。对于所有 Objective C 对象对应的是 __NSSetObjectValueAndNotify 方法。 KVO即使是苹果官方的实现，也是有缺陷的，这里有一篇文章详细了分析了KVO中的缺陷，主要问题在KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-addObserver:forKeyPath:options:context:方法所引发的一系列问题。而且只监听一两个属性值还好，如果监听的属性多了, 或者监听了多个对象的属性, 那有点麻烦，需要在方法里面写很多的if-else的判断。最后，官方文档上对于KVO的实现的最后，给出了需要我们注意的一点是，永远不要用用isa来判断一个类的继承关系，而是应该用class方法来判断类的实例。 Associated Object 关联对象Associated Objects是Objective-C 2.0中Runtime的特性之一。众所周知，在 Category 中，我们无法添加@property，因为添加了@property之后并不会自动帮我们生成实例变量以及存取方法。那么，我们现在就可以通过关联对象来实现在 Category 中添加属性的功能了。 用法借用这篇经典文章Associated Objects里面的例子来说明一下用法。 12345678910111213141516// NSObject+AssociatedObject.h@interface NSObject (AssociatedObject)@property (nonatomic, strong) id associatedObject;@end // NSObject+AssociatedObject.m@implementation NSObject (AssociatedObject)@dynamic associatedObject; - (void)setAssociatedObject:(id)object &#123; objc_setAssociatedObject(self, @selector(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125; - (id)associatedObject &#123; return objc_getAssociatedObject(self, @selector(associatedObject));&#125; 这里涉及到了3个函数： 12345678OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); OBJC_EXPORT void objc_removeAssociatedObjects(id object) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_3_1); 来说明一下这些参数的意义： id object 设置关联对象的实例对象 const void *key 区分不同的关联对象的 key。这里会有3种写法。 使用 &amp;AssociatedObjectKey 作为key值 static char AssociatedObjectKey = “AssociatedKey”; 使用AssociatedKey 作为key值 static const void *AssociatedKey = “AssociatedKey”; 使用@selector @selector(associatedKey) 3种方法都可以，不过推荐使用更加简洁的第三种方式。 id value 关联的对象 objc_AssociationPolicy policy 关联对象的存储策略，它是一个枚举，与property的attribute 相对应。 这里需要注意的是标记成OBJC_ASSOCIATION_ASSIGN的关联对象和 @property (weak) 是不一样的，上面表格中等价定义写的是 @property (unsafe_unretained)，对象被销毁时，属性值仍然还在。如果之后再次使用该对象就会导致程序闪退。所以我们在使用OBJC_ASSOCIATION_ASSIGN时，要格外注意。 According to the Deallocation Timeline described in WWDC 2011, Session 322(~36:00), associated objects are erased surprisingly late in the object lifecycle, inobject_dispose(), which is invoked by NSObject -dealloc. 关于关联对象还有一点需要说明的是objc_removeAssociatedObjects。这个方法是移除源对象中所有的关联对象，并不是其中之一。所以其方法参数中也没有传入指定的key。要删除指定的关联对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可。 1objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC); 关联对象3种使用场景 为现有的类添加私有变量 为现有的类添加公有属性 为KVO创建一个关联的观察者。 源码分析objc_setAssociatedObject方法1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; 这个函数里面主要分为2部分，一部分是if里面对应的new_value不为nil的时候，另一部分是else里面对应的new_value为nil的情况。当new_value不为nil的时候，查找时候，流程如下： 首先在AssociationsManager的结构如下 12345678910111213class AssociationsManager &#123; static spinlock_t _lock; static AssociationsHashMap *_map;public: AssociationsManager() &#123; _lock.lock(); &#125; ~AssociationsManager() &#123; _lock.unlock(); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; 在AssociationsManager中有一个spinlock类型的自旋锁lock。保证每次只有一个线程对AssociationsManager进行操作，保证线程安全。AssociationsHashMap对应的是一张哈希表。 AssociationsHashMap哈希表里面key是disguised_ptr_t。 1disguised_ptr_t disguised_object = DISGUISE(object); 通过调用DISGUISE( )方法获取object地址的指针。拿到disguised_object后，通过这个key值，在AssociationsHashMap哈希表里面找到对应的value值。而这个value值ObjcAssociationMap表的首地址。 在ObjcAssociationMap表中，key值是set方法里面传过来的形参const void *key，value值是ObjcAssociation对象。 ObjcAssociation对象中存储了set方法最后两个参数，policy和value。 所以objc_setAssociatedObject方法中传的4个形参在上图中已经标出。 现在弄清楚结构之后再来看源码，就很容易了。objc_setAssociatedObject方法的目的就是在这2张哈希表中存储对应的键值对。 先初始化一个 AssociationsManager，获取唯一的保存关联对象的哈希表 AssociationsHashMap，然后在AssociationsHashMap里面去查找object地址的指针。 如果找到，就找到了第二张表ObjectAssociationMap。在这张表里继续查找object的key。 1234567891011if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125;&#125; 如果在第二张表ObjectAssociationMap找到对应的ObjcAssociation对象，那就更新它的值。如果没有找到，就新建一个ObjcAssociation对象，放入第二张表ObjectAssociationMap中。 再回到第一张表AssociationsHashMap中，如果没有找到对应的键值 1234ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value);object-&gt;setHasAssociatedObjects(); 此时就不存在第二张表ObjectAssociationMap了，这时就需要新建第二张ObjectAssociationMap表，来维护对象的所有新增属性。新建完第二张ObjectAssociationMap表之后，还需要再实例化 ObjcAssociation对象添加到 Map 中，调用setHasAssociatedObjects方法，表明当前对象含有关联对象。这里的setHasAssociatedObjects方法，改变的是isa_t结构体中的第二个标志位has_assoc的值。(关于isa_t结构体的结构，详情请看第一天的解析) 12// release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association); 最后如果老的association对象有值，此时还会释放它。 以上是new_value不为nil的情况。其实只要记住上面那2张表的结构，这个objc_setAssociatedObject的过程就是更新 / 新建 表中键值对的过程。 再来看看new_value为nil的情况 12345678910// setting the association to nil breaks the association.AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125;&#125; 当new_value为nil的时候，就是我们要移除关联对象的时候。这个时候就是在两张表中找到对应的键值，并调用erase( )方法，即可删除对应的关联对象。 objc_getAssociatedObject方法123456789101112131415161718192021222324id _object_get_associative_reference(id object, void *key) &#123; id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; ObjcAssociation &amp;entry = j-&gt;second; value = entry.value(); policy = entry.policy(); if (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((id(*)(id, SEL))objc_msgSend)(value, SEL_retain); &#125; &#125; &#125; if (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123; ((id(*)(id, SEL))objc_msgSend)(value, SEL_autorelease); &#125; return value;&#125; objc_getAssociatedObject方法 很简单。就是通过遍历AssociationsHashMap哈希表 和 ObjcAssociationMap表的所有键值找到对应的ObjcAssociation对象，找到了就返回ObjcAssociation对象，没有找到就返回nil。 objc_removeAssociatedObjects方法12345678910111213141516171819202122232425262728void objc_removeAssociatedObjects(id object) &#123; if (object &amp;&amp; object-&gt;hasAssociatedObjects()) &#123; _object_remove_assocations(object); &#125;&#125; void _object_remove_assocations(id object) &#123; vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i-&gt;second; for (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123; elements.push_back(j-&gt;second); &#125; // remove the secondary table. delete refs; associations.erase(i); &#125; &#125; // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue());&#125; 在移除关联对象object的时候，会先去判断object的isa_t中的第二位has_assoc的值，当object 存在并且object-&gt;hasAssociatedObjects( )值为1的时候，才会去调用_object_remove_assocations方法。 _object_remove_assocations方法的目的是删除第二张ObjcAssociationMap表，即删除所有的关联对象。删除第二张表，就需要在第一张AssociationsHashMap表中遍历查找。这里会把第二张ObjcAssociationMap表中所有的ObjcAssociation对象都存到一个数组elements里面，然后调用associations.erase( )删除第二张表。最后再遍历elements数组，把ObjcAssociation对象依次释放。 以上就是Associated Object关联对象3个函数的源码分析。 动态的增加方法在消息发送阶段，如果在父类中也没有找到相应的IMP，就会执行resolveInstanceMethod方法。在这个方法里面，我们可以动态的给类对象或者实例对象动态的增加方法。 123456789+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; NSString *selectorString = NSStringFromSelector(sel); if ([selectorString isEqualToString:@\"method1\"]) &#123; class_addMethod(self.class, @selector(method1), (IMP)functionForMethod1, \"@:\"); &#125; return [super resolveInstanceMethod:sel];&#125; 关于方法操作方面的函数还有以下这些 1234567891011121314151617181920212223242526// 调用指定方法的实现id method_invoke ( id receiver, Method m, ... ); // 调用返回一个数据结构的方法的实现void method_invoke_stret ( id receiver, Method m, ... ); // 获取方法名SEL method_getName ( Method m ); // 返回方法的实现IMP method_getImplementation ( Method m ); // 获取描述方法参数和返回值类型的字符串const char * method_getTypeEncoding ( Method m ); // 获取方法的返回值类型的字符串char * method_copyReturnType ( Method m ); // 获取方法的指定位置参数的类型字符串char * method_copyArgumentType ( Method m, unsigned int index ); // 通过引用返回方法的返回值类型字符串void method_getReturnType ( Method m, char *dst, size_t dst_len ); // 返回方法的参数的个数unsigned int method_getNumberOfArguments ( Method m ); // 通过引用返回方法指定位置参数的类型字符串void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len ); // 返回指定方法的方法描述结构体struct objc_method_description * method_getDescription ( Method m ); // 设置方法的实现IMP method_setImplementation ( Method m, IMP imp ); // 交换两个方法的实现void method_exchangeImplementations ( Method m1, Method m2 ); 这些方法其实平时不需要死记硬背，使用的时候只要先打出method开头，后面就会有补全信息，找到相应的方法，传入对应的方法即可。 NSCoding的自动归档和自动解档现在虽然手写归档和解档的时候不多了，但是自动操作还是用Runtime来实现的。 12345678910- (void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:self.name forKey:@\"name\"];&#125; - (id)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; self.name = [aDecoder decodeObjectForKey:@\"name\"]; &#125; return self;&#125; 手动的有一个缺陷，如果属性多起来，要写好多行相似的代码，虽然功能是可以完美实现，但是看上去不是很优雅。用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。 12345678910111213141516171819202122232425262728293031323334#import \"Student.h\"#import &lt;objc/runtime.h&gt;#import &lt;objc/message.h&gt; @implementation Student - (void)encodeWithCoder:(NSCoder *)aCoder&#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [self valueForKey:key]; [aCoder encodeObject:value forKey:key]; &#125;&#125; - (nullable __kindof)initWithCoder:(NSCoder *)aDecoder&#123; if (self = [super init]) &#123; unsigned int outCount = 0; Ivar *vars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar var = vars[i]; const char *name = ivar_getName(var); NSString *key = [NSString stringWithUTF8String:name]; id value = [aDecoder decodeObjectForKey:key]; [self setValue:value forKey:key]; &#125; &#125; return self;&#125;@end class_copyIvarList方法用来获取当前 Model 的所有成员变量，ivar_getName方法用来获取每个成员变量的名称。 字典和模型互相转换字典转模型 调用 class_getProperty 方法获取当前 Model 的所有属性。 调用 property_copyAttributeList 获取属性列表。 根据属性名称生成 setter 方法。 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC） 123456789101112131415161718192021222324252627+(id)objectWithKeyValues:(NSDictionary *)aDictionary&#123; id objc = [[self alloc] init]; for (NSString *key in aDictionary.allKeys) &#123; id value = aDictionary[key]; /*判断当前属性是不是Model*/ objc_property_t property = class_getProperty(self, key.UTF8String); unsigned int outCount = 0; objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount); objc_property_attribute_t attribute = attributeList[0]; NSString *typeString = [NSString stringWithUTF8String:attribute.value]; if ([typeString isEqualToString:@\"@\\\"Student\\\"\"]) &#123; value = [self objectWithKeyValues:value]; &#125; //生成setter方法，并用objc_msgSend调用 NSString *methodName = [NSString stringWithFormat:@\"set%@%@:\",[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]]; SEL setter = sel_registerName(methodName.UTF8String); if ([objc respondsToSelector:setter]) &#123; ((void (*) (id,SEL,id)) objc_msgSend) (objc,setter,value); &#125; free(attributeList); &#125; return objc;&#125; 这段代码里面有一处判断typeString的，这里判断是防止model嵌套，比如说Student里面还有一层Student，那么这里就需要再次转换一次，当然这里有几层就需要转换几次。 几个出名的开源库JSONModel、MJExtension等都是通过这种方式实现的(利用runtime的class_copyIvarList获取属性数组，遍历模型对象的所有成员属性，根据属性名找到字典中key值进行赋值，当然这种方法只能解决NSString、NSNumber等，如果含有NSArray或NSDictionary，还要进行第二步转换，如果是字典数组，需要遍历数组中的字典，利用objectWithDict方法将字典转化为模型，在将模型放到数组中，最后把这个模型数组赋值给之前的字典数组) 模型转字典这里是上一部分字典转模型的逆步骤： 调用 class_copyPropertyList 方法获取当前 Model 的所有属性。 调用 property_getName 获取属性名称。 根据属性名称生成 getter 方法。 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC） 1234567891011121314151617181920212223242526272829//模型转字典-(NSDictionary *)keyValuesWithObject&#123; unsigned int outCount = 0; objc_property_t *propertyList = class_copyPropertyList([self class], &amp;outCount); NSMutableDictionary *dict = [NSMutableDictionary dictionary]; for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = propertyList[i]; //生成getter方法，并用objc_msgSend调用 const char *propertyName = property_getName(property); SEL getter = sel_registerName(propertyName); if ([self respondsToSelector:getter]) &#123; id value = ((id (*) (id,SEL)) objc_msgSend) (self,getter); /*判断当前属性是不是Model*/ if ([value isKindOfClass:[self class]] &amp;&amp; value) &#123; value = [value keyValuesWithObject]; &#125; if (value) &#123; NSString *key = [NSString stringWithUTF8String:propertyName]; [dict setObject:value forKey:key]; &#125; &#125; &#125; free(propertyList); return dict;&#125; 中间注释那里的判断也是防止model嵌套，如果model里面还有一层model，那么model转字典的时候还需要再次转换，同样，有几层就需要转换几次。不过上述的做法是假设字典里面不再包含二级字典，如果还包含数组，数组里面再包含字典，那还需要多级转换。这里有一个关于字典里面包含数组的demo. Runtime缺点看了上面八大点之后，是不是感觉Runtime很神奇，可以迅速解决很多问题，然而，Runtime就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：What are the Dangers of Method Swizzling in Objective C?，它的危险性主要体现以下几个方面： Method swizzling is not atomic Method swizzling不是原子性操作。如果在+load方法里面写，是没有问题的，但是如果写在+initialize方法中就会出现一些奇怪的问题。 Changes behavior of un-owned code 如果你在一个类中重写一个方法，并且不调用super方法，你可能会导致一些问题出现。在大多数情况下，super方法是期望被调用的（除非有特殊说明）。如果你使用同样的思想来进行Swizzling，可能就会引起很多问题。如果你不调用原始的方法实现，那么你Swizzling改变的太多了，而导致整个程序变得不安全。 Possible naming conflicts 命名冲突是程序开发中经常遇到的一个问题。我们经常在类别中的前缀类名称和方法名称。不幸的是，命名冲突是在我们程序中的像一种瘟疫。一般我们会这样写Method Swizzling 12345678910111213141516@interface NSView : NSObject- (void)setFrame:(NSRect)frame;@end @implementation NSView (MyViewAdditions) - (void)my_setFrame:(NSRect)frame &#123; // do custom work [self my_setFrame:frame];&#125; + (void)load &#123; [self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)];&#125; @end 这样写看上去是没有问题的。但是如果在整个大型程序中还有另外一处定义了my_setFrame:方法呢？那又会造成命名冲突的问题。我们应该把上面的Swizzling改成以下这种样子： 123456789101112131415@implementation NSView (MyViewAdditions) static void MySetFrame(id self, SEL _cmd, NSRect frame); static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame); static void MySetFrame(id self, SEL _cmd, NSRect frame) &#123; // do custom work SetFrameIMP(self, _cmd, frame);&#125; + (void)load &#123; [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP];&#125; @end 虽然上面的代码看上去不是OC(因为使用了函数指针)，但是这种做法确实有效的防止了命名冲突的问题。原则上来说，其实上述做法更加符合标准化的Swizzling。这种做法可能和人们使用方法不同，但是这种做法更好。Swizzling Method 标准定义应该是如下的样子： 123456789101112131415161718192021typedef IMP *IMPPointer; BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123; IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) &#123; const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) &#123; imp = method_getImplementation(method); &#125; &#125; if (imp &amp;&amp; store) &#123; *store = imp; &#125; return (imp != NULL);&#125; @implementation NSObject (FRRuntimeAdditions)+ (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123; return class_swizzleMethodAndStore(self, original, replacement, store);&#125;@end Swizzling changes the method’s arguments 这一点是这些问题中最大的一个。标准的Method Swizzling是不会改变方法参数的。使用Swizzling中，会改变传递给原来的一个函数实现的参数，例如 1[self my_setFrame:frame]; 会变转换成 1objc_msgSend(self, @selector(my_setFrame:), frame); objcmsgSend会去查找mysetFrame对应的IMP。一旦IMP找到，会把相同的参数传递进去。这里会找到最原始的setFrame:方法，调用执行它。但是这里的cmd参数并不是setFrame:，现在是mysetFrame:。原始的方法就被一个它不期待的接收参数调用了。这样并不好。 这里有一个简单的解决办法，上一条里面所说的，用函数指针去实现。参数就不会变了。 The order of swizzles matters调用顺序对于Swizzling来说，很重要。假设setFrame:方法仅仅被定义在NSView类里面。 123[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)]; 当NSButton被swizzled之后会发生什么呢？大多数的swizzling应该保证不会替换setFrame:方法。因为一旦改了这个方法，会影响下面所有的View。所以它会去拉取实例方法。NSButton会使用已经存在的方法去重新定义setFrame:方法。以至于改变了IMP实现不会影响所有的View。相同的事情也会发生在对NSControl进行swizzling的时候，同样，IMP也是定义在NSView类里面，把NSControl 和 NSButton这上下两行swizzle顺序替换，结果也是相同的。 当调用NSButton的setFrame:方法，会去调用swizzled method，然后会跳入NSView类里面定义的setFrame:方法。NSControl 和 NSView对应的swizzled method不会被调用。 NSButton 和 NSControl各自调用各自的 swizzling方法，相互不会影响。 但是我们改变一下调用顺序，把NSView放在第一位调用。 123[NSView swizzle:@selector(setFrame:) with:@selector(my_viewSetFrame:)];[NSControl swizzle:@selector(setFrame:) with:@selector(my_controlSetFrame:)];[NSButton swizzle:@selector(setFrame:) with:@selector(my_buttonSetFrame:)]; 一旦这里的NSView先进行了swizzling了以后，情况就和上面大不相同了。NSControl的swizzling会去拉取NSView替换后的方法。相应的，NSControl在NSButton前面，NSButton也会去拉取到NSControl替换后的方法。这样就十分混乱了。但是顺序就是这样排列的。我们开发中如何能保证不出现这种混乱呢？ 再者，在load方法中加载swizzle。如果仅仅是在已经加载完成的class中做了swizzle，那么这样做是安全的。load方法能保证父类会在其任何子类加载方法之前，加载相应的方法。这就保证了我们调用顺序的正确性。 Difficult to understand (looks recursive) 看着传统定义的swizzled method，我认为很难去预测会发生什么。但是对比上面标准的swizzling，还是很容易明白。这一点已经被解决了。 Difficult to debug 在调试中，会出现奇怪的堆栈调用信息，尤其是swizzled的命名很混乱，一切方法调用都是混乱的。对比标准的swizzled方式，你会在堆栈中看到清晰的命名方法。swizzling还有一个比较难调试的一点， 在于你很难记住当前确切的哪个方法已经被swizzling了。 在代码里面写好文档注释，即使你认为这段代码只有你一个人会看。遵循这个方式去实践，你的代码都会没问题。它的调试也没有多线程的调试困难。 最后经过在“神经病院”3天的修炼之后，对OC 的Runtime理解更深了。 关于黑魔法Method swizzling，我个人觉得如果使用得当，还是很安全的。一个简单而安全的措施是你仅仅只在load方法中去swizzle。和编程中很多事情一样，不了解它的时候会很危险可怕，但是一旦明白了它的原理之后，使用它又会变得非常正确高效。 对于多人开发，尤其是改动过Runtime的地方，文档记录一定要完整。如果某人不知道某个方法被Swizzling了，出现问题调试起来，十分蛋疼。 如果是SDK开发，某些Swizzling会改变全局的一些方法的时候，一定要在文档里面标注清楚，否则使用SDK的人不知道，出现各种奇怪的问题，又要被坑好久。 在合理使用 + 文档完整齐全 的情况下，解决特定问题，使用Runtime还是非常简洁安全的。 日常可能用的比较多的Runtime函数可能就是下面这些 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//获取cls类对象所有成员ivar结构体Ivar *class_copyIvarList(Class cls, unsigned int *outCount) //获取cls类对象name对应的实例方法结构体Method class_getInstanceMethod(Class cls, SEL name) //获取cls类对象name对应类方法结构体Method class_getClassMethod(Class cls, SEL name) //获取cls类对象name对应方法imp实现IMP class_getMethodImplementation(Class cls, SEL name) //测试cls对应的实例是否响应sel对应的方法BOOL class_respondsToSelector(Class cls, SEL sel) //获取cls对应方法列表Method *class_copyMethodList(Class cls, unsigned int *outCount) //测试cls是否遵守protocol协议BOOL class_conformsToProtocol(Class cls, Protocol *protocol) //为cls类对象添加新方法BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) //替换cls类对象中name对应方法的实现IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) //为cls添加新成员BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) //为cls添加新属性BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) //获取m对应的选择器SEL method_getName(Method m) //获取m对应的方法实现的imp指针IMP method_getImplementation(Method m) //获取m方法的对应编码const char *method_getTypeEncoding(Method m) //获取m方法参数的个数unsigned int method_getNumberOfArguments(Method m) //copy方法返回值类型char *method_copyReturnType(Method m) //获取m方法index索引参数的类型char *method_copyArgumentType(Method m, unsigned int index) //获取m方法返回值类型void method_getReturnType(Method m, char *dst, size_t dst_len) //获取方法的参数类型void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len) //设置m方法的具体实现指针IMP method_setImplementation(Method m, IMP imp) //交换m1，m2方法对应具体实现的函数指针void method_exchangeImplementations(Method m1, Method m2) //获取v的名称const char *ivar_getName(Ivar v) //获取v的类型编码const char *ivar_getTypeEncoding(Ivar v) //设置object对象关联的对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取object关联的对象id objc_getAssociatedObject(id object, const void *key) //移除object关联的对象void objc_removeAssociatedObjects(id object) 这些API看上去不好记，其实使用的时候不难，关于方法操作的，一般都是method开头，关于类的，一般都是class开头的，其他的基本都是objc开头的，剩下的就看代码补全的提示，看方法名基本就能找到想要的方法了。当然很熟悉的话，可以直接打出指定方法，也不会依赖代码补全。 还有一些关于协议相关的API以及其他一些不常用，但是也可能用到的，就需要查看Objective-C Runtime官方API文档，这个官方文档里面详细说明，平时不懂的多看看文档。 涉及的资料 Objective-C Runtime Programming Guide 《Objective-C +load vs +initialize》 iOS动态性(二)可复用而且高度解耦的用户统计埋点实现 Key-Value Observing Programming Guide KVO中的缺陷 What are the Dangers of Method Swizzling in Objective C?","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"神经病院Objective-C Runtime入院系列文章","slug":"IOS/Runtime/神经病院Objective-C-Runtime入院系列文章","permalink":"http://yoursite.com/categories/IOS/Runtime/神经病院Objective-C-Runtime入院系列文章/"}]},{"title":"NSInvocation的基本使","date":"2016-11-24T07:35:49.000Z","path":"wiki/IOS/foundation使用记录/NSInvocation的基本使/","text":"iOS中可以间接向对象发送消息方式有两种： 使用performSelector:withObject； 使用NSInvocation。performSelector:withObject能完成简单的调用。但是对于大于2个的参数或者有返回值的消息，它就显得有点有心无力了，那么在这种情况下，我们就可以使用NSInvocation来进行这些相对复杂的操作。 方法签名An NSMethodSignature object records type information for the return value and parameters of a method. It is used to forward messages that the receiving object does not respond to—most notably in the case of distributed objects.NSMethodSignature对象记录了方法的参数和返回值的类型信息。它被用于转发接受者不能处理的消息。 You typically create an NSMethodSignature object using the NSObject methodSignatureForSelector: instance method . It is then used to create an NSInvocation object,。 NSObject的实例方法methodSignatureForSelector:是创建NSMethodSignature对象的典型方法。 使用NSMethodSignature对象用于创建NSInvocation 对象(通过NSInvocation的invocationWithMethodSignature:类方法)。下面是创建方法签名的代码： ///1. 创建方法签名 NSMethodSignature *signature = [ViewController instanceMethodSignatureForSelector:@selector(fucWithName:)]; if (signature == nil) { return; } 使用numberOfArguments获取方法的参数个数，参数个数比sel多两个隐藏参数，一个是self,一个是_cmd。页可以使用getArgumentTypeAtIndex:获取参数。还可以使用methodReturnType获取返回类型。 使用NSInvocation发送消息///2、创建NSInvocation对象 NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; invocation.target = self; //注意：这里的方法名一定要与方法签名类中的方法一致 invocation.selector = @selector(fucWithName:); NSString *strName = @&quot;dog&quot;; //这里的Index要从2开始，以为0跟1已经被占据了，分别是self（target）,selector(_cmd) [invocation setArgument:&amp;strName atIndex:2]; //3、调用invoke方法 [invocation invoke]; id res = nil; if (signature.methodReturnLength != 0) { [invocation getReturnValue:&amp;res]; } NSLog(@&quot;res = %@&quot;,res); 首先使用invocationWithMethodSignature:创建一个NSInvocation对象，然后设置对象的target、selector。NSInvocation对象实际上就是将方法封装为对象。然后使用invoke方法调用消息。使用getReturnValue获取返回值。输出的结果如下： ViewController object receive message functionWithName: res = dog","tags":[{"name":"NSInvocation","slug":"NSInvocation","permalink":"http://yoursite.com/tags/NSInvocation/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"foundation使用记录","slug":"IOS/foundation使用记录","permalink":"http://yoursite.com/categories/IOS/foundation使用记录/"}]},{"title":"第二天--消息发送与转发（转载)","date":"2016-11-22T02:38:11.000Z","path":"wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/secondDay/","text":"现在越来越多的app都使用了JSPatch实现app热修复，而JSPatch 能做到通过 JS 调用和改写 OC 方法最根本的原因是 Objective-C 是动态语言，OC 上所有方法的调用/类的生成都通过 Objective-C Runtime 在运行时进行，我们可以通过类名/方法名反射得到相应的类和方法，也可以替换某个类的方法为新的实现，理论上你可以在运行时通过类名/方法名调用到任何 OC 方法，替换任何类的实现以及新增任意类。今天就来详细解析一下OC中runtime最为吸引人的地方。 消息发送阶段—objc_msgSend函数简介最初接触到OC Runtime，一定是从[receiver message]这里开始的。[receiver message]会被编译器转化为： 1id objc_msgSend ( id self, SEL op, ... ); 这是一个可变参数函数。第二个参数类型是SEL。SEL在OC中是selector方法选择器。 1typedef struct objc_selector *SEL; objc_selector是一个映射到方法的C字符串。需要注意的是@selector()选择子只与函数名有关。不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。由于这点特性，也导致了OC不支持函数重载。 在receiver拿到对应的selector之后，如果自己无法执行这个方法，那么该条消息要被转发。或者临时动态的添加方法实现。如果转发到最后依旧没法处理，程序就会崩溃。 所以编译期仅仅是确定了要发送消息，而消息如何处理是要运行期需要解决的事情。 objc_msgSend函数究竟会干什么事情呢？从这篇objc_msgSend() Tour文章里面可以得到一个比较详细的结论。 Check for ignored selectors (GC) and short-circuit. Check for nil target. If nil &amp; nil receiver handler configured, jump to handler If nil &amp; no handler (default), cleanup and return. Search the class’s method cache for the method IMP(use hash to find&amp;store method in cache) If found, jump to it. Not found: lookup the method IMP in the class itself corresponding its hierarchy chain. If found, load it into cache and jump to it. If not found, jump to forwarding mechanism.总结一下objc_msgSend会做一下几件事情： 检测这个 selector是不是要忽略的。 检查target是不是为nil。 如果这里有相应的nil的处理函数，就跳转到相应的函数中。 如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。 如果找到，就跳转进去执行。 如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止。 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程。 消息发送阶段—objc_msgSend源码解析在这篇文章Obj-C Optimization: The faster objc_msgSend中看到了这样一段C版本的objc_msgSend的源码。 123456789101112131415161718192021222324252627282930313233#include &lt;objc/objc-runtime.h&gt;id c_objc_msgSend( struct objc_class /* ahem */ *self, SEL _cmd, ...) &#123; struct objc_class *cls; struct objc_cache *cache; unsigned int hash; struct objc_method *method; unsigned int index; if( self) &#123; cls = self-&gt;isa; cache = cls-&gt;cache; hash = cache-&gt;mask; index = (unsigned int) _cmd &amp; hash; do &#123; method = cache-&gt;buckets[ index]; if( ! method) goto recache; index = (index + 1) &amp; cache-&gt;mask; &#125; while( method-&gt;method_name != _cmd); return( (*method-&gt;method_imp)( (id) self, _cmd)); &#125; return( (id) self); recache: /* ... */ return( 0);&#125; 该源码中有一个do-while循环，这个循环就是上一章里面提到的在方法分发表里面查找method的过程。不过在obj4-680里面的objc-msg-x86_64.s文件中实现是一段汇编代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344 /******************************************************************** * * id objc_msgSend(id self, SEL _cmd,...); * ********************************************************************/ .data .align 3 .globl _objc_debug_taggedpointer_classes_objc_debug_taggedpointer_classes: .fill 16, 8, 0 ENTRY _objc_msgSend MESSENGER_START NilTest NORMAL GetIsaFast NORMAL // r11 = self-&gt;isa CacheLookup NORMAL // calls IMP on success NilTestSupport NORMAL GetIsaSupport NORMAL // cache miss: go search the method listsLCacheMiss: // isa still in r11 MethodTableLookup %a1, %a2 // r11 = IMP cmp %r11, %r11 // set eq (nonstret) for forwarding jmp *%r11 // goto *imp END_ENTRY _objc_msgSend ENTRY _objc_msgSend_fixup int3 END_ENTRY _objc_msgSend_fixup STATIC_ENTRY _objc_msgSend_fixedup // Load _cmd from the message_ref movq 8(%a2), %a2 jmp _objc_msgSend END_ENTRY _objc_msgSend_fixedup 来分析一下这段汇编代码。 乍一看，如果从LCacheMiss:这里上下分开，可以很明显的看到objc_msgSend就干了两件事情—— CacheLookup 和 MethodTableLookup。 123456789101112131415161718192021222324///////////////////////////////////////////////////////////////////////// NilTest return-type//// Takes: $0 = NORMAL or FPRET or FP2RET or STRET// %a1 or %a2 (STRET) = receiver//// On exit: Loads non-nil receiver in %a1 or %a2 (STRET), or returns zero./////////////////////////////////////////////////////////////////////// .macro NilTest.if $0 == SUPER || $0 == SUPER_STRET error super dispatch does not test for nil.endif .if $0 != STRET testq %a1, %a1.else testq %a2, %a2.endif PN jz LNilTestSlow_f.endmacro NilTest是用来检测是否为nil的。传入参数有4种，NORMAL / FPRET / FP2RET / STRET。 objc_msgSend 传入的参数是NilTest NORMAL objc_msgSend_fpret 传入的参数是NilTest FPRET objc_msgSend_fp2ret 传入的参数是NilTest FP2RET objc_msgSend_stret 传入的参数是NilTest STRET 如果检测方法的接受者是nil，那么系统会自动clean并且return。 GetIsaFast宏可以快速地获取到对象的 isa 指针地址（放到 r11 寄存器，r10会被重写；在 arm 架构上是直接赋值到 r9） 12345678910111213141516171819202122232425262728.macro CacheLookup ldrh r12, [r9, #CACHE_MASK] // r12 = mask ldr r9, [r9, #CACHE] // r9 = buckets.if $0 == STRET || $0 == SUPER_STRET and r12, r12, r2 // r12 = index = SEL &amp; mask.else and r12, r12, r1 // r12 = index = SEL &amp; mask.endif add r9, r9, r12, LSL #3 // r9 = bucket = buckets+index*8 ldr r12, [r9] // r12 = bucket-&gt;sel2: .if $0 == STRET || $0 == SUPER_STRET teq r12, r2.else teq r12, r1.endif bne 1f CacheHit $01: cmp r12, #1 blo LCacheMiss_f // if (bucket-&gt;sel == 0) cache miss it eq // if (bucket-&gt;sel == 1) cache wrap ldreq r9, [r9, #4] // bucket-&gt;imp is before first bucket ldr r12, [r9, #8]! // r12 = (++bucket)-&gt;sel b 2b .endmacro r12里面存的是方法method，r9里面是cache。r1，r2是SEL。在这个CacheLookup函数中，不断的通过SEL与cache中的bucket-&gt;sel进行比较，如果r12 = = 0，则跳转到LCacheMiss_f标记去继续执行。如果r12找到了,r12 = =1，即在cache中找到了相应的SEL，则直接执行该IMP(放在r10中)。 程序跳到LCacheMiss，就说明cache中无缓存，未命中缓存。这个时候就要开始下一阶段MethodTableLookup的查找了。 123456789101112131415161718192021222324252627282930///////////////////////////////////////////////////////////////////////// MethodTableLookup classRegister, selectorRegister//// Takes: $0 = class to search (a1 or a2 or r10 ONLY)// $1 = selector to search for (a2 or a3 ONLY)// r11 = class to search//// On exit: imp in %r11///////////////////////////////////////////////////////////////////////.macro MethodTableLookup MESSENGER_END_SLOW SaveRegisters // _class_lookupMethodAndLoadCache3(receiver, selector, class) movq $0, %a1 movq $1, %a2 movq %r11, %a3 call __class_lookupMethodAndLoadCache3 // IMP is now in %rax movq %rax, %r11 RestoreRegisters .endmacro MethodTableLookup 可以算是个接口层宏，主要用于保存环境与准备参数，来调用 __class_lookupMethodAndLoadCache3函数（在objc-class.mm中）。具体是把receiver, selector, class三个参数传给$0，$1，r11，然后再去调用lookupMethodAndLoadCache3方法。最后会将 IMP 返回（从 r11 挪到 rax）。最后在 objc_msgSend中调用 IMP。 12345678910111213/************************************************************************ _class_lookupMethodAndLoadCache.* Method lookup for dispatchers ONLY. OTHER CODE SHOULD USE lookUpImp().* This lookup avoids optimistic cache scan because the dispatcher * already tried that.这个查找方法的函数只能被 dispatchers （也就是 objc_msgSend、objc_msgSend_stret 等函数）使用其他的代码应该使用 lookUpImp() 函数这个函数避免了扫描缓存，因为 dispatchers 已经尝试过扫描缓存了，正是因为缓存中没有找到，才调用这个方法找的**********************************************************************/IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls) &#123; return lookUpImpOrForward(cls, sel, obj, YES/*initialize*/, NO/*cache*/, YES/*resolver*/);&#125; __class_lookupMethodAndLoadCache3函数也是个接口层（C编写），此函数提供相应参数配置，实际功能在lookUpImpOrForward函数中。再来看看lookUpImpOrForward函数实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233/************************************************************************ lookUpImpOrForward.* The standard IMP lookup. * initialize==NO tries to avoid +initialize (but sometimes fails)* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)* Most callers should use initialize==YES and cache==YES.* inst is an instance of cls or a subclass thereof, or nil if none is known. * If cls is an un-initialized metaclass then a non-nil inst is faster.* May return _objc_msgForward_impcache. IMPs destined for external use * must be converted to _objc_msgForward or _objc_msgForward_stret.* If you don't want forwarding at all, use lookUpImpOrNil() instead.**********************************************************************/// 标准的查找 IMP 的函数// 在 cls 类以及父类中寻找 sel 对应的 IMP，// initialize == NO 表示尝试避免触发 +initialize (但有时失败)，// cache == NO 表示跳过 optimistic unlocked lookup，即跳过前面不加锁的部分对缓存的查找，但是在 retry 里加锁的部分还是会优先查找缓存// 大多数调用者应该用 initialize==YES and cache==YES.// inst 是这个类的实例，或者它的子类的实例，也可能是 nil，// 如果这个类是一个不是 initialized 状态的元类，那么 obj 非空的话，会快一点，// resolver == YES 的话，如果在缓存和方法列表中都没有找到 IMP，就会进行 resolve，尝试动态添加方法// 有可能返回 _objc_msgForward_impcache。IMPs 被用作外部的使用时（转发？？），一定要转为 _objc_msgForward 或者 _objc_msgForward_stret// 如果确实不想转发，就用 lookUpImpOrNil() 代替IMP lookUpImpOrForward(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; Class curClass; IMP imp = nil; Method meth; // 用来标记是否尝试过 resolver，调用 _class_resolveMethod 后就置为 YES， // 即使再 retry 也不会再 resolver，详情自己在下面找 bool triedResolver = NO; runtimeLock.assertUnlocked(); // 确定 runtimeLock 已经解锁 // Optimistic cache lookup if (cache) &#123; // 如果指定了需要在缓存中查找，这时是不加锁的，这是与 retry 部分的缓存查找最大的不同 imp = cache_getImp(cls, sel); // 就在缓存中找 if (imp) &#123; return imp; // 如果很幸运得在缓存中找到了，就将找到的 IMP 返回，注意哦，有可能找到的是 _objc_msgForward_impcache 函数 // 这个函数会进行消息转发 &#125; &#125; // 如果 cls 还没被 realized，就将 cls 类 realize 了 if (!cls-&gt;isRealized()) &#123; // runtimeLock 加写锁 rwlock_writer_t lock(runtimeLock); // 将 cls 类 realize 了，realizeClass() 函数里还会顺便把 cls 类的父类和元类也一并 realize 了 // 当然这会造成递归，会把 cls 往上的所有没 realize 的祖宗类和 cls类的元类往上所有没有被 realize 的元类都 realize 了 realizeClass(cls); &#125; // 如果 cls 类还不是 initialized 状态，并且指定了需要 initialize 的话，就将它 initialize 了 if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; // 1. 先调用 _class_getNonMetaClass() 取得 cls 的实例类 // 如果 cls 不是元类的话，_class_getNonMetaClass 返回的就是 cls 本身 // 如果 cls 是元类，就找到它对应的实例类 // 2. 对 _class_getNonMetaClass 返回的类进行 initialize， // 其中如果父类没有初始化，会将父类也初始化了；其中会有递归，在完成 cls 的初始化工作之前，会将所有祖宗类都完成初始化， // 如果有 cls 类或者其中有个祖宗类正在其他线程上被初始化，本线程还会挂起等待，所以这都是串行并且线程安全的， // 类的状态会从 未初始化 -&gt; initializing -&gt; initialized _class_initialize (_class_getNonMetaClass(cls, inst)); // If sel == initialize, _class_initialize will send +initialize and // then the messenger will send +initialize again after this // procedure finishes. Of course, if this is not being called // from the messenger then it won't happen. 2778172 /* 这段话是说，如果 sel 本身就是 initialize 方法的话，因为 _class_initialize 中会调用 +initialize 方法， 所以本函数结束以后，会再一次调用 +initialize 方法，也就是 +initialize 会悲催地走两次。 +initialize 方法的调用与普通方法的调用是一样的，走的都是发送消息的流程。换言之，如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。 因此，如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。有时候，这可能是你想要的；但如果我们想确保自己的 +initialize 方法只执行一次，避免多次执行可能带来的副作用时，我们可以使用下面的代码来实现： + (void)initialize &#123; if (self == [ClassName self]) &#123; // ... do the initialization ... &#125; &#125; 或者使用： + (void)initialize &#123; static BOOL b = false; if (!b) &#123; NSLog(@\"Person initialize\"); b = true; &#125; &#125; */ &#125; // The lock is held to make method-lookup + cache-fill atomic // with respect to method addition. Otherwise, a category could // be added but ignored indefinitely because the cache was re-filled // with the old value after the cache flush on behalf of the category. // 这个锁是用来实现 方法查找 + 填充缓存 两个步骤的原子性的, // 否则，一个分类被添加进来后有可能被无限期地忽略， // 添加分类的时候会清空缓存，见 attachCategories() 函数，而调用 attachCategories() 函数之前都对 runtimeLock 加写锁， // 设想下，如果没有 runtimeLock 读写锁的存在，那么就可能会出现下面的情况： // 1. 线程 1 method-lookup 方法查找 找到了老的 IMP， // 2. 线程 2 attachCategories() 函数中添加完分类并清空方法缓存， // 3. 线程 1 cache-fill 将老的 IMP 插进了缓存中 // 这时，缓存中存的还是老的 IMP，之后 objc_msgSend 函数在缓存中找到的也都是老的 IMP，通过分类添加的新的方法就被忽略了 retry: // 进行 resolve 后，会进行一次 retry，即重新查一次 IMP，如果这回再找不到，就会进行消息转发 runtimeLock.read(); // runtimeLock 加读锁，原因见上面 // Ignore GC selectors if (ignoreSelector(sel)) &#123; // 查看 sel 是否需要被忽略 imp = _objc_ignored_method; // 被忽略的 sel，会被分配 _objc_ignored_method 为 IMP， // 这与 _objc_ignored_method() 的做法是一致的 // _objc_ignored_method 的实现源码也在 objc_msg_arm.s 文件中 cache_fill(cls, sel, imp, inst); // 将 sel 和 imp(_objc_ignored_method) 插入到缓存中 goto done; // 就算是已经确定 IMP 了，完成，跳到 done &#125; // Try this class's cache. // 再在缓存中查找一次，与函数开头的缓存查找不同的是，现在是加了读锁的 // 还有个不同是，这时可能是 retry，即命中的这个 IMP 可能是 resolve 成功时插入到缓存中的 imp = cache_getImp(cls, sel); if (imp) &#123; goto done; // 找到就跳到 done &#125; // Try this class's method lists. meth = getMethodNoSuper_nolock(cls, sel); // 在 cls 类中搜索 sel 对应的方法，NoSuper 即不在 cls 的父类中查找 if (meth) &#123; // 如果找到了，就将 meth 中的 IMP 和 sel 一并存入缓存 log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); // 存起来，后面需要返回 imp imp = meth-&gt;imp; goto done; &#125; // Try superclass caches and method lists. // 缓存中没有、cls 类中也没有，只能沿着 cls 类的祖宗类一路向上寻找了 curClass = cls; // 先从父类开始找，直到找到 NSObject 类，NSObject 类没有父类，就停止循环了 while ((curClass = curClass-&gt;superclass)) &#123; // Superclass cache. // 在 curClass 类的缓存中寻找 imp = cache_getImp(curClass, sel); if (imp) &#123; // 如果找到了，并且 IMP 不是 _objc_msgForward_impcache // 即不是消息转发，就将 IMP 放入 cls 类的方法缓存中 // 一定要注意哦，是 cls 类的方法缓存，不是 curClass 类的方法缓存 // 因为我们在为 cls 类寻找 IMP，最后存在 cls 类的方法缓存中，也有利于以后对 cls 类的方法调用，即各自类缓存各自的 IMP，互不干扰，查起来即简单又快 if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. // 找到一个消息转发，就停止寻找，但是不缓存， // 先对这个 curClass 类调用 resolver 方法，即 +resolveInstanceMethod 和 +resolveClassMethod // 这两个方法可以给程序员动态添加 实例方法 和 类方法 的机会 break; &#125; &#125; // Superclass method list. // 缓存中没找到，就只能在 curClass 类的方法列表中查找 meth = getMethodNoSuper_nolock(curClass, sel); // 如果找到了，就将方法的 IMP 插入 cls 类的方法缓存中，注意，是 cls 类的方法缓存 if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; // 保存一下 imp，后面返回用 goto done; &#125; &#125; // No implementation found. Try method resolver once. // 找不到 IMP，尝试一次 resolver，即调用 +resolveInstanceMethod 和 +resolveClassMethod // 但是必须指定需要 resolver，并且没有尝试过 resolver，才能进行 resolver // retry 最多只会进行一次，即 resolve 只有一次机会，如果还不成功，就进行完整的消息转发 if (resolver &amp;&amp; !triedResolver/*没有尝试过resolver*/) &#123; runtimeLock.unlockRead(); // 释放 runtimeLock 的读锁，retry 的时候会再加上读锁 _class_resolveMethod(cls, sel, inst); // 调用 _class_resolveMethod() 尝试 resolve // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. // 不缓存结果，我们释放了读锁，所以结果是不可信的，中间过程中很有可能已经有其他的线程修改了它 // 进行 retry 时，会重新获得读锁，并重新进行搜索 triedResolver = YES; goto retry; &#125; // No implementation found, and method resolver didn't help. // Use forwarding. // 任何方法都失败了，resolve 也失败了，就进行完整的消息转发，返回这个消息转发函数 imp = (IMP)_objc_msgForward_impcache; // 将 _objc_msgForward_impcache 作为 sel 对应的 IMP 插入到缓存中 cache_fill(cls, sel, imp, inst); done: runtimeLock.unlockRead(); // 释放读锁 // paranoia: look for ignored selectors with non-ignored implementations // sel 必须不能是需要忽略的 SEL，且 imp 必须不是 _objc_ignored_method // 因为如果是这种情况，在上面就应该已经返回了，绝不应该走到这里 assert(!(ignoreSelector(sel) &amp;&amp; imp != (IMP)&amp;_objc_ignored_method)); // paranoia: never let uncached leak out // imp 必须不能是 _objc_msgSend_uncached_impcache 函数，绝不能泄漏未命中的缓存 // 我猜，如果返回 _objc_msgSend_uncached_impcache 的话，因为 _objc_msgSend_uncached_impcache 中会调用 _class_lookupMethodAndLoadCache3() 函数，而 _class_lookupMethodAndLoadCache3() 又会调用 lookUpImpOrForward，即本函数，那么就反反复复死循环了 // 理解 _objc_msgSend_uncached_impcache 函数需要看 objc_msg_arm.s 中的 STATIC_ENTRY _objc_msgSend_uncached_impcache // 它也只在汇编中用到，其他地方并没有用到这个函数 assert(imp != _objc_msgSend_uncached_impcache); return imp;&#125; 下面来分析代码，整个代码的目的是查找IMP。 调用cache_getImp 在缓存中查找，如果找到，直接返回，其中cache_getImp在objc-msg-x86_64.s里面，是汇编语言实现。 调用realizeClass，实现Class。 将class的bits成员变量从ro转化为rw ，转化后，bits 指向class_rw_t rw，rw中的ro指向原来的ro。 更新superclass. 调用reconcileInstanceVariables重建成员变量 调用addSubclass 给父类添加一个子类 调用methodizeClass，将分类中的方法列表、属性列表、协议列表加载到 methods、 properties 和 protocols 列表数组中，并且添加categories 进入retry 流程，resolve后，还会进入到这里，重新查找imp。下面都是retry流程 判断是否是忽略的消息，忽略的消息就是垃圾回收的消息，包括release，autorelease，retainCount，dealloc。IOS不支持垃圾回收（GC），所以没有忽略的消息 调用cache_getImp，再一次在缓存中查找imp 调用getMethodNoSuper_nolock，在Class 中查找sel,返回的是method_t，不是IMP。查找方法是枚举cls-&gt;bits-&gt;methods方法列表。 循环class的superclass，查找imp，查找方法先用cache_getImp找，后用getMethodNoSuper_nolock找。 如果步骤4-7任何一步找到，都会调用cache_fill缓存方法。跳转到done 流程。 调用class_resolveMethod 尝试解决方法 。如果成功，跳转到步骤4。 如果还是没有找到，调用_objc_msgForward_impcache 进行完整的消息转发流程。 接下来一行行的解析。 1runtimeLock.assertUnlocked(); runtimeLock.assertUnlocked(); 这个是加一个读写锁，保证线程安全。 12345// Optimistic cache lookupif (cache) &#123; imp = cache_getImp(cls, sel); if (imp) return imp;&#125; lookUpImpOrForward第5个新参是是否找到cache的布尔量，如果传入的是YES，那么就会调用cache_getImp方法去找到缓存里面的IMP。 1234567891011121314151617181920212223/******************************************************************** * IMP cache_getImp(Class cls, SEL sel) * * On entry: a1 = class whose cache is to be searched * a2 = selector to search for * * If found, returns method implementation. * If not found, returns NULL. ********************************************************************/ STATIC_ENTRY _cache_getImp// do lookup movq %a1, %r11 // move class to r11 for CacheLookup CacheLookup GETIMP // returns IMP on successLCacheMiss:// cache miss, return nil xorl %eax, %eax retLGetImpExit: END_ENTRY _cache_getImp cache_getImp会把找到的IMP放在r11中。 1234if (!cls-&gt;isRealized()) &#123; rwlock_writer_t lock(runtimeLock); realizeClass(cls);&#125; 调用realizeClass方法是申请class_rw_t的可读写空间。 123if (initialize &amp;&amp; !cls-&gt;isInitialized()) &#123; _class_initialize (_class_getNonMetaClass(cls, inst));&#125; _class_initialize是类初始化的过程。 12retry: runtimeLock.read(); runtimeLock.read();这里加了一个读锁。因为在运行时中会动态的添加方法，为了保证线程安全，所以要加锁。从这里开始，下面会出现5处goto done的地方，和一处goto retry。 12done: runtimeLock.unlockRead(); 在done的地方，会完成IMP的查找，于是可以打开读锁 123456// Ignore GC selectorsif (ignoreSelector(sel)) &#123; imp = _objc_ignored_method; cache_fill(cls, sel, imp, inst); goto done;&#125; 紧接着GC selectors是为了忽略macOS中GC垃圾回收机制用到的方法，iOS则没有这一步。如果忽略，则进行cache_fill，然后跳转到goto done那里去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void cache_fill(Class cls, SEL sel, IMP imp, id receiver)&#123;#if !DEBUG_TASK_THREADS mutex_locker_t lock(cacheUpdateLock); cache_fill_nolock(cls, sel, imp, receiver);#else _collecting_in_critical(); return;#endif&#125;static void cache_fill_nolock(Class cls, SEL sel, IMP imp, id receiver)&#123; cacheUpdateLock.assertLocked(); // Never cache before +initialize is done if (!cls-&gt;isInitialized()) return; // Make sure the entry wasn't added to the cache by some other thread // before we grabbed the cacheUpdateLock. if (cache_getImp(cls, sel)) return; cache_t *cache = getCache(cls); cache_key_t key = getKey(sel); // Use the cache as-is if it is less than 3/4 full mask_t newOccupied = cache-&gt;occupied() + 1; mask_t capacity = cache-&gt;capacity(); if (cache-&gt;isConstantEmptyCache()) &#123; // Cache is read-only. Replace it. cache-&gt;reallocate(capacity, capacity ?: INIT_CACHE_SIZE); &#125; else if (newOccupied &lt;= capacity / 4 * 3) &#123; // Cache is less than 3/4 full. Use it as-is. &#125; else &#123; // Cache is too full. Expand it. cache-&gt;expand(); &#125; bucket_t *bucket = cache-&gt;find(key, receiver); if (bucket-&gt;key() == 0) cache-&gt;incrementOccupied(); bucket-&gt;set(key, imp);&#125; 在cache_fill中还会去调用cache_fill_nolock函数，如果缓存中的内容大于容量的 3/4就会扩充缓存，使缓存的大小翻倍。找到第一个空的 bucket_t，以 (SEL, IMP)的形式填充进去。 1234// Try this class's cache. imp = cache_getImp(cls, sel); if (imp) goto done; 如果不忽略，则再次尝试从类的cache中获取IMP，如果获取到，然后也会跳转到goto done去。 12345678// Try this class's method lists.meth = getMethodNoSuper_nolock(cls, sel);if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls); imp = meth-&gt;imp; goto done;&#125; 如果在cache缓存中获取失败，则再去类方法列表里面进行查找。找到后跳转到goto done。 12345678910111213141516171819// Try superclass caches and method lists.curClass = cls;while ((curClass = curClass-&gt;superclass)) &#123; // Superclass cache. imp = cache_getImp(curClass, sel); if (imp) &#123; if (imp != (IMP)_objc_msgForward_impcache) &#123; // Found the method in a superclass. Cache it in this class. log_and_fill_cache(cls, imp, sel, inst, curClass); goto done; &#125; else &#123; // Found a forward:: entry in a superclass. // Stop searching, but don't cache yet; call method // resolver for this class first. break; &#125; &#125; 如果以上尝试都失败了，接下来就会循环尝试父类的缓存和方法列表。一直找到NSObject为止。因为NSObject的superclass为nil，才跳出循环。 如果在父类中找到了该方法method的IMP，接下来就应该把这个方法cache回自己的缓存中。fill完之后跳转goto done语句。 12345678// Superclass method list. meth = getMethodNoSuper_nolock(curClass, sel); if (meth) &#123; log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass); imp = meth-&gt;imp; goto done; &#125; &#125; 如果没有在父类的cache中找到IMP，继续在父类的方法列表里面查找。如果找到，跳转goto done语句。 1234567891011121314151617181920static method_t *getMethodNoSuper_nolock(Class cls, SEL sel)&#123; runtimeLock.assertLocked(); assert(cls-&gt;isRealized()); // fixme nil cls? // fixme nil sel? for (auto mlists = cls-&gt;data()-&gt;methods.beginLists(), end = cls-&gt;data()-&gt;methods.endLists(); mlists != end; ++mlists) &#123; method_t *m = search_method_list(*mlists, sel); if (m) return m; &#125; return nil;&#125; 这里可以解析一下method的查找过程。在getMethodNoSuper_nolock方法中，会遍历一次methodList链表，从begin一直遍历到end。遍历过程中会调用search_method_list函数。 123456789101112131415161718192021222324252627static method_t *search_method_list(const method_list_t *mlist, SEL sel)&#123; int methodListIsFixedUp = mlist-&gt;isFixedUp(); int methodListHasExpectedSize = mlist-&gt;entsize() == sizeof(method_t); if (__builtin_expect(methodListIsFixedUp &amp;&amp; methodListHasExpectedSize, 1)) &#123; return findMethodInSortedMethodList(sel, mlist); &#125; else &#123; // Linear search of unsorted method list for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) return &amp;meth; &#125; &#125;#if DEBUG // sanity-check negative results if (mlist-&gt;isFixedUp()) &#123; for (auto&amp; meth : *mlist) &#123; if (meth.name == sel) &#123; _objc_fatal(\"linear search worked when binary search did not\"); &#125; &#125; &#125;#endif return nil;&#125; 在search_method_list函数中，会去判断当前methodList是否有序，如果有序，会调用findMethodInSortedMethodList方法，这个方法里面的实现是一个二分搜索，具体代码就不贴了。如果非有序，就调用线性的傻瓜式遍历搜索。 12345678910// No implementation found. Try method resolver once. if (resolver &amp;&amp; !triedResolver) &#123; runtimeLock.unlockRead(); _class_resolveMethod(cls, sel, inst); // Don't cache the result; we don't hold the lock so it may have // changed already. Re-do the search from scratch instead. triedResolver = YES; goto retry; &#125; 如果父类找到NSObject还没有找到，那么就会开始尝试_class_resolveMethod方法。注意，这些需要打开读锁，因为开发者可能会在这里动态增加方法实现，所以不需要缓存结果。此处虽然锁被打开，可能会出现线程问题，所以在执行完_class_resolveMethod方法之后，会goto retry，重新执行一遍之前查找的过程。 1234567891011121314151617181920212223/************************************************************************ _class_resolveMethod* Call +resolveClassMethod or +resolveInstanceMethod.* Returns nothing; any result would be potentially out-of-date already.* Does not check if the method already exists.**********************************************************************/void _class_resolveMethod(Class cls, SEL sel, id inst)&#123; if (! cls-&gt;isMetaClass()) &#123; // try [cls resolveInstanceMethod:sel] _class_resolveInstanceMethod(cls, sel, inst); &#125; else &#123; // try [nonMetaClass resolveClassMethod:sel] // and [cls resolveInstanceMethod:sel] _class_resolveClassMethod(cls, sel, inst); if (!lookUpImpOrNil(cls, sel, inst, NO/*initialize*/, YES/*cache*/, NO/*resolver*/)) &#123; _class_resolveInstanceMethod(cls, sel, inst); &#125; &#125;&#125; 这个函数首先判断是否是meta-class类，如果不是元类，就执行_class_resolveInstanceMethod，如果是元类，执行_class_resolveClassMethod。这里有一个lookUpImpOrNil的函数调用。 1234567IMP lookUpImpOrNil(Class cls, SEL sel, id inst, bool initialize, bool cache, bool resolver)&#123; IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver); if (imp == _objc_msgForward_impcache) return nil; else return imp;&#125; 在这个函数实现中，还会去调用lookUpImpOrForward去查找有没有传入的sel的实现，但是返回值还会返回nil。在imp == _objc_msgForward_impcache会返回nil。_objc_msgForward_impcache是一个标记，这个标记用来表示在父类的缓存中停止继续查找。 12345678910111213141516IMP class_getMethodImplementation(Class cls, SEL sel)&#123; IMP imp; if (!cls || !sel) return nil; imp = lookUpImpOrNil(cls, sel, nil, YES/*initialize*/, YES/*cache*/, YES/*resolver*/); // Translate forwarding function to C-callable external version if (!imp) &#123; return _objc_msgForward; &#125; return imp;&#125; 再回到_class_resolveMethod的实现中，如果lookUpImpOrNil返回nil，就代表在父类中的缓存中找到，于是需要再调用一次_class_resolveInstanceMethod方法。保证给sel添加上了对应的IMP。 12345// No implementation found, and method resolver didn't help. // Use forwarding.imp = (IMP)_objc_msgForward_impcache;cache_fill(cls, sel, imp, inst); 回到lookUpImpOrForward方法中，如果也没有找到IMP的实现，那么method resolver也没用了，只能进入消息转发阶段。进入这个阶段之前，imp变成_objc_msgForward_impcache。最后再加入缓存中。_objc_msgForward_impcache 第二个作用就是作为方法实现的 imp ，调用转发流程。 消息转发Message Forwarding阶段到了转发阶段，会调用id _objc_msgForward(id self, SEL _cmd,…)方法。在objc-msg-x86_64.s中有其汇编的实现。 1234567891011121314151617181920212223STATIC_ENTRY __objc_msgForward_impcache// Method cache version// THIS IS NOT A CALLABLE C FUNCTION// Out-of-band condition register is NE for stret, EQ otherwise.MESSENGER_STARTnopMESSENGER_END_SLOWjne __objc_msgForward_stretjmp __objc_msgForwardEND_ENTRY __objc_msgForward_impcacheENTRY __objc_msgForward// Non-stret versionmovq __objc_forward_handler(%rip), %r11jmp *%r11END_ENTRY __objc_msgForward 在执行_objc_msgForward之后会调用__objc_forward_handler函数。 12345678910// Default forward handler halts the process.__attribute__((noreturn)) void objc_defaultForwardHandler(id self, SEL sel)&#123; _objc_fatal(\"%c[%s %s]: unrecognized selector sent to instance %p \" \"(no message forward handler is installed)\", class_isMetaClass(object_getClass(self)) ? '+' : '-', object_getClassName(self), sel_getName(sel), self);&#125;void *_objc_forward_handler = (void*)objc_defaultForwardHandler; 在最新的Objc2.0中会有一个objc_defaultForwardHandler，看源码实现我们可以看到熟悉的语句。当我们给一个对象发送一个没有实现的方法的时候，如果其父类也没有这个方法，则会崩溃，报错信息类似于这样：unrecognized selector sent to instance，然后接着会跳出一些堆栈信息。这些信息就是从这里而来。 1234567891011121314151617181920void *_objc_forward_handler = (void*)objc_defaultForwardHandler; #if SUPPORT_STRETstruct stret &#123; int i[100]; &#125;; __attribute__((noreturn)) struct stret objc_defaultForwardStretHandler(id self, SEL sel) &#123; objc_defaultForwardHandler(self, sel);&#125;void *_objc_forward_stret_handler = (void*)objc_defaultForwardStretHandler; #endif #endif void objc_setForwardHandler(void *fwd, void *fwd_stret) &#123; _objc_forward_handler = fwd;#if SUPPORT_STRET _objc_forward_stret_handler = fwd_stret;#endif&#125; 要设置转发只要重写_objc_forward_handler方法即可。在objc_setForwardHandler方法中，可以设置ForwardHandler。 但是当你想要弄清objc_setForwardHandler调用栈的情况的时候，你会发现打印不出来入口。因为苹果在这里做了点手脚。关于objc_setForwardHandler的调用，以及之后的消息转发调用栈的问题，需要用到逆向的知识。推荐大家看这两篇文章就会明白其中的原理。 Objective-C 消息发送与转发机制原理 Hmmm, What’s that Selector? 还是回到消息转发上面来。当前的SEL无法找到相应的IMP的时候，开发者可以通过重写- (id)forwardingTargetForSelector:(SEL)aSelector方法来“偷梁换柱”，把消息的接受者换成一个可以处理该消息的对象。 1234567- (id)forwardingTargetForSelector:(SEL)aSelector&#123; if(aSelector == @selector(Method:))&#123; return otherObject; &#125; return [super forwardingTargetForSelector:aSelector];&#125; 当然也可以替换类方法，那就要重写 + (id)forwardingTargetForSelector:(SEL)aSelector方法，返回值是一个类对象。 123456+ (id)forwardingTargetForSelector:(SEL)aSelector &#123; if(aSelector == @selector(xxx)) &#123; return NSClassFromString(@\"Class name\"); &#125; return [super forwardingTargetForSelector:aSelector];&#125; 这一步是替消息找备援接收者，如果这一步返回的是nil，那么补救措施就完全的失效了，Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。 接下来未识别的方法崩溃之前，系统会做一次完整的消息转发。 我们只需要重写下面这个方法，就可以自定义我们自己的转发逻辑了。 12345678- (void)forwardInvocation:(NSInvocation *)anInvocation&#123; if ([someOtherObject respondsToSelector: [anInvocation selector]]) [anInvocation invokeWithTarget:someOtherObject]; else [super forwardInvocation:anInvocation];&#125; 实现此方法之后，若发现某调用不应由本类处理，则会调用超类的同名方法。如此，继承体系中的每个类都有机会处理该方法调用的请求，一直到NSObject根类。如果到NSObject也不能处理该条消息，那么就是再无挽救措施了，只能抛出“doesNotRecognizeSelector”异常了。 至此，消息发送和转发的过程都清楚明白了。 forwardInvocation的例子这里我想举一个好玩的例子，来说明一下forwardInvocation的使用方法。这个例子中我们会利用runtime消息转发机制创建一个动态代理。利用这个动态代理来转发消息。这里我们会用到两个基类的另外一个神秘的类，NSProxy。NSProxy类和NSObject同为OC里面的基类，但是NSProxy类是一种抽象的基类，无法直接实例化，可用于实现代理模式。它通过实现一组经过简化的方法，代替目标对象捕捉和处理所有的消息。NSProxy类也同样实现了NSObject的协议声明的方法，而且它有两个必须实现的方法。 12- (void)forwardInvocation:(NSInvocation *)invocation;- (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel NS_SWIFT_UNAVAILABLE(\"NSInvocation and related APIs not available\"); 另外还需要说明的是，NSProxy类的子类必须声明并实现至少一个init方法，这样才能符合OC中创建和初始化对象的惯例。Foundation框架里面也含有多个NSProxy类的具体实现类。 NSDistantObject类：定义其他应用程序或线程中对象的代理类。 NSProtocolChecker类：定义对象，使用这话对象可以限定哪些消息能够发送给另外一个对象。接下来就来看看下面这个好玩的例子。 123456#import &lt;Foundation/Foundation.h&gt; @interface Student : NSObject-(void)study:(NSString *)subject andRead:(NSString *)bookName;-(void)study:(NSString *)subject :(NSString *)bookName;@end 定义一个student类，里面随便给两个方法。 123456789101112131415#import \"Student.h\"#import &lt;objc/runtime.h&gt;@implementation Student -(void)study:(NSString *)subject :(NSString *)bookName&#123; NSLog(@\"Invorking method on %@ object with selector %@\",[self class],NSStringFromSelector(_cmd));&#125; -(void)study:(NSString *)subject andRead:(NSString *)bookName&#123; NSLog(@\"Invorking method on %@ object with selector %@\",[self class],NSStringFromSelector(_cmd));&#125;@end 在两个方法实现里面增加log信息，这是为了一会打印的时候方便知道调用了哪个方法。 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import \"Invoker.h\" @interface AspectProxy : NSProxy /** 通过NSProxy实例转发消息的真正对象 */@property(strong) id proxyTarget;/** 能够实现横切功能的类（遵守Invoker协议）的实例 */@property(strong) id&lt;Invoker&gt; invoker;/** 定义了哪些消息会调用横切功能 */@property(readonly) NSMutableArray *selectors; // AspectProxy类实例的初始化方法- (id)initWithObject:(id)object andInvoker:(id&lt;Invoker&gt;)invoker;- (id)initWithObject:(id)object selectors:(NSArray *)selectors andInvoker:(id&lt;Invoker&gt;)invoker;// 向当前的选择器列表中添加选择器- (void)registerSelector:(SEL)selector; @end 定义一个AspectProxy类，这个类专门用来转发消息的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#import \"AspectProxy.h\" @implementation AspectProxy - (id)initWithObject:(id)object selectors:(NSArray *)selectors andInvoker:(id&lt;Invoker&gt;)invoker&#123; _proxyTarget = object; _invoker = invoker; _selectors = [selectors mutableCopy]; return self;&#125; - (id)initWithObject:(id)object andInvoker:(id&lt;Invoker&gt;)invoker&#123; return [self initWithObject:object selectors:nil andInvoker:invoker];&#125; // 添加另外一个选择器- (void)registerSelector:(SEL)selector&#123; NSValue *selValue = [NSValue valueWithPointer:selector]; [self.selectors addObject:selValue];&#125; // 为目标对象中被调用的方法返回一个NSMethodSignature实例// 运行时系统要求在执行标准转发时实现这个方法- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel&#123; return [self.proxyTarget methodSignatureForSelector:sel];&#125; /** * 当调用目标方法的选择器与在AspectProxy对象中注册的选择器匹配时，forwardInvocation:会 * 调用目标对象中的方法，并根据条件语句的判断结果调用AOP（面向切面编程）功能 */- (void)forwardInvocation:(NSInvocation *)invocation&#123; // 在调用目标方法前执行横切功能 if ([self.invoker respondsToSelector:@selector(preInvoke:withTarget:)]) &#123; if (self.selectors != nil) &#123; SEL methodSel = [invocation selector]; for (NSValue *selValue in self.selectors) &#123; if (methodSel == [selValue pointerValue]) &#123; [[self invoker] preInvoke:invocation withTarget:self.proxyTarget]; break; &#125; &#125; &#125;else&#123; [[self invoker] preInvoke:invocation withTarget:self.proxyTarget]; &#125; &#125; // 调用目标方法 [invocation invokeWithTarget:self.proxyTarget]; // 在调用目标方法后执行横切功能 if ([self.invoker respondsToSelector:@selector(postInvoke:withTarget:)]) &#123; if (self.selectors != nil) &#123; SEL methodSel = [invocation selector]; for (NSValue *selValue in self.selectors) &#123; if (methodSel == [selValue pointerValue]) &#123; [[self invoker] postInvoke:invocation withTarget:self.proxyTarget]; break; &#125; &#125; &#125;else&#123; [[self invoker] postInvoke:invocation withTarget:self.proxyTarget]; &#125; &#125;&#125; 接着我们定义一个代理协议 123456789101112#import &lt;Foundation/Foundation.h&gt; @protocol Invoker &lt;NSObject&gt; @required// 在调用对象中的方法前执行对功能的横切- (void)preInvoke:(NSInvocation *)inv withTarget:(id)target;@optional// 在调用对象中的方法后执行对功能的横切- (void)postInvoke:(NSInvocation *)inv withTarget:(id)target; @end 最后还需要一个遵守协议的类 12345678910111213141516171819#import &lt;Foundation/Foundation.h&gt;#import \"Invoker.h\" @interface AuditingInvoker : NSObject&lt;Invoker&gt;//遵守Invoker协议@end #import \"AuditingInvoker.h\" @implementation AuditingInvoker - (void)preInvoke:(NSInvocation *)inv withTarget:(id)target&#123; NSLog(@\"before sending message with selector %@ to %@ object\", NSStringFromSelector([inv selector]),[target className]);&#125;- (void)postInvoke:(NSInvocation *)inv withTarget:(id)target&#123; NSLog(@\"after sending message with selector %@ to %@ object\", NSStringFromSelector([inv selector]),[target className]); &#125;@end 在这个遵循代理类里面我们只实现协议里面的两个方法。写出测试代码 123456789101112131415161718192021222324252627282930#import &lt;Foundation/Foundation.h&gt;#import \"AspectProxy.h\"#import \"AuditingInvoker.h\"#import \"Student.h\" int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; id student = [[Student alloc] init]; // 设置代理中注册的选择器数组 NSValue *selValue1 = [NSValue valueWithPointer:@selector(study:andRead:)]; NSArray *selValues = @[selValue1]; // 创建AuditingInvoker AuditingInvoker *invoker = [[AuditingInvoker alloc] init]; // 创建Student对象的代理studentProxy id studentProxy = [[AspectProxy alloc] initWithObject:student selectors:selValues andInvoker:invoker]; // 使用指定的选择器向该代理发送消息---例子1 [studentProxy study:@\"Computer\" andRead:@\"Algorithm\"]; // 使用还未注册到代理中的其他选择器，向这个代理发送消息！---例子2 [studentProxy study:@\"mathematics\" :@\"higher mathematics\"]; // 为这个代理注册一个选择器并再次向其发送消息---例子3 [studentProxy registerSelector:@selector(study::)]; [studentProxy study:@\"mathematics\" :@\"higher mathematics\"]; &#125; return 0;&#125; 这里有3个例子。里面会分别输出什么呢？ 123456789before sending message with selector study:andRead: to Student object Invorking method on Student object with selector study:andRead: after sending message with selector study:andRead: to Student object Invorking method on Student object with selector study:: before sending message with selector study:: to Student object Invorking method on Student object with selector study:: after sending message with selector study:: to Student object 例子1中会输出3句话。调用Student对象的代理中的study:andRead:方法，会使该代理调用AuditingInvoker对象中的preInvoker:方法、真正目标（Student对象）中的study:andRead:方法，以及AuditingInvoker对象中的postInvoker:方法。一个方法的调用，调用起了3个方法。原因是study:andRead:方法是通过Student对象的代理注册的； 例子2就只会输出1句话。调用Student对象代理中的study::方法，因为该方法还未通过这个代理注册，所以程序仅会将调用该方法的消息转发给Student对象，而不会调用AuditorInvoker方法。 例子3又会输出3句话了。因为study::通过这个代理进行了注册，然后程序再次调用它，在这次调用过程中，程序会调用AuditingInvoker对象中的AOP方法和真正目标（Student对象）中的study::方法。 这个例子就实现了一个简单的AOP(Aspect Oriented Programming)面向切面编程。我们把一切功能”切”出去，与其他部分分开，这样可以提高程序的模块化程度。AOP能解耦也能动态组装，可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能。比如上面的例子三，我们通过把方法注册到动态代理类中，于是就实现了该类也能处理方法的功能。 入院考试下面的代码会？Compile Error / Runtime Crash / NSLog…? 12345678910111213141516171819202122@interface NSObject (Sark)+ (void)foo;- (void)foo;@end@implementation NSObject (Sark)- (void)foo&#123; NSLog(@\"IMP: -[NSObject(Sark) foo]\");&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; [NSObject foo]; [[NSObject new] foo]; &#125; return 0;&#125; 这道有两处难点，难点一是给NSObject增加了一个分类，分类声明的是一个加号的类方法，而实现中是一个减号的实例方法。在main中去NSObject去调用了这个foo方法，会编译错误，还是会Crash呢？ 难点二是会输出什么内容呢？ 先来看难点一，这里会牵扯到Category的知识。推荐文章还是美团的这篇经典的深入理解Objective-C：Category 12345678910111213141516171819202122232425262728293031// 这个函数算是整个 objc4 库的入口函数，被 libSystem 库调用#if !__OBJC2__static __attribute__((constructor))#endifvoid _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); // Register for unmap first, in case some +load unmaps something // 首先第一步，注册 unmap 函数，万一有的类的 +load 方法需要 unmap 一些东西 // unmap，即 un-memory-mapped，这里应该就是取消内存映射，移除镜像的意思 _dyld_register_func_for_remove_image(&amp;unmap_image); // 注册镜像状态改变时的回调函数 dyld_register_image_state_change_handler(dyld_image_state_bound, 1/*batch 是否批处理*/, &amp;map_2_images); // 注册镜像状态改变时的回调函数，镜像加载完成后，需要调用 +load 时会回调 load_images 函数 // 不进行批处理，所以 load_images 会被调用多次，每次有新的镜像进来时，都会被调用 dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);&#125; OC在初始化的时候，会去加载map_images，map_images最终会调用objc-runtime-new.mm里面的_read_images方法。_read_images方法里面会去初始化内存中的map, 这个时候将会load所有的类，协议还有Category。NSOBject的+load方法就是这个时候调用的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 // Discover categories.for (EACH_HEADER) &#123; // 遍历 hList // 取得 hi 镜像中的所有分类 category_t **catlist = _getObjc2CategoryList(hi, &amp;count); for (i = 0; i &lt; count; i++) &#123; // 遍历所有分类 category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); // 得到分类所属的类的 live class if (!cls) &#123; // 如果 cls 为空 // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. // 分类所属的类丢了，很多可能是 weak-linked 了 // 这个分类就是不可信的，完全没有什么鸟用了 catlist[i] = nil; // 将这个分类从列表中删除 if (PrintConnecting) &#123; _objc_inform(\"CLASS: IGNORING category \\?\\?\\?(%s) %p with \" \"missing weak-linked target class\", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. // 处理这个分类 // 首先，注册注册这个分类 // 然后，如果这个类已经是 realized 的话，就重新建立这个类的方法列表（把分类的方法添加进去） bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) // 如果分类中存在实例方法 or 协议 or 实例属性 &#123; // 添加分类到所属的 cls 类上，即把这个分类添加到 cls 对应的所有 unattached 的分类的列表中 addUnattachedCategoryForClass(cat, cls, hi); // 如果 cls 类已经被 realized if (cls-&gt;isRealized()) &#123; // 就重新 methodize 一下 cls 类，里面会重新 attachCategories 一下所有未被 attach 的分类 // 即把这些分类中的方法、协议、属性添加到 cls 类中 remethodizeClass(cls); classExists = YES; // 标记类存在 &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category -%s(%s) %s\", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? \"on existing class\" : \"\"); &#125; &#125; // 如果分类中存在类方法 or 协议 if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; // 添加分类到所属类 cls 的元类中 addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); // 如果 cls 的元类已经 realized 过了 if (cls-&gt;ISA()-&gt;isRealized()) &#123; // 就重新 methodize 一下 cls 类的元类 remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform(\"CLASS: found category +%s(%s)\", cls-&gt;nameForLogging(), cat-&gt;name); &#125; &#125; &#125;&#125; 在这个加载中，for循环中会反复调用_getObjc2CategoryList 方法，这个方法的具体实现是 123456789101112 // function name content type section name GETSECT(_getObjc2CategoryList, category_t *, \"__objc_catlist\"); 最后一个参数__objc_catlist就是编译器刚刚生成的category数组。加载完所有的category之后，就开始处理这些类别。大体思路还是分为2类来分开处理。 if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties)&#123; &#125;第一类是实例方法 if (cat-&gt;classMethods || cat-&gt;protocols /* || cat-&gt;classProperties */) &#123; &#125; 第二类是类方法。 处理完之后的结果 把category的实例方法、协议以及属性添加到类上 把category的类方法和协议添加到类的metaclass上 这两种情况里面的处理方式都差不多，先去调用addUnattachedCategoryForClass函数，申请内存，分配空间。remethodizeClass这个方法里面会调用attachCategories方法。attachCategories方法代码就不贴了，有兴趣的可以自己去看看。这个方法里面会用头插法，把新加的方法从头插入方法链表中。并且最后还会flushCaches。这也就是为什么我们可以在Category里面覆盖原有的方法的原因，因为头插法，新的方法在链表的前面，会优先被遍历到。以上就是Category加载时候的流程。 再回到这道题目上面来，在加载NSObject的Category中，在编译期会提示我们没有实现+(void)foo的方法，因为在.m文件中并没有找到+的方法，而是一个-号的方法，所以会提示。但是在实际加载Category的时候，会把-(void)foo加载进去，由于是实例方法，所以会放在NSObject的实例方法链表里面。根据第二章分析的objc_msgSend源码实现，我们可以知道： 在调用[NSObject foo]的时候，会先在NSObject的meta-class中去查找foo方法的IMP，未找到，继续在superClass中去查找，NSObject的meta-class的superClass就是本身NSObject，于是又回到NSObject的类方法中查找foo方法，于是乎找到了，执行foo方法，输出 1IMP: -[NSObject(Sark) foo] 在调用[[NSObject new] foo]的时候，会先生成一个NSObject的对象，用这个NSObject实例对象再去调用foo方法的时候，会去NSObject的类方法里面去查找，找到，于是也会输出 1IMP: -[NSObject(Sark) foo] 所以上面这题，不会Compile Error ，更不会 Runtime Crash ，会输出两个相同的结果。 Runtime中的优化关于Runtime系统中，有3种地方进行了优化。 方法列表的缓存 虚函数表vTable dyld共享缓存 方法列表的缓存在消息发送过程中，查找IMP的过程，会优先查找缓存。这个缓存会存储最近使用过的方法都缓存起来。这个cache和CPU里面的cache的工作方式有点类似。原理是调用的方法有可能经常会被调用。如果没有这个缓存，直接去类方法的方法链表里面去查找，查询效率实在太低。所以查找IMP会优先搜索饭方法缓存，如果没有找到，接着会在虚函数表中寻找IMP。如果找到了，就会把这个IMP存储到缓存中备用。基于这个设计，使Runtime系统能能够执行快速高效的方法查询操作。 虚函数表虚函数表也称为分派表，是编程语言中常用的动态绑定支持机制。在OC的Runtime运行时系统库实现了一种自定义的虚函数表分派机制。这个表是专门用来提高性能和灵活性的。这个虚函数表是用来存储IMP类型的数组。每个object-class都有这样一个指向虚函数表的指针。 dyld共享缓存在我们的程序中，一定会有很多自定义类，而这些类中，很多SEL是重名的，比如alloc，init等等。Runtime系统需要为每一个方法给定一个SEL指针，然后为每次调用个各个方法更新元数据，以获取唯一值。这个过程是在应用程序启动的时候完成。为了提高这一部分的执行效率，Runtime会通过dyld共享缓存实现选择器的唯一性。 dyld是一种系统服务，用于定位和加载动态库。它含有共享缓存，能够使多个进程共用这些动态库。dyld共享缓存中含有一个选择器表，从而能使运行时系统能够通过使用缓存访问共享库和自定义类的选择器。 关于dyld的知识可以看看这篇文章dyld: Dynamic Linking On OS X","tags":[{"name":"消息发送 消息转发","slug":"消息发送-消息转发","permalink":"http://yoursite.com/tags/消息发送-消息转发/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"神经病院Objective-C Runtime入院系列文章","slug":"IOS/Runtime/神经病院Objective-C-Runtime入院系列文章","permalink":"http://yoursite.com/categories/IOS/Runtime/神经病院Objective-C-Runtime入院系列文章/"}]},{"title":"经典数学文章","date":"2016-11-21T04:07:12.000Z","path":"wiki/数学知识/经典数学文章/","text":"文章目录 黎曼猜想与调和级数","tags":[{"name":"调和级数","slug":"调和级数","permalink":"http://yoursite.com/tags/调和级数/"}],"categories":[{"name":"数学知识","slug":"数学知识","permalink":"http://yoursite.com/categories/数学知识/"}]},{"title":"算法4","date":"2016-11-21T04:07:12.000Z","path":"wiki/数据结构与算法/算法4/about/","text":"算法4 官网地址","tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}],"categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://yoursite.com/categories/数据结构与算法/"},{"name":"算法4","slug":"数据结构与算法/算法4","permalink":"http://yoursite.com/categories/数据结构与算法/算法4/"}]},{"title":"union定义(转载)","date":"2016-11-21T04:07:12.000Z","path":"wiki/C语言语法/union定义/","text":"union定义union 维护足够的空间来置放多个数据成员中的“一种”，而不是为每一个数据成员配置空间，在union 中所有的数据成员共用一个空间，同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址。例子如下： 1234567union StateMachine&#123; char character; int number; char *str; double exp;&#125;; 一个union 只配置一个足够大的空间以来容纳最大长度的数据成员，以上例而言，最大长度是double 型态，所以StateMachine 的空间大小就是double 数据类型的大小。 在C++里，union 的成员默认属性页为public。union 主要用来压缩空间。如果一些数据不可能在同一时间同时被用到，则可以使用union。 大小端模式对union 类型数据的影响下面再看一个例子： 12345678union&#123; int i; char a[2];&#125;*p, u;p =&amp;u;p-&gt;a[0] = 0x39;p-&gt;a[1] = 0x38; p.i 的值应该为多少呢？ 这里需要考虑存储模式：大端模式和小端模式。大端模式（Big_endian）：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。小端模式（Little_endian）：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。union 型数据所占的空间等于其最大的成员所占的空间。对union 型的成员的存取都是相对于该联合体基地址的偏移量为0 处开始，也就是联合体的访问不论对哪个变量的存取都是从union 的首地址位置开始。如此一解释，上面的问题是否已经有了答案呢？ 如何用程序确认当前系统的存储模式？上述问题似乎还比较简单，那来个有技术含量的：请写一个C 函数，若处理器是Big_endian 的，则返回0；若是Little_endian 的，则返回1。 先分析一下，按照上面关于大小端模式的定义，假设int 类型变量i 被初始化为1。 以大端模式存储，其内存布局如下图：以小端模式存储，其内存布局如下图： 变量i 占4 个字节，但只有一个字节的值为1，另外三个字节的值都为0。如果取出低地址上的值为0，毫无疑问，这是大端模式；如果取出低地址上的值为1，毫无疑问，这是小端模式。既然如此，我们完全可以利用union 类型数据的特点：所有成员的起始地址一致。 到现在，应该知道怎么写了吧？参考答案如下： 12345678910int checkSystem( )&#123; union check &#123; int i; char ch; &#125; c; c.i = 1; return (c.ch ==1);&#125; 总结union同一时间只能储存其中一个数据成员，所有的数据成员具有相同的起始地址，它所占的空间等于其最大的成员所占的空间，机器的大小端存储影响union成员的取值。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"第一天--isa和Class(转载)","date":"2016-11-18T01:50:28.000Z","path":"wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/firstDay/","text":"本文转载自神经病院Objective-C Runtime入院第一天——isa和Class。 Runtime简介Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。 C语言中，在编译期，函数的调用就会决定调用哪个函数。而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。编译时向接受者发送消息，运行时找到函数调用 Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。Objc 在三种层面上与 Runtime 系统进行交互： 通过 Objective-C 源代码 一般情况开发者只需要编写 OC 代码即可，Runtime系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码 ，在运行时确定对应的数据结构和调用具体哪个方法。 通过 Foundation 框架的 NSObject 类定义的方法 在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。 在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。 12345- (Class)class OBJC_SWIFT_UNAVAILABLE(\"use 'anObject.dynamicType' instead\");- (BOOL)isKindOfClass:(Class)aClass;- (BOOL)isMemberOfClass:(Class)aClass;- (BOOL)conformsToProtocol:(Protocol *)aProtocol;- (BOOL)respondsToSelector:(SEL)aSelector; -class方法返回对象的类； -isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)； -respondsToSelector: 检查对象能否响应指定的消息； -conformsToProtocol:检查对象是否实现了指定协议类的方法； 在NSObject的类中还定义了一个方法 1- (IMP)methodForSelector:(SEL)aSelector; 这个方法会返回指定方法实现的地址IMP。 以上这些方法会在本篇文章中详细分析具体实现。 通过对 Runtime 库函数的直接调用 关于库函数可以在Objective-C Runtime Reference中查看 Runtime 函数的详细文档。 关于这一点，其实还有一个小插曲。当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，那些函数里面的参数和描述都没有了。对于熟悉Runtime的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从iOS6开始开发的同学，依稀可能能感受到，关于Runtime的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从Xcode5开始，苹果就不建议我们手动调用Runtime的API，也同样希望我们不要知道具体底层实现。所以IDE上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释。 具体设置如下: 如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成NO，即可。 NSObject起源由上面一章节，我们知道了与Runtime交互有3种方式，前两种方式都与NSObject有关，那我们就从NSObject基类开始说起。以下源码分析均来自objc4-680NSObject的定义如下: 12345typedef struct objc_class *Class; @interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; 在Objc2.0之前，objc_class源码如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif &#125; OBJC2_UNAVAILABLE; 在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。 ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这表明可以通过动态修改*methodLists的值来实现添加成员方法的目的，这也是Category实现的原理，同样解释了Category不能添加属性的原因。 关于Category，这里推荐2篇文章可以仔细研读一下。 深入理解Objective-C：Category 结合 Category 工作原理分析 OC2.0 中的 runtime 然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了。 123456789101112131415161718192021222324252627282930typedef struct objc_class *Class; typedef struct objc_object *id; @interface Object &#123; Class isa; &#125; @interface NSObject &lt;NSObject&gt; &#123; Class isa OBJC_ISA_AVAILABILITY;&#125; struct objc_object &#123; private: isa_t isa;&#125; struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags&#125; union isa_t &#123; isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits;&#125; 把源码的定义转化成类图，就是上图的样子。 从上述源码中，我们可以看到，Objective-C 对象都是 C 语言结构体实现的，在objc2.0中，所有的对象都会包含一个isa_t类型的结构体。 objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。 objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量： 一个是父类的指针 一个是方法缓存 最后一个这个类的实例方法表。 object类和NSObject类里面分别都包含一个objc_class类型的isa。 上图的左半边类的关系描述完了，接着先从isa来说起。 当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。 但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。 关于元类，更多具体可以研究这篇文章What is a meta-class in Objective-C（译文）? 在引入元类之后，类对象和对象查找方法的机制就完全统一了。1. 调用对象的实例方法时，通过对象的 isa 在类中获取方法的实现。2. 调用类对象的类方法时，通过类的isa指针在元类中获取方法的实现。meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。 图中实线是 super_class指针，虚线是isa指针。 Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。 每个Class都有一个isa指针指向唯一的元类（Meta class）。 Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。 每个Meta class的isa指针都指向Root class (meta)。 我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。具体可看sunnyxx这篇iOS 程序 main 函数之前发生了什么 isa_t结构体的具体实现接下来我们就该研究研究isa的具体实现了。objc_object里面的isa是isa_t类型。通过查看源码，我们可以知道isa_t是一个union联合体。 12345678910111213141516171819202122232425262728293031323334353637union isa_t &#123; // 构造函数 isa_t() &#123; &#125; isa_t(uintptr_t value) : bits(value) &#123; &#125; Class cls; uintptr_t bits; struct &#123; uintptr_t indexed : 1; // 0表示普通的isa指针 1表示优化过的，存储引用计数 uintptr_t has_assoc : 1; // 对象是否包含 associated object，如果没有，析构时会更快 uintptr_t has_cxx_dtor : 1; // 是否有C++或ARC的析构函数，如果没有，析构时会更快 uintptr_t shiftcls : 33; // 最重要的原来的Class cls部分，占33个bit，与 ISA_MASK 进行 &amp; 操作可以得到 // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; // 用于调试时分辨对象是否完成初始化 uintptr_t weakly_referenced : 1; // 对象是否有过weak引用，如果没有，析构时会更快 uintptr_t deallocating : 1; // 对象是否正在析构 uintptr_t has_sidetable_rc : 1; // 表示对象的引用计数过大，无法存储在isa指针，只能存在side table中 uintptr_t extra_rc : 19; // 存储引用计数，不过好像是减 1 后的值，可以在 rootRetainCount 方法中看到 // 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。# define RC_ONE (1ULL&lt;&lt;45) // 左移 45 bit，正好是extra_rc 所在的位置# define RC_HALF (1ULL&lt;&lt;18) // extra_rc 总共是19位，RC_HALF是18位，也就是全部引用计数的一半 &#125;; &#125;struct objc_object &#123; private: isa_t isa;public: // initIsa() should be used to init the isa of new objects only. // If this object already has an isa, use changeIsa() for correctness. // initInstanceIsa(): objects with no custom RR/AWZ void initIsa(Class cls /*indexed=false*/); void initInstanceIsa(Class cls, bool hasCxxDtor);private: void initIsa(Class newCls, bool indexed, bool hasCxxDtor);｝ 那就从initIsa方法开始研究。下面以arm64为例。 1234567891011121314151617inline void objc_object::initInstanceIsa(Class cls, bool hasCxxDtor) &#123; initIsa(cls, true, hasCxxDtor);&#125; inline void objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor) &#123; if (!indexed) &#123; isa.cls = cls; &#125; else &#123; isa.bits = ISA_MAGIC_VALUE; isa.has_cxx_dtor = hasCxxDtor; isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; &#125;&#125; initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。 1234567891011121314151617181920212223242526272829303132333435# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# define ISA_MAGIC_MASK 0x000003f000000001ULL# define ISA_MAGIC_VALUE 0x000001a000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 33; // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 19;# define RC_ONE (1ULL&lt;&lt;45)# define RC_HALF (1ULL&lt;&lt;18) &#125;; # elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# define ISA_MAGIC_MASK 0x001f800000000001ULL# define ISA_MAGIC_VALUE 0x001d800000000001ULL struct &#123; uintptr_t indexed : 1; uintptr_t has_assoc : 1; uintptr_t has_cxx_dtor : 1; uintptr_t shiftcls : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000 uintptr_t magic : 6; uintptr_t weakly_referenced : 1; uintptr_t deallocating : 1; uintptr_t has_sidetable_rc : 1; uintptr_t extra_rc : 8;# define RC_ONE (1ULL&lt;&lt;56)# define RC_HALF (1ULL&lt;&lt;7) &#125;; ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：关于参数的说明： 第一位index，代表是否开启isa指针优化。index = 1，代表开启isa指针优化。 在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。 在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。 假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示： 苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：关于Tagged Pointer技术详细的，可以看上面链接那个文章。 has_assoc对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存 has_cxx_dtor表示该对象是否有 C++ 或者 Objc 的析构器 shiftcls类的指针。arm64架构中有33位可以存储类指针。 源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看从 NSObject 的初始化了解isa 这篇文章里面的shiftcls分析。 magic判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。 weakly_referenced对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放 deallocating对象是否正在释放内存 has_sidetable_rc判断该对象的引用计数是否过大，如果过大则需要存在side table中。 extra_rc存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。 ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。 123456inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125; 关于x86_64的架构，具体可以看从 NSObject 的初始化了解 isa文章里面的详细分析。 cache_t的具体实现还是继续看源码 1234567891011121314151617struct cache_t &#123; struct bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125; typedef unsigned int uint32_t; typedef uint32_t mask_t; // x86_64 &amp; arm64 asm are less efficient with 16-bits typedef unsigned long uintptr_t; typedef uintptr_t cache_key_t; struct bucket_t &#123; private: cache_key_t _key; IMP _imp;&#125; 根据源码，我们可以知道cache_t中存储了一个bucket_t的结构体，和两个unsigned int的变量。 mask：分配用来缓存bucket的总数。occupied：表明目前实际占用的缓存bucket的个数。 bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。 cache_t中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。 Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。 class_data_bits_t的具体实现源码实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344struct class_data_bits_t &#123; // Values are the FAST_ flags above. uintptr_t bits;&#125; struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; property_array_t properties; protocol_array_t protocols; Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125; struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 在 objc_class结构体中的注释写到： class_data_bits_t相当于 class_rw_t指针加上 rr/alloc 的标志。 1class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags 它为我们提供了便捷方法用于返回其中的 class_rw_t *指针： 1234567objc_class::class_rw_t *data() &#123; return bits.data();&#125;// 取出 bits 中存的 class_rw_tclass_data_bits_t::class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK);&#125; Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite，ro-readonly 在编译期类的结构中的 class_data_bits_t data指向的是一个 class_ro_t 指针： 在运行时调用 realizeClass方法，会做以下3件事情： 从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针 初始化一个 class_rw_t结构体 设置结构体 ro的值以及 flag 最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。 1234567891011121314struct method_t &#123; SEL name; const char *types; IMP imp; struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;;&#125;; 方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是Type Encoding类型编码，类型可参考Type Encoding，在此不细说。 IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。 整个运行时过程可以描述如下：更加详细的分析，请看@Draveness 的这篇文章 深入解析 ObjC 中方法的结构 到此，总结一下objc_class 1.0和2.0的差别。 入院考试[self class] 与 [super class]下面代码输出什么? 123456789101112@implementation Son : Father- (id)init&#123; self = [super init]; if (self) &#123; NSLog(@\"%@\", NSStringFromClass([self class])); NSLog(@\"%@\", NSStringFromClass([super class])); &#125;return self;&#125;@end self和super的区别： self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。 super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。 在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend 1234567891011121314151617OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ ) /// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;; 在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是 当前类的父类super_class。 入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。 objc_msgSendSuper的工作原理应该是这样的: 从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc-&gt;receiver去调用父类的这个selector。注意，最后的调用者是objc-&gt;receiver，而不是super_class！ 那么objc_msgSendSuper最后就转变成 12345objc_msgSend(objc_super-&gt;receiver, @selector(class)) + (Class)class &#123; return self;&#125; 由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super-&gt;receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。 isKindOfClass 与 isMemberOfClass下面代码输出什么？ 1234567891011121314151617@interface Sark : NSObject@end@implementation Sark@endint main(int argc, const char * argv[]) &#123;@autoreleasepool &#123; BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; Y BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]]; Y BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]]; BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]]; NSLog(@\"%d %d %d %d\", res1, res2, res3, res4);&#125;return 0;&#125; 先来分析一下源码这两个函数的对象实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;Class object_getClass(id obj) &#123; if (obj) return obj-&gt;getIsa(); else return Nil;&#125;inline Class objc_object::getIsa() &#123; if (isTaggedPointer()) &#123; uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK; return objc_tag_classes[slot]; &#125; return ISA();&#125;inline Class objc_object::ISA() &#123; assert(!isTaggedPointer()); return (Class)(isa.bits &amp; ISA_MASK);&#125;+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125; 首先题目中NSObject 和 Sark分别调用了class方法。 (BOOL)isKindOfClass:(Class)cls方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj-&gt;getIsa()，最后在ISA()方法中获得meta class的指针。 接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。 [NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。 同理，[Sark class]执行完之后调用isKindOfClass，第一次for循环，Sark的Meta Class与[Sark class]不等，第二次for循环，Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Sark Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。 如果把这里的Sark改成它的实例对象，[sark isKindOfClass:[Sark class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断sark的meta class是自己的元类Sark，第一次for循环就能输出YES了。 isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Sark的Meta Class，和Sark Class也不等，所以第二行res2和第四行res4都输出NO。 Class与内存地址下面的代码会？Compile Error / Runtime Crash / NSLog…? 123456789101112131415161718192021@interface Sark : NSObject@property (nonatomic, copy) NSString *name;- (void)speak;@end @implementation Sark- (void)speak &#123; NSLog(@\"my name's %@\", self.name);&#125;@end @implementation ViewController - (void)viewDidLoad &#123; [super viewDidLoad]; id cls = [Sark class]; void *obj = &amp;cls; [(__bridge id)obj speak];&#125;@end 这道题有两个难点。难点一，obj调用speak方法，到底会不会崩溃。难点二，如果speak方法不崩溃，应该输出什么？ 首先需要谈谈隐藏参数self和_cmd的问题。 当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self在上面已经讲解明白了，接下来就来说说_cmd。_cmd表示当前调用方法，其实它就是一个方法选择器SEL。 难点一，能不能调用speak方法？ 12id cls = [Sark class]; void *obj = &amp;cls; 答案是可以的。obj被转换成了一个指向Sark Class的指针，然后使用id转换成了objc_object类型。obj现在已经是一个Sark类型的实例对象了。当然接下来可以调用speak的方法。 难点二，如果能调用speak，会输出什么呢？ 很多人可能会认为会输出sark相关的信息。这样答案就错误了。 正确的答案会输出 1my name is &lt;ViewController: 0x7ff6d9f31c50&gt; 内存地址每次运行都不同，但是前面一定是ViewController。why？ 我们把代码改变一下，打印更多的信息出来。 123456789101112131415161718- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark,&amp;sark); [sark speak];&#125; 我们把对象的指针地址都打印出来。输出结果： 12345678ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8 Sark class = Sark 地址 = 0x7fff543f5a88 Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80my name is &lt;ViewController: 0x7fb570e2ad00&gt;Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78 my name is (null) 123456789101112131415161718192021// objc_msgSendSuper2() takes the current search class, not its superclass.OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0); objc_msgSendSuper2方法入参是一个objc_super *super。/// Specifies the superclass of an instance. struct objc_super &#123; /// Specifies an instance of a class. __unsafe_unretained id receiver; /// Specifies the particular superclass of the instance to message. #if !defined(__cplusplus) &amp;&amp; !__OBJC2__ /* For compatibility with old objc-runtime.h header */ __unsafe_unretained Class class;#else __unsafe_unretained Class super_class;#endif /* super_class is the first class to search */&#125;;#endif 所以按viewDidLoad执行时各个变量入栈顺序从高到底为self, _cmd, super_class(等同于self.class), receiver(等同于self), obj。 第一个self和第二个_cmd是隐藏参数。第三个self.class和第四个self是[super viewDidLoad]方法执行时候的参数。 在调用self.name的时候，本质上是self指针在内存向高位地址偏移一个指针。 从打印结果我们可以看到，obj就是cls的地址。在obj向上偏移一个指针就到了0x7fff543f5a90，这正好是ViewController的地址。 所以输出为my name is 。 至此，Objc中的对象到底是什么呢？ 实质：Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N) 加深一下对上面这句话的理解，下面这段代码会输出什么？ 1234567891011121314151617181920- (void)viewDidLoad &#123; [super viewDidLoad]; NSLog(@\"ViewController = %@ , 地址 = %p\", self, &amp;self); NSString *myName = @\"halfrost\"; id cls = [Sark class]; NSLog(@\"Sark class = %@ 地址 = %p\", cls, &amp;cls); void *obj = &amp;cls; NSLog(@\"Void *obj = %@ 地址 = %p\", obj,&amp;obj); [(__bridge id)obj speak]; Sark *sark = [[Sark alloc]init]; NSLog(@\"Sark instance = %@ 地址 = %p\",sark,&amp;sark); [sark speak];&#125; 12345678ViewController = &lt;ViewController: 0x7fff44404ab0&gt; , 地址 = 0x7fff56a48a78Sark class = Sark 地址 = 0x7fff56a48a50Void *obj = &lt;Sark: 0x7fff56a48a50&gt; 地址 = 0x7fff56a48a48my name is halfrostSark instance = &lt;Sark: 0x6080000233e0&gt; 地址 = 0x7fff56a48a40my name is (null) 由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak];这句话会输出“my name is halfrost” 原因还是和上面的类似。按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class( super_class )，self ( receiver )，myName，obj。obj往上偏移一个指针，就是myName字符串，所以输出变成了输出myName了。 这里有一点需要额外说明的是，栈里面有两个 self，可能有些人认为是指针偏移到了第一个 self 了，于是打印出了 ViewController： 1my name is &lt;ViewController: 0x7fb570e2ad00&gt; 其实这种想法是不对的，从 obj 往上找 name 属性，完全是指针偏移了一个 offset 导致的，也就是说指针只往下偏移了一个。那么怎么证明指针只偏移了一个，而不是偏移了4个到最下面的 self 呢？ obj 的地址是 0x7fff5c7b9a08，self 的地址是 0x7fff5c7b9a28。每个指针占8个字节，所以从 obj 到 self 中间确实有4个指针大小的间隔。如果从 obj 偏移一个指针，就到了 0x7fff5c7b9a10。我们需要把这个内存地址里面的内容打印出来。 LLDB 调试中，可以使用examine命令（简写是x）来查看内存地址中的值。x命令的语法如下所示：x/ n、f、u是可选的参数。n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。 f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果地十是指令地址，那么格式可以是 i。 u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 我们用 x 命令分别打印出 0x7fff5c7b9a10 和 0x7fff5c7b9a28 内存地址里面的内容，我们会发现两个打印出来的值是一样的，都是 0x7fbf0d606aa0。 这两个 self 的地址不同，里面存储的内容是相同的。 所以 obj 是偏移了一个指针，而不是偏移到最下面的 self 。","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"神经病院Objective-C Runtime入院系列文章","slug":"IOS/Runtime/神经病院Objective-C-Runtime入院系列文章","permalink":"http://yoursite.com/categories/IOS/Runtime/神经病院Objective-C-Runtime入院系列文章/"}]},{"title":"Objective-C 中的元类（meta class）是什么？","date":"2016-11-12T11:56:17.000Z","path":"wiki/IOS/Runtime/经典文章/meta_class/","text":"在本文我们会看到一个在Objective-C中很陌生的概念——元类。Objective-C中的每个类都有和自己相关联的元类，但我们几乎从来不直接使用它，它们依然是那么神秘。我们将开始学习怎样在运行时创建一个类。通过创建的“class pair”，我会解释什么是元类，然后探讨它对于Objective-C中对象和类的意义。 在运行时创建一个类下面的代码在运行时创建了一个NSError的子类，并且添加了一个方法： 1234Class newClass =objc_allocateClassPair([NSError class], \"RuntimeErrorSubclass\", 0);class_addMethod(newClass, @selector(report), (IMP)ReportFunction, \"v@:\");objc_registerClassPair(newClass); ReportFunction函数就是添加的实例方法，具体实现如下： 123456789101112131415void ReportFunction(id self, SEL _cmd)&#123; NSLog(@\"This object is %p.\", self); NSLog(@\"Class is %@, and super is %@.\", [self class], [self superclass]); Class currentClass = [self class]; for (int i = 1; i &lt; 5; i++) &#123; NSLog(@\"Following the isa pointer %d times gives %p\", i, currentClass); currentClass = object_getClass(currentClass); &#125; NSLog(@\"NSObject's class is %p\", [NSObject class]); NSLog(@\"NSObject's meta class is %p\", object_getClass([NSObject class]));&#125; 表面上看来，这相当简单。在运行时创建一个类只需要3个步骤: 为”class pair”分配内存 (使用objc_allocateClassPair). 添加方法或成员变量到有需要的类里 (我已经使用class_addMethod添加了一个方法). 注册类以便它能使用 (使用objc_registerClassPair). 然而，有一个很迫切的问题：什么是“class pair”？objc_allocateClassPair函数仅返回了一个值：the class。那另一半pair在哪？ 我相信你已经猜到了，另一半pair就是元类（这篇文章的主题）。为了解释它是什么和我们为什么需要它，还需要交代下Objective-C的对象和类的相关背景。 什么数据结构才能称之为对象？每个对象都有类。这是面向对象的基本概念，但是在Objective-C中，它对数据结构也一样。含有一个指针且该指针可以正确指向类的数据结构，都可以被视作为对象。 在Objective-C中，对象的类是isa指针决定的。isa指针指向对象所属的类。 实际上，Objective-C中对象最基本的定义是这样的： 123typedef struct objc_object &#123; Class isa;&#125; *id; 这说的是：任何带有以指针开始并指向类结构的结构都可以被视作objc_object。 Objective-C中对象最重要的特点是你可以发送消息给它们： 12[@\"stringValue\" writeToFile:@\"/file.txt\" atomically:YES encoding:NSUTF8StringEncoding error:NULL]; 这能工作是因为Objective-C对象（这儿是NSCFString）在发送消息时，运行时库会追寻着对象的isa指针得到了对象所属的类（这儿是NSCFString类）。这个类包含了能应用于这个类的所有实例方法和指向超类的指针以便可以找到父类的实例方法。运行时库检查这个类和其超类的方法列表，找到一个匹配这条消息的方法（在上面的代码里，是NSString类的writeToFile:atomically:encoding:error方法）。运行时库基于那个方法调用函数（IMP）。 重点就是类要定义这个你发送给对象的消息。 什么是元类现在，可能你已经知道了，Objective-C的一个类也是一个对象。这意味着你可以发送消息给一个类。 1NSStringEncoding defaultStringEncoding = [NSString defaultStringEncoding]; 因为Objective-C中每个类本身也是一个对象。如上面所展示的，这意味着类结构必须以一个isa指针开始，从而可以和objc_object在二进制层面兼容，然后这个结构的下一字段必须是一个指向超类的指针（对于基类则为nil）。 正如我上周展示的，类被定义的方式有点不同，依赖于你的运行时库版本，但是，它们都以isa字段开始，随后是superclass字段。 123456typedef struct objc_class *Class;struct objc_class &#123; Class isa; Class super_class; /* followed by runtime specific details... */&#125;; 为了调用类里的方法，类的isa指针必须指向包含这些类方法的类结构体。 这就引出了元类的定义：元类是类对象的类。简单说就是： 当你给对象发送消息时，消息是在寻找这个对象的类的方法列表。 当你给类发消息时，消息是在寻找这个类的元类的方法列表。 元类是必不可少的，因为它存储了类的类方法。每个类都必须有独一无二的元类，因为每个类都有独一无二的类方法。 元类的类是什么？元类，就像之前的类一样，它也是一个对象。你也可以调用它的方法。自然的，这就意味着他必须也有一个类。 所有的元类都使用根元类（继承体系中处于顶端的类的元类）作为他们的类。这就意味着所有NSObject的子类（大多数类）的元类都会以NSObject的元类作为他们的类 根据这个规则，所有的元类使用根元类作为他们的类，根元类的元类则就是它自己。也就是说基类的元类的isa指针指向他自己。 类和元类的继承类用 super_class指针指向了超类，同样的，元类用super_class指向类的super_class的元类。 说的更拗口一点就是，根元类把它自己的基类设置成了super_class。 在这样的继承体系下，所有实例、类以及元类（meta class）都继承自一个基类。 这意味着对于继承于NSObject的所有实例、类和元类，他们可以使用NSObject的所有实例方法，类和元类可以使用NSObject的所有类方法 这些文字看起来莫名其妙难以理解。Greg Parker给出了一份精彩的图谱来展示这些关系： 实验证明为了验证，让我们看看我在文章开始写的ReportFunction 函数的输出。这个函数的目的是跟随isa指针并打印出它的路途。 为了运行ReportFunction，我们需要创建一个动态实例来创建类调用report方法。 1234id instanceOfNewClass = [[newClass alloc] initWithDomain:@\"someDomain\" code:0 userInfo:nil];[instanceOfNewClass performSelector:@selector(report)];[instanceOfNewClass release]; 这里没有声明report方法，但我使用performSelector:调用它，所以编译器不会给出警告。然后ReportFunction函数会沿着isa进行检索，来告诉我们class，meta-class以及meta-class的class是什么样的情况： 得到对象的类：ReportFunction 函数使用object_getClass跟踪isa指针，因为isa指针是类的保护成员（你不能直接接收其他对象的isa指针）。ReportFunction不使用类方法，因为在类对象里调用类方法不能返回元类，它会再次返回这个类（因此[NSString class]会返回NSString 类而不是NSString元类） This is the output (minus NSLog prefixes) when the program runs:这是程序运行时的输出（省略了NSlog前缀）： 12345678This object is 0x10010c810.Class is RuntimeErrorSubclass, and super is NSError.Following the isa pointer 1 times gives 0x10010c600Following the isa pointer 2 times gives 0x10010c630Following the isa pointer 3 times gives 0x7fff71038480Following the isa pointer 4 times gives 0x7fff71038480NSObject's class is 0x7fff710384a8NSObject's meta class is 0x7fff71038480 观察isa到达过的地址的值： 对象的地址是 0x10010c810. 类的地址是 0x10010c600. 元类的地址是 0x10010c630. 根元类（NSObject的元类）的地址是 0x7fff71038480. NSObject元类的类是它本身. 这些地址的值并不重要，重要的是它们说明了文中讨论的从类到meta-class到NSObject的meta-class的整个流程。 最后元类是 Class 对象的类。每个类（Class）都有自己独一无二的元类（每个类都有自己第一无二的方法列表）。这意味着所有的类对象都不同。 元类总是会确保类对象和基类的所有实例和类方法。对于从NSObject继承下来的类，这意味着所有的NSObject实例和protocol方法在所有的类（和meta-class）中都可以使用。 所有的meta-class使用基类的meta-class作为自己的基类，对于顶层基类的meta-class也是一样，只是它指向自己而已。","tags":[{"name":"runtime","slug":"runtime","permalink":"http://yoursite.com/tags/runtime/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"Runtime","slug":"IOS/Runtime","permalink":"http://yoursite.com/categories/IOS/Runtime/"},{"name":"经典文章","slug":"IOS/Runtime/经典文章","permalink":"http://yoursite.com/categories/IOS/Runtime/经典文章/"}]},{"title":"二级指针动态申请内存","date":"2016-10-29T07:53:34.000Z","path":"wiki/C语言语法/CC_pointer_memry/","text":"在读《高质量CC++编程指南》的时候，为了透彻理解二级指针传递内存的原理，写下本文，本文用图形化的方式描述二级指针传递内存的原理。 一级指针不能动态申请内存如果函数的参数是一个指针，不要指望用该指针去申请动态内存，下面的代码试图用GemMemory函数获取内存失败。 1234567891011void GetMemory(char *p,int num)&#123; p = (char*)malloc(sizeof(char)*num);&#125;void Test(void)&#123; char * sz = NULL; GeyMemory(sz,100); ///执行完sz任然为NULL strcpy(sz,\"hello\"); ///运行错误&#125; 下面给出一张图，说明GemMemory函数为什么传递不了内存。 编译器总是为函数的每个参数制作临时副本，在被调用函数内部使用副本，指针p的副本是_p,函数执行前，_p = p ,都指向地址0x00000000处，用虚线头表示；GemMemory函数执行时，_p指向了新申请的内存0xA0101010地址；函数调用结束后，p还指向地址0x00000000处，_p指向了0xA0101010，但应该已经不存在，_p改变不能改变p指针，不能让p指针指向地址0xA0101010出处，执行完的指针指向使用实线表示。所以GemMemory不能传递内存。 二级指针动态申请内存下面是二级指针动态申请内存的示例代码： 1234567891011void GetMemory2(char **p,int num)&#123; *p = (char*)malloc(sizeof(char)*num);&#125;void Test(void)&#123; char * sz = NULL; GeyMemory2(&amp;sz,100); strcpy(sz,\"hello\"); ///没有问题 &#125; 下面给出一张图，说明GemMemory2函数可以传递内存的原因。图中所有地址都是随机写的，不是真实地址。 现在假设，指针p的副本是_p,函数执行前，_p = p，他俩都指向地址0x88888888，0x88888888地址的内容还是个地址，指向地址0x00000000 ；GemMemory2执行时， *_p指向了0xB0101010地址，也就是说，地址0x88888888中的内容变为0xB0101010，那么，*p也就指向了0xB0101010地址。修改*_p，*p也被修改；函数执行结束：二级指针P最终指向了地址0xB0101010。所以GemMemory2可以动态申请内存。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"给IOS模拟器按照APP","date":"2016-10-27T01:15:55.000Z","path":"wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/","text":"这里介绍了给IOS模拟器安装APP的方法。 安装步骤 安装HomeBrew ,终端输入 ： ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” 安装node.js, 终端输入： brew install node 安装ios-sim，在终端中输入 ： npm install ios-sim -g 安装、启动APP ios-sim launch APP路径 –devicetypeid iPhone-6s","tags":[{"name":"IOS 工具","slug":"IOS-工具","permalink":"http://yoursite.com/tags/IOS-工具/"}],"categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"},{"name":"IOS模拟器安装app","slug":"工具/IOS模拟器安装app","permalink":"http://yoursite.com/categories/工具/IOS模拟器安装app/"}]},{"title":"struct定义语法","date":"2016-10-26T10:13:26.000Z","path":"wiki/C语言语法/struct_Analize/","text":"在C语言中，若使用struct node {}这样来定义结构体的话。在定义变量时，需要这样写：struct node n;若用typedef定义结构体，typedef struct node{}NODE; 。在定义变量时可以这样写，NODE n;区别就在于使用时，是否可以省去struct这个关键字。 定义结构体C 定义结构体在C中定义一个结构体类型要用typedef: 1234typedef struct Student&#123; int a;&#125;Stu; Stu就变为了结构体类型，等同于struct Student，相当于一个别名。于是声明变量可以使用： Stu stu1; struct Student stu1; 另外这里也可以不写Student（于是也不能struct Student stu1;了） 1234typedef struct&#123; int a;&#125;Stu; C++ 定义结构体但在c++里很简单，直接 1234struct Student&#123;int a;&#125;; 于是就定义了结构体类型Student，声明变量时直接Student stu2； 在c++中如果用typedef的话，又会造成区别： 123456789struct Student&#123;int a;&#125;stu1;//stu1是一个变量typedef struct Student2&#123;int a;&#125;stu2;//stu2是一个结构体类型 使用时可以直接访问stu1.a但是stu2则必须先 stu2 s2;然后 s2.a=10; struct 与class 的区别在C++里struct 关键字与class 关键字一般可以通用，只有一个很小的区别。struct 的成员默认情况下属性是public 的，而class 成员却是private 的。很多人觉得不好记，其实很容易。你平时用结构体时用public 修饰它的成员了吗？既然struct 关键字与class 关键字可以通用，你也不要认为结构体内不能放函数了。 ##位域有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。为了节省存储空间，并使处理简便，C语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。一、位域的定义和位域变量的说明位域定义与结构定义相仿，其形式为： struct 位域结构名 { 位域列表 }; 其中位域列表的形式为： 类型说明符 位域名：位域长度例如：123456struct bs&#123;int a:8;int b:2;int c:6;&#125;; 下面是IOS runtime中使用位域的一个例子 1234567891011121314 struct &#123; uintptr_t indexed : 1; // 0表示普通的isa指针 1表示优化过的，存储引用计数 uintptr_t has_assoc : 1; // 对象是否包含 associated object，如果没有，析构时会更快 uintptr_t has_cxx_dtor : 1; // 是否有C++或ARC的析构函数，如果没有，析构时会更快 uintptr_t shiftcls : 33; // 最重要的原来的Class cls部分，占33个bit，与 ISA_MASK 进行 &amp; 操作可以得到 // MACH_VM_MAX_ADDRESS 0x1000000000 uintptr_t magic : 6; // 用于调试时分辨对象是否完成初始化 uintptr_t weakly_referenced : 1; // 对象是否有过weak引用，如果没有，析构时会更快 uintptr_t deallocating : 1; // 对象是否正在析构 uintptr_t has_sidetable_rc : 1; // 表示对象的引用计数过大，无法存储在isa指针，只能存在side table中 uintptr_t extra_rc : 19; // 存储引用计数，不过好像是减 1 后的值，可以在 rootRetainCount 方法中看到 // 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。# define RC_ONE (1ULL&lt;&lt;45) // 左移 45 bit，正好是extra_rc 所在的位置# define RC_HALF (1ULL&lt;&lt;18) // extra_rc 总共是19位，RC_HALF是18位，也就是全部引用计数的一半 &#125;; 总结在C语言和C++语言中，struct的定义感觉非常难记忆，我记忆的方法是：首先记住C语言中的struct的定义，“typedef struct Student{}Stu;”，struct Student整体才当做是类型，至于C++的struct的定义不用记，就把struct当成是class，class怎么使用，struct就怎么使用。","tags":[{"name":"C 语言语法","slug":"C-语言语法","permalink":"http://yoursite.com/tags/C-语言语法/"}],"categories":[{"name":"C语言语法","slug":"C语言语法","permalink":"http://yoursite.com/categories/C语言语法/"}]},{"title":"2. 收集崩溃日志方法","date":"2016-10-17T04:18:26.000Z","path":"wiki/IOS/crash/2_Collection_Crash/","text":"本文主要内容： Crash日志收集的方法 搭建一个简单的系统日志收集方案。 系统收集、符号化Crash日志系统如何收集、符号化Crash日志有多种方式，主要有如下几种方式： CrashReporter收集、Xocde或symbolicatecrash符号化。当iOS系统上的某个 APP崩溃时，IOS系统自带的CrashReporter会创建一份crash日志保存在设备上。如果能拿到Crash的手机，就可以通过Xcode或symbolicatecrash符号化Crash日志。如果设备上的Crash 日志超过了一定数量，可能保存不了Crash日志。 第三方SDK。如友盟，鹅厂的Bugly 等等 Crash 打造自己的收集、符号化程序。主要方法：使用NSSetUncaughtExceptionHandler注册异常处理函数，当APP 发生Crash时刻，回调到异常处理函数，在异常处理函数中收集Crash信息，然后上传到服务器；当需要分析的时候，从服务器取回Crash日志，如果没有符号化，使用atos命令符号化。 开源框架KSCrash。如果上面的几种收集、符号化的方式依然不能满足你的需求，那么完备的KSCrash框架应该是一个不错的选择。 CrashReporter收集日志CrashReporter 是IOS自带的工具，当APP发生崩溃时，CrashReporter会创建一份Crash日志并保存到设备上。上一篇阐述的Crash日志，就是出自CrashReporter之手。 可以使用Xcode、iTool导出CrashReporter创建的日志。其中：Xcode导出Crash日志的方法如下： 在Xcode-&gt;Window菜单-&gt;Devices，弹出的设备面板，选择崩溃的设备 -&gt; 选择右侧的View Device Logs-&gt;选中导出的日志，右击，选中export log, 导出.crash后缀的崩溃日志 Xcode 解析Crash日志Xcode可以将日志中的地址信息符号化为代码中的符号，但有个前提条件：crash log和dSYM或APP携带的UUID一致。crash log携带的UUID指的是镜像的UUID。 如果APP是自己电脑编译生成的，Xcode会根据spotlight自动找到对应的符号文件 如果不是自己电脑编译生成的，只需要将.app和dSYM放入同一文件夹，然后手动生成索引，这样Xcode也能找到。在命令行中输入如下命令手动创建索引： 1mdimport pathName mdimport ,导入文件到datastore（import file hierarchies into the metadata datastore）。 上面两种方式确保了Xcode能依据UUID找到地址对应的符号文件，这样，Xcode就能解析出崩溃日志。 使用Xcode解析崩溃日志的方法：在Xcode-&gt;Devices-&gt;View Device Logs中，查看设备的所有崩溃日志，如果能解析，Xcode会自动解析崩溃日志。这种方式可以实现批量解析崩溃日志 。 Xcode解析崩溃日志的优势： 批量解析，可以一次解析出所有可解析的Crash日志。 稳定性比symbolicatecrash好。 symbolicatecrashsymbolicatecrash，按照字面意思理解，就是符号化异常工具。symbolicatecrash符号化日志的一般步骤为： 查找symbolicatecrash的存储位置，symbolicatecrash在各个Xcode版本中的位置都不一样，我没有办法记住每个版本的位置，所以使用查找命令查找symbolicatecrash 的位置 1find /Applications/Xcode.app -name symbolicatecrash -type f #查找symbolicatecrash 的路径。 输出如下: 12AAA$ find /Applications/Xcode.app -name symbolicatecrash -type f/Applications/Xcode.app/Contents/SharedFrameworks/DVTFoundation.framework/Versions/A/Resources/symbolicatecrash 将符号文件、Crash日志、symbolicatecrash放在同一目录下。cd 到该目录下，终端执行命令： 1./symbolicatecrash name.crash 符号文件 &gt; out.txt 如果成功，会将符号化的日志重定向到out.txt中。 备注： 如果执行中遇到下面的错误： 1Error: \"DEVELOPER_DIR\" is not defined at ./symbolicatecrash line 60. 执行下面的命令，设置环境变量 1export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer 打造自己的收集、符号化程序当APP发布到AppStore后，如果发生了Crash，通常情况下我们拿不到崩溃手机，也就是说拿不到Crash日志。这是一个棘手的问题。有人说可以在开发者中心找到用户上传到苹果的日志，但是，不是所有的用户都会在程序Crash后上传Crash日志，所以有必要打造一个属于我们自己的异常收集系统。下面就讲讲我打造的异常收集系统，主要思路：使用NSSetUncaughtExceptionHandler注册异常处理函数，当APP 发生Crash时，回调到异常处理函数，在异常处理函数中收集Crash信息，然后上传到服务器；当需要分析的时候，从服务器取回Crash日志，如果没有符号化，使用atos命令符号化。由于我没有服务器，就保存到了沙盒路径的Document目录下，可以使用itunes方便的导出日志。这里我提供了一个简单示例代码：caughtException。 实现代码这里会分别列出关键的代码。下面是 AppDelegate.m中的代码 123456- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#123; [LJCaughtException setDefaultHandler]; // Override point for customization after application launch. return YES;&#125; 在application:didFinishLaunchingWithOptions:中注册异常处理函数，所有的异常注册和异常处理函数的代码都封装到LJCaughtException.m中，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344///先前注册的处理句柄NSUncaughtExceptionHandler *preHander; /// 异常处理函数void UncaughtExceptionHandler(NSException * exception)&#123; [LJCaughtException processException:exception];&#125; @implementation LJCaughtException + (void)setDefaultHandler&#123; ///首先保存先前注册的异常处理句柄 preHander = [LJCaughtException getHandler]; ///注册异常处理句柄 NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);&#125; + (NSUncaughtExceptionHandler *)getHandler&#123; return NSGetUncaughtExceptionHandler();&#125; ///异常处理句柄+ (void)processException:(NSException *)exception&#123; /// 异常的堆栈信息 NSArray *aryCrashBackTrace = [exception callStackSymbols]; if (!aryCrashBackTrace) &#123; return; &#125; /// 出现异常的原因 NSString *strCrashReason = [exception reason]; /// 异常名称 NSString *strCrashName = [exception name]; ....&#125;... @end 上面代码可以分解为三个部分理解： 定义异常处理函数：异常处理函数的原型为： 1typedef void NSUncaughtExceptionHandler(NSException *exception); 注册异常处理函数：使用NSSetUncaughtExceptionHandler注册异常处理函数,注册的代码为： 1NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler); 执行异常处理函数：当异常发生时，自动执行异常处理函数。异常处理函数内部完成收集Crash信息的功能。 下面是在Debug模式下，Crash时捕获的线程回溯： 可以看出，使用系统的API可以完美的捕获到崩溃日志，而且符号化了，一行代码（callStackSymbols）就获取了异常线程的回溯并完成了符号化工作，不费吹灰之力。其实，事情没有这么简单，不妨试试发布包，是不是也能像在debug和release模式那样，获取到符号化的异常线程回溯？ 发布包没带符号表将测试程序打为发布包，查看异常线程回溯图，如下： 是不是很奇怪，图中红框是异常线程的关键回溯，显示的是镜像的名字，没有被转化为有效的代码符号。这是为什么？ 发布包没有包含符号表，是不是？ 请在终端中使用nm命令验证下。 确实是，发布包没有符号表，为什么？ 原来，符号表是一个debug产物，如果使用archive模式打包，那么符号表会被剪裁掉。不过你也可以在Xcode的编译选项中配置为符号表不剪裁。方法是设置Strip Style选项为Debugging Symbols，但是会让最后生成的IPA变大约%5。我用我们项目测试，居然大了约%30，可能是代码太多的原因吧。这个对于严格限制APP大小的人来说，是无法接受的。下图是设置发布包带符号表的方法： 其实，使用archive打包时，生成了一个dSYM符号文件，这个文件不发布，在本地保存着。 显然，对于发布到用户手中的发布包，在程序Crash后，不能在用户设备上完成符号化工作，callStackSymbols只能返回带地址的日志信息，需要我们线下符号化，还好苹果提供了一个命令行工具—–atos，完成符号化工作。 若想通过atos工具在符号文件中查找到地址对应的符号，需要代码构架、镜像加载地址这两个参数，查看图11，这两个参数都没有，怎么办？我只能祭出OS X ABI Mach-O File Format Reference和KSCrash 开源框架这两个终极神器。OS X ABI Mach-O File Format Reference阐述了可执行二进制程序的存储格式，提供原理性的支撑。KSCrash包含了获取代码构架和镜像加载地址的代码。依据这两个神器，我们可以顺利的拿到代码构架、镜像加载地址。其中《OS X ABI Mach-O File Format Reference》居然在苹果的官网上找不到了，前段时间都能找到的，幸好我又一个备份，我只能放在七牛上保存起来了。 获取构架、镜像加载地址好了，上面说了那么多Mach-O文件结构，主要是提供原理支撑，目的是通过对Mach-O文件结构的理解，找到获取构架、镜像加载地址的方法。 构架很好获取，就在Mach-O的文件头中，获取的关键代码如下 ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* 获取代码的构架 */NSString * getCodeArch()&#123; NSString *strSystemArch =nil; ///获取应用程序的名称 NSDictionary *dicInfo = [[NSBundle mainBundle] infoDictionary]; if (LJM_Dic_Not_Valid(dicInfo)) &#123; return strSystemArch; &#125; NSString *strAppName = dicInfo[@\"CFBundleName\"]; if (!strAppName) &#123; return strSystemArch; &#125; ///获取 cpu 的大小版本号 uint32_t count = _dyld_image_count(); cpu_type_t cpuType = -1; cpu_type_t cpuSubType =-1; for(uint32_t iImg = 0; iImg &lt; count; iImg++) &#123; const char* szName = _dyld_get_image_name(iImg); if (strstr(szName, strAppName.UTF8String) != NULL) &#123; const struct mach_header* machHeader = _dyld_get_image_header(iImg); cpuType = machHeader-&gt;cputype; cpuSubType = machHeader-&gt;cpusubtype; break; &#125; &#125; if(cpuType &lt; 0 || cpuSubType &lt;0) &#123; return strSystemArch; &#125; ///转化cpu 版本为文字类型 switch(cpuType) &#123; case CPU_TYPE_ARM: &#123; strSystemArch = @\"arm\"; switch (cpuSubType) &#123; case CPU_SUBTYPE_ARM_V6: strSystemArch = @\"armv6\"; break; case CPU_SUBTYPE_ARM_V7: strSystemArch = @\"armv7\"; break; case CPU_SUBTYPE_ARM_V7F: strSystemArch = @\"armv7f\"; break; case CPU_SUBTYPE_ARM_V7K: strSystemArch = @\"armv7k\"; break;#ifdef CPU_SUBTYPE_ARM_V7S case CPU_SUBTYPE_ARM_V7S: strSystemArch = @\"armv7s\"; break;#endif &#125; break; &#125;#ifdef CPU_TYPE_ARM64 case CPU_TYPE_ARM64: strSystemArch = @\"arm64\"; break;#endif case CPU_TYPE_X86: strSystemArch = @\"i386\"; break; case CPU_TYPE_X86_64: strSystemArch = @\"x86_64\"; break; &#125; return strSystemArch;&#125; 主要思路是：通过_dyld_image_count 获取到所有的镜像个数，然后根据镜像索引（0…镜像个数-1），依次枚举出镜像的名字，然后，镜像名字使用_dyld_get_image_header函数获取到镜像的header结构体信息，赋值到：mach_header* machHeader中。最后，通过machHeader-&gt;cputype（ CPU的类型）和machHeader-&gt;cpusubtype（CPU的子类型）转化为具体的代码构架。 对于镜像的加载地址，其实就是镜像的header结构体的首地址。详细代码如下 12345678910111213141516171819202122232425262728/* 获取应用程序的加载地址 */NSString * getImageLoadAddress()&#123; NSString *strLoadAddress =nil; NSString * strAppName = getAppName(); if (!strAppName) &#123; return strLoadAddress; &#125; ///获取应用程序的load address uint32_t count = _dyld_image_count(); for(uint32_t iImg = 0; iImg &lt; count; iImg++) &#123; const char* szName = _dyld_get_image_name(iImg); if (strstr(szName, strAppName.UTF8String) != NULL) &#123; const struct mach_header* header = _dyld_get_image_header(iImg); strLoadAddress = [NSString stringWithFormat:@\"0x%lX\",(uintptr_t)header]; break; &#125; &#125; return strLoadAddress;&#125; 主要思路就是：利用_dyld_get_image_header获取镜像的header结构体，header结构体是整个Mach-O的起始部分，所以，header结构体的首地址就是镜像的加载地址。 好了，到目前为止，使用atos符号化崩溃日志的三个条件条件（符号文件、代码构架、镜像加载地址）都有了，那么我们就可以完成异常地址的符号化工作了。所以，到目前为止，我们定制的异常系统基本完成了，收集功能、符号化动能都有了。下面来看看我们的系统输出的内容。 输出Crash日志本崩溃收集系统的输出格式使用json格式，输出的信息包括arch、CrashName、CrashReason、CrashBackTrace、CrashSystemVerson 。有了这些信息，我们完全可以符号化崩溃地址了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; \"strCrashArch\" : \"arm64\", ///代码构架 \"strCrashName\" : \"NSRangeException\", \"strCrashSystemVersion\" : \"10.0.2\", \"strCrashReason\" : \"*** -[__NSArrayI objectAtIndex:]: index 2 beyond bounds [0 .. 1]\", \"aryCrashBackTrace\" : [ &#123; \"strStackAddress\" : \"0x000000018ec6c1d8\", \"strImageName\" : \"CoreFoundation\", \"strImageLoadAddress\" : \"&lt;redacted&gt;\" &#125;, &#123; \"strStackAddress\" : \"0x000000018d6a455c\", \"strImageName\" : \"libobjc.A.dylib\", \"strImageLoadAddress\" : \"objc_exception_throw\" &#125;, &#123; \"strStackAddress\" : \"0x000000018eb48584\", \"strImageName\" : \"CoreFoundation\", \"strImageLoadAddress\" : \"CFRunLoopRemoveTimer\" &#125;, &#123; \"strStackAddress\" : \"0x00000001000b48a0\", ///崩溃地址 \"strImageName\" : \"UncaughtException\", \"strImageLoadAddress\" : \"0x1000B0000\" ///镜像加载地址 &#125;, &#123; \"strStackAddress\" : \"0x0000000194aea7b0\", \"strImageName\" : \"UIKit\", \"strImageLoadAddress\" : \"&lt;redacted&gt;\" &#125;, ........ ........ &#123; \"strStackAddress\" : \"0x0000000194b1b360\", \"strImageName\" : \"UIKit\", \"strImageLoadAddress\" : \"UIApplicationMain\" &#125;, &#123; \"strStackAddress\" : \"0x00000001000b4df0\", \"strImageName\" : \"UncaughtException\", \"strImageLoadAddress\" : \"0x1000B0000\" &#125;, &#123; \"strStackAddress\" : \"0x000000018db285b8\", \"strImageName\" : \"libdyld.dylib\", \"strImageLoadAddress\" : \"&lt;redacted&gt;\" &#125; ]&#125; 小结这章，我们使用苹果的API完成了Crash日志收集系统，这个系统输出的日志可以使用atos在线下符号化。同时介绍了Mach-O的文件结构。 你被默默的坑了吗通常一个大型的APP总是会引用第三方的SDK，第三方SDK也会集成一个Crash收集服务，以及时发现他们SDK的问题。当多个收集服务集成到一个APP中时，难免出现时序问题，强行覆盖等等的恶意竞争，总会有人默默被坑。所以NSSetUncaughtExceptionHandler设置自己的异常处理函数前，要保存先前的异常处理函数。当我们的异常处理函数执行完，执行先前的异常处理函数。这样才能保证多个异常收集系统能有序工作。 深度定制异常收集系统我们上面定制的系统非常简单，功能单一。只能捕获到Object C异常。不能满足实际项目的需求，所以有必要找一个功能完善的异常收集框架，经过筛选，KSCrash是个不错的选择。 KSCrash 是一个异常收集的开源框架。它可以捕获到Mach级内核异常、信号异常、C++异常、Objective-C异常、主线程死锁；当捕获到异常后，KSCrash可以在设备上完成符号化崩溃日志(前提是编译的时候将符号表编译到可执行程序中)；日志的格式你也可以定制，可以是JSON格式的，也可以是Apple crash日志风格。另外，还有僵尸对象查找、内存自省等特性。 总结本文介绍了开发者获取崩溃日志，和解析崩溃日志的一般方法。最后定制了一个简单的崩溃日志收集程序。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"1. 系统Crash日志结构介绍","date":"2016-10-17T04:18:26.000Z","path":"wiki/IOS/crash/1_system_Crash_Type/","text":"由于代码的缺陷，我们千辛万苦发布发布出去的APP，在用户手中，偶尔会出现Crash现象。为了及时查找到Crash的原因，我们需要收集这些Crash信息,解决问题。本文就是从分析系统Crash日志开始，一直到定制个性化的Crash日志收集系统，一步步的说明如何完成Crash日志收集系统。 千里之行，始于足下，我们先从系统Crash日志开始。 系统的Crash日志相信大家都见过，但不一定都认真分析过，所以我想，有必要重新对它做个认识。先贴出一张Crash日志截图，方便大家认识我啊~~~。 Crash日志内容非常，截图只能展示一部分内容，后续会依次贴出每个模块的内容，分别讲解。一个Crash日志由六部分组成：基本信息模块、系统信息模块、异常信息模块、线程回溯、CUP寄存器信息、镜像信息。 基本信息模块1234567891011121314151617181920///崩溃报告的唯一标识符，标识不同的CrashIncident Identifier: 2964A813-5C6B-4E43-B7FD-40965E97F720 CrashReporter Key: d280e6d8a2446a3c34436cf9d1c6e98448d0c5ca///代表发生Crash的设备类型Hardware Model: iPhone7,1 ///Crash的APP名称、APP进程id Process: Simple-Example [2279] ///Crash的APP在设备上的存储路径 Path: /private/var/containers/Bundle/Application/A86C469E-5A97-4948-8BBF-98C0B814088E/Simple-Example.app/Simple-Example ///APP 的描述符 Identifier: com.gome.gomeEShop ///APP的版本 Version: 1.0 (1.0) ///代码的构架，可以通过file命名查看代码的编译构架，///了解更过的构架信息可以到IOS SDK路径下的/usr/include/mach/machine.h文件中查找 Code Type: ARM-64 (Native) Role: Foreground///父进程Parent Process: launchd [1] Coalition: com.gome.gomeEShop [1008] 系统信息模块系统信息模块包含Crash时间、 APP启动时间、OS 版本信息、Crash日志的格式 12345678///Crash发生的时间Date/Time: 2016-10-17 16:11:43.7670 +0800///Crash的APP的启动时间 Launch Time: 2016-10-17 16:11:40.0612 +0800 ///系统版本，（）内的数字代表的是Bulid号 OS Version: iPhone OS 10.0.2 (14A456) Crash日志的格式，一般为104 Report Version: 104 异常信息模块异常信息模块包含异常类型（Mach异常、Unix信号异常）、异常子类型、异常原因、异常线程ID。 12345678910///异常类型Exception Type: EXC_BAD_ACCESS (SIGSEGV) ///异常子类型、异常的地址Exception Subtype: KERN_INVALID_ADDRESS at 0xffffffffffffffff Termination Signal: Segmentation fault: 11///异常原因（非常重要）Termination Reason: Namespace SIGNAL, Code 0xbTerminating Process: exc handler [0]///发生异常的线程IDTriggered by Thread: 0 异常类型(Exception Type)由两部分构成：Mach异常、Unix信号异常。 苹果系统有一个微内核，叫做XNU，它的源码可以在opensource上载到。Mach是XNU的核心，因而，Mach异常就指Mach内核异常。Mach包含三部分内容：thread，task，host。后续的章节中很多地方都会用到Mach。不妨移步到Mach IPC Interface，了解下Mach暴露给用户的API。 Mach暴露给了用户部分API，允许用户和内核交互。用户态的开发者可以通过Mach API设置thread、task、host的异常端口，来捕获Mach异常，抓取Crash事件。 Mach异常包括： 12345678910111213141516171819202122232425262728293031#define EXC_BAD_ACCESS 1 /* Could not access memory */ /* Code contains kern_return_t describing error. */ /* Subcode contains bad memory address. */ #define EXC_BAD_INSTRUCTION 2 /* Instruction failed */ /* Illegal or undefined instruction or operand */ #define EXC_ARITHMETIC 3 /* Arithmetic exception */ /* Exact nature of exception is in code field */ #define EXC_EMULATION 4 /* Emulation instruction */ /* Emulation support instruction encountered */ /* Details in code and subcode fields */ #define EXC_SOFTWARE 5 /* Software generated exception */ /* Exact exception is in code field. */ /* Codes 0 - 0xFFFF reserved to hardware */ /* Codes 0x10000 - 0x1FFFF reserved for OS emulation (Unix) */ #define EXC_BREAKPOINT 6 /* Trace, breakpoint, etc. */ /* Details in code field. */ #define EXC_SYSCALL 7 /* System calls. */ #define EXC_MACH_SYSCALL 8 /* Mach system calls. */ #define EXC_RPC_ALERT 9 /* RPC alert */ #define EXC_CRASH 10 /* Abnormal process exit */ #define EXC_RESOURCE 11 /* Hit resource consumption limit */ Unix信号：信号是通知进程已发生某种情况的软中断技术。例如：某个进程执行了除法操作，其除数为0，则将名为SIGFPE（浮点异常）的信号发送给该进程。 那么，怎么会有两种异常信息呢？ 念茜的漫谈iOS Crash收集框架阐述了两者的关系，我这里再重复下。 苹果系统是基于Unix系统的，苹果的大牛们为了兼容Unix信号，将Mach异常转化为Unix信号，并投射到异常的线程，这样做的目的是：对于不懂Mach异常的人，也可以使用Unix信号捕获异常。所以，Crash日志有两种异常信息。 Mach和Unix关系图： 所有Mach异常都在host层被ux_exception转换为相应的Unix信号，并通过threadsignal将信号投递到出错的线程。 捕获Mach异常或者Unix信号都可以抓到crash事件，这两种方式哪个更好呢？优选Mach异常，因为Mach异常的处理会先于Unix信号处理，如果Mach异常的handler让程序exit了，那么Unix信号就永远不会到达这个进程了。 所以，Crash日志中的EXC_BAD_ACCESS 是Mach异常信息，SIGSEGV是Unix信号异常信息。 小贴士:因为硬件产生的信号(通过CPU陷阱)被Mach层捕获，然后才转换为对应的Unix信号；苹果为了统一机制，于是操作系统和用户产生的信号(通过调用kill和pthread_kill)也首先沉下来被转换为Mach异常，再转换为Unix信号。 线程回溯符号化回溯线程线程的回溯是APP Crash瞬间，程序中所有线程的逆向调用堆栈。线程回溯对我们修复Crash非常非常的有用，根据线程回溯，可以分析、定位程序崩溃的原因。 下面将崩溃的代码、未符号化崩溃日志、符号化崩溃日志贴出来，做个对比性的理解。 12345678@implementation ViewController - (IBAction) onCrash:(__unused id) sender&#123; char* ptr = (char*)-1; *ptr = 10; ///这里程序崩溃了 &#125;@end 图5中红色文字展示了几个名词：镜像文件、加载地址、堆栈地址。还有没有展示出来的一个名词：符号在二进制中的偏移量。他们的含义分别为： 镜像文件：是可执行二进制文件和二进制文件依赖的动态库的总称。堆栈地址：是代码在内存中执行的内存地址。镜像的加载地址：程序执行时，内核会将包含程序代码的镜像加载到内存中，镜像在内存中的基地址就是加载地址。程序每次启动时，镜像的加载地址是随机的。所以，同一代码在不同的设备中执行时，堆栈地址是不一样的。符号在二进制中的偏移量：按照字面意思理解吧。它以通过下面的公式得到： 1符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址 符号在二进制中的偏移量非常有用，我们就是根据它，从符号文件中查找出地址对应的代码符号。这里的符号文件指的是：带有符号表的可执行二进制文件、dSYM文件，这两种文件在后续章节中都统称为符号文件。 那么怎么将图5中的Crash日志符号化为图6中的形式呢？ 苹果自带的atos命令行工具可以查找地址对应的符号，在终端中输入： 1/usr/bin/atos -o [符号文件] -arch arm64 -l 0x100030000 0x000000010003522c 输出结果如下： 1-[ViewController onCrash:] (in Simple-Example) (ViewController.m:10) 是不是很简单的就将地址转换为符号？是的，只需将符号文件（-o指定）、代码构架（-arch指定）、加载地址（-l指定）、堆栈地址 传入atos命令，就能解析出符号。 atos命令解析出了堆栈地址为0x000000010003522c、加载地址为0x100030000对应的符号。符号为[ViewController onCrash:]，也验证了崩溃发生在onCrash函数中，也验证了崩溃日志中的地址是可以符号化的。 符号化是简单，但是原理是什么？怎么就通过地址找到了Crash代码的符号，要听详细信息，请看《符号化内幕》。 符号化内幕符号化的内幕就是：在符号文件中，通过偏移量查找符号。下面，一步步的来分析，首先计算Crash地址在符号文件中的偏移量，为000000010000522c。 1符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址 = 0x000000010003522c - 0x100030000 = 000000010000522c 在符号文件中直接找地址000000010000522c，应该是找不到，在后续你可以理解。我们使用逆向方法，根据符号-[ViewController onCrash:]，找对应的地址，比较是不是000000010000522c，如果是，就充分说明了，通过偏移量是可以查找到内存地址对应的符号的。在终端中输入下面的命令： 1nm [符号文件] | grep \"ViewController onCrash:\" 输出如下 1200008320 t -[ViewController onCrash:]0000000100005224 t -[ViewController onCrash:] 输出的第一行是armv7s构架的符号，第二行是arm64构架的符号，Crash日志显示的代码构架是arm64，使用第二行，符号-[ViewController onCrash:]对应的偏移量是0000000100005224，而不是 000000010000522c，是我给你埋了个坑吗？专门来坑你的？不是的，不是的，这个问题也困扰了我N久、折磨了我N久。这个公式是在stack overflow上找到的，我也怀疑他们骗了我，但是，仔细看两个地址，又那么的相似、那么的相近—就相差8！！！ 虽说相差8，但毕竟不一样。差之毫厘谬以千里啊。感觉就要成功，但就是不对。就永远差了那么一点点，试了好多崩溃日志，都是差那么一点点，相信你也体会过这种感觉，只差一点点，真的只差一点点。就差那么该死的一点点，问题就能解决。百思不得其姐的困扰、抓狂的困扰 。。好久好久我都没想明白，那一点点是怎么差的。这不，今天写日志组织测试用例的时候，忽然明白了为什么差那一点点，踏破铁鞋无觅处，得来全不费功夫！！。原来，我们通过nm命令查找出的符号地址对，是函数入口地址和对应的函数调用的符号对，仅仅是函数调用的符号，没有函数内部代码的符号，而程序是崩溃到函数内部，崩溃到ptr = 10这句话，内部代码的地址怎么可能和入口地址一样呢！相差一点点！下面根据偏移量000000010000522c和代码推算函数的入口地址吧，看看是什么。崩溃代码ptr = 10前面只有一个语句—定义初始化指针“char ptr = (char)-1”，在64位系统上指针的地址占8个字节，000000010000522c - 8= 0000000100005224， 果然是0000000100005224。这个不就是函数的入口地址嘛，对，就是。原来那一点点的原因在这里。 那么偏移量0000000100005224 对应的符号正是-[ViewController onCrash:]。 上面通过nm 命令查找符号可能不直观，可以通过可视化工具MachOView查看。验证下吧，选择 Debug Symbols（ARM64_ALL）-&gt;Symbol Table-&gt;Symbols,然后在右上角的搜索框中输入符号：-[ViewController onCrash:]，结果如下，通过这个工具可以直观的查看到符号和地址的对应关系。 小小结ok，终于可以歇一歇了，我们终于把符号化和符号化原理阐述完了。简单的回顾下： 可以通过系统的atos符号化崩溃日志的单个符号 符号化内部原理就是：根据符号在二进制中的偏移量，在符号文件中查找对应的符号。其中：符号在二进制中的偏移量 = 堆栈地址 - 镜像的加载地址。 线程的状态寄存器12345678910Thread 0 crashed with ARM Thread State (64-bit): x0: 0x000000010050b460 x1: 0x0000000100102cea x2: 0x00000001004339d0 x3: 0x00000001740f8f00 x4: 0x00000001740f8f00 x5: 0x00000001740f8f00 x6: 0x0000000000000001 x7: 0x0000000000000000 x8: 0xffffffffffffffff x9: 0x000000000000000a x10: 0x00000001b3ad0018 x11: 0x00c1580100c15880 x12: 0x0000000000c15800 x13: 0x0000000000c15900 x14: 0x0000000000c158c0 x15: 0x0000000000c15801 x16: 0x0000000000000000 x17: 0x00000001000c1224 x18: 0x0000000000000000 x19: 0x00000001740f8f00 x20: 0x00000001004339d0 x21: 0x0000000100102cea x22: 0x000000010050b460 x23: 0x0000000170240bd0 x24: 0x000000017400db90 x25: 0x0000000000000001 x26: 0x0000000000000000 x27: 0x00000001b2822000 x28: 0x0000000000000040 fp: 0x000000016fd41ab0 lr: 0x0000000194aea7b0 sp: 0x000000016fd41a90 pc: 0x00000001000c122c cpsr: 0x60000000 这是APP crash的时候，ARM64 构架CPU的32个寄存器的值， 其中fp 帧指针、sp堆栈指针，lr 是返回地址指针，这三个都比较有用，用来逐级回溯线程调用栈。 Binary Images 镜像文件就是上面讲的可执行程序 和 依赖的所有动态库。镜像文件中包括镜像的加载地址，和线程回溯中的镜像加载地址指的是一个地址。加载地址后面有个UUID，符号文件中也有个UUID，只有这两个地址一致，才能解析出地址对应的符号。符号文件中的UUID可以通过终端中输入下面的命令得到： 1dwarfdump —u [符号文件] 输出如下： 12UUID: C8E0E6E4-F761-3A19-B231-A31C1BB9037A (armv7) UUID: 39BBB8F4-CCB0-3193-8491-C007931CA05E (arm64) 第二行的arm64构架的UUID居然和图8中的红色矩形框中UUID惊人的一致。是的。必须得一致，这才表示代码对应的符号能在这个符号文件中找到，如果不一致，就没法解析出地址对应的符号。不论是Xcode，还是symbolicatecrash，都解析不了。也可以通过MachOView查看符号文件的UUID，结果如下： 小结这节阐述了崩溃日志的组成结构、通过atos命令行工具符号化崩溃日志以及符号化崩溃日志的原理。同时提及了几个工具有用的工具： file,文件类型显示工具（The file-type displaying tool，位于/usr/bin/file）; atos,(将数字地址转换为镜像或可执行程序中的符号工具，convert numeric addresses to symbols of binary images or processes，位于/usr/bin/atos); nm，（符号表展示工具，The symbol table display tool,位于 /usr/bin/nm）; 可视化查看Mach-O工具，MachOView。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]},{"title":"3. KSCrash原理浅析","date":"2016-07-17T04:18:26.000Z","path":"wiki/IOS/crash/3_KSCrash_Analize/","text":"KSCrash 是一个异常收集的开源框架。它可以捕获到Mach级内核异常、信号异常、C++异常、Objective-C异常、主线程死锁；当捕获到异常后，KSCrash可以在设备上完成符号化崩溃日志(前提是编译的时候将符号表编译到可执行程序中)；日志的格式你也可以定制，可以是JSON格式的，也可以是Apple crash日志风格。另外，还有僵尸对象查找、内存自省等特性。 目前异常收集的框架非常多，有集成了收集、统计功能的一条龙产品，如，友盟，鹅厂的Bugly 等等；也有几个开源框架，如，KSCrash，plcrashreporter，CrashKit。基于我们项目的安全性考虑，即，不希望第三方SDK看到崩溃日志，我选取了开源框架这条路。纵览这几个开源框架，只有KSCrash一直在更新。所以，毫不犹豫的选用了它。 APP Crash后，获取崩溃线程的程调用堆栈的过程，是程序执行过程的逆向过程。那么，了解APP的执行正向过程，对获取崩溃线程的调用堆栈是非常非常有益的。所以，在分析KSCrash原理前，依照APP正向执行过程先推导下 异常收集、符号化的原理。 推导异常收集、符号化的原理本节描述的内容只是按照自己的理解编写的，由于道行尚浅，理解不深，所以具体安排的内容不一定合理。依据APP执行的过程，主要囊括了：编译生成可执行APP、内核加载并启动APP、调用堆栈等，并穿插了一点理解KSCrash的必备知识。 编译生成可执行APP开发者通过IDE集成开发环境（例如Xcode），将源码文件转化为临时中间文件（这种文件应该是机器语言了），然后使用链接器（/usr/bin/ld）将临时的对象文件（object file）合并为可执行文件。不过上面的编译、链接步骤都集成到Xcode中了。我们在Xcode中编译的时候，体会不到这个过程。在苹果系统中，可执行APP的存储格式是Mach-O格式。所以我们先了解下Mach-O文件格式。 Mach-O文件存储格式Mach-O (Mach object的缩写) 是苹果系统上存储可执行程序和库（libraries）的标准格式。它是BSD系统中.a文件格式的替代物，它封装着程序的可执行代码和数据。可以参考《OS X ABI Mach-O File Format Reference》官方文档。这个文档在官网打不来了，我就链接到我自己的pdf地址了。 Mach-O文件包括三个组成部分，分别如下： header：指定了文件的基本信息，如CUP类型、加载命令个数等。 Load commands：加载命令，指定了文件的逻辑结构、在虚拟内存（virtual memory）中文件的布局。你可以理解为一片文章的目录。 Raw segment data：数据部分。 这个是官网上的结构示意图。 headerMach-O文件的开头部分是就是Header—文件头。Header的数据结构定义在XNU微内核的loader.h文件中。loader.h也可以在IOS SDK的/usr/include/mach-o目录下找到，header的数据结构定义如下： 12345678910struct mach_header &#123; uint32_t magic; /* mach magic number identifier */ cpu_type_t cputype; /* cpu specifier */ cpu_subtype_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */&#125;; 可以看出包括了 ：魔数、cup的类型、子类型、文件的类型、load commend个数、load commend大小等数据。 load commend紧跟在Header后面的是load commend。load commend指定了文件的布局。具体指定了以下内容： • The initial layout of the file in virtual memory 文件在虚拟内存中的初始布局 • The location of the symbol table (used for dynamic linking) 符号表的位置 • The initial execution state of the main thread of the program 程序主线程的入口地址 • The names of shared libraries that contain definitions for the main executable’s imported symbols 主执行文件依赖的分享库 load commend 的种类非常多，loader.h 中的定义了各种所有的类型。我们仅以LC_SEGMENT、LC_SYMTAB（符号表）为例了解load commend。每种类型的load commend都有对应的数据结构，可以在loader.h文件中查看。下面是部分类型Load Commond： 1234567891011121314151617#define LC_SEGMENT 0x1 ///代码段#define LC_SYMTAB 0x2 /// 符号表 #define LC_SYMSEG 0x3 /* link-edit gdb symbol table info (obsolete) */#define LC_THREAD 0x4 /* thread */#define LC_UNIXTHREAD 0x5 /* unix thread (includes a stack) */#define LC_LOADFVMLIB 0x6 /* load a specified fixed VM shared library */#define LC_IDFVMLIB 0x7 /* fixed VM shared library identification */#define LC_IDENT 0x8 /* object identification info (obsolete) */#define LC_FVMFILE 0x9 /* fixed VM file inclusion (internal use) */#define LC_PREPAGE 0xa /* prepage command (internal use) */#define LC_DYSYMTAB 0xb /* dynamic link-edit symbol table info */#define LC_LOAD_DYLIB 0xc /* load a dynamically linked shared library */#define LC_ID_DYLIB 0xd /* dynamically linked shared lib ident */#define LC_LOAD_DYLINKER 0xe /* load a dynamic linker */#define LC_ID_DYLINKER 0xf /* dynamic linker identification */#define LC_PREBOUND_DYLIB 0x10 /* modules prebound for a dynamically */................... DataData紧跟在Load Commond后面。load commend中定义的各种数据都存储在这部分中。 查看Mach-O实用工具在终端中有几个工具是可以查看Mach-O文件内容的。另外位于usr/include/mach-o/dyld.h中的函数可以在程序中访问Mach-O文件内容。 文件类型展示工具-file。The file-type displaying tool, 位于/usr/bin/file，显示文件的类型，对于多构架的文件，它显示每个构架下的镜像类型。在终端中输入： 1~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： 123/Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive: Mach-O universal binary with 2 architectures/Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture armv7): Mach-O executable arm/Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): Mach-O 64-bit executable 对象文件展示工具otool。The object-file displaying tool，位于/usr/bin/otool，显示Mach-O文件的各种数据。查看Mach-O header内容，在终端中输入： 1otool -hV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： 123456Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flagsMH_MAGIC ARM V7 0x00 EXECUTE 23 2432 NOUNDEFS DYLDLINK TWOLEVEL PIEMach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flagsMH_MAGIC_64 ARM64 ALL 0x00 EXECUTE 23 2872 NOUNDEFS DYLDLINK TWOLEVEL PIE 可以使用otool 查看load commend。在终端中输入： 1otool -lV ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： 12345678910111213141516Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags0xfeedface 12 9 0x00 2 23 2432 0x00200085Load command 0 cmd LC_SEGMENTcmdsize 56segname __PAGEZEROvmaddr 0x00000000vmsize 0x00004000fileoff 0filesize 0maxprot 0x00000000initprot 0x00000000nsects 0flags 0x0.......... 符号展示工具-nm，The symbol table display tool,位于 /usr/bin/nm, allows you to view the contents of an object file’s symbol table。查看符号表，在终端中输入： 1nm ~/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive 输出： 1234567891011121314151617/Users/lijian/Desktop/收集、解析IOS崩溃日式/Exception/UncaughtException_archive (for architecture arm64): U _NSGetUncaughtExceptionHandler U _NSLog U _NSSearchPathForDirectoriesInDomains U _NSSetUncaughtExceptionHandler U _NSStringFromClass U _objc_msgSend U _objc_msgSendSuper2 U _objc_release U _objc_retain U _objc_retainAutorelease U _objc_retainAutoreleasedReturnValue U _objc_setProperty_nonatomic_copy U _objc_storeStrong U _strstr U dyld_stub_binder ........... 绑定和执行根据上面分析的可执行文件的结构，我们可以看到，可执行文件中已经包含了符号表 ，这个符号表是可执行代码的虚拟地址和代码中符号的对应表。符号表是绑定过程中建立的，程序的绑定有很多种，可以参看下面的文档：Mach-O Programming Topics - Binding Symbols，里面详细介绍了绑定和查找符号的过程。 看到符号表，那么我们可以做这样的设想：如果程序崩溃，只要我们获取到了崩溃调用堆栈的回溯地址，然后从这个符号表中查找对应的符号，就完成了调用堆栈的符号化工作？ 还有就是我们如何获取程序的调用堆栈呢？还有很多需要我们接着往下看。为了知道如何获取调用堆栈的回溯，我们了解下程序的执行过程： 程序的执行过程：内核首先加载可执行文件，并且检测程序文件的起始部分的mach_header结构，内核验证是否合法的Macj-O文件，解析header中的load commands。加载Load Commond中指定依赖镜像到内存中，然后启动进程，执行程序的入口函数，进入正常的run loop。 调用堆栈首先介绍一下什么叫调用堆栈：假设我们为了完成一个任务1，任务1的完成需要完成任务2…. 分别定义为几个函数：function1,function2,function3,funtion4。即，function1调用function2，function2调用function3，function3调用function4。在function4运行过程中，我们可以从线程当前堆栈中了解到调用他的那几个函数分别是谁。function4、function3、function2、function1呈现出一种“堆栈”的特征，最后被调用的函数出现在最上方。因此称呼这种关系为调用堆栈(call stack)。 下面有一个图展示下： 函数调用经常是嵌套的，在同一时刻，堆栈中会有多个函数的信息。每个未完成运行的函数占用一个独立的连续区域，称作栈帧(Stack Frame)。栈帧是堆栈的逻辑片段，当调用函数时逻辑栈帧被压入堆栈, 当函数返回时逻辑栈帧被从堆栈中弹出。栈帧存放着函数参数，局部变量及恢复前一栈帧所需要的数据等。理解了入栈和出栈，基本能理解调用堆栈，下面两个图，一个是入栈，一个是出栈，图中描述的很清楚。 所以获取到崩溃时线程的ebp和esp 就能回溯到上一个调用，依次类推，回溯出所有的调用堆栈。下面了解下寄存器。 寄存器为了线程获取BP和SP，我们需要了解一点点寄存器。因为他们保存在CPU的寄存器中。arm64构架的寄存器在Procedure Call Standard for the ARM 64-bit Architecture (AArch64)有详细的说明。不过都是英文的，我没有看，我从代码中也找到了它的定义，位于IOS SDK的usr/include/arm目录下的_mcontext.h文件中。其中几个关键的定义的代码我摘录下来了，如下： 123456_STRUCT_MCONTEXT64&#123; _STRUCT_X86_EXCEPTION_STATE64 __es; ///异常寄存器 _STRUCT_X86_THREAD_STATE64 __ss; ///线程状态寄存器 _STRUCT_X86_FLOAT_STATE64 __fs; ///浮点寄存器&#125;; 这个结构体定义了所有的寄存器。其中_STRUCT_MCONTEXT64结构体定义了三大类寄存器，根据字面意思理解为：异常寄存器、线程状态寄存器、浮点寄存器。我们只关注线程状态寄存器。 12345678910_STRUCT_ARM_THREAD_STATE64&#123; __uint64_t __x[29]; ///General purpose registers x0-x28 __uint64_t __fp; ///这里就是BP,x29 __uint64_t __lr; /// Link register x30 __uint64_t __sp; ///这里就是SP x31 __uint64_t __pc; Program counter __uint32_t __cpsr; Current program status register __uint32_t __pad; /* Same size for 32-bit or 64-bit clients */&#125;; 不管你见或者不见我我就在那里，BP就在 _STRUCT_MCONTEXT64-&gt;ss.fp里，SP就在_STRUCT_MCONTEXT64-&gt;ss-&gt;sp里。不知不觉的问题已经转化了，转化为获取线程的_STRUCT_X86_THREAD_STATE64数据，即，获取线程的状态结构体。 XNU微内核的核心部分Mach，里面暴露了一些线程的接口函数，我们应该能获取到线程的状态结构体。了解这些函数的接口定义可以参考：Mach IPC Interface、IPC 原理讲解。 获取线程状态IPC 接口文档的线程接口部分（Thread Interface）的 thread_get_state函数可以获取线程的状态。他的定义如下： 12345kern_return_t thread_get_state (thread_act_t target_thread, thread_state_flavor_t flavor, thread_state_t old_state, mach_msg_type_number_t old_state_count); thread_get_state函数返回target_thread的执行状态，存储在flavor参数里。看着上面的定义，是不是一点感觉都没有，一头雾水，摸不着头脑？我也是，幸好KSCrash中有这部分代码，贴出来瞅瞅： 12345678910111213141516171819202122232425bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext)&#123; return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE, ARM_THREAD_STATE_COUNT);&#125; bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount)&#123; mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) &#123; KSLOG_ERROR(\"thread_get_state: %s\", mach_error_string(kr)); return false; &#125; return true;&#125; 上面代码说明了thread_get_state函数可以根据线程ID（thread_t thread），获取到线程状态（_STRUCT_ARM_THREAD_STATE64），也就是通过线程ID，就能获取到线程当前执行状态的BP 和SP。 思路回溯上面讲了，那么多，目的只有一个，就是理出一个思路—–获取程序崩溃时线程的调用堆栈。现在大概是这样的： 程序发生崩溃，我们获取到崩溃的线程，取出线程的threadID。 通过thread_get_state函数， 获取线程ID为threadID的线程的 当前执行状态，目的是获取：帧指针BP、栈指针SP； 依据《调用堆栈》原理、BP、SP，循环取出线程的调用堆栈。 依据《 Mach-O文件存储格式》原理，将调用堆栈中的地址转换为代码中的符号。 总体逻辑现在通了，但是，还有好多好多的细节，等待我们去完善，比如，一个关键的逻辑，我是怎么知道程序崩溃了呢？从而让程序执行到崩溃处理函数里，完成线程回溯功能。 通过分析KS的代码，得知，可以在程序启动的时候注册崩溃的处理函数，程序崩溃发生时，会执行崩溃处理函数。 其实，捕获异常的方式多种多样，不同捕获方式，捕获的原理不同。捕获原理请参看《二、KSCrash异常捕获原理》。这里只扫盲下经典的捕获方式。 捕获崩溃方式捕获崩溃的方式有： 捕获Mach 异常 捕获Unix 信号其实，这部分内容在漫谈 iOS Crash 收集框架中阐述的非常明白。为了表示写的好，这里再重复的阐述下。 iOS 系统自带的Apple’s Crash Reporter 记录在设备中的 Crash 日志，Exception Type项通常会包含两个元素：Mach 异常 和 Unix 信号。 12Exception Type: EXC_BAD_ACCESS (SIGSEGV) Exception Subtype: KERN_INVALID_ADDRESS at 0x041a6f3 Mach 异常是什么？它又是如何与 Unix 信号建立联系的？Mach 是一个 XNU 的微内核核心，Mach 异常是指最底层的内核级异常，被定义在 下 。每个 thread，task，host 都有一个异常端口数组，Mach 的部分 API 暴露给了用户态，用户态的开发者可以直接通过 Mach API 设置 thread，task，host 的异常端口，来捕获 Mach 异常，抓取 Crash 事件。 所有 Mach 异常都在 host 层被ux_exception转换为相应的 Unix 信号，并通过threadsignal将信号投递到出错的线程。iOS 中的 POSIX API 就是通过 Mach 之上的 BSD 层实现的。 因此，EXC_BAD_ACCESS (SIGSEGV)表示的意思是：Mach 层的EXC_BAD_ACCESS异常，在 host 层被转换成 SIGSEGV 信号投递到出错的线程。既然最终以信号的方式投递到出错的线程，那么就可以通过注册 signalHandler 来捕获信号: 1signal(SIGSEGV,signalHandler); 捕获 Mach 异常或者 Unix 信号都可以抓到 crash 事件，这两种方式哪个更好呢？优选 Mach 异常，因为 Mach 异常处理会先于 Unix 信号处理发生，如果 Mach 异常的 handler 让程序 exit 了，那么 Unix 信号就永远不会到达这个进程了。转换 Unix 信号是为了兼容更为流行的 POSIX 标准 (SUS 规范)，这样不必了解 Mach 内核也可以通过 Unix 信号的方式来兼容开发。 KSCrash异常捕获原理KSCrash是一个完备的异常捕获开源框架，它不仅可以捕获到各种异常，并可在设备上完成符号化工作。同时，还有很多高级的特性，例如查找僵尸对象（Zombie）、 内存自省（Introspection）、 主线程死锁检测。 捕获日志流程这里只分析KSCrash获取崩溃日志的原理。下面是主要的流程： 获取崩溃日志主要流程有： 注册异常处理函数 等待异常发生 异常发生 回调到异常处理函数 在异常处理函数中获取异常发生时刻的所有线程 循环获取每个线程的调用堆栈 符号化调用堆栈 保存异常日志 程序结束 下次启动发送上次的崩溃日志 捕获的异常种类根据KSCrash的官网介绍，它可以捕获多种异常,包括： Mach kernel exceptions Fatal signals C++ exceptions Objective-C exceptions Main thread deadlock (experimental) Custom crashes (e.g. from scripting languages) 下面主要介绍下 Mach kernel exceptions、Fatal signals、C++ exceptions异常的注册异常处理函数原理。 Mach异常注册原理下面是mach exceptions 的注册流程图 基本流程是： 首先调用task_get_exception_ports 保存先前的异常处理端口。 调用mach_port_allocate 创建异常处理端口g_exceptionPort。 调用 mach_port_insert_right 获取端口的权限 设置异常处理端口 创建线程，线程中不停的调用mach_msg ，读取g_exceptionPort端口上的数据，如果异常发生，mach_msg成功，进入异常处理流程。 恢复先前的异常处理端口 调用ksmachexc_i_fetchMachineState 获取线程状态。 保存状态并完成符号化功能。 卸载异常处理函数。 千言万语，不如几行代码的说服力，所以后面的内容都使用代码+注释的形式表述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273bool kscrashsentry_installMachHandler(KSCrash_SentryContext* const context)&#123; bool attributes_created = false; pthread_attr_t attr; kern_return_t kr; int error; const task_t thisTask = mach_task_self(); exception_mask_t mask = EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT; if(g_installed) &#123; return true; &#125; g_installed = 1; g_context = context; ///获取先前异常捕获的端口 kr = task_get_exception_ports(thisTask, mask, g_previousExceptionPorts.masks, &amp;g_previousExceptionPorts.count, g_previousExceptionPorts.ports, g_previousExceptionPorts.behaviors, g_previousExceptionPorts.flavors); if(g_exceptionPort == MACH_PORT_NULL) &#123; ///创建异常捕获端口 kr = mach_port_allocate(thisTask, MACH_PORT_RIGHT_RECEIVE, &amp;g_exceptionPort); ///获取端口的权限 kr = mach_port_insert_right(thisTask, g_exceptionPort, g_exceptionPort, MACH_MSG_TYPE_MAKE_SEND); &#125; ///设置异常捕获端口 kr = task_set_exception_ports(thisTask, mask, g_exceptionPort, EXCEPTION_DEFAULT, THREAD_STATE_NONE); ///启动读异常端口数据的线程 pthread_attr_init(&amp;attr); attributes_created = true; pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); error = pthread_create(&amp;g_secondaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadSecondary); g_secondaryMachThread = pthread_mach_thread_np(g_secondaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachSecondary] = g_secondaryMachThread; error = pthread_create(&amp;g_primaryPThread, &amp;attr, &amp;ksmachexc_i_handleExceptions, kThreadPrimary); pthread_attr_destroy(&amp;attr); g_primaryMachThread = pthread_mach_thread_np(g_primaryPThread); context-&gt;reservedThreads[KSCrashReservedThreadTypeMachPrimary] = g_primaryMachThread;failed: return false;&#125; 这里完了展示主要逻辑，去掉了很多日志和错误判断的代码。下面是异常处理函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104void* ksmachexc_i_handleExceptions(void* const userData)&#123; MachExceptionMessage exceptionMessage = &#123;&#123;0&#125;&#125;; MachReplyMessage replyMessage = &#123;&#123;0&#125;&#125;; const char* threadName = (const char*) userData; pthread_setname_np(threadName); if(threadName == kThreadSecondary) &#123; thread_suspend(ksmach_thread_self()); &#125; for(;;) &#123; ///读取异常端口 kern_return_t kr = mach_msg(&amp;exceptionMessage.header, MACH_RCV_MSG, 0, sizeof(exceptionMessage), g_exceptionPort, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); if(kr == KERN_SUCCESS) &#123; break; &#125; &#125; ///读取到异常信息，证明崩溃发生 if(g_installed) &#123; bool wasHandlingCrash = g_context-&gt;handlingCrash; kscrashsentry_beginHandlingCrash(g_context); ///挂起所有的线程 kscrashsentry_suspendThreads(); // Switch to the secondary thread if necessary, or uninstall the handler // to avoid a death loop. if(ksmach_thread_self() == g_primaryMachThread) &#123; KSLOG_DEBUG(\"This is the primary exception thread. Activating secondary thread.\"); if(thread_resume(g_secondaryMachThread) != KERN_SUCCESS) &#123; KSLOG_DEBUG(\"Could not activate secondary thread. Restoring original exception ports.\"); ksmachexc_i_restoreExceptionPorts(); &#125; &#125; else &#123; KSLOG_DEBUG(\"This is the secondary exception thread. Restoring original exception ports.\"); ksmachexc_i_restoreExceptionPorts(); &#125; ///是否正在处理异常 if(wasHandlingCrash) &#123; KSLOG_INFO(\"Detected crash in the crash reporter. Restoring original handlers.\"); // The crash reporter itself crashed. Make a note of this and // uninstall all handlers so that we don't get stuck in a loop. g_context-&gt;crashedDuringCrashHandling = true; kscrashsentry_uninstall(KSCrashTypeAsyncSafe); &#125; /// 填充异常信息 STRUCT_MCONTEXT_L machineContext; if(ksmachexc_i_fetchMachineState(exceptionMessage.thread.name, &amp;machineContext)) &#123; if(exceptionMessage.exception == EXC_BAD_ACCESS) &#123; g_context-&gt;faultAddress = ksmach_faultAddress(&amp;machineContext); &#125; else &#123; g_context-&gt;faultAddress = ksmach_instructionAddress(&amp;machineContext); &#125; &#125; g_context-&gt;crashType = KSCrashTypeMachException; g_context-&gt;offendingThread = exceptionMessage.thread.name; g_context-&gt;registersAreValid = true; g_context-&gt;mach.type = exceptionMessage.exception; g_context-&gt;mach.code = exceptionMessage.code[0]; g_context-&gt;mach.subcode = exceptionMessage.code[1]; g_context-&gt;onCrash(); kscrashsentry_uninstall(KSCrashTypeAsyncSafe); kscrashsentry_resumeThreads(); &#125; // Send a reply saying \"I didn't handle this exception\". replyMessage.header = exceptionMessage.header; replyMessage.NDR = exceptionMessage.NDR; replyMessage.returnCode = KERN_FAILURE; mach_msg(&amp;replyMessage.header, MACH_SEND_MSG, sizeof(replyMessage), 0, MACH_PORT_NULL, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL); return NULL;&#125; signals异常注册下图是signals exceptions 异常处理函数的注册过程： 替换信号处理函数栈 1234int sigaltstack(const stack_t *ss, stack_t *oss);&lt;/signal.h&gt; int sigaction(int signo,const struct sigaction *restrict act, struct sigaction *restrict oact); 给信号signum设置新的信号处理函数act， 同时保留该信号原有的信号处理函数oldact 安装的信号句柄是g_signalStack，信号的种类包括如下： 12345678SIGABRT, /* abort() */SIGBUS, /* bus error */SIGFPE, /* floating point exception */SIGILL, /* illegal instruction (not reset when caught) */SIGPIPE, /* write on a pipe with no one to read it */SIGSEGV, /* segmentation violation */SIGSYS, /* bad argument to system call */SIGTRAP, /* trace trap (not reset when caught) */ C++ exceptions 异常注册这个比较简单，直接调用了标注库的std::set_terminate(CPPExceptionTerminate)函数，设置CPPExceptionTerminate为C++ exceptions 的异常处理函数。 Object C 异常注册具体看代码Sentry 目录下的KSCrashSentry_NSException.m文件 获取线程的调用堆栈、符号化调用堆栈获取线程的调用堆栈、符号化调用堆栈原理 下面只用代码讲解，代码只保留主要逻辑，kscrash_i_onCrash符号化的入口函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990void kscrash_i_onCrash(void)&#123; ... ///根据崩溃上下文context，写崩溃日志 kscrashreport_writeMinimalReport(context, g_recrashReportFilePath); ......&#125; void kscrashreport_writeStandardReport(KSCrash_Context* const crashContext, const char* const path)&#123; ...... /// 写崩溃时刻所有线程的 回溯 kscrw_i_writeAllThreads(writer, KSCrashField_Threads, &amp;crashContext-&gt;crash, crashContext-&gt;config.introspectionRules.enabled, crashContext-&gt;config.searchThreadNames, crashContext-&gt;config.searchQueueNames); .....&#125; void kscrw_i_writeAllThreads(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, bool writeNotableAddresses, bool searchThreadNames, bool searchQueueNames)&#123; const task_t thisTask = mach_task_self(); thread_act_array_t threads; mach_msg_type_number_t numThreads; kern_return_t kr; ///获取所有线程 if((kr = task_threads(thisTask, &amp;threads, &amp;numThreads)) != KERN_SUCCESS) &#123; KSLOG_ERROR(\"task_threads: %s\", mach_error_string(kr)); return; &#125; // Fetch info for all threads. writer-&gt;beginArray(writer, key); &#123; for(mach_msg_type_number_t i = 0; i &lt; numThreads; i++) &#123; kscrw_i_writeThread(writer, NULL, crash, threads[i], (int)i, writeNotableAddresses, searchThreadNames, searchQueueNames); &#125; &#125; ....&#125;void kscrw_i_writeThread(const KSCrashReportWriter* const writer, const char* const key, const KSCrash_SentryContext* const crash, const thread_t thread, const int index, const bool writeNotableAddresses, const bool searchThreadNames, const bool searchQueueNames)&#123; bool isCrashedThread = thread == crash-&gt;offendingThread; char nameBuffer[128]; STRUCT_MCONTEXT_L machineContextBuffer; uintptr_t backtraceBuffer[kMaxBacktraceDepth]; int backtraceLength = sizeof(backtraceBuffer) / sizeof(*backtraceBuffer); int skippedEntries = 0; /// 获取线程状态、 异常状态 STRUCT_MCONTEXT_L* machineContext = kscrw_i_getMachineContext(crash, thread, &amp;machineContextBuffer); ///获取异常线程的回溯 uintptr_t* backtrace = kscrw_i_getBacktrace(crash, thread, machineContext, backtraceBuffer, &amp;backtraceLength, &amp;skippedEntries); if(backtrace != NULL) &#123; ///符号化线程回溯 kscrw_i_writeBacktrace(writer, KSCrashField_Backtrace, backtrace, backtraceLength, skippedEntries); &#125; ......&#125; 代码分析到目前，关键的代码已经出现了，三部分： 获取线程状态、 异常状态 获取异常线程的回溯 符号化线程回溯 获取线程状态 代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960STRUCT_MCONTEXT_L* kscrw_i_getMachineContext(const KSCrash_SentryContext* const crash, const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer)&#123; if(!kscrw_i_fetchMachineState(thread, machineContextBuffer)) &#123; return NULL; &#125; return machineContextBuffer;&#125; bool kscrw_i_fetchMachineState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContextBuffer)&#123; if(!ksmach_threadState(thread, machineContextBuffer)) &#123; return false; &#125; if(!ksmach_exceptionState(thread, machineContextBuffer)) &#123; return false; &#125; return true;&#125; bool ksmach_threadState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext)&#123; return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__ss, ARM_THREAD_STATE64, ARM_THREAD_STATE64_COUNT);&#125; bool ksmach_fillState(const thread_t thread, const thread_state_t state, const thread_state_flavor_t flavor, const mach_msg_type_number_t stateCount)&#123; mach_msg_type_number_t stateCountBuff = stateCount; kern_return_t kr; kr = thread_get_state(thread, flavor, state, &amp;stateCountBuff); if(kr != KERN_SUCCESS) &#123; return false; &#125; return true;&#125; bool ksmach_exceptionState(const thread_t thread, STRUCT_MCONTEXT_L* const machineContext)&#123; return ksmach_fillState(thread, (thread_state_t)&amp;machineContext-&gt;__es, ARM_EXCEPTION_STATE64, ARM_EXCEPTION_STATE64_COUNT);&#125; 获取异常线程的回溯 代码分析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556uintptr_t* kscrw_i_getBacktrace(const KSCrash_SentryContext* const crash, const thread_t thread, const STRUCT_MCONTEXT_L* const machineContext, uintptr_t* const backtraceBuffer, int* const backtraceLength, int* const skippedEntries)&#123; int actualSkippedEntries = 0; int actualLength = ksbt_backtraceLength(machineContext); *backtraceLength = ksbt_backtraceThreadState(machineContext, backtraceBuffer, actualSkippedEntries, *backtraceLength); return backtraceBuffer;&#125; int ksbt_backtraceThreadState(const STRUCT_MCONTEXT_L* const machineContext, uintptr_t*const backtraceBuffer, const int skipEntries, const int maxEntries)&#123; int i = 0; if(skipEntries == 0) &#123; const uintptr_t instructionAddress = ksmach_instructionAddress(machineContext); backtraceBuffer[i] = instructionAddress; i++; &#125; KSFrameEntry frame = &#123;0&#125;; const uintptr_t framePtr = ksmach_framePointer(machineContext); if(framePtr == 0 || ksmach_copyMem((void*)framePtr, &amp;frame, sizeof(frame)) != KERN_SUCCESS) &#123; return 0; &#125; for(; i &lt; maxEntries; i++) &#123; backtraceBuffer[i] = frame.return_address; if(backtraceBuffer[i] == 0 || frame.previous == 0 || ksmach_copyMem(frame.previous, &amp;frame, sizeof(frame)) != KERN_SUCCESS) &#123; break; &#125; &#125; return i;&#125;uintptr_t ksmach_instructionAddress(const STRUCT_MCONTEXT_L* const machineContext)&#123; return machineContext-&gt;__ss.__pc;&#125; 符号化的代码 代码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125struct nlist_64 &#123; union &#123; uint32_t n_strx; /* index into the string table */ &#125; n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */&#125;; typedef struct dl_info &#123; const char *dli_fname; /* Pathname of shared object */ void *dli_fbase; /* Base address of shared object */ const char *dli_sname; /* Name of nearest symbol */ void *dli_saddr; /* Address of nearest symbol */&#125; Dl_info;void kscrw_i_writeBacktrace(const KSCrashReportWriter* const writer, const char* const key, const uintptr_t* const backtrace, const int backtraceLength, const int skippedEntries)&#123; Dl_info symbolicated[backtraceLength]; ksbt_symbolicate(backtrace, symbolicated, backtraceLength, skippedEntries);&#125; #define CALL_INSTRUCTION_FROM_RETURN_ADDRESS(A) (DETAG_INSTRUCTION_ADDRESS((A)) - 1) void ksbt_symbolicate(const uintptr_t* const backtraceBuffer, Dl_info* const symbolsBuffer, const int numEntries, const int skippedEntries)&#123; int i = 0; for(; i &lt; numEntries; i++) &#123; ksdl_dladdr(CALL_INSTRUCTION_FROM_RETURN_ADDRESS(backtraceBuffer[i]), &amp;symbolsBuffer[i]); &#125;&#125; bool ksdl_dladdr(const uintptr_t address, Dl_info* const info)&#123; info-&gt;dli_fname = NULL; info-&gt;dli_fbase = NULL; info-&gt;dli_sname = NULL; info-&gt;dli_saddr = NULL; const uint32_t idx = ksdl_imageIndexContainingAddress(address); if(idx == UINT_MAX) &#123; return false; &#125; const struct mach_header* header = _dyld_get_image_header(idx); const uintptr_t imageVMAddrSlide = (uintptr_t)_dyld_get_image_vmaddr_slide(idx); /// 符号在镜像的偏移量 = 堆栈地址 - 镜像的加载地址 const uintptr_t addressWithSlide = address - imageVMAddrSlide; const uintptr_t segmentBase = ksdl_segmentBaseOfImageIndex(idx) + imageVMAddrSlide; if(segmentBase == 0) &#123; return false; &#125; info-&gt;dli_fname = _dyld_get_image_name(idx); info-&gt;dli_fbase = (void*)header; // Find symbol tables and get whichever symbol is closest to the address. const STRUCT_NLIST* bestMatch = NULL; uintptr_t bestDistance = ULONG_MAX; uintptr_t cmdPtr = ksdl_firstCmdAfterHeader(header); if(cmdPtr == 0) &#123; return false; &#125; for(uint32_t iCmd = 0; iCmd &lt; header-&gt;ncmds; iCmd++) &#123; const struct load_command* loadCmd = (struct load_command*)cmdPtr; ///查找LC_SYMTAB load command if(loadCmd-&gt;cmd == LC_SYMTAB) &#123; const struct symtab_command* symtabCmd = (struct symtab_command*)cmdPtr; const STRUCT_NLIST* symbolTable = (STRUCT_NLIST*)(segmentBase + symtabCmd-&gt;symoff); const uintptr_t stringTable = segmentBase + symtabCmd-&gt;stroff; ///在符号表中循环查找，直到首次达到 镜像偏移量imageVMAddrSlide for(uint32_t iSym = 0; iSym &lt; symtabCmd-&gt;nsyms; iSym++) &#123; // If n_value is 0, the symbol refers to an external object. if(symbolTable[iSym].n_value != 0) &#123; uintptr_t symbolBase = symbolTable[iSym].n_value; uintptr_t currentDistance = addressWithSlide - symbolBase; if((addressWithSlide &gt;= symbolBase) &amp;&amp; (currentDistance &lt;= bestDistance)) &#123; bestMatch = symbolTable + iSym; bestDistance = currentDistance; &#125; &#125; &#125; ///取出符号信息，符号信息存储在 if(bestMatch != NULL) &#123; info-&gt;dli_saddr = (void*)(bestMatch-&gt;n_value + imageVMAddrSlide); info-&gt;dli_sname = (char*)((intptr_t)stringTable + (intptr_t)bestMatch-&gt;n_un.n_strx); if(*info-&gt;dli_sname == '_') &#123; info-&gt;dli_sname++; &#125; // This happens if all symbols have been stripped. if(info-&gt;dli_saddr == info-&gt;dli_fbase &amp;&amp; bestMatch-&gt;n_type == 3) &#123; info-&gt;dli_sname = NULL; &#125; break; &#125; &#125; cmdPtr += loadCmd-&gt;cmdsize; &#125; return true;&#125; 上面是所有的关键代码。用到了一些Mach 的API，单不是苹果私有API，放心用吧。","tags":[{"name":"Crash","slug":"Crash","permalink":"http://yoursite.com/tags/Crash/"}],"categories":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/categories/IOS/"},{"name":"crash","slug":"IOS/crash","permalink":"http://yoursite.com/categories/IOS/crash/"}]}]}