<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>LJ小窝</title>
    
    
        <meta name="keywords" content="LJ小窝">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="勿以恶小而为之 勿以善小而不为">
<meta property="og:type" content="website">
<meta property="og:title" content="LJ小窝">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="LJ小窝">
<meta property="og:description" content="勿以恶小而为之 勿以善小而不为">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LJ小窝">
<meta name="twitter:description" content="勿以恶小而为之 勿以善小而不为">
    

    
        <link rel="alternate" href="/atom.xml" title="LJ小窝" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LJ小窝</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++Primer
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第七章类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第七章类/类/">类</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第三章 字符串、向量、数组
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/">字符串、向量、数组</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第九章顺序容器
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/">顺序容器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章变量和基本类型
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/">变量和基本类型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第八章io库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第八章io库/IO库/">IO库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第六章函数
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第六章函数/函数/">函数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十三章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十三章/拷贝控制/">拷贝控制</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十九章特殊工具和技术
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/">特殊工具和技术</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十二章 动态内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/">动态内存</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十五章 面向对象程序设计
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/">面向对象程序设计</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十六章 模板和泛型编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/">模板和泛型编程</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十四章/重载运算与类型转换/">重载运算与类型转换</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十章 泛型算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/">泛型算法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章 表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/表达式/">表达式</a></li>  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/运算符优先级表/">运算符优先级表</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            附录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/附录/关键字使用的位置/">关键字使用的位置</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++关键字理解
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++关键字理解/explicit-learn/">explicit实例浅析(转载)</a></li>  <li class="file"><a href="/wiki/C++语言/C++关键字理解/static/">static关键字作用总结(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            STL源码剖析
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第二章/空间配置器/">空间配置器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第四章/deque/">deque</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            container
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            deque
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/">deque的实现原理和使用方法详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            list
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/list/C++标准库中的list的实现原理/">C++标准库中的list的实现原理</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++语言/container/容器基本操作/">容器基本操作</a></li>  <li class="file"><a href="/wiki/C++语言/container/forward_list不支持push_back操作/">为什么`forward_list`不支持`push_back`操作？</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C语言语法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C语言语法/CC_pointer_memry/">二级指针动态申请内存</a></li>  <li class="file"><a href="/wiki/C语言语法/union定义/">union定义(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/">堆区（heap）和栈区（stack）的区别(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/struct_Analize/">struct定义语法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Hybird
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            webview
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/webview/gome-Webview/">通用webview开发记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            weex
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/event-analize/">weex 事件原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-conmunication/">weex 通信原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-debug/">搭建weex断点调试环境</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Category
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Category/深入理解Objective-C：Category/">深入理解Objective-C：Category(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GCD
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/GCD/use-dispatch-semaphore/">dispatch_semaphore 的使用方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS12
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/IOS12/IOS12-compatibility/">IOS12 兼容</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            MachO
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/MachO/machoviewer/">mach-o Viewer 源码学习</a></li>  <li class="file"><a href="/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Runtime
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            objc
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/objc/NSObject_isa/">从 NSObject 的初始化了解 isa（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/NSObject_objc_object/">2.深入解析 ObjC 中方法的结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/NSObject_isa的副本/">从 NSObject 的初始化了解 isa（转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            神经病院Objective-C Runtime入院系列文章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/firstDay/">第一天--isa和Class(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/secondDay/">第二天--消息发送与转发（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/">第三天——如何正确使用Runtime(转载)</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/IOS/Runtime/Objective-C-消息发送与转发机制原理/">Objective-C 消息发送与转发机制原理</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/meta_class/">What is a meta-class in Objective-C(译文)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            crash
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/crash/Analize_Crash/">收集、符号化IOS崩溃日志</a></li>  <li class="file"><a href="/wiki/IOS/crash/KSCrash_Analize/">KSCrash崩溃收集原理浅析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            foundation使用记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSDateFormatter时间格式/">NSDateFormatter 时间格式</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/">NSInvocation的基本使</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            事件处理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/事件处理/iOS事件处理/">iOS事件处理看我就够了(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            内存管理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/内存管理/内存学习/">内存学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            动态库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/动态库/static_lib_aggregate_script/">合并真机模拟器静态库(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/库/组件化-库/">组件化-库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            开源库学习
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            fishhook
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/fishHookPicture/">图解fishhook</a></li>  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/learn_fishhook/">fishhook学习记录</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            暂无分类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/暂无分类/指定初始化函数/">正确使用NS_DESIGNATED_INITIALIZER</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            虚拟内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a></li>  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JS
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/JS/flexBox/">flexBox 伸缩盒子模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WWDC
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/WWDC/What’s New in User Notifications/">What’s New in User Notifications</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            linux命令
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/linux命令/export命令/">export命令</a></li>  <li class="file"><a href="/wiki/linux命令/set命令/">set命令</a></li>  <li class="file"><a href="/wiki/linux命令/特殊参数/">set命令</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cocoapods
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Cocoapods/Cocoapods-new-spec/">Cocoapods-new-spec</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-private-repo/">创建私有仓库</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-learn-install/">cocoapod学习 安装和使用（1）</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS模拟器安装app
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/">给IOS模拟器按照APP</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SSH
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/SSH/ssh-theory/">图解SSH原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Xcode编译常量
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Xcode编译常量/xcode编译环境变量/">Xcode编译环境变量</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git简略版
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git简略版/git简略版/">Git笔记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git详细记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git详细记录/git仓库/">Git仓库(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git分支管理/">Git分支管理(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git工作区/">git时光穿梭(转载)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            hexo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/hexo/LaTex/">支持LaTEX的hexo博客</a></li>  <li class="file"><a href="/wiki/工具/hexo/hexo-use/">hexo使用指南</a></li>  <li class="file"><a href="/wiki/工具/hexo/自己搭建博客的经历/">自己搭建博客的经历</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            markdowm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/markdowm/Markdown公式编辑学习笔记/">Markdown公式编辑</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ruby
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具下载地址
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/工具下载地址/工具下载地址/">工具下载地址</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据知识/数学基础知识/">数学知识一对数指数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            编程基础
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            正则表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程基础/正则表达式/正则表达式学习/">正则表达式学习摘要</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main">
        <article id="post-IOS/虚拟内存/虚拟内存之2" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/虚拟内存/">虚拟内存</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/虚拟内存/">虚拟内存</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/虚拟内存/虚拟内存之2/">
            <time datetime="2018-06-02T04:07:12.000Z" itemprop="datePublished">2018-06-02</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p></p><p>If you need more detailed information about virtual memory usage, you can use the top, vm_stat, pagestuff, and vmmap command-line tools for analyzing your Mac apps. The information returned by these tools ranges from summary information about all the system processes to detailed information about a specific process.<br>如果您需要关于虚拟内存使用的更详细的信息，您可以使用上面的vm_stat、pagestuff和vmmap命令行工具来分析您的Mac应用程序。这些工具返回的信息范围从关于所有系统流程的总结信息到关于特定流程的详细信息。</p>
<p>The following sections provide information on using the vm_stat, pagestuff, and vmmap tools to gather detailed memory information. For more information on using Instruments to analyze memory, see <a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">Instruments User Guide</a> and the other articles in this document. For information on how to use the top tool,<br>以下部分提供了关于使用vm_stat、pagestuff和vmmap工具收集详细内存信息的信息。有关使用仪器分析内存的更多信息，请参阅<a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html#//apple_ref/doc/uid/TP40004652" rel="external nofollow noopener noreferrer" target="_blank">仪器用户指南</a>和本文中的其他文章。有关如何使用顶部工具的信息，请参见<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">2</a>。see <a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/PerformanceOverview/Introduction/Introduction.html#//apple_ref/doc/uid/TP40001410" rel="external nofollow noopener noreferrer" target="_blank">Performance Overview</a>.</p><p></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/IOS/虚拟内存/虚拟内存之2/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-IOS/虚拟内存/虚拟内存" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/虚拟内存/">虚拟内存</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/虚拟内存1/">虚拟内存1</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/虚拟内存/虚拟内存/">
            <time datetime="2018-06-01T04:07:12.000Z" itemprop="datePublished">2018-06-01</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p></p><p>这篇文章翻译下<a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" rel="external nofollow noopener noreferrer" target="_blank">Memory Usage Performance Guidelines</a></p><p></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/IOS/虚拟内存/虚拟内存/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-IOS/MachO/MachO_FileStructure" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/MachO/">MachO</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Mach-O/">Mach-O</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/MachO/MachO_FileStructure/">
            <time datetime="2018-05-16T04:07:12.000Z" itemprop="datePublished">2018-05-16</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p></p><p>Mach-O是mac系统中文件的存储格式。熟悉Mach-O 文件结构可以：</p>
<ol>
<li>有助于理解崩溃日志解析的原理。理解KSCrash源码；</li>
<li>有助于理解开源代码fishhook的原理；</li>
<li>有助于理解腾讯OOMDetector开源库源码；</li>
<li>好处应该不止这些。</li>
</ol><p></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/IOS/MachO/MachO_FileStructure/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Hybird/weex/Weex_six_events" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/Weex_six_events/">
            <time datetime="2018-05-04T05:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p><!--
<p align='center'>
<img src='http://upload-images.jianshu.io/upload_images/1194012-cc51f3fa785a0464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240'>
</p>
--></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/Hybird/weex/Weex_six_events/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Hybird/weex/weex_two" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/weex_two/">
            <time datetime="2018-05-04T04:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="关于Weex"><a href="#关于Weex" class="headerlink" title="关于Weex"></a>关于Weex</h2><p>Weex是一套跨平台的动态页面解决方案，让开发者可以用前端的语法写出Native级别的体验，这一点核心功能与React Native是相同的，但RN并不是今天的主角， 这里也不多花笔墨介绍。WEEX宣称「Write Once, Run Everywhere」，同一份代码可以在不同端上运行。Weex是如何做到的呢？</p>
<p>话不多说，先上一张上镜率特别高的流程图，了解一下Weex的工作流程：</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex1.jpg" alt=""></p>
<p>在服务端，开发者将写好的Weex文件转换成JS bundle并部署到服务器上供终端下载；终端会在合适的时机拉取JS Bundle，同时利用WeexSDK 中预先准备好的 JavaScript 引擎解析执行JS bundle，在执行过程中通过JS-Native Bridge产生各种终端能够识别的命令进行界面渲染或数据存储、网络通信、调用设备功能、用户交互响应等移动应用的场景实践。</p>
<h2 id="Weex框架"><a href="#Weex框架" class="headerlink" title="Weex框架"></a>Weex框架</h2><p>Weex源码可以在Github(<a href="https://github.com/apache/incubator-weex)上下载到，先看下0.16.1版本下的文件目录结构：" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/apache/incubator-weex)上下载到，先看下0.16.1版本下的文件目录结构：</a></p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex2.jpg" alt=""></p>
<p>目录的划分比较清楚，一个目录基本就是对应一个功能模块，我们可以对其做一个归类，把它分为三端：JS端、桥接端和纯Native端。见下图：（灰色的方块代表一个文件目录）</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex3.jpg" alt=""></p>
<h2 id="JS端"><a href="#JS端" class="headerlink" title="JS端"></a>JS端</h2><p>JS端主要内容是Weex源码中的native-bundle-main.js文件，它提供了一系列Weex的基础JS方法，作用相当于一个库，因此我们又称之为JS Framework。Weex把JS Bundle拆分为基础JS库和业务JS代码， 并把JS库带到安装包中，这样一来，页面请求的JS Bundle就只需要包含业务代码，体积会变得很小，对于加载速度提升大有裨益。JS Framework会在WeexSDK初始化时被加载到内存中。</p>
<h2 id="桥接端（Bridge）"><a href="#桥接端（Bridge）" class="headerlink" title="桥接端（Bridge）"></a>桥接端（Bridge）</h2><p>桥接层负责JS和Native的通信，主要依靠一个全局的JSContext作为媒介。WeexSDK初始化时会往这个全局的JSContext中注入一些方法，举个栗子：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">JSValue* </span>(^callNativeBlock)(<span class="keyword">JSValue </span>*, <span class="keyword">JSValue </span>*, <span class="keyword">JSValue </span>*) = ^<span class="keyword">JSValue*(JSValue </span>*<span class="keyword">instance, </span><span class="keyword">JSValue </span>*tasks, <span class="keyword">JSValue </span>*callback)&#123;</span><br><span class="line">        NSString *<span class="keyword">instanceId </span>= [<span class="keyword">instance </span>toString]<span class="comment">;</span></span><br><span class="line">        NSArray *tasksArray = [tasks toArray]<span class="comment">;</span></span><br><span class="line">        NSString *callbackId = [callback toString]<span class="comment">;  </span></span><br><span class="line">      return [<span class="keyword">JSValue </span>valueWithInt32:(int32_t)callNative(<span class="keyword">instanceId, </span>tasksArray, callbackId) inContext:[<span class="keyword">JSContext </span>currentContext]]<span class="comment">;</span></span><br><span class="line">    &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    _jsContext[@<span class="string">"callNative"</span>] = callNativeBlock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而终端调用JS也是通过取JSContext对象，调用invokeMethod:withArguments:方法实现。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (JSValue *)callJSMethod:(NSString *)<span class="function"><span class="keyword">method</span> <span class="title">args</span>:</span>(NSArray *)args</span><br><span class="line"><span class="comment">&#123;    </span></span><br><span class="line"><span class="comment">    return [[_jsContext globalObject] invokeMethod:method withArguments:args];</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="纯Native端"><a href="#纯Native端" class="headerlink" title="纯Native端"></a>纯Native端</h2><font color="red">主要的业务都代码都是这一端，包括JS Bundle的请求、UI渲染、性能统计等等。功能层面对其自上而下划分，又可拆分为接口层（Interface）、功能层（Function）、基础层（Basic）。</font>

<p>接口层顾名思义，就是对外暴露API的模块，是最贴近开发者的一层。通过Engine可以对SDK进行初始化，同时注册一些通用的Component和Module，JS Framework会在此时被加载。Controller不必多说，可以使用这个现成的Controller创建一个weex页面，我们需要做的仅仅是传递一个url给它。但如果想要自已实现一个Weex Controller而不是继承它，这个时候就需要用到Model中的WXSDKInstance，Weex渲染过程的各个阶段都会在WXSDKInstance中有回调，JS Bundle的请求也是在这个类中发出。</p>
<p>先绕过功能层，看基础层。基础层提供了一些基础的、与业务无强相关的功能。如Network就是对NSURLSession进行一次再封装，提供基础的下载功能；Event用来定义一些标准手势事件；Layout则是页面布局相关实现，布局引擎采用C语言，可以跨平台使用。Event和Layout最终都服务于Component。</p>
<p>最后是代码最重的功能层，其中Monitor和DevTool是相对比较独立的，Monitor是测速模块，DevTool用来支持远程调试的，可以不集成到代码中，不影响编译，此处不谈。</p>
<p>Module、Component和Handler是Weex三贱客，它们都是采用插件的形式集合到SDK中，很方便扩展。注册的时机也相同，SDK会在初始化时调用registerDefaultModules/Compoents/Handlers加载一些标准的插件。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)registerDefaults</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">self _registerDefaultComponents</span>];</span><br><span class="line">    [<span class="meta">self _registerDefaultModules</span>];</span><br><span class="line">    [<span class="meta">self _registerDefaultHandlers</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// register some default components when the engine initializes.+ (void)_registerDefaultComponents</span></span><br><span class="line">&#123;</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"container"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXDivComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"div"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"text"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXTextComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    [self <span class="string">registerComponent:</span>@<span class="string">"image"</span> <span class="string">withClass:</span>NSClassFromString(@<span class="string">"WXImageComponent"</span>) <span class="string">withProperties:</span>nil];</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从注册时的命名上不难看出，<font color="red">Component实现的是UIKit的功能。</font>那还有两贱客是干吗的？<font color="red">我们可以认为Module是终端提供给JS的功能模块，为了让JS获得终端的能力，例如网络请求的能力（WXStreamModule）、定时器的能力（WXTimerModule）等。三贱客里，Component和Module都是可以直接和JS通信的，而Handler不行，Handler仅仅作为面向协议编程的一种手段，在纯Native端使用</font>。</p>
<p>Loader就是采用了Handler的形式对Network进行了进一步的再封装，用这种方式会让Loader模块更灵活一些，开发者完全可以通过重新注册Handler来挂载新的网络请求方法，实现一些自定义的功能。</p>
<font color="red">除了Component和Module，还有一个模块可以直接和JS通信，就是结构图中与桥接端相邻的Manager（与桥接端相邻代表二者可以直接通信），Manager模块主要包括WXComponentManager和Factory，WXComponentManager用来做Component的调度，而Factory用来保存Component和Module的配置。</font>

<p>讲完了WeexSDK源码框架，或许读者还是会有不少疑问：说了那么一堆高大上的名词，然并卵，我还是不知道Weex是怎么跑起来的。那我们就更具体一点，去看看Module和Component的世界吧。</p>
<h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>前面有一个高频词汇：注册。<font color="red">所谓注册，其实在实现上就是往全局字典里面以Key-Value的形式保存一些模块的信息。</font>Weex三贱客都需要注册，Handler的注册上文提到过，其实就是以Protocol Name为Key，往全局字典里面写入一个实现了该Protocol的对象。Module和Component的注册则更接近一些，都是以注册时的标签为Key，而保存的value是一个WXInvocationConfig派生类对象，可以瞄一眼WXInvocationConfig携带的信息，包括：标签名、类名、同步方法和异步方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXInvocationConfig</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *clazz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *asyncMethods;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *syncMethods;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name <span class="keyword">class</span>:(<span class="built_in">NSString</span> *)clazz;</span><br><span class="line">- (<span class="keyword">void</span>)registerMethods;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>以WXDomModule为例，在WXDomModule的类实现文件中有一坨被WX_EXPORT_METHOD宏定义包裹的selector：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">createBody</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">addElement</span>:<span class="attribute">element</span>:<span class="attribute">atIndex</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">removeElement</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">moveElement</span>:<span class="attribute">parentRef</span>:<span class="attribute">index</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">addEvent</span>:<span class="attribute">event</span>:))</span><br><span class="line"><span class="selector-tag">WX_EXPORT_METHOD</span>(<span class="variable">@selector</span>(<span class="attribute">removeEvent</span>:<span class="attribute">event</span>:))</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define WX_EXPORT_METHOD(<span class="function"><span class="keyword">method</span>) <span class="title">WX_EXPORT_METHOD_INTERNAL</span><span class="params">(<span class="keyword">method</span>,wx_export_method_)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WX_EXPORT_METHOD_INTERNAL</span><span class="params">(<span class="keyword">method</span>, token)</span> \</span></span><br><span class="line"><span class="function">+ <span class="params">(NSString *)</span><span class="title">WX_CONCAT_WRAPPER</span><span class="params">(token, __LINE__)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment"> \    return NSStringFromSelector(method); \</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">#<span class="title">define</span> <span class="title">WX_CONCAT_WRAPPER</span><span class="params">(a, b)</span>    <span class="title">WX_CONCAT</span><span class="params">(a, b)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (NSString *)wx_export_method_40 &#123;   </span><br><span class="line"> <span class="keyword">return</span> NSStringFromSelector(<span class="meta">@selector(createBody:)</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerMethods</span><br><span class="line">&#123;</span><br><span class="line">    Class currentClass = <span class="built_in">NSClassFromString</span>(_clazz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (currentClass != [<span class="built_in">NSObject</span> <span class="keyword">class</span>]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">        Method *methodList = class_copyMethodList(object_getClass(currentClass), &amp;methodCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *selStr = [<span class="built_in">NSString</span> stringWithCString:sel_getName(method_getName(methodList[i])) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">            <span class="built_in">BOOL</span> isSyncMethod = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">if</span> ([selStr hasPrefix:<span class="string">@"wx_export_method_sync_"</span>]) &#123;</span><br><span class="line">                isSyncMethod = <span class="literal">YES</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([selStr hasPrefix:<span class="string">@"wx_export_method_"</span>]) &#123;</span><br><span class="line">                isSyncMethod = <span class="literal">NO</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSString</span> *name = <span class="literal">nil</span>, *method = <span class="literal">nil</span>;</span><br><span class="line">            SEL selector = <span class="built_in">NSSelectorFromString</span>(selStr);</span><br><span class="line">            <span class="keyword">if</span> ([currentClass respondsToSelector:selector]) &#123;</span><br><span class="line">                method = ((<span class="built_in">NSString</span>* (*)(<span class="keyword">id</span>, SEL))[currentClass methodForSelector:selector])(currentClass, selector);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSRange</span> range = [method rangeOfString:<span class="string">@":"</span>];</span><br><span class="line">            <span class="keyword">if</span> (range.location != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">                name = [method substringToIndex:range.location];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                name = method;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *methods = isSyncMethod ? _syncMethods : _asyncMethods;</span><br><span class="line">            [methods setObject:method forKey:name];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        free(methodList);</span><br><span class="line">        currentClass = class_getSuperclass(currentClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用完registerMethods方法后，WXDomModule的Config包含的信息如下：</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex4.jpg" alt=""></p>
<font color="red">同步方法和异步方法存储的Key列表就是JS端可调用的函数名列表。</font>趁热打铁，继续看下JS端是具体是怎么调用这些暴露出去的方法。<br><br>在前文第二节Weex框架中有提到，WeexSDK会在桥接层往JSContext注入一些方法作为JS调用Native的通道，其中callNativeModule方法就是用来调用Native Module的（JS调用Module不仅限于callNativeModule方法）。<br><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">_jsBridge</span> registerCallNativeModule:^NSInvocation*(<span class="name">NSString</span> *instanceId, NSString *moduleName, NSString *methodName, NSArray *arguments, NSDictionary *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [<span class="name">WXSDKManager</span> instanceForID:instanceId]<span class="comment">;</span></span><br><span class="line">    WXModuleMethod *method = [[<span class="name">WXModuleMethod</span> alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments options:options instance:instance]<span class="comment">; </span></span><br><span class="line">   return [<span class="name">method</span> invoke]<span class="comment">;</span></span><br><span class="line">&#125;]<span class="comment">;</span></span><br></pre></td></tr></table></figure><br><br>| Moudule | 能力<br>| — | — |<br>| WXDomModule | 提供Demo解析能力 |<br>| WXNavigatorModule | 提供控制UI能力 |<br>| WXStreamModule | 提供网络请求能力 |<br>| WXAnimationModule | 提供动画能力<br> |<br>| WXModalUIModule | 提供alert、toast等模态UI展示能力 |<br>| WXWebViewModule | 提供webview基础能力<br> |<br>| WXInstanceWrap | 提供访问终端instance实例能力 |<br>| WXTimerModule | 提供定时器能力 |<br>| WXStorageModule | 提供持久化能力 |<br>| WXClipboardModule | 提供剪切板能力 |<br>| WXGlobalEventModule | 提供全局事件(监听通知)能力 |<br>| WXCanvasModule | 提供绘图能力 |<br>| WXPickerModule | 提供DatePicker和TimePicker能力 |<br>| WXMetaModule | 提供设置视口(viewport)能力 |<br>| WXWebSocketModule | 提供WebSocket能力 |<br>| WXVoiceOverModule | 提供VoiceOver能力 |<br><br>## Component<br><br>理解了Module后再来看一下Component。前面提到过Component的主要作用对应UIKit,每一个Component类就与一种UI类型强相关，如tableView、imageView。Component维护了一个生命周期，这一点跟UIViewController有点相似：<br><br><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex5.jpg" alt=""><br><br>Component的init方法有许多参数要传，包括样式、属性、事件等都可以在初始化时传入；loadView时，WXComponent的派生类需要返回一个UI类型实例，它会被赋值给Component的view属性，跟Component关联起来；loadView之后会走到addEvent，这里允许我们添加一些自定义的事件（常用的单击、长按等事件已经实现，在初始化时传入即可，不需要操作addEvent方法）；在viewDidLoad中可以对view做个性化的配置，然后启动布局。<br><br>Weex允许在view加载出来了以后再去updateStyles/Attributes，JS可以直接访问到这个Component对象。<br><br>JS调用Component的原理和Module基本一样，通过注入的callNativeComponent、callUpdateAttrs等一系列方法，在调用过程中生成一个WXComponentMethod对象，然后再利用NSInvocation invoke触达Native。除此之外，JS还可以通过WXComponentManager间接调用Component。<br><br><font color="red">WXComponentManager是Component的调度器，可以直接和JS通信。注入JSContext的方法中与其相关的有callAddElement、callRemoveElement、callAddEvent等,通过这些方法直接调用WXComponentManager即图示中的链路①。而在首屏渲染时通常走的是链路②，即JS Framework在解析JS Bundle时会先访问WXDomModule，然后再由WXDomModule间接地调用WXComponentManager，两种方式其实没有太大差别，在首屏全部使用WXDomModule会更容易监控Dom解析过程而已。</font>

<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex6.jpg" alt=""></p>
<p>addComponent的作用类似于addSubview，WXComponentManager会先用JS传递过来的componentData创建Component对象，然后再把生成的Component添加到它supercomponent的树结构中，同时把Component关联的view加到视图层级上去，之后再对它的children结点递归调用addComponent。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)<span class="string">_recursivelyAddComponent:</span>(NSDictionary *)componentData <span class="string">toSupercomponent:</span>(WXComponent *)supercomponent <span class="string">atIndex:</span>(NSInteger)index <span class="string">appendingInTree:</span>(BOOL)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *component = [self <span class="string">_buildComponentForData:</span>componentData <span class="string">supercomponent:</span>supercomponent];</span><br><span class="line">    [supercomponent <span class="string">_insertSubcomponent:</span>component <span class="string">atIndex:</span>index];</span><br><span class="line">    <span class="keyword">if</span> (!component-&gt;_isTemplate) &#123;</span><br><span class="line">        [supercomponent <span class="string">insertSubview:</span>component <span class="string">atIndex:</span>index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSArray *subcomponentsData = [componentData <span class="string">valueForKey:</span>@<span class="string">"children"</span>];</span><br><span class="line">    BOOL appendTree = !appendingInTree &amp;&amp; [component.attributes[@<span class="string">"append"</span>] <span class="string">isEqualToString:</span>@<span class="string">"tree"</span>];   </span><br><span class="line">     <span class="comment">// if ancestor is appending tree, child should not be laid out again even it is appending tree.</span></span><br><span class="line">    <span class="keyword">for</span>(NSDictionary *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [self <span class="string">_recursivelyAddComponent:</span>subcomponentData <span class="string">toSupercomponent:</span>component <span class="string">atIndex:</span><span class="number">-1</span> <span class="string">appendingInTree:</span>appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    [component _didInserted];  </span><br><span class="line">      <span class="keyword">if</span> (appendTree) &#123;   </span><br><span class="line">           <span class="comment">// If appending tree，force layout in case of too much tasks piling up in syncQueue</span></span><br><span class="line">        [self _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex7.jpg" alt=""></p>
<p>WXComponentManager中会起一个DisplayLink，在每个定时周期循环遍历各个元素，检查是否需要更新布局，需要布局的cssNode会在is_dirty字段标识。<font color="red">如果超过1s没有布局任务，DisplayLink会进入休眠状态直至下一次唤醒。</font></p>
<h2 id="WXSDKInstance"><a href="#WXSDKInstance" class="headerlink" title="WXSDKInstance"></a>WXSDKInstance</h2><font color="red">在了解过Module和Component的大致原理后，对Weex已经有一个基本认知，但距离整个流程跑通还欠缺一点。分散的Module和Component本身是不会工作的，还需要一个动力，这时我们的WXSDKInstance就要粉墨登场了。</font>

<p>还记得最初的那张Weex框架图吗？ WXSDKInstance（在Model模块里）是整个Weex页面加载的起点，它会去服务端请求JS Bundle，没有JS Bundle我们什么事都干不了！</p>
<p>WXSDKInstance下载JS Bundle后，会把它传给JS Framework，JS Framework解析JS Bundle并通过WXDomModule往RootView上渲染视图。每个WXSDKInstance都会绑定一个独立的WXComponentManager。</p>
<p>用图表示的话，流程大概是下面这样子，WXSDKInstace负责串联各部分模块并带动整个流程：</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex8.jpg" alt=""></p>
<p>在一些关键的流程上，WXSDKInstance都会有回调，如图上标注出的onCreate()是在下载完JS Bundle，RootView被创建出时回调；renderFinish()是在首屏Dom解析完成后回调；除此之外，还有onFailed()会在加载失败时回调，onJSRuntimeException()在JS执行异常时回调。这些回调都是对外暴露的，我们可以这些回调上做一些定制化的内容。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li>
<li><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">官方手册</a></li>
<li><a href="https://mp.weixin.qq.com/s/Hh3vXjQ8nZDJny1bd0xYOw" rel="external nofollow noopener noreferrer" target="_blank">企鹅电竞weex实践—— iOS SDK的小九九</a></li>
</ol>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Hybird/weex/Weex_five" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/Weex_five/">
            <time datetime="2018-05-04T04:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>1.Weex布局算法</li>
<li>2.Weex布局算法性能分析</li>
<li>3.Weex是如何布局原生界面的</li>
</ul>
<h3 id="一-Weex布局算法"><a href="#一-Weex布局算法" class="headerlink" title="一. Weex布局算法"></a>一. Weex布局算法</h3><p>打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。</p>
<p>Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。</p>
<p>当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-de7f409bd683080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(<a href="https://facebook.github.io/yoga/" rel="external nofollow noopener noreferrer" target="_blank">Yoga官网</a>)。</p>
<p>那么Flexbox是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-a85be95bcb08cc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。</p>
<p>关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">官方文档链接</a></p>
<p>Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-8c812635119a366c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>故以下源码分析都基于v0.10.0这个版本。</p>
<h4 id="（一）FlexBox中的基本数据结构"><a href="#（一）FlexBox中的基本数据结构" class="headerlink" title="（一）FlexBox中的基本数据结构"></a>（一）FlexBox中的基本数据结构</h4><p>Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。</p>
<p>在FlexBox的世界里，存在着主轴和侧轴的概念。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b476d0e771837826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-951af0f2fc01b0a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。</p>
<p><strong>主轴（main axis）：</strong>父视图的主轴，子视图主要沿着这条轴进行排列布局。</p>
<p><strong>主轴起点（main-start）和主轴终点（main-end）：</strong>子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。</p>
<p><strong>主轴尺寸（main size）：</strong>子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。</p>
<p><strong>侧轴（cross axis）：</strong>垂直于主轴称为侧轴。它的方向主要取决于主轴方向。</p>
<p><strong>侧轴起点（cross-start）和侧轴终点（cross-end）：</strong>子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</p>
<p><strong>侧轴尺寸（cross size）：</strong>子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。</p>
<p>接下来看看Layout是怎么定义FlexBox里面的元素的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_DIRECTION_INHERIT = <span class="number">0</span>,</span><br><span class="line">  CSS_DIRECTION_LTR,</span><br><span class="line">  CSS_DIRECTION_RTL</span><br><span class="line">&#125; <span class="keyword">css_direction_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN = <span class="number">0</span>,</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN_REVERSE,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW_REVERSE</span><br><span class="line">&#125; <span class="keyword">css_flex_direction_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是Flex的方向。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-74e4b1f77d6fa40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是COLUMN。布局的走向是从上往下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d34a0fea4404545e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是COLUMN_REVERSE。布局的走向是从下往上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-8a6e7643a60e2906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ROW。布局的走向是从左往右。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-569f2a299797e27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ROW_REVERSE。布局的走向是从右往左。</p>
<p>这里可以看出来，在LTR的上下文中，ROW_REVERSE即等于RTL的上下文中的ROW。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_JUSTIFY_FLEX_START = <span class="number">0</span>,</span><br><span class="line">  CSS_JUSTIFY_CENTER,</span><br><span class="line">  CSS_JUSTIFY_FLEX_END,</span><br><span class="line">  CSS_JUSTIFY_SPACE_BETWEEN,</span><br><span class="line">  CSS_JUSTIFY_SPACE_AROUND</span><br><span class="line">&#125; <span class="keyword">css_justify_t</span>;</span><br></pre></td></tr></table></figure>
<p>这是定义的子视图在主轴上的排列方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7dd84c06eabd1ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d86b61dabc5a97fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-945bde67f5931fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-3823fed50bd98895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_SPACE_BETWEEN</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5c514b364e470dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_SPACE_AROUND。这种方式是每个视图的左右都保持着一定的宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_ALIGN_AUTO = <span class="number">0</span>,</span><br><span class="line">  CSS_ALIGN_FLEX_START,</span><br><span class="line">  CSS_ALIGN_CENTER,</span><br><span class="line">  CSS_ALIGN_FLEX_END,</span><br><span class="line">  CSS_ALIGN_STRETCH</span><br><span class="line">&#125; <span class="keyword">css_align_t</span>;</span><br></pre></td></tr></table></figure>
<p>这是定义的子视图在侧轴上的对齐方式。</p>
<p>在Weex这里定义了三种属于css_align_t类型的方式，align_content，align_items，align_self。这三种类型的对齐方式略有不同。</p>
<p>ALIGN_AUTO只是针对align_self的一个默认值，但是对于align_content，align_items子视图的对齐方式是无效的值。</p>
<h4 id="1-align-items"><a href="#1-align-items" class="headerlink" title="1.align_items"></a>1.align_items</h4><p>align_items定义的是子视图在一行里面侧轴上排列的方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-e756eec5a022f74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5e200b8d742b01a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-ceab624ccd23e978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7bb4781738e20528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_STRETCH</p>
<p>align_items在W3C的定义里面其实还有一个种baseline的对齐方式，这里在定义里面并没有。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-10e077f6a05f4fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>注意，上面这种baseline的对齐方式在Weex的定义里面并没有！</p>
<h4 id="2-align-content"><a href="#2-align-content" class="headerlink" title="2. align_content"></a>2. align_content</h4><p><strong>align_content定义的是子视图行与行之间在侧轴上排列的方式。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c4e6c4930823f326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-3425b3876c3d665b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c5358bd9b76e9aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6a98ea3472c5b20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_STRETCH</p>
<p>在FlexBox的W3C的定义里面其实还有两种方式在Weex没有定义。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b5b1500aa720593a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_AROUND，align-content里面的space-around这种对齐方式在Weex是没有的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-77e9ab8a8268646f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_BETWEEN，align-content里面的space-between这种对齐方式在Weex是没有的。</p>
<h4 id="3-align-self"><a href="#3-align-self" class="headerlink" title="3.align_self"></a>3.align_self</h4><p>最后这一种对齐方式是可以在align_items的基础上再分别自定义每个子视图的对齐方式。如果是auto，是与align_items方式相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-964d7fb4451fb0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_POSITION_RELATIVE = <span class="number">0</span>,</span><br><span class="line">  CSS_POSITION_ABSOLUTE</span><br><span class="line">&#125; <span class="keyword">css_position_type_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个是定义坐标地址的类型，有相对坐标和绝对坐标两种。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_NOWRAP = <span class="number">0</span>,</span><br><span class="line">  CSS_WRAP</span><br><span class="line">&#125; <span class="keyword">css_wrap_type_t</span>;</span><br></pre></td></tr></table></figure>
<p>在Weex里面wrap只有两种类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d982430a883bd70e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是NOWRAP。所有的子视图都会排列在一行之中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-40c4c59a6237ebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是WRAP。所有的子视图会从左到右，从上到下排列。</p>
<p>在W3C的标准里面还有一种wrap_reverse的排列方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-40d7272e17d5b429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这种排列方式，是从左到右，从下到上进行排列，目前在Weex里面没有定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_LEFT = <span class="number">0</span>,</span><br><span class="line">  CSS_TOP,</span><br><span class="line">  CSS_RIGHT,</span><br><span class="line">  CSS_BOTTOM,</span><br><span class="line">  CSS_START,</span><br><span class="line">  CSS_END,</span><br><span class="line">  CSS_POSITION_COUNT</span><br><span class="line">&#125; <span class="keyword">css_position_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是坐标的描述。Left和Top因为会出现在position[2] 和 position[4]中，所以它们两个排列在Right和Bottom前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_MEASURE_MODE_UNDEFINED = <span class="number">0</span>,</span><br><span class="line">  CSS_MEASURE_MODE_EXACTLY,</span><br><span class="line">  CSS_MEASURE_MODE_AT_MOST</span><br><span class="line">&#125; <span class="keyword">css_measure_mode_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是计算的方式，一种是精确计算，另外一种是估算近视值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_WIDTH = <span class="number">0</span>,</span><br><span class="line">  CSS_HEIGHT</span><br><span class="line">&#125; <span class="keyword">css_dimension_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是子视图的尺寸，宽和高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存一些信息防止每次Layout过程都要重复计算</span></span><br><span class="line">  <span class="keyword">bool</span> should_update;</span><br><span class="line">  <span class="keyword">float</span> last_requested_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_width;</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_height;</span><br><span class="line">  <span class="keyword">float</span> last_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_position[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> last_direction;</span><br><span class="line">&#125; <span class="keyword">css_layout_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个css_layout_t结构体。结构体里面position和dimensions数组里面分别存储的是四周的位置和宽高的尺寸。direction里面存储的就是LTR还是RTL的方向。</p>
<p>至于下面那些变量信息都是缓存，用来防止没有改变的Lauout还会重复计算的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_dim_t</span>;</span><br></pre></td></tr></table></figure>
<p>css_dim_t结构体里面装的就是子视图的尺寸信息，宽和高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 整个页面CSS的方向，LTR、RTL</span></span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line">  <span class="comment">// Flex 的方向</span></span><br><span class="line">  <span class="keyword">css_flex_direction_t</span> flex_direction;</span><br><span class="line">  <span class="comment">// 子视图在主轴上的排列对齐方式</span></span><br><span class="line">  <span class="keyword">css_justify_t</span> justify_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上行与行之间的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_items;</span><br><span class="line">  <span class="comment">// 子视图自己本身的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_self;</span><br><span class="line">  <span class="comment">// 子视图的坐标系类型(相对坐标系，绝对坐标系)</span></span><br><span class="line">  <span class="keyword">css_position_type_t</span> position_type;</span><br><span class="line">  <span class="comment">// wrap类型</span></span><br><span class="line">  <span class="keyword">css_wrap_type_t</span> flex_wrap;</span><br><span class="line">  <span class="keyword">float</span> flex;</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> margin[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> padding[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> border[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 宽，高</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最小的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> minDimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最大的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> maxDimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_style_t</span>;</span><br></pre></td></tr></table></figure>
<p>css_style_t记录了整个style的所有信息。每个变量的意义见上面注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> <span class="title">css_node_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">css_style_t</span> style;</span><br><span class="line">  <span class="keyword">css_layout_t</span> layout;</span><br><span class="line">  <span class="keyword">int</span> children_count;</span><br><span class="line">  <span class="keyword">int</span> line_index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_node_t</span> *next_absolute_child;</span><br><span class="line">  <span class="keyword">css_node_t</span> *next_flex_child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_dim_t</span> (*measure)(<span class="keyword">void</span> *context, <span class="keyword">float</span> width, <span class="keyword">css_measure_mode_t</span> widthMode, <span class="keyword">float</span> height, <span class="keyword">css_measure_mode_t</span> heightMode);</span><br><span class="line">  <span class="keyword">void</span> (*print)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span>* (*<span class="title">get_child</span>)(<span class="title">void</span> *<span class="title">context</span>, <span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line">  <span class="keyword">bool</span> (*is_dirty)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="keyword">void</span> *context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>css_node定义的是FlexBox的一个节点的数据结构。它包含了之前的css_style_t和css_layout_t。由于结构体里面无法定义成员函数，所以下面包含4个函数指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-9192b10f6607271c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">css_node_t</span> *new_css_node(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面3个函数是关于css_node的生命周期相关的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="keyword">css_node_t</span> *new_css_node() &#123;</span><br><span class="line">  <span class="keyword">css_node_t</span> *node = (<span class="keyword">css_node_t</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*node));</span><br><span class="line">  init_css_node(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建节点的时候就是调用的init_css_node方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;style.align_items = CSS_ALIGN_STRETCH;</span><br><span class="line">  node-&gt;style.align_content = CSS_ALIGN_FLEX_START;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.direction = CSS_DIRECTION_INHERIT;</span><br><span class="line">  node-&gt;style.flex_direction = CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意下面这些数组里面的值初始化为undefined，而不是0</span></span><br><span class="line">  node-&gt;style.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.minDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.minDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.maxDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.maxDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.position[CSS_LEFT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_TOP] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_RIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_BOTTOM] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.margin[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.margin[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_END] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下这些用来对比是否发生变化的缓存变量，初始值都为 -1。</span></span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_WIDTH] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_HEIGHT] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_width = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_height = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_direction = (<span class="keyword">css_direction_t</span>)<span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.should_update = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css_node的初始化的align_items是ALIGN_STRETCH，align_content是ALIGN_FLEX_START，direction是继承自父类，flex_direction是按照列排列的。</p>
<p>接着下面数组里面存的都是UNDEFINED，而不是0，因为0会和结构体里面的0冲突。</p>
<p>最后缓存的变量初始化都为-1。</p>
<p>接下来定义了4个全局的数组，这4个数组非常有用，它会决定接下来layout的方向和属性。4个数组和轴的方向是相互关联的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> leading[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的leading就是CSS_TOP，方向如果是COLUMN_REVERSE，那么子视图的leading就是CSS_BOTTOM；如果主轴在ROW水平方向，那么子视图的leading就是CSS_LEFT，方向如果是ROW_REVERSE，那么子视图的leading就是CSS_RIGHT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> trailing[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_RIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_LEFT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的trailing就是CSS_BOTTOM，方向如果是COLUMN_REVERSE，那么子视图的trailing就是CSS_TOP；如果主轴在ROW水平方向，那么子视图的trailing就是CSS_RIGHT，方向如果是ROW_REVERSE，那么子视图的trailing就是CSS_LEFT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> pos[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的position就是以CSS_TOP开始的，方向如果是COLUMN_REVERSE，那么子视图的position就是以CSS_BOTTOM开始的；如果主轴在ROW水平方向，那么子视图的position就是以CSS_LEFT开始的，方向如果是ROW_REVERSE，那么子视图的position就是以CSS_RIGHT开始的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_dimension_t</span> dim[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_WIDTH,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_WIDTH</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图在这个方向上的尺寸就是CSS_HEIGHT，方向如果是COLUMN_REVERSE，那么子视图在这个方向上的尺寸也是CSS_HEIGHT；如果主轴在ROW水平方向，那么子视图在这个方向上的尺寸就是CSS_WIDTH，方向如果是ROW_REVERSE，那么子视图在这个方向上的尺寸是CSS_WIDTH。</p>
<h4 id="（二）FlexBox中的布局算法"><a href="#（二）FlexBox中的布局算法" class="headerlink" title="（二）FlexBox中的布局算法"></a>（二）FlexBox中的布局算法</h4><p>Weex 盒模型基于 <a href="https://www.w3.org/TR/css3-box/" rel="external nofollow noopener noreferrer" target="_blank">CSS 盒模型</a>，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。</p>
<p>盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2968e2f04c41c140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>盒子模型如上，这个图是基于LTR，并且主轴在水平方向的。</p>
<p>所以主轴在不同方向可能就会有不同的情况。</p>
<blockquote>
<p>注意：<br>Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容content、内边距padding和边框的宽度border，不包含外边距的宽度margin。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是水平方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRowDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_ROW ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_ROW_REVERSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是垂直方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isColumnDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_COLUMN ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_COLUMN_REVERSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断轴的方向的方向就是上面这两个。</p>
<p>然后接着还要计算4个方向上的padding、border、margin。这里就举一个方向的例子。</p>
<p>首先如何计算Margin的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_START])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[leading[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断轴的方向是不是水平方向，如果是水平方向就直接取node的margin里面的CSS_START即是LeadingMargin，如果是竖直方向，就取出在竖直轴上面的leading方向的margin的值。</p>
<p>如果取TrailingMargin那么就取margin[CSS_END]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getTrailingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_END])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_END];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[trailing[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下padding、border、margin三个值的数组存储有6个值，如果是水平方向，那么CSS_START存储的都是Leading，CSS_END存储的都是Trailing。下面没有特殊说明，都按照这个规则来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingPadding</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.padding[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.padding[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.padding[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取Padding的思路也和取Margin的思路一样，水平方向就是取出数组里面的padding[CSS_START]，如果是竖直方向，就对应得取出padding[leading[axis]]的值即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingBorder</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.border[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.border[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.border[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这是Border的计算方法，和上述Padding，Margin一模一样，这里就不再赘述了。</p>
<p>四周边距的计算方法都实现了，接下来就是如何layout了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算布局的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> maxWidth, <span class="keyword">float</span> maxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用layoutNode之前，可以重置node节点的layout</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>重置node节点的方法就是把节点的坐标重置为0，然后把宽和高都重置为UNDEFINED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.position[CSS_LEFT] = <span class="number">0</span>;</span><br><span class="line">  node-&gt;layout.position[CSS_TOP] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，布局方法就是如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">css_layout_t</span> *layout = &amp;node-&gt;layout;</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction = node-&gt;style.direction;</span><br><span class="line">  layout-&gt;should_update = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比当前环境是否“干净”，以及比较待布局的node节点和上次节点是否完全一致。</span></span><br><span class="line">  <span class="keyword">bool</span> skipLayout =</span><br><span class="line">    !node-&gt;is_dirty(node-&gt;context) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_WIDTH], layout-&gt;dimensions[CSS_WIDTH]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_HEIGHT], layout-&gt;dimensions[CSS_HEIGHT]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_width, parentMaxWidth) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_height, parentMaxHeight) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_direction, direction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skipLayout) &#123;</span><br><span class="line">    <span class="comment">// 把缓存的值直接赋值给当前的layout</span></span><br><span class="line">    layout-&gt;dimensions[CSS_WIDTH] = layout-&gt;last_dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;dimensions[CSS_HEIGHT] = layout-&gt;last_dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;position[CSS_TOP] = layout-&gt;last_position[CSS_TOP];</span><br><span class="line">    layout-&gt;position[CSS_LEFT] = layout-&gt;last_position[CSS_LEFT];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存node节点</span></span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_parent_max_width = parentMaxWidth;</span><br><span class="line">    layout-&gt;last_parent_max_height = parentMaxHeight;</span><br><span class="line">    layout-&gt;last_direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有子视图node的尺寸和位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = node-&gt;children_count; i &lt; childCount; i++) &#123;</span><br><span class="line">      resetNodeLayout(node-&gt;get_child(node-&gt;context, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局视图的核心实现</span></span><br><span class="line">    layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局完成，把此次的布局缓存起来，防止下次重复的布局重复计算</span></span><br><span class="line">    layout-&gt;last_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_position[CSS_TOP] = layout-&gt;position[CSS_TOP];</span><br><span class="line">    layout-&gt;last_position[CSS_LEFT] = layout-&gt;position[CSS_LEFT];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每步都注释了，见上述代码注释，在调用布局的核心实现layoutNodeImpl之前，会循环调用resetNodeLayout，初始化所有子视图。</p>
<p>所有的核心实现就在layoutNodeImpl这个方法里面了。Weex里面的这个方法实现有700多行，在Yoga的实现中，布局算法有1000多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">layoutNodeImpl</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分析一下这个算法的主要流程。在Weex的这个实现中，有7个循环，假设依次分别标上A，B，C，D，E，F，G。</p>
<p>先来看循环A</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainContentDim = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 存在3类子视图，支持flex的子视图，不支持flex的子视图，绝对布局的子视图，我们需要知道哪些子视图是在等待分配空间。</span></span><br><span class="line"><span class="keyword">int</span> flexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> totalFlexible = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nonFlexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在主轴上简单的堆叠子视图，在循环C中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackMain =</span><br><span class="line">    (isMainDimDefined &amp;&amp; justifyContent == CSS_JUSTIFY_FLEX_START) ||</span><br><span class="line">    (!isMainDimDefined &amp;&amp; justifyContent != CSS_JUSTIFY_CENTER);</span><br><span class="line"><span class="keyword">int</span> firstComplexMain = (isSimpleStackMain ? childCount : startLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在侧轴上简单的堆叠子视图，在循环D中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackCross = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> firstComplexCross = childCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">css_node_t</span>* firstFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">css_node_t</span>* currentFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainDim = leadingPaddingAndBorderMain;</span><br><span class="line"><span class="keyword">float</span> crossDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> maxWidth = CSS_UNDEFINED;</span><br><span class="line"><span class="keyword">float</span> maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环A从这里开始</span></span><br><span class="line"><span class="keyword">for</span> (i = startLine; i &lt; childCount; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line">  child-&gt;line_index = linesCount;</span><br><span class="line"></span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">  child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在递归layout之前，先预填充侧轴上可以被拉伸的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH &amp;&amp;</span><br><span class="line">      child-&gt;style.position_type == CSS_POSITION_RELATIVE &amp;&amp;</span><br><span class="line">      isCrossDimDefined &amp;&amp;</span><br><span class="line">      !isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 这里要进行一个比较，比较子视图在侧轴上的尺寸 和 侧轴上减去两边的Margin、padding、Border剩下的可拉伸的空间 进行比较，因为拉伸是不会压缩原始的大小的。</span></span><br><span class="line">    child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">      boundAxis(child, crossAxis, node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">        paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">      getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE) &#123;</span><br><span class="line">    <span class="comment">// 这里会储存一个绝对布局子视图的链表。这样我们在后面布局的时候可以快速的跳过它们。</span></span><br><span class="line">    <span class="keyword">if</span> (firstAbsoluteChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      firstAbsoluteChild = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      currentAbsoluteChild-&gt;next_absolute_child = child;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAbsoluteChild = child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预填充子视图，这里需要用到视图在轴上面的绝对坐标，如果是水平轴，需要用到左右的偏移量，如果是竖直轴，需要用到上下的偏移量。</span></span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">      axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">          !isStyleDimDefined(child, axis) &amp;&amp;</span><br><span class="line">          isPosDefined(child, leading[axis]) &amp;&amp;</span><br><span class="line">          isPosDefined(child, trailing[axis])) &#123;</span><br><span class="line">        child-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">          <span class="comment">// 这里是绝对布局，还需要减去leading和trailing</span></span><br><span class="line">          boundAxis(child, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">            getPaddingAndBorderAxis(node, axis) -</span><br><span class="line">            getMarginAxis(child, axis) -</span><br><span class="line">            getPosition(child, leading[axis]) -</span><br><span class="line">            getPosition(child, trailing[axis])),</span><br><span class="line">          getPaddingAndBorderAxis(child, axis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>循环A的具体实现如上，注释见代码。<br>循环A主要是实现的是layout布局中不可以flex的子视图的布局，mainContentDim变量是用来记录所有的尺寸以及所有不能flex的子视图的margin的总和。它被用来设置node节点的尺寸，和计算剩余空间以便供可flex子视图进行拉伸适配。</p>
<p>每个node节点的next_absolute_child维护了一个链表，这里存储的依次是绝对布局视图的链表。</p>
<p>接着需要再统计可以被拉伸的子视图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">float</span> nextContentDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计可以拉伸flex的子视图</span></span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined &amp;&amp; isFlex(child)) &#123;</span><br><span class="line">  flexibleChildrenCount++;</span><br><span class="line">  totalFlexible += child-&gt;style.flex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储一个链表维护可以flex的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (firstFlexChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    firstFlexChild = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    currentFlexChild-&gt;next_flex_child = child;</span><br><span class="line">  &#125;</span><br><span class="line">  currentFlexChild = child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这时我们虽然不知道确切的尺寸信息，但是已经知道了padding , border , margin，我们可以利用这些信息来给子视图确定一个最小的size，计算剩余可用的空间。</span></span><br><span class="line">  <span class="comment">// 下一个content的距离等于当前子视图Leading和Trailing的padding , border , margin6个尺寸之和。</span></span><br><span class="line">  nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +</span><br><span class="line">    getMarginAxis(child, mainAxis);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  maxWidth = CSS_UNDEFINED;</span><br><span class="line">  maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算出最大宽度和最大高度</span></span><br><span class="line">  <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">          paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用layout函数，进行不能拉伸的子视图的布局。</span></span><br><span class="line">  <span class="keyword">if</span> (alreadyComputedNextLayout == <span class="number">0</span>) &#123;</span><br><span class="line">    layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于绝对布局的子视图的位置和layout无关，所以我们不能用它们来计算mainContentDim</span></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">    nonFlexibleChildrenCount++;</span><br><span class="line">    nextContentDim = getDimWithMargin(child, mainAxis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就确定出了不可拉伸的子视图的布局。</p>
<p>每个node节点的next_flex_child维护了一个链表，这里存储的依次是可以flex拉伸视图的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="comment">// 将要加入的元素可能会被挤到下一行</span></span><br><span class="line">      <span class="keyword">if</span> (isNodeFlexWrap &amp;&amp;</span><br><span class="line">          isMainDimDefined &amp;&amp;</span><br><span class="line">          mainContentDim + nextContentDim &gt; definedMainDim &amp;&amp;</span><br><span class="line">          <span class="comment">// 如果这里只有一个元素，它可能就需要单独占一行</span></span><br><span class="line">          i != startLine) &#123;</span><br><span class="line">        nonFlexibleChildrenCount--;</span><br><span class="line">        alreadyComputedNextLayout = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在主轴上堆叠子视图，剩余的子视图都在循环C里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE || isFlex(child))) &#123;</span><br><span class="line">        isSimpleStackMain = <span class="literal">false</span>;</span><br><span class="line">        firstComplexMain = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在侧轴上堆叠子视图，剩余的子视图都在循环D里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE ||</span><br><span class="line">              (alignItem != CSS_ALIGN_STRETCH &amp;&amp; alignItem != CSS_ALIGN_FLEX_START) ||</span><br><span class="line">              (alignItem == CSS_ALIGN_STRETCH &amp;&amp; !isCrossDimDefined))) &#123;</span><br><span class="line">        isSimpleStackCross = <span class="literal">false</span>;</span><br><span class="line">        firstComplexCross = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line">        <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图主轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, mainAxis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以算出了主轴上的尺寸了</span></span><br><span class="line">        mainDim += getDimWithMargin(child, mainAxis);</span><br><span class="line">        <span class="comment">// 可以算出侧轴上的尺寸了</span></span><br><span class="line">        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;</span><br><span class="line">        <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图侧轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, crossAxis);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      alreadyComputedNextLayout = <span class="number">0</span>;</span><br><span class="line">      mainContentDim += nextContentDim;</span><br><span class="line">      endLine = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 循环A 至此结束</span></span><br></pre></td></tr></table></figure>
<p>循环A结束以后，会计算出endLine，计算出主轴上的尺寸，侧轴上的尺寸。不可拉伸的子视图的布局也会被确定。</p>
<p>接下来进入循环B的阶段。</p>
<p>循环B主要分为2个部分，第一个部分是用来布局可拉伸的子视图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为了在主轴上布局，需要控制两个space，一个是第一个子视图和最左边的距离，另一个是两个子视图之间的距离</span></span><br><span class="line"><span class="keyword">float</span> leadingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> betweenMainDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录剩余的可用空间</span></span><br><span class="line"><span class="keyword">float</span> remainingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">  remainingMainDim = definedMainDim - mainContentDim;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  remainingMainDim = fmaxf(mainContentDim, <span class="number">0</span>) - mainContentDim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前还有可拉伸的子视图，它们就要填充剩余的可用空间</span></span><br><span class="line"><span class="keyword">if</span> (flexibleChildrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">float</span> flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line">  <span class="keyword">float</span> baseMainDim;</span><br><span class="line">  <span class="keyword">float</span> boundMainDim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果剩余的空间不能提供给可拉伸的子视图，不能满足它们的最大或者最小的bounds，那么这些子视图也要排除到计算拉伸的过程之外</span></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    baseMainDim = flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">        getPaddingAndBorderAxis(currentFlexChild, mainAxis);</span><br><span class="line">    boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseMainDim != boundMainDim) &#123;</span><br><span class="line">      remainingMainDim -= boundMainDim;</span><br><span class="line">      totalFlexible -= currentFlexChild-&gt;style.flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">  &#125;</span><br><span class="line">  flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不可以拉伸的子视图可以在父视图内部overflow，在这种情况下，假设没有可用的拉伸space</span></span><br><span class="line">  <span class="keyword">if</span> (flexibleMainDim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    flexibleMainDim = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这层循环里面我们已经可以确认子视图的最终大小了</span></span><br><span class="line">    currentFlexChild-&gt;layout.dimensions[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,</span><br><span class="line">      flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">          getPaddingAndBorderAxis(currentFlexChild, mainAxis)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算水平方向轴上子视图的最大宽度</span></span><br><span class="line">    maxWidth = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算垂直方向轴上子视图的最大高度</span></span><br><span class="line">    maxHeight = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMainRowDirection) &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次递归完成可拉伸的子视图的布局</span></span><br><span class="line">    layoutNode(currentFlexChild, maxWidth, maxHeight, direction);</span><br><span class="line"></span><br><span class="line">    child = currentFlexChild;</span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">    child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述2个while结束以后，所有可以被拉伸的子视图就都布局完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (justifyContent != CSS_JUSTIFY_FLEX_START) &#123;</span><br><span class="line">     <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_CENTER) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_FLEX_END) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_BETWEEN) &#123;</span><br><span class="line">       remainingMainDim = fmaxf(remainingMainDim, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">         betweenMainDim = remainingMainDim /</span><br><span class="line">           (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         betweenMainDim = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_AROUND) &#123;</span><br><span class="line">       <span class="comment">// 这里是实现SPACE_AROUND的代码</span></span><br><span class="line">       betweenMainDim = remainingMainDim /</span><br><span class="line">         (flexibleChildrenCount + nonFlexibleChildrenCount);</span><br><span class="line">       leadingMainDim = betweenMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可flex拉伸的视图布局完成以后，这里是收尾工作，根据justifyContent，更改betweenMainDim和leadingMainDim的大小。</p>
<p>接着再是循环C。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在这个循环中，所有子视图的宽和高都将被确定下来。在确定各个子视图的坐标的时候，同时也将确定父视图的宽和高。</span></span><br><span class="line">mainDim += leadingMainDim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照Line，一层层的循环</span></span><br><span class="line"><span class="keyword">for</span> (i = firstComplexMain; i &lt; endLine; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">      isPosDefined(child, leading[mainAxis])) &#123;</span><br><span class="line">    <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，左边距和上边距已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +</span><br><span class="line">      getLeadingBorder(node, mainAxis) +</span><br><span class="line">      getLeadingMargin(child, mainAxis);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果子视图不是绝对坐标，坐标是相对的，或者还没有确定下来左边距和上边距，那么就根据当前位置确定坐标</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定trailing的坐标位置</span></span><br><span class="line">    <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来开始处理相对坐标的子视图，具有绝对坐标的子视图不会参与下述的布局计算中</span></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">      <span class="comment">// 主轴上的宽度是由所有的子视图的宽度累加而成</span></span><br><span class="line">      mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);</span><br><span class="line">      <span class="comment">// 侧轴的高度是由最高的子视图决定的</span></span><br><span class="line">      crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> containerCrossAxis = node-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  containerCrossAxis = fmaxf(</span><br><span class="line">    <span class="comment">// 计算父视图的时候需要加上，上下的padding和Border。</span></span><br><span class="line">    boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环C中，会在主轴上计算出所有子视图的坐标，包括各个子视图的宽和高。</p>
<p>接下来就到循环D的流程了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = firstComplexCross; i &lt; endLine; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">        isPosDefined(child, leading[crossAxis])) &#123;</span><br><span class="line">      <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，上下左右至少有一边的坐标已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +</span><br><span class="line">        getLeadingBorder(node, crossAxis) +</span><br><span class="line">        getLeadingMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">float</span> leadingCrossDim = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在侧轴上，针对相对坐标的子视图，我们利用父视图的alignItems或者子视图的alignSelf来确定具体的坐标位置</span></span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="comment">// 获取子视图的AlignItem属性值</span></span><br><span class="line">        <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line">        <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">          <span class="comment">// 如果在侧轴上子视图还没有确定尺寸，那么才会相应STRETCH拉伸。</span></span><br><span class="line">          <span class="keyword">if</span> (!isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">            <span class="keyword">float</span> dimCrossAxis = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">            child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">              boundAxis(child, crossAxis, containerCrossAxis -</span><br><span class="line">                paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">              getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果视图的大小变化了，连带该视图的子视图还需要再次layout</span></span><br><span class="line">            <span class="keyword">if</span> (dimCrossAxis != child-&gt;layout.dimensions[dim[crossAxis]] &amp;&amp; child-&gt;children_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Reset child margins before re-layout as they are added back in layoutNode and would be doubled</span></span><br><span class="line">              child-&gt;layout.position[leading[mainAxis]] -= getLeadingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[mainAxis]] -= getTrailingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[leading[crossAxis]] -= getLeadingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[crossAxis]] -= getTrailingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 递归子视图的布局</span></span><br><span class="line">              layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignItem != CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">          <span class="comment">// 在侧轴上剩余的空间等于父视图在侧轴上的高度减去子视图的在侧轴上padding、Border、Margin以及高度</span></span><br><span class="line">          <span class="keyword">float</span> remainingCrossDim = containerCrossAxis -</span><br><span class="line">            paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (alignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">            leadingCrossDim += remainingCrossDim / <span class="number">2</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// CSS_ALIGN_FLEX_END</span></span><br><span class="line">            leadingCrossDim += remainingCrossDim;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定子视图在侧轴上的坐标位置</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingCrossDim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定trailing的坐标</span></span><br><span class="line">      <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        setTrailingPosition(node, child, crossAxis);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  linesCrossDim += crossDim;</span><br><span class="line">  linesMainDim = fmaxf(linesMainDim, mainDim);</span><br><span class="line">  linesCount += <span class="number">1</span>;</span><br><span class="line">  startLine = endLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的循环D中主要是在侧轴上计算子视图的坐标。如果视图发生了大小变化，还需要递归子视图，重新布局一次。</p>
<p>再接着是循环E</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (linesCount &gt; <span class="number">1</span> &amp;&amp; isCrossDimDefined) &#123;</span><br><span class="line">  <span class="keyword">float</span> nodeCrossAxisInnerSize = node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">      paddingAndBorderAxisCross;</span><br><span class="line">  <span class="keyword">float</span> remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> crossDimLead = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> currentLead = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 布局alignContent</span></span><br><span class="line">  <span class="keyword">css_align_t</span> alignContent = node-&gt;style.align_content;</span><br><span class="line">  <span class="keyword">if</span> (alignContent == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim / <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeCrossAxisInnerSize &gt; linesCrossDim) &#123;</span><br><span class="line">      crossDimLead = (remainingAlignContentDim / linesCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; linesCount; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每一行的行高，行高根据lineHeight和子视图在侧轴上的高度加上下的Margin之和比较，取最大值</span></span><br><span class="line">    <span class="keyword">float</span> lineHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; childCount; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;line_index != i) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(child, crossAxis)) &#123;</span><br><span class="line">        lineHeight = fmaxf(</span><br><span class="line">          lineHeight,</span><br><span class="line">          child-&gt;layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endIndex = ii;</span><br><span class="line">    lineHeight += crossDimLead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; endIndex; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 布局AlignItem</span></span><br><span class="line">      <span class="keyword">css_align_t</span> alignContentAlignItem = getAlignItem(node, child);</span><br><span class="line">      <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">        <span class="keyword">float</span> childHeight = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">        <span class="comment">// TODO(prenaux): Correctly set the height of items with undefined</span></span><br><span class="line">        <span class="comment">//                (auto) crossAxis dimension.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentLead += lineHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行循环E有一个前提，就是，行数至少要超过一行，并且侧轴上有高度定义。满足了这个前提条件以后才会开始下面的align规则。</p>
<p>在循环E中会处理侧轴上的align拉伸规则。这里会布局alignContent和AlignItem。</p>
<p>这块代码实现的算法原理请参见<a href="http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm" rel="external nofollow noopener noreferrer" target="_blank">http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm</a> section 9.4部分。</p>
<p>至此可能还存在一些没有指定宽和高的视图，接下来将会做最后一次的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个视图没有被指定宽或者高，并且也没有被父视图设置宽和高，那么在这里通过子视图来设置宽和高</span></span><br><span class="line"><span class="keyword">if</span> (!isMainDimDefined) &#123;</span><br><span class="line">  <span class="comment">// 视图的宽度等于内部子视图的宽度加上Trailing的Padding、Border的宽度和主轴上Leading的Padding、Border+ Trailing的Padding、Border，两者取最大值。</span></span><br><span class="line">  node-&gt;layout.dimensions[dim[mainAxis]] = fmaxf(</span><br><span class="line">    boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),</span><br><span class="line">    paddingAndBorderAxisMain</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsMainTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  node-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">    <span class="comment">// 视图的高度等于内部子视图的高度加上上下的Padding、Border的宽度和侧轴上Padding、Border，两者取最大值。</span></span><br><span class="line">    boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsCrossTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些没有确定宽和高的子视图的宽和高会根据父视图来决定。方法见上述代码。</p>
<p>再就是循环F了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsMainTrailingPos || needsCrossTrailingPos) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; childCount; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsMainTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsCrossTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, crossAxis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步是设置当前node节点的Trailing坐标，如果有必要的话。如果不需要，这一步会直接跳过。</p>
<p>最后一步就是循环G了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">currentAbsoluteChild = firstAbsoluteChild;</span><br><span class="line"><span class="keyword">while</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">    axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">        !isStyleDimDefined(currentAbsoluteChild, axis) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, leading[axis]) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, trailing[axis])) &#123;</span><br><span class="line">      <span class="comment">// 绝对坐标的子视图在主轴上的宽度，在侧轴上的高度都不能比Padding、Border的总和小。</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">        boundAxis(currentAbsoluteChild, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">          getBorderAxis(node, axis) -</span><br><span class="line">          getMarginAxis(currentAbsoluteChild, axis) -</span><br><span class="line">          getPosition(currentAbsoluteChild, leading[axis]) -</span><br><span class="line">          getPosition(currentAbsoluteChild, trailing[axis])</span><br><span class="line">        ),</span><br><span class="line">        getPaddingAndBorderAxis(currentAbsoluteChild, axis)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPosDefined(currentAbsoluteChild, trailing[axis]) &amp;&amp;</span><br><span class="line">        !isPosDefined(currentAbsoluteChild, leading[axis])) &#123;</span><br><span class="line">      <span class="comment">// 当前子视图的坐标等于当前视图的宽度减去子视图的宽度再减去trailing</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.position[leading[axis]] =</span><br><span class="line">        node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        getPosition(currentAbsoluteChild, trailing[axis]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  child = currentAbsoluteChild;</span><br><span class="line">  currentAbsoluteChild = currentAbsoluteChild-&gt;next_absolute_child;</span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这一步循环G是用来给绝对坐标的子视图计算宽度和高度。</p>
<p>执行完上述7个循环以后，所有的子视图就都layout完成了。</p>
<p>总结一下上述的流程，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-fc141fa8e3dc0433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="二-Weex布局算法性能分析"><a href="#二-Weex布局算法性能分析" class="headerlink" title="二. Weex布局算法性能分析"></a>二. Weex布局算法性能分析</h3><h4 id="1-算法实现分析"><a href="#1-算法实现分析" class="headerlink" title="1.算法实现分析"></a>1.算法实现分析</h4><p>上一章节看了Weex的layout算法实现。这里就分析一下在这个实现下，布局能力究竟有多强。</p>
<p>Weex的实现是FaceBook的开源库Yoga的前身，所以这里可以把两个看成是一种实现。</p>
<p>Weex的这种FlexBox的实现其实只是W3C标准的一个实现的子集，因为FlexBox的官方标准里面还有一些并没有实现出来。W3C上定义的FlexBox的标准，文档在<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p>
<p>FlexBox标准定义：</p>
<p>针对父视图 (flex container):</p>
<ol>
<li>display</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ol>
<p>针对子视图 (flex items):</p>
<ol>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-63e820c1ee9472cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>相比官方的定义，上述的实现有一些限制：</p>
<ol>
<li>所有显示属性的node节点都默认假定是Flex的视图，当然这里要除去文本节点，因为它会被假定为inline-flex。</li>
<li>不支持zIndex的属性，包括任何z上的排序。所有的node节点都是按照代码书写的先后顺序进行排列的。Weex 目前也不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。</li>
<li>FlexBox里面定义的order属性，也不支持。flex item默认按照代码书写顺序。</li>
<li>visibility属性默认都是可见的，暂时不支持边缘塌陷合并(collapse)和隐藏(hidden)属性。</li>
<li>不支持forced breaks。</li>
<li>不支持垂直方向的inline(比如从上到下的text，或者从下到上的text)</li>
</ol>
<p>关于Flexbox 在iOS这边的具体实现上一章节已经分析过了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2a97e349befdc557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来仔细分析一下Autolayout的具体实现</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b994236e0c27d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>原来我们用Frame进行布局的时候，需要知道一个点（origin或者center）和宽高就可以确定一个View。</p>
<p>现在换成了Autolayout，每个View需要知道4个尺寸。left，top，width，height。</p>
<p>但是一个View的约束是相对于另一个View的，比如说相对于父视图，或者是相对于两两View之间的。</p>
<p>那么两两个View之间的约束就会变成一个八元一次的方程组。</p>
<p>解这个方程组可能有以下3种情况：</p>
<ol>
<li>当方程组的解的个数有无穷多个，最终会得到欠约束的有歧义的布局。</li>
<li>当方程无解时，则表示约束有冲突。</li>
<li>只有当方程组有唯一解的时候，才能得到一个稳定的布局。</li>
</ol>
<p><strong>Autolayout 本质是一个线性方程解析器，该解析器试图找到一种可满足其规则的几何表达式。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-09b7902e4c7c67e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Autolayout的底层数学模型是线性算术约束问题。</p>
<p>关于这个问题，早在1940年，由Dantzig提出了一个the simplex algorithm算法，但是由于这个算法实在很难用在UI应用上面，所以没有得到很广泛的应用，直到1997年，澳大利亚的莫纳什大学（Monash University）的两名学生，Alan Borning 和 Kim Marriott实现了Cassowary线性约束算法，才得以在UI应用上被大量的应用起来。</p>
<p>Cassowary线性约束算法是基于双simplex算法的，在增加约束或者一个对象被移除的时候，通过局部误差增益 和 加权求和比较 ，能够完美的增量处理不同层次的约束。Cassowary线性约束算法适合GUI布局系统，被用来计算view之间的位置的。开发者可以指定不同View之间的位置关系和约束关系，Cassowary线性约束算法会去求处符合条件的最优值。</p>
<p>下面是两位学生写的相关的论文，有兴趣的可以读一下，了解一下算法的具体实现：</p>
<ol>
<li>Alan Borning, Kim Marriott, Peter Stuckey, and Yi Xiao, <a href="https://constraints.cs.washington.edu/solvers/uist97.pdf" rel="external nofollow noopener noreferrer" target="_blank">Solving Linear Arithmetic Constraints for User Interface Applications</a>, Proceedings of the 1997 ACM Symposium on User Interface Software and Technology, October 1997, pages 87-96.</li>
<li>Greg J. Badros and Alan Borning, “The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation”, Technical Report UW-CSE-98-06-04, June 1998 (<a href="https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li>
<li>Greg J. Badros, Alan Borning, and Peter J. Stuckey, “The Cassowary Linear Arithmetic Constraint Solving Algorithm,” <em>ACM Transactions on Computer Human Interaction</em>, Vol. 8 No. 4, December 2001, pages 267-306. (<a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li>
</ol>
<p>Cassowary线性约束算法的伪代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2f208ced7d958ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>关于这个算法已经被人们实现成了各个版本。1年以后，又出了一个新的QOCA算法。以下这段话摘抄自1997年ACM权威论文上的一篇文章：</p>
<blockquote>
<p>Both of our algorithms have been implemented, Cassowary<br>in Smalltalk and QOCA in C++. They perform surprisingly<br>well. The QOCA implementation is considerably more sophisticated<br>and has much better performance than the current version of<br>Cassowary. However, QOCA is inherently a more complex<br>algorithm, and re-implementing it with a comparable level<br>of performance would be a daunting task. In contrast, Cassowary<br>is straightforward, and a reimplementation based on<br>this paper is more reasonable, given a knowledge of the simplex<br>algorithm.</p>
</blockquote>
<p>Cassowary（<a href="https://constraints.cs.washington.edu/cassowary/" rel="external nofollow noopener noreferrer" target="_blank">项目主页</a>）也是优先被Smalltalk实现了，也是用在Autolayout技术上。另外还有更加复杂的QOCA算法，这里就不再细谈了，有兴趣的同学可以看看上面三篇论文，里面有详细的描述。</p>
<h4 id="2-算法性能测试准备工作"><a href="#2-算法性能测试准备工作" class="headerlink" title="2.算法性能测试准备工作"></a>2.算法性能测试准备工作</h4><p>开始笔者是打算连带Weex的布局性能一起测试的，但是由于Weex的布局都在子线程，刷新渲染回到主线程，需要测试都在主线程的情况需要改动一些代码，而且Weex原生的布局是从JS调用方法，如果用这种方法又会多损耗一些性能，对测试结果有影响。于是换成Weex相同布局方式的Yoga算法进行测试。由于Facebook对它进行了很好的封装，使用起来也很方便。虽然Layout算法和Weex有些差异，但是不影响定性的比较。</p>
<p>确定下来测试对象：Frame，FlexBox(Yoga实现)，Autolayout。</p>
<p>测试前，还需要准备测试模型，这里选出了3种测试模型。</p>
<p>第一种测试模型是随机生成完全不相关联的View。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-a7a0d48cba94f3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>第二种测试模型是生成相互嵌套的View。嵌套规则设置一个简单的：子视图依次比父视图高度少一个像素。类似下图，这是500个View相互嵌套的结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-0828ddc58f8d30ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>第三种测试模型是针对Autolayout专门加的。由于Autolayout约束的特殊性，这里针对链式约束额外增加的测试模型。规则是前后两个相连的View之间依次加上约束。类似下图，这是500个View链式的约束结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-1b8f68cd9debed67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>根据测试模型，我们可以得到如下的7组需要测试的测试用例：</p>
<p>1.Frame<br>2.嵌套的Frame<br>3.Yoga<br>4.嵌套的Yoga<br>5.Autolayout<br>6.嵌套的Autolayout<br>7.链式的Autolayout</p>
<p>测试样本：由于需要考虑到测试的通用性，测试样本要尽量随机。于是针对随机生成的坐标全部都随机生成，View的颜色也全部都随机生成，这样保证了通用公正公平性质。</p>
<p>测试次数：为了保证测试数据能尽量真实，笔者在这里花了大量的时间。每组测试用例都针对从100，200，300，400，500，600，700，800，900，1000个视图进行测试，为了保证测试的普遍性，这里每次测试都测试10000次，然后对10000次的结果进行加和平均。加和平均取小数点后5位。（10000次的统计是用计算机来算的，但是真的非常非常非常的耗时，有兴趣的可以自己用电脑试试）</p>
<p>最后展示一下测试机器的配置和系统版本：</p>
<p>（由于iPhone真机对每个App的内存有限制，产生1000个嵌套的视图，并且进行10000次试验，iPhone真机完全受不了这种计算量，App直接闪退，所以用真机测试到一半，改用模拟器测试，借助Mac的性能，咬着牙从零开始，重新统计了所有测试用例的数据）</p>
<p>如果有性能更强的Mac电脑（垃圾桶），测试全过程花的时间可能会更少。</p>
<p>笔者用的电脑的配置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-510c7d7ab97e2330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>测试用的模拟器是iPad Pro（12.9 inch）iOS 10.3（14E269）</p>
<p>我所用的测试代码也公布出来，有兴趣的可以自己测试测试。<a href="https://github.com/halfrost/Halfrost-Field/tree/master/contents/iOS/AutoLayoutProfiling-master" rel="external nofollow noopener noreferrer" target="_blank">测试代码在这里</a>  </p>
<h4 id="3-算法性能测试结果"><a href="#3-算法性能测试结果" class="headerlink" title="3.算法性能测试结果"></a>3.算法性能测试结果</h4><p>公布测试结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-34171d65db564340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图数据是10，20，30，40，50，60，70，80，90，100个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-f9468b0f10f0ef95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>结果依旧是Autolayout的3种方式都高于其他4种布局方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7f51f5e34c9e5485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-64f5f7c2e89e2661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-409f0c3e820c5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后这张图也是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，嵌套的Autolayout的性能依旧是最差的！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b338b4507694268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图数据是100，200，300，400，500，600，700，800，900，1000个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-e60d70a0eaa4a67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当视图多到900，1000的时候，嵌套的Autolayout直接就导致模拟器崩溃了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-4560c9da3bfa0968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-cad15676ac4504b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c71dbeba866e73fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后这张图是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，平时我们使用嵌套的Autolayout的性能是最差的！</p>
<h3 id="三-Weex是如何布局原生界面的"><a href="#三-Weex是如何布局原生界面的" class="headerlink" title="三. Weex是如何布局原生界面的"></a>三. Weex是如何布局原生界面的</h3><p>上一章节看了FlexBox算法的强大布局能力，这一章节就来看看Weex究竟是如何利用这个能力的对原生View进行Layout。</p>
<p>在解答上面这个问题之前，先让我们回顾一下上篇文章<a href="http://www.jianshu.com/p/41cde2c62b81" rel="external nofollow noopener noreferrer" target="_blank">《Weex 是如何在 iOS 客户端上跑起来的》</a>里面提到的，在JSFramework转换从网络上下载下来的JS文件之前，本地先注册了4个重要的回调函数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallNative)(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallAddElement)(<span class="built_in">NSString</span> *instanceId,  <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInvocation</span> *(^WXJSCallNativeModule)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^WXJSCallNativeComponent)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br></pre></td></tr></table></figure>
<p>这4个block非常重要，是JS和OC进行相互调用的四大函数。</p>
<p>先来回顾一下这四大函数注册的时候分别封装了哪些闭包。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXBridgeContext</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;WXBridgeProtocol&gt;  jsBridge;</span><br></pre></td></tr></table></figure>
<p>在WXBridgeContext类里面有一个jsBridge。jsBridge初始化的时候会注册这4个全局函数。</p>
<p>第一个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallNative:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> [weakSelf invokeNative:instance tasks:tasks callback:callback];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里的闭包函数会被传入到下面这个函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceId = [instance toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *tasksArray = [tasks toArray];</span><br><span class="line">        <span class="built_in">NSString</span> *callbackId = [callback toString];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"Calling native... instance:%@, tasks:%@, callback:%@"</span>, instanceId, tasksArray, callbackId);</span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _jsContext[<span class="string">@"callNative"</span>] = callNativeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就封装了一个函数，暴露给JS用。方法名叫callNative，函数参数为3个，分别是instanceId，tasksArray任务数组，callbackId回调ID。</p>
<p>所有的OC的闭包都需要封装一层，因为暴露给JS的方法不能有冒号，所有的参数都是直接跟在小括号的参数列表里面的，因为JS的函数是这样定义的。</p>
<p>当JS调用callNative方法之后，就会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p>
<p>第二个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *componentData = [element toDictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *parentRef = [ref toString];</span><br><span class="line">        <span class="built_in">NSInteger</span> insertIndex = [[index toNumber] integerValue];</span><br><span class="line">        </span><br><span class="line">         WXLogDebug(<span class="string">@"callAddElement...%@, %@, %@, %ld"</span>, instanceIdString, parentRef, componentData, (<span class="keyword">long</span>)insertIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _jsContext[<span class="string">@"callAddElement"</span>] = callAddElementBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的包装方法和第一个方法是相同的。这里暴露给JS的方法名叫callAddElement，函数参数为4个，分别是instanceIdString，componentData组件的数据，parentRef引用编号，insertIndex插入视图的index。</p>
<p>当JS调用callAddElement方法，就会最终执行WXBridgeContext类里面的WXPerformBlockOnComponentThread闭包。</p>
<p>第三个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeModule:^<span class="built_in">NSInvocation</span>*(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *arguments, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found for callNativeModule:%@.%@, maybe already destroyed"</span>, moduleName, methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">    <span class="keyword">return</span> [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeModule"</span>] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *moduleNameString = [moduleName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeModule...%@,%@,%@,%@"</span>, instanceIdString, moduleNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = callNativeModuleBlock(instanceIdString, moduleNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">        JSValue *returnValue = [JSValue wx_valueWithReturnValueFromInvocation:invocation inContext:[JSContext currentContext]];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暴露给JS的方法名叫callNativeModule，函数参数为5个，分别是instanceIdString，moduleNameString模块名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p>
<p>当JS调用callNativeModule方法，就会最终执行WXBridgeContext类里面的WXModuleMethod方法。</p>
<p>第四个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeComponent:^<span class="keyword">void</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:componentRef methodName:methodName arguments:args instance:instance];</span><br><span class="line">    [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeComponent:(WXJSCallNativeComponent)callNativeComponentBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeComponent"</span>] = ^<span class="keyword">void</span>(JSValue *instanceId, JSValue *componentName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *componentNameString = [componentName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeComponent...%@,%@,%@,%@"</span>, instanceIdString, componentNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        callNativeComponentBlock(instanceIdString, componentNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暴露给JS的方法名叫callNativeComponent，函数参数为5个，分别是instanceIdString，componentNameString组件名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p>
<p>当JS调用callNativeComponent方法，就会最终执行WXBridgeContext类里面的WXComponentMethod方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-23bfe161375b750a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>总结一下上述暴露给JS的4个方法：</p>
<ol>
<li><p>callNative<br>这个方法是JS用来调用任意一个Native方法的。</p>
</li>
<li><p>callAddElement<br>这个方法是JS用来给当前页面添加视图元素的。</p>
</li>
<li><p>callNativeModule<br>这个方法是JS用来调用模块里面暴露出来的方法。</p>
</li>
<li><p>callNativeComponent<br>这个方法是JS用来调用组件里面暴露出来的方法。</p>
</li>
</ol>
<p>Weex在布局的时候就只会用到前2个方法。</p>
<p>####（一）createRoot:</p>
<p>当JSFramework把JS文件转换类似JSON的文件之后，就开始调用Native的callNative方法。</p>
<p>callNative方法会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p>
<p>当前操作处于子线程“com.taobao.weex.bridge”中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)invokeNative:(<span class="built_in">NSString</span> *)instanceId tasks:(<span class="built_in">NSArray</span> *)tasks callback:(<span class="built_in">NSString</span> __unused*)callback</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertBridgeThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instanceId || !tasks) &#123;</span><br><span class="line">        WX_MONITOR_FAIL(WXMTNativeRender, WX_ERR_JSFUNC_PARAM, <span class="string">@"JS call Native params error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance already destroyed, task ignored"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据JS发送过来的方法，进行转换成Native方法调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *methodName = task[<span class="string">@"method"</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *arguments = task[<span class="string">@"args"</span>];</span><br><span class="line">        <span class="keyword">if</span> (task[<span class="string">@"component"</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *ref = task[<span class="string">@"ref"</span>];</span><br><span class="line">            WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:ref methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *moduleName = task[<span class="string">@"module"</span>];</span><br><span class="line">            WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有回调，回调给JS</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_sendQueueLoop) withObject:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会把JS从发送过来的callNative方法转换成Native的组件component的方法调用或者模块module的方法调用。</p>
<p>举个例子：</p>
<p>JS从callNative方法传过来3个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">instance:0,</span><br><span class="line"></span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">                        &#123;</span><br><span class="line">                attr =                 &#123;</span><br><span class="line">                &#125;;</span><br><span class="line">                ref = &quot;_root&quot;;</span><br><span class="line">                style =                 &#123;</span><br><span class="line">                    alignItems = center;</span><br><span class="line">                &#125;;</span><br><span class="line">                type = div;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        method = createBody;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line"></span><br><span class="line">callback:-1</span><br></pre></td></tr></table></figure>
<p>tasks数组里面会解析出各个方法和调用者。</p>
<p>这个例子里面就会解析出Dom模块的createBody方法。</p>
<p>接着就会调用Dom模块的createBody方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="keyword">return</span> invocation;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法之前，有一个线程切换的步骤。如果是同步方法，那么就直接调用，如果是异步方法，那么嗨需要进行线程转换。</p>
<p>Dom模块的createBody方法是异步的方法，于是就需要调用_dispatchInvocation: moduleInstance:方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_dispatchInvocation:(<span class="built_in">NSInvocation</span> *)invocation moduleInstance:(<span class="keyword">id</span>&lt;WXModuleProtocol&gt;)moduleInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dispatch to user specified queue or thread, default is main thread</span></span><br><span class="line">    dispatch_block_t dispatchBlock = ^ ()&#123;</span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *targetThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteQueue)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Queue，如果没有，就返回main_queue，如果有，就切换到targetQueue</span></span><br><span class="line">        targetQueue = [moduleInstance targetExecuteQueue] ?: dispatch_get_main_queue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteThread)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Thread，如果没有，就返回主线程，如果有，就切换到targetThread</span></span><br><span class="line">        targetThread = [moduleInstance targetExecuteThread] ?: [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetThread = [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXAssert(targetQueue || targetThread, <span class="string">@"No queue or thread found for module:%@"</span>, moduleInstance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (targetQueue) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(targetQueue, dispatchBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WXPerformBlockOnThread(^&#123;</span><br><span class="line">            dispatchBlock();</span><br><span class="line">        &#125;, targetThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在整个Weex模块中，目前只有2个模块是有targetQueue的，一个是WXClipboardModule，另一个是WXStorageModule。所以这里没有targetQueue，就只能切换到对应的targetThread上。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> WXPerformBlockOnThread(<span class="keyword">void</span> (^ _Nonnull block)(), <span class="built_in">NSThread</span> *thread)</span><br><span class="line">&#123;</span><br><span class="line">    [WXUtility performBlock:block onThread:thread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)performBlock:(<span class="keyword">void</span> (^)())block onThread:(<span class="built_in">NSThread</span> *)thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!thread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程不是目标线程上，就要切换线程</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] == thread) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_performBlock:)</span><br><span class="line">                     onThread:thread</span><br><span class="line">                   withObject:[block <span class="keyword">copy</span>]</span><br><span class="line">                waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是切换线程的操作，如果当前线程不是目标线程，就要切换线程。在目标线程上调用_performBlock:方法，入参还是最初传进来的block闭包。</p>
<p>切换前线程处于子线程“com.taobao.weex.bridge”中。</p>
<p>在WXDomModule中调用targetExecuteThread方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSThread</span> *)targetExecuteThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [WXComponentManager componentThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换线程之后，当前线程变成了“com.taobao.weex.component”。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createBody:(<span class="built_in">NSDictionary</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createRoot:body];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performBlockOnComponentManager:(<span class="keyword">void</span>(^)(WXComponentManager *))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = weakSelf.weexInstance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启组件任务</span></span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        block(manager);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用了Dom模块的createBody方法以后，会先调用WXComponentManager的startComponentTasks方法，再调用createRoot:方法。</p>
<p>这里会初始化一个WXComponentManager。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponentManager *)componentManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_componentManager) &#123;</span><br><span class="line">        _componentManager = [[WXComponentManager alloc] initWithWeexInstance:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _componentManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWeexInstance:(<span class="keyword">id</span>)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        </span><br><span class="line">        _indexDict = [<span class="built_in">NSMapTable</span> strongToWeakObjectsMapTable];</span><br><span class="line">        _fixedComponents = [<span class="built_in">NSMutableArray</span> wx_mutableArrayUsingWeakReferences];</span><br><span class="line">        _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _isValid = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> _startDisplayLink];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的初始化重点是会开启DisplayLink，它会开启一个runloop。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_startDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!_displayLink)&#123;</span><br><span class="line">        _displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_handleDisplayLink)];</span><br><span class="line">        [_displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>displayLink一旦开启，被加入到当前runloop之中，每次runloop循环一次都会执行刷新布局的方法_handleDisplayLink。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startComponentTasks</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> _awakeDisplayLink];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_awakeDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    <span class="keyword">if</span>(_displayLink &amp;&amp; _displayLink.paused) &#123;</span><br><span class="line">        _displayLink.paused = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的startComponentTasks方法仅仅是更改了CADisplayLink的paused的状态。CADisplayLink就是用来刷新layout的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WXComponentManager</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对WXSDKInstance的弱引用</span></span><br><span class="line">    __<span class="keyword">weak</span> WXSDKInstance *_weexInstance;</span><br><span class="line">    <span class="comment">// 当前WXComponentManager是否可用</span></span><br><span class="line">    <span class="built_in">BOOL</span> _isValid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否停止刷新布局</span></span><br><span class="line">    <span class="built_in">BOOL</span> _stopRunning;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _noTaskTickCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// access only on component thread</span></span><br><span class="line">    <span class="built_in">NSMapTable</span>&lt;<span class="built_in">NSString</span> *, WXComponent *&gt; *_indexDict;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;dispatch_block_t&gt; *_uiTaskQueue;</span><br><span class="line">    </span><br><span class="line">    WXComponent *_rootComponent;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_fixedComponents;</span><br><span class="line">    </span><br><span class="line">    css_node_t *_rootCSSNode;</span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_displayLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是WXComponentManager的所有属性，可以看出WXComponentManager就是用来处理UI任务的。</p>
<p>再来看看createRoot:方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createRoot:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    WXAssertParam(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建WXComponent，作为rootComponent</span></span><br><span class="line">    _rootComponent = [<span class="keyword">self</span> _buildComponentForData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.初始化css_node_t，作为rootCSSNode</span></span><br><span class="line">    [<span class="keyword">self</span> _initRootCSSNode];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 3.添加UI任务到uiTaskQueue数组中</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">        [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里干了3件事情:</p>
<h4 id="1-创建WXComponent"><a href="#1-创建WXComponent" class="headerlink" title="1.创建WXComponent"></a>1.创建WXComponent</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponent *)_buildComponentForData:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *ref = data[<span class="string">@"ref"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *type = data[<span class="string">@"type"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *styles = data[<span class="string">@"style"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = data[<span class="string">@"attr"</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *events = data[<span class="string">@"event"</span>];</span><br><span class="line">        </span><br><span class="line">    Class clazz = [WXComponentFactory classWithComponentName:type];</span><br><span class="line">    WXComponent *component = [[clazz alloc] initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:<span class="keyword">self</span>.weexInstance];</span><br><span class="line">    WXAssert(component, <span class="string">@"Component build failed for data:%@"</span>, data);</span><br><span class="line">    </span><br><span class="line">    [_indexDict setObject:component forKey:component.ref];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参data是之前的tasks数组。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                     styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pthread_mutexattr_init(&amp;_propertMutexAttr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;_propertMutexAttr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        pthread_mutex_init(&amp;_propertyMutex, &amp;_propertMutexAttr);</span><br><span class="line">        </span><br><span class="line">        _ref = ref;</span><br><span class="line">        _type = type;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        _styles = [<span class="keyword">self</span> parseStyles:styles];</span><br><span class="line">        _attributes = attributes ? [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:attributes] : [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _events = events ? [<span class="built_in">NSMutableArray</span> arrayWithArray:events] : [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _subcomponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        _absolutePosition = <span class="built_in">CGPointMake</span>(NAN, NAN);</span><br><span class="line">        </span><br><span class="line">        _isNeedJoinLayoutSystem = <span class="literal">YES</span>;</span><br><span class="line">        _isLayoutDirty = <span class="literal">YES</span>;</span><br><span class="line">        _isViewFrameSyncWithCalculated = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        _async = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//TODO set indicator style </span></span><br><span class="line">        <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"indicator"</span>]) &#123;</span><br><span class="line">            _styles[<span class="string">@"position"</span>] = <span class="string">@"absolute"</span>;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"left"</span>] &amp;&amp; !_styles[<span class="string">@"right"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"left"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"top"</span>] &amp;&amp; !_styles[<span class="string">@"bottom"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"top"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置NavBar的Style</span></span><br><span class="line">        [<span class="keyword">self</span> _setupNavBarWithStyles:_styles attributes:_attributes];</span><br><span class="line">        <span class="comment">// 根据style初始化cssNode数据结构</span></span><br><span class="line">        [<span class="keyword">self</span> _initCSSNodeWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 根据style初始化View的各个属性</span></span><br><span class="line">        [<span class="keyword">self</span> _initViewPropertyWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 处理Border的圆角，边线宽度，背景颜色等属性</span></span><br><span class="line">        [<span class="keyword">self</span> _handleBorders:styles isUpdating:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数就是初始化WXComponent的布局的各个属性。这里会用到FlexBox里面的一些计算属性的方法就在_initCSSNodeWithStyles:方法里面。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initCSSNodeWithStyles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">&#123;</span><br><span class="line">    _cssNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    _cssNode-&gt;print = cssNodePrint;</span><br><span class="line">    _cssNode-&gt;get_child = cssNodeGetChild;</span><br><span class="line">    _cssNode-&gt;is_dirty = cssNodeIsDirty;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> measureBlock]) &#123;</span><br><span class="line">        _cssNode-&gt;measure = cssNodeMeasure;</span><br><span class="line">    &#125;</span><br><span class="line">    _cssNode-&gt;context = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新计算_cssNode需要布局的子视图个数</span></span><br><span class="line">    [<span class="keyword">self</span> _recomputeCSSNodeChildren];</span><br><span class="line">    <span class="comment">// 将style各个属性都填充到cssNode数据结构中</span></span><br><span class="line">    [<span class="keyword">self</span> _fillCSSNode:styles];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// To be in conformity with Android/Web, hopefully remove this in the future.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.ref isEqualToString:WX_SDK_ROOT_REF]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_HEIGHT]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.height) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_HEIGHT] = <span class="keyword">self</span>.weexInstance.frame.size.height;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_WIDTH]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.width) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_WIDTH] = <span class="keyword">self</span>.weexInstance.frame.size.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在_fillCSSNode:方法里面会对FlexBox算法里面定义的各个属性值就行赋值。</p>
<h4 id="2-初始化css-node-t"><a href="#2-初始化css-node-t" class="headerlink" title="2.初始化css_node_t"></a>2.初始化css_node_t</h4><p>在这里，准备开始Layout之前，我们需要先初始化rootCSSNode</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initRootCSSNode</span><br><span class="line">&#123;</span><br><span class="line">    _rootCSSNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据页面weexInstance设置rootCSSNode的坐标和宽高尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> _applyRootFrame:<span class="keyword">self</span>.weexInstance.frame toRootCSSNode:_rootCSSNode];</span><br><span class="line">    </span><br><span class="line">    _rootCSSNode-&gt;style.flex_wrap = CSS_NOWRAP;</span><br><span class="line">    _rootCSSNode-&gt;is_dirty = rootNodeIsDirty;</span><br><span class="line">    _rootCSSNode-&gt;get_child = rootNodeGetChild;</span><br><span class="line">    _rootCSSNode-&gt;context = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    _rootCSSNode-&gt;children_count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述方法中，会初始化rootCSSNode的坐标和宽高尺寸。</p>
<h4 id="3-添加UI任务到uiTaskQueue数组中"><a href="#3-添加UI任务到uiTaskQueue数组中" class="headerlink" title="3.添加UI任务到uiTaskQueue数组中"></a>3.添加UI任务到uiTaskQueue数组中</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">    [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>WXComponentManager会把当前的组件以及它对应的View添加到页面Instance的rootView上面的这个任务，添加到uiTaskQueue数组中。</p>
<p>_rootComponent.view会创建组件对应的WXView，这个是继承自UIView的。所以Weex通过JS代码创建出来的控件都是原生的，都是WXView类型的，实质就是UIView。创建UIView这一步又是回到主线程中执行的。</p>
<p>最后显示到页面上的工作，是由displayLink的刷新方法在主线程刷新UI显示的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_handleDisplayLink</span><br><span class="line">&#123; </span><br><span class="line">    [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layoutAndSyncUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Flexbox布局</span></span><br><span class="line">    [<span class="keyword">self</span> _layout];</span><br><span class="line">    <span class="keyword">if</span>(_uiTaskQueue.count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 同步执行UI任务</span></span><br><span class="line">        [<span class="keyword">self</span> _syncUITasks];</span><br><span class="line">        _noTaskTickCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前一秒内没有任务，那么智能的挂起displaylink，以节约CPU时间</span></span><br><span class="line">        _noTaskTickCount ++;</span><br><span class="line">        <span class="keyword">if</span> (_noTaskTickCount &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _suspendDisplayLink];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_layoutAndSyncUI是布局和刷新UI的核心流程。每次刷新一次，都会先调用Flexbox算法的Layout进行布局，这个布局是在子线程“com.taobao.weex.component”执行的。接着再去查看当前是否有UI任务需要执行，如果有，就切换到主线程进行UI刷新操作。</p>
<p>这里还会有一个智能的挂起操作。就是判断一秒内如果都没有任务，那么就挂起displaylink，以节约CPU时间。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> needsLayout = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = [_indexDict objectEnumerator];</span><br><span class="line">    WXComponent *component;</span><br><span class="line">    <span class="comment">// 判断当前是否需要布局，即是判断当前组件的_isLayoutDirty这个BOLL属性值</span></span><br><span class="line">    <span class="keyword">while</span> ((component = [enumerator nextObject])) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([component needsLayout]) &#123;</span><br><span class="line">            needsLayout = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!needsLayout) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Flexbox的算法核心函数</span></span><br><span class="line">    layoutNode(_rootCSSNode, _rootCSSNode-&gt;style.dimensions[CSS_WIDTH], _rootCSSNode-&gt;style.dimensions[CSS_HEIGHT], CSS_DIRECTION_INHERIT);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableSet</span>&lt;WXComponent *&gt; *dirtyComponents = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    [_rootComponent _calculateFrameWithSuperAbsolutePosition:<span class="built_in">CGPointZero</span> gatherDirtyComponents:dirtyComponents];</span><br><span class="line">    <span class="comment">// 计算当前weexInstance的rootView.frame，并且重置rootCSSNode的Layout</span></span><br><span class="line">    [<span class="keyword">self</span> _calculateRootFrame];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在每个需要布局的组件之间</span></span><br><span class="line">    <span class="keyword">for</span> (WXComponent *dirtyComponent <span class="keyword">in</span> dirtyComponents) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">            [dirtyComponent _layoutDidFinish];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_indexDict里面维护了一张整个页面的布局结构的Map，举个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMapTable</span> &#123;</span><br><span class="line">[<span class="number">7</span>] _root -&gt; &lt;div ref=_root&gt; &lt;WXView: <span class="number">0x7fc59a416140</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">331.333</span> <span class="number">331.333</span>); layer = &lt;WXLayer: <span class="number">0x608000223180</span>&gt;&gt;</span><br><span class="line">[<span class="number">12</span>] <span class="number">5</span> -&gt; &lt;image ref=<span class="number">5</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a724430</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">192.333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; layer = &lt;WXLayer: <span class="number">0x60000002f780</span>&gt;&gt;</span><br><span class="line">[<span class="number">13</span>] <span class="number">3</span> -&gt; &lt;image ref=<span class="number">3</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a617a00</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">55.3333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; opaque = <span class="literal">NO</span>; gestureRecognizers = &lt;<span class="built_in">NSArray</span>: <span class="number">0x60000024b760</span>&gt;; layer = &lt;WXLayer: <span class="number">0x60000003e8c0</span>&gt;&gt;</span><br><span class="line">[<span class="number">15</span>] <span class="number">4</span> -&gt; &lt;text ref=<span class="number">4</span>&gt; &lt;WXText: <span class="number">0x7fc59a509840</span>; text: hello Weex; frame:<span class="number">0.000000</span>,<span class="number">441.666667</span>,<span class="number">331.333333</span>,<span class="number">26.666667</span> frame = (<span class="number">0</span> <span class="number">441.667</span>; <span class="number">331.333</span> <span class="number">26.6667</span>); opaque = <span class="literal">NO</span>; layer = &lt;WXLayer: <span class="number">0x608000223480</span>&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的组件都是由ref引用值作为Key存储的，只要知道这个页面上全局唯一的ref，就可以拿到这个ref对应的组件。</p>
<p>_layout会先判断当前是否有需要布局的组件，如果有，就从rootCSSNode开始进行Flexbox算法的Layout。执行完成以后还需要调整一次rootView的frame，最后添加一个UI任务到taskQueue中，这个任务标记的是组件布局完成。</p>
<p>注意上述所有布局操作都是在子线程“com.taobao.weex.component”中执行的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_syncUITasks</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用blocks接收原来uiTaskQueue里面的所有任务</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;dispatch_block_t&gt; *blocks = _uiTaskQueue;</span><br><span class="line">    <span class="comment">// 清空uiTaskQueue</span></span><br><span class="line">    _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 在主线程中依次执行uiTaskQueue里面的所有闭包</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">for</span>(dispatch_block_t block <span class="keyword">in</span> blocks) &#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局完成以后就调用同步的UI刷新方法。注意这里要对UI进行操作，一定要切换回主线程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b16532cf00e3f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>####（二）callAddElement</p>
<p>在子线程“com.taobao.weex.bridge”中，会一直相应来自JSFramework调用Native的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当JSFramework调用callAddElement方法，就会执行上述代码的闭包函数。这里会接收来自JS的4个入参。</p>
<p>举个例子，JSFramework可能会通过callAddElement方法传过来这样4个参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">_root, </span><br><span class="line">&#123;</span><br><span class="line">    attr =     &#123;</span><br><span class="line">        value = <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ref = <span class="number">4</span>;</span><br><span class="line">    style =     &#123;</span><br><span class="line">        color = <span class="string">"#000000"</span>;</span><br><span class="line">        fontSize = <span class="number">40</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    type = text;</span><br><span class="line">&#125;, </span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>这里的insertIndex为0，parentRef是_root，componentData是当前要创建的组件的信息，instanceIdString是-1。</p>
<p>之后WXComponentManager就会调用startComponentTasks开始displaylink继续准备刷新布局，最后调用addComponent: toSupercomponent: atIndex: appendingInTree:方法添加新的组件。</p>
<p>注意，WXComponentManager的这两步操作，又要切换线程，切换到“com.taobao.weex.component”子线程中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(<span class="built_in">NSString</span> *)superRef atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *supercomponent = [_indexDict objectForKey:superRef];</span><br><span class="line">    WXAssertComponentExist(supercomponent);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _recursivelyAddComponent:componentData toSupercomponent:supercomponent atIndex:index appendingInTree:appendingInTree];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager会在“com.taobao.weex.component”子线程中递归的添加子组件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_recursivelyAddComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据componentData构建组件</span></span><br><span class="line">    WXComponent *component = [<span class="keyword">self</span> _buildComponentForData:componentData];</span><br><span class="line">    </span><br><span class="line">    index = (index == <span class="number">-1</span> ? supercomponent-&gt;_subcomponents.count : index);</span><br><span class="line">    </span><br><span class="line">    [supercomponent _insertSubcomponent:component atIndex:index];</span><br><span class="line">    <span class="comment">// 用_lazyCreateView标识懒加载</span></span><br><span class="line">    <span class="keyword">if</span>(supercomponent &amp;&amp; component &amp;&amp; supercomponent-&gt;_lazyCreateView) &#123;</span><br><span class="line">        component-&gt;_lazyCreateView = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入一个UI任务</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        [supercomponent insertSubview:component atIndex:index];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *subcomponentsData = [componentData valueForKey:<span class="string">@"children"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class="string">@"append"</span>] isEqualToString:<span class="string">@"tree"</span>];</span><br><span class="line">    <span class="comment">// 再次递归的规则：如果父视图是一个树状结构，子视图即使也是一个树状结构，也不能再次Layout</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSDictionary</span> *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [<span class="keyword">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class="number">-1</span> appendingInTree:appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (appendTree) &#123;</span><br><span class="line">        <span class="comment">// 如果当前组件是树状结构，强制刷新layout，以防在syncQueue中堆积太多的同步任务。</span></span><br><span class="line">        [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在递归的添加子组件的时候，如果是树状结构，还需要再次强制进行一次layout，同步一次UI。这里调用[self _layoutAndSyncUI]方法和createRoot:时候实现是完全一样的，下面就不再赘述了。</p>
<p>这里会循环添加多个子视图，相应的也会调用多次Layout方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d1f730e3bee34bdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（三）createFinish"><a href="#（三）createFinish" class="headerlink" title="（三）createFinish"></a>（三）createFinish</h4><p>当所有的视图都添加完成以后，JSFramework就是再次调用callNative方法。</p>
<p>还是会传过来3个参数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">instance:<span class="number">0</span>, </span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">        );</span><br><span class="line">        method = createFinish;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line">callback:<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>callNative通过这个参数会调用到WXDomModule的createFinish方法。这里的具体实现见第一步的callNative，这里不再赘述。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createFinish];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终也是会调用到WXComponentManager的createFinish。当然这里是会进行线程切换，切换到WXComponentManager的线程“com.taobao.weex.component”子线程上。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    WXSDKInstance *instance  = <span class="keyword">self</span>.weexInstance;</span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;        </span><br><span class="line">        <span class="built_in">UIView</span> *rootView = instance.rootView;</span><br><span class="line">        </span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTFirstScreenRender, instance);</span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTAllRender, instance);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTJSBridge);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTNativeRender);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(instance.renderFinish)&#123;</span><br><span class="line">            instance.renderFinish(rootView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的createFinish方法最后就是添加一个UI任务，回调到主线程的renderFinish方法里面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2896c636f11b2202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>至此，Weex的布局流程就完成了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-caf559cea2e73cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>虽然Autolayout是苹果原生就支持的自动布局方案，但是在稍微复杂的界面就会出现性能问题。大半年前，Draveness的这篇<a href="http://draveness.me/layout-performance/" rel="external nofollow noopener noreferrer" target="_blank">《从 Auto Layout 的布局算法谈性能》</a>文章里面也稍微“批判”了Autolayout的性能问题，但是文章里面最后提到的是用ASDK的方法来解决问题。本篇文章则献上另外一种可用的布局方法——FlexBox，并且带上了经过大量测试的测试数据，向大左的这篇经典文章致敬！</p>
<p>如今，iOS平台上几大可用的布局方法有：Frame原生布局，Autolayout原生自动布局，FlexBox的Yoga实现，ASDK。</p>
<p>当然，基于这4种基本方案以外，还有一些组合方法，比如Weex的这种，用JS的CSS解析成类似JSON的DOM，再调用Native的FlexBox算法进行布局。前段时间还有来自美团的<a href="http://tech.meituan.com/the_future_of_layout.html" rel="external nofollow noopener noreferrer" target="_blank">《布局编码的未来》</a>里面提到的毕加索（picasso）布局方法。原理也是会用到JSCore，将JS写的JSON或者自定义的DSL，经过本地的picassoEngine布局引擎转换成Native布局，最终利用锚点的概念做到高效的布局。</p>
<p>最后，推荐2个iOS平台上比较优秀的利用了FlexBox的原理的开源库：</p>
<p>来自Facebook的<strong><a href="https://github.com/facebook/yoga" rel="external nofollow noopener noreferrer" target="_blank">yoga</a></strong><br>来自饿了么的<strong><a href="https://github.com/LPD-iOS/FlexBoxLayout" rel="external nofollow noopener noreferrer" target="_blank">FlexBoxLayout</a></strong></p>
<hr>
<p>Weex 源码解析系列文章：</p>
<p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_how_to_work_in_iOS.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 是如何在 iOS 客户端上跑起来的</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_layout_engine_powered_by_Flexbox&#39;s_algorithm.md" rel="external nofollow noopener noreferrer" target="_blank">由 FlexBox 算法强力驱动的 Weex 布局引擎</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_events.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 事件传递的那些事儿</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_ingenuity_JS_framework.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 中别具匠心的 JS Framework</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a>  </p>
<hr>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Hybird/weex/weex_one" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/weex_one/">
            <time datetime="2018-05-04T04:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="React-Native-和-Weex"><a href="#React-Native-和-Weex" class="headerlink" title="React Native 和 Weex"></a>React Native 和 Weex</h2><p>自从Weex出生的那一天起，就无法摆脱和React Native相互比较的命运。React Native宣称“Learn once, write anywhere”，而Weex宣称“Write Once, Run Everywhere”。Weex从出生那天起，就被给予了一统三端的厚望。React Native可以支持iOS、Android，而Weex可以支持iOS、Android、HTML5。</p>
<p>在Native端，两者的最大的区别可能就是在对JSBundle是否分包。React Native官方只允许将React Native基础JS库和业务JS一起打成一个JS bundle，没有提供分包的功能，所以如果想节约流量就必须制作分包打包工具。而Weex默认打的JS bundle只包含业务JS代码，体积小很多，基础JS库包含在Weex SDK中，这一点Weex与Facebook的React Native和微软的Cordova相比，Weex更加轻量，体积小巧。</p>
<p>在JS端，Weex又被人称为Vue Native，所以 React Native 和 Weex 的区别就在 React 和 Vue 两者上了。</p>
<p>笔者没有写过React Native，所以也没法客观的去比较两者。不过知乎上有一个关于Weex 和 React Native很好的对比文章<a href="https://zhuanlan.zhihu.com/p/21677103" rel="external nofollow noopener noreferrer" target="_blank">《weex&amp;React Native对比》</a>，推荐大家阅读。</p>
<p>前两天<a href="http://www.weibo.com/122678100" rel="external nofollow noopener noreferrer" target="_blank">@Allen 许帅</a>也在<a href="http://tech.glowing.com/cn/" rel="external nofollow noopener noreferrer" target="_blank">Glow 技术团队博客</a>上面发布了一篇<a href="http://tech.glowing.com/cn/react-native-at-glow/" rel="external nofollow noopener noreferrer" target="_blank">《React Native 在 Glow 的实践》</a>这篇文章里面也谈了很多关于React Native实践相关的点，也强烈推荐大家去阅读。</p>
<h2 id="入门手册"><a href="#入门手册" class="headerlink" title="入门手册"></a>入门手册</h2><p>关于小白想入门Weex，当然最基础的还是要通读文档，文档是官方最好的学习资料。官方的基础文档有两份：</p>
<p><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">教程文档</a><br><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">手册文档</a></p>
<p>在文档手册里面包含了Weex所有目前有的组件，模块，每个组件和模块的用法和属性。遇到问题可以先过来翻翻。很有可能有些组件和模块没有那些属性。</p>
<h2 id="Weex系列工具"><a href="#Weex系列工具" class="headerlink" title="Weex系列工具"></a>Weex系列工具</h2><p>看完官方文档以后，就可以开始上手构建工程项目了。</p>
<p>Weex也和前端项目一样，拥有它自己的脚手架全家桶。</p>
<ol>
<li>weex-toolkit </li>
<li>weexpack </li>
<li>playground </li>
<li>code snippets </li>
<li>weex-devtool。</li>
</ol>
<h4 id="weex-toolkit"><a href="#weex-toolkit" class="headerlink" title="weex-toolkit"></a>weex-toolkit</h4><p>weex-toolkit是用来初始化项目，编译，运行，debug所有工具。</p>
<p>通过下面的命令安装 </p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -g weex-toolkit</span><br></pre></td></tr></table></figure>
<p>安装完成后就可以使用weex 命令了 </p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex-toolkit.png" alt=""></p>
<p>我们主要用的就是debug 和 compile命令。debug 是启动chrome调试器 、compile命令是将写好的js文件编译为JS bundle。</p>
<h4 id="weexpack"><a href="#weexpack" class="headerlink" title="weexpack"></a>weexpack</h4><p>weexpack是用来打包JSBundle的，实际也是对Webpack的封装。</p>
<h4 id="playground"><a href="#playground" class="headerlink" title="playground"></a>playground</h4><p>playground是一个上架的App，这个可以用来通过扫码实时在手机上显示出实际的页面。</p>
<p> <img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/playground.png" alt=""></p>
<h4 id="code-snippets"><a href="#code-snippets" class="headerlink" title="code snippets"></a>code snippets</h4><p>code snippets这个是一个在线的playground。</p>
<p> <img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/dotwe.png" alt=""></p>
<h4 id="weex-devtool"><a href="#weex-devtool" class="headerlink" title="weex-devtool"></a>weex-devtool</h4><p>weex-devtool 可以使用chrome调试JS 代码。  这个工具我认为主要方便前端开发使用。</p>
<p>使用步骤，首先启动调试服务，终端输入</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">weex</span> <span class="literal">debug</span></span><br></pre></td></tr></table></figure>
<p>结果如下:</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebug.png" alt=""></p>
<p>同时启动chrome。然后在代码中将host换为图中的host。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NSString *strHost =  [[NSUserDefaults standardUserDefaults] <span class="string">objectForKey:</span>GWX_WEEX_DEBUG_HOST];</span><br><span class="line">    <span class="keyword">if</span>(strHost.length&gt;<span class="number">5</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        NSString *strURL = [NSString <span class="string">stringWithFormat:</span>@<span class="string">"ws://%@/debugProxy/native"</span>,strHost];</span><br><span class="line">        [WXDevTool <span class="string">setDebug:</span>YES];</span><br><span class="line">        [WXLog <span class="string">setLogLevel:</span>WXLogLevelLog];</span><br><span class="line">        [WXDevTool <span class="string">launchDevToolDebugWithUrl:</span>strURL];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        [WXDebugTool <span class="string">setDebug:</span>NO];</span><br><span class="line">        [WXLog <span class="string">setLogLevel:</span>WXLogLevelError];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>启动app，看到app链接到了 chrome调试服务器 </p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugapp.png" alt=""></p>
<p>下图是debuger 截图 ：</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugdebug.png" alt=""></p>
<p>下图是inspect截图：<br><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weexdebugpage.png" alt=""></p>
<p>具体使用方法看这两篇文章即可：</p>
<ol>
<li><p><a href="https://zhuanlan.zhihu.com/p/25331465" rel="external nofollow noopener noreferrer" target="_blank">《Weex 入坑指南：Debug 调试是一门手艺活》</a>  </p>
</li>
<li><p><a href="https://github.com/weexteam/article/issues/50" rel="external nofollow noopener noreferrer" target="_blank">《Weex调试神器——Weex Devtools使用手册》</a></p>
</li>
</ol>
<h2 id="Weex-Market插件"><a href="#Weex-Market插件" class="headerlink" title="Weex Market插件"></a><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md#2-weex-market%E6%8F%92%E4%BB%B6" rel="external nofollow noopener noreferrer" target="_blank">Weex Market插件</a></h2><p>在日常开发中，我们可以全部自己开发完所有的Weex界面，当然还可以用一些已有的优秀的轮子。Weex的所有优秀的轮子都在Weex Market里面。</p>
<p> <a href="https://camo.githubusercontent.com/bdaba9a49b7d7b32486fb7d68a1c5c965c07b19c/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f313139343031322d353631643838663562333739353763352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" rel="external nofollow noopener noreferrer" target="_blank">Weex Market</a> </p>
<p>在这个Market里面有很多已经写好的轮子，直接拿来用，可以节约很多时间。</p>
<p>比如这里很火的weex-chart。weex-chart图表插件是通过g2-mobile依赖[gcanvas插件][23]实现的</p>
<p>如果你想使用[Weex Market][24]的Plugin插件，你可以使用weex plugin 命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="keyword">add</span><span class="bash"> plugin_name</span></span><br></pre></td></tr></table></figure>
<p>你只需要输入插件的名称就可以从远程添加插件到你本地的项目，比如添加 weex-chart，我们可以输入命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="keyword">add</span><span class="bash"> weex-chart</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用plugin remove移除插件，比如移除安装好的 weex-cahrt：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ weex plugin <span class="builtin-name">remove</span> weex-chart</span><br></pre></td></tr></table></figure>
<p>这个插件库里面我用过weex-router，还不错，用它来做weex的路由管理。推荐使用。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://weex-project.io/cn/guide/" rel="external nofollow noopener noreferrer" target="_blank">官方教程</a></li>
<li><a href="http://weex-project.io/cn/references/" rel="external nofollow noopener noreferrer" target="_blank">官方手册</a></li>
<li><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md#ios-开发者的-weex-伪最佳实践指北" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a></li>
</ol>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-Hybird/weex/weex_four" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/weex_four/">
            <time datetime="2018-05-04T04:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <a id="more"></a>
<h3 id="一、Flex-布局是什么？"><a href="#一、Flex-布局是什么？" class="headerlink" title="一、Flex 布局是什么？"></a>一、Flex 布局是什么？</h3><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>任何一个容器都可以指定为 Flex 布局。</p>
<blockquote>
<p>.box{ display: flex; }</p>
</blockquote>
<p>行内元素也可以使用 Flex 布局。</p>
<blockquote>
<p>.box{ display: inline-flex; }</p>
</blockquote>
<p>Webkit 内核的浏览器，必须加上-webkit前缀。</p>
<blockquote>
<p>.box{ display: -webkit-flex; /<em> Safari </em>/ display: flex; }</p>
</blockquote>
<p>注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。</p>
<h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><p><strong>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</strong></p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_1.png" alt=""></p>
<font color="red">容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</font>

<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<h3 id="三、容器的属性"><a href="#三、容器的属性" class="headerlink" title="三、容器的属性"></a>三、容器的属性</h3><p>以下6个属性设置在容器上。</p>
<ol>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ol>
<h3 id="3-1-flex-direction属性"><a href="#3-1-flex-direction属性" class="headerlink" title="3.1 flex-direction属性"></a>3.1 flex-direction属性</h3><p><strong>flex-direction属性决定主轴的方向（即项目的排列方向）。</strong></p>
<p><code>.box { flex-direction: row | row-reverse | column | column-reverse; }</code></p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_2.png" alt=""></p>
<p>它可能有4个值。</p>
<ol>
<li>row（默认值）：主轴为水平方向，起点在左端。</li>
<li>row-reverse：主轴为水平方向，起点在右端。</li>
<li>column：主轴为垂直方向，起点在上沿。</li>
<li>column-reverse：主轴为垂直方向，起点在下沿。</li>
</ol>
<h3 id="3-2-flex-wrap属性"><a href="#3-2-flex-wrap属性" class="headerlink" title="3.2 flex-wrap属性"></a>3.2 flex-wrap属性</h3><p><strong>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</strong></p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_3.png" alt=""></p>
<blockquote>
<p>.box{ flex-wrap: nowrap | wrap | wrap-reverse; }</p>
</blockquote>
<p>它可能取三个值。</p>
<p>（1）nowrap（默认）：不换行。</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_4.png" alt=""></p>
<p>（2）wrap：换行，第一行在上方。</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_6.jpg" alt=""></p>
<p>（3）wrap-reverse：换行，第一行在下方。</p>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_6.png" alt=""></p>
<h3 id="3-3-flex-flow"><a href="#3-3-flex-flow" class="headerlink" title="3.3 flex-flow"></a>3.3 flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<blockquote>
<p>.box { flex-flow: || ; }</p>
</blockquote>
<h3 id="3-4-justify-content属性"><a href="#3-4-justify-content属性" class="headerlink" title="3.4 justify-content属性"></a>3.4 justify-content属性</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p>
<blockquote>
<p>.box { justify-content: flex-start | flex-end | center | space-between | space-around; }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_7.png" alt=""></p>
<p>它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<blockquote>
<p>flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</p>
</blockquote>
<h3 id="3-5-align-items属性"><a href="#3-5-align-items属性" class="headerlink" title="3.5 align-items属性"></a>3.5 align-items属性</h3><font color="red"><strong>align-items属性定义项目在交叉轴上如何对齐。</strong></font>

<blockquote>
<p>.box { align-items: flex-start | flex-end | center | baseline | stretch; }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_8.png" alt=""></p>
<p>它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p>
<blockquote>
<p>flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p>
</blockquote>
<h3 id="3-6-align-content属性"><a href="#3-6-align-content属性" class="headerlink" title="3.6 align-content属性"></a>3.6 align-content属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p>
<blockquote>
<p>.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_9.png" alt=""></p>
<p>该属性可能取6个值。</p>
<blockquote>
<p>flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。</p>
</blockquote>
<h3 id="四、项目的属性"><a href="#四、项目的属性" class="headerlink" title="四、项目的属性"></a>四、项目的属性</h3><p>以下6个属性设置在项目上。</p>
<ol>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flexalign-self</li>
</ol>
<h3 id="4-1-order属性"><a href="#4-1-order属性" class="headerlink" title="4.1 order属性"></a>4.1 order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<blockquote>
<p>.item { order: ; }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_10.png" alt=""></p>
<h3 id="4-2-flex-grow属性"><a href="#4-2-flex-grow属性" class="headerlink" title="4.2 flex-grow属性"></a>4.2 flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<blockquote>
<p>.item { flex-grow: ; /<em> default 0 </em>/ }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_11.png" alt=""></p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<h3 id="4-3-flex-shrink属性"><a href="#4-3-flex-shrink属性" class="headerlink" title="4.3 flex-shrink属性"></a>4.3 flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<blockquote>
<p>.item { flex-shrink: ; /<em> default 1 </em>/ }</p>
</blockquote>
<p><img src="/wiki/Hybird/weex/weex_four/weexImage/weex_flex_12.jpg" alt=""></p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<p>负值对该属性无效。</p>
<h3 id="4-4-flex-basis属性"><a href="#4-4-flex-basis属性" class="headerlink" title="4.4 flex-basis属性"></a>4.4 flex-basis属性</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<blockquote>
<p>.item { flex-basis: | auto; /<em> default auto </em>/ }</p>
</blockquote>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="4-5-flex属性"><a href="#4-5-flex属性" class="headerlink" title="4.5 flex属性"></a>4.5 flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<blockquote>
<p>.item { flex: none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ] }</p>
</blockquote>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<h3 id="4-6-align-self属性"><a href="#4-6-align-self属性" class="headerlink" title="4.6 align-self属性"></a>4.6 align-self属性</h3><p><strong>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</strong></p>
<blockquote>
<p>.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; }</p>
</blockquote>
<p><img src="http://of685p9vy.bkt.clouddn.com/hybird/weex/weex_flex_12.jpg" alt=""></p>
<p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>
<hr>
<h2 id="抄袭地址"><a href="#抄袭地址" class="headerlink" title="抄袭地址"></a>抄袭地址</h2><ol>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" rel="external nofollow noopener noreferrer" target="_blank">Flex 布局教程：语法篇</a></li>
</ol>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-IOS/事件处理/iOS事件处理" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/事件处理/">事件处理</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/事件处理/">事件处理</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/事件处理/iOS事件处理/">
            <time datetime="2018-04-27T04:07:12.000Z" itemprop="datePublished">2018-04-27</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/IOS/事件处理/iOS事件处理/">iOS事件处理看我就够了(转载)</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p></p><p>本文转载自<a href="https://www.jianshu.com/p/b0884faae603" rel="external nofollow noopener noreferrer" target="_blank">iOS事件处理，看我就够了~</a></p><p></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/IOS/事件处理/iOS事件处理/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <article id="post-工具/ruby/homebrew-gem使用" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/工具/">工具</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/工具/ruby/">ruby</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/工具/">工具</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/工具/ruby/homebrew-gem使用/">
            <time datetime="2018-04-23T04:07:12.000Z" itemprop="datePublished">2018-04-23</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a>
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                
                <p></p><p>最近使用cocoapod更新repo会报下面错误：</p>
<p>Updating spec repo <code>master</code><br>[!] Failed to connect to GitHub to update the CocoaPods/Specs specs repo - Please check if you are offline, or that GitHub is down</p>
<p>经过查找，发现GitHub在2018年2月23日移除了弱加密标准，导致无法正常连接到GitHub。<a href="https://blog.github.com/2018-02-23-weak-cryptographic-standards-removed/" rel="external nofollow noopener noreferrer" target="_blank">传送门</a>。</p>
<p>解决办法是：升级Cocoapod、openssl、ruby。首先介绍下更新ruby使用的Homebrew。</p><p></p>
            
        
        
            </div>   
            <div class="article-more-link">
                <a href="/wiki/工具/ruby/homebrew-gem使用/#more">查看更多</a>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>






    
        <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
        </nav>
    
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LJ &copy; 2018 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'lijian'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
