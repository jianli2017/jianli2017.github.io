<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎 | LJ小窝</title>
    
    
        <meta name="keywords" content="weex">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="前言在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。 目录 1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的  一. Weex布局算法打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex">
<meta name="keywords" content="weex">
<meta property="og:type" content="article">
<meta property="og:title" content="weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎">
<meta property="og:url" content="http://yoursite.com/wiki/Hybird/weex/Weex_five/index.html">
<meta property="og:site_name" content="LJ小窝">
<meta property="og:description" content="前言在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。 目录 1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的  一. Weex布局算法打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-de7f409bd683080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-a85be95bcb08cc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-8c812635119a366c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-b476d0e771837826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-951af0f2fc01b0a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-74e4b1f77d6fa40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-d34a0fea4404545e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-8a6e7643a60e2906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-569f2a299797e27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-7dd84c06eabd1ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-d86b61dabc5a97fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-945bde67f5931fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-3823fed50bd98895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-5c514b364e470dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-e756eec5a022f74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-5e200b8d742b01a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-ceab624ccd23e978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-7bb4781738e20528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-10e077f6a05f4fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-c4e6c4930823f326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-3425b3876c3d665b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-c5358bd9b76e9aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-6a98ea3472c5b20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-b5b1500aa720593a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-77e9ab8a8268646f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-964d7fb4451fb0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-d982430a883bd70e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-40c4c59a6237ebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-40d7272e17d5b429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-9192b10f6607271c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-2968e2f04c41c140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-fc141fa8e3dc0433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-63e820c1ee9472cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-2a97e349befdc557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-6b994236e0c27d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-09b7902e4c7c67e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-2f208ced7d958ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-a7a0d48cba94f3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-0828ddc58f8d30ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-1b8f68cd9debed67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-510c7d7ab97e2330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-34171d65db564340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-f9468b0f10f0ef95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-7f51f5e34c9e5485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-64f5f7c2e89e2661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-409f0c3e820c5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-6b338b4507694268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-e60d70a0eaa4a67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-4560c9da3bfa0968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-cad15676ac4504b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-c71dbeba866e73fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-23bfe161375b750a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-6b16532cf00e3f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-d1f730e3bee34bdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-2896c636f11b2202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1194012-caf559cea2e73cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-06-22T06:35:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎">
<meta name="twitter:description" content="前言在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。 目录 1.Weex布局算法 2.Weex布局算法性能分析 3.Weex是如何布局原生界面的  一. Weex布局算法打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1194012-de7f409bd683080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
    

    
        <link rel="alternate" href="/atom.xml" title="LJ小窝" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LJ小窝</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++Primer
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第七章类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第七章类/类/">类</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第三章 字符串、向量、数组
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/">字符串、向量、数组</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第九章顺序容器
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/">顺序容器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章变量和基本类型
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/">变量和基本类型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第八章io库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第八章io库/IO库/">IO库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第六章函数
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第六章函数/函数/">函数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十三章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十三章/拷贝控制/">拷贝控制</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十九章特殊工具和技术
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/">特殊工具和技术</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十二章 动态内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/">动态内存</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十五章 面向对象程序设计
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/">面向对象程序设计</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十六章 模板和泛型编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/">模板和泛型编程</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十四章/重载运算与类型转换/">重载运算与类型转换</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十章 泛型算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/">泛型算法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章 表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/运算符优先级表/">运算符优先级表</a></li>  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/表达式/">表达式</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            附录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/附录/关键字使用的位置/">关键字使用的位置</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++关键字理解
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++关键字理解/explicit-learn/">explicit实例浅析(转载)</a></li>  <li class="file"><a href="/wiki/C++语言/C++关键字理解/static/">static关键字作用总结(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            STL源码剖析
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第二章/空间配置器/">空间配置器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第四章/deque/">deque</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            container
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            deque
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/">deque的实现原理和使用方法详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            list
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/list/C++标准库中的list的实现原理/">C++标准库中的list的实现原理</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++语言/container/forward_list不支持push_back操作/">为什么`forward_list`不支持`push_back`操作？</a></li>  <li class="file"><a href="/wiki/C++语言/container/容器基本操作/">容器基本操作</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C语言语法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C语言语法/CC_pointer_memry/">二级指针动态申请内存</a></li>  <li class="file"><a href="/wiki/C语言语法/struct_Analize/">struct定义语法</a></li>  <li class="file"><a href="/wiki/C语言语法/union定义/">union定义(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/">堆区（heap）和栈区（stack）的区别(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Hybird
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            webview
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/webview/gome-Webview/">通用webview开发记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            weex
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/weex/event-analize/">weex 事件原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-conmunication/">weex 通信原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-debug/">搭建weex断点调试环境</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a></li>  <li class="file active"><a href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Category
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Category/深入理解Objective-C：Category/">深入理解Objective-C：Category(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GCD
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/GCD/use-dispatch-semaphore/">dispatch_semaphore 的使用方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS12
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/IOS12/IOS12-compatibility/">IOS12 兼容</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            MachO
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/MachO/machoviewer/">mach-o Viewer 源码学习</a></li>  <li class="file"><a href="/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Runtime
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            objc
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/objc/3NSObject/">3. NSObject 基本完整类图</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/4entsize_list_tt/">4. 方法列表entsize_list_tt结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/5list_array_tt/">5. list_array_tt 结构详解</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/0_refer/">0. 参考资料</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/">2. class_data_bits_t 结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/6_NXHashTable/">6. 上古时代 Objective-C 中哈希表的实现(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/1_NSObject_isa/">1. 从 NSObject 的初始化了解 isa（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/7_NXMapTable/">7. NXMapTable数据结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/8__objc_init/">8. objc4入口函数</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/9__read_images/">9. _read_images 从二进制文件中读取类信息</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/10_load_images/">10.load_images 函数分析</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/12_initialize/">12. 懒惰的 initialize 方法（转载）</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/11_load/">11. 你真的了解 load 方法么？</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/13_class_initialize/">13. _class_initialize 源码分析</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/14_AssociatedObject /">14. 关联对象 AssociatedObject 完全解析（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/16_retain_release/">16. retain 和 release（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/15_autoreleasepool/">15. 自动释放池的前世今生（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/17_weak/">16. retain 和 release（转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            神经病院Objective-C Runtime入院系列文章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/firstDay/">第一天--isa和Class(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/secondDay/">第二天--消息发送与转发（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/">第三天——如何正确使用Runtime(转载)</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/IOS/Runtime/meta_class/">What is a meta-class in Objective-C(译文)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            crash
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/crash/KSCrash_Analize/">KSCrash崩溃收集原理浅析</a></li>  <li class="file"><a href="/wiki/IOS/crash/Analize_Crash/">收集、符号化IOS崩溃日志</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            foundation使用记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSDateFormatter时间格式/">NSDateFormatter 时间格式</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/">NSInvocation的基本使</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            事件处理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/事件处理/iOS事件处理/">iOS事件处理看我就够了(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            内存管理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/内存管理/内存学习/">内存学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            动态库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/动态库/static_lib_aggregate_script/">合并真机模拟器静态库(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/库/组件化-库/">组件化-库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            开源库学习
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            fishhook
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/fishHookPicture/">图解fishhook</a></li>  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/learn_fishhook/">fishhook学习记录</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            暂无分类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/暂无分类/指定初始化函数/">正确使用NS_DESIGNATED_INITIALIZER</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            虚拟内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a></li>  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JS
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/JS/flexBox/">flexBox 伸缩盒子模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            WWDC
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/WWDC/What’s New in User Notifications/">What’s New in User Notifications</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            linux命令
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/linux命令/export命令/">export命令</a></li>  <li class="file"><a href="/wiki/linux命令/set命令/">set命令</a></li>  <li class="file"><a href="/wiki/linux命令/特殊参数/">set命令</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cocoapods
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-learn-install/">cocoapod学习 安装和使用（1）</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-private-repo/">创建私有仓库</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/Cocoapods-new-spec/">Cocoapods-new-spec</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS模拟器安装app
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/">给IOS模拟器按照APP</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SSH
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/SSH/ssh-theory/">图解SSH原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Xcode编译常量
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Xcode编译常量/xcode编译环境变量/">Xcode编译环境变量</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git简略版
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git简略版/git简略版/">Git笔记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git详细记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git详细记录/git仓库/">Git仓库(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git工作区/">git时光穿梭(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git分支管理/">Git分支管理(转载)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            hexo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/hexo/LaTex/">支持LaTEX的hexo博客</a></li>  <li class="file"><a href="/wiki/工具/hexo/hexo-use/">hexo使用指南</a></li>  <li class="file"><a href="/wiki/工具/hexo/自己搭建博客的经历/">自己搭建博客的经历</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            markdowm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/markdowm/Markdown公式编辑学习笔记/">Markdown公式编辑</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ruby
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具下载地址
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/工具下载地址/工具下载地址/">工具下载地址</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据知识/数学基础知识/">数学知识一对数指数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            编程基础
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            正则表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程基础/正则表达式/正则表达式学习/">正则表达式学习摘要</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-Hybird/weex/Weex_five" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/Hybird/">Hybird</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hybird/weex/">weex</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/weex/">weex</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/Hybird/weex/Weex_five/">
            <time datetime="2018-05-04T04:07:12.000Z" itemprop="datePublished">2018-05-04</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#目录"><span class="toc-number">2.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一-Weex布局算法"><span class="toc-number">3.</span> <span class="toc-text">一. Weex布局算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）FlexBox中的基本数据结构"><span class="toc-number">3.1.</span> <span class="toc-text">（一）FlexBox中的基本数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-align-items"><span class="toc-number">3.2.</span> <span class="toc-text">1.align_items</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-align-content"><span class="toc-number">3.3.</span> <span class="toc-text">2. align_content</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-align-self"><span class="toc-number">3.4.</span> <span class="toc-text">3.align_self</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）FlexBox中的布局算法"><span class="toc-number">3.5.</span> <span class="toc-text">（二）FlexBox中的布局算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二-Weex布局算法性能分析"><span class="toc-number">4.</span> <span class="toc-text">二. Weex布局算法性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-算法实现分析"><span class="toc-number">4.1.</span> <span class="toc-text">1.算法实现分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-算法性能测试准备工作"><span class="toc-number">4.2.</span> <span class="toc-text">2.算法性能测试准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-算法性能测试结果"><span class="toc-number">4.3.</span> <span class="toc-text">3.算法性能测试结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三-Weex是如何布局原生界面的"><span class="toc-number">5.</span> <span class="toc-text">三. Weex是如何布局原生界面的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-创建WXComponent"><span class="toc-number">5.1.</span> <span class="toc-text">1.创建WXComponent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-初始化css-node-t"><span class="toc-number">5.2.</span> <span class="toc-text">2.初始化css_node_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-添加UI任务到uiTaskQueue数组中"><span class="toc-number">5.3.</span> <span class="toc-text">3.添加UI任务到uiTaskQueue数组中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）createFinish"><span class="toc-number">5.4.</span> <span class="toc-text">（三）createFinish</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最后"><span class="toc-number">6.</span> <span class="toc-text">最后</span></a></li></ol>
                </div>
            
        
        
            <a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在上篇文章里面谈了Weex在iOS客户端工作的基本流程。这篇文章将会详细的分析Weex是如何高性能的布局原生界面的，之后还会与现有的布局方法进行对比，看看Weex的布局性能究竟如何。</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>1.Weex布局算法</li>
<li>2.Weex布局算法性能分析</li>
<li>3.Weex是如何布局原生界面的</li>
</ul>
<h3 id="一-Weex布局算法"><a href="#一-Weex布局算法" class="headerlink" title="一. Weex布局算法"></a>一. Weex布局算法</h3><p>打开Weex的源码的Layout文件夹，就会看到两个c的文件，这两个文件就是今天要谈的Weex的布局引擎。</p>
<p>Layout.h和Layout.c最开始是来自于React-Native里面的代码。也就是说Weex和React-Native的布局引擎都是同一套代码。</p>
<p>当前React-Native的代码里面已经没有这两个文件了，而是换成了Yoga。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-de7f409bd683080e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Yoga本是Facebook在React Native里引入的一种跨平台的基于CSS的布局引擎，它实现了Flexbox规范，完全遵守W3C的规范。随着该系统不断完善，Facebook对其进行重新发布，于是就成了现在的Yoga(<a href="https://facebook.github.io/yoga/" rel="external nofollow noopener noreferrer" target="_blank">Yoga官网</a>)。</p>
<p>那么Flexbox是什么呢？</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-a85be95bcb08cc24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>熟悉前端的同学一定很熟悉这个概念。2009年，W3C提出了一种新的方案——Flex布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了几乎所有浏览器的支持，目前的前端主要是使用Html / CSS / JS实现，其中CSS用于前端的布局。任何一个Html的容器可以通过css指定为Flex布局，一旦一个容器被指定为Flex布局，其子元素就可以按照FlexBox的语法进行布局。</p>
<p>关于FlexBox的基本定义，更加详细的文档说明，感兴趣的同学可以去阅读一下W3C的官方文档，那里会有很详细的说明。<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">官方文档链接</a></p>
<p>Weex中的Layout文件是Yoga的前身，是Yoga正式发布之前的版本。底层代码使用C语言代码，所以性能也不是问题。接下来就仔细分析Layout文件是如何实现FlexBox的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-8c812635119a366c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>故以下源码分析都基于v0.10.0这个版本。</p>
<h4 id="（一）FlexBox中的基本数据结构"><a href="#（一）FlexBox中的基本数据结构" class="headerlink" title="（一）FlexBox中的基本数据结构"></a>（一）FlexBox中的基本数据结构</h4><p>Flexbox布局（Flexible Box)设计之初的目的是为了能更加高效的分配子视图的布局情况，包括动态的改变宽度，高度，以及排列顺序。Flexbox可以更加方便的兼容各个大小不同的屏幕，比如拉伸和压缩子视图。</p>
<p>在FlexBox的世界里，存在着主轴和侧轴的概念。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b476d0e771837826.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>大多数情况，子视图都是沿着主轴（main axis），从主轴起点（main-start）到主轴终点（main-end）排列。但是这里需要注意的一点是，主轴和侧轴虽然永远是垂直的关系，但是谁是水平，谁是竖直，并没有确定，有可能会有如下的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-951af0f2fc01b0a2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在上图这种水平是侧轴的情况下，子视图是沿着侧轴（cross axis），从侧轴起点（cross-start）到侧轴终点（cross-end）排列的。</p>
<p><strong>主轴（main axis）：</strong>父视图的主轴，子视图主要沿着这条轴进行排列布局。</p>
<p><strong>主轴起点（main-start）和主轴终点（main-end）：</strong>子视图在父视图里面布局的方向是从主轴起点（main-start）向主轴终点（main-start）的方向。</p>
<p><strong>主轴尺寸（main size）：</strong>子视图在主轴方向的宽度或高度就是主轴的尺寸。子视图主要的大小属性要么是宽度，要么是高度属性，由哪一个对着主轴方向决定。</p>
<p><strong>侧轴（cross axis）：</strong>垂直于主轴称为侧轴。它的方向主要取决于主轴方向。</p>
<p><strong>侧轴起点（cross-start）和侧轴终点（cross-end）：</strong>子视图行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</p>
<p><strong>侧轴尺寸（cross size）：</strong>子视图的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是「width」或「height」属性，由哪一个对着侧轴方向决定。</p>
<p>接下来看看Layout是怎么定义FlexBox里面的元素的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_DIRECTION_INHERIT = <span class="number">0</span>,</span><br><span class="line">  CSS_DIRECTION_LTR,</span><br><span class="line">  CSS_DIRECTION_RTL</span><br><span class="line">&#125; <span class="keyword">css_direction_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个方向是定义的上下文的整体布局的方向，INHERIT是继承，LTR是Left To Right，从左到右布局。RTL是Right To Left，从右到左布局。下面分析如果不做特殊说明，都是LTR从左向右布局。如果是RTL就是LTR反向。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN = <span class="number">0</span>,</span><br><span class="line">  CSS_FLEX_DIRECTION_COLUMN_REVERSE,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW,</span><br><span class="line">  CSS_FLEX_DIRECTION_ROW_REVERSE</span><br><span class="line">&#125; <span class="keyword">css_flex_direction_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是Flex的方向。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-74e4b1f77d6fa40d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是COLUMN。布局的走向是从上往下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d34a0fea4404545e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是COLUMN_REVERSE。布局的走向是从下往上。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-8a6e7643a60e2906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ROW。布局的走向是从左往右。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-569f2a299797e27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ROW_REVERSE。布局的走向是从右往左。</p>
<p>这里可以看出来，在LTR的上下文中，ROW_REVERSE即等于RTL的上下文中的ROW。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_JUSTIFY_FLEX_START = <span class="number">0</span>,</span><br><span class="line">  CSS_JUSTIFY_CENTER,</span><br><span class="line">  CSS_JUSTIFY_FLEX_END,</span><br><span class="line">  CSS_JUSTIFY_SPACE_BETWEEN,</span><br><span class="line">  CSS_JUSTIFY_SPACE_AROUND</span><br><span class="line">&#125; <span class="keyword">css_justify_t</span>;</span><br></pre></td></tr></table></figure>
<p>这是定义的子视图在主轴上的排列方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7dd84c06eabd1ddd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d86b61dabc5a97fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-945bde67f5931fcf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-3823fed50bd98895.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_SPACE_BETWEEN</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5c514b364e470dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是JUSTIFY_SPACE_AROUND。这种方式是每个视图的左右都保持着一定的宽度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_ALIGN_AUTO = <span class="number">0</span>,</span><br><span class="line">  CSS_ALIGN_FLEX_START,</span><br><span class="line">  CSS_ALIGN_CENTER,</span><br><span class="line">  CSS_ALIGN_FLEX_END,</span><br><span class="line">  CSS_ALIGN_STRETCH</span><br><span class="line">&#125; <span class="keyword">css_align_t</span>;</span><br></pre></td></tr></table></figure>
<p>这是定义的子视图在侧轴上的对齐方式。</p>
<p>在Weex这里定义了三种属于css_align_t类型的方式，align_content，align_items，align_self。这三种类型的对齐方式略有不同。</p>
<p>ALIGN_AUTO只是针对align_self的一个默认值，但是对于align_content，align_items子视图的对齐方式是无效的值。</p>
<h4 id="1-align-items"><a href="#1-align-items" class="headerlink" title="1.align_items"></a>1.align_items</h4><p>align_items定义的是子视图在一行里面侧轴上排列的方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-e756eec5a022f74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-5e200b8d742b01a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-ceab624ccd23e978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7bb4781738e20528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_STRETCH</p>
<p>align_items在W3C的定义里面其实还有一个种baseline的对齐方式，这里在定义里面并没有。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-10e077f6a05f4fe8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>注意，上面这种baseline的对齐方式在Weex的定义里面并没有！</p>
<h4 id="2-align-content"><a href="#2-align-content" class="headerlink" title="2. align_content"></a>2. align_content</h4><p><strong>align_content定义的是子视图行与行之间在侧轴上排列的方式。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c4e6c4930823f326.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_START</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-3425b3876c3d665b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_CENTER</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c5358bd9b76e9aac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_FLEX_END</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6a98ea3472c5b20c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是ALIGN_STRETCH</p>
<p>在FlexBox的W3C的定义里面其实还有两种方式在Weex没有定义。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-b5b1500aa720593a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_AROUND，align-content里面的space-around这种对齐方式在Weex是没有的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-77e9ab8a8268646f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图的这种对齐方式是对应的justify里面的JUSTIFY_SPACE_BETWEEN，align-content里面的space-between这种对齐方式在Weex是没有的。</p>
<h4 id="3-align-self"><a href="#3-align-self" class="headerlink" title="3.align_self"></a>3.align_self</h4><p>最后这一种对齐方式是可以在align_items的基础上再分别自定义每个子视图的对齐方式。如果是auto，是与align_items方式相同。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-964d7fb4451fb0b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_POSITION_RELATIVE = <span class="number">0</span>,</span><br><span class="line">  CSS_POSITION_ABSOLUTE</span><br><span class="line">&#125; <span class="keyword">css_position_type_t</span>;</span><br></pre></td></tr></table></figure>
<p>这个是定义坐标地址的类型，有相对坐标和绝对坐标两种。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_NOWRAP = <span class="number">0</span>,</span><br><span class="line">  CSS_WRAP</span><br><span class="line">&#125; <span class="keyword">css_wrap_type_t</span>;</span><br></pre></td></tr></table></figure>
<p>在Weex里面wrap只有两种类型。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d982430a883bd70e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是NOWRAP。所有的子视图都会排列在一行之中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-40c4c59a6237ebbb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是WRAP。所有的子视图会从左到右，从上到下排列。</p>
<p>在W3C的标准里面还有一种wrap_reverse的排列方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-40d7272e17d5b429.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这种排列方式，是从左到右，从下到上进行排列，目前在Weex里面没有定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_LEFT = <span class="number">0</span>,</span><br><span class="line">  CSS_TOP,</span><br><span class="line">  CSS_RIGHT,</span><br><span class="line">  CSS_BOTTOM,</span><br><span class="line">  CSS_START,</span><br><span class="line">  CSS_END,</span><br><span class="line">  CSS_POSITION_COUNT</span><br><span class="line">&#125; <span class="keyword">css_position_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是坐标的描述。Left和Top因为会出现在position[2] 和 position[4]中，所以它们两个排列在Right和Bottom前面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_MEASURE_MODE_UNDEFINED = <span class="number">0</span>,</span><br><span class="line">  CSS_MEASURE_MODE_EXACTLY,</span><br><span class="line">  CSS_MEASURE_MODE_AT_MOST</span><br><span class="line">&#125; <span class="keyword">css_measure_mode_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是计算的方式，一种是精确计算，另外一种是估算近视值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  CSS_WIDTH = <span class="number">0</span>,</span><br><span class="line">  CSS_HEIGHT</span><br><span class="line">&#125; <span class="keyword">css_dimension_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义的是子视图的尺寸，宽和高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缓存一些信息防止每次Layout过程都要重复计算</span></span><br><span class="line">  <span class="keyword">bool</span> should_update;</span><br><span class="line">  <span class="keyword">float</span> last_requested_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_width;</span><br><span class="line">  <span class="keyword">float</span> last_parent_max_height;</span><br><span class="line">  <span class="keyword">float</span> last_dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">float</span> last_position[<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">css_direction_t</span> last_direction;</span><br><span class="line">&#125; <span class="keyword">css_layout_t</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个css_layout_t结构体。结构体里面position和dimensions数组里面分别存储的是四周的位置和宽高的尺寸。direction里面存储的就是LTR还是RTL的方向。</p>
<p>至于下面那些变量信息都是缓存，用来防止没有改变的Lauout还会重复计算的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_dim_t</span>;</span><br></pre></td></tr></table></figure>
<p>css_dim_t结构体里面装的就是子视图的尺寸信息，宽和高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// 整个页面CSS的方向，LTR、RTL</span></span><br><span class="line">  <span class="keyword">css_direction_t</span> direction;</span><br><span class="line">  <span class="comment">// Flex 的方向</span></span><br><span class="line">  <span class="keyword">css_flex_direction_t</span> flex_direction;</span><br><span class="line">  <span class="comment">// 子视图在主轴上的排列对齐方式</span></span><br><span class="line">  <span class="keyword">css_justify_t</span> justify_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上行与行之间的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_content;</span><br><span class="line">  <span class="comment">// 子视图在侧轴上的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_items;</span><br><span class="line">  <span class="comment">// 子视图自己本身的对齐方式</span></span><br><span class="line">  <span class="keyword">css_align_t</span> align_self;</span><br><span class="line">  <span class="comment">// 子视图的坐标系类型(相对坐标系，绝对坐标系)</span></span><br><span class="line">  <span class="keyword">css_position_type_t</span> position_type;</span><br><span class="line">  <span class="comment">// wrap类型</span></span><br><span class="line">  <span class="keyword">css_wrap_type_t</span> flex_wrap;</span><br><span class="line">  <span class="keyword">float</span> flex;</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> margin[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右</span></span><br><span class="line">  <span class="keyword">float</span> position[<span class="number">4</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> padding[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 上，下，左，右，start，end</span></span><br><span class="line">  <span class="keyword">float</span> border[<span class="number">6</span>];</span><br><span class="line">  <span class="comment">// 宽，高</span></span><br><span class="line">  <span class="keyword">float</span> dimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最小的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> minDimensions[<span class="number">2</span>];</span><br><span class="line">  <span class="comment">// 最大的宽和高</span></span><br><span class="line">  <span class="keyword">float</span> maxDimensions[<span class="number">2</span>];</span><br><span class="line">&#125; <span class="keyword">css_style_t</span>;</span><br></pre></td></tr></table></figure>
<p>css_style_t记录了整个style的所有信息。每个变量的意义见上面注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> <span class="title">css_node_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">css_node</span> &#123;</span></span><br><span class="line">  <span class="keyword">css_style_t</span> style;</span><br><span class="line">  <span class="keyword">css_layout_t</span> layout;</span><br><span class="line">  <span class="keyword">int</span> children_count;</span><br><span class="line">  <span class="keyword">int</span> line_index;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_node_t</span> *next_absolute_child;</span><br><span class="line">  <span class="keyword">css_node_t</span> *next_flex_child;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_dim_t</span> (*measure)(<span class="keyword">void</span> *context, <span class="keyword">float</span> width, <span class="keyword">css_measure_mode_t</span> widthMode, <span class="keyword">float</span> height, <span class="keyword">css_measure_mode_t</span> heightMode);</span><br><span class="line">  <span class="keyword">void</span> (*print)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">css_node</span>* (*<span class="title">get_child</span>)(<span class="title">void</span> *<span class="title">context</span>, <span class="title">int</span> <span class="title">i</span>);</span></span><br><span class="line">  <span class="keyword">bool</span> (*is_dirty)(<span class="keyword">void</span> *context);</span><br><span class="line">  <span class="keyword">void</span> *context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>css_node定义的是FlexBox的一个节点的数据结构。它包含了之前的css_style_t和css_layout_t。由于结构体里面无法定义成员函数，所以下面包含4个函数指针。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-9192b10f6607271c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">css_node_t</span> *new_css_node(<span class="keyword">void</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上面3个函数是关于css_node的生命周期相关的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="keyword">css_node_t</span> *new_css_node() &#123;</span><br><span class="line">  <span class="keyword">css_node_t</span> *node = (<span class="keyword">css_node_t</span> *)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*node));</span><br><span class="line">  init_css_node(node);</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">free</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建节点的时候就是调用的init_css_node方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_css_node</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;style.align_items = CSS_ALIGN_STRETCH;</span><br><span class="line">  node-&gt;style.align_content = CSS_ALIGN_FLEX_START;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.direction = CSS_DIRECTION_INHERIT;</span><br><span class="line">  node-&gt;style.flex_direction = CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意下面这些数组里面的值初始化为undefined，而不是0</span></span><br><span class="line">  node-&gt;style.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.minDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.minDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.maxDimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.maxDimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.position[CSS_LEFT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_TOP] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_RIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.position[CSS_BOTTOM] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;style.margin[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.margin[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.padding[CSS_END] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_START] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;style.border[CSS_END] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下这些用来对比是否发生变化的缓存变量，初始值都为 -1。</span></span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_WIDTH] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_requested_dimensions[CSS_HEIGHT] = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_width = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_parent_max_height = <span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.last_direction = (<span class="keyword">css_direction_t</span>)<span class="number">-1</span>;</span><br><span class="line">  node-&gt;layout.should_update = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>css_node的初始化的align_items是ALIGN_STRETCH，align_content是ALIGN_FLEX_START，direction是继承自父类，flex_direction是按照列排列的。</p>
<p>接着下面数组里面存的都是UNDEFINED，而不是0，因为0会和结构体里面的0冲突。</p>
<p>最后缓存的变量初始化都为-1。</p>
<p>接下来定义了4个全局的数组，这4个数组非常有用，它会决定接下来layout的方向和属性。4个数组和轴的方向是相互关联的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> leading[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的leading就是CSS_TOP，方向如果是COLUMN_REVERSE，那么子视图的leading就是CSS_BOTTOM；如果主轴在ROW水平方向，那么子视图的leading就是CSS_LEFT，方向如果是ROW_REVERSE，那么子视图的leading就是CSS_RIGHT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> trailing[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_RIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_LEFT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的trailing就是CSS_BOTTOM，方向如果是COLUMN_REVERSE，那么子视图的trailing就是CSS_TOP；如果主轴在ROW水平方向，那么子视图的trailing就是CSS_RIGHT，方向如果是ROW_REVERSE，那么子视图的trailing就是CSS_LEFT。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_position_t</span> pos[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_TOP,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_BOTTOM,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_LEFT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_RIGHT</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图的position就是以CSS_TOP开始的，方向如果是COLUMN_REVERSE，那么子视图的position就是以CSS_BOTTOM开始的；如果主轴在ROW水平方向，那么子视图的position就是以CSS_LEFT开始的，方向如果是ROW_REVERSE，那么子视图的position就是以CSS_RIGHT开始的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">css_dimension_t</span> dim[<span class="number">4</span>] = &#123;</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_COLUMN_REVERSE = */</span> CSS_HEIGHT,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW = */</span> CSS_WIDTH,</span><br><span class="line">  <span class="comment">/* CSS_FLEX_DIRECTION_ROW_REVERSE = */</span> CSS_WIDTH</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果主轴在COLUMN垂直方向，那么子视图在这个方向上的尺寸就是CSS_HEIGHT，方向如果是COLUMN_REVERSE，那么子视图在这个方向上的尺寸也是CSS_HEIGHT；如果主轴在ROW水平方向，那么子视图在这个方向上的尺寸就是CSS_WIDTH，方向如果是ROW_REVERSE，那么子视图在这个方向上的尺寸是CSS_WIDTH。</p>
<h4 id="（二）FlexBox中的布局算法"><a href="#（二）FlexBox中的布局算法" class="headerlink" title="（二）FlexBox中的布局算法"></a>（二）FlexBox中的布局算法</h4><p>Weex 盒模型基于 <a href="https://www.w3.org/TR/css3-box/" rel="external nofollow noopener noreferrer" target="_blank">CSS 盒模型</a>，每个 Weex 元素都可视作一个盒子。我们一般在讨论设计或布局时，会提到「盒模型」这个概念。</p>
<p>盒模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界 margin edge, 边框边界 border edge, 内边距边界 padding edge 与内容边界 content edge。这四层边界，形成一层层的盒子包裹起来，这就是盒模型大体上的含义。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2968e2f04c41c140.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>盒子模型如上，这个图是基于LTR，并且主轴在水平方向的。</p>
<p>所以主轴在不同方向可能就会有不同的情况。</p>
<blockquote>
<p>注意：<br>Weex 盒模型的 box-sizing 默认为 border-box，即盒子的宽高包含内容content、内边距padding和边框的宽度border，不包含外边距的宽度margin。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是水平方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isRowDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_ROW ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_ROW_REVERSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断轴是否是垂直方向</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">isColumnDirection</span><span class="params">(<span class="keyword">css_flex_direction_t</span> flex_direction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flex_direction == CSS_FLEX_DIRECTION_COLUMN ||</span><br><span class="line">         flex_direction == CSS_FLEX_DIRECTION_COLUMN_REVERSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断轴的方向的方向就是上面这两个。</p>
<p>然后接着还要计算4个方向上的padding、border、margin。这里就举一个方向的例子。</p>
<p>首先如何计算Margin的呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_START])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[leading[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断轴的方向是不是水平方向，如果是水平方向就直接取node的margin里面的CSS_START即是LeadingMargin，如果是竖直方向，就取出在竖直轴上面的leading方向的margin的值。</p>
<p>如果取TrailingMargin那么就取margin[CSS_END]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getTrailingMargin</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp; !isUndefined(node-&gt;style.margin[CSS_END])) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.margin[CSS_END];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> node-&gt;style.margin[trailing[axis]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下padding、border、margin三个值的数组存储有6个值，如果是水平方向，那么CSS_START存储的都是Leading，CSS_END存储的都是Trailing。下面没有特殊说明，都按照这个规则来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingPadding</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.padding[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.padding[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.padding[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.padding[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取Padding的思路也和取Margin的思路一样，水平方向就是取出数组里面的padding[CSS_START]，如果是竖直方向，就对应得取出padding[leading[axis]]的值即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getLeadingBorder</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">css_flex_direction_t</span> axis)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isRowDirection(axis) &amp;&amp;</span><br><span class="line">      !isUndefined(node-&gt;style.border[CSS_START]) &amp;&amp;</span><br><span class="line">      node-&gt;style.border[CSS_START] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[CSS_START];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node-&gt;style.border[leading[axis]] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;style.border[leading[axis]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这是Border的计算方法，和上述Padding，Margin一模一样，这里就不再赘述了。</p>
<p>四周边距的计算方法都实现了，接下来就是如何layout了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 计算布局的方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> maxWidth, <span class="keyword">float</span> maxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在调用layoutNode之前，可以重置node节点的layout</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span></span>;</span><br></pre></td></tr></table></figure>
<p>重置node节点的方法就是把节点的坐标重置为0，然后把宽和高都重置为UNDEFINED。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetNodeLayout</span><span class="params">(<span class="keyword">css_node_t</span> *node)</span> </span>&#123;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_WIDTH] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.dimensions[CSS_HEIGHT] = CSS_UNDEFINED;</span><br><span class="line">  node-&gt;layout.position[CSS_LEFT] = <span class="number">0</span>;</span><br><span class="line">  node-&gt;layout.position[CSS_TOP] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，布局方法就是如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutNode</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">css_layout_t</span> *layout = &amp;node-&gt;layout;</span><br><span class="line">  <span class="keyword">css_direction_t</span> direction = node-&gt;style.direction;</span><br><span class="line">  layout-&gt;should_update = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对比当前环境是否“干净”，以及比较待布局的node节点和上次节点是否完全一致。</span></span><br><span class="line">  <span class="keyword">bool</span> skipLayout =</span><br><span class="line">    !node-&gt;is_dirty(node-&gt;context) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_WIDTH], layout-&gt;dimensions[CSS_WIDTH]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_requested_dimensions[CSS_HEIGHT], layout-&gt;dimensions[CSS_HEIGHT]) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_width, parentMaxWidth) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_parent_max_height, parentMaxHeight) &amp;&amp;</span><br><span class="line">    eq(layout-&gt;last_direction, direction);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (skipLayout) &#123;</span><br><span class="line">    <span class="comment">// 把缓存的值直接赋值给当前的layout</span></span><br><span class="line">    layout-&gt;dimensions[CSS_WIDTH] = layout-&gt;last_dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;dimensions[CSS_HEIGHT] = layout-&gt;last_dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;position[CSS_TOP] = layout-&gt;last_position[CSS_TOP];</span><br><span class="line">    layout-&gt;position[CSS_LEFT] = layout-&gt;last_position[CSS_LEFT];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 缓存node节点</span></span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_requested_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_parent_max_width = parentMaxWidth;</span><br><span class="line">    layout-&gt;last_parent_max_height = parentMaxHeight;</span><br><span class="line">    layout-&gt;last_direction = direction;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化所有子视图node的尺寸和位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, childCount = node-&gt;children_count; i &lt; childCount; i++) &#123;</span><br><span class="line">      resetNodeLayout(node-&gt;get_child(node-&gt;context, i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局视图的核心实现</span></span><br><span class="line">    layoutNodeImpl(node, parentMaxWidth, parentMaxHeight, parentDirection);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局完成，把此次的布局缓存起来，防止下次重复的布局重复计算</span></span><br><span class="line">    layout-&gt;last_dimensions[CSS_WIDTH] = layout-&gt;dimensions[CSS_WIDTH];</span><br><span class="line">    layout-&gt;last_dimensions[CSS_HEIGHT] = layout-&gt;dimensions[CSS_HEIGHT];</span><br><span class="line">    layout-&gt;last_position[CSS_TOP] = layout-&gt;position[CSS_TOP];</span><br><span class="line">    layout-&gt;last_position[CSS_LEFT] = layout-&gt;position[CSS_LEFT];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每步都注释了，见上述代码注释，在调用布局的核心实现layoutNodeImpl之前，会循环调用resetNodeLayout，初始化所有子视图。</p>
<p>所有的核心实现就在layoutNodeImpl这个方法里面了。Weex里面的这个方法实现有700多行，在Yoga的实现中，布局算法有1000多行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">layoutNodeImpl</span><span class="params">(<span class="keyword">css_node_t</span> *node, <span class="keyword">float</span> parentMaxWidth, <span class="keyword">float</span> parentMaxHeight, <span class="keyword">css_direction_t</span> parentDirection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里分析一下这个算法的主要流程。在Weex的这个实现中，有7个循环，假设依次分别标上A，B，C，D，E，F，G。</p>
<p>先来看循环A</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainContentDim = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 存在3类子视图，支持flex的子视图，不支持flex的子视图，绝对布局的子视图，我们需要知道哪些子视图是在等待分配空间。</span></span><br><span class="line"><span class="keyword">int</span> flexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> totalFlexible = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nonFlexibleChildrenCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在主轴上简单的堆叠子视图，在循环C中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackMain =</span><br><span class="line">    (isMainDimDefined &amp;&amp; justifyContent == CSS_JUSTIFY_FLEX_START) ||</span><br><span class="line">    (!isMainDimDefined &amp;&amp; justifyContent != CSS_JUSTIFY_CENTER);</span><br><span class="line"><span class="keyword">int</span> firstComplexMain = (isSimpleStackMain ? childCount : startLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一层循环在侧轴上简单的堆叠子视图，在循环D中，会忽略这些已经在循环A中已经排列好的子视图</span></span><br><span class="line"><span class="keyword">bool</span> isSimpleStackCross = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> firstComplexCross = childCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">css_node_t</span>* firstFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">css_node_t</span>* currentFlexChild = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> mainDim = leadingPaddingAndBorderMain;</span><br><span class="line"><span class="keyword">float</span> crossDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> maxWidth = CSS_UNDEFINED;</span><br><span class="line"><span class="keyword">float</span> maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环A从这里开始</span></span><br><span class="line"><span class="keyword">for</span> (i = startLine; i &lt; childCount; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line">  child-&gt;line_index = linesCount;</span><br><span class="line"></span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">  child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在递归layout之前，先预填充侧轴上可以被拉伸的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH &amp;&amp;</span><br><span class="line">      child-&gt;style.position_type == CSS_POSITION_RELATIVE &amp;&amp;</span><br><span class="line">      isCrossDimDefined &amp;&amp;</span><br><span class="line">      !isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 这里要进行一个比较，比较子视图在侧轴上的尺寸 和 侧轴上减去两边的Margin、padding、Border剩下的可拉伸的空间 进行比较，因为拉伸是不会压缩原始的大小的。</span></span><br><span class="line">    child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">      boundAxis(child, crossAxis, node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">        paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">      getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE) &#123;</span><br><span class="line">    <span class="comment">// 这里会储存一个绝对布局子视图的链表。这样我们在后面布局的时候可以快速的跳过它们。</span></span><br><span class="line">    <span class="keyword">if</span> (firstAbsoluteChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      firstAbsoluteChild = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      currentAbsoluteChild-&gt;next_absolute_child = child;</span><br><span class="line">    &#125;</span><br><span class="line">    currentAbsoluteChild = child;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预填充子视图，这里需要用到视图在轴上面的绝对坐标，如果是水平轴，需要用到左右的偏移量，如果是竖直轴，需要用到上下的偏移量。</span></span><br><span class="line">    <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">      axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">          !isStyleDimDefined(child, axis) &amp;&amp;</span><br><span class="line">          isPosDefined(child, leading[axis]) &amp;&amp;</span><br><span class="line">          isPosDefined(child, trailing[axis])) &#123;</span><br><span class="line">        child-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">          <span class="comment">// 这里是绝对布局，还需要减去leading和trailing</span></span><br><span class="line">          boundAxis(child, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">            getPaddingAndBorderAxis(node, axis) -</span><br><span class="line">            getMarginAxis(child, axis) -</span><br><span class="line">            getPosition(child, leading[axis]) -</span><br><span class="line">            getPosition(child, trailing[axis])),</span><br><span class="line">          getPaddingAndBorderAxis(child, axis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>循环A的具体实现如上，注释见代码。<br>循环A主要是实现的是layout布局中不可以flex的子视图的布局，mainContentDim变量是用来记录所有的尺寸以及所有不能flex的子视图的margin的总和。它被用来设置node节点的尺寸，和计算剩余空间以便供可flex子视图进行拉伸适配。</p>
<p>每个node节点的next_absolute_child维护了一个链表，这里存储的依次是绝对布局视图的链表。</p>
<p>接着需要再统计可以被拉伸的子视图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">float</span> nextContentDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计可以拉伸flex的子视图</span></span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined &amp;&amp; isFlex(child)) &#123;</span><br><span class="line">  flexibleChildrenCount++;</span><br><span class="line">  totalFlexible += child-&gt;style.flex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储一个链表维护可以flex的子视图</span></span><br><span class="line">  <span class="keyword">if</span> (firstFlexChild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    firstFlexChild = child;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    currentFlexChild-&gt;next_flex_child = child;</span><br><span class="line">  &#125;</span><br><span class="line">  currentFlexChild = child;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这时我们虽然不知道确切的尺寸信息，但是已经知道了padding , border , margin，我们可以利用这些信息来给子视图确定一个最小的size，计算剩余可用的空间。</span></span><br><span class="line">  <span class="comment">// 下一个content的距离等于当前子视图Leading和Trailing的padding , border , margin6个尺寸之和。</span></span><br><span class="line">  nextContentDim = getPaddingAndBorderAxis(child, mainAxis) +</span><br><span class="line">    getMarginAxis(child, mainAxis);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  maxWidth = CSS_UNDEFINED;</span><br><span class="line">  maxHeight = CSS_UNDEFINED;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 计算出最大宽度和最大高度</span></span><br><span class="line">  <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">          paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归调用layout函数，进行不能拉伸的子视图的布局。</span></span><br><span class="line">  <span class="keyword">if</span> (alreadyComputedNextLayout == <span class="number">0</span>) &#123;</span><br><span class="line">    layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 由于绝对布局的子视图的位置和layout无关，所以我们不能用它们来计算mainContentDim</span></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">    nonFlexibleChildrenCount++;</span><br><span class="line">    nextContentDim = getDimWithMargin(child, mainAxis);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就确定出了不可拉伸的子视图的布局。</p>
<p>每个node节点的next_flex_child维护了一个链表，这里存储的依次是可以flex拉伸视图的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      <span class="comment">// 将要加入的元素可能会被挤到下一行</span></span><br><span class="line">      <span class="keyword">if</span> (isNodeFlexWrap &amp;&amp;</span><br><span class="line">          isMainDimDefined &amp;&amp;</span><br><span class="line">          mainContentDim + nextContentDim &gt; definedMainDim &amp;&amp;</span><br><span class="line">          <span class="comment">// 如果这里只有一个元素，它可能就需要单独占一行</span></span><br><span class="line">          i != startLine) &#123;</span><br><span class="line">        nonFlexibleChildrenCount--;</span><br><span class="line">        alreadyComputedNextLayout = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在主轴上堆叠子视图，剩余的子视图都在循环C里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE || isFlex(child))) &#123;</span><br><span class="line">        isSimpleStackMain = <span class="literal">false</span>;</span><br><span class="line">        firstComplexMain = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止在侧轴上堆叠子视图，剩余的子视图都在循环D里面布局</span></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross &amp;&amp;</span><br><span class="line">          (child-&gt;style.position_type != CSS_POSITION_RELATIVE ||</span><br><span class="line">              (alignItem != CSS_ALIGN_STRETCH &amp;&amp; alignItem != CSS_ALIGN_FLEX_START) ||</span><br><span class="line">              (alignItem == CSS_ALIGN_STRETCH &amp;&amp; !isCrossDimDefined))) &#123;</span><br><span class="line">        isSimpleStackCross = <span class="literal">false</span>;</span><br><span class="line">        firstComplexCross = i;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackMain) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line">        <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图主轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, mainAxis);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以算出了主轴上的尺寸了</span></span><br><span class="line">        mainDim += getDimWithMargin(child, mainAxis);</span><br><span class="line">        <span class="comment">// 可以算出侧轴上的尺寸了</span></span><br><span class="line">        crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isSimpleStackCross) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingPaddingAndBorderCross;</span><br><span class="line">        <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        <span class="comment">// 设置子视图侧轴上的TrailingPosition</span></span><br><span class="line">          setTrailingPosition(node, child, crossAxis);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      alreadyComputedNextLayout = <span class="number">0</span>;</span><br><span class="line">      mainContentDim += nextContentDim;</span><br><span class="line">      endLine = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 循环A 至此结束</span></span><br></pre></td></tr></table></figure>
<p>循环A结束以后，会计算出endLine，计算出主轴上的尺寸，侧轴上的尺寸。不可拉伸的子视图的布局也会被确定。</p>
<p>接下来进入循环B的阶段。</p>
<p>循环B主要分为2个部分，第一个部分是用来布局可拉伸的子视图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 为了在主轴上布局，需要控制两个space，一个是第一个子视图和最左边的距离，另一个是两个子视图之间的距离</span></span><br><span class="line"><span class="keyword">float</span> leadingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">float</span> betweenMainDim = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录剩余的可用空间</span></span><br><span class="line"><span class="keyword">float</span> remainingMainDim = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">  remainingMainDim = definedMainDim - mainContentDim;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  remainingMainDim = fmaxf(mainContentDim, <span class="number">0</span>) - mainContentDim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前还有可拉伸的子视图，它们就要填充剩余的可用空间</span></span><br><span class="line"><span class="keyword">if</span> (flexibleChildrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">float</span> flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line">  <span class="keyword">float</span> baseMainDim;</span><br><span class="line">  <span class="keyword">float</span> boundMainDim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果剩余的空间不能提供给可拉伸的子视图，不能满足它们的最大或者最小的bounds，那么这些子视图也要排除到计算拉伸的过程之外</span></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    baseMainDim = flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">        getPaddingAndBorderAxis(currentFlexChild, mainAxis);</span><br><span class="line">    boundMainDim = boundAxis(currentFlexChild, mainAxis, baseMainDim);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseMainDim != boundMainDim) &#123;</span><br><span class="line">      remainingMainDim -= boundMainDim;</span><br><span class="line">      totalFlexible -= currentFlexChild-&gt;style.flex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">  &#125;</span><br><span class="line">  flexibleMainDim = remainingMainDim / totalFlexible;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不可以拉伸的子视图可以在父视图内部overflow，在这种情况下，假设没有可用的拉伸space</span></span><br><span class="line">  <span class="keyword">if</span> (flexibleMainDim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    flexibleMainDim = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentFlexChild = firstFlexChild;</span><br><span class="line">  <span class="keyword">while</span> (currentFlexChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 在这层循环里面我们已经可以确认子视图的最终大小了</span></span><br><span class="line">    currentFlexChild-&gt;layout.dimensions[dim[mainAxis]] = boundAxis(currentFlexChild, mainAxis,</span><br><span class="line">      flexibleMainDim * currentFlexChild-&gt;style.flex +</span><br><span class="line">          getPaddingAndBorderAxis(currentFlexChild, mainAxis)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算水平方向轴上子视图的最大宽度</span></span><br><span class="line">    maxWidth = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, resolvedRowAxis)) &#123;</span><br><span class="line">      maxWidth = node-&gt;layout.dimensions[dim[resolvedRowAxis]] -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isMainRowDirection) &#123;</span><br><span class="line">      maxWidth = parentMaxWidth -</span><br><span class="line">        getMarginAxis(node, resolvedRowAxis) -</span><br><span class="line">        paddingAndBorderAxisResolvedRow;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算垂直方向轴上子视图的最大高度</span></span><br><span class="line">    maxHeight = CSS_UNDEFINED;</span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, CSS_FLEX_DIRECTION_COLUMN)) &#123;</span><br><span class="line">      maxHeight = node-&gt;layout.dimensions[dim[CSS_FLEX_DIRECTION_COLUMN]] -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isMainRowDirection) &#123;</span><br><span class="line">      maxHeight = parentMaxHeight -</span><br><span class="line">        getMarginAxis(node, CSS_FLEX_DIRECTION_COLUMN) -</span><br><span class="line">        paddingAndBorderAxisColumn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次递归完成可拉伸的子视图的布局</span></span><br><span class="line">    layoutNode(currentFlexChild, maxWidth, maxHeight, direction);</span><br><span class="line"></span><br><span class="line">    child = currentFlexChild;</span><br><span class="line">    currentFlexChild = currentFlexChild-&gt;next_flex_child;</span><br><span class="line">    child-&gt;next_flex_child = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述2个while结束以后，所有可以被拉伸的子视图就都布局完成了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (justifyContent != CSS_JUSTIFY_FLEX_START) &#123;</span><br><span class="line">     <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_CENTER) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_FLEX_END) &#123;</span><br><span class="line">       leadingMainDim = remainingMainDim;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_BETWEEN) &#123;</span><br><span class="line">       remainingMainDim = fmaxf(remainingMainDim, <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span> != <span class="number">0</span>) &#123;</span><br><span class="line">         betweenMainDim = remainingMainDim /</span><br><span class="line">           (flexibleChildrenCount + nonFlexibleChildrenCount - <span class="number">1</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         betweenMainDim = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (justifyContent == CSS_JUSTIFY_SPACE_AROUND) &#123;</span><br><span class="line">       <span class="comment">// 这里是实现SPACE_AROUND的代码</span></span><br><span class="line">       betweenMainDim = remainingMainDim /</span><br><span class="line">         (flexibleChildrenCount + nonFlexibleChildrenCount);</span><br><span class="line">       leadingMainDim = betweenMainDim / <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可flex拉伸的视图布局完成以后，这里是收尾工作，根据justifyContent，更改betweenMainDim和leadingMainDim的大小。</p>
<p>接着再是循环C。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在这个循环中，所有子视图的宽和高都将被确定下来。在确定各个子视图的坐标的时候，同时也将确定父视图的宽和高。</span></span><br><span class="line">mainDim += leadingMainDim;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照Line，一层层的循环</span></span><br><span class="line"><span class="keyword">for</span> (i = firstComplexMain; i &lt; endLine; ++i) &#123;</span><br><span class="line">  child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">      isPosDefined(child, leading[mainAxis])) &#123;</span><br><span class="line">    <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，左边距和上边距已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] = getPosition(child, leading[mainAxis]) +</span><br><span class="line">      getLeadingBorder(node, mainAxis) +</span><br><span class="line">      getLeadingMargin(child, mainAxis);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果子视图不是绝对坐标，坐标是相对的，或者还没有确定下来左边距和上边距，那么就根据当前位置确定坐标</span></span><br><span class="line">    child-&gt;layout.position[pos[mainAxis]] += mainDim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定trailing的坐标位置</span></span><br><span class="line">    <span class="keyword">if</span> (isMainDimDefined) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来开始处理相对坐标的子视图，具有绝对坐标的子视图不会参与下述的布局计算中</span></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">      <span class="comment">// 主轴上的宽度是由所有的子视图的宽度累加而成</span></span><br><span class="line">      mainDim += betweenMainDim + getDimWithMargin(child, mainAxis);</span><br><span class="line">      <span class="comment">// 侧轴的高度是由最高的子视图决定的</span></span><br><span class="line">      crossDim = fmaxf(crossDim, boundAxis(child, crossAxis, getDimWithMargin(child, crossAxis)));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> containerCrossAxis = node-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  containerCrossAxis = fmaxf(</span><br><span class="line">    <span class="comment">// 计算父视图的时候需要加上，上下的padding和Border。</span></span><br><span class="line">    boundAxis(node, crossAxis, crossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在循环C中，会在主轴上计算出所有子视图的坐标，包括各个子视图的宽和高。</p>
<p>接下来就到循环D的流程了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = firstComplexCross; i &lt; endLine; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_ABSOLUTE &amp;&amp;</span><br><span class="line">        isPosDefined(child, leading[crossAxis])) &#123;</span><br><span class="line">      <span class="comment">// 到这里，绝对坐标的子视图的坐标已经确定下来了，上下左右至少有一边的坐标已经被定下来了。这时子视图的绝对坐标可以确定了。</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] = getPosition(child, leading[crossAxis]) +</span><br><span class="line">        getLeadingBorder(node, crossAxis) +</span><br><span class="line">        getLeadingMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">float</span> leadingCrossDim = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在侧轴上，针对相对坐标的子视图，我们利用父视图的alignItems或者子视图的alignSelf来确定具体的坐标位置</span></span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type == CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="comment">// 获取子视图的AlignItem属性值</span></span><br><span class="line">        <span class="keyword">css_align_t</span> alignItem = getAlignItem(node, child);</span><br><span class="line">        <span class="keyword">if</span> (alignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">          <span class="comment">// 如果在侧轴上子视图还没有确定尺寸，那么才会相应STRETCH拉伸。</span></span><br><span class="line">          <span class="keyword">if</span> (!isStyleDimDefined(child, crossAxis)) &#123;</span><br><span class="line">            <span class="keyword">float</span> dimCrossAxis = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">            child-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">              boundAxis(child, crossAxis, containerCrossAxis -</span><br><span class="line">                paddingAndBorderAxisCross - getMarginAxis(child, crossAxis)),</span><br><span class="line">              getPaddingAndBorderAxis(child, crossAxis)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果视图的大小变化了，连带该视图的子视图还需要再次layout</span></span><br><span class="line">            <span class="keyword">if</span> (dimCrossAxis != child-&gt;layout.dimensions[dim[crossAxis]] &amp;&amp; child-&gt;children_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// Reset child margins before re-layout as they are added back in layoutNode and would be doubled</span></span><br><span class="line">              child-&gt;layout.position[leading[mainAxis]] -= getLeadingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[mainAxis]] -= getTrailingMargin(child, mainAxis) +</span><br><span class="line">                getRelativePosition(child, mainAxis);</span><br><span class="line">              child-&gt;layout.position[leading[crossAxis]] -= getLeadingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line">              child-&gt;layout.position[trailing[crossAxis]] -= getTrailingMargin(child, crossAxis) +</span><br><span class="line">                getRelativePosition(child, crossAxis);</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 递归子视图的布局</span></span><br><span class="line">              layoutNode(child, maxWidth, maxHeight, direction);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignItem != CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">          <span class="comment">// 在侧轴上剩余的空间等于父视图在侧轴上的高度减去子视图的在侧轴上padding、Border、Margin以及高度</span></span><br><span class="line">          <span class="keyword">float</span> remainingCrossDim = containerCrossAxis -</span><br><span class="line">            paddingAndBorderAxisCross - getDimWithMargin(child, crossAxis);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (alignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">            leadingCrossDim += remainingCrossDim / <span class="number">2</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// CSS_ALIGN_FLEX_END</span></span><br><span class="line">            leadingCrossDim += remainingCrossDim;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定子视图在侧轴上的坐标位置</span></span><br><span class="line">      child-&gt;layout.position[pos[crossAxis]] += linesCrossDim + leadingCrossDim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 确定trailing的坐标</span></span><br><span class="line">      <span class="keyword">if</span> (isCrossDimDefined) &#123;</span><br><span class="line">        setTrailingPosition(node, child, crossAxis);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  linesCrossDim += crossDim;</span><br><span class="line">  linesMainDim = fmaxf(linesMainDim, mainDim);</span><br><span class="line">  linesCount += <span class="number">1</span>;</span><br><span class="line">  startLine = endLine;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的循环D中主要是在侧轴上计算子视图的坐标。如果视图发生了大小变化，还需要递归子视图，重新布局一次。</p>
<p>再接着是循环E</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (linesCount &gt; <span class="number">1</span> &amp;&amp; isCrossDimDefined) &#123;</span><br><span class="line">  <span class="keyword">float</span> nodeCrossAxisInnerSize = node-&gt;layout.dimensions[dim[crossAxis]] -</span><br><span class="line">      paddingAndBorderAxisCross;</span><br><span class="line">  <span class="keyword">float</span> remainingAlignContentDim = nodeCrossAxisInnerSize - linesCrossDim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> crossDimLead = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">float</span> currentLead = leadingPaddingAndBorderCross;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 布局alignContent</span></span><br><span class="line">  <span class="keyword">css_align_t</span> alignContent = node-&gt;style.align_content;</span><br><span class="line">  <span class="keyword">if</span> (alignContent == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">    currentLead += remainingAlignContentDim / <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContent == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nodeCrossAxisInnerSize &gt; linesCrossDim) &#123;</span><br><span class="line">      crossDimLead = (remainingAlignContentDim / linesCount);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> endIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; linesCount; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> startIndex = endIndex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算每一行的行高，行高根据lineHeight和子视图在侧轴上的高度加上下的Margin之和比较，取最大值</span></span><br><span class="line">    <span class="keyword">float</span> lineHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; childCount; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;line_index != i) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isLayoutDimDefined(child, crossAxis)) &#123;</span><br><span class="line">        lineHeight = fmaxf(</span><br><span class="line">          lineHeight,</span><br><span class="line">          child-&gt;layout.dimensions[dim[crossAxis]] + getMarginAxis(child, crossAxis)</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    endIndex = ii;</span><br><span class="line">    lineHeight += crossDimLead;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ii = startIndex; ii &lt; endIndex; ++ii) &#123;</span><br><span class="line">      child = node-&gt;get_child(node-&gt;context, ii);</span><br><span class="line">      <span class="keyword">if</span> (child-&gt;style.position_type != CSS_POSITION_RELATIVE) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 布局AlignItem</span></span><br><span class="line">      <span class="keyword">css_align_t</span> alignContentAlignItem = getAlignItem(node, child);</span><br><span class="line">      <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_START) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_FLEX_END) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + lineHeight - getTrailingMargin(child, crossAxis) - child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_CENTER) &#123;</span><br><span class="line">        <span class="keyword">float</span> childHeight = child-&gt;layout.dimensions[dim[crossAxis]];</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + (lineHeight - childHeight) / <span class="number">2</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (alignContentAlignItem == CSS_ALIGN_STRETCH) &#123;</span><br><span class="line">        child-&gt;layout.position[pos[crossAxis]] = currentLead + getLeadingMargin(child, crossAxis);</span><br><span class="line">        <span class="comment">// TODO(prenaux): Correctly set the height of items with undefined</span></span><br><span class="line">        <span class="comment">//                (auto) crossAxis dimension.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentLead += lineHeight;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行循环E有一个前提，就是，行数至少要超过一行，并且侧轴上有高度定义。满足了这个前提条件以后才会开始下面的align规则。</p>
<p>在循环E中会处理侧轴上的align拉伸规则。这里会布局alignContent和AlignItem。</p>
<p>这块代码实现的算法原理请参见<a href="http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm" rel="external nofollow noopener noreferrer" target="_blank">http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/#layout-algorithm</a> section 9.4部分。</p>
<p>至此可能还存在一些没有指定宽和高的视图，接下来将会做最后一次的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果某个视图没有被指定宽或者高，并且也没有被父视图设置宽和高，那么在这里通过子视图来设置宽和高</span></span><br><span class="line"><span class="keyword">if</span> (!isMainDimDefined) &#123;</span><br><span class="line">  <span class="comment">// 视图的宽度等于内部子视图的宽度加上Trailing的Padding、Border的宽度和主轴上Leading的Padding、Border+ Trailing的Padding、Border，两者取最大值。</span></span><br><span class="line">  node-&gt;layout.dimensions[dim[mainAxis]] = fmaxf(</span><br><span class="line">    boundAxis(node, mainAxis, linesMainDim + getTrailingPaddingAndBorder(node, mainAxis)),</span><br><span class="line">    paddingAndBorderAxisMain</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mainAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      mainAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsMainTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isCrossDimDefined) &#123;</span><br><span class="line">  node-&gt;layout.dimensions[dim[crossAxis]] = fmaxf(</span><br><span class="line">    <span class="comment">// 视图的高度等于内部子视图的高度加上上下的Padding、Border的宽度和侧轴上Padding、Border，两者取最大值。</span></span><br><span class="line">    boundAxis(node, crossAxis, linesCrossDim + paddingAndBorderAxisCross),</span><br><span class="line">    paddingAndBorderAxisCross</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (crossAxis == CSS_FLEX_DIRECTION_ROW_REVERSE ||</span><br><span class="line">      crossAxis == CSS_FLEX_DIRECTION_COLUMN_REVERSE) &#123;</span><br><span class="line">    needsCrossTrailingPos = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些没有确定宽和高的子视图的宽和高会根据父视图来决定。方法见上述代码。</p>
<p>再就是循环F了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needsMainTrailingPos || needsCrossTrailingPos) &#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; childCount; ++i) &#123;</span><br><span class="line">    child = node-&gt;get_child(node-&gt;context, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsMainTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, mainAxis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (needsCrossTrailingPos) &#123;</span><br><span class="line">      setTrailingPosition(node, child, crossAxis);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这一步是设置当前node节点的Trailing坐标，如果有必要的话。如果不需要，这一步会直接跳过。</p>
<p>最后一步就是循环G了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">currentAbsoluteChild = firstAbsoluteChild;</span><br><span class="line"><span class="keyword">while</span> (currentAbsoluteChild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (ii = <span class="number">0</span>; ii &lt; <span class="number">2</span>; ii++) &#123;</span><br><span class="line">    axis = (ii != <span class="number">0</span>) ? CSS_FLEX_DIRECTION_ROW : CSS_FLEX_DIRECTION_COLUMN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isLayoutDimDefined(node, axis) &amp;&amp;</span><br><span class="line">        !isStyleDimDefined(currentAbsoluteChild, axis) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, leading[axis]) &amp;&amp;</span><br><span class="line">        isPosDefined(currentAbsoluteChild, trailing[axis])) &#123;</span><br><span class="line">      <span class="comment">// 绝对坐标的子视图在主轴上的宽度，在侧轴上的高度都不能比Padding、Border的总和小。</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] = fmaxf(</span><br><span class="line">        boundAxis(currentAbsoluteChild, axis, node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">          getBorderAxis(node, axis) -</span><br><span class="line">          getMarginAxis(currentAbsoluteChild, axis) -</span><br><span class="line">          getPosition(currentAbsoluteChild, leading[axis]) -</span><br><span class="line">          getPosition(currentAbsoluteChild, trailing[axis])</span><br><span class="line">        ),</span><br><span class="line">        getPaddingAndBorderAxis(currentAbsoluteChild, axis)</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isPosDefined(currentAbsoluteChild, trailing[axis]) &amp;&amp;</span><br><span class="line">        !isPosDefined(currentAbsoluteChild, leading[axis])) &#123;</span><br><span class="line">      <span class="comment">// 当前子视图的坐标等于当前视图的宽度减去子视图的宽度再减去trailing</span></span><br><span class="line">      currentAbsoluteChild-&gt;layout.position[leading[axis]] =</span><br><span class="line">        node-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        currentAbsoluteChild-&gt;layout.dimensions[dim[axis]] -</span><br><span class="line">        getPosition(currentAbsoluteChild, trailing[axis]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  child = currentAbsoluteChild;</span><br><span class="line">  currentAbsoluteChild = currentAbsoluteChild-&gt;next_absolute_child;</span><br><span class="line">  child-&gt;next_absolute_child = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后这一步循环G是用来给绝对坐标的子视图计算宽度和高度。</p>
<p>执行完上述7个循环以后，所有的子视图就都layout完成了。</p>
<p>总结一下上述的流程，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-fc141fa8e3dc0433.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="二-Weex布局算法性能分析"><a href="#二-Weex布局算法性能分析" class="headerlink" title="二. Weex布局算法性能分析"></a>二. Weex布局算法性能分析</h3><h4 id="1-算法实现分析"><a href="#1-算法实现分析" class="headerlink" title="1.算法实现分析"></a>1.算法实现分析</h4><p>上一章节看了Weex的layout算法实现。这里就分析一下在这个实现下，布局能力究竟有多强。</p>
<p>Weex的实现是FaceBook的开源库Yoga的前身，所以这里可以把两个看成是一种实现。</p>
<p>Weex的这种FlexBox的实现其实只是W3C标准的一个实现的子集，因为FlexBox的官方标准里面还有一些并没有实现出来。W3C上定义的FlexBox的标准，文档在<a href="https://www.w3.org/TR/css-flexbox-1/" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p>
<p>FlexBox标准定义：</p>
<p>针对父视图 (flex container):</p>
<ol>
<li>display</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ol>
<p>针对子视图 (flex items):</p>
<ol>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-63e820c1ee9472cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>相比官方的定义，上述的实现有一些限制：</p>
<ol>
<li>所有显示属性的node节点都默认假定是Flex的视图，当然这里要除去文本节点，因为它会被假定为inline-flex。</li>
<li>不支持zIndex的属性，包括任何z上的排序。所有的node节点都是按照代码书写的先后顺序进行排列的。Weex 目前也不支持 z-index 设置元素层级关系，但靠后的元素层级更高，因此，对于层级高的元素，可将其排列在后面。</li>
<li>FlexBox里面定义的order属性，也不支持。flex item默认按照代码书写顺序。</li>
<li>visibility属性默认都是可见的，暂时不支持边缘塌陷合并(collapse)和隐藏(hidden)属性。</li>
<li>不支持forced breaks。</li>
<li>不支持垂直方向的inline(比如从上到下的text，或者从下到上的text)</li>
</ol>
<p>关于Flexbox 在iOS这边的具体实现上一章节已经分析过了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2a97e349befdc557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来仔细分析一下Autolayout的具体实现</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b994236e0c27d79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>原来我们用Frame进行布局的时候，需要知道一个点（origin或者center）和宽高就可以确定一个View。</p>
<p>现在换成了Autolayout，每个View需要知道4个尺寸。left，top，width，height。</p>
<p>但是一个View的约束是相对于另一个View的，比如说相对于父视图，或者是相对于两两View之间的。</p>
<p>那么两两个View之间的约束就会变成一个八元一次的方程组。</p>
<p>解这个方程组可能有以下3种情况：</p>
<ol>
<li>当方程组的解的个数有无穷多个，最终会得到欠约束的有歧义的布局。</li>
<li>当方程无解时，则表示约束有冲突。</li>
<li>只有当方程组有唯一解的时候，才能得到一个稳定的布局。</li>
</ol>
<p><strong>Autolayout 本质是一个线性方程解析器，该解析器试图找到一种可满足其规则的几何表达式。</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-09b7902e4c7c67e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>Autolayout的底层数学模型是线性算术约束问题。</p>
<p>关于这个问题，早在1940年，由Dantzig提出了一个the simplex algorithm算法，但是由于这个算法实在很难用在UI应用上面，所以没有得到很广泛的应用，直到1997年，澳大利亚的莫纳什大学（Monash University）的两名学生，Alan Borning 和 Kim Marriott实现了Cassowary线性约束算法，才得以在UI应用上被大量的应用起来。</p>
<p>Cassowary线性约束算法是基于双simplex算法的，在增加约束或者一个对象被移除的时候，通过局部误差增益 和 加权求和比较 ，能够完美的增量处理不同层次的约束。Cassowary线性约束算法适合GUI布局系统，被用来计算view之间的位置的。开发者可以指定不同View之间的位置关系和约束关系，Cassowary线性约束算法会去求处符合条件的最优值。</p>
<p>下面是两位学生写的相关的论文，有兴趣的可以读一下，了解一下算法的具体实现：</p>
<ol>
<li>Alan Borning, Kim Marriott, Peter Stuckey, and Yi Xiao, <a href="https://constraints.cs.washington.edu/solvers/uist97.pdf" rel="external nofollow noopener noreferrer" target="_blank">Solving Linear Arithmetic Constraints for User Interface Applications</a>, Proceedings of the 1997 ACM Symposium on User Interface Software and Technology, October 1997, pages 87-96.</li>
<li>Greg J. Badros and Alan Borning, “The Cassowary Linear Arithmetic Constraint Solving Algorithm: Interface and Implementation”, Technical Report UW-CSE-98-06-04, June 1998 (<a href="https://constraints.cs.washington.edu/cassowary/cassowary-tr.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li>
<li>Greg J. Badros, Alan Borning, and Peter J. Stuckey, “The Cassowary Linear Arithmetic Constraint Solving Algorithm,” <em>ACM Transactions on Computer Human Interaction</em>, Vol. 8 No. 4, December 2001, pages 267-306. (<a href="https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf" rel="external nofollow noopener noreferrer" target="_blank">pdf</a>)</li>
</ol>
<p>Cassowary线性约束算法的伪代码如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2f208ced7d958ce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>关于这个算法已经被人们实现成了各个版本。1年以后，又出了一个新的QOCA算法。以下这段话摘抄自1997年ACM权威论文上的一篇文章：</p>
<blockquote>
<p>Both of our algorithms have been implemented, Cassowary<br>in Smalltalk and QOCA in C++. They perform surprisingly<br>well. The QOCA implementation is considerably more sophisticated<br>and has much better performance than the current version of<br>Cassowary. However, QOCA is inherently a more complex<br>algorithm, and re-implementing it with a comparable level<br>of performance would be a daunting task. In contrast, Cassowary<br>is straightforward, and a reimplementation based on<br>this paper is more reasonable, given a knowledge of the simplex<br>algorithm.</p>
</blockquote>
<p>Cassowary（<a href="https://constraints.cs.washington.edu/cassowary/" rel="external nofollow noopener noreferrer" target="_blank">项目主页</a>）也是优先被Smalltalk实现了，也是用在Autolayout技术上。另外还有更加复杂的QOCA算法，这里就不再细谈了，有兴趣的同学可以看看上面三篇论文，里面有详细的描述。</p>
<h4 id="2-算法性能测试准备工作"><a href="#2-算法性能测试准备工作" class="headerlink" title="2.算法性能测试准备工作"></a>2.算法性能测试准备工作</h4><p>开始笔者是打算连带Weex的布局性能一起测试的，但是由于Weex的布局都在子线程，刷新渲染回到主线程，需要测试都在主线程的情况需要改动一些代码，而且Weex原生的布局是从JS调用方法，如果用这种方法又会多损耗一些性能，对测试结果有影响。于是换成Weex相同布局方式的Yoga算法进行测试。由于Facebook对它进行了很好的封装，使用起来也很方便。虽然Layout算法和Weex有些差异，但是不影响定性的比较。</p>
<p>确定下来测试对象：Frame，FlexBox(Yoga实现)，Autolayout。</p>
<p>测试前，还需要准备测试模型，这里选出了3种测试模型。</p>
<p>第一种测试模型是随机生成完全不相关联的View。如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-a7a0d48cba94f3d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>第二种测试模型是生成相互嵌套的View。嵌套规则设置一个简单的：子视图依次比父视图高度少一个像素。类似下图，这是500个View相互嵌套的结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-0828ddc58f8d30ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>第三种测试模型是针对Autolayout专门加的。由于Autolayout约束的特殊性，这里针对链式约束额外增加的测试模型。规则是前后两个相连的View之间依次加上约束。类似下图，这是500个View链式的约束结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-1b8f68cd9debed67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>根据测试模型，我们可以得到如下的7组需要测试的测试用例：</p>
<p>1.Frame<br>2.嵌套的Frame<br>3.Yoga<br>4.嵌套的Yoga<br>5.Autolayout<br>6.嵌套的Autolayout<br>7.链式的Autolayout</p>
<p>测试样本：由于需要考虑到测试的通用性，测试样本要尽量随机。于是针对随机生成的坐标全部都随机生成，View的颜色也全部都随机生成，这样保证了通用公正公平性质。</p>
<p>测试次数：为了保证测试数据能尽量真实，笔者在这里花了大量的时间。每组测试用例都针对从100，200，300，400，500，600，700，800，900，1000个视图进行测试，为了保证测试的普遍性，这里每次测试都测试10000次，然后对10000次的结果进行加和平均。加和平均取小数点后5位。（10000次的统计是用计算机来算的，但是真的非常非常非常的耗时，有兴趣的可以自己用电脑试试）</p>
<p>最后展示一下测试机器的配置和系统版本：</p>
<p>（由于iPhone真机对每个App的内存有限制，产生1000个嵌套的视图，并且进行10000次试验，iPhone真机完全受不了这种计算量，App直接闪退，所以用真机测试到一半，改用模拟器测试，借助Mac的性能，咬着牙从零开始，重新统计了所有测试用例的数据）</p>
<p>如果有性能更强的Mac电脑（垃圾桶），测试全过程花的时间可能会更少。</p>
<p>笔者用的电脑的配置如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-510c7d7ab97e2330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>测试用的模拟器是iPad Pro（12.9 inch）iOS 10.3（14E269）</p>
<p>我所用的测试代码也公布出来，有兴趣的可以自己测试测试。<a href="https://github.com/halfrost/Halfrost-Field/tree/master/contents/iOS/AutoLayoutProfiling-master" rel="external nofollow noopener noreferrer" target="_blank">测试代码在这里</a>  </p>
<h4 id="3-算法性能测试结果"><a href="#3-算法性能测试结果" class="headerlink" title="3.算法性能测试结果"></a>3.算法性能测试结果</h4><p>公布测试结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-34171d65db564340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图数据是10，20，30，40，50，60，70，80，90，100个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-f9468b0f10f0ef95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>结果依旧是Autolayout的3种方式都高于其他4种布局方式。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-7f51f5e34c9e5485.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-64f5f7c2e89e2661.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-409f0c3e820c5770.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后这张图也是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，嵌套的Autolayout的性能依旧是最差的！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b338b4507694268.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图数据是100，200，300，400，500，600，700，800，900，1000个View分别用7组用例测试出来的结果。将上面的结果统计成折线图，如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-e60d70a0eaa4a67f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>当视图多到900，1000的时候，嵌套的Autolayout直接就导致模拟器崩溃了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-4560c9da3bfa0968.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在普通场景下的性能比较图，可以看到，FlexBox的性能接近于原生的Frame。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-cad15676ac4504b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图是3个布局算法在嵌套情况下的性能比较图，可以看到，FlexBox的性能也依旧接近于原生的Frame。而嵌套情况下的Autolayout的性能急剧下降。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-c71dbeba866e73fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>最后这张图是专门针对Autolayout额外加的一组测试。目的是为了比较3种场景下不同的Autolayout的性能，可以看到，平时我们使用嵌套的Autolayout的性能是最差的！</p>
<h3 id="三-Weex是如何布局原生界面的"><a href="#三-Weex是如何布局原生界面的" class="headerlink" title="三. Weex是如何布局原生界面的"></a>三. Weex是如何布局原生界面的</h3><p>上一章节看了FlexBox算法的强大布局能力，这一章节就来看看Weex究竟是如何利用这个能力的对原生View进行Layout。</p>
<p>在解答上面这个问题之前，先让我们回顾一下上篇文章<a href="http://www.jianshu.com/p/41cde2c62b81" rel="external nofollow noopener noreferrer" target="_blank">《Weex 是如何在 iOS 客户端上跑起来的》</a>里面提到的，在JSFramework转换从网络上下载下来的JS文件之前，本地先注册了4个重要的回调函数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallNative)(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInteger</span>(^WXJSCallAddElement)(<span class="built_in">NSString</span> *instanceId,  <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSInvocation</span> *(^WXJSCallNativeModule)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^WXJSCallNativeComponent)(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options);</span><br></pre></td></tr></table></figure>
<p>这4个block非常重要，是JS和OC进行相互调用的四大函数。</p>
<p>先来回顾一下这四大函数注册的时候分别封装了哪些闭包。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WXBridgeContext</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span>&lt;WXBridgeProtocol&gt;  jsBridge;</span><br></pre></td></tr></table></figure>
<p>在WXBridgeContext类里面有一个jsBridge。jsBridge初始化的时候会注册这4个全局函数。</p>
<p>第一个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallNative:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instance, <span class="built_in">NSArray</span> *tasks, <span class="built_in">NSString</span> *callback) &#123;</span><br><span class="line">    <span class="keyword">return</span> [weakSelf invokeNative:instance tasks:tasks callback:callback];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里的闭包函数会被传入到下面这个函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNative:(WXJSCallNative)callNative</span><br><span class="line">&#123;</span><br><span class="line">    JSValue* (^callNativeBlock)(JSValue *, JSValue *, JSValue *) = ^JSValue*(JSValue *instance, JSValue *tasks, JSValue *callback)&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceId = [instance toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *tasksArray = [tasks toArray];</span><br><span class="line">        <span class="built_in">NSString</span> *callbackId = [callback toString];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"Calling native... instance:%@, tasks:%@, callback:%@"</span>, instanceId, tasksArray, callbackId);</span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callNative(instanceId, tasksArray, callbackId) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    _jsContext[<span class="string">@"callNative"</span>] = callNativeBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就封装了一个函数，暴露给JS用。方法名叫callNative，函数参数为3个，分别是instanceId，tasksArray任务数组，callbackId回调ID。</p>
<p>所有的OC的闭包都需要封装一层，因为暴露给JS的方法不能有冒号，所有的参数都是直接跟在小括号的参数列表里面的，因为JS的函数是这样定义的。</p>
<p>当JS调用callNative方法之后，就会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p>
<p>第二个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallAddElement:(WXJSCallAddElement)callAddElement</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> callAddElementBlock = ^(JSValue *instanceId, JSValue *ref, JSValue *element, JSValue *index, JSValue *ifCallback) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *componentData = [element toDictionary];</span><br><span class="line">        <span class="built_in">NSString</span> *parentRef = [ref toString];</span><br><span class="line">        <span class="built_in">NSInteger</span> insertIndex = [[index toNumber] integerValue];</span><br><span class="line">        </span><br><span class="line">         WXLogDebug(<span class="string">@"callAddElement...%@, %@, %@, %ld"</span>, instanceIdString, parentRef, componentData, (<span class="keyword">long</span>)insertIndex);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> [JSValue valueWithInt32:(int32_t)callAddElement(instanceIdString, parentRef, componentData, insertIndex) inContext:[JSContext currentContext]];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    _jsContext[<span class="string">@"callAddElement"</span>] = callAddElementBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的包装方法和第一个方法是相同的。这里暴露给JS的方法名叫callAddElement，函数参数为4个，分别是instanceIdString，componentData组件的数据，parentRef引用编号，insertIndex插入视图的index。</p>
<p>当JS调用callAddElement方法，就会最终执行WXBridgeContext类里面的WXPerformBlockOnComponentThread闭包。</p>
<p>第三个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeModule:^<span class="built_in">NSInvocation</span>*(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *moduleName, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *arguments, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found for callNativeModule:%@.%@, maybe already destroyed"</span>, moduleName, methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">    <span class="keyword">return</span> [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeModule:(WXJSCallNativeModule)callNativeModuleBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeModule"</span>] = ^JSValue *(JSValue *instanceId, JSValue *moduleName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *moduleNameString = [moduleName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeModule...%@,%@,%@,%@"</span>, instanceIdString, moduleNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSInvocation</span> *invocation = callNativeModuleBlock(instanceIdString, moduleNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">        JSValue *returnValue = [JSValue wx_valueWithReturnValueFromInvocation:invocation inContext:[JSContext currentContext]];</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暴露给JS的方法名叫callNativeModule，函数参数为5个，分别是instanceIdString，moduleNameString模块名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p>
<p>当JS调用callNativeModule方法，就会最终执行WXBridgeContext类里面的WXModuleMethod方法。</p>
<p>第四个闭包函数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[_jsBridge registerCallNativeComponent:^<span class="keyword">void</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *componentRef, <span class="built_in">NSString</span> *methodName, <span class="built_in">NSArray</span> *args, <span class="built_in">NSDictionary</span> *options) &#123;</span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:componentRef methodName:methodName arguments:args instance:instance];</span><br><span class="line">    [method invoke];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这个闭包会被传到下面的函数中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)registerCallNativeComponent:(WXJSCallNativeComponent)callNativeComponentBlock</span><br><span class="line">&#123;</span><br><span class="line">    _jsContext[<span class="string">@"callNativeComponent"</span>] = ^<span class="keyword">void</span>(JSValue *instanceId, JSValue *componentName, JSValue *methodName, JSValue *args, JSValue *options) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *instanceIdString = [instanceId toString];</span><br><span class="line">        <span class="built_in">NSString</span> *componentNameString = [componentName toString];</span><br><span class="line">        <span class="built_in">NSString</span> *methodNameString = [methodName toString];</span><br><span class="line">        <span class="built_in">NSArray</span> *argsArray = [args toArray];</span><br><span class="line">        <span class="built_in">NSDictionary</span> *optionsDic = [options toDictionary];</span><br><span class="line">        </span><br><span class="line">        WXLogDebug(<span class="string">@"callNativeComponent...%@,%@,%@,%@"</span>, instanceIdString, componentNameString, methodNameString, argsArray);</span><br><span class="line">        </span><br><span class="line">        callNativeComponentBlock(instanceIdString, componentNameString, methodNameString, argsArray, optionsDic);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里暴露给JS的方法名叫callNativeComponent，函数参数为5个，分别是instanceIdString，componentNameString组件名，methodNameString方法名，argsArray参数数组，optionsDic字典。</p>
<p>当JS调用callNativeComponent方法，就会最终执行WXBridgeContext类里面的WXComponentMethod方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-23bfe161375b750a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>总结一下上述暴露给JS的4个方法：</p>
<ol>
<li><p>callNative<br>这个方法是JS用来调用任意一个Native方法的。</p>
</li>
<li><p>callAddElement<br>这个方法是JS用来给当前页面添加视图元素的。</p>
</li>
<li><p>callNativeModule<br>这个方法是JS用来调用模块里面暴露出来的方法。</p>
</li>
<li><p>callNativeComponent<br>这个方法是JS用来调用组件里面暴露出来的方法。</p>
</li>
</ol>
<p>Weex在布局的时候就只会用到前2个方法。</p>
<p>####（一）createRoot:</p>
<p>当JSFramework把JS文件转换类似JSON的文件之后，就开始调用Native的callNative方法。</p>
<p>callNative方法会最终执行WXBridgeContext类里面的[weakSelf invokeNative:instance tasks:tasks callback:callback]方法。</p>
<p>当前操作处于子线程“com.taobao.weex.bridge”中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)invokeNative:(<span class="built_in">NSString</span> *)instanceId tasks:(<span class="built_in">NSArray</span> *)tasks callback:(<span class="built_in">NSString</span> __unused*)callback</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertBridgeThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instanceId || !tasks) &#123;</span><br><span class="line">        WX_MONITOR_FAIL(WXMTNativeRender, WX_ERR_JSFUNC_PARAM, <span class="string">@"JS call Native params error!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance already destroyed, task ignored"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据JS发送过来的方法，进行转换成Native方法调用</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *task <span class="keyword">in</span> tasks) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *methodName = task[<span class="string">@"method"</span>];</span><br><span class="line">        <span class="built_in">NSArray</span> *arguments = task[<span class="string">@"args"</span>];</span><br><span class="line">        <span class="keyword">if</span> (task[<span class="string">@"component"</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *ref = task[<span class="string">@"ref"</span>];</span><br><span class="line">            WXComponentMethod *method = [[WXComponentMethod alloc] initWithComponentRef:ref methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *moduleName = task[<span class="string">@"module"</span>];</span><br><span class="line">            WXModuleMethod *method = [[WXModuleMethod alloc] initWithModuleName:moduleName methodName:methodName arguments:arguments instance:instance];</span><br><span class="line">            [method invoke];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有回调，回调给JS</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_sendQueueLoop) withObject:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会把JS从发送过来的callNative方法转换成Native的组件component的方法调用或者模块module的方法调用。</p>
<p>举个例子：</p>
<p>JS从callNative方法传过来3个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">instance:0,</span><br><span class="line"></span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">                        &#123;</span><br><span class="line">                attr =                 &#123;</span><br><span class="line">                &#125;;</span><br><span class="line">                ref = &quot;_root&quot;;</span><br><span class="line">                style =                 &#123;</span><br><span class="line">                    alignItems = center;</span><br><span class="line">                &#125;;</span><br><span class="line">                type = div;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        method = createBody;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line"></span><br><span class="line">callback:-1</span><br></pre></td></tr></table></figure>
<p>tasks数组里面会解析出各个方法和调用者。</p>
<p>这个例子里面就会解析出Dom模块的createBody方法。</p>
<p>接着就会调用Dom模块的createBody方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">    [invocation invoke];</span><br><span class="line">    <span class="keyword">return</span> invocation;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> _dispatchInvocation:invocation moduleInstance:moduleInstance];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用方法之前，有一个线程切换的步骤。如果是同步方法，那么就直接调用，如果是异步方法，那么嗨需要进行线程转换。</p>
<p>Dom模块的createBody方法是异步的方法，于是就需要调用_dispatchInvocation: moduleInstance:方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_dispatchInvocation:(<span class="built_in">NSInvocation</span> *)invocation moduleInstance:(<span class="keyword">id</span>&lt;WXModuleProtocol&gt;)moduleInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// dispatch to user specified queue or thread, default is main thread</span></span><br><span class="line">    dispatch_block_t dispatchBlock = ^ ()&#123;</span><br><span class="line">        [invocation invoke];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSThread</span> *targetThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteQueue)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Queue，如果没有，就返回main_queue，如果有，就切换到targetQueue</span></span><br><span class="line">        targetQueue = [moduleInstance targetExecuteQueue] ?: dispatch_get_main_queue();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([moduleInstance respondsToSelector:<span class="keyword">@selector</span>(targetExecuteThread)])&#123;</span><br><span class="line">        <span class="comment">// 判断当前是否有Thread，如果没有，就返回主线程，如果有，就切换到targetThread</span></span><br><span class="line">        targetThread = [moduleInstance targetExecuteThread] ?: [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetThread = [<span class="built_in">NSThread</span> mainThread];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    WXAssert(targetQueue || targetThread, <span class="string">@"No queue or thread found for module:%@"</span>, moduleInstance);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (targetQueue) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(targetQueue, dispatchBlock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WXPerformBlockOnThread(^&#123;</span><br><span class="line">            dispatchBlock();</span><br><span class="line">        &#125;, targetThread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在整个Weex模块中，目前只有2个模块是有targetQueue的，一个是WXClipboardModule，另一个是WXStorageModule。所以这里没有targetQueue，就只能切换到对应的targetThread上。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">void</span> WXPerformBlockOnThread(<span class="keyword">void</span> (^ _Nonnull block)(), <span class="built_in">NSThread</span> *thread)</span><br><span class="line">&#123;</span><br><span class="line">    [WXUtility performBlock:block onThread:thread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)performBlock:(<span class="keyword">void</span> (^)())block onThread:(<span class="built_in">NSThread</span> *)thread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!thread || !block) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果当前线程不是目标线程上，就要切换线程</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread] == thread) &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(_performBlock:)</span><br><span class="line">                     onThread:thread</span><br><span class="line">                   withObject:[block <span class="keyword">copy</span>]</span><br><span class="line">                waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是切换线程的操作，如果当前线程不是目标线程，就要切换线程。在目标线程上调用_performBlock:方法，入参还是最初传进来的block闭包。</p>
<p>切换前线程处于子线程“com.taobao.weex.bridge”中。</p>
<p>在WXDomModule中调用targetExecuteThread方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSThread</span> *)targetExecuteThread</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [WXComponentManager componentThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切换线程之后，当前线程变成了“com.taobao.weex.component”。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createBody:(<span class="built_in">NSDictionary</span> *)body</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createRoot:body];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)performBlockOnComponentManager:(<span class="keyword">void</span>(^)(WXComponentManager *))block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = weakSelf.weexInstance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开启组件任务</span></span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        block(manager);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用了Dom模块的createBody方法以后，会先调用WXComponentManager的startComponentTasks方法，再调用createRoot:方法。</p>
<p>这里会初始化一个WXComponentManager。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponentManager *)componentManager</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_componentManager) &#123;</span><br><span class="line">        _componentManager = [[WXComponentManager alloc] initWithWeexInstance:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _componentManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithWeexInstance:(<span class="keyword">id</span>)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        </span><br><span class="line">        _indexDict = [<span class="built_in">NSMapTable</span> strongToWeakObjectsMapTable];</span><br><span class="line">        _fixedComponents = [<span class="built_in">NSMutableArray</span> wx_mutableArrayUsingWeakReferences];</span><br><span class="line">        _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _isValid = <span class="literal">YES</span>;</span><br><span class="line">        [<span class="keyword">self</span> _startDisplayLink];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的初始化重点是会开启DisplayLink，它会开启一个runloop。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_startDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!_displayLink)&#123;</span><br><span class="line">        _displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_handleDisplayLink)];</span><br><span class="line">        [_displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>displayLink一旦开启，被加入到当前runloop之中，每次runloop循环一次都会执行刷新布局的方法_handleDisplayLink。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startComponentTasks</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> _awakeDisplayLink];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_awakeDisplayLink</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    <span class="keyword">if</span>(_displayLink &amp;&amp; _displayLink.paused) &#123;</span><br><span class="line">        _displayLink.paused = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的startComponentTasks方法仅仅是更改了CADisplayLink的paused的状态。CADisplayLink就是用来刷新layout的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WXComponentManager</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对WXSDKInstance的弱引用</span></span><br><span class="line">    __<span class="keyword">weak</span> WXSDKInstance *_weexInstance;</span><br><span class="line">    <span class="comment">// 当前WXComponentManager是否可用</span></span><br><span class="line">    <span class="built_in">BOOL</span> _isValid;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否停止刷新布局</span></span><br><span class="line">    <span class="built_in">BOOL</span> _stopRunning;</span><br><span class="line">    <span class="built_in">NSUInteger</span> _noTaskTickCount;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// access only on component thread</span></span><br><span class="line">    <span class="built_in">NSMapTable</span>&lt;<span class="built_in">NSString</span> *, WXComponent *&gt; *_indexDict;</span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;dispatch_block_t&gt; *_uiTaskQueue;</span><br><span class="line">    </span><br><span class="line">    WXComponent *_rootComponent;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *_fixedComponents;</span><br><span class="line">    </span><br><span class="line">    css_node_t *_rootCSSNode;</span><br><span class="line">    <span class="built_in">CADisplayLink</span> *_displayLink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是WXComponentManager的所有属性，可以看出WXComponentManager就是用来处理UI任务的。</p>
<p>再来看看createRoot:方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createRoot:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    WXAssertParam(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.创建WXComponent，作为rootComponent</span></span><br><span class="line">    _rootComponent = [<span class="keyword">self</span> _buildComponentForData:data];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.初始化css_node_t，作为rootCSSNode</span></span><br><span class="line">    [<span class="keyword">self</span> _initRootCSSNode];</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    <span class="comment">// 3.添加UI任务到uiTaskQueue数组中</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">        strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">        [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里干了3件事情:</p>
<h4 id="1-创建WXComponent"><a href="#1-创建WXComponent" class="headerlink" title="1.创建WXComponent"></a>1.创建WXComponent</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (WXComponent *)_buildComponentForData:(<span class="built_in">NSDictionary</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *ref = data[<span class="string">@"ref"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *type = data[<span class="string">@"type"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *styles = data[<span class="string">@"style"</span>];</span><br><span class="line">    <span class="built_in">NSDictionary</span> *attributes = data[<span class="string">@"attr"</span>];</span><br><span class="line">    <span class="built_in">NSArray</span> *events = data[<span class="string">@"event"</span>];</span><br><span class="line">        </span><br><span class="line">    Class clazz = [WXComponentFactory classWithComponentName:type];</span><br><span class="line">    WXComponent *component = [[clazz alloc] initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:<span class="keyword">self</span>.weexInstance];</span><br><span class="line">    WXAssert(component, <span class="string">@"Component build failed for data:%@"</span>, data);</span><br><span class="line">    </span><br><span class="line">    [_indexDict setObject:component forKey:component.ref];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的入参data是之前的tasks数组。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRef:(<span class="built_in">NSString</span> *)ref</span><br><span class="line">                       type:(<span class="built_in">NSString</span> *)type</span><br><span class="line">                     styles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">                 attributes:(<span class="built_in">NSDictionary</span> *)attributes</span><br><span class="line">                     events:(<span class="built_in">NSArray</span> *)events</span><br><span class="line">               weexInstance:(WXSDKInstance *)weexInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        pthread_mutexattr_init(&amp;_propertMutexAttr);</span><br><span class="line">        pthread_mutexattr_settype(&amp;_propertMutexAttr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">        pthread_mutex_init(&amp;_propertyMutex, &amp;_propertMutexAttr);</span><br><span class="line">        </span><br><span class="line">        _ref = ref;</span><br><span class="line">        _type = type;</span><br><span class="line">        _weexInstance = weexInstance;</span><br><span class="line">        _styles = [<span class="keyword">self</span> parseStyles:styles];</span><br><span class="line">        _attributes = attributes ? [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:attributes] : [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">        _events = events ? [<span class="built_in">NSMutableArray</span> arrayWithArray:events] : [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        _subcomponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        _absolutePosition = <span class="built_in">CGPointMake</span>(NAN, NAN);</span><br><span class="line">        </span><br><span class="line">        _isNeedJoinLayoutSystem = <span class="literal">YES</span>;</span><br><span class="line">        _isLayoutDirty = <span class="literal">YES</span>;</span><br><span class="line">        _isViewFrameSyncWithCalculated = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">        _async = <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//TODO set indicator style </span></span><br><span class="line">        <span class="keyword">if</span> ([type isEqualToString:<span class="string">@"indicator"</span>]) &#123;</span><br><span class="line">            _styles[<span class="string">@"position"</span>] = <span class="string">@"absolute"</span>;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"left"</span>] &amp;&amp; !_styles[<span class="string">@"right"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"left"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!_styles[<span class="string">@"top"</span>] &amp;&amp; !_styles[<span class="string">@"bottom"</span>]) &#123;</span><br><span class="line">                _styles[<span class="string">@"top"</span>] = @<span class="number">0.0</span>f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置NavBar的Style</span></span><br><span class="line">        [<span class="keyword">self</span> _setupNavBarWithStyles:_styles attributes:_attributes];</span><br><span class="line">        <span class="comment">// 根据style初始化cssNode数据结构</span></span><br><span class="line">        [<span class="keyword">self</span> _initCSSNodeWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 根据style初始化View的各个属性</span></span><br><span class="line">        [<span class="keyword">self</span> _initViewPropertyWithStyles:_styles];</span><br><span class="line">        <span class="comment">// 处理Border的圆角，边线宽度，背景颜色等属性</span></span><br><span class="line">        [<span class="keyword">self</span> _handleBorders:styles isUpdating:<span class="literal">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数就是初始化WXComponent的布局的各个属性。这里会用到FlexBox里面的一些计算属性的方法就在_initCSSNodeWithStyles:方法里面。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initCSSNodeWithStyles:(<span class="built_in">NSDictionary</span> *)styles</span><br><span class="line">&#123;</span><br><span class="line">    _cssNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    _cssNode-&gt;print = cssNodePrint;</span><br><span class="line">    _cssNode-&gt;get_child = cssNodeGetChild;</span><br><span class="line">    _cssNode-&gt;is_dirty = cssNodeIsDirty;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> measureBlock]) &#123;</span><br><span class="line">        _cssNode-&gt;measure = cssNodeMeasure;</span><br><span class="line">    &#125;</span><br><span class="line">    _cssNode-&gt;context = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新计算_cssNode需要布局的子视图个数</span></span><br><span class="line">    [<span class="keyword">self</span> _recomputeCSSNodeChildren];</span><br><span class="line">    <span class="comment">// 将style各个属性都填充到cssNode数据结构中</span></span><br><span class="line">    [<span class="keyword">self</span> _fillCSSNode:styles];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// To be in conformity with Android/Web, hopefully remove this in the future.</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.ref isEqualToString:WX_SDK_ROOT_REF]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_HEIGHT]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.height) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_HEIGHT] = <span class="keyword">self</span>.weexInstance.frame.size.height;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isUndefined(_cssNode-&gt;style.dimensions[CSS_WIDTH]) &amp;&amp; <span class="keyword">self</span>.weexInstance.frame.size.width) &#123;</span><br><span class="line">            _cssNode-&gt;style.dimensions[CSS_WIDTH] = <span class="keyword">self</span>.weexInstance.frame.size.width;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在_fillCSSNode:方法里面会对FlexBox算法里面定义的各个属性值就行赋值。</p>
<h4 id="2-初始化css-node-t"><a href="#2-初始化css-node-t" class="headerlink" title="2.初始化css_node_t"></a>2.初始化css_node_t</h4><p>在这里，准备开始Layout之前，我们需要先初始化rootCSSNode</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_initRootCSSNode</span><br><span class="line">&#123;</span><br><span class="line">    _rootCSSNode = new_css_node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据页面weexInstance设置rootCSSNode的坐标和宽高尺寸</span></span><br><span class="line">    [<span class="keyword">self</span> _applyRootFrame:<span class="keyword">self</span>.weexInstance.frame toRootCSSNode:_rootCSSNode];</span><br><span class="line">    </span><br><span class="line">    _rootCSSNode-&gt;style.flex_wrap = CSS_NOWRAP;</span><br><span class="line">    _rootCSSNode-&gt;is_dirty = rootNodeIsDirty;</span><br><span class="line">    _rootCSSNode-&gt;get_child = rootNodeGetChild;</span><br><span class="line">    _rootCSSNode-&gt;context = (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>);</span><br><span class="line">    _rootCSSNode-&gt;children_count = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述方法中，会初始化rootCSSNode的坐标和宽高尺寸。</p>
<h4 id="3-添加UI任务到uiTaskQueue数组中"><a href="#3-添加UI任务到uiTaskQueue数组中" class="headerlink" title="3.添加UI任务到uiTaskQueue数组中"></a>3.添加UI任务到uiTaskQueue数组中</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    strongSelf.weexInstance.rootView.wx_component = strongSelf-&gt;_rootComponent;</span><br><span class="line">    [strongSelf.weexInstance.rootView addSubview:strongSelf-&gt;_rootComponent.view];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>WXComponentManager会把当前的组件以及它对应的View添加到页面Instance的rootView上面的这个任务，添加到uiTaskQueue数组中。</p>
<p>_rootComponent.view会创建组件对应的WXView，这个是继承自UIView的。所以Weex通过JS代码创建出来的控件都是原生的，都是WXView类型的，实质就是UIView。创建UIView这一步又是回到主线程中执行的。</p>
<p>最后显示到页面上的工作，是由displayLink的刷新方法在主线程刷新UI显示的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_handleDisplayLink</span><br><span class="line">&#123; </span><br><span class="line">    [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layoutAndSyncUI</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Flexbox布局</span></span><br><span class="line">    [<span class="keyword">self</span> _layout];</span><br><span class="line">    <span class="keyword">if</span>(_uiTaskQueue.count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// 同步执行UI任务</span></span><br><span class="line">        [<span class="keyword">self</span> _syncUITasks];</span><br><span class="line">        _noTaskTickCount = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前一秒内没有任务，那么智能的挂起displaylink，以节约CPU时间</span></span><br><span class="line">        _noTaskTickCount ++;</span><br><span class="line">        <span class="keyword">if</span> (_noTaskTickCount &gt; <span class="number">60</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _suspendDisplayLink];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_layoutAndSyncUI是布局和刷新UI的核心流程。每次刷新一次，都会先调用Flexbox算法的Layout进行布局，这个布局是在子线程“com.taobao.weex.component”执行的。接着再去查看当前是否有UI任务需要执行，如果有，就切换到主线程进行UI刷新操作。</p>
<p>这里还会有一个智能的挂起操作。就是判断一秒内如果都没有任务，那么就挂起displaylink，以节约CPU时间。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_layout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">BOOL</span> needsLayout = <span class="literal">NO</span>;</span><br><span class="line">    <span class="built_in">NSEnumerator</span> *enumerator = [_indexDict objectEnumerator];</span><br><span class="line">    WXComponent *component;</span><br><span class="line">    <span class="comment">// 判断当前是否需要布局，即是判断当前组件的_isLayoutDirty这个BOLL属性值</span></span><br><span class="line">    <span class="keyword">while</span> ((component = [enumerator nextObject])) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([component needsLayout]) &#123;</span><br><span class="line">            needsLayout = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!needsLayout) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Flexbox的算法核心函数</span></span><br><span class="line">    layoutNode(_rootCSSNode, _rootCSSNode-&gt;style.dimensions[CSS_WIDTH], _rootCSSNode-&gt;style.dimensions[CSS_HEIGHT], CSS_DIRECTION_INHERIT);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSMutableSet</span>&lt;WXComponent *&gt; *dirtyComponents = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    [_rootComponent _calculateFrameWithSuperAbsolutePosition:<span class="built_in">CGPointZero</span> gatherDirtyComponents:dirtyComponents];</span><br><span class="line">    <span class="comment">// 计算当前weexInstance的rootView.frame，并且重置rootCSSNode的Layout</span></span><br><span class="line">    [<span class="keyword">self</span> _calculateRootFrame];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 在每个需要布局的组件之间</span></span><br><span class="line">    <span class="keyword">for</span> (WXComponent *dirtyComponent <span class="keyword">in</span> dirtyComponents) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">            [dirtyComponent _layoutDidFinish];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_indexDict里面维护了一张整个页面的布局结构的Map，举个例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMapTable</span> &#123;</span><br><span class="line">[<span class="number">7</span>] _root -&gt; &lt;div ref=_root&gt; &lt;WXView: <span class="number">0x7fc59a416140</span>; frame = (<span class="number">0</span> <span class="number">0</span>; <span class="number">331.333</span> <span class="number">331.333</span>); layer = &lt;WXLayer: <span class="number">0x608000223180</span>&gt;&gt;</span><br><span class="line">[<span class="number">12</span>] <span class="number">5</span> -&gt; &lt;image ref=<span class="number">5</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a724430</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">192.333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; layer = &lt;WXLayer: <span class="number">0x60000002f780</span>&gt;&gt;</span><br><span class="line">[<span class="number">13</span>] <span class="number">3</span> -&gt; &lt;image ref=<span class="number">3</span>&gt; &lt;WXImageView: <span class="number">0x7fc59a617a00</span>; baseClass = <span class="built_in">UIImageView</span>; frame = (<span class="number">110.333</span> <span class="number">55.3333</span>; <span class="number">110.333</span> <span class="number">110.333</span>); clipsToBounds = <span class="literal">YES</span>; opaque = <span class="literal">NO</span>; gestureRecognizers = &lt;<span class="built_in">NSArray</span>: <span class="number">0x60000024b760</span>&gt;; layer = &lt;WXLayer: <span class="number">0x60000003e8c0</span>&gt;&gt;</span><br><span class="line">[<span class="number">15</span>] <span class="number">4</span> -&gt; &lt;text ref=<span class="number">4</span>&gt; &lt;WXText: <span class="number">0x7fc59a509840</span>; text: hello Weex; frame:<span class="number">0.000000</span>,<span class="number">441.666667</span>,<span class="number">331.333333</span>,<span class="number">26.666667</span> frame = (<span class="number">0</span> <span class="number">441.667</span>; <span class="number">331.333</span> <span class="number">26.6667</span>); opaque = <span class="literal">NO</span>; layer = &lt;WXLayer: <span class="number">0x608000223480</span>&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的组件都是由ref引用值作为Key存储的，只要知道这个页面上全局唯一的ref，就可以拿到这个ref对应的组件。</p>
<p>_layout会先判断当前是否有需要布局的组件，如果有，就从rootCSSNode开始进行Flexbox算法的Layout。执行完成以后还需要调整一次rootView的frame，最后添加一个UI任务到taskQueue中，这个任务标记的是组件布局完成。</p>
<p>注意上述所有布局操作都是在子线程“com.taobao.weex.component”中执行的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_syncUITasks</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 用blocks接收原来uiTaskQueue里面的所有任务</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;dispatch_block_t&gt; *blocks = _uiTaskQueue;</span><br><span class="line">    <span class="comment">// 清空uiTaskQueue</span></span><br><span class="line">    _uiTaskQueue = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">// 在主线程中依次执行uiTaskQueue里面的所有闭包</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">for</span>(dispatch_block_t block <span class="keyword">in</span> blocks) &#123;</span><br><span class="line">            block();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布局完成以后就调用同步的UI刷新方法。注意这里要对UI进行操作，一定要切换回主线程。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-6b16532cf00e3f99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>####（二）callAddElement</p>
<p>在子线程“com.taobao.weex.bridge”中，会一直相应来自JSFramework调用Native的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[_jsBridge registerCallAddElement:^<span class="built_in">NSInteger</span>(<span class="built_in">NSString</span> *instanceId, <span class="built_in">NSString</span> *parentRef, <span class="built_in">NSDictionary</span> *elementData, <span class="built_in">NSInteger</span> index) &#123;</span><br><span class="line">    <span class="comment">// Temporary here , in order to improve performance, will be refactored next version.</span></span><br><span class="line">    WXSDKInstance *instance = [WXSDKManager instanceForID:instanceId];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">        WXLogInfo(<span class="string">@"instance not found, maybe already destroyed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WXPerformBlockOnComponentThread(^&#123;</span><br><span class="line">        WXComponentManager *manager = instance.componentManager;</span><br><span class="line">        <span class="keyword">if</span> (!manager.isValid) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        [manager startComponentTasks];</span><br><span class="line">        [manager addComponent:elementData toSupercomponent:parentRef atIndex:index appendingInTree:<span class="literal">NO</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>当JSFramework调用callAddElement方法，就会执行上述代码的闭包函数。这里会接收来自JS的4个入参。</p>
<p>举个例子，JSFramework可能会通过callAddElement方法传过来这样4个参数：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">_root, </span><br><span class="line">&#123;</span><br><span class="line">    attr =     &#123;</span><br><span class="line">        value = <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    ref = <span class="number">4</span>;</span><br><span class="line">    style =     &#123;</span><br><span class="line">        color = <span class="string">"#000000"</span>;</span><br><span class="line">        fontSize = <span class="number">40</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    type = text;</span><br><span class="line">&#125;, </span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>这里的insertIndex为0，parentRef是_root，componentData是当前要创建的组件的信息，instanceIdString是-1。</p>
<p>之后WXComponentManager就会调用startComponentTasks开始displaylink继续准备刷新布局，最后调用addComponent: toSupercomponent: atIndex: appendingInTree:方法添加新的组件。</p>
<p>注意，WXComponentManager的这两步操作，又要切换线程，切换到“com.taobao.weex.component”子线程中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(<span class="built_in">NSString</span> *)superRef atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line">    WXComponent *supercomponent = [_indexDict objectForKey:superRef];</span><br><span class="line">    WXAssertComponentExist(supercomponent);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> _recursivelyAddComponent:componentData toSupercomponent:supercomponent atIndex:index appendingInTree:appendingInTree];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager会在“com.taobao.weex.component”子线程中递归的添加子组件。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_recursivelyAddComponent:(<span class="built_in">NSDictionary</span> *)componentData toSupercomponent:(WXComponent *)supercomponent atIndex:(<span class="built_in">NSInteger</span>)index appendingInTree:(<span class="built_in">BOOL</span>)appendingInTree</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据componentData构建组件</span></span><br><span class="line">    WXComponent *component = [<span class="keyword">self</span> _buildComponentForData:componentData];</span><br><span class="line">    </span><br><span class="line">    index = (index == <span class="number">-1</span> ? supercomponent-&gt;_subcomponents.count : index);</span><br><span class="line">    </span><br><span class="line">    [supercomponent _insertSubcomponent:component atIndex:index];</span><br><span class="line">    <span class="comment">// 用_lazyCreateView标识懒加载</span></span><br><span class="line">    <span class="keyword">if</span>(supercomponent &amp;&amp; component &amp;&amp; supercomponent-&gt;_lazyCreateView) &#123;</span><br><span class="line">        component-&gt;_lazyCreateView = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入一个UI任务</span></span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;</span><br><span class="line">        [supercomponent insertSubview:component atIndex:index];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *subcomponentsData = [componentData valueForKey:<span class="string">@"children"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> appendTree = !appendingInTree &amp;&amp; [component.attributes[<span class="string">@"append"</span>] isEqualToString:<span class="string">@"tree"</span>];</span><br><span class="line">    <span class="comment">// 再次递归的规则：如果父视图是一个树状结构，子视图即使也是一个树状结构，也不能再次Layout</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">NSDictionary</span> *subcomponentData <span class="keyword">in</span> subcomponentsData)&#123;</span><br><span class="line">        [<span class="keyword">self</span> _recursivelyAddComponent:subcomponentData toSupercomponent:component atIndex:<span class="number">-1</span> appendingInTree:appendTree || appendingInTree];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (appendTree) &#123;</span><br><span class="line">        <span class="comment">// 如果当前组件是树状结构，强制刷新layout，以防在syncQueue中堆积太多的同步任务。</span></span><br><span class="line">        [<span class="keyword">self</span> _layoutAndSyncUI];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在递归的添加子组件的时候，如果是树状结构，还需要再次强制进行一次layout，同步一次UI。这里调用[self _layoutAndSyncUI]方法和createRoot:时候实现是完全一样的，下面就不再赘述了。</p>
<p>这里会循环添加多个子视图，相应的也会调用多次Layout方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-d1f730e3bee34bdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="（三）createFinish"><a href="#（三）createFinish" class="headerlink" title="（三）createFinish"></a>（三）createFinish</h4><p>当所有的视图都添加完成以后，JSFramework就是再次调用callNative方法。</p>
<p>还是会传过来3个参数。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">instance:<span class="number">0</span>, </span><br><span class="line">tasks:(</span><br><span class="line">        &#123;</span><br><span class="line">        args =         (</span><br><span class="line">        );</span><br><span class="line">        method = createFinish;</span><br><span class="line">        module = dom;</span><br><span class="line">    &#125;</span><br><span class="line">), </span><br><span class="line">callback:<span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>callNative通过这个参数会调用到WXDomModule的createFinish方法。这里的具体实现见第一步的callNative，这里不再赘述。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performBlockOnComponentManager:^(WXComponentManager *manager) &#123;</span><br><span class="line">        [manager createFinish];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终也是会调用到WXComponentManager的createFinish。当然这里是会进行线程切换，切换到WXComponentManager的线程“com.taobao.weex.component”子线程上。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)createFinish</span><br><span class="line">&#123;</span><br><span class="line">    WXAssertComponentThread();</span><br><span class="line">    </span><br><span class="line">    WXSDKInstance *instance  = <span class="keyword">self</span>.weexInstance;</span><br><span class="line">    [<span class="keyword">self</span> _addUITask:^&#123;        </span><br><span class="line">        <span class="built_in">UIView</span> *rootView = instance.rootView;</span><br><span class="line">        </span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTFirstScreenRender, instance);</span><br><span class="line">        WX_MONITOR_INSTANCE_PERF_END(WXPTAllRender, instance);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTJSBridge);</span><br><span class="line">        WX_MONITOR_SUCCESS(WXMTNativeRender);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(instance.renderFinish)&#123;</span><br><span class="line">            instance.renderFinish(rootView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WXComponentManager的createFinish方法最后就是添加一个UI任务，回调到主线程的renderFinish方法里面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1194012-2896c636f11b2202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>至此，Weex的布局流程就完成了。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p><img src="http://upload-images.jianshu.io/upload_images/1194012-caf559cea2e73cb1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>虽然Autolayout是苹果原生就支持的自动布局方案，但是在稍微复杂的界面就会出现性能问题。大半年前，Draveness的这篇<a href="http://draveness.me/layout-performance/" rel="external nofollow noopener noreferrer" target="_blank">《从 Auto Layout 的布局算法谈性能》</a>文章里面也稍微“批判”了Autolayout的性能问题，但是文章里面最后提到的是用ASDK的方法来解决问题。本篇文章则献上另外一种可用的布局方法——FlexBox，并且带上了经过大量测试的测试数据，向大左的这篇经典文章致敬！</p>
<p>如今，iOS平台上几大可用的布局方法有：Frame原生布局，Autolayout原生自动布局，FlexBox的Yoga实现，ASDK。</p>
<p>当然，基于这4种基本方案以外，还有一些组合方法，比如Weex的这种，用JS的CSS解析成类似JSON的DOM，再调用Native的FlexBox算法进行布局。前段时间还有来自美团的<a href="http://tech.meituan.com/the_future_of_layout.html" rel="external nofollow noopener noreferrer" target="_blank">《布局编码的未来》</a>里面提到的毕加索（picasso）布局方法。原理也是会用到JSCore，将JS写的JSON或者自定义的DSL，经过本地的picassoEngine布局引擎转换成Native布局，最终利用锚点的概念做到高效的布局。</p>
<p>最后，推荐2个iOS平台上比较优秀的利用了FlexBox的原理的开源库：</p>
<p>来自Facebook的<strong><a href="https://github.com/facebook/yoga" rel="external nofollow noopener noreferrer" target="_blank">yoga</a></strong><br>来自饿了么的<strong><a href="https://github.com/LPD-iOS/FlexBoxLayout" rel="external nofollow noopener noreferrer" target="_blank">FlexBoxLayout</a></strong></p>
<hr>
<p>Weex 源码解析系列文章：</p>
<p><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_how_to_work_in_iOS.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 是如何在 iOS 客户端上跑起来的</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_layout_engine_powered_by_Flexbox&#39;s_algorithm.md" rel="external nofollow noopener noreferrer" target="_blank">由 FlexBox 算法强力驱动的 Weex 布局引擎</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_events.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 事件传递的那些事儿</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_ingenuity_JS_framework.md" rel="external nofollow noopener noreferrer" target="_blank">Weex 中别具匠心的 JS Framework</a><br><a href="https://github.com/halfrost/Halfrost-Field/blob/master/contents/iOS/Weex/Weex_pseudo-best_practices_for_iOS_developers.md" rel="external nofollow noopener noreferrer" target="_blank">iOS 开发者的 Weex 伪最佳实践指北</a>  </p>
<hr>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/Hybird/weex/weex_one/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    weex系列抄之一---环境搭建
                
            </div>
        </a>
    
    
        <a href="/wiki/Hybird/weex/weex_two/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">weex系列抄之二---weex原理</div>
        </a>
    
</nav>





    
    
        <section id="comments"> 
    <div class="ds-thread" data-thread-key="wiki/Hybird/weex/Weex_five/" data-title="weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎" data-url="http://yoursite.com/wiki/Hybird/weex/Weex_five/"></div>
    <style>
        #ds-thread #ds-reset .ds-textarea-wrapper {
            background: none;
        }
        #ds-reset .ds-avatar img {
            box-shadow: none;
        }
        #ds-reset .ds-gradient-bg {
            background: #f7f7f7;
        }
        #ds-thread #ds-reset li.ds-tab a {
            border-radius: 3px;
        }
        #ds-thread #ds-reset .ds-post-button {
            color: white;
            border: none;
            box-shadow: none;
            background: #d32;
            text-shadow: none;
            font-weight: normal;
            font-family: 'Microsoft Yahei';
        }
        #ds-thread #ds-reset .ds-post-button:hover {
            color: white;
            background: #DE594C;
        }
        #ds-thread #ds-reset .ds-post-button:active {
            background: #d32;
        }
        #ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current {
            color: white;
            background: #d32;
            box-shadow: none;
            text-shadow: none;
            font-weight: normal;
        }
    </style>
 </section>
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LJ &copy; 2018 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'lijian'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
