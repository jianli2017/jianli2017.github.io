<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>第三天——如何正确使用Runtime(转载) | LJ小窝</title>
    
    
        <meta name="keywords" content="runtime">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。">
<meta name="keywords" content="runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="第三天——如何正确使用Runtime(转载)">
<meta property="og:url" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/index.html">
<meta property="og:site_name" content="LJ小窝">
<meta property="og:description" content="到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay1.png">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay2.png">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay3.jpg">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay4.jpg">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay5.jpg">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay6.png">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay7.png">
<meta property="og:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay8.png">
<meta property="og:updated_time" content="2018-11-01T09:02:19.695Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="第三天——如何正确使用Runtime(转载)">
<meta name="twitter:description" content="到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。">
<meta name="twitter:image" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C%20Runtime入院系列文章/thirdDay/runtime_thirdDay1.png">
    

    
        <link rel="alternate" href="/atom.xml" title="LJ小窝" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LJ小窝</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++Primer
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第七章类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第七章类/类/">类</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第三章 字符串、向量、数组
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/">字符串、向量、数组</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第九章顺序容器
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第九章顺序容器/顺序容器/">顺序容器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章变量和基本类型
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/">变量和基本类型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第八章io库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第八章io库/IO库/">IO库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第六章函数
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第六章函数/函数/">函数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十三章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十三章/拷贝控制/">拷贝控制</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十九章特殊工具和技术
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/">特殊工具和技术</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十二章 动态内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十二章 动态内存/动态内存/">动态内存</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十五章 面向对象程序设计
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/">面向对象程序设计</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十六章 模板和泛型编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/">模板和泛型编程</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十四章/重载运算与类型转换/">重载运算与类型转换</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十章 泛型算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十章 泛型算法/泛型算法/">泛型算法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章 表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/表达式/">表达式</a></li>  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/运算符优先级表/">运算符优先级表</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            附录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/附录/关键字使用的位置/">关键字使用的位置</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++关键字理解
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++关键字理解/explicit-learn/">explicit实例浅析(转载)</a></li>  <li class="file"><a href="/wiki/C++语言/C++关键字理解/static/">static关键字作用总结(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            STL源码剖析
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第二章/空间配置器/">空间配置器</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/STL源码剖析/第四章/deque/">deque</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            container
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            deque
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/">deque的实现原理和使用方法详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            list
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/list/C++标准库中的list的实现原理/">C++标准库中的list的实现原理</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++语言/container/forward_list不支持push_back操作/">为什么`forward_list`不支持`push_back`操作？</a></li>  <li class="file"><a href="/wiki/C++语言/container/容器基本操作/">容器基本操作</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C语言语法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C语言语法/struct_Analize/">struct定义语法</a></li>  <li class="file"><a href="/wiki/C语言语法/CC_pointer_memry/">二级指针动态申请内存</a></li>  <li class="file"><a href="/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/">堆区（heap）和栈区（stack）的区别(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/union定义/">union定义(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Hybird
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            webview
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/webview/WKWebview/">通用webview开发记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            weex
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            桌面移动过来的资料
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            weex 文档
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/weex/桌面移动过来的资料/weex 文档/国美weex使用教程/"></a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/event-analize/">weex 事件原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-conmunication/">weex 通信原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-debug/">搭建weex断点调试环境</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            IOS
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ABTest
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ABTest
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/ABTest/ABTest/about/"></a></li>  <li class="file"><a href="/wiki/IOS/ABTest/ABTest/ABTest/">ABTest IOS SDK设计</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GCD
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/GCD/use-dispatch-semaphore/">dispatch_semaphore 的使用方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS12
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/IOS12/IOS12-compatibility/">IOS12 兼容</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            MachO
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/MachO/MachO_FileStructure/">Mach-O文件结构理解</a></li>  <li class="file"><a href="/wiki/IOS/MachO/machoviewer/">mach-o Viewer 源码学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Runtime
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            objc
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/objc/0_refer/">0. 参考资料</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/10_load_images/">10.load_images 函数分析</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/12_initialize/">12. 懒惰的 initialize 方法（转载）</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/13_class_initialize/">13. _class_initialize 源码分析</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/15_autoreleasepool/">15. 自动释放池的前世今生（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/14_AssociatedObject /">14. 关联对象 AssociatedObject 完全解析（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/11_load/">11. 你真的了解 load 方法么？</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/16_retain_release/">16. retain 和 release（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/17_weak/">17. weak 相关源码分析</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/18_syncsize/">18. @synchronized</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/4entsize_list_tt/">4. 方法列表entsize_list_tt结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/2_NSObject_objc_object/">2. class_data_bits_t 结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/1_NSObject_isa/">1. 从 NSObject 的初始化了解 isa（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/3NSObject/">3. NSObject 基本完整类图</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/5list_array_tt/">5. list_array_tt 结构详解</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/7_NXMapTable/">7. NXMapTable数据结构</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/6_NXHashTable/">6. 上古时代 Objective-C 中哈希表的实现(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/8__objc_init/">8. objc4入口函数</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/objc/9__read_images/">9. _read_images 从二进制文件中读取类信息</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            神经病院Objective-C Runtime入院系列文章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/firstDay/">第一天--isa和Class(转载)</a></li>  <li class="file active"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/">第三天——如何正确使用Runtime(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/secondDay/">第二天--消息发送与转发（转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            经典文章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/经典文章/Objective_C_Category/">深入理解Objective-C：Category(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/经典文章/meta_class/">Objective-C 中的元类（meta class）是什么？</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            crash
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/crash/1_system_Crash_Type/">1. 系统Crash日志结构介绍</a></li>  <li class="file"><a href="/wiki/IOS/crash/2_Collection_Crash/">2. 收集崩溃日志方法</a></li>  <li class="file"><a href="/wiki/IOS/crash/3_KSCrash_Analize/">3. KSCrash原理浅析</a></li>  <li class="file"><a href="/wiki/IOS/crash/5_increase_Wild_Pointer/">5. 如何定位Obj-C野指针随机Crash(二):让非必现Crash变成必现(转载)</a></li>  <li class="file"><a href="/wiki/IOS/crash/4_increase_Wild_Pointer/">4.如何定位Obj-C野指针随机Crash(一):先提高野指针Crash率(转载)</a></li>  <li class="file"><a href="/wiki/IOS/crash/7_increase_Wild_Pointer/">7. Scribble& NSZombieEnabled</a></li>  <li class="file"><a href="/wiki/IOS/crash/6_increase_Wild_Pointer/">6. 如何定位Obj-C野指针随机Crash(三)：加点黑科技让Crash自报家门(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            foundation使用记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSDateFormatter时间格式/">NSDateFormatter 时间格式</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/">NSInvocation的基本使</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSScaner/">NSScanner</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSURL记录/">NSURL记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            opensource
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            AFNetworking
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/opensource/AFNetworking/AFNetworking/">AFNetworking 源码浅析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JLRoute
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/opensource/JLRoute/JLRoute/">JLRoute学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            fishhook
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/opensource/fishhook/fishHookPicture/">图解fishhook</a></li>  <li class="file"><a href="/wiki/IOS/opensource/fishhook/learn_fishhook/">fishhook学习记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            logan
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/opensource/logan/logan/">logan 源码浅析</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            swiftUI
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/swiftUI/swiftUI/">Swift新特性</a></li>  <li class="file"><a href="/wiki/IOS/swiftUI/swiftUI_DataFlow/">SwiftUI 数据流理解</a></li>  <li class="file"><a href="/wiki/IOS/swiftUI/swiftUI_Share/">SwiftUI 分享内容</a></li>  <li class="file"><a href="/wiki/IOS/swiftUI/swiftUI_Share的副本/"></a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            swift语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            swift学习摘要
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/12__方法/">12. 方法</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/10__类和结构体/">10. 类和结构体</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/11__属性/">11. 属性</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/17__可选链/">17. 可选链</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/13__下标/">13. 下标</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/16__析构过程/">16. 析构过程</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/18__错误处理/">18. 错误处理</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/15__构造过程/">15. 构造过程</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/19__类型转换/">19. 类型转换</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/14__继承/">14. 继承</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/20__嵌套类型/">20. 嵌套类型</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/2__基础/">2. 基础</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/22__协议/">22. 协议</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/23__泛型/">23. 泛型</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/21__扩展/">21. 扩展</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/7__函数/">7. 函数</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/8__闭包/">7. 函数</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/24__自动引用计数器/">24. 自动引用计数器</a></li>  <li class="file"><a href="/wiki/IOS/swift语言/swift学习摘要/9__枚举/">1. 枚举</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/IOS/swift语言/swift使用经验/">swift 使用经验</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            事件处理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/事件处理/event/">iOS事件处理看我就够了(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            内存管理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/内存管理/内存学习/">内存学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            动态库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/动态库/static_lib_aggregate_script/">合并真机模拟器静态库(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            小码哥视频
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/小码哥视频/ios_jalebroke/">NSInvocation的基本使</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/库/组件化-库/">组件化-库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            暂无分类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/暂无分类/指定初始化函数/">正确使用NS_DESIGNATED_INITIALIZER</a></li>  <li class="file"><a href="/wiki/IOS/暂无分类/ios_sign/">iOS App 签名的原理([抄袭的，有问题请联系](http://wereadteam.github.io/2017/03/13/Signature/))</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            虚拟内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a></li>  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JS
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/JS/flexBox/">flexBox 伸缩盒子模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            linux命令
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/linux命令/export命令/">export命令</a></li>  <li class="file"><a href="/wiki/linux命令/set命令/">set命令</a></li>  <li class="file"><a href="/wiki/linux命令/特殊参数/">linux shell下的特殊用法及参数的说明</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cocoapods
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-learn-install/">cocoapod学习 安装和使用（1）</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-private-repo/">创建私有仓库</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/Cocoapods-new-spec/">Cocoapods-new-spec</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS模拟器安装app
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/">给IOS模拟器按照APP</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Xcode编译常量
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Xcode编译常量/xcode编译环境变量/">Xcode编译环境变量</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git简略版
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git简略版/git简略版/">Git笔记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git详细记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git详细记录/git仓库/">Git仓库(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git分支管理/">Git分支管理(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git工作区/">git时光穿梭(转载)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            hexo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/hexo/LaTex/">支持LaTEX的hexo博客</a></li>  <li class="file"><a href="/wiki/工具/hexo/hexo-use/">hexo使用指南</a></li>  <li class="file"><a href="/wiki/工具/hexo/自己搭建博客的经历/">自己搭建博客的经历</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            markdowm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/markdowm/Markdown公式编辑学习笔记/">Markdown公式编辑</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ruby
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具下载地址
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/工具下载地址/工具下载地址/">工具下载地址</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/工具/use_appledoc/">appledoc生成文档实践</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数学知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数学知识/经典数学文章/">经典数学文章</a></li>  <li class="file"><a href="/wiki/数学知识/数学基础知识/">数学知识一对数指数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据结构与算法
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据结构和算法之美
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据结构与算法/数据结构和算法之美/34_KMP/">KMP字符串查找</a></li>  <li class="file"><a href="/wiki/数据结构与算法/数据结构和算法之美/36_AC自动机/">AC自动机多模式匹配</a></li>  <li class="file"><a href="/wiki/数据结构与算法/数据结构和算法之美/38_分治思想/">分治思想</a></li>  <li class="file"><a href="/wiki/数据结构与算法/数据结构和算法之美/39_回溯思想/">39_回溯思想</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            算法4
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据结构与算法/算法4/about/">算法4</a></li>  <li class="file"><a href="/wiki/数据结构与算法/算法4/5_1_sort/">字符串排序</a></li>  <li class="file"><a href="/wiki/数据结构与算法/算法4/5_3_findSubString/">子字符串查找</a></li>  <li class="file"><a href="/wiki/数据结构与算法/算法4/5_2_search/">单词查找数</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            编程理论
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            OAuth 2.0
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程理论/OAuth 2.0/OAuth/">理解OAuth</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SSH
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程理论/SSH/ssh-theory/">图解SSH原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            mmap
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程理论/mmap/union定义的副本/">mmap原理之详解(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            正则表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程理论/正则表达式/正则表达式学习/">正则表达式学习摘要</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            资料收集
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            learn
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/资料收集/learn/学习资源/">学习计划&资源</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            notice
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/资料收集/notice/notice/">注意事项</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/Runtime/">Runtime</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/Runtime/神经病院Objective-C-Runtime入院系列文章/">神经病院Objective-C Runtime入院系列文章</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/runtime/">runtime</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/">
            <time datetime="2016-11-29T06:25:09.000Z" itemprop="datePublished">2016-11-29</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            第三天——如何正确使用Runtime(转载)
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#实现多继承Multiple-Inheritance"><span class="toc-number">1.</span> <span class="toc-text">实现多继承Multiple Inheritance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Method-Swizzling"><span class="toc-number">2.</span> <span class="toc-text">Method Swizzling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Swizzling原理"><span class="toc-number">2.1.</span> <span class="toc-text">Method Swizzling原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Swizzling使用"><span class="toc-number">2.2.</span> <span class="toc-text">Method Swizzling使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Swizzling注意点"><span class="toc-number">2.3.</span> <span class="toc-text">Method Swizzling注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Swizzling应该总在-load中执行"><span class="toc-number">2.3.1.</span> <span class="toc-text">Swizzling应该总在+load中执行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swizzling应该总是在dispatch-once中执行"><span class="toc-number">2.4.</span> <span class="toc-text">Swizzling应该总是在dispatch_once中执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Swizzling在-load中执行时，不要调用-super-load"><span class="toc-number">2.4.1.</span> <span class="toc-text">Swizzling在+load中执行时，不要调用[super load]</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#上述模板中没有错误"><span class="toc-number">2.4.2.</span> <span class="toc-text">上述模板中没有错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method-Swizzling使用场景"><span class="toc-number">2.5.</span> <span class="toc-text">Method Swizzling使用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现AOP"><span class="toc-number">2.5.1.</span> <span class="toc-text">实现AOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现埋点统计"><span class="toc-number">2.5.2.</span> <span class="toc-text">实现埋点统计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现异常保护"><span class="toc-number">2.5.3.</span> <span class="toc-text">实现异常保护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Aspect-Oriented-Programming"><span class="toc-number">3.</span> <span class="toc-text">Aspect Oriented Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intercepter注册"><span class="toc-number">3.1.</span> <span class="toc-text">Intercepter注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intercepter执行"><span class="toc-number">3.2.</span> <span class="toc-text">Intercepter执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Isa-Swizzling"><span class="toc-number">4.</span> <span class="toc-text">Isa Swizzling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#重写class方法"><span class="toc-number">4.1.</span> <span class="toc-text">重写class方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写setter方法"><span class="toc-number">4.2.</span> <span class="toc-text">重写setter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写dealloc方法"><span class="toc-number">4.3.</span> <span class="toc-text">重写dealloc方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写-isKVOA方法"><span class="toc-number">4.4.</span> <span class="toc-text">重写_isKVOA方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Associated-Object-关联对象"><span class="toc-number">5.</span> <span class="toc-text">Associated Object 关联对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用法"><span class="toc-number">5.1.</span> <span class="toc-text">用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#源码分析"><span class="toc-number">5.2.</span> <span class="toc-text">源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-setAssociatedObject方法"><span class="toc-number">5.2.1.</span> <span class="toc-text">objc_setAssociatedObject方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-getAssociatedObject方法"><span class="toc-number">5.2.2.</span> <span class="toc-text">objc_getAssociatedObject方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objc-removeAssociatedObjects方法"><span class="toc-number">5.2.3.</span> <span class="toc-text">objc_removeAssociatedObjects方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#动态的增加方法"><span class="toc-number">6.</span> <span class="toc-text">动态的增加方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSCoding的自动归档和自动解档"><span class="toc-number">7.</span> <span class="toc-text">NSCoding的自动归档和自动解档</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字典和模型互相转换"><span class="toc-number">8.</span> <span class="toc-text">字典和模型互相转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字典转模型"><span class="toc-number">8.1.</span> <span class="toc-text">字典转模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模型转字典"><span class="toc-number">8.2.</span> <span class="toc-text">模型转字典</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runtime缺点"><span class="toc-number">9.</span> <span class="toc-text">Runtime缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最后"><span class="toc-number">10.</span> <span class="toc-text">最后</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#涉及的资料"><span class="toc-number">11.</span> <span class="toc-text">涉及的资料</span></a></li></ol>
                </div>
            
        
        
            <p>到了今天终于要”出院”了，要总结一下住院几天的收获，谈谈Runtime到底能为我们开发带来些什么好处。当然它也是把双刃剑，使用不当的话，也会成为开发路上的一个大坑。<br><a id="more"></a></p>
<h2 id="实现多继承Multiple-Inheritance"><a href="#实现多继承Multiple-Inheritance" class="headerlink" title="实现多继承Multiple Inheritance"></a>实现多继承Multiple Inheritance</h2><p>在上一篇文章里面讲到的forwardingTargetForSelector:方法就能知道，一个类可以做到继承多个类的效果，只需要在这一步将消息转发给正确的类对象就可以模拟多继承的效果。</p>
<p>在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a>上记录了这样一段例子。<br><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay1.png" alt="多继承原理--  好像Warrior继承至Diplpmat,也继承至其本来的父类"><br>在OC程序中可以借用消息转发机制来实现多继承的功能。 在上图中，一个对象对一个消息做出回应，类似于另一个对象中的方法借过来或是“继承”过来一样。 在图中，warrior实例转发了一个negotiate消息到Diplomat实例中，执行Diplomat中的negotiate方法，结果看起来像是warrior实例执行了一个和Diplomat实例一样的negotiate方法，其实执行者还是Diplomat实例。</p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，这样一个类可以响应自己继承分支里面的方法，同时也能响应其他不相干类发过来的消息。在上图中Warrior和Diplomat没有继承关系，但是Warrior将negotiate消息转发给了Diplomat后，就好似Diplomat是Warrior的超类一样。</p>
<p>消息转发提供了许多类似于多继承的特性，但是他们之间有一个很大的不同：</p>
<ol>
<li>多继承：合并了不同的行为特征在一个单独的对象中，会得到一个重量级多层面的对象。</li>
<li>消息转发：将各个功能分散到不同的对象中，得到的一些轻量级的对象，这些对象通过消息转发联合起来。</li>
</ol>
<p>这里值得说明的一点是，即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开。像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个Warrior对象如果被问到是否能响应negotiate消息：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> ( [aWarrior <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(negotiate)] )</span><br></pre></td></tr></table></figure>
<p>结果是NO，虽然它能够响应negotiate消息而不报错，但是它是靠转发消息给Diplomat类来响应消息的。</p>
<p>如果非要制造假象，反应出这种“假”的继承关系，那么需要重新实现 respondsToSelector:和 isKindOfClass:来加入你的转发算法：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</span><br><span class="line"><span class="built_in">        return</span> YES;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /* Here, test whether <span class="keyword">the</span> aSelector message can     *</span><br><span class="line">         * be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  *</span><br><span class="line">         * object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  */</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">    return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了respondsToSelector:和 isKindOfClass:之外，instancesRespondToSelector:中也应该写一份转发算法。如果使用了协议，conformsToProtocol:也一样需要重写。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个methodSignatureForSelector:来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现methodSignatureForSelector:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (NSMethodSignature*)<span class="string">methodSignatureForSelector:</span>(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature* signature = [<span class="keyword">super</span> <span class="string">methodSignatureForSelector:</span>selector];</span><br><span class="line">    <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">        signature = [surrogate <span class="string">methodSignatureForSelector:</span>selector];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note:  This is an advanced technique, suitable only for situations where no other solution is possible. It is not intended as a replacement for inheritance. If you must make use of this technique, make sure you fully understand the behavior of the class doing the forwarding and the class you’re forwarding to.</p>
</blockquote>
<p>需要引起注意的一点，实现methodSignatureForSelector方法是一种先进的技术，只适用于没有其他解决方案的情况下。它不会作为继承的替代。如果您必须使用这种技术，请确保您完全理解类做的转发和您转发的类的行为。请勿滥用！</p>
<h2 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h2><p>提到Objective-C 中的 Runtime，大多数人第一个想到的可能就是黑魔法Method Swizzling。毕竟这是Runtime里面很强大的一部分，它可以通过Runtime的API实现更改任意的方法，理论上可以在运行时通过类名/方法名hook到任何 OC 方法，替换任何类的实现以及新增任意类。<br>举的最多的例子应该就是埋点统计用户信息的例子。<br>假设我们需要在页面上不同的地方统计用户信息，常见做法有两种： </p>
<ol>
<li>傻瓜式的在所有需要统计的页面都加上代码。这样做简单，但是重复的代码太多。 </li>
<li>把统计的代码写入基类中，比如说BaseViewController。这样虽然代码只需要写一次，但是</li>
</ol>
<p>UITableViewController，UICollectionViewcontroller都需要写一遍，这样重复的代码依旧不少。</p>
<p>基于这两点，我们这时候选用Method Swizzling来解决这个事情最优雅。</p>
<h3 id="Method-Swizzling原理"><a href="#Method-Swizzling原理" class="headerlink" title="Method Swizzling原理"></a>Method Swizzling原理</h3><p>Method Swizzing是发生在运行时的，主要用于在运行时将两个Method进行交换，我们可以将Method Swizzling代码写到任何地方，但是只有在这段Method Swilzzling代码执行完毕之后互换才起作用。而且Method Swizzling也是iOS中AOP(面相切面编程)的一种实现方式，我们可以利用苹果这一特性来实现AOP编程。<br>Method Swizzling本质上就是对IMP和SEL进行交换。</p>
<h3 id="Method-Swizzling使用"><a href="#Method-Swizzling使用" class="headerlink" title="Method Swizzling使用"></a>Method Swizzling使用</h3><p>一般我们使用都是新建一个分类，在分类中进行Method Swizzling方法的交换。交换的代码模板如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Swizzling</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">        <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">        SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line">        <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                            originalSelector,</span><br><span class="line">                                            method_getImplementation(swizzledMethod),</span><br><span class="line">                                            method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                                swizzledSelector,</span><br><span class="line">                                method_getImplementation(originalMethod),</span><br><span class="line">                                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>Method Swizzling可以在运行时通过修改类的方法列表中selector对应的函数或者设置交换方法实现，来动态修改方法。可以重写某个方法而不用继承，同时还可以调用原先的实现。所以通常应用于在category中添加一个方法。</p>
<p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay2.png" alt="方法调配的原理"></p>
<h3 id="Method-Swizzling注意点"><a href="#Method-Swizzling注意点" class="headerlink" title="Method Swizzling注意点"></a>Method Swizzling注意点</h3><h4 id="Swizzling应该总在-load中执行"><a href="#Swizzling应该总在-load中执行" class="headerlink" title="Swizzling应该总在+load中执行"></a>Swizzling应该总在+load中执行</h4><p>Objective-C在运行时会自动调用类的两个方法+load和+initialize。<font color="red" size="4" face="黑体">+load会在类初始加载时调用， +initialize方法是以懒加载的方式被调用的，</font>如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize方法是永远不会被调用的。所以Swizzling要是写在+initialize方法中，是有可能永远都不被执行。和+initialize比较+load能保证在类的初始化过程中被加载。</p>
<p>关于+load和+initialize的比较可以参看这篇文章<a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" rel="external nofollow noopener noreferrer" target="_blank">《Objective-C +load vs +initialize》</a></p>
<h3 id="Swizzling应该总是在dispatch-once中执行"><a href="#Swizzling应该总是在dispatch-once中执行" class="headerlink" title="Swizzling应该总是在dispatch_once中执行"></a>Swizzling应该总是在dispatch_once中执行</h3><p>Swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为Method Swizzling的最佳实践。<br>这里有一个很容易犯的错误，那就是继承中用了Swizzling。如果不写dispatch_once就会导致Swizzling失效！</p>
<p>举个例子，比如同时对NSArray和NSMutableArray中的objectAtIndex:方法都进行了Swizzling，这样可能会导致NSArray中的Swizzling失效的。</p>
<p>可是为什么会这样呢？ 原因是，我们没有用dispatch_once控制Swizzling只执行一次。如果这段Swizzling被执行多次，经过多次的交换IMP和SEL之后，结果可能就是未交换之前的状态。</p>
<p>比如说父类A的B方法和子类C的D方法进行交换，交换一次后，父类A持有D方法的IMP，子类C持有B方法的IMP，但是再次交换一次，就又还原了。父类A还是持有B方法的IMP，子类C还是持有D方法的IMP，这样就相当于咩有交换。可以看出，如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！</p>
<h4 id="Swizzling在-load中执行时，不要调用-super-load"><a href="#Swizzling在-load中执行时，不要调用-super-load" class="headerlink" title="Swizzling在+load中执行时，不要调用[super load]"></a>Swizzling在+load中执行时，不要调用[super load]</h4><p>原因同注意点二，如果是多继承，并且对同一个方法都进行了Swizzling，那么调用[super load]以后，父类的Swizzling就失效了。</p>
<h4 id="上述模板中没有错误"><a href="#上述模板中没有错误" class="headerlink" title="上述模板中没有错误"></a>上述模板中没有错误</h4><p>有些人怀疑我上述给的模板可能有错误。在这里需要讲解一下。<br>在进行Swizzling的时候，我们需要用class_addMethod先进行判断一下原有类中是否有要替换的方法的实现。<br>如果class_addMethod返回NO，说明当前类中有要替换方法的实现，所以可以直接进行替换，调用method_exchangeImplementations即可实现Swizzling。</p>
<p>如果class_addMethod返回YES，说明当前类中没有要替换方法的实现，我们需要在父类中去寻找。这个时候就需要用到method_getImplementation去获取class_getInstanceMethod里面的方法实现。然后再进行class_replaceMethod来实现Swizzling。这是Swizzling需要判断的一点。</p>
<p>还有一点需要注意的是，在我们替换的方法- (void)xxx_viewWillAppear:(BOOL)animated中，调用了[self xxx_viewWillAppear:animated];这不是死循环了么？</p>
<p>其实这里并不会死循环。 由于我们进行了Swizzling，所以其实在原来的- (void)viewWillAppear:(BOOL)animated方法中，调用的是- (void)xxx_viewWillAppear:(BOOL)animated方法的实现。所以不会造成死循环。相反的，如果这里把[self xxx_viewWillAppear:animated];改成[self viewWillAppear:animated];就会造成死循环。因为外面调用[self viewWillAppear:animated];的时候，会交换方法走到[self xxx_viewWillAppear:animated];这个方法实现中来，然后这里又去调用[self viewWillAppear:animated]，就会造成死循环了。</p>
<p>所以按照上述Swizzling的模板来写，就不会遇到这4点需要注意的问题啦。</p>
<h3 id="Method-Swizzling使用场景"><a href="#Method-Swizzling使用场景" class="headerlink" title="Method Swizzling使用场景"></a>Method Swizzling使用场景</h3><p>Method Swizzling使用场景其实有很多很多，在一些特殊的开发需求中适时的使用黑魔法，可以做法神来之笔的效果。这里就举3种常见的场景。</p>
<h4 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h4><p>AOP的例子在上一篇文章中举了一个例子，在下一章中也打算详细分析一下其实现原理，这里就一笔带过。</p>
<h4 id="实现埋点统计"><a href="#实现埋点统计" class="headerlink" title="实现埋点统计"></a>实现埋点统计</h4><p>如果app有埋点需求，并且要自己实现一套埋点逻辑，那么这里用到Swizzling是很合适的选择。优点在开头已经分析了，这里不再赘述。看到一篇分析的挺精彩的埋点的文章，推荐大家阅读。 <a href="http://www.jianshu.com/p/0497afdad36d" rel="external nofollow noopener noreferrer" target="_blank">iOS动态性(二)可复用而且高度解耦的用户统计埋点实现</a></p>
<h4 id="实现异常保护"><a href="#实现异常保护" class="headerlink" title="实现异常保护"></a>实现异常保护</h4><p>日常开发我们经常会遇到NSArray数组越界的情况，苹果的API也没有对异常保护，所以需要我们开发者开发时候多多留意。关于Index有好多方法，objectAtIndex，removeObjectAtIndex，replaceObjectAtIndex，exchangeObjectAtIndex等等，这些设计到Index都需要判断是否越界。</p>
<p>常见做法是给NSArray，NSMutableArray增加分类，增加这些异常保护的方法，不过如果原有工程里面已经写了大量的AtIndex系列的方法，去替换成新的分类的方法，效率会比较低。这里可以考虑用Swizzling做。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"NSArray+ Swizzling.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"objc/runtime.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSArray</span> (<span class="title">Swizzling</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    Method fromMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(objectAtIndex:));</span><br><span class="line">    Method toMethod = class_getInstanceMethod(objc_getClass(<span class="string">"__NSArrayI"</span>), <span class="keyword">@selector</span>(swizzling_objectAtIndex:));</span><br><span class="line">    method_exchangeImplementations(fromMethod, toMethod);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">id</span>)swizzling_objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.count<span class="number">-1</span> &lt; index) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> swizzling_objectAtIndex:index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// 打印崩溃信息</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"---------- %s Crash Because Method %s  ----------\n"</span>, class_getName(<span class="keyword">self</span>.class), __func__);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [exception callStackSymbols]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@finally</span> &#123;&#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> swizzling_objectAtIndex:index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>注意，调用这个objc_getClass方法的时候，要先知道类对应的真实的类名才行，NSArray其实在Runtime中对应着<strong>NSArrayI，NSMutableArray对应着</strong>NSArrayM，NSDictionary对应着<strong>NSDictionaryI，NSMutableDictionary对应着</strong>NSDictionaryM。</p>
<h2 id="Aspect-Oriented-Programming"><a href="#Aspect-Oriented-Programming" class="headerlink" title="Aspect Oriented Programming"></a>Aspect Oriented Programming</h2><p>Wikipedia 里对 AOP 是这么介绍的:</p>
<blockquote>
<p>An aspect can alter the behavior of the base code by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches).</p>
</blockquote>
<p>类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(Cross-cutting concern)，<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="external nofollow noopener noreferrer" target="_blank">AOP</a>作用就是分离横向关注点(Cross-cutting concern)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。</p>
<p>接下来分析分析AOP的工作原理。<br>在上一篇中我们分析过了，在objc_msgSend函数查找IMP的过程中，如果在父类也没有找到相应的IMP，那么就会开始执行_class_resolveMethod方法，如果不是元类，就执行_class_resolveInstanceMethod，如果是元类，执行_class_resolveClassMethod。在这个方法中，允许开发者动态增加方法实现。这个阶段一般是给@dynamic属性变量提供动态方法的。<br>如果_class_resolveMethod无法处理，会开始选择备援接受者接受消息，这个时候就到了forwardingTargetForSelector方法。如果该方法返回非nil的对象，则使用该对象作为新的消息接收者。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">forwardingTargetForSelector</span><span class="selector-pseudo">:(SEL)aSelector</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">if</span>(aSelector == <span class="variable">@selector</span>(<span class="attribute">Method</span>:))&#123;</span><br><span class="line">        <span class="selector-tag">return</span> <span class="selector-tag">otherObject</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[super forwardingTargetForSelector:aSelector]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样也可以替换类方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+ (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="meta">@selector(xxx)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> NSClassFromString(@<span class="string">"Class name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>替换类方法返回值就是一个类对象。</p>
<font color="red" size="4" face="黑体">forwardingTargetForSelector这种方法属于单纯的转发，无法对消息的参数和返回值进行处理。 </font><br>最后到了完整转发阶段。<br>Runtime系统会向对象发送methodSignatureForSelector:消息，并取到返回的方法签名用于生成NSInvocation对象。为接下来的完整的消息转发生成一个 NSMethodSignature对象。NSMethodSignature 对象会被包装成 NSInvocation 对象，forwardInvocation: 方法里就可以对 NSInvocation 进行处理了。<br><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为目标对象中被调用的方法返回一个NSMethodSignature实例</span></span><br><span class="line"><span class="selector-id">#warning</span> 运行时系统要求在执行标准转发时实现这个方法</span><br><span class="line"><span class="selector-tag">-</span> (NSMethodSignature *)<span class="selector-tag">methodSignatureForSelector</span><span class="selector-pseudo">:(SEL)sel</span>&#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-attr">[self.proxyTarget methodSignatureForSelector:sel]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><font color="red" size="4" face="黑体"> 对象需要创建一个NSInvocation对象，把消息调用的全部细节封装进去，包括selector, target, arguments 等参数，还能够对返回结果进行处理。</font>

<p>AOP的多数操作就是在forwardInvocation中完成的。一般会分为2个阶段:</p>
<ol>
<li>一个是Intercepter注册阶段</li>
<li>一个是Intercepter执行阶段。</li>
</ol>
<h3 id="Intercepter注册"><a href="#Intercepter注册" class="headerlink" title="Intercepter注册"></a>Intercepter注册</h3><p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay3.jpg" alt="注册"><br>首先会把类里面的某个要切片的方法的IMP加入到Aspect中，类方法里面如果有forwardingTargetForSelector:的IMP，也要加入到Aspect中。</p>
<p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay4.jpg" alt="交互方法"><br>然后对类的切片方法和forwardingTargetForSelector:的IMP进行替换。两者的IMP相应的替换为objc_msgForward()方法和hook过的forwardingTargetForSelector:。这样主要的Intercepter注册就完成了。</p>
<h3 id="Intercepter执行"><a href="#Intercepter执行" class="headerlink" title="Intercepter执行"></a>Intercepter执行</h3><p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay5.jpg" alt="交互方法"><br>当执行func()方法的时候，会去查找它的IMP，现在它的IMP已经被我们替换为了objc_msgForward()方法，于是开始查找备援转发对象。</p>
<p>查找备援接受者调用forwardingTargetForSelector:这个方法，由于这里是被我们hook过的，所以IMP指向的是hook过的forwardingTargetForSelector:方法。这里我们会返回Aspect的target，即选取Aspect作为备援接受者。<br>有了备援接受者之后，就会重新objc_msgSend，从消息发送阶段重头开始。<br>objc_msgSend找不到指定的IMP，再进行_class_resolveMethod，这里也没有找到，forwardingTargetForSelector:这里也不做处理，接着就会methodSignatureForSelector。在methodSignatureForSelector方法中创建一个NSInvocation对象，传递给最终的forwardInvocation方法。<br>Aspect里面的forwardInvocation方法会干所有切面的事情。这里转发逻辑就完全由我们自定义了。Intercepter注册的时候我们也加入了原来方法中的method()和forwardingTargetForSelector:方法的IMP，这里我们可以在forwardInvocation方法中去执行这些IMP。在执行这些IMP的前后都可以任意的插入任何IMP以达到切面的目的。</p>
<h2 id="Isa-Swizzling"><a href="#Isa-Swizzling" class="headerlink" title="Isa Swizzling"></a>Isa Swizzling</h2><p>前面第二点谈到了黑魔法Method Swizzling，本质上就是对IMP和SEL进行交换。其实接下来要说的Isa Swizzling，和它类似，本质上也是交换，不过交换的是Isa。<br>在苹果的官方库里面有一个很有名的技术就用到了这个Isa Swizzling，那就是KVO——Key-Value Observing。<br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" rel="external nofollow noopener noreferrer" target="_blank">Key-Value Observing Programming Guide</a>官方文档上对于KVO的定义是这样的:</p>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.<br>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.<br>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<p>官方给的就这么多，具体实现也没有说的很清楚。那只能我们自己来实验一下。<br>KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。<font color="red" size="4" face="黑体">所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。</font>具体实现应该是重写其setter方法即可。<br>官方是如何优雅的实现重写监听类的setter方法的呢？实验代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student *stu = [[Student alloc]init];</span><br><span class="line">    </span><br><span class="line">[stu <span class="string">addObserver:</span>self <span class="string">forKeyPath:</span>@<span class="string">"name"</span> <span class="string">options:</span>NSKeyValueObservingOptionNew <span class="string">context:</span>nil];</span><br></pre></td></tr></table></figure>
<p>我们可以打印观察isa指针的指向</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Printing description <span class="keyword">of</span> stu-&gt;isa:  </span><br><span class="line">Student  </span><br><span class="line">Printing description <span class="keyword">of</span> stu-&gt;isa:  </span><br><span class="line">NSKVONotifying_Student</span><br></pre></td></tr></table></figure>
<p>通过打印，我们可以很明显的看到，被观察的对象的isa变了，变成了NSKVONotifying_Student这个类了。</p>
<p>在@interface NSObject(NSKeyValueObserverRegistration) 这个分类里面，苹果定义了KVO的方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath context:(<span class="keyword">nullable</span> <span class="keyword">void</span> *)context <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_7, <span class="number">5</span>_0);</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObserver:(<span class="built_in">NSObject</span> *)observer forKeyPath:(<span class="built_in">NSString</span> *)keyPath;</span><br></pre></td></tr></table></figure>
<p>KVO在调用addObserver方法之后，苹果的做法是在执行完addObserver: forKeyPath: options: context: 方法之后，把isa指向到另外一个类去。<br>在这个新类里面重写被观察的对象四个方法。class，setter，dealloc，_isKVOA。</p>
<h3 id="重写class方法"><a href="#重写class方法" class="headerlink" title="重写class方法"></a>重写class方法</h3><p>重写class方法是为了我们调用它的时候返回跟重写继承类之前同样的内容。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * ClassMethodNames(Class c)  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> * array = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> methodCount = <span class="number">0</span>;</span><br><span class="line">    Method * methodList = class_copyMethodList(c, &amp;methodCount);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; methodCount; i++) &#123;</span><br><span class="line">        [array addObject: <span class="built_in">NSStringFromSelector</span>(method_getName(methodList[i]))];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    free(methodList);</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;  </span><br><span class="line">    </span><br><span class="line">    Student *stu = [[Student alloc]init];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">///添加观察者之前</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self-&gt;isa:%@"</span>,object_getClass(stu));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class:%@"</span>,[stu <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ClassMethodNames = %@"</span>,ClassMethodNames(object_getClass(stu)));</span><br><span class="line">    </span><br><span class="line">    [stu addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self-&gt;isa:%@"</span>,object_getClass(stu));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"self class:%@"</span>,[stu <span class="keyword">class</span>]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ClassMethodNames = %@"</span>,ClassMethodNames(object_getClass(stu)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>-&gt;<span class="symbol">isa:</span>Student  </span><br><span class="line"><span class="keyword">self</span> <span class="class"><span class="keyword">class</span>:<span class="title">Student</span>  </span></span><br><span class="line">ClassMethodNames = (  </span><br><span class="line"><span class="string">".cxx_destruct"</span>,</span><br><span class="line">name,  </span><br><span class="line"><span class="string">"setName:"</span></span><br><span class="line">)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">self</span>-&gt;<span class="symbol">isa:</span>NSKVONotifying_Student  </span><br><span class="line"><span class="keyword">self</span> <span class="class"><span class="keyword">class</span>:<span class="title">Student</span>  </span></span><br><span class="line">ClassMethodNames = (  </span><br><span class="line"><span class="string">"setName:"</span>,</span><br><span class="line"><span class="class"><span class="keyword">class</span>,  </span></span><br><span class="line">dealloc,  </span><br><span class="line"><span class="string">"_isKVOA"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里也可以看出，这是object_getClass方法和class方法的区别。</p>
<h3 id="重写setter方法"><a href="#重写setter方法" class="headerlink" title="重写setter方法"></a>重写setter方法</h3><p>在新的类中会重写对应的set方法，是为了在set方法中增加另外两个方法的调用：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>willChangeValueForKey:<span class="params">(NSString *)</span>key</span><br><span class="line">- <span class="params">(void)</span>didChangeValueForKey:<span class="params">(NSString *)</span>key</span><br></pre></td></tr></table></figure>
<p>在didChangeValueForKey:方法再调用</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- <span class="params">(void)</span>observeValueForKeyPath:<span class="params">(NSString *)</span>keyPath</span><br><span class="line">                      ofObject:<span class="params">(id)</span>object</span><br><span class="line">                        change:<span class="params">(NSDictionary *)</span>change</span><br><span class="line">                       context:<span class="params">(void *)</span>context</span><br></pre></td></tr></table></figure>
<p>这里有几种情况需要说明一下：</p>
<ol>
<li>如果使用了KVC<br>如果有访问器方法，则运行时会在setter方法中调用will/didChangeValueForKey:方法；<br>如果没用访问器方法，运行时会在setValue:forKey方法中调用will/didChangeValueForKey:方法。<br>所以这种情况下，KVO是奏效的。</li>
<li>有访问器方法<br>运行时会重写访问器方法调用will/didChangeValueForKey:方法。 因此，直接调用访问器方法改变属性值时，KVO也能监听到。</li>
<li>直接调用will/didChangeValueForKey:方法。</li>
</ol>
<p>综上所述，只要setter中重写will/didChangeValueForKey:方法就可以使用KVO了。</p>
<h3 id="重写dealloc方法"><a href="#重写dealloc方法" class="headerlink" title="重写dealloc方法"></a>重写dealloc方法</h3><p>销毁新生成的NSKVONotifying_类。</p>
<h3 id="重写-isKVOA方法"><a href="#重写-isKVOA方法" class="headerlink" title="重写_isKVOA方法"></a>重写_isKVOA方法</h3><p>这个私有方法估计可能是用来标示该类是一个 KVO 机制声称的类。</p>
<p>Foundation 到底为我们提供了哪些用于 KVO 的辅助函数。打开 terminal，使用 nm -a 命令查看 Foundation 中的信息：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm -a <span class="regexp">/System/</span>Library<span class="regexp">/Frameworks/</span>Foundation.framework<span class="regexp">/Versions/</span>C<span class="regexp">/Foundation</span></span><br></pre></td></tr></table></figure>
<p>里面包含了以下这些KVO中可能用到的函数</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000000233</span>e7 <span class="built_in">t</span> __NSSetDoubleValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f32ba <span class="built_in">t</span> __NSSetFloatValueAndNotify  </span><br><span class="line"><span class="number">0000000000025025</span> <span class="built_in">t</span> __NSSetIntValueAndNotify  </span><br><span class="line"><span class="number">000000000007</span>fbb5 <span class="built_in">t</span> __NSSetLongLongValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f33e8 <span class="built_in">t</span> __NSSetLongValueAndNotify  </span><br><span class="line"><span class="number">000000000002</span>d36c <span class="built_in">t</span> __NSSetObjectValueAndNotify  </span><br><span class="line"><span class="number">0000000000024</span>dc5 <span class="built_in">t</span> __NSSetPointValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f39ba <span class="built_in">t</span> __NSSetRangeValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3aeb <span class="built_in">t</span> __NSSetRectValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3512 <span class="built_in">t</span> __NSSetShortValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3c2f <span class="built_in">t</span> __NSSetSizeValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f363b <span class="built_in">t</span> __NSSetUnsignedCharValueAndNotify  </span><br><span class="line"><span class="number">000000000006</span>e91f <span class="built_in">t</span> __NSSetUnsignedIntValueAndNotify  </span><br><span class="line"><span class="number">0000000000034</span>b5b <span class="built_in">t</span> __NSSetUnsignedLongLongValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3766 <span class="built_in">t</span> __NSSetUnsignedLongValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3890 <span class="built_in">t</span> __NSSetUnsignedShortValueAndNotify  </span><br><span class="line"><span class="number">00000000000</span>f3060 <span class="built_in">t</span> __NSSetValueAndNotifyForKeyInIvar  </span><br><span class="line"><span class="number">00000000000</span>f30d7 <span class="built_in">t</span> __NSSetValueAndNotifyForUndefinedKey</span><br></pre></td></tr></table></figure>
<p>Foundation 提供了大部分基础数据类型的辅助函数（Objective C中的 Boolean 只是 unsigned char 的 typedef，所以包括了，但没有 C++中的 bool），此外还包括一些常见的结构体如 Point, Range, Rect, Size，这表明这些结构体也可以用于自动键值观察，但要注意除此之外的结构体就不能用于自动键值观察了。对于所有 Objective C 对象对应的是 __NSSetObjectValueAndNotify 方法。</p>
<p>KVO即使是苹果官方的实现，也是有缺陷的，这里有一篇文章详细了分析了<a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" rel="external nofollow noopener noreferrer" target="_blank">KVO中的缺陷</a>，主要问题在KVO的回调机制，不能传一个selector或者block作为回调，而必须重写-addObserver:forKeyPath:options:context:方法所引发的一系列问题。而且只监听一两个属性值还好，如果监听的属性多了, 或者监听了多个对象的属性, 那有点麻烦，需要在方法里面写很多的if-else的判断。<br>最后，官方文档上对于KVO的实现的最后，给出了需要我们注意的一点是，永远不要用用isa来判断一个类的继承关系，而是应该用class方法来判断类的实例。</p>
<h2 id="Associated-Object-关联对象"><a href="#Associated-Object-关联对象" class="headerlink" title="Associated Object 关联对象"></a>Associated Object 关联对象</h2><p>Associated Objects是Objective-C 2.0中Runtime的特性之一。众所周知，在 Category 中，我们无法添加@property，因为添加了@property之后并不会自动帮我们生成实例变量以及存取方法。那么，我们现在就可以通过关联对象来实现在 Category 中添加属性的功能了。</p>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>借用这篇经典文章<a href="http://nshipster.com/associated-objects/" rel="external nofollow noopener noreferrer" target="_blank">Associated Objects</a>里面的例子来说明一下用法。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NSObject+AssociatedObject.h</span></span><br><span class="line"><span class="variable">@interface</span> NSObject (AssociatedObject)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, strong) id associatedObject;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">// NSObject+AssociatedObject.m</span></span><br><span class="line"><span class="variable">@implementation</span> NSObject (AssociatedObject)</span><br><span class="line"><span class="variable">@dynamic</span> associatedObject;</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">setAssociatedObject</span><span class="selector-pseudo">:(id)object</span> &#123;</span><br><span class="line">    <span class="selector-tag">objc_setAssociatedObject</span>(self, <span class="variable">@selector</span>(associatedObject), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">-</span> (id)<span class="selector-tag">associatedObject</span> &#123;</span><br><span class="line">    <span class="selector-tag">return</span> <span class="selector-tag">objc_getAssociatedObject</span>(self, <span class="variable">@selector</span>(associatedObject));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了3个函数：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OBJC_EXPORT <span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)  </span></span><br><span class="line"><span class="function">    __<span class="title">OSX_AVAILABLE_STARTING</span>(<span class="params">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br><span class="line">	</span><br><span class="line"><span class="function">OBJC_EXPORT id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)  </span></span><br><span class="line"><span class="function">    __<span class="title">OSX_AVAILABLE_STARTING</span>(<span class="params">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br><span class="line">	</span><br><span class="line"><span class="function">OBJC_EXPORT <span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)  </span></span><br><span class="line"><span class="function">    __<span class="title">OSX_AVAILABLE_STARTING</span>(<span class="params">__MAC_10_6, __IPHONE_3_1</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>来说明一下这些参数的意义：</p>
<ol>
<li>id object 设置关联对象的实例对象</li>
<li><p>const void *key 区分不同的关联对象的 key。这里会有3种写法。</p>
<ol>
<li><p>使用 &amp;AssociatedObjectKey 作为key值</p>
<p> static char AssociatedObjectKey = “AssociatedKey”;</p>
</li>
<li><p>使用AssociatedKey 作为key值</p>
<p> static const void *AssociatedKey = “AssociatedKey”;</p>
</li>
<li><p>使用@selector</p>
<p> @selector(associatedKey)</p>
<p>3种方法都可以，不过推荐使用更加简洁的第三种方式。</p>
</li>
</ol>
</li>
<li><p>id value 关联的对象</p>
</li>
<li>objc_AssociationPolicy policy 关联对象的存储策略，它是一个枚举，与property的attribute 相对应。</li>
</ol>
<p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay6.png" alt="关联对象策略"></p>
<p>这里需要注意的是标记成OBJC_ASSOCIATION_ASSIGN的关联对象和 @property (weak) 是不一样的，上面表格中等价定义写的是 @property (unsafe_unretained)，对象被销毁时，属性值仍然还在。如果之后再次使用该对象就会导致程序闪退。所以我们在使用OBJC_ASSOCIATION_ASSIGN时，要格外注意。</p>
<blockquote>
<p>According to the Deallocation Timeline described in WWDC 2011, Session 322(~36:00), associated objects are erased surprisingly late in the object lifecycle, inobject_dispose(), which is invoked by NSObject -dealloc.</p>
</blockquote>
<p>关于关联对象还有一点需要说明的是objc_removeAssociatedObjects。这个方法是移除源对象中所有的关联对象，并不是其中之一。所以其方法参数中也没有传入指定的key。要删除指定的关联对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(<span class="name">self</span>, associatedKey, <span class="literal">nil</span>, OBJC_ASSOCIATION_COPY_NONATOMIC)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>关联对象3种使用场景</p>
<ol>
<li>为现有的类添加私有变量 </li>
<li>为现有的类添加公有属性 </li>
<li>为KVO创建一个关联的观察者。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="objc-setAssociatedObject方法"><a href="#objc-setAssociatedObject方法" class="headerlink" title="objc_setAssociatedObject方法"></a>objc_setAssociatedObject方法</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>set<span class="number">_</span>associative<span class="number">_</span>reference(id <span class="keyword">object</span>, <span class="keyword">void</span> *key, id <span class="keyword">value</span>, uintptr<span class="number">_</span>t policy) &#123;  </span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old<span class="number">_</span>association(<span class="number">0</span>, nil);</span><br><span class="line">    id <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span> = <span class="keyword">value</span> ? acquireValue(<span class="keyword">value</span>, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>) &#123;</span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;</span><br><span class="line">                associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line">                <span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old<span class="number">_</span>association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old<span class="number">_</span>association.hasValue()) ReleaseValue()(old<span class="number">_</span>association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数里面主要分为2部分，一部分是if里面对应的new_value不为nil的时候，另一部分是else里面对应的new_value为nil的情况。<br>当new_value不为nil的时候，查找时候，流程如下：</p>
<p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay7.png" alt="关联对象内存数据结构"></p>
<p>首先在AssociationsManager的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">spinlock_t</span> _lock;</span><br><span class="line">    <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    AssociationsManager()   &#123; _lock.lock(); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; _lock.unlock(); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AssociationsHashMap &amp;<span class="title">associations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_map == <span class="literal">NULL</span>)</span><br><span class="line">            _map = <span class="keyword">new</span> AssociationsHashMap();</span><br><span class="line">        <span class="keyword">return</span> *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在AssociationsManager中有一个spinlock类型的自旋锁lock。保证每次只有一个线程对AssociationsManager进行操作，保证线程安全。AssociationsHashMap对应的是一张哈希表。</p>
<p>AssociationsHashMap哈希表里面key是disguised_ptr_t。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br></pre></td></tr></table></figure>
<p>通过调用DISGUISE( )方法获取object地址的指针。拿到disguised_object后，通过这个key值，在AssociationsHashMap哈希表里面找到对应的value值。而这个value值ObjcAssociationMap表的首地址。</p>
<p>在ObjcAssociationMap表中，key值是set方法里面传过来的形参const void *key，value值是ObjcAssociation对象。</p>
<p>ObjcAssociation对象中存储了set方法最后两个参数，policy和value。</p>
<p>所以objc_setAssociatedObject方法中传的4个形参在上图中已经标出。</p>
<p>现在弄清楚结构之后再来看源码，就很容易了。objc_setAssociatedObject方法的目的就是在这2张哈希表中存储对应的键值对。</p>
<p>先初始化一个 AssociationsManager，获取唯一的保存关联对象的哈希表 AssociationsHashMap，然后在AssociationsHashMap里面去查找object地址的指针。</p>
<p>如果找到，就找到了第二张表ObjectAssociationMap。在这张表里继续查找object的key。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i != associations.end()) &#123;  </span><br><span class="line">    <span class="comment">// secondary table exists</span></span><br><span class="line">    O<span class="function"><span class="title">bjectAssociationMap</span> *refs = i-&gt;</span>second;</span><br><span class="line">    O<span class="function"><span class="title">bjectAssociationMap</span>::iterator j = refs-&gt;</span>find(key);</span><br><span class="line">    <span class="function"><span class="title">if</span> (j != refs-&gt;</span>end()) &#123;</span><br><span class="line">        <span class="function"><span class="title">old_association</span> = j-&gt;</span>second;</span><br><span class="line">        <span class="function"><span class="title">j</span>-&gt;</span>second = ObjcAssociation(policy, new_value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在第二张表ObjectAssociationMap找到对应的ObjcAssociation对象，那就更新它的值。如果没有找到，就新建一个ObjcAssociation对象，放入第二张表ObjectAssociationMap中。</p>
<p>再回到第一张表AssociationsHashMap中，如果没有找到对应的键值</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectAssociationMap *refs = <span class="keyword">new</span> ObjectAssociationMap;  </span><br><span class="line">associations[disguised<span class="number">_</span><span class="keyword">object</span>] = refs;  </span><br><span class="line">(*refs)[key] = ObjcAssociation(policy, <span class="keyword">new</span><span class="number">_</span><span class="keyword">value</span>);</span><br><span class="line"><span class="keyword">object</span>-&gt;setHasAssociatedObjects();</span><br></pre></td></tr></table></figure>
<p>此时就不存在第二张表ObjectAssociationMap了，这时就需要新建第二张ObjectAssociationMap表，来维护对象的所有新增属性。新建完第二张ObjectAssociationMap表之后，还需要再实例化 ObjcAssociation对象添加到 Map 中，调用setHasAssociatedObjects方法，表明当前对象含有关联对象。这里的setHasAssociatedObjects方法，改变的是isa_t结构体中的第二个标志位has_assoc的值。(关于isa_t结构体的结构，详情请看第一天的解析)</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line"> <span class="keyword">if</span> <span class="comment">(old_association.hasValue()</span>) ReleaseValue<span class="comment">()</span><span class="comment">(old_association)</span>;</span><br></pre></td></tr></table></figure>
<p>最后如果老的association对象有值，此时还会释放它。</p>
<p>以上是new_value不为nil的情况。其实只要记住上面那2张表的结构，这个objc_setAssociatedObject的过程就是更新 / 新建 表中键值对的过程。</p>
<p>再来看看new_value为nil的情况</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">AssociationsHashMap::iterator i = associations.find(disguised_object);  </span><br><span class="line"><span class="keyword">if</span> (i !=  associations.end()) &#123;  </span><br><span class="line">    O<span class="function"><span class="title">bjectAssociationMap</span> *refs = i-&gt;</span>second;</span><br><span class="line">    O<span class="function"><span class="title">bjectAssociationMap</span>::iterator j = refs-&gt;</span>find(key);</span><br><span class="line">    <span class="function"><span class="title">if</span> (j != refs-&gt;</span>end()) &#123;</span><br><span class="line">        <span class="function"><span class="title">old_association</span> = j-&gt;</span>second;</span><br><span class="line">        <span class="function"><span class="title">refs</span>-&gt;</span>erase(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当new_value为nil的时候，就是我们要移除关联对象的时候。这个时候就是在两张表中找到对应的键值，并调用erase( )方法，即可删除对应的关联对象。</p>
<h4 id="objc-getAssociatedObject方法"><a href="#objc-getAssociatedObject方法" class="headerlink" title="objc_getAssociatedObject方法"></a>objc_getAssociatedObject方法</h4><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id _object_get_associative_reference(<span class="name">id</span> object, void *key) &#123;  </span><br><span class="line">    id value = nil;</span><br><span class="line">    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">        if (i != associations.end()) &#123;</span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second<span class="comment">;</span></span><br><span class="line">            ObjectAssociationMap:<span class="symbol">:iterator</span> j = refs-&gt;find(<span class="name">key</span>)<span class="comment">;</span></span><br><span class="line">            if (<span class="name">j</span> != refs-&gt;end()) &#123;</span><br><span class="line">                ObjcAssociation <span class="symbol">&amp;entry</span> = j-&gt;second<span class="comment">;</span></span><br><span class="line">                value = entry.value()<span class="comment">;</span></span><br><span class="line">                policy = entry.policy()<span class="comment">;</span></span><br><span class="line">                if (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_RETAIN) ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_retain)<span class="comment">;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (<span class="name">value</span> <span class="symbol">&amp;&amp;</span> (<span class="name">policy</span> &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) &#123;</span><br><span class="line">        ((<span class="name">id</span>(<span class="name">*</span>)(<span class="name">id</span>, SEL))objc_msgSend)(<span class="name">value</span>, SEL_autorelease)<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    return value<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>objc_getAssociatedObject方法 很简单。就是通过遍历AssociationsHashMap哈希表 和 ObjcAssociationMap表的所有键值找到对应的ObjcAssociation对象，找到了就返回ObjcAssociation对象，没有找到就返回nil。</p>
<h4 id="objc-removeAssociatedObjects方法"><a href="#objc-removeAssociatedObjects方法" class="headerlink" title="objc_removeAssociatedObjects方法"></a>objc_removeAssociatedObjects方法</h4><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc<span class="number">_</span>removeAssociatedObjects(id <span class="keyword">object</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">object</span> &amp;&amp; <span class="keyword">object</span>-&gt;hasAssociatedObjects()) &#123;</span><br><span class="line">        <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(<span class="keyword">object</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">void</span> <span class="number">_</span><span class="keyword">object</span><span class="number">_</span>remove<span class="number">_</span>assocations(id <span class="keyword">object</span>) &#123;  </span><br><span class="line">    vector&lt; ObjcAssociation,ObjcAllocator&lt;ObjcAssociation&gt; &gt; elements;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        <span class="keyword">if</span> (associations.size() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        disguised<span class="number">_p</span>tr<span class="number">_</span>t disguised<span class="number">_</span><span class="keyword">object</span> = DISGUISE(<span class="keyword">object</span>);</span><br><span class="line">        AssociationsHashMap::iterator i = associations.find(disguised<span class="number">_</span><span class="keyword">object</span>);</span><br><span class="line">        <span class="keyword">if</span> (i != associations.end()) &#123;</span><br><span class="line">            <span class="comment">// copy all of the associations that need to be removed.</span></span><br><span class="line">            ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">            <span class="keyword">for</span> (ObjectAssociationMap::iterator j = refs-&gt;begin(), end = refs-&gt;end(); j != end; ++j) &#123;</span><br><span class="line">                elements.push<span class="number">_</span>back(j-&gt;second);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the secondary table.</span></span><br><span class="line">            delete refs;</span><br><span class="line">            associations.erase(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the calls to releaseValue() happen outside of the lock.</span></span><br><span class="line">    <span class="keyword">for</span><span class="number">_</span>each(elements.begin(), elements.end(), ReleaseValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在移除关联对象object的时候，会先去判断object的isa_t中的第二位has_assoc的值，当object 存在并且object-&gt;hasAssociatedObjects( )值为1的时候，才会去调用_object_remove_assocations方法。</p>
<p>_object_remove_assocations方法的目的是删除第二张ObjcAssociationMap表，即删除所有的关联对象。删除第二张表，就需要在第一张AssociationsHashMap表中遍历查找。这里会把第二张ObjcAssociationMap表中所有的ObjcAssociation对象都存到一个数组elements里面，然后调用associations.erase( )删除第二张表。最后再遍历elements数组，把ObjcAssociation对象依次释放。</p>
<p>以上就是Associated Object关联对象3个函数的源码分析。</p>
<h2 id="动态的增加方法"><a href="#动态的增加方法" class="headerlink" title="动态的增加方法"></a>动态的增加方法</h2><p>在消息发送阶段，如果在父类中也没有找到相应的IMP，就会执行resolveInstanceMethod方法。在这个方法里面，我们可以动态的给类对象或者实例对象动态的增加方法。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (BOOL)<span class="string">resolveInstanceMethod:</span>(SEL)sel &#123;</span><br><span class="line">    </span><br><span class="line">    NSString *selectorString = NSStringFromSelector(sel);</span><br><span class="line">    <span class="keyword">if</span> ([selectorString <span class="string">isEqualToString:</span>@<span class="string">"method1"</span>]) &#123;</span><br><span class="line">        class_addMethod(self.<span class="keyword">class</span>, <span class="meta">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">"@:"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> <span class="string">resolveInstanceMethod:</span>sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于方法操作方面的函数还有以下这些</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现</span></span><br><span class="line">id method_invoke ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span>  </span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现</span></span><br><span class="line">void method_invoke_stret ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span>  </span><br><span class="line"><span class="comment">// 获取方法名</span></span><br><span class="line">SEL method_getName ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line">IMP method_getImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="keyword">const</span> char * method_getTypeEncoding ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line">char * method_copyReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line">char * method_copyArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span> );</span>  </span><br><span class="line"><span class="comment">// 通过引用返回方法的返回值类型字符串</span></span><br><span class="line">void method_getReturnType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span>  </span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line">unsigned int method_getNumberOfArguments ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 通过引用返回方法指定位置参数的类型字符串</span></span><br><span class="line">void method_getArgumentType ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">index</span>, <span class="title">char</span> *<span class="title">dst</span>, <span class="title">size_t</span> <span class="title">dst_len</span> );</span>  </span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line">struct objc_method_description * method_getDescription ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span>  </span><br><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line">IMP method_setImplementation ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, <span class="title">IMP</span> <span class="title">imp</span> );</span>  </span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line">void method_exchangeImplementations ( <span class="function"><span class="keyword">Method</span> <span class="title">m1</span>, <span class="title">Method</span> <span class="title">m2</span> );</span></span><br></pre></td></tr></table></figure>
<p>这些方法其实平时不需要死记硬背，使用的时候只要先打出method开头，后面就会有补全信息，找到相应的方法，传入对应的方法即可。</p>
<h2 id="NSCoding的自动归档和自动解档"><a href="#NSCoding的自动归档和自动解档" class="headerlink" title="NSCoding的自动归档和自动解档"></a>NSCoding的自动归档和自动解档</h2><p>现在虽然手写归档和解档的时候不多了，但是自动操作还是用Runtime来实现的。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</span><br><span class="line">    [aCoder encodeObject:<span class="keyword">self</span>.name forKey:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = [aDecoder decodeObjectForKey:<span class="string">@"name"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动的有一个缺陷，如果属性多起来，要写好多行相似的代码，虽然功能是可以完美实现，但是看上去不是很优雅。<br>用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"Student.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line">	</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Student</span></span></span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">void</span>)encodeWithCoder:(<span class="built_in">NSCoder</span> *)aCoder&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        Ivar var = vars[i];</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">        <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">id</span> value = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line">        [aCoder encodeObject:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">- (<span class="keyword">nullable</span> __kindof)initWithCoder:(<span class="built_in">NSCoder</span> *)aDecoder&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        Ivar *vars = class_copyIvarList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">            Ivar var = vars[i];</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = ivar_getName(var);</span><br><span class="line">            <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:name];</span><br><span class="line">            <span class="keyword">id</span> value = [aDecoder decodeObjectForKey:key];</span><br><span class="line">            [<span class="keyword">self</span> setValue:value forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>class_copyIvarList方法用来获取当前 Model 的所有成员变量，ivar_getName方法用来获取每个成员变量的名称。</p>
<h2 id="字典和模型互相转换"><a href="#字典和模型互相转换" class="headerlink" title="字典和模型互相转换"></a>字典和模型互相转换</h2><h3 id="字典转模型"><a href="#字典转模型" class="headerlink" title="字典转模型"></a>字典转模型</h3><ol>
<li>调用 class_getProperty 方法获取当前 Model 的所有属性。 </li>
<li>调用 property_copyAttributeList 获取属性列表。 </li>
<li>根据属性名称生成 setter 方法。 </li>
<li>使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">id</span>)objectWithKeyValues:(<span class="built_in">NSDictionary</span> *)aDictionary&#123;</span><br><span class="line">    <span class="keyword">id</span> objc = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> aDictionary.allKeys) &#123;</span><br><span class="line">        <span class="keyword">id</span> value = aDictionary[key];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*判断当前属性是不是Model*/</span></span><br><span class="line">        objc_property_t property = class_getProperty(<span class="keyword">self</span>, key.UTF8String);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        objc_property_attribute_t *attributeList = property_copyAttributeList(property, &amp;outCount);</span><br><span class="line">        objc_property_attribute_t attribute = attributeList[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *typeString = [<span class="built_in">NSString</span> stringWithUTF8String:attribute.value];</span><br><span class="line">	</span><br><span class="line">        <span class="keyword">if</span> ([typeString isEqualToString:<span class="string">@"@\"Student\""</span>]) &#123;</span><br><span class="line">            value = [<span class="keyword">self</span> objectWithKeyValues:value];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成setter方法，并用objc_msgSend调用</span></span><br><span class="line">        <span class="built_in">NSString</span> *methodName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@%@:"</span>,[key substringToIndex:<span class="number">1</span>].uppercaseString,[key substringFromIndex:<span class="number">1</span>]];</span><br><span class="line">        SEL <span class="keyword">setter</span> = sel_registerName(methodName.UTF8String);</span><br><span class="line">        <span class="keyword">if</span> ([objc respondsToSelector:<span class="keyword">setter</span>]) &#123;</span><br><span class="line">            ((<span class="keyword">void</span> (*) (<span class="keyword">id</span>,SEL,<span class="keyword">id</span>)) objc_msgSend) (objc,<span class="keyword">setter</span>,value);</span><br><span class="line">        &#125;</span><br><span class="line">        free(attributeList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> objc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码里面有一处判断typeString的，这里判断是防止model嵌套，比如说Student里面还有一层Student，那么这里就需要再次转换一次，当然这里有几层就需要转换几次。</p>
<p>几个出名的开源库JSONModel、MJExtension等都是通过这种方式实现的(利用runtime的class_copyIvarList获取属性数组，遍历模型对象的所有成员属性，根据属性名找到字典中key值进行赋值，当然这种方法只能解决NSString、NSNumber等，如果含有NSArray或NSDictionary，还要进行第二步转换，如果是字典数组，需要遍历数组中的字典，利用objectWithDict方法将字典转化为模型，在将模型放到数组中，最后把这个模型数组赋值给之前的字典数组)</p>
<p><img src="/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/runtime_thirdDay8.png" alt="字典转model示意图"></p>
<h3 id="模型转字典"><a href="#模型转字典" class="headerlink" title="模型转字典"></a>模型转字典</h3><p>这里是上一部分字典转模型的逆步骤：</p>
<ol>
<li>调用 class_copyPropertyList 方法获取当前 Model 的所有属性。 </li>
<li>调用 property_getName 获取属性名称。 </li>
<li>根据属性名称生成 getter 方法。 </li>
<li>使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模型转字典</span></span><br><span class="line">-(<span class="built_in">NSDictionary</span> *)keyValuesWithObject&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">    objc_property_t *propertyList = class_copyPropertyList([<span class="keyword">self</span> <span class="keyword">class</span>], &amp;outCount);</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i ++) &#123;</span><br><span class="line">        objc_property_t property = propertyList[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//生成getter方法，并用objc_msgSend调用</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">        SEL <span class="keyword">getter</span> = sel_registerName(propertyName);</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = ((<span class="keyword">id</span> (*) (<span class="keyword">id</span>,SEL)) objc_msgSend) (<span class="keyword">self</span>,<span class="keyword">getter</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">/*判断当前属性是不是Model*/</span></span><br><span class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="keyword">self</span> <span class="keyword">class</span>]] &amp;&amp; value) &#123;</span><br><span class="line">                value = [value keyValuesWithObject];</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:propertyName];</span><br><span class="line">                [dict setObject:value forKey:key];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    free(propertyList);</span><br><span class="line">    <span class="keyword">return</span> dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中间注释那里的判断也是防止model嵌套，如果model里面还有一层model，那么model转字典的时候还需要再次转换，同样，有几层就需要转换几次。<br>不过上述的做法是假设字典里面不再包含二级字典，如果还包含数组，数组里面再包含字典，那还需要多级转换。这里有一个关于字典里面包含数组的demo.</p>
<h2 id="Runtime缺点"><a href="#Runtime缺点" class="headerlink" title="Runtime缺点"></a>Runtime缺点</h2><p>看了上面八大点之后，是不是感觉Runtime很神奇，可以迅速解决很多问题，然而，Runtime就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：<a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What are the Dangers of Method Swizzling in Objective C?</a>，它的危险性主要体现以下几个方面：</p>
<p>Method swizzling is not atomic</p>
<p>Method swizzling不是原子性操作。如果在+load方法里面写，是没有问题的，但是如果写在+initialize方法中就会出现一些奇怪的问题。</p>
<p>Changes behavior of un-owned code</p>
<p>如果你在一个类中重写一个方法，并且不调用super方法，你可能会导致一些问题出现。在大多数情况下，super方法是期望被调用的（除非有特殊说明）。如果你使用同样的思想来进行Swizzling，可能就会引起很多问题。如果你不调用原始的方法实现，那么你Swizzling改变的太多了，而导致整个程序变得不安全。</p>
<p>Possible naming conflicts</p>
<p>命名冲突是程序开发中经常遇到的一个问题。我们经常在类别中的前缀类名称和方法名称。不幸的是，命名冲突是在我们程序中的像一种瘟疫。一般我们会这样写Method Swizzling</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> <span class="attribute">NSView </span>: NSObject</span><br><span class="line">- (void)<span class="attribute">setFrame</span>:(NSRect)frame;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line">	</span><br><span class="line"><span class="variable">@implementation</span> NSView (MyViewAdditions)</span><br><span class="line">	</span><br><span class="line">- (void)<span class="attribute">my_setFrame</span>:(NSRect)frame &#123;</span><br><span class="line">    <span class="comment">// do custom work</span></span><br><span class="line">    <span class="selector-attr">[self my_setFrame:frame]</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    <span class="selector-attr">[self swizzle:@selector(setFrame:) with:@selector(my_setFrame:)]</span>;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure>
<p>这样写看上去是没有问题的。但是如果在整个大型程序中还有另外一处定义了my_setFrame:方法呢？那又会造成命名冲突的问题。我们应该把上面的Swizzling改成以下这种样子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSView</span> (<span class="title">MyViewAdditions</span>)</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MySetFrame(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame);  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> (*SetFrameIMP)(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame);</span><br><span class="line">	</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MySetFrame(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSRect</span> frame) &#123;  </span><br><span class="line">    <span class="comment">// do custom work</span></span><br><span class="line">    SetFrameIMP(<span class="keyword">self</span>, _cmd, frame);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzle:<span class="keyword">@selector</span>(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP];</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>虽然上面的代码看上去不是OC(因为使用了函数指针)，但是这种做法确实有效的防止了命名冲突的问题。原则上来说，其实上述做法更加符合标准化的Swizzling。这种做法可能和人们使用方法不同，但是这种做法更好。Swizzling Method 标准定义应该是如下的样子：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">typedef IMP *IMPPointer;</span><br><span class="line">	</span><br><span class="line">BOOL class_swizzleMethodAndStore(<span class="class"><span class="keyword">Class</span> <span class="title">class</span>, <span class="title">SEL</span> <span class="title">original</span>, <span class="title">IMP</span> <span class="title">replacement</span>, <span class="title">IMPPointer</span> <span class="title">store</span>) &#123;  </span></span><br><span class="line">    IMP imp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="function"><span class="keyword">Method</span> <span class="title">method</span> =</span> class_getInstanceMethod(<span class="class"><span class="keyword">class</span>, <span class="title">original</span>);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="function"><span class="keyword">method</span>) &#123;</span></span><br><span class="line">        <span class="keyword">const</span> char *type = method_getTypeEncoding(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">        imp = class_replaceMethod(<span class="class"><span class="keyword">class</span>, <span class="title">original</span>, <span class="title">replacement</span>, <span class="title">type</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (!imp) &#123;</span><br><span class="line">            imp = method_getImplementation(<span class="function"><span class="keyword">method</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (imp &amp;&amp; store) &#123; *store = imp; &#125;</span><br><span class="line">    <span class="keyword">return</span> (imp != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">@implementation NSObject (FRRuntimeAdditions)</span><br><span class="line">+ (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123;</span><br><span class="line">    <span class="keyword">return</span> class_swizzleMethodAndStore(<span class="built_in">self</span>, original, replacement, store);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>Swizzling changes the method’s arguments</p>
<p>这一点是这些问题中最大的一个。标准的Method Swizzling是不会改变方法参数的。使用Swizzling中，会改变传递给原来的一个函数实现的参数，例如</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[self my_setFrame:frame]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>会变转换成</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">objc_msgSend</span>(self, <span class="variable">@selector</span>(<span class="attribute">my_setFrame</span>:), frame);</span><br></pre></td></tr></table></figure>
<p>objcmsgSend会去查找mysetFrame对应的IMP。一旦IMP找到，会把相同的参数传递进去。这里会找到最原始的setFrame:方法，调用执行它。但是这里的cmd参数并不是setFrame:，现在是mysetFrame:。原始的方法就被一个它不期待的接收参数调用了。这样并不好。</p>
<p>这里有一个简单的解决办法，上一条里面所说的，用函数指针去实现。参数就不会变了。</p>
<p>The order of swizzles matters<br>调用顺序对于Swizzling来说，很重要。假设setFrame:方法仅仅被定义在NSView类里面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSButton <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_buttonSetFrame:</span>)];</span><br><span class="line">[NSControl <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_controlSetFrame:</span>)];</span><br><span class="line">[NSView <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_viewSetFrame:</span>)];</span><br></pre></td></tr></table></figure>
<p>当NSButton被swizzled之后会发生什么呢？大多数的swizzling应该保证不会替换setFrame:方法。因为一旦改了这个方法，会影响下面所有的View。所以它会去拉取实例方法。NSButton会使用已经存在的方法去重新定义setFrame:方法。以至于改变了IMP实现不会影响所有的View。相同的事情也会发生在对NSControl进行swizzling的时候，同样，IMP也是定义在NSView类里面，把NSControl 和 NSButton这上下两行swizzle顺序替换，结果也是相同的。</p>
<p>当调用NSButton的setFrame:方法，会去调用swizzled method，然后会跳入NSView类里面定义的setFrame:方法。NSControl 和 NSView对应的swizzled method不会被调用。</p>
<p>NSButton 和 NSControl各自调用各自的 swizzling方法，相互不会影响。</p>
<p>但是我们改变一下调用顺序，把NSView放在第一位调用。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[NSView <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_viewSetFrame:</span>)];</span><br><span class="line">[NSControl <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_controlSetFrame:</span>)];</span><br><span class="line">[NSButton <span class="string">swizzle:</span><span class="meta">@selector</span>(<span class="string">setFrame:</span>) <span class="string">with:</span><span class="meta">@selector</span>(<span class="string">my_buttonSetFrame:</span>)];</span><br></pre></td></tr></table></figure>
<p>一旦这里的NSView先进行了swizzling了以后，情况就和上面大不相同了。NSControl的swizzling会去拉取NSView替换后的方法。相应的，NSControl在NSButton前面，NSButton也会去拉取到NSControl替换后的方法。这样就十分混乱了。但是顺序就是这样排列的。我们开发中如何能保证不出现这种混乱呢？</p>
<p>再者，在load方法中加载swizzle。如果仅仅是在已经加载完成的class中做了swizzle，那么这样做是安全的。load方法能保证父类会在其任何子类加载方法之前，加载相应的方法。这就保证了我们调用顺序的正确性。</p>
<p>Difficult to understand (looks recursive)</p>
<p>看着传统定义的swizzled method，我认为很难去预测会发生什么。但是对比上面标准的swizzling，还是很容易明白。这一点已经被解决了。</p>
<p>Difficult to debug</p>
<p>在调试中，会出现奇怪的堆栈调用信息，尤其是swizzled的命名很混乱，一切方法调用都是混乱的。对比标准的swizzled方式，你会在堆栈中看到清晰的命名方法。swizzling还有一个比较难调试的一点， 在于你很难记住当前确切的哪个方法已经被swizzling了。</p>
<p>在代码里面写好文档注释，即使你认为这段代码只有你一个人会看。遵循这个方式去实践，你的代码都会没问题。它的调试也没有多线程的调试困难。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>经过在“神经病院”3天的修炼之后，对OC 的Runtime理解更深了。</p>
<p>关于黑魔法Method swizzling，我个人觉得如果使用得当，还是很安全的。一个简单而安全的措施是你仅仅只在load方法中去swizzle。和编程中很多事情一样，不了解它的时候会很危险可怕，但是一旦明白了它的原理之后，使用它又会变得非常正确高效。</p>
<p>对于多人开发，尤其是改动过Runtime的地方，文档记录一定要完整。如果某人不知道某个方法被Swizzling了，出现问题调试起来，十分蛋疼。</p>
<p>如果是SDK开发，某些Swizzling会改变全局的一些方法的时候，一定要在文档里面标注清楚，否则使用SDK的人不知道，出现各种奇怪的问题，又要被坑好久。</p>
<p>在合理使用 + 文档完整齐全 的情况下，解决特定问题，使用Runtime还是非常简洁安全的。</p>
<p>日常可能用的比较多的Runtime函数可能就是下面这些</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取cls类对象所有成员ivar结构体</span></span><br><span class="line">Ivar *class_copyIvarList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)  </span><br><span class="line"><span class="comment">//获取cls类对象name对应的实例方法结构体</span></span><br><span class="line">Method class_getInstanceMethod(Class cls, SEL name)  </span><br><span class="line"><span class="comment">//获取cls类对象name对应类方法结构体</span></span><br><span class="line">Method class_getClassMethod(Class cls, SEL name)  </span><br><span class="line"><span class="comment">//获取cls类对象name对应方法imp实现</span></span><br><span class="line">IMP class_getMethodImplementation(Class cls, SEL name)  </span><br><span class="line"><span class="comment">//测试cls对应的实例是否响应sel对应的方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_respondsToSelector(Class cls, SEL sel)  </span><br><span class="line"><span class="comment">//获取cls对应方法列表</span></span><br><span class="line">Method *class_copyMethodList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)  </span><br><span class="line"><span class="comment">//测试cls是否遵守protocol协议</span></span><br><span class="line"><span class="built_in">BOOL</span> class_conformsToProtocol(Class cls, Protocol *protocol)  </span><br><span class="line"><span class="comment">//为cls类对象添加新方法</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)  </span><br><span class="line"><span class="comment">//替换cls类对象中name对应方法的实现</span></span><br><span class="line">IMP class_replaceMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)  </span><br><span class="line"><span class="comment">//为cls添加新成员</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addIvar(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, size_t size, uint8_t alignment, <span class="keyword">const</span> <span class="keyword">char</span> *types)  </span><br><span class="line"><span class="comment">//为cls添加新属性</span></span><br><span class="line"><span class="built_in">BOOL</span> class_addProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)  </span><br><span class="line"><span class="comment">//获取m对应的选择器</span></span><br><span class="line">SEL method_getName(Method m)  </span><br><span class="line"><span class="comment">//获取m对应的方法实现的imp指针</span></span><br><span class="line">IMP method_getImplementation(Method m)  </span><br><span class="line"><span class="comment">//获取m方法的对应编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *method_getTypeEncoding(Method m)  </span><br><span class="line"><span class="comment">//获取m方法参数的个数</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> method_getNumberOfArguments(Method m)  </span><br><span class="line"><span class="comment">//copy方法返回值类型</span></span><br><span class="line"><span class="keyword">char</span> *method_copyReturnType(Method m)  </span><br><span class="line"><span class="comment">//获取m方法index索引参数的类型</span></span><br><span class="line"><span class="keyword">char</span> *method_copyArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)  </span><br><span class="line"><span class="comment">//获取m方法返回值类型</span></span><br><span class="line"><span class="keyword">void</span> method_getReturnType(Method m, <span class="keyword">char</span> *dst, size_t dst_len)  </span><br><span class="line"><span class="comment">//获取方法的参数类型</span></span><br><span class="line"><span class="keyword">void</span> method_getArgumentType(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, size_t dst_len)  </span><br><span class="line"><span class="comment">//设置m方法的具体实现指针</span></span><br><span class="line">IMP method_setImplementation(Method m, IMP imp)  </span><br><span class="line"><span class="comment">//交换m1，m2方法对应具体实现的函数指针</span></span><br><span class="line"><span class="keyword">void</span> method_exchangeImplementations(Method m1, Method m2)  </span><br><span class="line"><span class="comment">//获取v的名称</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getName(Ivar v)  </span><br><span class="line"><span class="comment">//获取v的类型编码</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ivar_getTypeEncoding(Ivar v)  </span><br><span class="line"><span class="comment">//设置object对象关联的对象</span></span><br><span class="line"><span class="keyword">void</span> objc_setAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">id</span> value, objc_AssociationPolicy policy)  </span><br><span class="line"><span class="comment">//获取object关联的对象</span></span><br><span class="line"><span class="keyword">id</span> objc_getAssociatedObject(<span class="keyword">id</span> object, <span class="keyword">const</span> <span class="keyword">void</span> *key)  </span><br><span class="line"><span class="comment">//移除object关联的对象</span></span><br><span class="line"><span class="keyword">void</span> objc_removeAssociatedObjects(<span class="keyword">id</span> object)</span><br></pre></td></tr></table></figure>
<p>这些API看上去不好记，其实使用的时候不难，关于方法操作的，一般都是method开头，关于类的，一般都是class开头的，其他的基本都是objc开头的，剩下的就看代码补全的提示，看方法名基本就能找到想要的方法了。当然很熟悉的话，可以直接打出指定方法，也不会依赖代码补全。</p>
<p>还有一些关于协议相关的API以及其他一些不常用，但是也可能用到的，就需要查看Objective-C Runtime官方API文档，这个官方文档里面详细说明，平时不懂的多看看文档。</p>
<h2 id="涉及的资料"><a href="#涉及的资料" class="headerlink" title="涉及的资料"></a>涉及的资料</h2><ol>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Programming Guide</a></li>
<li><a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" rel="external nofollow noopener noreferrer" target="_blank">《Objective-C +load vs +initialize》</a></li>
<li><a href="http://www.jianshu.com/p/0497afdad36d" rel="external nofollow noopener noreferrer" target="_blank">iOS动态性(二)可复用而且高度解耦的用户统计埋点实现</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html" rel="external nofollow noopener noreferrer" target="_blank">Key-Value Observing Programming Guide</a></li>
<li><a href="https://www.mikeash.com/pyblog/key-value-observing-done-right.html" rel="external nofollow noopener noreferrer" target="_blank">KVO中的缺陷</a></li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" rel="external nofollow noopener noreferrer" target="_blank">What are the Dangers of Method Swizzling in Objective C?</a></li>
</ol>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/IOS/Runtime/经典文章/Objective_C_Category/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    深入理解Objective-C：Category(转载)
                
            </div>
        </a>
    
    
        <a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">NSInvocation的基本使</div>
        </a>
    
</nav>





    
    
        <section id="comments"> 
    <div class="ds-thread" data-thread-key="wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/" data-title="第三天——如何正确使用Runtime(转载)" data-url="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C Runtime入院系列文章/thirdDay/"></div>
    <style>
        #ds-thread #ds-reset .ds-textarea-wrapper {
            background: none;
        }
        #ds-reset .ds-avatar img {
            box-shadow: none;
        }
        #ds-reset .ds-gradient-bg {
            background: #f7f7f7;
        }
        #ds-thread #ds-reset li.ds-tab a {
            border-radius: 3px;
        }
        #ds-thread #ds-reset .ds-post-button {
            color: white;
            border: none;
            box-shadow: none;
            background: #d32;
            text-shadow: none;
            font-weight: normal;
            font-family: 'Microsoft Yahei';
        }
        #ds-thread #ds-reset .ds-post-button:hover {
            color: white;
            background: #DE594C;
        }
        #ds-thread #ds-reset .ds-post-button:active {
            background: #d32;
        }
        #ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current {
            color: white;
            background: #d32;
            box-shadow: none;
            text-shadow: none;
            font-weight: normal;
        }
    </style>
 </section>
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LJ &copy; 2019 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'lijian'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
