<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>神经病院Objective-C Runtime入院第一天——isa和Class(转载) | LJ小窝</title>
    
    
        <meta name="keywords" content="runtime">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="本文转载自神经病院Objective-C Runtime入院第一天——isa和Class。Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。">
<meta name="keywords" content="runtime">
<meta property="og:type" content="article">
<meta property="og:title" content="神经病院Objective-C Runtime入院第一天——isa和Class(转载)">
<meta property="og:url" content="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/index.html">
<meta property="og:site_name" content="LJ小窝">
<meta property="og:description" content="本文转载自神经病院Objective-C Runtime入院第一天——isa和Class。Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime1.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime2.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime3.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/meta-class1.png">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime4.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime5.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime6.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime7.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime8.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime9.jpg">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime10.png">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime11.png">
<meta property="og:image" content="http://of685p9vy.bkt.clouddn.com/runtime12.png">
<meta property="og:updated_time" content="2018-02-28T08:39:10.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="神经病院Objective-C Runtime入院第一天——isa和Class(转载)">
<meta name="twitter:description" content="本文转载自神经病院Objective-C Runtime入院第一天——isa和Class。Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了。">
<meta name="twitter:image" content="http://of685p9vy.bkt.clouddn.com/runtime1.jpg">
    

    
        <link rel="alternate" href="/atom.xml" title="LJ小窝" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LJ小窝</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++Premer
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十三章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Premer/第十三章/拷贝控制/">拷贝控制</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++关键字
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++关键字/static/">static关键字作用总结(转载)</a></li>  <li class="file"><a href="/wiki/C++语言/C++关键字/explicit-learn/">explicit实例浅析(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            container
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            deque
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/">deque的实现原理和使用方法详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            list
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/list/C++标准库中的list的实现原理/">C++标准库中的list的实现原理</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++语言/container/forward_list不支持push_back操作/">为什么`forward_list`不支持`push_back`操作？</a></li>  <li class="file"><a href="/wiki/C++语言/container/容器基本操作/">容器基本操作</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            运算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/运算法/运算符优先级表/">运算符优先级表</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C语言语法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C语言语法/struct_Analize/">struct定义语法</a></li>  <li class="file"><a href="/wiki/C语言语法/CC_pointer_memry/">二级指针动态申请内存</a></li>  <li class="file"><a href="/wiki/C语言语法/union定义/">union定义(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/">堆区（heap）和栈区（stack）的区别(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Hybird
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            webview
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/webview/gome-Webview/">通用webview开发记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            weex
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/weex/event-analize/">weex 事件原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-conmunication/">weex 通信原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-debug/">搭建weex断点调试环境</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            IOS
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Category
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Category/深入理解Objective-C：Category/">深入理解Objective-C：Category(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GCD
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/GCD/use-dispatch-semaphore/">dispatch_semaphore 的使用方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Mach_O
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Mach_O/Mach_O_File_Struct/">Mach-o文件结构理解</a></li>  <li class="file"><a href="/wiki/IOS/Mach_O/machoviewer/">mach-o Viewer 源码学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            Runtime
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/meta_class/">What is a meta-class in Objective-C(译文)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/Objective-C-消息发送与转发机制原理/">Objective-C 消息发送与转发机制原理</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/runtime1/">runtime1</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime住院第二天——消息发送与转发（转载/">神经病院Objective-C Runtime住院第二天——消息发送与转发（转载)</a></li>  <li class="file active"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/">神经病院Objective-C Runtime入院第一天——isa和Class(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime-转载/">神经病院Objective-C Runtime出院第三天——如何正确使用Runtime(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            crash
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/crash/Analize_Crash/">收集、符号化IOS崩溃日志</a></li>  <li class="file"><a href="/wiki/IOS/crash/KSCrash_Analize/">KSCrash崩溃收集原理浅析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            foundation使用记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/">NSInvocation的基本使</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSDateFormatter时间格式/">NSDateFormatter 时间格式</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            事件处理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/事件处理/iOS事件处理/">iOS事件处理看我就够了(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            内存管理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/内存管理/内存学习/">内存学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            动态库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/动态库/static_lib_aggregate_script/">合并真机模拟器静态库(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            开源库学习
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            fishhook
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/fishHookPicture/">图解fishhook</a></li>  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/learn_fishhook/">fishhook学习记录</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            暂无分类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/暂无分类/指定初始化函数/">正确使用NS_DESIGNATED_INITIALIZER</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            虚拟内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a></li>  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JS
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/JS/flexBox/">flexBox 伸缩盒子模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cocoapods
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Cocoapods/Cocoapods-new-spec/">Cocoapods-new-spec</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-learn-install/">cocoapod学习 安装和使用（1）</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-private-repo/">创建私有仓库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS模拟器安装app
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/">给IOS模拟器按照APP</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SSH
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/SSH/ssh-theory/">图解SSH原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Xcode编译常量
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Xcode编译常量/xcode编译环境变量/">Xcode编译环境变量</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git简略版
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git简略版/git简略版/">Git笔记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git详细记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git详细记录/git仓库/">Git仓库(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git工作区/">git时光穿梭(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git分支管理/">Git分支管理(转载)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            hexo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/hexo/LaTex/">支持LaTEX的hexo博客</a></li>  <li class="file"><a href="/wiki/工具/hexo/hexo-use/">hexo使用指南</a></li>  <li class="file"><a href="/wiki/工具/hexo/自己搭建博客的经历/">自己搭建博客的经历</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            markdowm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/markdowm/Markdown公式编辑学习笔记/">Markdown公式编辑</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ruby
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具下载地址
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/工具下载地址/工具下载地址/">工具下载地址</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据知识/数学基础知识/">数学知识一对数指数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            编程基础
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            正则表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程基础/正则表达式/正则表达式学习/">正则表达式学习摘要</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/IOS/">IOS</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/IOS/Runtime/">Runtime</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/runtime/">runtime</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/">
            <time datetime="2016-11-18T01:50:28.000Z" itemprop="datePublished">2016-11-18</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            神经病院Objective-C Runtime入院第一天——isa和Class(转载)
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Runtime简介"><span class="toc-number">1.</span> <span class="toc-text">Runtime简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#通过-Objective-C-源代码"><span class="toc-number">1.1.</span> <span class="toc-text">通过 Objective-C 源代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过-Foundation-框架的-NSObject-类定义的方法"><span class="toc-number">1.2.</span> <span class="toc-text">通过 Foundation 框架的 NSObject 类定义的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过对-Runtime-库函数的直接调用"><span class="toc-number">1.3.</span> <span class="toc-text">通过对 Runtime 库函数的直接调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NSObject起源"><span class="toc-number">2.</span> <span class="toc-text">NSObject起源</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#isa-t结构体的具体实现"><span class="toc-number">2.1.</span> <span class="toc-text">isa_t结构体的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cache-t的具体实现"><span class="toc-number">2.2.</span> <span class="toc-text">cache_t的具体实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-data-bits-t的具体实现"><span class="toc-number">2.3.</span> <span class="toc-text">class_data_bits_t的具体实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#入院考试"><span class="toc-number">3.</span> <span class="toc-text">入院考试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#self-class-与-super-class"><span class="toc-number">3.1.</span> <span class="toc-text">[self class] 与 [super class]</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#isKindOfClass-与-isMemberOfClass"><span class="toc-number">3.2.</span> <span class="toc-text">isKindOfClass 与 isMemberOfClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class与内存地址"><span class="toc-number">3.3.</span> <span class="toc-text">Class与内存地址</span></a></li></ol></li></ol>
                </div>
            
        
        
            <p>本文转载自<a href="https://halfrost.com/objc_runtime_isa_class/" rel="external nofollow noopener noreferrer" target="_blank">神经病院Objective-C Runtime入院第一天——isa和Class</a>。Runtime又叫运行时，是一套底层的C语言API，是iOS系统的核心之一。<font color="red" size="4" face="黑体">开发者在编码过程中，可以给任意一个对象发送消息，在编译阶段只是确定了要向接收者发送这条消息，而接受者将要如何响应和处理这条消息，那就要看运行时来决定了</font>。<br><a id="more"></a></p>
<h1 id="Runtime简介"><a href="#Runtime简介" class="headerlink" title="Runtime简介"></a>Runtime简介</h1><p>C语言中，在编译期，函数的调用就会决定调用哪个函数。而OC的函数，属于动态调用过程，在编译期并不能决定真正调用哪个函数，只有在真正运行时才会根据函数的名称找到对应的函数来调用。<font color="red" size="4" face="黑体">编译时向接受者发送消息，运行时找到函数调用</font><br>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。<br>Objc 在三种层面上与 Runtime 系统进行交互：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime1.jpg" alt="runtime1"></p>
<h2 id="通过-Objective-C-源代码"><a href="#通过-Objective-C-源代码" class="headerlink" title="通过 Objective-C 源代码"></a>通过 Objective-C 源代码</h2><p>一般情况开发者只需要编写 OC 代码即可，Runtime<font color="red" size="4" face="黑体">系统自动在幕后把我们写的源代码在编译阶段转换成运行时代码</font> ，在运行时确定对应的数据结构和调用具体哪个方法。</p>
<h2 id="通过-Foundation-框架的-NSObject-类定义的方法"><a href="#通过-Foundation-框架的-NSObject-类定义的方法" class="headerlink" title="通过 Foundation 框架的 NSObject 类定义的方法"></a>通过 Foundation 框架的 NSObject 类定义的方法</h2><p>在OC的世界中，除了NSProxy类以外，所有的类都是NSObject的子类。在Foundation框架下，NSObject和NSProxy两个基类，定义了类层次结构中该类下方所有类的公共接口和行为。NSProxy是专门用于实现代理对象的类，这个类暂时本篇文章不提。这两个类都遵循了NSObject协议。在NSObject协议中，声明了所有OC对象的公共方法。</p>
<p>在NSObject协议中，有以下5个方法，是可以从Runtime中获取信息，让对象进行自我检查。</p>
<pre><code>- (Class)class OBJC_SWIFT_UNAVAILABLE(&quot;use &apos;anObject.dynamicType&apos; instead&quot;);
- (BOOL)isKindOfClass:(Class)aClass;
- (BOOL)isMemberOfClass:(Class)aClass;
- (BOOL)conformsToProtocol:(Protocol *)aProtocol;
- (BOOL)respondsToSelector:(SEL)aSelector;
</code></pre><p>-class方法返回对象的类；<br>-isKindOfClass: 和 -isMemberOfClass: 方法检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)；<br>-respondsToSelector: 检查对象能否响应指定的消息；<br>-conformsToProtocol:检查对象是否实现了指定协议类的方法；</p>
<p>在NSObject的类中还定义了一个方法</p>
<pre><code>- (IMP)methodForSelector:(SEL)aSelector;
</code></pre><p>这个方法会返回指定方法实现的地址IMP。</p>
<p>以上这些方法会在本篇文章中详细分析具体实现。</p>
<h2 id="通过对-Runtime-库函数的直接调用"><a href="#通过对-Runtime-库函数的直接调用" class="headerlink" title="通过对 Runtime 库函数的直接调用"></a>通过对 Runtime 库函数的直接调用</h2><p>关于库函数可以在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" rel="external nofollow noopener noreferrer" target="_blank">Objective-C Runtime Reference</a>中查看 Runtime 函数的详细文档。</p>
<p>关于这一点，其实还有一个小插曲。当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，那些函数里面的参数和描述都没有了。对于熟悉Runtime的开发者来说，这并没有什么难的，因为参数早已铭记于胸。但是对于新手来说，这是相当不友好的。而且，如果是从iOS6开始开发的同学，依稀可能能感受到，关于Runtime的具体实现的官方文档越来越少了？可能还怀疑是不是错觉。其实从Xcode5开始，苹果就不建议我们手动调用Runtime的API，也同样希望我们不要知道具体底层实现。所以IDE上面默认代了一个参数，禁止了Runtime的代码提示，源码和文档方面也删除了一些解释。</p>
<p>具体设置如下:<br><img src="http://of685p9vy.bkt.clouddn.com/runtime2.jpg" alt="runtime2"><br>如果发现导入了两个库文件之后，仍然没有代码提示，就需要把这里的设置改成NO，即可。</p>
<h1 id="NSObject起源"><a href="#NSObject起源" class="headerlink" title="NSObject起源"></a>NSObject起源</h1><p>由上面一章节，我们知道了与Runtime交互有3种方式，前两种方式都与NSObject有关，那我们就从NSObject基类开始说起。以下源码分析均来自<a href="https://github.com/xuhong1105/objc4-680" rel="external nofollow noopener noreferrer" target="_blank">objc4-680</a><br>NSObject的定义如下:</p>
<pre><code>typedef struct objc_class *Class;

@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
}
</code></pre><p>在Objc2.0之前，objc_class源码如下：</p>
<pre><code>struct objc_class {  
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;
</code></pre><p>在这里可以看到，在一个类中，有超类的指针，类名，版本的信息。 ivars是objc_ivar_list成员变量列表的指针；methodLists是指向objc_method_list指针的指针。*methodLists是指向方法列表的指针。这表明可以通过动态修改*methodLists的值来实现添加成员方法的目的，这也是Category实现的原理，同样解释了Category不能添加属性的原因。</p>
<p>关于Category，这里推荐2篇文章可以仔细研读一下。<br><a href="http://tech.meituan.com/DiveIntoCategory.html" rel="external nofollow noopener noreferrer" target="_blank">深入理解Objective-C：Category</a><br><a href="http://www.jianshu.com/p/d66d65314add" rel="external nofollow noopener noreferrer" target="_blank">结合 Category 工作原理分析 OC2.0 中的 runtime</a></p>
<p>然后在2006年苹果发布Objc 2.0之后，objc_class的定义就变成下面这个样子了。</p>
<pre><code>typedef struct objc_class *Class;  
typedef struct objc_object *id;

@interface Object { 
    Class isa; 
}

@interface NSObject &lt;NSObject&gt; {
    Class isa  OBJC_ISA_AVAILABILITY;
}

struct objc_object {  
private:  
    isa_t isa;
}

struct objc_class : objc_object {  
    // Class ISA;
    Class superclass;
    cache_t cache;             // formerly cache pointer and vtable
    class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags
}

union isa_t  
{
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }
    Class cls;
    uintptr_t bits;
}
</code></pre><p><img src="http://of685p9vy.bkt.clouddn.com/runtime3.jpg" alt="runtime3"><br>把源码的定义转化成类图，就是上图的样子。</p>
<p>从上述源码中，我们可以看到，<font color="red" size="4" face="黑体">Objective-C 对象都是 C 语言结构体实现的</font>，在objc2.0中，所有的<font color="red" size="4" face="黑体">对象都会包含一个isa_t类型的结构体</font>。</p>
<p>objc_object被源码typedef成了id类型，这也就是我们平时遇到的id类型。这个结构体中就只包含了一个isa_t类型的结构体。这个结构体在下面会详细分析。</p>
<p>objc_class继承于objc_object。所以在objc_class中也会包含isa_t类型的结构体isa。至此，可以得出结论：<font color="red" size="4" face="黑体">Objective-C 中类也是一个对象。在objc_class中，除了isa之外，还有3个成员变量，一个是父类的指针，一个是方法缓存，最后一个这个类的实例方法表。</font></p>
<p>object类和NSObject类里面分别都包含一个objc_class类型的isa。<br>上图的左半边类的关系描述完了，接着先从isa来说起。<br>当一个对象的实例方法被调用的时候，会通过isa找到相应的类，然后在该类的class_data_bits_t中去查找方法。<font color="red" size="4" face="黑体">class_data_bits_t是指向了类对象的数据区域。在该数据区域内查找相应方法的对应实现。</font><br>但是在我们调用类方法的时候，类对象的isa里面是什么呢？这里为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。<br>关于元类，更多具体可以研究这篇文章<a href="https://jianli2017.github.io/2016/11/12/runtime/meta_class/" rel="external nofollow noopener noreferrer" target="_blank">What is a meta-class in Objective-C（译文）?</a></p>
<font color="red" size="4" face="黑体">在引入元类之后，类对象和对象查找方法的机制就完全统一了。<br>调用对象的实例方法时，通过对象的 isa 在类中获取方法的实现。调用类对象的类方法时，通过类的isa指针在元类中获取方法的实现。<br>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</font>

<p>对应关系的图如下图，下图很好的描述了对象，类，元类之间的关系:<br><img src="http://of685p9vy.bkt.clouddn.com/meta-class1.png" alt="meta-class"><br>图中实线是 super_class指针，虚线是isa指针。</p>
<ol>
<li>Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。</li>
<li>每个Class都有一个isa指针指向唯一的元类（Meta class）。</li>
<li>Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。</li>
<li>每个Meta class的isa指针都指向Root class (meta)。</li>
</ol>
<p>我们其实应该明白，类对象和元类对象是唯一的，对象是可以在运行时创建无数个的。而在main方法执行之前，从 dyld到runtime这期间，类对象和元类对象在这期间被创建。具体可看sunnyxx这篇<a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" rel="external nofollow noopener noreferrer" target="_blank">iOS 程序 main 函数之前发生了什么</a></p>
<h2 id="isa-t结构体的具体实现"><a href="#isa-t结构体的具体实现" class="headerlink" title="isa_t结构体的具体实现"></a>isa_t结构体的具体实现</h2><p>接下来我们就该研究研究isa的具体实现了。objc_object里面的isa是isa_t类型。通过查看源码，我们可以知道isa_t是一个union联合体。</p>
<pre><code>union isa_t 
{
    // 构造函数
    isa_t() { }
    isa_t(uintptr_t value) : bits(value) { }

    Class cls;
    uintptr_t bits;

    struct {
        uintptr_t indexed           : 1; // 0表示普通的isa指针 1表示优化过的，存储引用计数
        uintptr_t has_assoc         : 1; // 对象是否包含 associated object，如果没有，析构时会更快
        uintptr_t has_cxx_dtor      : 1; // 是否有C++或ARC的析构函数，如果没有，析构时会更快
        uintptr_t shiftcls          : 33; // 最重要的原来的Class cls部分，占33个bit，与 ISA_MASK 进行 &amp; 操作可以得到  // MACH_VM_MAX_ADDRESS 0x1000000000
        uintptr_t magic             : 6; // 用于调试时分辨对象是否完成初始化
        uintptr_t weakly_referenced : 1; // 对象是否有过weak引用，如果没有，析构时会更快
        uintptr_t deallocating      : 1; // 对象是否正在析构
        uintptr_t has_sidetable_rc  : 1; // 表示对象的引用计数过大，无法存储在isa指针，只能存在side table中
        uintptr_t extra_rc          : 19; // 存储引用计数，不过好像是减 1 后的值，可以在 rootRetainCount 方法中看到
        // 在 64 位环境下，优化的 isa 指针并不是就一定会存储引用计数，毕竟用 19bit （iOS 系统）保存引用计数不一定够。需要注意的是这 19 位保存的是引用计数的值减一。has_sidetable_rc 的值如果为 1，那么引用计数会存储在一个叫 SideTable 的类的属性中。
#       define RC_ONE   (1ULL&lt;&lt;45) // 左移 45 bit，正好是extra_rc 所在的位置
#       define RC_HALF  (1ULL&lt;&lt;18) // extra_rc 总共是19位，RC_HALF是18位，也就是全部引用计数的一半
    };
 }


struct objc_object {  
private:  
    isa_t isa;
public:  
    // initIsa() should be used to init the isa of new objects only.
    // If this object already has an isa, use changeIsa() for correctness.
    // initInstanceIsa(): objects with no custom RR/AWZ
    void initIsa(Class cls /*indexed=false*/);
    void initInstanceIsa(Class cls, bool hasCxxDtor);
private:  
    void initIsa(Class newCls, bool indexed, bool hasCxxDtor);
｝
</code></pre><p>那就从initIsa方法开始研究。下面以arm64为例。</p>
<pre><code>inline void  
objc_object::initInstanceIsa(Class cls, bool hasCxxDtor)  
{
    initIsa(cls, true, hasCxxDtor);
}

inline void  
objc_object::initIsa(Class cls, bool indexed, bool hasCxxDtor)  
{
    if (!indexed) {
        isa.cls = cls;
    } else {
        isa.bits = ISA_MAGIC_VALUE;
        isa.has_cxx_dtor = hasCxxDtor;
        isa.shiftcls = (uintptr_t)cls &gt;&gt; 3;
    }
}
</code></pre><p>initIsa第二个参数传入了一个true，所以initIsa就会执行else里面的语句。</p>
<pre><code># if __arm64__
#   define ISA_MASK        0x0000000ffffffff8ULL
#   define ISA_MAGIC_MASK  0x000003f000000001ULL
#   define ISA_MAGIC_VALUE 0x000001a000000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 33; // MACH_VM_MAX_ADDRESS 0x1000000000
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 19;
#       define RC_ONE   (1ULL&lt;&lt;45)
#       define RC_HALF  (1ULL&lt;&lt;18)
    };

# elif __x86_64__
#   define ISA_MASK        0x00007ffffffffff8ULL
#   define ISA_MAGIC_MASK  0x001f800000000001ULL
#   define ISA_MAGIC_VALUE 0x001d800000000001ULL
    struct {
        uintptr_t indexed           : 1;
        uintptr_t has_assoc         : 1;
        uintptr_t has_cxx_dtor      : 1;
        uintptr_t shiftcls          : 44; // MACH_VM_MAX_ADDRESS 0x7fffffe00000
        uintptr_t magic             : 6;
        uintptr_t weakly_referenced : 1;
        uintptr_t deallocating      : 1;
        uintptr_t has_sidetable_rc  : 1;
        uintptr_t extra_rc          : 8;
#       define RC_ONE   (1ULL&lt;&lt;56)
#       define RC_HALF  (1ULL&lt;&lt;7)
    };
</code></pre><p><img src="http://of685p9vy.bkt.clouddn.com/runtime4.jpg" alt="runtime4"><br>ISA_MAGIC_VALUE = 0x000001a000000001ULL转换成二进制是11010000000000000000000000000000000000001，结构如下图：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime5.jpg" alt="runtime5"><br>关于参数的说明：</p>
<p>第一位index，代表是否开启isa指针优化。index = 1，代表开启isa指针优化。</p>
<p>在2013年9月，苹果推出了iPhone5s，与此同时，iPhone5s配备了首个采用64位架构的A7双核处理器，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p>
<p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer的存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p>
<p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。如下图所示：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime6.jpg" alt="runtime6"><br>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。所以，引入了Tagged Pointer对象之后，64位CPU下NSNumber的内存图变成了以下这样：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime7.jpg" alt="runtime7"><br>关于<a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer/" rel="external nofollow noopener noreferrer" target="_blank">Tagged Pointer</a>技术详细的，可以看上面链接那个文章。</p>
<p>has_assoc<br>对象含有或者曾经含有关联引用，没有关联引用的可以更快地释放内存</p>
<p>has_cxx_dtor<br>表示该对象是否有 C++ 或者 Objc 的析构器</p>
<p>shiftcls<br>类的指针。arm64架构中有33位可以存储类指针。</p>
<p>源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。具体可以看<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md#shiftcls" rel="external nofollow noopener noreferrer" target="_blank">从 NSObject 的初始化了解isa</a> 这篇文章里面的shiftcls分析。</p>
<p>magic<br>判断对象是否初始化完成，在arm64中0x16是调试器判断当前对象是真的对象还是没有初始化的空间。</p>
<p>weakly_referenced<br>对象被指向或者曾经指向一个 ARC 的弱变量，没有弱引用的对象可以更快释放</p>
<p>deallocating<br>对象是否正在释放内存</p>
<p>has_sidetable_rc<br>判断该对象的引用计数是否过大，如果过大则需要存在side table中。</p>
<p>extra_rc<br>存放该对象的引用计数值减一后的结果。对象的引用计数超过 1，会存在这个这个里面，如果引用计数为 10，extra_rc的值就为 9。</p>
<p>ISA_MAGIC_MASK 和 ISA_MASK 分别是通过掩码的方式获取MAGIC值 和 isa类指针。</p>
<pre><code>inline Class  
objc_object::ISA()  
{
    assert(!isTaggedPointer()); 
    return (Class)(isa.bits &amp; ISA_MASK);
}
</code></pre><p>关于x86_64的架构，具体可以看从<a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/从%20NSObject%20的初始化了解%20isa.md#shiftcls" rel="external nofollow noopener noreferrer" target="_blank"> NSObject 的初始化了解 isa</a>文章里面的详细分析。</p>
<h2 id="cache-t的具体实现"><a href="#cache-t的具体实现" class="headerlink" title="cache_t的具体实现"></a>cache_t的具体实现</h2><p>还是继续看源码</p>
<pre><code>struct cache_t {  
    struct bucket_t *_buckets;
    mask_t _mask;
    mask_t _occupied;
}

typedef unsigned int uint32_t;  
typedef uint32_t mask_t;  // x86_64 &amp; arm64 asm are less efficient with 16-bits

typedef unsigned long  uintptr_t;  
typedef uintptr_t cache_key_t;

struct bucket_t {  
private:  
    cache_key_t _key;
    IMP _imp;
}
</code></pre><p><img src="http://of685p9vy.bkt.clouddn.com/runtime8.jpg" alt="runtime8"><br>根据源码，我们可以知道cache_t中存储了一个bucket_t的结构体，和两个unsigned int的变量。</p>
<p>mask：分配用来缓存bucket的总数。<br>occupied：表明目前实际占用的缓存bucket的个数。</p>
<p>bucket_t的结构体中存储了一个unsigned long和一个IMP。IMP是一个函数指针，指向了一个方法的具体实现。</p>
<p>cache_t中的bucket_t *_buckets其实就是一个散列表，用来存储Method的链表。</p>
<p>Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为<font color="red" size="4" face="黑体">往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</font></p>
<h2 id="class-data-bits-t的具体实现"><a href="#class-data-bits-t的具体实现" class="headerlink" title="class_data_bits_t的具体实现"></a>class_data_bits_t的具体实现</h2><p>源码实现如下：</p>
<pre><code>struct class_data_bits_t {

    // Values are the FAST_ flags above.
    uintptr_t bits;
}

struct class_rw_t {  
    uint32_t flags;
    uint32_t version;

    const class_ro_t *ro;

    method_array_t methods;
    property_array_t properties;
    protocol_array_t protocols;

    Class firstSubclass;
    Class nextSiblingClass;

    char *demangledName;
}

struct class_ro_t {  
    uint32_t flags;
    uint32_t instanceStart;
    uint32_t instanceSize;
#ifdef __LP64__
    uint32_t reserved;
#endif

    const uint8_t * ivarLayout;

    const char * name;
    method_list_t * baseMethodList;
    protocol_list_t * baseProtocols;
    const ivar_list_t * ivars;

    const uint8_t * weakIvarLayout;
    property_list_t *baseProperties;

    method_list_t *baseMethods() const {
        return baseMethodList;
    }
};
</code></pre><p><img src="http://of685p9vy.bkt.clouddn.com/runtime9.jpg" alt="runtime9"><br>在 objc_class结构体中的注释写到 class_data_bits_t相当于 class_rw_t指针加上 rr/alloc 的标志。</p>
<pre><code>class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags
</code></pre><p>它为我们提供了便捷方法用于返回其中的 class_rw_t *指针：</p>
<pre><code>class_rw_t *data() {  
    return bits.data();
}
</code></pre><p>Objc的类的属性、方法、以及遵循的协议在obj 2.0的版本之后都放在class_rw_t中。class_ro_t是一个指向常量的指针，存储来编译器决定了的属性、方法和遵守协议。rw-readwrite，ro-readonly</p>
<p>在编译期类的结构中的 class_data_bits_t <em>data指向的是一个 class_ro_t </em>指针：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime10.png" alt="runtime10"><br>在运行时调用 realizeClass方法，会做以下3件事情： </p>
<ol>
<li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针 </li>
<li>初始化一个 class_rw_t结构体 </li>
<li>设置结构体 ro的值以及 flag</li>
</ol>
<p>最后调用methodizeClass方法，把类里面的属性，协议，方法都加载进来。</p>
<pre><code>struct method_t {  
    SEL name;
    const char *types;
    IMP imp;

    struct SortBySELAddress :
        public std::binary_function&lt;const method_t&amp;,
                                    const method_t&amp;, bool&gt;
    {
        bool operator() (const method_t&amp; lhs,
                         const method_t&amp; rhs)
        { return lhs.name &lt; rhs.name; }
    };
};
</code></pre><p>方法method的定义如上。里面包含3个成员变量。SEL是方法的名字name。types是Type Encoding类型编码，类型可参考<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" rel="external nofollow noopener noreferrer" target="_blank">Type Encoding</a>，在此不细说。</p>
<p>IMP是一个函数指针，指向的是函数的具体实现。在runtime中消息传递和转发的目的就是为了找到IMP，并执行函数。</p>
<p>整个运行时过程可以描述如下：<br><img src="http://of685p9vy.bkt.clouddn.com/runtime11.png" alt="runtime11"><br>更加详细的分析，请看@Draveness 的这篇文章 <a href="https://github.com/Draveness/iOS-Source-Code-Analyze/blob/master/contents/objc/深入解析%20ObjC%20中方法的结构.md#深入解析-objc-中方法的结构" rel="external nofollow noopener noreferrer" target="_blank">深入解析 ObjC 中方法的结构</a></p>
<p>到此，总结一下objc_class 1.0和2.0的差别。<br><img src="http://of685p9vy.bkt.clouddn.com/runtime12.png" alt="runtime11"></p>
<h1 id="入院考试"><a href="#入院考试" class="headerlink" title="入院考试"></a>入院考试</h1><h2 id="self-class-与-super-class"><a href="#self-class-与-super-class" class="headerlink" title="[self class] 与 [super class]"></a>[self class] 与 [super class]</h2><p>下面代码输出什么?</p>
<pre><code>@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self)
    {
        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
    }
return self;
}
@end
</code></pre><p>self和super的区别：</p>
<p>self是类的一个隐藏参数，每个方法的实现的第一个参数即为self。</p>
<p>super并不是隐藏参数，它实际上只是一个”编译器标示符”，它负责告诉编译器，当调用方法时，去调用父类的方法，而不是本类中的方法。</p>
<p>在调用[super class]的时候，runtime会去调用objc_msgSendSuper方法，而不是objc_msgSend</p>
<pre><code>OBJC_EXPORT void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */ )


/// Specifies the superclass of an instance. 
struct objc_super {  
    /// Specifies an instance of a class.
    __unsafe_unretained id receiver;

    /// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
    /* For compatibility with old objc-runtime.h header */
    __unsafe_unretained Class class;
#else
    __unsafe_unretained Class super_class;
#endif
    /* super_class is the first class to search */
};
</code></pre><p>在objc_msgSendSuper方法中，第一个参数是一个objc_super的结构体，这个结构体里面有两个变量，一个是接收消息的receiver，一个是 当前类的父类super_class。</p>
<p>入院考试第一题错误的原因就在这里，误认为[super class]是调用的[super_class class]。</p>
<p>objc_msgSendSuper的工作原理应该是这样的:<br>从objc_super结构体指向的superClass父类的方法列表开始查找selector，找到后以objc-&gt;receiver去调用父类的这个selector。注意，最后的调用者是objc-&gt;receiver，而不是super_class！</p>
<p>那么objc_msgSendSuper最后就转变成</p>
<pre><code>objc_msgSend(objc_super-&gt;receiver, @selector(class))

+ (Class)class {
    return self;
}
</code></pre><p>由于找到了父类NSObject里面的class方法的IMP，又因为传入的入参objc_super-&gt;receiver = self。self就是son，调用class，所以父类的方法class执行IMP之后，输出还是son，最后输出两个都一样，都是输出son。</p>
<h2 id="isKindOfClass-与-isMemberOfClass"><a href="#isKindOfClass-与-isMemberOfClass" class="headerlink" title="isKindOfClass 与 isMemberOfClass"></a>isKindOfClass 与 isMemberOfClass</h2><p>下面代码输出什么？</p>
<pre><code>@interface Sark : NSObject
@end

@implementation Sark
@end

int main(int argc, const char * argv[]) {
@autoreleasepool {
    BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]]; Y
    BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];   Y
    BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];   
    BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];

   NSLog(@&quot;%d %d %d %d&quot;, res1, res2, res3, res4);
}
return 0;
}
</code></pre><p>先来分析一下源码这两个函数的对象实现</p>
<pre><code>+ (Class)class {
    return self;
}

- (Class)class {
    return object_getClass(self);
}

Class object_getClass(id obj)  
{
    if (obj) return obj-&gt;getIsa();
    else return Nil;
}

inline Class  
objc_object::getIsa()  
{
    if (isTaggedPointer()) {
        uintptr_t slot = ((uintptr_t)this &gt;&gt; TAG_SLOT_SHIFT) &amp; TAG_SLOT_MASK;
        return objc_tag_classes[slot];
    }
    return ISA();
}

inline Class  
objc_object::ISA()  
{
    assert(!isTaggedPointer()); 
    return (Class)(isa.bits &amp; ISA_MASK);
}

+ (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = object_getClass((id)self); tcls; tcls = tcls-&gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

- (BOOL)isKindOfClass:(Class)cls {
    for (Class tcls = [self class]; tcls; tcls = tcls-&gt;superclass) {
        if (tcls == cls) return YES;
    }
    return NO;
}

+ (BOOL)isMemberOfClass:(Class)cls {
    return object_getClass((id)self) == cls;
}

- (BOOL)isMemberOfClass:(Class)cls {
    return [self class] == cls;
}
</code></pre><p>首先题目中NSObject 和 Sark分别调用了class方法。</p>
<ul>
<li>(BOOL)isKindOfClass:(Class)cls方法内部，会先去获得object_getClass的类，而object_getClass的源码实现是去调用当前类的obj-&gt;getIsa()，最后在ISA()方法中获得meta class的指针。</li>
</ul>
<p>接着在isKindOfClass中有一个循环，先判断class是否等于meta class，不等就继续循环判断是否等于super class，不等再继续取super class，如此循环下去。</p>
<p>[NSObject class]执行完之后调用isKindOfClass，第一次判断先判断NSObject 和 NSObject的meta class是否相等，之前讲到meta class的时候放了一张很详细的图，从图上我们也可以看出，NSObject的meta class与本身不等。接着第二次循环判断NSObject与meta class的superclass是否相等。还是从那张图上面我们可以看到：Root class(meta) 的superclass 就是 Root class(class)，也就是NSObject本身。所以第二次循环相等，于是第一行res1输出应该为YES。</p>
<p>同理，[Sark class]执行完之后调用isKindOfClass，第一次for循环，Sark的Meta Class与[Sark class]不等，第二次for循环，Sark Meta Class的super class 指向的是 NSObject Meta Class， 和 Sark Class不相等。第三次for循环，NSObject Meta Class的super class指向的是NSObject Class，和 Sark Class 不相等。第四次循环，NSObject Class 的super class 指向 nil， 和 Sark Class不相等。第四次循环之后，退出循环，所以第三行的res3输出为NO。</p>
<p>如果把这里的Sark改成它的实例对象，[sark isKindOfClass:[Sark class]，那么此时就应该输出YES了。因为在isKindOfClass函数中，判断sark的meta class是自己的元类Sark，第一次for循环就能输出YES了。</p>
<p>isMemberOfClass的源码实现是拿到自己的isa指针和自己比较，是否相等。<br>第二行isa 指向 NSObject 的 Meta Class，所以和 NSObject Class不相等。第四行，isa指向Sark的Meta Class，和Sark Class也不等，所以第二行res2和第四行res4都输出NO。</p>
<h2 id="Class与内存地址"><a href="#Class与内存地址" class="headerlink" title="Class与内存地址"></a>Class与内存地址</h2><p>下面的代码会？Compile Error / Runtime Crash / NSLog…?</p>
<pre><code>@interface Sark : NSObject
@property (nonatomic, copy) NSString *name;
- (void)speak;
@end

@implementation Sark
- (void)speak {                            
   NSLog(@&quot;my name&apos;s %@&quot;, self.name);
}
@end


@implementation ViewController

- (void)viewDidLoad {  
  [super viewDidLoad];
  id cls = [Sark class];
  void *obj = &amp;cls;
  [(__bridge id)obj speak];
}
@end
</code></pre><p>这道题有两个难点。难点一，obj调用speak方法，到底会不会崩溃。难点二，如果speak方法不崩溃，应该输出什么？</p>
<p>首先需要谈谈隐藏参数self和_cmd的问题。 当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。self在上面已经讲解明白了，接下来就来说说_cmd。_cmd表示当前调用方法，其实它就是一个方法选择器SEL。</p>
<p>难点一，能不能调用speak方法？</p>
<pre><code>id cls = [Sark class];  
void *obj = &amp;cls;
</code></pre><p>答案是可以的。obj被转换成了一个指向Sark Class的指针，然后使用id转换成了objc_object类型。obj现在已经是一个Sark类型的实例对象了。当然接下来可以调用speak的方法。</p>
<p>难点二，如果能调用speak，会输出什么呢？</p>
<p>很多人可能会认为会输出sark相关的信息。这样答案就错误了。</p>
<p>正确的答案会输出</p>
<pre><code>my name is &lt;ViewController: 0x7ff6d9f31c50&gt;
</code></pre><p>内存地址每次运行都不同，但是前面一定是ViewController。why？</p>
<p>我们把代码改变一下，打印更多的信息出来。</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self);

    id cls = [Sark class];
    NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls);

    void *obj = &amp;cls;
    NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj,&amp;obj);

    [(__bridge id)obj speak];

    Sark *sark = [[Sark alloc]init];
    NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark,&amp;sark);

    [sark speak];

}
</code></pre><p>我们把对象的指针地址都打印出来。输出结果：</p>
<pre><code>ViewController = &lt;ViewController: 0x7fb570e2ad00&gt; , 地址 = 0x7fff543f5aa8  
Sark class = Sark 地址 = 0x7fff543f5a88  
Void *obj = &lt;Sark: 0x7fff543f5a88&gt; 地址 = 0x7fff543f5a80

my name is &lt;ViewController: 0x7fb570e2ad00&gt;

Sark instance = &lt;Sark: 0x7fb570d20b10&gt; 地址 = 0x7fff543f5a78  
my name is (null)


    // objc_msgSendSuper2() takes the current search class, not its superclass.
OBJC_EXPORT id objc_msgSendSuper2(struct objc_super *super, SEL op, ...)  
    __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_2_0);
</code></pre><p>objc_msgSendSuper2方法入参是一个objc_super *super。</p>
<pre><code>/// Specifies the superclass of an instance. 
struct objc_super {  
    /// Specifies an instance of a class.
    __unsafe_unretained id receiver;

    /// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &amp;&amp;  !__OBJC2__
    /* For compatibility with old objc-runtime.h header */
    __unsafe_unretained Class class;
#else
    __unsafe_unretained Class super_class;
#endif
    /* super_class is the first class to search */
};
#endif
</code></pre><p>所以按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class，self，obj。</p>
<p>第一个self和第二个_cmd是隐藏参数。第三个self.class和第四个self是[super viewDidLoad]方法执行时候的参数。</p>
<p>在调用self.name的时候，本质上是self指针在内存向高位地址偏移一个指针。在32位下面，一个指针是4字节=4*8bit=32bit。</p>
<p>从打印结果我们可以看到，obj就是cls的地址。在obj向上偏移32bit就到了0x7fff543f5aa8，这正好是ViewController的地址。</p>
<p>所以输出为my name is <viewcontroller: 0x7fb570e2ad00="">。</viewcontroller:></p>
<p>至此，Objc中的对象到底是什么呢？</p>
<p>实质：<font color="red" size="4" face="黑体">Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</font></p>
<p>加深一下对上面这句话的理解，下面这段代码会输出什么？</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];

    NSLog(@&quot;ViewController = %@ , 地址 = %p&quot;, self, &amp;self);

    NSString *myName = @&quot;halfrost&quot;;

    id cls = [Sark class];
    NSLog(@&quot;Sark class = %@ 地址 = %p&quot;, cls, &amp;cls);

    void *obj = &amp;cls;
    NSLog(@&quot;Void *obj = %@ 地址 = %p&quot;, obj,&amp;obj);

    [(__bridge id)obj speak];

    Sark *sark = [[Sark alloc]init];
    NSLog(@&quot;Sark instance = %@ 地址 = %p&quot;,sark,&amp;sark);

    [sark speak];

}


ViewController = &lt;ViewController: 0x7fff44404ab0&gt; ,  地址  = 0x7fff56a48a78  
Sark class = Sark  地址  = 0x7fff56a48a50  
Void *obj = &lt;Sark: 0x7fff56a48a50&gt;  地址 = 0x7fff56a48a48

my name is halfrost

Sark instance = &lt;Sark: 0x6080000233e0&gt;  地址 = 0x7fff56a48a40  
my name is (null)
</code></pre><p>由于加了一个字符串，结果输出就完全变了，[(__bridge id)obj speak];这句话会输出“my name is halfrost”</p>
<p>原因还是和上面的类似。按viewDidLoad执行时各个变量入栈顺序从高到底为self，_cmd，self.class，self，myName，obj。obj往上偏移32位，就是myName字符串，所以输出变成了输出myName了。</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/C语言语法/union定义/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    union定义(转载)
                
            </div>
        </a>
    
    
        <a href="/wiki/IOS/Runtime/meta_class/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">What is a meta-class in Objective-C(译文)</div>
        </a>
    
</nav>





    
    
        <section id="comments"> 
    <div class="ds-thread" data-thread-key="wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/" data-title="神经病院Objective-C Runtime入院第一天——isa和Class(转载)" data-url="http://yoursite.com/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/"></div>
    <style>
        #ds-thread #ds-reset .ds-textarea-wrapper {
            background: none;
        }
        #ds-reset .ds-avatar img {
            box-shadow: none;
        }
        #ds-reset .ds-gradient-bg {
            background: #f7f7f7;
        }
        #ds-thread #ds-reset li.ds-tab a {
            border-radius: 3px;
        }
        #ds-thread #ds-reset .ds-post-button {
            color: white;
            border: none;
            box-shadow: none;
            background: #d32;
            text-shadow: none;
            font-weight: normal;
            font-family: 'Microsoft Yahei';
        }
        #ds-thread #ds-reset .ds-post-button:hover {
            color: white;
            background: #DE594C;
        }
        #ds-thread #ds-reset .ds-post-button:active {
            background: #d32;
        }
        #ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current {
            color: white;
            background: #d32;
            box-shadow: none;
            text-shadow: none;
            font-weight: normal;
        }
    </style>
 </section>
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LJ &copy; 2018 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'lijian'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
