<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>union定义(转载) | LJ小窝</title>
    
    
        <meta name="keywords" content="C 语言语法">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Alright, good morning.Thanks so much for coming out this morning to learn all about what’s new in Cocoa Touch.Now normally, Eliza would join me up here a little bit later although this year actually y">
<meta name="keywords" content="C 语言语法">
<meta property="og:type" content="article">
<meta property="og:title" content="union定义(转载)">
<meta property="og:url" content="http://yoursite.com/wiki/WWDC/union定义的副本/index.html">
<meta property="og:site_name" content="LJ小窝">
<meta property="og:description" content="Alright, good morning.Thanks so much for coming out this morning to learn all about what’s new in Cocoa Touch.Now normally, Eliza would join me up here a little bit later although this year actually y">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-08-23T07:44:58.366Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="union定义(转载)">
<meta name="twitter:description" content="Alright, good morning.Thanks so much for coming out this morning to learn all about what’s new in Cocoa Touch.Now normally, Eliza would join me up here a little bit later although this year actually y">
    

    
        <link rel="alternate" href="/atom.xml" title="LJ小窝" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">
    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    


</head>
</html>
<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">LJ小窝</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>分类</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++语言
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++Primer
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第七章类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第七章类/类/">类</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第三章 字符串、向量、数组
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第三章 字符串、向量、数组/字符串、向量、数组/">字符串、向量、数组</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第二章变量和基本类型
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第二章变量和基本类型/变量和基本类型/">变量和基本类型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第八章io库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第八章io库/IO库/">IO库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第六章函数
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第六章函数/函数/">函数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十三章
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十三章/拷贝控制/">拷贝控制</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十九章特殊工具和技术
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十九章特殊工具和技术/特殊工具和技术/">特殊工具和技术</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十五章 面向对象程序设计
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十五章 面向对象程序设计/面向对象程序设计/">面向对象程序设计</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第十六章 模板和泛型编程
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第十六章 模板和泛型编程/模板和泛型编程/">模板和泛型编程</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            第四章 表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/表达式/">表达式</a></li>  <li class="file"><a href="/wiki/C++语言/C++Primer/第四章 表达式/运算符优先级表/">运算符优先级表</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C++关键字理解
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/C++关键字理解/static/">static关键字作用总结(转载)</a></li>  <li class="file"><a href="/wiki/C++语言/C++关键字理解/explicit-learn/">explicit实例浅析(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            container
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            deque
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/deque/deque的实现原理和使用方法详解/">deque的实现原理和使用方法详解</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            list
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C++语言/container/list/C++标准库中的list的实现原理/">C++标准库中的list的实现原理</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/wiki/C++语言/container/forward_list不支持push_back操作/">为什么`forward_list`不支持`push_back`操作？</a></li>  <li class="file"><a href="/wiki/C++语言/container/容器基本操作/">容器基本操作</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            C语言语法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/C语言语法/CC_pointer_memry/">二级指针动态申请内存</a></li>  <li class="file"><a href="/wiki/C语言语法/struct_Analize/">struct定义语法</a></li>  <li class="file"><a href="/wiki/C语言语法/union定义/">union定义(转载)</a></li>  <li class="file"><a href="/wiki/C语言语法/堆区（heap）和栈区（stack）的区别/">堆区（heap）和栈区（stack）的区别(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Hybird
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            webview
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/webview/gome-Webview/">通用webview开发记录</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            weex
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/Hybird/weex/event-analize/">weex 事件原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-debug/">搭建weex断点调试环境</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_one/">weex系列抄之一---环境搭建</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex-conmunication/">weex 通信原理分析</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_six_events/">weex系列抄之一---事件处理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_four/">weex系列抄之四---flex 布局</a></li>  <li class="file"><a href="/wiki/Hybird/weex/weex_two/">weex系列抄之二---weex原理</a></li>  <li class="file"><a href="/wiki/Hybird/weex/Weex_five/">weex系列抄之四---由 FlexBox 算法强力驱动的 Weex 布局引擎</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Category
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Category/深入理解Objective-C：Category/">深入理解Objective-C：Category(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            GCD
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/GCD/use-dispatch-semaphore/">dispatch_semaphore 的使用方法</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS12
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/IOS12/IOS12-compatibility/">IOS12 兼容</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Mach_O
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Mach_O/Mach_O_File_Struct/">Mach-o文件结构理解</a></li>  <li class="file"><a href="/wiki/IOS/Mach_O/machoviewer/">mach-o Viewer 源码学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Runtime
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/Runtime/Objective-C-消息发送与转发机制原理/">Objective-C 消息发送与转发机制原理</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/meta_class/">What is a meta-class in Objective-C(译文)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/runtime1/">runtime1</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime住院第二天——消息发送与转发（转载/">神经病院Objective-C Runtime住院第二天——消息发送与转发（转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/">神经病院Objective-C Runtime入院第一天——isa和Class(转载)</a></li>  <li class="file"><a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime-转载/">神经病院Objective-C Runtime出院第三天——如何正确使用Runtime(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            crash
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/crash/KSCrash_Analize/">KSCrash崩溃收集原理浅析</a></li>  <li class="file"><a href="/wiki/IOS/crash/Analize_Crash/">收集、符号化IOS崩溃日志</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            foundation使用记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSInvocation的基本使/">NSInvocation的基本使</a></li>  <li class="file"><a href="/wiki/IOS/foundation使用记录/NSDateFormatter时间格式/">NSDateFormatter 时间格式</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            事件处理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/事件处理/iOS事件处理/">iOS事件处理看我就够了(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            内存管理
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/内存管理/内存学习/">内存学习</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            动态库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/动态库/static_lib_aggregate_script/">合并真机模拟器静态库(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            库
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/库/组件化-库/">组件化-库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            开源库学习
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            fishhook
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/fishHookPicture/">图解fishhook</a></li>  <li class="file"><a href="/wiki/IOS/开源库学习/fishhook/learn_fishhook/">fishhook学习记录</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            暂无分类
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/暂无分类/指定初始化函数/">正确使用NS_DESIGNATED_INITIALIZER</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            虚拟内存
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存之2/">查看虚拟内存</a></li>  <li class="file"><a href="/wiki/IOS/虚拟内存/虚拟内存/">虚拟内存之一----关于</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            JS
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/JS/flexBox/">flexBox 伸缩盒子模型</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            WWDC
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/WWDC/What’s New in User Notifications/">What’s New in User Notifications</a></li>  <li class="file active"><a href="/wiki/WWDC/union定义的副本/">union定义(转载)</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            linux命令
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/linux命令/set命令/">set命令</a></li>  <li class="file"><a href="/wiki/linux命令/$0,$?,$!等的特殊用法/">set命令</a></li>  <li class="file"><a href="/wiki/linux命令/export命令/">set命令</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cocoapods
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Cocoapods/Cocoapods-new-spec/">Cocoapods-new-spec</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-learn-install/">cocoapod学习 安装和使用（1）</a></li>  <li class="file"><a href="/wiki/工具/Cocoapods/cocoapod-private-repo/">创建私有仓库</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            IOS模拟器安装app
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/IOS模拟器安装app/IOS_simulator_install_app/">给IOS模拟器按照APP</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SSH
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/SSH/ssh-theory/">图解SSH原理</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Xcode编译常量
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/Xcode编译常量/xcode编译环境变量/">Xcode编译环境变量</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git简略版
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git简略版/git简略版/">Git笔记</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            git详细记录
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/git/git详细记录/git仓库/">Git仓库(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git分支管理/">Git分支管理(转载)</a></li>  <li class="file"><a href="/wiki/工具/git/git详细记录/git工作区/">git时光穿梭(转载)</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            hexo
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/hexo/LaTex/">支持LaTEX的hexo博客</a></li>  <li class="file"><a href="/wiki/工具/hexo/自己搭建博客的经历/">自己搭建博客的经历</a></li>  <li class="file"><a href="/wiki/工具/hexo/hexo-use/">hexo使用指南</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            markdowm
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/markdowm/Markdown公式编辑学习笔记/">Markdown公式编辑</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ruby
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/ruby/homebrew-gem使用/">homebrew-gem使用.</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            工具下载地址
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/工具/工具下载地址/工具下载地址/">工具下载地址</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据知识
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/数据知识/数学基础知识/">数学知识一对数指数</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            编程基础
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            正则表达式
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/wiki/编程基础/正则表达式/正则表达式学习/">正则表达式学习摘要</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                     </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-WWDC/union定义的副本" class="article article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/WWDC/">WWDC</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/C-语言语法/">C 语言语法</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/WWDC/union定义的副本/">
            <time datetime="2016-11-21T04:07:12.000Z" itemprop="datePublished">2016-11-21</time>
        </a>
    </div>


                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            union定义(转载)
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
                <div id="toc" class="toc-article">
                <strong class="toc-title">文章目录</strong>
                    
                </div>
            
        
        
            <p>Alright, good morning.<br>Thanks so much for coming out this morning to learn all about what’s new in Cocoa Touch.<br>Now normally, Eliza would join me up here a little bit later although this year actually you’re just going to be hearing from me.<br>So, she’ll be back in later years.<br>Don’t worry about it.<br>This morning we’re going to talk about things in three main categories.<br>今天早上我们将从三个方面来讨论。</p>
<ol>
<li>Framework updates</li>
<li>API enhancements</li>
<li>siri shortcuts</li>
</ol>
<p>We’re going to start with some framework updates including things like performance and security.<br>我们将从一些框架更新开始，包括性能和安全性。</p>
<p>Then we’re going to talk about some API enhancements across a number of different existing APIs in the SDK, including notifications and messages.<br>然后，我们将讨论SDK中许多现有API的一些API增强，包括通知和消息。<br>最后是Siri快捷键。</p>
<p>And then we’re going to end with Siri Shortcuts.<br>最后是Siri快捷键。</p>
<p>So let’s get started with our first topic: Performance Updates.<br>让我们从第一个主题开始:性能更新。</p>
<p>Now we’re going to talk about performance across three main areas: scrolling, memory, and auto layout.<br>现在我们将讨论三个主要领域的性能:滚动、内存和自动布局。</p>
<p>Now before we get in to it, it’s important to keep in mind one little bit of background information about scrolling.<br>在我们开始之前，有一点关于滚动的背景信息是很重要的。</p>
<p>Scrolling on iOS follows a pretty common pattern in most places.<br>在大多数地方，在iOS上滚动遵循一种相当常见的模式。</p>
<p>We load content to be displayed into the views and then we’re just moving that content around.<br>我们把要显示的内容加载到视图中，然后我们就移动这些内容。</p>
<p>And while we’re moving it around, most of those frames are really cheap to generate because we don’t have to load anything new.<br>当我们移动它的时候，大部分的帧都很便宜因为我们不需要加载任何新的东西。</p>
<p>But every now and then, a new view first becomes visible and the one frame when that first happens is quite a bit more expensive to generate than those other cheaper ones.<br>但时不时地，一个新视图就会出现，当第一个视图出现时，生成的帧比生成其他更便宜的帧要贵很多。</p>
<p>Now, of course, once that one frame is loaded, we’re just back to moving content around, so the amount of work we do on the CPU goes back to being pretty small for most of that other scrolling.<br>现在，当然，一旦加载了这一帧，我们就又开始移动内容了，所以我们在CPU上做的工作对于其他滚动来说就变得非常小了。</p>
<p>So what’s happening during that really expensive frame that causes that one to be more than all the others? Well, let’s take a look from the perspective UI Table View but everything we look at here will really be the same for UI Collection View or really any of your own custom views that you may build that behave in similar ways.<br>那么在这个非常昂贵的坐标系中发生了什么使得这个比其他的都大呢?好，让我们从透视图的UI表格视图看一下但是我们在这里看到的所有东西对于UI集合视图都是一样的或者任何你自己的自定义视图都是一样的，你可以用类似的方式构建它们。</p>
<p>So the work in that expensive frame probably starts in your implementation of TableView, cell For Row At index Path delegate method.<br>在这个昂贵的框架中工作可能从TableView的实现开始，单元格在索引路径委托方法。</p>
<p>Now the first thing we’re going to do in there is get the cell that we want to display.<br>现在我们要做的第一件事就是获取我们想要显示的单元格。</p>
<p>And so we’re going to try and dequeue it ideally from the reuse queue although if one is not available already in the queue, we might actually have to do some memory allocation in order to get it ready.<br>因此，我们将尝试将它从重用队列中退出，尽管如果队列中已经没有可用的内存，我们可能需要做一些内存分配来准备它。</p>
<p>Once we have the cell, we’re then going to populate it with your model data.<br>一旦我们有了单元格，我们就会用你的模型数据填充它。</p>
<p>Now how expensive that is will vary depending on your application but it can be including a fairly large amount of expensive operations like reading files, loading data out of databases, or other things of that nature.<br>它的代价取决于你的应用程序，但它可能包括大量昂贵的操作，比如读取文件，从数据库中加载数据，或者其他类似的操作。</p>
<p>So you’ll definitely want to look at the expense here in your own apps but it tends to be this is where a good portion of it will exist.<br>所以你肯定会想要看看你自己的应用程序的花费但是这往往是它的一部分存在的地方。</p>
<p>Now, you may think looking here that that’s the end of the expensive work but even once you return from this method, there’s actually more work that has to happen in order to get the cell prepared to have it show up on screen.<br>现在，你可能认为这是昂贵工作的结束但即使你从这个方法返回，为了让单元格在屏幕上显示，实际上还需要做更多的工作。</p>
<p>So, of course, next, we have to lay out all of the content in that cell.<br>当然，接下来，我们要列出单元格中的所有内容。</p>
<p>We need to size all the views and position them in the right spot.<br>我们需要调整所有视图的大小，并将它们放置在正确的位置。</p>
<p>Now, this can actually be a pretty substantial amount of the total time that we’re spending because it can include other expensive operations like measuring text.<br>现在，这实际上可以是我们花费的总时间的相当大的一部分因为它可以包括其他昂贵的操作比如测量文本。</p>
<p>Once everything is properly sized and positioned, then it’s time to generate any content that would need to be drawn using drawing calls and to do that we have to call draw Rect on all of the subviews within that cell.<br>一旦所有内容都正确地大小和位置，那么就该使用绘图调用生成需要绘制的任何内容了，为此，我们必须在单元格中的所有子视图上调用draw Rect。</p>
<p>Again, this can be a pretty large amount of the time because we’ll also be doing things like drawing text.<br>同样，这可能是一个相当大的时间因为我们还会做一些事情，比如绘制文本。</p>
<p>So overall, there’s a lot of work that has to happen across this whole piece of code and it has to happen in a really short period of time.<br>总的来说，这段代码中有很多工作需要在很短的时间内完成。</p>
<p>On our 60-hertz devices, you have 16 milliseconds to complete all this work in order to make sure you don’t drop any frames, and maintain smooth scrolling.<br>在我们的60赫兹设备上，你有16毫秒的时间来完成所有这些工作，以确保你不会掉下任何帧，并保持平滑滚动。</p>
<p>On our 12-hertz iPads, on the iPad Pro, you have only 8 milliseconds to complete all of that work.<br>在我们的12赫兹的iPad上，在iPad Pro上，你只有8毫秒来完成所有的工作。<br>所以，这真的需要尽快完成。</p>
<p>So, it really needs to be done as quickly as possible.<br>所以，这真的需要尽快完成。</p>
<p>Now, to help with that, in iOS 10, we introduced a cell prefetching API and the idea with the prefetch API is to take some of this work, populating your cell with model data, and pull it out of this critical section that’s happening on demand in that short window, do it earlier, and do it on a background thread so it can happen asynchronously with some of the other work, in particular those cheaper scrolling frames we talked about.<br>现在,帮助,在iOS 10中,我们介绍了一个细胞预取API和与预取API的想法是把一些工作,填充你的细胞模型数据,并把它的关键部分的需求发生在短窗口,早些时候,在后台线程中,所以它可以异步发生的一些其他工作,尤其是便宜的滚动框我们讨论。</p>
<p>Now adopting this is really easy.<br>现在采用这个非常简单。</p>
<p>It’s just a UI Table View Data Source Prefetching protocol and it only has two methods, only one of which is actually required.<br>它只是一个UI表视图数据源预取协议，它只有两个方法，其中只有一个是实际需要的。</p>
<p>And the idea here is to move some of that expensive work of loading things from files or reading your database into here so that you don’t have to do it on demand.<br>这里的想法是把一些昂贵的工作从文件中加载或者读取你的数据库转移到这里这样你就不必按要求去做了。</p>
<p>You data is already prepared when the cell is needed for display.<br>当需要显示单元格时，您的数据已经准备好了。</p>
<p>So this in most cases can be a really big win although while we were looking at some of our own apps in iOS 12, we actually noticed a case where this was causing an issue instead of helping us.<br>所以在大多数情况下，这是一个非常大的胜利尽管当我们在ios12中看到我们自己的一些应用时，我们实际上注意到一个例子，这导致了一个问题而不是帮助我们。</p>
<p>So let’s take a look at what that looked like.<br>我们来看看它是什么样子的。</p>
<p>Now here’s an example of a trace that we took while scrolling on an iPhone 6 Plus.<br>这里有一个我们在iPhone 6 Plus上滚动时追踪的例子。</p>
<p>The vertical bars across the top, those represent frames that we want to display.<br>顶部的竖线表示我们想要显示的帧。</p>
<p>The alternating light and dark blue colors represent frames that we did swap to the display as they were changing.<br>交替的浅蓝色和深蓝颜色代表了我们交换到显示器上的帧，因为它们在变化。</p>
<p>And that double wide light blue bar, that is a place where we drew the same frame for two full frame durations.<br>这个双宽的淡蓝色条，在这里我们画了相同的框架两个完整的框架。</p>
<p>So for a customer looking at the device while this was happening, that looked like a dropped frame or a scrolling hitch, which obviously is what we’re trying to avoid.<br>因此，对于一个用户来说，在这种情况下看着设备，看起来就像一个掉下来的框架或滚动故障，这显然是我们要避免的。</p>
<p>So what was happening in this case? Well, here you can see that red bar is representing the time that we’re spending in the critical section we just talked about, all the self-[inaudible] index path, layout, and drawing.<br>那么这个案例中发生了什么?这里你可以看到红色的条代表了我们在关键部分花费的时间我们刚刚讨论过，所有的自我[听不清]索引路径，布局和绘图。</p>
<p>And here, it’s actually taking longer than the 16 milliseconds we had to draw the frame.<br>在这里，它实际上花费的时间比我们画出坐标系的16毫秒还要长。</p>
<p>Now because the device can only swap new frames onto the screen at fixed positions in time, once we miss that deadline, we ended up displaying the same frame for two full durations, which was obviously not great.<br>现在，由于设备只能在固定的时间位置在屏幕上交换新的帧，一旦我们错过了最后期限，我们就会在两个完整的时间段内显示相同的帧，这是显而易见的</p>
<p>So why did that happen here? In this case, we’re looking at an app where we actually had implemented the cell prefetching method so our data should’ve been ready.<br>为什么会这样呢?在本例中，我们正在查看一个应用程序，其中我们实际实现了单元格预取方法，因此我们的数据应该已经准备好了。</p>
<p>Ideally, this could’ve been done more quickly.<br>理想情况下，这样做可以更快。</p>
<p>Well, if we look at a little more of the trace, we can see what was going on.<br>好吧，如果我们再多看一点痕迹，我们就能看到发生了什么。</p>
<p>The cell prefetching API was being called at the same time that we were requesting the current cell.<br>在请求当前单元格的同时调用了单元格预抓取API。</p>
<p>Now it wasn’t being called for the data for the current cell.<br>现在没有为当前单元格调用数据。</p>
<p>It was being called for data that we might need in a future cell, but it was getting run at the same time.<br>它被调用来获取未来单元格中可能需要的数据，但它同时在运行。</p>
<p>And so there was now contention for the CPU as we tried to both load the current frame and also load data for a future frame that we don’t actually need yet.<br>现在CPU出现了争用，因为我们既要加载当前帧，又要为未来的帧加载数据，而我们实际上还不需要这些数据。</p>
<p>So because of that contention, it actually caused both tasks to take a little bit longer.<br>因此，由于这个争论，实际上这两个任务都花了更长的时间。</p>
<p>Now in iOS 12, we’re much more intelligent about scheduling these background prefetch operations so that rather than happening concurrently and causing some CPU contention, they’ll now happen serially, shortening the time that you need to take to load the current cell and helping avoid dropped frames in many cases.<br>现在在ios12中，我们更加智能地安排这些后台预取操作，这样就不会同时发生并引起CPU争用，而是会连续发生，缩短加载当前单元格所需的时间，并在很多情况下帮助避免帧丢失。</p>
<p>So once we had that fixed, we kept profiling our apps and we actually found another case where there was a bit of a surprising cause of some dropped frames.<br>一旦我们修复了这个问题，我们就会对我们的应用程序进行分析我们发现了另一个案例其中有一些令人惊讶的帧丢失的原因。</p>
<p>Now what we found was that when the device was not under load, there was no background activity, all we were doing was a little bit of scrolling in the foreground app.<br>现在我们发现当设备没有负载时，没有后台活动，我们所做的就是在前台应用程序中滚动一下。</p>
<p>Counterintuitively, we could actually drop more frames than times when there was some small amount of light background work going on.<br>与直觉相反的是，当有少量的光背景工作在进行时，我们实际上可以下降更多的帧。</p>
<p>That didn’t really make a lot of sense.<br>这没有什么意义。</p>
<p>And to understand why it was happening, we had to drop down a level and take a look at the behavior of the CPU when it was scheduling our workloads.<br>为了理解为什么会发生这种情况，我们必须下拉一个级别，查看CPU在调度工作负载时的行为。</p>
<p>So let’s take a look at another trace.<br>我们来看看另一条轨迹。</p>
<p>Here, we’ve got the same situation.<br>在这里，我们遇到了同样的情况。</p>
<p>Double wide blue bar is causing us to drop a frame or rather is our dropped frame.<br>双宽的蓝条会让我们掉下一帧或者说是我们掉下的帧。</p>
<p>Now here we can see a graph of our CPU’s performance over time.<br>现在我们可以看到CPU性能随时间变化的图表。</p>
<p>Now during most of those cheap frames, our CPU performance is staying pretty low.<br>现在，在大多数廉价的帧中，我们的CPU性能保持在相当低的水平。</p>
<p>There’s no background work going on.<br>没有背景工作在进行。</p>
<p>All we’re doing is scrolling things and that’s exactly what you would want because when we’re not doing expensive work for scrolling, you want to keep the CPU as low as possible to preserve battery life.<br>我们所做的就是滚动东西，这正是你想要的，因为当我们不做昂贵的滚动工作时，你想让CPU尽可能低，以保持电池寿命。</p>
<p>So that was great.<br>这是伟大的。</p>
<p>What wasn’t great is that it took a little bit of time before it could ramp up.<br>不太好的是，它需要一段时间才能上升。</p>
<p>You heard about this yesterday in the keynote.<br>你昨天在主题演讲中听到过这个。</p>
<p>Now when it did finally ramp up, it was already too late to have completed the work to load the cell that we needed to display and so we ended up missing that frame again.<br>现在，当它终于开始爬升的时候，已经太晚了，无法完成加载我们需要显示的单元格的工作，所以我们又一次错过了那个帧。</p>
<p>Now because we own the full software stack from top to bottom, in iOS 12 we took all the information we have in the high-level UIKit framework about what scrolling is happening and when these critical sections are occurring and pass that information all the way down to the low-level CPU performance controller so that it can now much more intelligently reason about the work that’s happening and predict both when these bursts will occur and how much CPU performance will be required to meet the deadline for the historical demand that your app has had.<br>因为我们从上到下拥有完整的软件栈，iOS 12我们把所有的信息我们已经在高级UIKit框架滚动正在发生什么,当这些关键部分发生并传递这些信息一直到低级的CPU性能控制器,以便它可以更明智地思考工作和预测都当这些发生的爆炸会发生多少CPU性能需要满足最后期限的历史要求应用程序。</p>
<p>So once that change happens, where the load starts right here, we end up seeing that we’ve ramped the CPU far more frequently or, far more quickly, to the exact amount of perform it needs to make sure that we hit that deadline and don’t drop frames.<br>This has caused a really great improvement across many different scrolling scenarios around iOS.<br>一旦改变发生了，负载从这里开始，我们最终会发现我们增加了CPU的频率，或者更快，达到了它需要的确切执行量，以确保我们达到了最后期限，不会掉帧。</p>
<p>So all of your applications will get all of this enhancements, both of them and a number of others, for free with no additional work on your part, but there are a couple of things that you can do to make sure that you get the most out of both of them.<br>这在许多不同的iOS滚动场景中都带来了很大的改进。所以你所有的应用程序将得到所有这些改进,他们和许多其他人,免费,没有额外的工作在你的部分,但也有几件事你可以做,以确保你得到的。</p>
<p>So first of all, if you haven’t already adopted that tableView cell prefetching API or the Collection View one, definitely look into that because having your data ready is one of the best things you can do to make sure that loading cells is as quick as possible.<br>首先，如果你还没有采用tableView单元格预抓取API或者集合视图，一定要注意这一点因为准备好数据是确保加载单元格尽可能快的最好方法之一。</p>
<p>Of course, it’s also important that you profile your full critical sections of your cell loading and reduce that demand as much as you can.<br>当然，重要的是你要对单元格负载的所有关键部分进行分析，并尽可能减少需求。</p>
<p>iOS 12 will now try to match the CPU performance to the needs of your application during this period but the best thing that you can do will always remain to reduce the amount of work that you have to do to make sure that you give your customers a really smooth scrolling experience.<br>iOS 12现在将尝试匹配CPU性能的应用程序的需要在这段时间,但你能做的最好的事情将永远是减少你的工作量,确保你给你的客户一个非常平滑滚动体验。</p>
<p>So that’s scrolling in iOS 12.<br>这是ios12中的滚动。</p>
<p>Next, let’s turn our attention to our next performance topic: memory.<br>接下来，让我们将注意力转向下一个性能主题:内存。</p>
<p>Now, you might wonder why memory is showing up right here in the middle of a performance discussion, but I assure you that that actually makes a lot of sense and, in fact, the reason is because memory really is performance.<br>现在，你可能想知道为什么内存会出现在性能讨论的中间，但我向你保证，这是很有意义的，事实上，原因是内存真的是性能。</p>
<p>The more memory that your app is going to use, the more that it will have an impact on the performance of your application.<br>So to understand why, let’s take a look at a really high-level overview of what the overall memory on the system might look like in a common situation.<br>应用程序使用的内存越多，它对应用程序性能的影响就越大。</p>
<p>So, of course, you can see here, a lot of the system’s memory is being used by other applications and the system itself.<br>Your app is using some amount for the moment.<br>当然，你可以在这里看到，很多系统内存被其他应用程序和系统本身使用。您的应用程序目前正在使用一些数量。</p>
<p>And there’s some that’s being kept free to service new allocation requests as they come in.<br>有一些是免费的，可以为新的分配请求提供服务。</p>
<p>Now, most of that memory is probably not truly free.<br>现在，大部分的记忆可能并不是真正自由的。</p>
<p>It’s likely including things like caches or other things that can be quickly thrown away to make sure that the memory is available to satisfy demand right away but in general it’s probably actually being used for something, but it is readily available.<br>它可能包括缓存或其他可以快速丢弃的东西，以确保内存能够立即满足需求，但一般来说，它可能实际上是用于某些东西，但它是现成可用的。</p>
<p>So let’s look at what happens when your application requests some memory.<br>让我们看看应用程序请求内存时会发生什么。</p>
<p>Maybe you’ll make a small request, something that can be satisfied by the amount that’s currently available in that free pool.<br>Well, if that’s the case, it’ll be return right away to your app and you can continue on with your work.<br>也许你会提出一个小的请求，这个请求可以通过当前在空闲池中可用的数量来满足。</p>
<p>Now, let’s say, though, that your application makes a larger request, and maybe it doesn’t need it for a long period of time, so you might not be real worried about it.<br>现在，假设，你的应用程序提出了一个更大的请求，也许它在很长一段时间内都不需要它，所以你可能并不担心它。</p>
<p>Perhaps you’re just going to load an image off disc and decompress it, perform some quick operation on some of the pixels and then throw it away.<br>也许你只是想从磁盘上加载一个图像，然后解压，对一些像素执行一些快速操作，然后把它扔掉。</p>
<p>So it seems like a quick operation that you don’t have to worry too much about.<br>所以这看起来是一个快速的手术，你不用太担心。</p>
<p>Well, we’ll make that big request and now that is more memory that is currently easily readily available to the system.<br>好了，我们会做一个大的请求现在这是更多的内存现在系统很容易就能得到。</p>
<p>So it won’t be able to satisfy it immediately and we’ll have to go find that memory from somewhere else.<br>所以它不能立即满足它我们必须从别处找到那个记忆。</p>
<p>And, in fact, the most likely place to come from is from other applications or things on the system.<br>实际上，最有可能来自于系统上的其他应用程序或东西。</p>
<p>Now, that might not worry you too much because you’re trying to get the memory for your app right now, so you’re not so worried about what’s happening elsewhere.<br>这可能不会让你太担心因为你现在正在为你的应用程序获取内存，所以你不太担心其他地方发生的事情。</p>
<p>But, of course, this will have an impact on something else later that your customers will be expecting will be working, but more importantly to you right now, it will have an impact on your app as well because the system has to do work to go get this memory for you.<br>但是,当然,这也会影响别的东西以后,你的客户会期待会工作,但更重要的是现在,它会影响你的应用程序因为系统要做的工作去得到这个记忆。</p>
<p>The fact that it’s not readily available means that the kernel has to go find it and perform operations on the CPU in order to make it available.<br>它不可用的事实意味着内核必须找到它并在CPU上执行操作，以使它可用。</p>
<p>And that time it’s spending getting that memory for you is time that could be better spent doing whatever your app does best.<br>So finding ways to either chunk these larger requests or just reduce those overall peak demands can actually have both a big impact on the performance of your app while you’re using it and also improve the customer experience across other apps later.<br>So there’s many ways that you can reduce the total memory usage of your apps and starting with a profile and instruments is a great way to look at that.<br>花在内存上的时间可以用来做应用程序最擅长的事情。因此，想办法将这些更大的请求集中起来，或者只是减少这些总峰值需求，实际上会对你的应用程序的性能产生很大的影响，同时还能提高其他应用程序的用户体验。<br>所以有很多方法可以减少应用程序的总内存使用量从个人资料和设备开始是一个很好的方法。</p>
<p>But for this morning, we’re just going to take a look at one new technique that iOS 12 brings along that helps reduce the memory usage of your apps and that’s Automatic Backing Stores.<br>但今天早上，我们要看一看iOS 12带来的一项新技术它可以帮助你减少应用的内存使用，那就是自动备份存储。</p>
<p>So let’s say we want to draw this lazy prairie dog in portrait mode on an iPhone X.<br>假设我们想在iPhone X上画这只懒土拨鼠的肖像模式。</p>
<p>Now, how big is that going to be? Portrait mode on iPhone X, 375 points wide and, to preserve our aspect ratio, it’ll be 250 points tall.<br>现在，它有多大?iPhone X上的竖屏模式，宽度375分，为了保持高宽比，它会是250分。</p>
<p>So how much memory will that use? Well, 375 by 250 at 3x, with 64 bits per pixel because this is a deep color device, is going to be 2.<br>那么这将使用多少内存呢?375乘250,3x，每像素64位因为这是一个深颜色设备，是2。</p>
<p>2 megabytes of memory to draw a prairie dog.<br>2兆的内存来画一只土拨鼠。</p>
<p>That seems like a pretty decent amount, but in this case that’s actually probably memory well spent.<br>这似乎是一个相当不错的数字，但在这种情况下，这实际上可能是很好的内存使用。</p>
<p>We’re actually trying to represent this full-fidelity image and that’s the amount of memory that’s needed to draw it into this buffer.<br>我们实际上是在尝试表示这个完全保真的图像这就是将它绘制到这个缓冲区所需要的内存量。</p>
<p>So that’s probably expected.<br>这是可能的预期。</p>
<p>But now let’s say that we were going to draw a lower-fidelity version of our prairie dog, maybe something in black and white that we were going to sketch out with core graphics, maybe it was drawn with an Apple pencil on an iPad.<br>但现在假设我们要画一个低保真版本的草原土拨鼠，也许是一些黑白的东西我们要用核心图形画出来，也许是用iPad上的苹果铅笔画的。</p>
<p>That might look something like this.<br>看起来像这样。</p>
<p>So how much memory is our low-fidelity prairie dog going to use? Well, it’ll actually use the exact same amount of memory.<br>Now here, that clearly is not as good of a use of memory.<br>那么我们的低保真度草原土拨鼠将会使用多少内存呢?它实际上会使用相同的内存。<br>在这里，这显然不是对记忆的有效利用。</p>
<p>It’s all grayscale.<br>这都是灰度。</p>
<p>All of that deep color information is not even being used in this image.<br>所有的深颜色信息甚至没有在这张图片中使用。</p>
<p>So hopefully we could do much better and iOS 12 introduces automatic backing store support to help make that exactly be the case.<br>希望我们能做得更好iOS 12引入了自动备份存储支持来帮助实现这一点。</p>
<p>So all of your views now that implement draw Rect will have their backing stores defined by the depth of the content being drawn into them.<br>因此，现在所有实现draw Rect的视图都将有它们的备份存储，这些存储存储是根据被绘制到它们中的内容的深度来定义的。</p>
<p>So in this case where we’re using Core Graphics to sketch out only grayscale content will actually automatically use an 8-bit per pixel backing store instead of a 64-bit per pixel one.<br>所以在这种情况下，我们使用Core Graphics来绘制灰度内容实际上会自动地使用8位/像素的备份存储而不是64位/像素的存储。</p>
<p>This reduces the memory demand for that drawn view by an order of magnitude down to 275 kilobytes from 2.<br>2 megabytes.<br>这将把绘制视图的内存需求从2减少到275千字节。<br>2字节。</p>
<p>That’s a really big improvement across many different applications, both yours and ours.<br>这在许多不同的应用程序中都是一个很大的改进，包括您和我们的应用程序。</p>
<p>So Automatic Backing Stores are enabled by default for all apps built with the iOS 12 SDK.<br>因此，默认情况下，所有iOS 12 SDK构建的应用程序都支持自动备份存储。</p>
<p>All implementations of draw Rect on UIView will have this happen automatically as well as all content that you draw with UI Graphics Image Renderer into offscreen bitmaps.<br>UIView上的draw Rect的所有实现都会自动实现，以及你用UI图形图像渲染器在屏幕外位图中绘制的所有内容。</p>
<p>Now in the case of UI Graphics Image Renderer, we don’t necessarily know what you’re planning on doing with the image that you get out at the end.<br>在UI图形图像渲染器的情况下，我们并不知道你打算如何处理你最后得到的图像。</p>
<p>So in cases where you actually know that the automatic behavior is not what you want, from Image Renderer, you can specify the specific backing store style that you want, for example using the new Range API to specify specifically that you want an extended-range image.<br>因此，在您实际上知道自动行为不是您想要的情况下，从图像呈现程序，您可以指定您想要的特定的备份存储样式，例如使用新的Range API来指定您想要的扩展范围映像。</p>
<p>Now you can learn all about this and many more techniques around UI Image in the Images and Graphics Best Practices Session later this week.<br>现在你可以在本周晚些时候的图像和图形最佳实践部分学习关于UI图像的所有知识和更多技术。</p>
<p>So that’s our second top for performance.<br>这是我们的第二名。</p>
<p>Next, let’s move on to Auto Layout.<br>接下来，让我们继续讨论自动布局。</p>
<p>Now Auto Layout in iOS 10 has some really great improvements.<br>The team has been working incredibly hard to optimize Auto Layout for your apps as much as possible.<br>So you’ll find that Auto Layout is now faster by default in iOS 12.<br>We’ll talk about a number of ways that’s the case.<br>But while they were profiling and optimizing Auto Layout, they also were looking across the system at many of our own apps and how they were using Auto Layout and they found a number of cases where there were some common pitfalls that different apps were falling in to.<br>So we’ll show you some of the simple best practices that you can follow in order to optimize your app layout as well.<br>So this morning, though, let’s look at how Auto Layout is faster by default in iOS 12 by looking at the asymptotic behavior of Auto Layout as we add more views in some common user scenarios.<br>Now, we’re looking at the asymptotics because we really want to look at what happens as we dramatically increase the number of views.<br>This can really make performance issues show up quickly when we go to a really like absurdly large number of views.<br>That just helps us see it though.<br>The optimizations really do apply and make things faster even for small numbers of views.<br>So let’s start with a really common pattern, the simplest case really, Independent Sibling Views inside of some container.<br>Now, these views are positioned with constraints against the container or other views but not against each other.<br>They’re independent of one another.<br>Now in iOS 11, the cost of these independent siblings, as you continue to add more, grew linearly.<br>So that’s actually pretty great.<br>That’s exactly what you’d expect for a situation like this.<br>Basically, what we’re saying is that there’s a fixed constant cost for each additional new view that you added into your hierarchy that was positioned independent of those other views.<br>Now because that was already growing with the exponentials that we expected, that remains the case in iOS 12; however, the team has worked really hard to reduce that constant cost to make additional views as cheap to add as possible.<br>So let’s look at a more interesting example next.<br>And in this case, we’re going to take a look at Dependent Siblings.<br>So this is the case where you have multiple child views and they’re now, they have constraints between each other.<br>So their layout is dependent on one another.<br>Now, unfortunately, in iOS 11, you’ll find that the asymptotics here weren’t quite as nice.<br>In fact, it was growing exponentially.<br>So the more views that you added, the surprisingly larger cost you would find as you added additional ones.<br>Now, the team worked really hard to identify the source of this exponential growth and fixed the algorithm so that is no longer the case.<br>So on iOS 12, these now grow linearly.<br>And, of course, the team’s also been working to reduce those constant costs for these cases as well.<br>Now in addition to dependent siblings, there’s another common type of layout that you’ll find and that’s Nested Views, when one view is inside of another and there’s constraints out to those outer ones.<br>This is obviously also a pretty common pattern in your apps and, unfortunately, here as well in iOS 11, we found some exponential growth.<br>And again, great news.<br>The team has also made this linear in iOS 12 as well.<br>So there’s a number of really great improvements across Auto Layout in iOS 12 and you’ll see these improvements in your apps as soon as you start running them on iOS 12 yourselves.<br>To learn more about all of that, get a better sense, develop a good sense of how to get some gut feel for the performance of different layouts and here are some of these topics I was talking about that are common pitfalls.<br>Definitely check out the High Performance Auto Layout talk later this week.<br>So for our final framework update topic, let’s turn to Swiftification.<br>As you heard, iOS 12 introduces Swift 4.<br>2.<br>And for Swift 4.<br>2 we really wanted to make sure that UIKit had a really great feel when used in Swift across your app, especially where it interacted with other Swift Standard Library or places that Swift had common patterns.<br>So, we audited all of UIKit and made sure that everything feels like it fits really naturally.<br>Even better, we made sure that all of the changes that we made to UIKit are all automatically migratable so there’s no additional work that you should have to do in order to get these updates.<br>Now, these updates fall into really three categories that we’ll talk about this morning, although there’s actually a ton of improvements and consistency improvements that you’ll find as you look at the SDK.<br>But today we’ll talk about nesting of types, constants, and functions.<br>So let’s first look at nesting types.<br>Now in Swift 4, there were a number of types that were in the global name space, things like UI Application State.<br>For types like this that have a really strong use along with another class, we’ve now nested them within this class.<br>So we looked at all the enumerations and other global types of this sort and now have moved them to be child types of the relevant class.<br>So this becomes UIApplication.<br>State.<br>This sends a much stronger message about the relationship between these two and makes them easier to find as well.<br>Now in comes cases this can also help improve understandability and remove some confusion.<br>So in this case, let’s look at UI Tab Bar Item Positioning.<br>Now do you think that’s UITabBarItemPositioning or UITabBarItem Positioning? It could actually be either.<br>Those are both classes.<br>And in Swift 42, it is now perfectly clear that it is, in fact, UITabBar ItemPositioning.<br>So in addition to nested types, we’ve also nested a bunch of constants.<br>So if we look here at Swift 4, we had NS notifications were all in the global NSNotification.<br>Name namespace and their associated user info keys were actually just global constants that were floating out there.<br>So for consistency with AppKit and to make it easier to find and associate these types together, they’ve now all been nested under the class that they’re used with.<br>So something like did Change Status Bar Orientation is now under UI Application did Change Status Bar Orientation Notification and its user info key moved along with it so that they’re all co-located.<br>Now we’ve also audited all of the other global constants all throughout UIKit and nested all of them in appropriate places.<br>So things like UI Float Range Zero and UI Float Range Infinite have not just become properties on UI Float Range so they’re both easy to find and easier to use.<br>In places to take a UI Float Range, you can now just type .<br>zero or .<br>infinite and, in fact, because they’re now properties, Xcode can suggest them as auto-completions for you in places where they make sense.<br>Now in addition to constants, we’ve also audited all of our global functions.<br>So things like UI Edge Inserts and UI Image had some global functions for operating on different types.<br>Now in Swift 4.<br>2, these had become methods on the appropriate type.<br>So it’s now really easy to inset Rect or get png Data from an image in a really natural Swift feeling way.<br>Now, here was one other big class of functions that I want to mention this morning and that was all of these string conversion functions for all of the many types in UIKit, CGPoint, CGRect, CGSize, CGVector, all of them, there’s quite a lot, both to and from strings.<br>Now, when we looked at these and tried to decide where they should go, we realized that they actually have two different use cases.<br>One is for encoding and decoding.<br>But the other is that they’re commonly used to print things when you’re just trying to get some debug descriptions.<br>And those are two very different uses but, in fact, Swift has first-class support for both of those cases.<br>And so we’ve made sure that all of these types will work really great with Swift’s built-in support for both.<br>So in Swift 4.<br>2, all of these types will conform to Codable so that you can very easily do things such as encode and decode JSON for all of these different types.<br>Of course, debug printing in Swift is actually even easier than in Objective-C because you don’t have to do any additional conversion.<br>The built-in introspection of the types can allow you to print them directly.<br>So in Swift 4.<br>2, you just actually pass these types directly to your print functions if you want to print them out for debug purposes or log them.<br>And then finally, you may already have some existing code that was using the behavior of the old string conversion functions and need a compatible functionality going forward.<br>And so for that we’ve actually just renamed all of these and moved them to be properties on NSCoder.<br>This really helps to emphasize the fact that the intent of these methods was to be used for encoding and decoding, so it’s a pretty natural fit for them to go over there.<br>So these are just a few of the consistency improvements that you’ll find across the iOS 12 SDK for Swift 4.<br>2 but you’ll find many more as well.<br>Now speaking of encoding and decoding, NS Secure Coding, in iOS 12 there are now new secure by default encoding and decoding APIs.<br>Adopting NS Secure Coding for all of your encoding needs on NS Keyed Archiver is really key to ensuring that you’re protecting your customers from both malicious and corrupted data.<br>You’ll also find that the older insecure APIs are not deprecated.<br>So you can learn all about that and get much more detail on it in the Data You Can Trust Session on Thursday at 9:00 a.<br>m.<br>And that’s framework updates.<br>Next, let’s turn our attention to some enhancements to a number of existing APIs and we’ll start with notifications.<br>Notifications has a number of really great improvements in iOS 12 but we’re going to focus on just three this morning.<br>Interaction within custom notifications, grouping of notifications, and access to your notification settings within your own apps.<br>So let’s start with interaction.<br>Now custom notifications have for a while now allowed you to define a predefined set of actions for those notifications.<br>In iOS 12, this set of actions is now no longer static.<br>It can be defined programmatically and you can change them at runtime.<br>In addition to these actions, and even better than that, the notifications themselves can now be made interactive.<br>So for example, here, you can see Messages is now allowing you to reply quickly to a message inline directly in that notification.<br>Now in addition to interaction, iOS 12 now includes grouping of notifications by default and the default behavior will be to group all the notifications for a particular app into a single group.<br>But, of course, your app may have custom needs to have more granular groupings so something like iMessage will group all of the messages from a particular conversation together and separate from all the rest of the notifications for that app.<br>Now you can adopt this in your app as well by just tagging your notifications with a particular thread identifier and then all the notifications for that threat identifier will appear in a single group.<br>Now the UI updates for notifications in iOS 12 also include some new ability for users to customize the delivery behavior of their notifications.<br>But, of course, your apps may also include some existing, more granular controls for notification management within your apps as well.<br>And iOS 12 introduces a new API that makes it easy for your customers to get directly deep linked into your notification settings UI exactly when they’re looking for those more granular controls.<br>So you can learn more about all of these notification things in What’s New in User Notifications and Using Grouped Notifications later this week.<br>That’s notifications.<br>Next, let’s talk about messages.<br>Now messages in iOS 12 includes some really new and exciting features in the camera.<br>And you can bring all of your iMessage stickers directly into the camera as well.<br>If you’re using the Xcode sticker template, this will work automatically by default with no additional work on your behalf.<br>But if you’re building a more custom sticker experience using the MS Messages App View Controller, some small amount of adoption is required.<br>Now there’s a new MS Messages Supported Presentation Contexts API that you can add into your user info plist and then specify that you want to appear both in the messages context and the media context.<br>Once you’ve done that, your apps will appear both in the App Strip and also within the camera.<br>Now if at runtime you need to figure out which context you’re in so that for example you want to customize the display of your stickers a little bit, there’s a new API for that as well.<br>By checking the presentation context, you can quickly see whether you’re in messages or in the camera.<br>Now in addition to these features, iOS 12 also brings a new access for interaction to your messages apps.<br>In compact mode, previously swiping horizontally down in your messages app would switch between apps.<br>In iOS 12, these horizontal swipes and interactions that move horizontally are now available for us by your apps directly so they’ll interact with your apps rather than switching to a different app.<br>And that’s Messages.<br>Next, let’s talk about automatic passwords and security code autofill.<br>Now iOS 11 introduced automatic passwords or password entry into your apps.<br>And in iOS 12, we’re taking these a whole step further.<br>But let’s go back to the beginning for a minute and talk about the entire experience.<br>So for users that have passwords stored in iCloud Keychain, since iOS 11 it’s now been possible to have those automatically get populated into your app in your login flows.<br>Now in iOS 12, these passwords can also be stored into iCloud Keychain from your apps both from your login window flows and also from your password change request UIs.<br>As soon as a user logs in, they’ll be prompted to save the password to iCloud Keychain.<br>Now even better, iOS 12 can automatically generate passwords in your new account flows and in your password change flows.<br>Adopting this is really easy.<br>You just make sure that you’ve tagged your password fields with either the password text content type, if it’s a login field, or the new password text content type if it’s either a new account or password change field.<br>If your services have a specific requirement on passwords for example if they got required or disallowed characters or if they have other requirements such as maximum number of consecutive repeated characters, you can specify these requirements as well to make sure that the automatically generated passwords are fully compatible with all of your requirements.<br>Now, the final bit of friction during some of your login experiences is when you have to take that two-factor authentication code, get it out of a text message and into your apps.<br>IOS 12 makes this really easy by automatically identifying these notifications, noting the security code in them, and suggesting it right in the Quick Type candidate bar so that it’s really easy to get it right into your app.<br>Now the only thing you have to do to make sure this works in your app is to be sure that you’re using standard iOS text interaction APIs in order to accept these passcodes.<br>With all of these new features, iOS 12 is enabling a much more secure future with unique, strong passwords used for every service that you never have to memorize or type ever again.<br>You can learn all about this in the Automatic Strong Passwords and Security Code Autofill Session later this week.<br>Now, our final API enhancement topic is actually a bit of a review but now with a little bit more context.<br>So in iOS 11, we introduced Safe Area insets.<br>Safe Area insets are a really great way to make sure that your content is avoiding any overlap from other parts of the user interface such as bars on the top and bottom of the screen.<br>This is really great on iPhones where bars are pretty straightforward, but it’s really powerful as well.<br>Safe Area insets give you that safe area coordinate in the local coordinate space of any view in your application, so it scales even the much more complex interfaces, things like iPad Split View which has different height bars on the master and detail side of the Split View.<br>The Safe Area insets in any view underneath these bars will be appropriate for the amount that they’re overlapped by the bar on their side of the split.<br>So this is really great on devices with rectangular screens but it also is really powerful on devices that have non-rectangular screens like iPhone X.<br>Now, you can see here we’ve got our larger bars at the top and bottom than we have on devices that have home buttons.<br>And the Safe Area insets obviously have just grown to accommodate that larger size.<br>Now, unique to iPhone X is that there are Safe Area insets even in cases where no bars are present and this extends the landscape mode too where it can really help you make sure that you’ve got a rectangular area at all times that’s safe to display content and will never be clipped.<br>So I want to thank you all for those of you who have adopted Safe Area insets and updated your apps for iPhone X.<br>It’s been a really great experience over the last year and I’m sure most of you have already done that.<br>If you haven’t, now is a really great time to do so.<br>Your customers will always prefer apps that are being kept up to date and support for iPhone X is a really visible indicator of that being the case.<br>So if you haven’t, definitely go do it now.<br>And to help make sure you have all the information necessary to do that, you can check out the UIKit Apps for Every Size and Shape Session later this week which will tell you both all about Safe Area insets and all of the other related inset APIs all throughout UIKit making it easy to make sure you have apps that scale to every shape and size.<br>So that’s our framework updates and our API enhancements.<br>Next, let’s talk about Siri Shortcuts.<br>So Siri Shortcuts is an exciting new API in iOS 12.<br>Siri Shortcuts makes it easy to get common actions out of your app and make them accessible via Siri.<br>Now, Siri Shortcuts can be suggested proactively right on the coversheet making it easy to access actions that you would want to access at the exact time and place that you want to access them.<br>Even better, they can also be suggested right on the Siri watch face on Apple Watch.<br>Now not only are Siri actions suggested proactively but they can also be set up to be executed using a custom voice phrase.<br>Now, adding Siri Action Support to your apps is really easy.<br>You can use two APIs.<br>There’s NS User Activity, which you may already be using for support for Handoff and Spotlight integration, and there’s also support for Siri Intents for more complex scenarios where you have more custom interactions.<br>So let’s look first at NS User Activity.<br>Now as I mentioned, NS User Activity is a common API with Handoff and Spotlight and this could be a really great API to use if your Siri Shortcuts should get your customers back to a specific place in your app, for example loading a particular message or document, the same as you would do if you were trying to hand that off to another device.<br>If you’re already doing this, it’s really easy to add support for Siri Shortcuts.<br>You just set Eligible for Prediction to true.<br>And if you’re not, this may still be a great way if your shortcut fits into one of these categories.<br>Now, if your app has other more custom needs or if you just want a lot more control, you can adopt the Siri Kit Intents API.<br>Now Siri Kit Intents provides a number of predefined intents that you can easily adopt on your own.<br>These are the same as the Siri Kit Intents in previous years.<br>Now if your apps have more custom behaviors, though, you can now in iOS 12 define your own custom intents.<br>Custom intents can be really flexible and they do anything that you would want.<br>In this case here, I’ve created one to help me create my WWDC slides next year.<br>Now the categories that you could put your intents in to are pretty broad already.<br>So here I’ve used the Create category.<br>But if your intents are even more generic than that, there are even more general ones available such as General Do, Run, and Go options.<br>Now once you’ve created your intent, you also want to make it really easy for your customers to create these custom shortcuts to get to them.<br>And so there’s now an API from right within your app you can allow customers to create a custom voice shortcut.<br>So here I’ve got a button that will just bring up a new panel enabling me to create a new shortcut right within my app as soon as I finished an operation.<br>So if you’re doing something like ordering a coffee in the morning and you notice it’s something that might be done again, this is a great opportunity to offer to create a Siri Shortcut to do that next time.<br>Now even better, you can also combine these shortcuts together using the new Shortcuts app available from the app store.<br>So you can learn all about this and much more in the Introduction to Siri Shortcuts, Building for Voice Siri Shortcuts, and Siri Shortcuts on the Siri Watch Face Sessions later this week.<br>So we’ve talked a lot this morning about what’s new in iOS 12, but there are also a number of great sessions that are worth mentioning that aren’t necessarily about what’s new.<br>So if you’re new to creating apps for iOS, there’s a really great session you should check out called I have This Idea For an App.<br>So definitely check that out.<br>And if you already have an app, and are just looking to add more polish, there’s a couple other great sessions as well, A Tour of UI Collection View and Adding Delight to Your IOS App.<br>So thanks so much for coming out this morning to hear what’s new.<br>Look forward to seeing you in the labs and I hope you have a great week.<br>Thanks.</p>

            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/wiki/C语言语法/union定义/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    union定义(转载)
                
            </div>
        </a>
    
    
        <a href="/wiki/IOS/Runtime/神经病院Objective-C-Runtime入院第一天——isa和Class/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">神经病院Objective-C Runtime入院第一天——isa和Class(转载)</div>
        </a>
    
</nav>





    
    
        <section id="comments"> 
    <div class="ds-thread" data-thread-key="wiki/WWDC/union定义的副本/" data-title="union定义(转载)" data-url="http://yoursite.com/wiki/WWDC/union定义的副本/"></div>
    <style>
        #ds-thread #ds-reset .ds-textarea-wrapper {
            background: none;
        }
        #ds-reset .ds-avatar img {
            box-shadow: none;
        }
        #ds-reset .ds-gradient-bg {
            background: #f7f7f7;
        }
        #ds-thread #ds-reset li.ds-tab a {
            border-radius: 3px;
        }
        #ds-thread #ds-reset .ds-post-button {
            color: white;
            border: none;
            box-shadow: none;
            background: #d32;
            text-shadow: none;
            font-weight: normal;
            font-family: 'Microsoft Yahei';
        }
        #ds-thread #ds-reset .ds-post-button:hover {
            color: white;
            background: #DE594C;
        }
        #ds-thread #ds-reset .ds-post-button:active {
            background: #d32;
        }
        #ds-smilies-tooltip ul.ds-smilies-tabs li a.ds-current {
            color: white;
            background: #d32;
            box-shadow: none;
            text-shadow: none;
            font-weight: normal;
        }
    </style>
 </section>
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            LJ &copy; 2018 
            <a rel="external nofollow noopener noreferrer" href="http://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a href="https://github.com/zthxxx/hexo-theme-Wikitten" rel="external nofollow noopener noreferrer" target="_blank">wikitten</a>
        </div>
    </div>
</footer>
        
    
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'lijian'};
    (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
    || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>



    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
